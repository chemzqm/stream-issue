‹Í`†∂#ifndef USE_LIBSQLITE3ŸO/******************************************************************************ŸK** This file is an amalgamation of many separate C source files from SQLiteŸJ** version 3.23.1.  By combining all the individual C code files into thisŸM** single large file, the entire code can be compiled as a single translationŸJ** unit.  This allows many compilers to do optimizations that would not beŸL** possible if the files were compiled separately.  Performance improvementsŸF** of 5% or more are commonly seen when SQLite is compiled as a single¥** translation unit.¢**ŸG** This file is all you need to compile SQLite.  To use SQLite in otherŸL** programs, you need this file and the "sqlite3.h" header file that definesŸH** the programming interface to the SQLite library.  (If you do not haveŸL** the "sqlite3.h" header file at hand, you will find a copy embedded withinŸN** the text of this file.  Search for "Begin file sqlite3.h" to find the startŸN** of the embedded sqlite3.h header file.) Additional code files may be neededŸL** if you want a wrapper to interface SQLite with your choice of programmingŸG** language. The code for the "sqlite3" command-line shell is also in aŸK** separate file. This file contains only code for the core SQLite library.¢*/µ#define SQLITE_CORE 1Ω#define SQLITE_AMALGAMATION 1∂#ifndef SQLITE_PRIVATEæ# define SQLITE_PRIVATE static¶#endifŸO/************** Begin file ctime.c *******************************************/¢/*≥** 2010 February 23¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸI** This file implements routines used to report what compile-time optionsπ** SQLite was built with.¢*/†Ÿ'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS†¢/*ŸL** Include the configuration header output by 'configure' if we're using the∑** autoconf-based build¢*/Ÿ>#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)≥#include "config.h"∏#define SQLITECONFIG_H 1¶#endif†ŸC/* These macros are provided to "stringify" the value of the defineŸ9** for those options in which the value is meaningful. */ø#define CTIMEOPT_VAL_(opt) #optŸ,#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)†¢/*ŸE** An array of names of all compile-time options.  This array should ±** be sorted A-Z.¢**ŸF** This array looks large, but in a typical installation actually usesŸN** only a handful of compile-time options, so most times this array is usuallyŸ-** rather short and uses little memory space.¢*/Ÿ3static const char * const sqlite3azCompileOpt[] = {†£/* Ÿ,** BEGIN CODE GENERATED BY tool/mkctime.tcl ¢*/∂#if SQLITE_32BIT_ROWID∞  "32BIT_ROWID",¶#endifŸ #if SQLITE_4_BYTE_ALIGNED_MALLOC∫  "4_BYTE_ALIGNED_MALLOC",¶#endif∂#if SQLITE_64BIT_STATS∞  "64BIT_STATS",¶#endifŸ$#if SQLITE_ALLOW_COVERING_INDEX_SCANæ  "ALLOW_COVERING_INDEX_SCAN",¶#endifæ#if SQLITE_ALLOW_URI_AUTHORITY∏  "ALLOW_URI_AUTHORITY",¶#endif∫#ifdef SQLITE_BITMASK_TYPEŸ4  "BITMASK_TYPE=" CTIMEOPT_VAL(SQLITE_BITMASK_TYPE),¶#endifŸ"#if SQLITE_BUG_COMPATIBLE_20160819º  "BUG_COMPATIBLE_20160819",¶#endifæ#if SQLITE_CASE_SENSITIVE_LIKE∏  "CASE_SENSITIVE_LIKE",¶#endif∂#if SQLITE_CHECK_PAGES∞  "CHECK_PAGES",¶#endifŸ2#if defined(__clang__) && defined(__clang_major__)Ÿ5  "COMPILER=clang-" CTIMEOPT_VAL(__clang_major__) "."Ÿ5                    CTIMEOPT_VAL(__clang_minor__) "."Ÿ7                    CTIMEOPT_VAL(__clang_patchlevel__),∑#elif defined(_MSC_VER)Ÿ*  "COMPILER=msvc-" CTIMEOPT_VAL(_MSC_VER),Ÿ/#elif defined(__GNUC__) && defined(__VERSION__)æ  "COMPILER=gcc-" __VERSION__,¶#endif∏#if SQLITE_COVERAGE_TEST≤  "COVERAGE_TEST",¶#endif∞#if SQLITE_DEBUG™  "DEBUG",¶#endifŸ"#if SQLITE_DEFAULT_AUTOMATIC_INDEXº  "DEFAULT_AUTOMATIC_INDEX",¶#endifΩ#if SQLITE_DEFAULT_AUTOVACUUM∑  "DEFAULT_AUTOVACUUM",¶#endifŸ #ifdef SQLITE_DEFAULT_CACHE_SIZEŸ@  "DEFAULT_CACHE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_CACHE_SIZE),¶#endifŸ #if SQLITE_DEFAULT_CKPTFULLFSYNC∫  "DEFAULT_CKPTFULLFSYNC",¶#endifŸ!#ifdef SQLITE_DEFAULT_FILE_FORMATŸB  "DEFAULT_FILE_FORMAT=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_FORMAT),¶#endifŸ&#ifdef SQLITE_DEFAULT_FILE_PERMISSIONSŸL  "DEFAULT_FILE_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_PERMISSIONS),¶#endifø#if SQLITE_DEFAULT_FOREIGN_KEYSπ  "DEFAULT_FOREIGN_KEYS",¶#endifŸ(#ifdef SQLITE_DEFAULT_JOURNAL_SIZE_LIMITŸP  "DEFAULT_JOURNAL_SIZE_LIMIT=" CTIMEOPT_VAL(SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT),¶#endifŸ"#ifdef SQLITE_DEFAULT_LOCKING_MODEŸD  "DEFAULT_LOCKING_MODE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),¶#endifø#ifdef SQLITE_DEFAULT_LOOKASIDEŸ>  "DEFAULT_LOOKASIDE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOOKASIDE),¶#endifº#if SQLITE_DEFAULT_MEMSTATUS∂  "DEFAULT_MEMSTATUS",¶#endifø#ifdef SQLITE_DEFAULT_MMAP_SIZEŸ>  "DEFAULT_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),¶#endifø#ifdef SQLITE_DEFAULT_PAGE_SIZEŸ>  "DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_PAGE_SIZE),¶#endifŸ##ifdef SQLITE_DEFAULT_PCACHE_INITSZŸF  "DEFAULT_PCACHE_INITSZ=" CTIMEOPT_VAL(SQLITE_DEFAULT_PCACHE_INITSZ),¶#endifŸ*#ifdef SQLITE_DEFAULT_PROXYDIR_PERMISSIONSŸT  "DEFAULT_PROXYDIR_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_PROXYDIR_PERMISSIONS),¶#endifŸ%#if SQLITE_DEFAULT_RECURSIVE_TRIGGERSø  "DEFAULT_RECURSIVE_TRIGGERS",¶#endifº#ifdef SQLITE_DEFAULT_ROWESTŸ8  "DEFAULT_ROWEST=" CTIMEOPT_VAL(SQLITE_DEFAULT_ROWEST),¶#endifŸ!#ifdef SQLITE_DEFAULT_SECTOR_SIZEŸB  "DEFAULT_SECTOR_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_SECTOR_SIZE),¶#endifŸ!#ifdef SQLITE_DEFAULT_SYNCHRONOUSŸB  "DEFAULT_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),¶#endifŸ(#ifdef SQLITE_DEFAULT_WAL_AUTOCHECKPOINTŸP  "DEFAULT_WAL_AUTOCHECKPOINT=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_AUTOCHECKPOINT),¶#endifŸ%#ifdef SQLITE_DEFAULT_WAL_SYNCHRONOUSŸJ  "DEFAULT_WAL_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),¶#endifŸ$#ifdef SQLITE_DEFAULT_WORKER_THREADSŸH  "DEFAULT_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WORKER_THREADS),¶#endifø#if SQLITE_DIRECT_OVERFLOW_READπ  "DIRECT_OVERFLOW_READ",¶#endif∫#if SQLITE_DISABLE_DIRSYNC¥  "DISABLE_DIRSYNC",¶#endifø#if SQLITE_DISABLE_FTS3_UNICODEπ  "DISABLE_FTS3_UNICODE",¶#endifŸ #if SQLITE_DISABLE_FTS4_DEFERRED∫  "DISABLE_FTS4_DEFERRED",¶#endifº#if SQLITE_DISABLE_INTRINSIC∂  "DISABLE_INTRINSIC",¶#endif∂#if SQLITE_DISABLE_LFS∞  "DISABLE_LFS",¶#endifŸ+#if SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATSŸ%  "DISABLE_PAGECACHE_OVERFLOW_STATS",¶#endifŸ%#if SQLITE_DISABLE_SKIPAHEAD_DISTINCTø  "DISABLE_SKIPAHEAD_DISTINCT",¶#endifæ#ifdef SQLITE_ENABLE_8_3_NAMESŸ<  "ENABLE_8_3_NAMES=" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),¶#endifª#if SQLITE_ENABLE_API_ARMORµ  "ENABLE_API_ARMOR",¶#endifæ#if SQLITE_ENABLE_ATOMIC_WRITE∏  "ENABLE_ATOMIC_WRITE",¶#endifŸ$#if SQLITE_ENABLE_BATCH_ATOMIC_WRITEæ  "ENABLE_BATCH_ATOMIC_WRITE",¶#endif∑#if SQLITE_ENABLE_CERODŸ4  "ENABLE_CEROD=" CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),¶#endifŸ!#if SQLITE_ENABLE_COLUMN_METADATAª  "ENABLE_COLUMN_METADATA",¶#endifŸ"#if SQLITE_ENABLE_COLUMN_USED_MASKº  "ENABLE_COLUMN_USED_MASK",¶#endif∫#if SQLITE_ENABLE_COSTMULT¥  "ENABLE_COSTMULT",¶#endifæ#if SQLITE_ENABLE_CURSOR_HINTS∏  "ENABLE_CURSOR_HINTS",¶#endifΩ#if SQLITE_ENABLE_DBSTAT_VTAB∑  "ENABLE_DBSTAT_VTAB",¶#endifŸ"#if SQLITE_ENABLE_EXPENSIVE_ASSERTº  "ENABLE_EXPENSIVE_ASSERT",¶#endif∂#if SQLITE_ENABLE_FTS1∞  "ENABLE_FTS1",¶#endif∂#if SQLITE_ENABLE_FTS2∞  "ENABLE_FTS2",¶#endif∂#if SQLITE_ENABLE_FTS3∞  "ENABLE_FTS3",¶#endifŸ"#if SQLITE_ENABLE_FTS3_PARENTHESISº  "ENABLE_FTS3_PARENTHESIS",¶#endifŸ #if SQLITE_ENABLE_FTS3_TOKENIZER∫  "ENABLE_FTS3_TOKENIZER",¶#endif∂#if SQLITE_ENABLE_FTS4∞  "ENABLE_FTS4",¶#endif∂#if SQLITE_ENABLE_FTS5∞  "ENABLE_FTS5",¶#endifŸ #if SQLITE_ENABLE_HIDDEN_COLUMNS∫  "ENABLE_HIDDEN_COLUMNS",¶#endifµ#if SQLITE_ENABLE_ICUØ  "ENABLE_ICU",¶#endifπ#if SQLITE_ENABLE_IOTRACE≥  "ENABLE_IOTRACE",¶#endif∑#if SQLITE_ENABLE_JSON1±  "ENABLE_JSON1",¶#endifŸ #if SQLITE_ENABLE_LOAD_EXTENSION∫  "ENABLE_LOAD_EXTENSION",¶#endifŸ"#ifdef SQLITE_ENABLE_LOCKING_STYLEŸD  "ENABLE_LOCKING_STYLE=" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),¶#endifŸ##if SQLITE_ENABLE_MEMORY_MANAGEMENTΩ  "ENABLE_MEMORY_MANAGEMENT",¶#endifπ#if SQLITE_ENABLE_MEMSYS3≥  "ENABLE_MEMSYS3",¶#endifπ#if SQLITE_ENABLE_MEMSYS5≥  "ENABLE_MEMSYS5",¶#endifª#if SQLITE_ENABLE_MULTIPLEXµ  "ENABLE_MULTIPLEX",¶#endifª#if SQLITE_ENABLE_NULL_TRIMµ  "ENABLE_NULL_TRIM",¶#endifŸ%#if SQLITE_ENABLE_OVERSIZE_CELL_CHECKø  "ENABLE_OVERSIZE_CELL_CHECK",¶#endifŸ #if SQLITE_ENABLE_PREUPDATE_HOOK∫  "ENABLE_PREUPDATE_HOOK",¶#endif∂#if SQLITE_ENABLE_QPSG∞  "ENABLE_QPSG",¶#endifµ#if SQLITE_ENABLE_RBUØ  "ENABLE_RBU",¶#endif∑#if SQLITE_ENABLE_RTREE±  "ENABLE_RTREE",¶#endifΩ#if SQLITE_ENABLE_SELECTTRACE∑  "ENABLE_SELECTTRACE",¶#endifπ#if SQLITE_ENABLE_SESSION≥  "ENABLE_SESSION",¶#endif∫#if SQLITE_ENABLE_SNAPSHOT¥  "ENABLE_SNAPSHOT",¶#endif∏#if SQLITE_ENABLE_SQLLOG≤  "ENABLE_SQLLOG",¶#endifŸ #if defined(SQLITE_ENABLE_STAT4)±  "ENABLE_STAT4",Ÿ"#elif defined(SQLITE_ENABLE_STAT3)±  "ENABLE_STAT3",¶#endif∫#if SQLITE_ENABLE_STMTVTAB¥  "ENABLE_STMTVTAB",¶#endifŸ!#if SQLITE_ENABLE_STMT_SCANSTATUSª  "ENABLE_STMT_SCANSTATUS",¶#endifŸ&#if SQLITE_ENABLE_UNKNOWN_SQL_FUNCTIONŸ   "ENABLE_UNKNOWN_SQL_FUNCTION",¶#endifø#if SQLITE_ENABLE_UNLOCK_NOTIFYπ  "ENABLE_UNLOCK_NOTIFY",¶#endifŸ%#if SQLITE_ENABLE_UPDATE_DELETE_LIMITø  "ENABLE_UPDATE_DELETE_LIMIT",¶#endifæ#if SQLITE_ENABLE_URI_00_ERROR∏  "ENABLE_URI_00_ERROR",¶#endif∫#if SQLITE_ENABLE_VFSTRACE¥  "ENABLE_VFSTRACE",¶#endifº#if SQLITE_ENABLE_WHERETRACE∂  "ENABLE_WHERETRACE",¶#endif∏#if SQLITE_ENABLE_ZIPVFS≤  "ENABLE_ZIPVFS",¶#endifŸ!#if SQLITE_EXPLAIN_ESTIMATED_ROWSª  "EXPLAIN_ESTIMATED_ROWS",¶#endif∫#if SQLITE_EXTRA_IFNULLROW¥  "EXTRA_IFNULLROW",¶#endif∏#ifdef SQLITE_EXTRA_INITŸ0  "EXTRA_INIT=" CTIMEOPT_VAL(SQLITE_EXTRA_INIT),¶#endifº#ifdef SQLITE_EXTRA_SHUTDOWNŸ8  "EXTRA_SHUTDOWN=" CTIMEOPT_VAL(SQLITE_EXTRA_SHUTDOWN),¶#endifŸ!#ifdef SQLITE_FTS3_MAX_EXPR_DEPTHŸB  "FTS3_MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_FTS3_MAX_EXPR_DEPTH),¶#endifæ#if SQLITE_FTS5_ENABLE_TEST_MI∏  "FTS5_ENABLE_TEST_MI",¶#endifŸ #if SQLITE_FTS5_NO_WITHOUT_ROWID∫  "FTS5_NO_WITHOUT_ROWID",¶#endif¥#if SQLITE_HAS_CODECÆ  "HAS_CODEC",¶#endifŸ##if HAVE_ISNAN || SQLITE_HAVE_ISNANØ  "HAVE_ISNAN",¶#endifŸ$#if SQLITE_HOMEGROWN_RECURSIVE_MUTEXæ  "HOMEGROWN_RECURSIVE_MUTEX",¶#endifŸ!#if SQLITE_IGNORE_AFP_LOCK_ERRORSª  "IGNORE_AFP_LOCK_ERRORS",¶#endifŸ##if SQLITE_IGNORE_FLOCK_LOCK_ERRORSΩ  "IGNORE_FLOCK_LOCK_ERRORS",¶#endif∏#if SQLITE_INLINE_MEMCPY≤  "INLINE_MEMCPY",¶#endifµ#if SQLITE_INT64_TYPEØ  "INT64_TYPE",¶#endifŸ'#ifdef SQLITE_INTEGRITY_CHECK_ERROR_MAXŸN  "INTEGRITY_CHECK_ERROR_MAX=" CTIMEOPT_VAL(SQLITE_INTEGRITY_CHECK_ERROR_MAX),¶#endifŸ"#if SQLITE_LIKE_DOESNT_MATCH_BLOBSº  "LIKE_DOESNT_MATCH_BLOBS",¶#endifµ#if SQLITE_LOCK_TRACEØ  "LOCK_TRACE",¶#endif∫#if SQLITE_LOG_CACHE_SPILL¥  "LOG_CACHE_SPILL",¶#endifø#ifdef SQLITE_MALLOC_SOFT_LIMITŸ>  "MALLOC_SOFT_LIMIT=" CTIMEOPT_VAL(SQLITE_MALLOC_SOFT_LIMIT),¶#endif∫#ifdef SQLITE_MAX_ATTACHEDŸ4  "MAX_ATTACHED=" CTIMEOPT_VAL(SQLITE_MAX_ATTACHED),¶#endif∏#ifdef SQLITE_MAX_COLUMNŸ0  "MAX_COLUMN=" CTIMEOPT_VAL(SQLITE_MAX_COLUMN),¶#endifŸ!#ifdef SQLITE_MAX_COMPOUND_SELECTŸB  "MAX_COMPOUND_SELECT=" CTIMEOPT_VAL(SQLITE_MAX_COMPOUND_SELECT),¶#endifŸ##ifdef SQLITE_MAX_DEFAULT_PAGE_SIZEŸF  "MAX_DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_DEFAULT_PAGE_SIZE),¶#endifº#ifdef SQLITE_MAX_EXPR_DEPTHŸ8  "MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_EXPR_DEPTH),¶#endifæ#ifdef SQLITE_MAX_FUNCTION_ARGŸ<  "MAX_FUNCTION_ARG=" CTIMEOPT_VAL(SQLITE_MAX_FUNCTION_ARG),¶#endif∏#ifdef SQLITE_MAX_LENGTHŸ0  "MAX_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LENGTH),¶#endifŸ%#ifdef SQLITE_MAX_LIKE_PATTERN_LENGTHŸJ  "MAX_LIKE_PATTERN_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LIKE_PATTERN_LENGTH),¶#endif∏#ifdef SQLITE_MAX_MEMORYŸ0  "MAX_MEMORY=" CTIMEOPT_VAL(SQLITE_MAX_MEMORY),¶#endifª#ifdef SQLITE_MAX_MMAP_SIZEŸ6  "MAX_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),¶#endifº#ifdef SQLITE_MAX_MMAP_SIZE_Ÿ8  "MAX_MMAP_SIZE_=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE_),¶#endifº#ifdef SQLITE_MAX_PAGE_COUNTŸ8  "MAX_PAGE_COUNT=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_COUNT),¶#endifª#ifdef SQLITE_MAX_PAGE_SIZEŸ6  "MAX_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_SIZE),¶#endifæ#ifdef SQLITE_MAX_SCHEMA_RETRYŸ<  "MAX_SCHEMA_RETRY=" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),¶#endifº#ifdef SQLITE_MAX_SQL_LENGTHŸ8  "MAX_SQL_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_SQL_LENGTH),¶#endifø#ifdef SQLITE_MAX_TRIGGER_DEPTHŸ>  "MAX_TRIGGER_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_TRIGGER_DEPTH),¶#endifŸ!#ifdef SQLITE_MAX_VARIABLE_NUMBERŸB  "MAX_VARIABLE_NUMBER=" CTIMEOPT_VAL(SQLITE_MAX_VARIABLE_NUMBER),¶#endifπ#ifdef SQLITE_MAX_VDBE_OPŸ2  "MAX_VDBE_OP=" CTIMEOPT_VAL(SQLITE_MAX_VDBE_OP),¶#endifŸ #ifdef SQLITE_MAX_WORKER_THREADSŸ@  "MAX_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_MAX_WORKER_THREADS),¶#endif≥#if SQLITE_MEMDEBUG≠  "MEMDEBUG",¶#endifŸ##if SQLITE_MIXED_ENDIAN_64BIT_FLOATΩ  "MIXED_ENDIAN_64BIT_FLOAT",¶#endifπ#if SQLITE_MMAP_READWRITE≥  "MMAP_READWRITE",¶#endifµ#if SQLITE_MUTEX_NOOPØ  "MUTEX_NOOP",¶#endifµ#if SQLITE_MUTEX_NREFØ  "MUTEX_NREF",¶#endifµ#if SQLITE_MUTEX_OMITØ  "MUTEX_OMIT",¶#endifπ#if SQLITE_MUTEX_PTHREADS≥  "MUTEX_PTHREADS",¶#endif¥#if SQLITE_MUTEX_W32Æ  "MUTEX_W32",¶#endif∏#if SQLITE_NEED_ERR_NAME≤  "NEED_ERR_NAME",¶#endif≥#if SQLITE_NOINLINE≠  "NOINLINE",¶#endif≤#if SQLITE_NO_SYNC¨  "NO_SYNC",¶#endif∫#if SQLITE_OMIT_ALTERTABLE¥  "OMIT_ALTERTABLE",¶#endif∑#if SQLITE_OMIT_ANALYZE±  "OMIT_ANALYZE",¶#endif∂#if SQLITE_OMIT_ATTACH∞  "OMIT_ATTACH",¶#endifΩ#if SQLITE_OMIT_AUTHORIZATION∑  "OMIT_AUTHORIZATION",¶#endifΩ#if SQLITE_OMIT_AUTOINCREMENT∑  "OMIT_AUTOINCREMENT",¶#endif∏#if SQLITE_OMIT_AUTOINIT≤  "OMIT_AUTOINIT",¶#endifø#if SQLITE_OMIT_AUTOMATIC_INDEXπ  "OMIT_AUTOMATIC_INDEX",¶#endifπ#if SQLITE_OMIT_AUTORESET≥  "OMIT_AUTORESET",¶#endif∫#if SQLITE_OMIT_AUTOVACUUM¥  "OMIT_AUTOVACUUM",¶#endifŸ$#if SQLITE_OMIT_BETWEEN_OPTIMIZATIONæ  "OMIT_BETWEEN_OPTIMIZATION",¶#endifº#if SQLITE_OMIT_BLOB_LITERAL∂  "OMIT_BLOB_LITERAL",¶#endif∫#if SQLITE_OMIT_BTREECOUNT¥  "OMIT_BTREECOUNT",¶#endif¥#if SQLITE_OMIT_CASTÆ  "OMIT_CAST",¶#endifµ#if SQLITE_OMIT_CHECKØ  "OMIT_CHECK",¶#endif∏#if SQLITE_OMIT_COMPLETE≤  "OMIT_COMPLETE",¶#endifø#if SQLITE_OMIT_COMPOUND_SELECTπ  "OMIT_COMPOUND_SELECT",¶#endifø#if SQLITE_OMIT_CONFLICT_CLAUSEπ  "OMIT_CONFLICT_CLAUSE",¶#endif≥#if SQLITE_OMIT_CTE≠  "OMIT_CTE",¶#endifæ#if SQLITE_OMIT_DATETIME_FUNCS∏  "OMIT_DATETIME_FUNCS",¶#endif∏#if SQLITE_OMIT_DECLTYPE≤  "OMIT_DECLTYPE",¶#endif∫#if SQLITE_OMIT_DEPRECATED¥  "OMIT_DEPRECATED",¶#endif∂#if SQLITE_OMIT_DISKIO∞  "OMIT_DISKIO",¶#endif∑#if SQLITE_OMIT_EXPLAIN±  "OMIT_EXPLAIN",¶#endifº#if SQLITE_OMIT_FLAG_PRAGMAS∂  "OMIT_FLAG_PRAGMAS",¶#endifæ#if SQLITE_OMIT_FLOATING_POINT∏  "OMIT_FLOATING_POINT",¶#endifª#if SQLITE_OMIT_FOREIGN_KEYµ  "OMIT_FOREIGN_KEY",¶#endifπ#if SQLITE_OMIT_GET_TABLE≥  "OMIT_GET_TABLE",¶#endifª#if SQLITE_OMIT_HEX_INTEGERµ  "OMIT_HEX_INTEGER",¶#endif∏#if SQLITE_OMIT_INCRBLOB≤  "OMIT_INCRBLOB",¶#endifø#if SQLITE_OMIT_INTEGRITY_CHECKπ  "OMIT_INTEGRITY_CHECK",¶#endifŸ!#if SQLITE_OMIT_LIKE_OPTIMIZATIONª  "OMIT_LIKE_OPTIMIZATION",¶#endifæ#if SQLITE_OMIT_LOAD_EXTENSION∏  "OMIT_LOAD_EXTENSION",¶#endifπ#if SQLITE_OMIT_LOCALTIME≥  "OMIT_LOCALTIME",¶#endifπ#if SQLITE_OMIT_LOOKASIDE≥  "OMIT_LOOKASIDE",¶#endif∏#if SQLITE_OMIT_MEMORYDB≤  "OMIT_MEMORYDB",¶#endifø#if SQLITE_OMIT_OR_OPTIMIZATIONπ  "OMIT_OR_OPTIMIZATION",¶#endifΩ#if SQLITE_OMIT_PAGER_PRAGMAS∑  "OMIT_PAGER_PRAGMAS",¶#endifº#if SQLITE_OMIT_PARSER_TRACE∂  "OMIT_PARSER_TRACE",¶#endifµ#if SQLITE_OMIT_POPENØ  "OMIT_POPEN",¶#endif∂#if SQLITE_OMIT_PRAGMA∞  "OMIT_PRAGMA",¶#endifŸ!#if SQLITE_OMIT_PROGRESS_CALLBACKª  "OMIT_PROGRESS_CALLBACK",¶#endifº#if SQLITE_OMIT_QUICKBALANCE∂  "OMIT_QUICKBALANCE",¶#endif∑#if SQLITE_OMIT_REINDEX±  "OMIT_REINDEX",¶#endifæ#if SQLITE_OMIT_SCHEMA_PRAGMAS∏  "OMIT_SCHEMA_PRAGMAS",¶#endifŸ&#if SQLITE_OMIT_SCHEMA_VERSION_PRAGMASŸ   "OMIT_SCHEMA_VERSION_PRAGMAS",¶#endifº#if SQLITE_OMIT_SHARED_CACHE∂  "OMIT_SHARED_CACHE",¶#endifŸ$#if SQLITE_OMIT_SHUTDOWN_DIRECTORIESæ  "OMIT_SHUTDOWN_DIRECTORIES",¶#endif∏#if SQLITE_OMIT_SUBQUERY≤  "OMIT_SUBQUERY",¶#endifº#if SQLITE_OMIT_TCL_VARIABLE∂  "OMIT_TCL_VARIABLE",¶#endif∂#if SQLITE_OMIT_TEMPDB∞  "OMIT_TEMPDB",¶#endifº#if SQLITE_OMIT_TEST_CONTROL∂  "OMIT_TEST_CONTROL",¶#endifµ#if SQLITE_OMIT_TRACEØ  "OMIT_TRACE",¶#endif∑#if SQLITE_OMIT_TRIGGER±  "OMIT_TRIGGER",¶#endifŸ%#if SQLITE_OMIT_TRUNCATE_OPTIMIZATIONø  "OMIT_TRUNCATE_OPTIMIZATION",¶#endifµ#if SQLITE_OMIT_UTF16Ø  "OMIT_UTF16",¶#endif∂#if SQLITE_OMIT_VACUUM∞  "OMIT_VACUUM",¶#endif¥#if SQLITE_OMIT_VIEWÆ  "OMIT_VIEW",¶#endifº#if SQLITE_OMIT_VIRTUALTABLE∂  "OMIT_VIRTUALTABLE",¶#endif≥#if SQLITE_OMIT_WAL≠  "OMIT_WAL",¶#endif≥#if SQLITE_OMIT_WSD≠  "OMIT_WSD",¶#endif∏#if SQLITE_OMIT_XFER_OPT≤  "OMIT_XFER_OPT",¶#endifŸ!#if SQLITE_PCACHE_SEPARATE_HEADERª  "PCACHE_SEPARATE_HEADER",¶#endifº#if SQLITE_PERFORMANCE_TRACE∂  "PERFORMANCE_TRACE",¶#endifæ#if SQLITE_POWERSAFE_OVERWRITE∏  "POWERSAFE_OVERWRITE",¶#endifø#if SQLITE_PREFER_PROXY_LOCKINGπ  "PREFER_PROXY_LOCKING",¶#endif∂#if SQLITE_PROXY_DEBUG∞  "PROXY_DEBUG",¶#endifŸ$#if SQLITE_REVERSE_UNORDERED_SELECTSæ  "REVERSE_UNORDERED_SELECTS",¶#endifπ#if SQLITE_RTREE_INT_ONLY≥  "RTREE_INT_ONLY",¶#endif∏#if SQLITE_SECURE_DELETE≤  "SECURE_DELETE",¶#endif∂#if SQLITE_SMALL_STACK∞  "SMALL_STACK",¶#endif∫#ifdef SQLITE_SORTER_PMASZŸ4  "SORTER_PMASZ=" CTIMEOPT_VAL(SQLITE_SORTER_PMASZ),¶#endif≤#if SQLITE_SOUNDEX¨  "SOUNDEX",¶#endifª#ifdef SQLITE_STAT4_SAMPLESŸ6  "STAT4_SAMPLES=" CTIMEOPT_VAL(SQLITE_STAT4_SAMPLES),¶#endifº#ifdef SQLITE_STMTJRNL_SPILLŸ8  "STMTJRNL_SPILL=" CTIMEOPT_VAL(SQLITE_STMTJRNL_SPILL),¶#endifø#if SQLITE_SUBSTR_COMPATIBILITYπ  "SUBSTR_COMPATIBILITY",¶#endif∏#if SQLITE_SYSTEM_MALLOC≤  "SYSTEM_MALLOC",¶#endifÆ#if SQLITE_TCL®  "TCL",¶#endif∏#ifdef SQLITE_TEMP_STOREŸ0  "TEMP_STORE=" CTIMEOPT_VAL(SQLITE_TEMP_STORE),¶#endifØ#if SQLITE_TEST©  "TEST",¶#endifæ#if defined(SQLITE_THREADSAFE)Ÿ0  "THREADSAFE=" CTIMEOPT_VAL(SQLITE_THREADSAFE),π#elif defined(THREADSAFE)Ÿ)  "THREADSAFE=" CTIMEOPT_VAL(THREADSAFE),•#else±  "THREADSAFE=1",¶#endifΩ#if SQLITE_UNLINK_AFTER_CLOSE∑  "UNLINK_AFTER_CLOSE",¶#endifµ#if SQLITE_UNTESTABLEØ  "UNTESTABLE",¶#endifæ#if SQLITE_USER_AUTHENTICATION∏  "USER_AUTHENTICATION",¶#endifµ#if SQLITE_USE_ALLOCAØ  "USE_ALLOCA",¶#endif∫#if SQLITE_USE_FCNTL_TRACE¥  "USE_FCNTL_TRACE",¶#endif≤#if SQLITE_USE_URI¨  "USE_URI",¶#endif∏#if SQLITE_VDBE_COVERAGE≤  "VDBE_COVERAGE",¶#endif∑#if SQLITE_WIN32_MALLOC±  "WIN32_MALLOC",¶#endif∂#if SQLITE_ZERO_MALLOC∞  "ZERO_MALLOC",¶#endif£/* Ÿ*** END CODE GENERATED BY tool/mkctime.tcl ¢*/¢};†Ÿ>SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt){ŸH  *pnOpt = sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]);Ÿ+  return (const char**)sqlite3azCompileOpt;°}†Ÿ,#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */†ŸO/************** End of ctime.c ***********************************************/ŸO/************** Begin file sqliteInt.h ***************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ-** Internal interface definitions for SQLite.¢**¢*/≥#ifndef SQLITEINT_H≥#define SQLITEINT_H†¥/* Special Comments:¢**ŸD** Some comments have special meaning to the tools that measure test¨** coverage:¢**ŸE**    NO_TEST                     - The branches on this line are notŸI**                                  measured by branch coverage.  This isŸG**                                  used on lines of code that actuallyŸH**                                  implement parts of coverage testing.¢**ŸL**    OPTIMIZATION-IF-TRUE        - This branch is allowed to alway be falseŸM**                                  and the correct answer is still obtained,Ÿ?**                                  though perhaps more slowly.¢**ŸK**    OPTIMIZATION-IF-FALSE       - This branch is allowed to alway be trueŸM**                                  and the correct answer is still obtained,Ÿ?**                                  though perhaps more slowly.¢**ŸJ**    PREVENTS-HARMLESS-OVERREAD  - This branch prevents a buffer overreadŸK**                                  that would be harmless and undetectableŸ6**                                  if it did occur.  ¢**ŸB** In all cases, the special comment must be enclosed in the usualŸM** slash-asterisk...asterisk-slash comment marks, with no spaces between the Ÿ"** asterisks and the comment text.¢*/†¢/*ŸH** Make sure the Tcl calling convention macro is defined.  This macro isŸ3** only used by test code and Tcl integration code.¢*/µ#ifndef SQLITE_TCLAPI∑#  define SQLITE_TCLAPI¶#endif†¢/*ŸK** Include the header file used to customize the compiler options for MSVC.ŸI** This should be done first so that it can successfully prevent spuriousŸK** compiler warnings due to subsequent content in this file and other filesŸ"** that are included by this file.¢*/ŸO/************** Include msvc.h in the middle of sqliteInt.h ******************/ŸO/************** Begin file msvc.h ********************************************/¢/*≤** 2015 January 12¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**Ÿ4** This file contains code that is specific to MSVC.¢*/µ#ifndef SQLITE_MSVC_Hµ#define SQLITE_MSVC_H†µ#if defined(_MSC_VER)ø#pragma warning(disable : 4054)ø#pragma warning(disable : 4055)ø#pragma warning(disable : 4100)ø#pragma warning(disable : 4127)ø#pragma warning(disable : 4130)ø#pragma warning(disable : 4152)ø#pragma warning(disable : 4189)ø#pragma warning(disable : 4206)ø#pragma warning(disable : 4210)ø#pragma warning(disable : 4232)ø#pragma warning(disable : 4244)ø#pragma warning(disable : 4305)ø#pragma warning(disable : 4306)ø#pragma warning(disable : 4702)ø#pragma warning(disable : 4706)æ#endif /* defined(_MSC_VER) */†∫#endif /* SQLITE_MSVC_H */†ŸO/************** End of msvc.h ************************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/†¢/*º** Special setup for VxWorks¢*/ŸO/************** Include vxworks.h in the middle of sqliteInt.h ***************/ŸO/************** Begin file vxworks.h *****************************************/¢/*≠** 2015-03-02¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸC** This file contains code that is specific to Wind River's VxWorks¢*/Ÿ,#if defined(__RTP__) || defined(_WRS_KERNEL)Ÿ8/* This is VxWorks.  Set up things specially for that OS¢*/¥#include <vxWorks.h>Ÿ2#include <pthread.h>  /* amalgamator: dontcache */¥#define OS_VXWORKS 1π#define SQLITE_OS_OTHER 0Ÿ*#define SQLITE_HOMEGROWN_RECURSIVE_MUTEX 1Ÿ$#define SQLITE_OMIT_LOAD_EXTENSION 1Ÿ%#define SQLITE_ENABLE_LOCKING_STYLE 0¥#define HAVE_UTIME 1•#else∫/* This is not VxWorks. */¥#define OS_VXWORKS 0µ#define HAVE_FCHOWN 1∑#define HAVE_READLINK 1¥#define HAVE_LSTAT 1Ÿ!#endif /* defined(_WRS_KERNEL) */†ŸO/************** End of vxworks.h *********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/†¢/*ŸA** These #defines should enable >2GB file support on POSIX if theŸ<** underlying operating system supports it.  If the OS lacksŸG** large file support, or if the OS is windows, these should be no-ops.¢**ŸD** Ticket #2739:  The _LARGEFILE_SOURCE macro must appear before anyŸF** system #includes.  Hence, this block of code must be the very firstº** code in all source files.¢**ŸK** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switchŸH** on the compiler command line.  This is necessary if you are compilingŸG** on a recent machine (ex: Red Hat 7.2) but you want your code to workŸH** on an older machine (ex: Red Hat 6.0).  If you compile on Red Hat 7.2ŸL** without this option, LFS is enable.  But LFS does not exist in the kernelŸE** in Red Hat 6.0, so the code won't work.  Hence, for maximum binaryŸ#** portability you should omit LFS.¢**ŸJ** The previous paragraph was written in 2005.  (This paragraph is writtenŸH** on 2008-11-28.) These days, all Linux kernels support large files, soŸL** you should probably leave LFS enabled.  But some embedded platforms mightŸM** lack LFS in which case the SQLITE_DISABLE_LFS macro might still be useful.¢**ŸP** Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.¢*/∫#ifndef SQLITE_DISABLE_LFSº# define _LARGE_FILE       1∫# ifndef _FILE_OFFSET_BITSø#   define _FILE_OFFSET_BITS 64ß# endifº# define _LARGEFILE_SOURCE 1¶#endif†Ÿ6/* The GCC_VERSION and MSVC_VERSION macros are used toŸF** conditionally include optimizations for each of these compilers.  AŸ9** value of 0 means that compiler is not being used.  TheŸH** SQLITE_DISABLE_INTRINSIC macro means do not use any compiler-specificŸ8** optimizations, and hence set all compiler macros to 0¢**ŸI** There was once also a CLANG_VERSION macro.  However, we learn that theŸI** version numbers in clang are for "marketing" only and are inconsistentŸI** and unreliable.  Fortunately, all versions of clang also recognize theŸL** gcc version numbers and have reasonable settings for gcc version numbers,ŸH** so the GCC_VERSION macro will be set to a correct non-zero value evenΩ** when compiling with clang.¢*/Ÿ;#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)ŸO# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)•#else∂# define GCC_VERSION 0¶#endifŸ;#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)æ# define MSVC_VERSION _MSC_VER•#else∑# define MSVC_VERSION 0¶#endif†Ÿ'/* Needed for various definitions... */Ÿ.#if defined(__GNUC__) && !defined(_GNU_SOURCE)¥# define _GNU_SOURCE¶#endif†Ÿ1#if defined(__OpenBSD__) && !defined(_BSD_SOURCE)¥# define _BSD_SOURCE¶#endif†¢/*ŸK** For MinGW, check to see if we can include the header file containing itsŸJ** version information, among other things.  Normally, this internal MinGWŸK** header file would [only] be included automatically by other MinGW headerŸL** files; however, the contained version information is now required by thisŸI** header file to work around binary compatibility issues (see below) andŸK** this is the only known way to reliably obtain it.  This entire #if blockŸJ** would be completely unnecessary if there was any other way of detectingŸL** MinGW via their preprocessor (e.g. if they customized their GCC to defineŸE** some MinGW-specific macros).  When compiling for MinGW, either theŸL** _HAVE_MINGW_H or _HAVE__MINGW_H (note the extra underscore) macro must beŸH** defined; otherwise, detection of conditions specific to MinGW will be¨** disabled.¢*/∫#if defined(_HAVE_MINGW_H)≥# include "mingw.h"Ω#elif defined(_HAVE__MINGW_H)¥# include "_mingw.h"¶#endif†¢/*ŸL** For MinGW version 4.x (and higher), check to see if the _USE_32BIT_TIME_TŸL** define is required to maintain binary compatibility with the MSVC runtimeŸ(** library in use (e.g. for Windows XP).¢*/ŸC#if !defined(_USE_32BIT_TIME_T) && !defined(_USE_64BIT_TIME_T) && \Ÿ,    defined(_WIN32) && !defined(_WIN64) && \ŸE    defined(__MINGW_MAJOR_VERSION) && __MINGW_MAJOR_VERSION >= 4 && \∑    defined(__MSVCRT__)∫# define _USE_32BIT_TIME_T¶#endif†ŸH/* The public SQLite interface.  The _FILE_OFFSET_BITS macro must appearŸI** first in QNX.  Also, the _USE_32BIT_TIME_T macro must appear first for©** MinGW.¢*/ŸO/************** Include sqlite3.h in the middle of sqliteInt.h ***************/ŸO/************** Begin file sqlite3.h *****************************************/¢/*≠** 2001-09-15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸA** This header file defines the interface that the SQLite libraryŸF** presents to client programs.  If a C-function, structure, datatype,ŸB** or constant definition does not appear in this file, then it isŸ>** not a published API of SQLite, is subject to change withoutŸD** notice, and should not be referenced by programs that use SQLite.¢**Ÿ>** Some of the definitions that are in this file are marked asŸ<** "experimental".  Experimental interfaces are normally newŸC** features recently added to SQLite.  We do not anticipate changesŸI** to experimental interfaces but reserve the right to make minor changesŸI** if experience from use "in the wild" suggest such changes are prudent.¢**ŸB** The official C-language API documentation for SQLite is derivedŸE** from comments in this file.  This file is the authoritative sourceŸ4** on how SQLite interfaces are supposed to operate.¢**ŸI** The name of this file under configuration management is "sqlite.h.in".ŸH** The makefile makes some minor changes to this file (such as insertingŸ=** the version number) and changes its name to "sqlite3.h" asΩ** part of the build process.¢*/±#ifndef SQLITE3_H±#define SQLITE3_HŸB#include <stdarg.h>     /* Needed for the definition of va_list */†¢/*Ÿ-** Make sure we can call this stuff from C++.¢*/•#if 0¨extern "C" {¶#endif††¢/*ŸE** Provide the ability to override linkage features of the interface.¢*/µ#ifndef SQLITE_EXTERNΩ# define SQLITE_EXTERN extern¶#endif≤#ifndef SQLITE_API≥# define SQLITE_API¶#endif¥#ifndef SQLITE_CDECLµ# define SQLITE_CDECL¶#endif∂#ifndef SQLITE_APICALL∑# define SQLITE_APICALL¶#endif∂#ifndef SQLITE_STDCALLŸ&# define SQLITE_STDCALL SQLITE_APICALL¶#endif∑#ifndef SQLITE_CALLBACK∏# define SQLITE_CALLBACK¶#endifµ#ifndef SQLITE_SYSAPI∂# define SQLITE_SYSAPI¶#endif†¢/*ŸC** These no-op macros are used in front of interfaces to mark thoseŸE** interfaces as either deprecated or experimental.  New applicationsŸJ** should not use deprecated interfaces - they are supported for backwardsŸ@** compatibility only.  Application writers should be aware thatŸC** experimental interfaces are subject to change in point releases.¢**ŸG** These macros used to resolve to various kinds of compiler magic thatŸA** would generate warning messages when they were used.  But thatŸB** compiler magic ended up generating such a flurry of bug reportsŸ>** that we have taken it all out and gone back to using simpleØ** noop macros.¢*/π#define SQLITE_DEPRECATEDª#define SQLITE_EXPERIMENTAL†¢/*ŸF** Ensure these symbols were not defined by some previous header file.¢*/µ#ifdef SQLITE_VERSION∂# undef SQLITE_VERSION¶#endifº#ifdef SQLITE_VERSION_NUMBERΩ# undef SQLITE_VERSION_NUMBER¶#endif†¢/*Ÿ1** CAPI3REF: Compile-Time Library Version Numbers¢**ŸF** ^(The [SQLITE_VERSION] C preprocessor macro in the sqlite3.h headerŸB** evaluates to a string literal that is the SQLite version in theŸC** format "X.Y.Z" where X is the major version number (always 3 forŸL** SQLite3) and Y is the minor version number and Z is the release number.)^ŸL** ^(The [SQLITE_VERSION_NUMBER] C preprocessor macro resolves to an integerŸI** with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the sameŸ&** numbers used in [SQLITE_VERSION].)^ŸF** The SQLITE_VERSION_NUMBER for any given release of SQLite will alsoŸF** be larger than the release from which it is derived.  Either Y willŸK** be held constant and Z will be incremented or else Y will be incrementedø** and Z will be reset to zero.¢**Ÿ-** Since [version 3.6.18] ([dateof:3.6.18]), Ÿ,** SQLite source code has been stored in theŸG** <a href="http://www.fossil-scm.org/">Fossil configuration managementŸ8** system</a>.  ^The SQLITE_SOURCE_ID macro evaluates toŸ<** a string which identifies a particular check-in of SQLiteŸE** within its configuration management system.  ^The SQLITE_SOURCE_IDŸE** string contains the date and time of the check-in (UTC) and a SHA1ŸF** or SHA3-256 hash of the entire source tree.  If the source code hasŸE** been edited in any way since it was last checked in, then the lastŸ7** four hexadecimal digits of the hash may be modified.¢**Ÿ$** See also: [sqlite3_libversion()],Ÿ7** [sqlite3_libversion_number()], [sqlite3_sourceid()],Ÿ/** [sqlite_version()] and [sqlite_source_id()].¢*/Ÿ&#define SQLITE_VERSION        "3.23.1"Ÿ%#define SQLITE_VERSION_NUMBER 3023001Ÿt#define SQLITE_SOURCE_ID      "2018-04-10 17:39:29 4bb2294022060e61de7da5c227a69ccd846ba330e31626ebcd59a94efd148b3b"†¢/*Ÿ-** CAPI3REF: Run-Time Library Version NumbersŸ-** KEYWORDS: sqlite3_version sqlite3_sourceid¢**ŸI** These interfaces provide the same information as the [SQLITE_VERSION],ŸH** [SQLITE_VERSION_NUMBER], and [SQLITE_SOURCE_ID] C preprocessor macrosŸN** but are associated with the library instead of the header file.  ^(CautiousŸH** programmers might include assert() statements in their application toŸF** verify that values returned by these interfaces match the macros inŸ6** the header, and thus ensure that the application isŸ3** compiled with matching library and header files.¢**¥** <blockquote><pre>Ÿ@** assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER );Ÿ@** assert( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,80)==0 );Ÿ<** assert( strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );∏** </pre></blockquote>)^¢**ŸO** ^The sqlite3_version[] string constant contains the text of [SQLITE_VERSION]ŸF** macro.  ^The sqlite3_libversion() function returns a pointer to theŸF** to the sqlite3_version[] string constant.  The sqlite3_libversion()ŸK** function is provided for use in DLLs since DLL users usually do not haveŸ:** direct access to string constants within the DLL.  ^TheŸC** sqlite3_libversion_number() function returns an integer equal toŸG** [SQLITE_VERSION_NUMBER].  ^(The sqlite3_sourceid() function returns ŸA** a pointer to a string constant whose value is the same as the ŸF** [SQLITE_SOURCE_ID] C preprocessor macro.  Except if SQLite is builtŸL** using an edited copy of [the amalgamation], then the last four charactersŸ<** of the hash might be different from [SQLITE_SOURCE_ID].)^¢**Ÿ9** See also: [sqlite_version()] and [sqlite_source_id()].¢*/Ÿ9SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;Ÿ0SQLITE_API const char *sqlite3_libversion(void);Ÿ.SQLITE_API const char *sqlite3_sourceid(void);Ÿ/SQLITE_API int sqlite3_libversion_number(void);†¢/*Ÿ=** CAPI3REF: Run-Time Library Compilation Options Diagnostics¢**Ÿ=** ^The sqlite3_compileoption_used() function returns 0 or 1 Ÿ:** indicating whether the specified option was defined at Ÿ>** compile time.  ^The SQLITE_ prefix may be omitted from the Ÿ8** option name passed to sqlite3_compileoption_used().  ¢**Ÿ=** ^The sqlite3_compileoption_get() function allows iteratingŸ@** over the list of options that were defined at compile time byŸI** returning the N-th compile time option string.  ^If N is out of range,ŸE** sqlite3_compileoption_get() returns a NULL pointer.  ^The SQLITE_ Ÿ2** prefix is omitted from any strings returned by ø** sqlite3_compileoption_get().¢**ŸE** ^Support for the diagnostic functions sqlite3_compileoption_used()ŸD** and sqlite3_compileoption_get() may be omitted by specifying the Ÿ<** [SQLITE_OMIT_COMPILEOPTION_DIAGS] option at compile time.¢**Ÿ<** See also: SQL functions [sqlite_compileoption_used()] andŸA** [sqlite_compileoption_get()] and the [compile_options pragma].¢*/Ÿ'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSŸ@SQLITE_API int sqlite3_compileoption_used(const char *zOptName);Ÿ8SQLITE_API const char *sqlite3_compileoption_get(int N);¶#endif†¢/*Ÿ5** CAPI3REF: Test To See If The Library Is Threadsafe¢**ŸA** ^The sqlite3_threadsafe() function returns zero if and only ifŸ<** SQLite was compiled with mutexing code omitted due to theŸ:** [SQLITE_THREADSAFE] compile-time option being set to 0.¢**Ÿ8** SQLite can be compiled with or without mutexes.  WhenŸB** the [SQLITE_THREADSAFE] C preprocessor macro is 1 or 2, mutexesŸ2** are enabled and SQLite is threadsafe.  When theŸ#** [SQLITE_THREADSAFE] macro is 0, Ÿ@** the mutexes are omitted.  Without the mutexes, it is not safeŸ8** to use SQLite concurrently from more than one thread.¢**Ÿ<** Enabling mutexes incurs a measurable performance penalty.ŸA** So if speed is of utmost importance, it makes sense to disableŸC** the mutexes.  But for maximum safety, mutexes should be enabled.Ÿ6** ^The default behavior is for mutexes to be enabled.¢**ŸE** This interface can be used by an application to make sure that theŸA** version of SQLite that it is linking against was compiled withŸ8** the desired setting of the [SQLITE_THREADSAFE] macro.¢**Ÿ@** This interface only reports on the compile-time mutex settingŸ?** of the [SQLITE_THREADSAFE] flag.  If SQLite is compiled withŸD** SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default butŸH** can be fully or partially disabled using a call to [sqlite3_config()]ŸL** with the verbs [SQLITE_CONFIG_SINGLETHREAD], [SQLITE_CONFIG_MULTITHREAD],Ÿ<** or [SQLITE_CONFIG_SERIALIZED].  ^(The return value of theŸG** sqlite3_threadsafe() function shows only the compile-time setting ofŸB** thread safety, not any run-time changes to that setting made byŸO** sqlite3_config(). In other words, the return value from sqlite3_threadsafe()Ÿ/** is unchanged by calls to sqlite3_config().)^¢**ŸE** See the [threading mode] documentation for additional information.¢*/Ÿ(SQLITE_API int sqlite3_threadsafe(void);†¢/*Ÿ'** CAPI3REF: Database Connection HandleŸ9** KEYWORDS: {database connection} {database connections}¢**ŸJ** Each open SQLite database is represented by a pointer to an instance ofŸM** the opaque structure named "sqlite3".  It is useful to think of an sqlite3ŸG** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], andŸM** [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]ŸF** and [sqlite3_close_v2()] are its destructors.  There are many other∂** interfaces (such asŸ;** [sqlite3_prepare_v2()], [sqlite3_create_function()], andŸE** [sqlite3_busy_timeout()] to name but three) that are methods on an≤** sqlite3 object.¢*/øtypedef struct sqlite3 sqlite3;†¢/*Ÿ!** CAPI3REF: 64-Bit Integer TypesŸ'** KEYWORDS: sqlite_int64 sqlite_uint64¢**ŸI** Because there is no cross-platform way to specify 64-bit integer typesŸD** SQLite includes typedefs for 64-bit signed and unsigned integers.¢**ŸK** The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.ŸG** The sqlite_int64 and sqlite_uint64 types are supported for backwards∂** compatibility only.¢**ŸE** ^The sqlite3_int64 and sqlite_int64 types can store integer valuesŸI** between -9223372036854775808 and +9223372036854775807 inclusive.  ^TheŸC** sqlite3_uint64 and sqlite_uint64 types can store integer values Ÿ1** between 0 and +18446744073709551615 inclusive.¢*/∏#ifdef SQLITE_INT64_TYPEŸ)  typedef SQLITE_INT64_TYPE sqlite_int64;∫# ifdef SQLITE_UINT64_TYPEŸ-    typedef SQLITE_UINT64_TYPE sqlite_uint64;®# else  Ÿ5    typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;ß# endifŸ0#elif defined(_MSC_VER) || defined(__BORLANDC__)ø  typedef __int64 sqlite_int64;Ÿ)  typedef unsigned __int64 sqlite_uint64;•#elseŸ%  typedef long long int sqlite_int64;Ÿ/  typedef unsigned long long int sqlite_uint64;¶#endifŸ#typedef sqlite_int64 sqlite3_int64;Ÿ%typedef sqlite_uint64 sqlite3_uint64;†¢/*ŸB** If compiling for a processor that lacks floating point support,Ÿ)** substitute integer for floating-point.¢*/Ÿ!#ifdef SQLITE_OMIT_FLOATING_POINTΩ# define double sqlite3_int64¶#endif†¢/*Ÿ*** CAPI3REF: Closing A Database Connection∂** DESTRUCTOR: sqlite3¢**ŸG** ^The sqlite3_close() and sqlite3_close_v2() routines are destructorsº** for the [sqlite3] object.ŸI** ^Calls to sqlite3_close() and sqlite3_close_v2() return [SQLITE_OK] ifŸD** the [sqlite3] object is successfully destroyed and all associatedΩ** resources are deallocated.¢**ŸF** ^If the database connection is associated with unfinalized preparedŸG** statements or unfinished sqlite3_backup objects then sqlite3_close()ŸD** will leave the database connection open and return [SQLITE_BUSY].ŸH** ^If sqlite3_close_v2() is called with unfinalized prepared statementsŸJ** and/or unfinished sqlite3_backups, then the database connection becomesŸH** an unusable "zombie" which will automatically be deallocated when theŸE** last prepared statement is finalized or the last sqlite3_backup isŸG** finished.  The sqlite3_close_v2() interface is intended for use withŸJ** host languages that are garbage collected, and where the order in whichŸ'** destructors are called is arbitrary.¢**ŸO** Applications should [sqlite3_finalize | finalize] all [prepared statements],Ÿ8** [sqlite3_blob_close | close] all [BLOB handles], and ŸK** [sqlite3_backup_finish | finish] all [sqlite3_backup] objects associatedŸJ** with the [sqlite3] object prior to attempting to close the object.  ^IfŸI** sqlite3_close_v2() is called on a [database connection] that still hasŸ<** outstanding [prepared statements], [BLOB handles], and/orŸL** [sqlite3_backup] objects then it returns [SQLITE_OK] and the deallocationŸL** of resources is deferred until all [prepared statements], [BLOB handles],Ÿ3** and [sqlite3_backup] objects are also destroyed.¢**ŸD** ^If an [sqlite3] object is destroyed while a transaction is open,Ÿ0** the transaction is automatically rolled back.¢**ŸB** The C parameter to [sqlite3_close(C)] and [sqlite3_close_v2(C)]∏** must be either a NULLŸ2** pointer or an [sqlite3] object pointer obtainedŸ0** from [sqlite3_open()], [sqlite3_open16()], orŸ2** [sqlite3_open_v2()], and not previously closed.ŸE** ^Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointerŸ ** argument is a harmless no-op.¢*/Ÿ'SQLITE_API int sqlite3_close(sqlite3*);Ÿ*SQLITE_API int sqlite3_close_v2(sqlite3*);†¢/*Ÿ$** The type for a callback function.Ÿ@** This is legacy and deprecated.  It is included for historicalŸ'** compatibility and is not documented.¢*/Ÿ:typedef int (*sqlite3_callback)(void*,int,char**, char**);†¢/*Ÿ/** CAPI3REF: One-Step Query Execution Interface≤** METHOD: sqlite3¢**Ÿ?** The sqlite3_exec() interface is a convenience wrapper aroundŸF** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],Ÿ?** that allows an application to run multiple statements of SQLŸ*** without having to use a lot of C code. ¢**ŸA** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,ŸB** semicolon-separate SQL statements passed into its 2nd argument,ŸC** in the context of the [database connection] passed in as its 1stŸ>** argument.  ^If the callback function of the 3rd argument toŸE** sqlite3_exec() is not NULL, then it is invoked for each result rowŸD** coming out of the evaluated SQL statements.  ^The 4th argument toŸ@** sqlite3_exec() is relayed through to the 1st argument of eachŸC** callback invocation.  ^If the callback pointer to sqlite3_exec()Ÿ@** is NULL, then no callback is ever invoked and result rows are´** ignored.¢**ŸF** ^If an error occurs while evaluating the SQL statements passed intoŸD** sqlite3_exec(), then execution of the current statement stops andŸN** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()ŸE** is not NULL then any error message is written into memory obtainedŸE** from [sqlite3_malloc()] and passed back through the 5th parameter.ŸH** To avoid memory leaks, the application should invoke [sqlite3_free()]ŸA** on error message strings returned through the 5th parameter ofŸE** sqlite3_exec() after the error message string is no longer needed.ŸD** ^If the 5th parameter to sqlite3_exec() is not NULL and no errorsŸF** occur, then sqlite3_exec() sets the pointer in its 5th parameter toπ** NULL before returning.¢**ŸF** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()ŸG** routine returns SQLITE_ABORT without invoking the callback again andŸ1** without running any subsequent SQL statements.¢**ŸC** ^The 2nd argument to the sqlite3_exec() callback function is theŸL** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()ŸB** callback is an array of pointers to strings obtained as if fromŸE** [sqlite3_column_text()], one for each column.  ^If an element of aŸC** result row is NULL then the corresponding string pointer for theŸG** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to theŸH** sqlite3_exec() callback is an array of pointers to strings where eachŸG** entry represents the name of corresponding result column as obtainedŸ ** from [sqlite3_column_name()].¢**ŸG** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointerŸI** to an empty string, or a pointer that contains only whitespace and/or ŸF** SQL comments, then no SQL statements are evaluated and the database≤** is not changed.¢**∞** Restrictions:¢**ß** <ul>ŸL** <li> The application must ensure that the 1st parameter to sqlite3_exec()Ÿ2**      is a valid and open [database connection].ŸM** <li> The application must not close the [database connection] specified byŸL**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.ŸJ** <li> The application must not modify the SQL statement text passed intoŸL**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.®** </ul>¢*/ºSQLITE_API int sqlite3_exec(ŸC  sqlite3*,                                  /* An open database */ŸF  const char *sql,                           /* SQL to be evaluated */ŸD  int (*callback)(void*,int,char**,char**),  /* Callback function */ŸK  void *,                                    /* 1st argument to callback */ŸI  char **errmsg                              /* Error msg written here */¢);†¢/*π** CAPI3REF: Result CodesŸ&** KEYWORDS: {result code definitions}¢**ŸI** Many SQLite functions return an integer result code from the set shownŸ0** here in order to indicate success or failure.¢**Ÿ=** New error codes may be added in future versions of SQLite.¢**Ÿ/** See also: [extended result code definitions]¢*/Ÿ7#define SQLITE_OK           0   /* Successful result */æ/* beginning-of-error-codes */Ÿ3#define SQLITE_ERROR        1   /* Generic error */ŸD#define SQLITE_INTERNAL     2   /* Internal logic error in SQLite */Ÿ>#define SQLITE_PERM         3   /* Access permission denied */ŸI#define SQLITE_ABORT        4   /* Callback routine requested an abort */ŸA#define SQLITE_BUSY         5   /* The database file is locked */ŸG#define SQLITE_LOCKED       6   /* A table in the database is locked */Ÿ7#define SQLITE_NOMEM        7   /* A malloc() failed */ŸJ#define SQLITE_READONLY     8   /* Attempt to write a readonly database */ŸP#define SQLITE_INTERRUPT    9   /* Operation terminated by sqlite3_interrupt()*/ŸJ#define SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */ŸJ#define SQLITE_CORRUPT     11   /* The database disk image is malformed */ŸN#define SQLITE_NOTFOUND    12   /* Unknown opcode in sqlite3_file_control() */ŸO#define SQLITE_FULL        13   /* Insertion failed because database is full */ŸF#define SQLITE_CANTOPEN    14   /* Unable to open the database file */ŸB#define SQLITE_PROTOCOL    15   /* Database lock protocol error */Ÿ7#define SQLITE_EMPTY       16   /* Internal use only */ŸA#define SQLITE_SCHEMA      17   /* The database schema changed */ŸG#define SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */ŸG#define SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */Ÿ8#define SQLITE_MISMATCH    20   /* Data type mismatch */Ÿ>#define SQLITE_MISUSE      21   /* Library used incorrectly */ŸL#define SQLITE_NOLFS       22   /* Uses OS features not supported on host */Ÿ:#define SQLITE_AUTH        23   /* Authorization denied */Ÿ.#define SQLITE_FORMAT      24   /* Not used */ŸP#define SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */ŸM#define SQLITE_NOTADB      26   /* File opened that is not a database file */ŸF#define SQLITE_NOTICE      27   /* Notifications from sqlite3_log() */ŸA#define SQLITE_WARNING     28   /* Warnings from sqlite3_log() */ŸJ#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */ŸK#define SQLITE_DONE        101  /* sqlite3_step() has finished executing */∏/* end-of-error-codes */†¢/*Ÿ"** CAPI3REF: Extended Result CodesŸ/** KEYWORDS: {extended result code definitions}¢**ŸM** In its default configuration, SQLite API routines return one of 30 integerŸ>** [result codes].  However, experience has shown that many ofŸE** these result codes are too coarse-grained.  They do not provide asŸN** much information about problems as programmers might like.  In an effort toŸG** address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]µ** and later) includeŸM** support for additional result codes that provide more detailed informationŸF** about errors. These [extended result codes] are enabled or disabledŸ/** on a per database connection basis using theŸD** [sqlite3_extended_result_codes()] API.  Or, the extended code forŸ.** the most recent error can be obtained usingŸ ** [sqlite3_extended_errcode()].¢*/Ÿ>#define SQLITE_ERROR_MISSING_COLLSEQ   (SQLITE_ERROR | (1<<8))Ÿ>#define SQLITE_ERROR_RETRY             (SQLITE_ERROR | (2<<8))Ÿ>#define SQLITE_IOERR_READ              (SQLITE_IOERR | (1<<8))Ÿ>#define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR | (2<<8))Ÿ>#define SQLITE_IOERR_WRITE             (SQLITE_IOERR | (3<<8))Ÿ>#define SQLITE_IOERR_FSYNC             (SQLITE_IOERR | (4<<8))Ÿ>#define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR | (5<<8))Ÿ>#define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR | (6<<8))Ÿ>#define SQLITE_IOERR_FSTAT             (SQLITE_IOERR | (7<<8))Ÿ>#define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR | (8<<8))Ÿ>#define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR | (9<<8))Ÿ?#define SQLITE_IOERR_DELETE            (SQLITE_IOERR | (10<<8))Ÿ?#define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR | (11<<8))Ÿ?#define SQLITE_IOERR_NOMEM             (SQLITE_IOERR | (12<<8))Ÿ?#define SQLITE_IOERR_ACCESS            (SQLITE_IOERR | (13<<8))Ÿ?#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))Ÿ?#define SQLITE_IOERR_LOCK              (SQLITE_IOERR | (15<<8))Ÿ?#define SQLITE_IOERR_CLOSE             (SQLITE_IOERR | (16<<8))Ÿ?#define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR | (17<<8))Ÿ?#define SQLITE_IOERR_SHMOPEN           (SQLITE_IOERR | (18<<8))Ÿ?#define SQLITE_IOERR_SHMSIZE           (SQLITE_IOERR | (19<<8))Ÿ?#define SQLITE_IOERR_SHMLOCK           (SQLITE_IOERR | (20<<8))Ÿ?#define SQLITE_IOERR_SHMMAP            (SQLITE_IOERR | (21<<8))Ÿ?#define SQLITE_IOERR_SEEK              (SQLITE_IOERR | (22<<8))Ÿ?#define SQLITE_IOERR_DELETE_NOENT      (SQLITE_IOERR | (23<<8))Ÿ?#define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))Ÿ?#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))Ÿ?#define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))Ÿ?#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))Ÿ?#define SQLITE_IOERR_AUTH              (SQLITE_IOERR | (28<<8))Ÿ?#define SQLITE_IOERR_BEGIN_ATOMIC      (SQLITE_IOERR | (29<<8))Ÿ?#define SQLITE_IOERR_COMMIT_ATOMIC     (SQLITE_IOERR | (30<<8))Ÿ?#define SQLITE_IOERR_ROLLBACK_ATOMIC   (SQLITE_IOERR | (31<<8))Ÿ@#define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))Ÿ@#define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))Ÿ@#define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))ŸA#define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1<<8))ŸA#define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2<<8))ŸA#define SQLITE_CANTOPEN_FULLPATH       (SQLITE_CANTOPEN | (3<<8))ŸA#define SQLITE_CANTOPEN_CONVPATH       (SQLITE_CANTOPEN | (4<<8))Ÿ@#define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1<<8))ŸA#define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1<<8))ŸA#define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2<<8))ŸA#define SQLITE_READONLY_ROLLBACK       (SQLITE_READONLY | (3<<8))ŸA#define SQLITE_READONLY_DBMOVED        (SQLITE_READONLY | (4<<8))ŸA#define SQLITE_READONLY_CANTINIT       (SQLITE_READONLY | (5<<8))ŸA#define SQLITE_READONLY_DIRECTORY      (SQLITE_READONLY | (6<<8))Ÿ>#define SQLITE_ABORT_ROLLBACK          (SQLITE_ABORT | (2<<8))ŸC#define SQLITE_CONSTRAINT_CHECK        (SQLITE_CONSTRAINT | (1<<8))ŸC#define SQLITE_CONSTRAINT_COMMITHOOK   (SQLITE_CONSTRAINT | (2<<8))ŸC#define SQLITE_CONSTRAINT_FOREIGNKEY   (SQLITE_CONSTRAINT | (3<<8))ŸC#define SQLITE_CONSTRAINT_FUNCTION     (SQLITE_CONSTRAINT | (4<<8))ŸC#define SQLITE_CONSTRAINT_NOTNULL      (SQLITE_CONSTRAINT | (5<<8))ŸC#define SQLITE_CONSTRAINT_PRIMARYKEY   (SQLITE_CONSTRAINT | (6<<8))ŸC#define SQLITE_CONSTRAINT_TRIGGER      (SQLITE_CONSTRAINT | (7<<8))ŸC#define SQLITE_CONSTRAINT_UNIQUE       (SQLITE_CONSTRAINT | (8<<8))ŸC#define SQLITE_CONSTRAINT_VTAB         (SQLITE_CONSTRAINT | (9<<8))ŸC#define SQLITE_CONSTRAINT_ROWID        (SQLITE_CONSTRAINT |(10<<8))Ÿ?#define SQLITE_NOTICE_RECOVER_WAL      (SQLITE_NOTICE | (1<<8))Ÿ?#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))Ÿ@#define SQLITE_WARNING_AUTOINDEX       (SQLITE_WARNING | (1<<8))Ÿ=#define SQLITE_AUTH_USER               (SQLITE_AUTH | (1<<8))Ÿ;#define SQLITE_OK_LOAD_PERMANENTLY     (SQLITE_OK | (1<<8))†¢/*Ÿ+** CAPI3REF: Flags For File Open Operations¢**Ÿ/** These bit values are intended for use in theŸ9** 3rd parameter to the [sqlite3_open_v2()] interface andŸ:** in the 4th parameter to the [sqlite3_vfs.xOpen] method.¢*/ŸO#define SQLITE_OPEN_READONLY         0x00000001  /* Ok for sqlite3_open_v2() */ŸO#define SQLITE_OPEN_READWRITE        0x00000002  /* Ok for sqlite3_open_v2() */ŸO#define SQLITE_OPEN_CREATE           0x00000004  /* Ok for sqlite3_open_v2() */Ÿ?#define SQLITE_OPEN_DELETEONCLOSE    0x00000008  /* VFS only */Ÿ?#define SQLITE_OPEN_EXCLUSIVE        0x00000010  /* VFS only */Ÿ?#define SQLITE_OPEN_AUTOPROXY        0x00000020  /* VFS only */ŸO#define SQLITE_OPEN_URI              0x00000040  /* Ok for sqlite3_open_v2() */ŸO#define SQLITE_OPEN_MEMORY           0x00000080  /* Ok for sqlite3_open_v2() */Ÿ?#define SQLITE_OPEN_MAIN_DB          0x00000100  /* VFS only */Ÿ?#define SQLITE_OPEN_TEMP_DB          0x00000200  /* VFS only */Ÿ?#define SQLITE_OPEN_TRANSIENT_DB     0x00000400  /* VFS only */Ÿ?#define SQLITE_OPEN_MAIN_JOURNAL     0x00000800  /* VFS only */Ÿ?#define SQLITE_OPEN_TEMP_JOURNAL     0x00001000  /* VFS only */Ÿ?#define SQLITE_OPEN_SUBJOURNAL       0x00002000  /* VFS only */Ÿ?#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  /* VFS only */ŸO#define SQLITE_OPEN_NOMUTEX          0x00008000  /* Ok for sqlite3_open_v2() */ŸO#define SQLITE_OPEN_FULLMUTEX        0x00010000  /* Ok for sqlite3_open_v2() */ŸO#define SQLITE_OPEN_SHAREDCACHE      0x00020000  /* Ok for sqlite3_open_v2() */ŸO#define SQLITE_OPEN_PRIVATECACHE     0x00040000  /* Ok for sqlite3_open_v2() */Ÿ?#define SQLITE_OPEN_WAL              0x00080000  /* VFS only */†Ÿ2/* Reserved:                         0x00F00000 */†¢/*Ÿ#** CAPI3REF: Device Characteristics¢**Ÿ@** The xDeviceCharacteristics method of the [sqlite3_io_methods]Ÿ7** object returns an integer which is a vector of theseŸ@** bit values expressing I/O characteristics of the mass storageŸ;** device that holds the file that the [sqlite3_io_methods]≠** refers to.¢**Ÿ<** The SQLITE_IOCAP_ATOMIC property means that all writes ofŸ:** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn valuesŸ<** mean that writes of blocks that are nnn bytes in size andŸ<** are aligned to an address which is an integer multiple ofŸ<** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value meansŸ=** that when data is appended to a file, the data is appendedŸ?** first then the size of the file is extended, never the otherŸ?** way around.  The SQLITE_IOCAP_SEQUENTIAL property means thatŸ<** information is written to disk in the same order as callsŸI** to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means thatŸD** after reboot following a crash or power loss, the only bytes in aŸE** file that were written at the application level might have changedŸA** and that adjacent bytes, even bytes within the same sector areŸF** guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPENŸ?** flag indicates that a file cannot be deleted when open.  TheŸ<** SQLITE_IOCAP_IMMUTABLE flag indicates that the file is onŸ?** read-only media and cannot be changed even by processes with∑** elevated privileges.¢**ŸC** The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlyingŸL** filesystem supports doing multiple write operations atomically when thoseŸJ** write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] andŸ&** [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].¢*/Ÿ6#define SQLITE_IOCAP_ATOMIC                 0x00000001Ÿ6#define SQLITE_IOCAP_ATOMIC512              0x00000002Ÿ6#define SQLITE_IOCAP_ATOMIC1K               0x00000004Ÿ6#define SQLITE_IOCAP_ATOMIC2K               0x00000008Ÿ6#define SQLITE_IOCAP_ATOMIC4K               0x00000010Ÿ6#define SQLITE_IOCAP_ATOMIC8K               0x00000020Ÿ6#define SQLITE_IOCAP_ATOMIC16K              0x00000040Ÿ6#define SQLITE_IOCAP_ATOMIC32K              0x00000080Ÿ6#define SQLITE_IOCAP_ATOMIC64K              0x00000100Ÿ6#define SQLITE_IOCAP_SAFE_APPEND            0x00000200Ÿ6#define SQLITE_IOCAP_SEQUENTIAL             0x00000400Ÿ6#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  0x00000800Ÿ6#define SQLITE_IOCAP_POWERSAFE_OVERWRITE    0x00001000Ÿ6#define SQLITE_IOCAP_IMMUTABLE              0x00002000Ÿ6#define SQLITE_IOCAP_BATCH_ATOMIC           0x00004000†¢/*Ÿ ** CAPI3REF: File Locking Levels¢**Ÿ8** SQLite uses one of these integer values as the secondŸB** argument to calls it makes to the xLock() and xUnlock() methodsŸ%** of an [sqlite3_io_methods] object.¢*/Ÿ##define SQLITE_LOCK_NONE          0Ÿ##define SQLITE_LOCK_SHARED        1Ÿ##define SQLITE_LOCK_RESERVED      2Ÿ##define SQLITE_LOCK_PENDING       3Ÿ##define SQLITE_LOCK_EXCLUSIVE     4†¢/*Ÿ'** CAPI3REF: Synchronization Type Flags¢**Ÿ/** When SQLite invokes the xSync() method of anŸ7** [sqlite3_io_methods] object it uses a combination ofŸ/** these integer values as the second argument.¢**Ÿ@** When the SQLITE_SYNC_DATAONLY flag is used, it means that theŸB** sync operation only needs to flush data to mass storage.  InodeŸF** information need not be flushed. If the lower four bits of the flagŸH** equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.Ÿ<** If the lower four bits equal SQLITE_SYNC_FULL, that meansŸ5** to use Mac OS X style fullsync instead of fsync().¢**ŸC** Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flagsŸE** with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULLŸC** settings.  The [synchronous pragma] determines when calls to theŸE** xSync VFS method occur and applies uniformly across all platforms.ŸB** The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine howŸ@** energetic or rigorous or forceful the sync operations are andŸA** only make a difference on Mac OSX for the default SQLite code.ŸC** (Third-party VFS implementations might also make the distinctionŸA** between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among theŸ?** operating systems natively supported by SQLite, only Mac OSXø** cares about the difference.)¢*/Ÿ)#define SQLITE_SYNC_NORMAL        0x00002Ÿ)#define SQLITE_SYNC_FULL          0x00003Ÿ)#define SQLITE_SYNC_DATAONLY      0x00010†¢/*Ÿ*** CAPI3REF: OS Interface Open File Handle¢**Ÿ;** An [sqlite3_file] object represents an open file in the Ÿ?** [sqlite3_vfs | OS interface layer].  Individual OS interface∑** implementations willŸ>** want to subclass this object by appending additional fieldsŸ<** for their own use.  The pMethods entry is a pointer to anŸB** [sqlite3_io_methods] object that defines methods for performingŸ#** I/O operations on the open file.¢*/Ÿ)typedef struct sqlite3_file sqlite3_file;µstruct sqlite3_file {ŸL  const struct sqlite3_io_methods *pMethods;  /* Methods for an open file */¢};†¢/*Ÿ5** CAPI3REF: OS Interface File Virtual Methods Object¢**ŸC** Every file opened by the [sqlite3_vfs.xOpen] method populates anŸ>** [sqlite3_file] object (or, more commonly, a subclass of theŸG** [sqlite3_file] object) with a pointer to an instance of this object.ŸE** This object defines the methods used to perform various operationsŸB** against the open file represented by the [sqlite3_file] object.¢**ŸL** If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element ŸC** to a non-NULL pointer, then the sqlite3_io_methods.xClose methodŸO** may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  TheŸN** only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]ŸJ** is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element´** to NULL.¢**ŸD** The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] orŸ?** [SQLITE_SYNC_FULL].  The first choice is the normal fsync().ŸN** The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]ŸA** flag may be ORed in to indicate that only the data of the fileŸ(** and not its inode needs to be synced.¢**Ÿ9** The integer values to xLock() and xUnlock() are one ofß** <ul>ª** <li> [SQLITE_LOCK_NONE],Ω** <li> [SQLITE_LOCK_SHARED],ø** <li> [SQLITE_LOCK_RESERVED],Ÿ!** <li> [SQLITE_LOCK_PENDING], orŸ ** <li> [SQLITE_LOCK_EXCLUSIVE].®** </ul>Ÿ<** xLock() increases the lock. xUnlock() decreases the lock.ŸJ** The xCheckReservedLock() method checks whether any database connection,ŸJ** either in this process or in some other process, is holding a RESERVED,Ÿ;** PENDING, or EXCLUSIVE lock on the file.  It returns trueŸ-** if such a lock exists and false otherwise.¢**ŸF** The xFileControl() method is a generic interface that allows customŸA** VFS implementations to directly control an open file using theŸF** [sqlite3_file_control()] interface.  The second "op" argument is anŸG** integer opcode.  The third argument is a generic pointer intended toŸG** point to a structure that may contain arguments or space in which toŸC** write return values.  Potential uses for xFileControl() might beŸB** functions to enable blocking locks with timeouts, to change theŸC** locking strategy (for example to use dot-file locks), to inquireŸC** about the status of a lock, or to break stale locks.  The SQLiteŸ;** core reserves all opcodes less than 100 for its own use.ŸI** A [file control opcodes | list of opcodes] less than 100 is available.ŸK** Applications that define a custom xFileControl method should use opcodesŸC** greater than 100 to avoid conflicts.  VFS implementations shouldŸE** return [SQLITE_NOTFOUND] for file control opcodes that they do not≠** recognize.¢**Ÿ:** The xSectorSize() method returns the sector size of theŸ:** device that underlies the file.  The sector size is theŸ9** minimum write that can be performed without disturbingŸ9** other bytes in the file.  The xDeviceCharacteristics()Ÿ:** method returns a bit vector describing behaviors of theµ** underlying device:¢**ß** <ul>Ω** <li> [SQLITE_IOCAP_ATOMIC]Ÿ ** <li> [SQLITE_IOCAP_ATOMIC512]ø** <li> [SQLITE_IOCAP_ATOMIC1K]ø** <li> [SQLITE_IOCAP_ATOMIC2K]ø** <li> [SQLITE_IOCAP_ATOMIC4K]ø** <li> [SQLITE_IOCAP_ATOMIC8K]Ÿ ** <li> [SQLITE_IOCAP_ATOMIC16K]Ÿ ** <li> [SQLITE_IOCAP_ATOMIC32K]Ÿ ** <li> [SQLITE_IOCAP_ATOMIC64K]Ÿ"** <li> [SQLITE_IOCAP_SAFE_APPEND]Ÿ!** <li> [SQLITE_IOCAP_SEQUENTIAL]Ÿ,** <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]Ÿ*** <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]Ÿ ** <li> [SQLITE_IOCAP_IMMUTABLE]Ÿ#** <li> [SQLITE_IOCAP_BATCH_ATOMIC]®** </ul>¢**Ÿ<** The SQLITE_IOCAP_ATOMIC property means that all writes ofŸ:** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn valuesŸ<** mean that writes of blocks that are nnn bytes in size andŸ<** are aligned to an address which is an integer multiple ofŸ<** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value meansŸ=** that when data is appended to a file, the data is appendedŸ?** first then the size of the file is extended, never the otherŸ?** way around.  The SQLITE_IOCAP_SEQUENTIAL property means thatŸ<** information is written to disk in the same order as callsØ** to xWrite().¢**Ÿ?** If xRead() returns SQLITE_IOERR_SHORT_READ it must also fillŸ?** in the unread portions of the buffer with zeros.  A VFS thatŸ?** fails to zero-fill short reads might seem to work.  However,Ÿ;** failure to zero-fill short reads will eventually lead to∑** database corruption.¢*/Ÿ5typedef struct sqlite3_io_methods sqlite3_io_methods;ªstruct sqlite3_io_methods {Ø  int iVersion;ø  int (*xClose)(sqlite3_file*);ŸD  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);ŸK  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);Ÿ6  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);Ÿ)  int (*xSync)(sqlite3_file*, int flags);Ÿ8  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);Ÿ#  int (*xLock)(sqlite3_file*, int);Ÿ%  int (*xUnlock)(sqlite3_file*, int);Ÿ9  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);Ÿ9  int (*xFileControl)(sqlite3_file*, int op, void *pArg);Ÿ$  int (*xSectorSize)(sqlite3_file*);Ÿ/  int (*xDeviceCharacteristics)(sqlite3_file*);Ÿ-  /* Methods above are valid for version 1 */ŸI  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);Ÿ?  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);Ÿ%  void (*xShmBarrier)(sqlite3_file*);Ÿ2  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);Ÿ-  /* Methods above are valid for version 2 */ŸI  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);Ÿ?  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);Ÿ-  /* Methods above are valid for version 3 */Ÿ:  /* Additional methods may be added in future releases */¢};†¢/*Ÿ*** CAPI3REF: Standard File Control OpcodesŸ9** KEYWORDS: {file control opcodes} {file control opcode}¢**ŸB** These integer constants are opcodes for the xFileControl methodŸJ** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]≠** interface.¢**ß** <ul>Ÿ!** <li>[[SQLITE_FCNTL_LOCKSTATE]]ŸC** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  ThisŸF** opcode causes the xFileControl method to write the current state ofŸ=** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],ŸM** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])ŸD** into an integer that the pArg argument points to. This capabilityŸD** is used during testing and is only available when the SQLITE_TESTø** compile-time option is used.¢**Ÿ!** <li>[[SQLITE_FCNTL_SIZE_HINT]]ŸH** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFSŸI** layer a hint of how large the database file will grow to be during theŸJ** current transaction.  This hint is not guaranteed to be accurate but itŸK** is often close.  The underlying VFS might choose to preallocate databaseŸH** file space based on this hint in order to help writes to the database≥** file run faster.¢**Ÿ"** <li>[[SQLITE_FCNTL_CHUNK_SIZE]]ŸG** The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFSŸH** extends and truncates the database file in chunks of a size specifiedŸG** by the user. The fourth argument to [sqlite3_file_control()] should ŸF** point to an integer (type int) containing the new chunk-size to useŸF** for the nominated database. Allocating database file space in largeŸG** chunks (say 1MB at a time), may reduce file-system fragmentation andŸ'** improve performance on some systems.¢**Ÿ$** <li>[[SQLITE_FCNTL_FILE_POINTER]]ŸE** The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointerŸE** to the [sqlite3_file] object associated with a particular databaseŸ8** connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].¢**Ÿ'** <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]ŸH** The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointerŸH** to the [sqlite3_file] object associated with the journal file (eitherŸM** the [rollback journal] or the [write-ahead log]) for a particular databaseŸ5** connection.  See also [SQLITE_FCNTL_FILE_POINTER].¢**Ÿ$** <li>[[SQLITE_FCNTL_SYNC_OMITTED]]¥** No longer in use.¢**º** <li>[[SQLITE_FCNTL_SYNC]]ŸG** The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite andŸF** sent to the VFS immediately before the xSync method is invoked on aŸD** database file descriptor. Or, if the xSync method is not invoked Ÿ/** because the user has configured SQLite with ŸH** [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place ŸG** of the xSync method. In most cases, the pointer argument passed withŸK** this file-control is NULL. However, if the database file is being syncedŸN** as part of a multi-database commit, the argument points to a nul-terminatedŸK** string containing the transactions master-journal file name. VFSes that ŸL** do not need this signal should silently ignore this opcode. Applications ŸM** should not call [sqlite3_file_control()] with this opcode as doing so may ŸG** disrupt the operation of the specialized VFSes that do require it.  ¢**Ÿ'** <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]ŸN** The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLiteŸI** and sent to the VFS after a transaction has been committed immediatelyŸJ** but before the database is unlocked. VFSes that do not need this signalŸC** should silently ignore this opcode. Applications should not callŸI** [sqlite3_file_control()] with this opcode as doing so may disrupt the Ÿ;** operation of the specialized VFSes that do require it.  ¢**Ÿ&** <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]ŸK** ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automaticŸE** retry counts and intervals for certain disk I/O operations for theŸB** windows [VFS] in order to provide robustness in the presence ofŸJ** anti-virus programs.  By default, the windows VFS will retry file read,ŸF** file write, and file delete operations up to 10 times, with a delayŸJ** of 25 milliseconds before the first retry and with the delay increasingŸE** by an additional 25 milliseconds with each subsequent retry.  ThisŸK** opcode allows these two values (10 retries and 25 milliseconds of delay)ŸG** to be adjusted.  The values are changed for all database connectionsŸI** within the same process.  The argument is a pointer to an array of twoŸI** integers where the first integer is the new retry count and the secondŸI** integer is the delay.  If either integer is negative, then the settingŸH** is not changed but instead the prior value of that setting is writtenŸB** into the array entry, allowing the current retry settings to beŸ3** interrogated.  The zDbName parameter is ignored.¢**Ÿ#** <li>[[SQLITE_FCNTL_PERSIST_WAL]]ŸE** ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query theŸI** persistent [WAL | Write Ahead Log] setting.  By default, the auxiliaryŸG** write ahead log and shared memory files used for transaction controlŸG** are automatically deleted when the latest connection to the databaseŸK** closes.  Setting persistent WAL mode causes those files to persist afterŸJ** close.  Persisting the files is useful when other processes that do notŸK** have write permission on the directory containing the database file wantŸK** to read the database file, as the WAL and shared memory files must existŸE** in order for the database to be readable.  The fourth parameter toŸN** [sqlite3_file_control()] for this opcode should be a pointer to an integer.ŸM** That integer is 0 to disable persistent WAL mode or 1 to enable persistentŸK** WAL mode.  If the integer is -1, then it is overwritten with the currentª** WAL persistence setting.¢**Ÿ+** <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]ŸM** ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query theŸH** persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW settingŸ?** determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of theŸ:** xDeviceCharacteristics methods. The fourth parameter toŸN** [sqlite3_file_control()] for this opcode should be a pointer to an integer.ŸK** That integer is 0 to disable zero-damage mode or 1 to enable zero-damageŸG** mode.  If the integer is -1, then it is overwritten with the currentº** zero-damage mode setting.¢**Ÿ!** <li>[[SQLITE_FCNTL_OVERWRITE]]ŸJ** ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after openingŸJ** a write transaction to indicate that, unless it is rolled back for someŸG** reason, the entire database file will be overwritten by the current Ÿ2** transaction. This is used by VACUUM operations.¢**ø** <li>[[SQLITE_FCNTL_VFSNAME]]ŸH** ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names ofŸH** all [VFSes] in the VFS stack.  The names are of all VFS shims and theŸ@** final bottom-level VFS are written into memory obtained from ŸD** [sqlite3_malloc()] and the result is stored in the char* variableŸC** that the fourth parameter of [sqlite3_file_control()] points to.ŸG** The caller is responsible for freeing the memory when done.  As withŸJ** all file-control actions, there is no guarantee that this will actuallyŸG** do anything.  Callers should initialize the char* variable to a NULLŸK** pointer in case this file-control is not implemented.  This file-controlŸ'** is intended for diagnostic use only.¢**Ÿ#** <li>[[SQLITE_FCNTL_VFS_POINTER]]ŸJ** ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-levelŸ1** [VFSes] currently in use.  ^(The argument X inŸ>** sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must beŸ8** of type "[sqlite3_vfs] **".  This opcodes will set *XŸ'** to a pointer to the top-level VFS.)^ŸI** ^When there are multiple VFS shims in the stack, this opcode finds the∏** upper-most shim only.¢**æ** <li>[[SQLITE_FCNTL_PRAGMA]]ŸF** ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA] ŸG** file control is sent to the open [sqlite3_file] object correspondingŸK** to the database file to which the pragma statement refers. ^The argumentŸ;** to the [SQLITE_FCNTL_PRAGMA] file control is an array ofŸH** pointers to strings (char**) in which the second element of the arrayŸI** is the name of the pragma and the third element is the argument to theŸE** pragma or NULL if the pragma has no argument.  ^The handler for anŸK** [SQLITE_FCNTL_PRAGMA] file control can optionally make the first elementŸM** of the char** argument point to a string obtained from [sqlite3_mprintf()]ŸL** or the equivalent and that string will become the result of the pragma orŸ1** the error message if the pragma fails. ^If theŸM** [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal Ÿ@** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]ŸE** file control returns [SQLITE_OK], then the parser assumes that theŸE** VFS has handled the PRAGMA itself and the parser generates a no-opŸF** prepared statement if result string is NULL, or that returns a copyŸ2** of the result string if the string is non-NULL.Ÿ5** ^If the [SQLITE_FCNTL_PRAGMA] file control returnsŸJ** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that meansŸH** that the VFS encountered an error while handling the [PRAGMA] and theŸM** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]ŸK** file control occurs at the beginning of pragma statement analysis and soŸ7** it is able to override built-in [PRAGMA] statements.¢**Ÿ#** <li>[[SQLITE_FCNTL_BUSYHANDLER]]Ÿ"** ^The [SQLITE_FCNTL_BUSYHANDLER]ŸD** file-control may be invoked by SQLite on the database file handleŸJ** shortly after it is opened in order to provide a custom VFS with accessŸN** to the connections busy-handler callback. The argument is of type (void **)ŸH** - an array of two (void *) values. The first (void *) actually pointsŸN** to a function of type (int (*)(void *)). In order to invoke the connectionsŸL** busy-handler, this function should be invoked with the second (void *) inŸM** the array as the only argument. If it returns non-zero, then the operationŸK** should be retried. If it returns zero, the custom VFS should abandon theµ** current operation.¢**Ÿ$** <li>[[SQLITE_FCNTL_TEMPFILENAME]]ŸG** ^Application can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-controlº** to have SQLite generate aŸK** temporary filename using the same algorithm that is followed to generateŸD** temporary filenames for TEMP tables and other internal uses.  TheŸE** argument should be a char** which will be filled with the filenameŸK** written into memory obtained from [sqlite3_malloc()].  The caller shouldŸ@** invoke [sqlite3_free()] on the result to avoid a memory leak.¢**Ÿ!** <li>[[SQLITE_FCNTL_MMAP_SIZE]]ŸH** The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set theŸC** maximum number of bytes that will be used for memory-mapped I/O.ŸB** The argument is a pointer to a value of type sqlite3_int64 thatŸI** is an advisory maximum number of bytes in the file to memory map.  TheŸJ** pointer is overwritten with the old value.  The limit is not changed ifŸI** the value originally pointed to is negative, and so the current limit ŸE** can be queried by passing in a pointer to a negative number.  ThisŸC** file-control is used internally to implement [PRAGMA mmap_size].¢**Ω** <li>[[SQLITE_FCNTL_TRACE]]ŸF** The [SQLITE_FCNTL_TRACE] file control provides advisory informationŸI** to the VFS about what the higher layers of the SQLite stack are doing.ŸB** This file control is used by some VFS activity tracing [shims].ŸB** The argument is a zero-terminated string.  Higher layers in theŸ>** SQLite stack may generate instances of this file control ifŸ?** the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.¢**Ÿ!** <li>[[SQLITE_FCNTL_HAS_MOVED]]ŸI** The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as aŸL** pointer to an integer and it writes a boolean into that integer dependingŸJ** on whether or not the file has been renamed, moved, or deleted since it¥** was first opened.¢**Ÿ(** <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]ŸG** The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain theŸJ** underlying native file handle associated with a file handle.  This fileŸK** control interprets its argument as a pointer to a native file handle andŸ$** writes the resulting value there.¢**Ÿ(** <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]ŸJ** The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  ThisŸM** opcode causes the xFileControl method to swap the file handle with the oneŸK** pointed to by the pArg argument.  This capability is used during testingŸ>** and only needs to be supported when SQLITE_TEST is defined.¢**Ÿ!** <li>[[SQLITE_FCNTL_WAL_BLOCK]]ŸJ** The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it mightŸO** be advantageous to block on the next WAL lock if the lock is not immediatelyŸ?** available.  The WAL subsystem issues this signal during rareŸC** circumstances in order to fix a problem with priority inversion.Ÿ:** Applications should <em>not</em> use this file-control.¢**æ** <li>[[SQLITE_FCNTL_ZIPVFS]]ŸL** The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All otherŸ5** VFS should return SQLITE_NOTFOUND for this opcode.¢**ª** <li>[[SQLITE_FCNTL_RBU]]ŸJ** The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used byŸK** the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for±** this opcode.  ¢**Ÿ*** <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]ŸJ** If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, thenŸ=** the file descriptor is placed in "batch write mode", whichŸB** means all subsequent write operations will be deferred and doneŸF** atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  SystemsŸG** that do not support batch atomic writes will return SQLITE_NOTFOUND.ŸG** ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior toŸ4** the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] orŸ9** [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will makeŸD** no VFS interface calls on the same [sqlite3_file] file descriptorŸD** except for calls to the xWrite method and the xFileControl methodŸ!** with [SQLITE_FCNTL_SIZE_HINT].¢**Ÿ+** <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]ŸA** The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all writeŸ4** operations since the previous successful call to Ÿ@** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.ŸG** This file control returns [SQLITE_OK] if and only if the writes wereŸL** all performed successfully and have been committed to persistent storage.ŸJ** ^Regardless of whether or not it is successful, this file control takesŸE** the file descriptor out of batch write mode so that all subsequentŸ$** write operations are independent.ŸE** ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE withoutŸ@** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].¢**Ÿ-** <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]ŸC** The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all writeŸ4** operations since the previous successful call to Ÿ7** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.ŸG** ^This file control takes the file descriptor out of batch write modeŸ;** so that all subsequent write operations are independent.ŸG** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE withoutŸ@** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].¢**Ÿ$** <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]ŸC** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode causes attempts to obtainŸE** a file lock using the xLock or xShmLock methods of the VFS to waitŸB** for up to M milliseconds before failing, where M is the single æ** unsigned integer parameter.®** </ul>¢*/Ÿ.#define SQLITE_FCNTL_LOCKSTATE               1Ÿ.#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2Ÿ.#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3Ÿ.#define SQLITE_FCNTL_LAST_ERRNO              4Ÿ.#define SQLITE_FCNTL_SIZE_HINT               5Ÿ.#define SQLITE_FCNTL_CHUNK_SIZE              6Ÿ.#define SQLITE_FCNTL_FILE_POINTER            7Ÿ.#define SQLITE_FCNTL_SYNC_OMITTED            8Ÿ.#define SQLITE_FCNTL_WIN32_AV_RETRY          9Ÿ.#define SQLITE_FCNTL_PERSIST_WAL            10Ÿ.#define SQLITE_FCNTL_OVERWRITE              11Ÿ.#define SQLITE_FCNTL_VFSNAME                12Ÿ.#define SQLITE_FCNTL_POWERSAFE_OVERWRITE    13Ÿ.#define SQLITE_FCNTL_PRAGMA                 14Ÿ.#define SQLITE_FCNTL_BUSYHANDLER            15Ÿ.#define SQLITE_FCNTL_TEMPFILENAME           16Ÿ.#define SQLITE_FCNTL_MMAP_SIZE              18Ÿ.#define SQLITE_FCNTL_TRACE                  19Ÿ.#define SQLITE_FCNTL_HAS_MOVED              20Ÿ.#define SQLITE_FCNTL_SYNC                   21Ÿ.#define SQLITE_FCNTL_COMMIT_PHASETWO        22Ÿ.#define SQLITE_FCNTL_WIN32_SET_HANDLE       23Ÿ.#define SQLITE_FCNTL_WAL_BLOCK              24Ÿ.#define SQLITE_FCNTL_ZIPVFS                 25Ÿ.#define SQLITE_FCNTL_RBU                    26Ÿ.#define SQLITE_FCNTL_VFS_POINTER            27Ÿ.#define SQLITE_FCNTL_JOURNAL_POINTER        28Ÿ.#define SQLITE_FCNTL_WIN32_GET_HANDLE       29Ÿ.#define SQLITE_FCNTL_PDB                    30Ÿ.#define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE     31Ÿ.#define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE    32Ÿ.#define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33Ÿ.#define SQLITE_FCNTL_LOCK_TIMEOUT           34†∂/* deprecated names */ŸD#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILEŸD#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILEŸ=#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO††¢/*π** CAPI3REF: Mutex Handle¢**ŸB** The mutex module within SQLite defines [sqlite3_mutex] to be anŸA** abstract type for a mutex object.  The SQLite core never looksŸA** at the internal representation of an [sqlite3_mutex].  It onlyŸ5** deals with pointers to the [sqlite3_mutex] object.¢**Ÿ5** Mutexes are created using [sqlite3_mutex_alloc()].¢*/Ÿ+typedef struct sqlite3_mutex sqlite3_mutex;†¢/*Ÿ%** CAPI3REF: Loadable Extension Thunk¢**ŸF** A pointer to the opaque sqlite3_api_routines structure is passed asŸF** the third parameter to entry points of [loadable extensions].  ThisŸH** structure must be typedefed in order to work around compiler warningsµ** on some platforms.¢*/Ÿ9typedef struct sqlite3_api_routines sqlite3_api_routines;†¢/*Ÿ ** CAPI3REF: OS Interface Object¢**ŸF** An instance of the sqlite3_vfs object defines the interface betweenŸB** the SQLite core and the underlying operating system.  The "vfs"ŸC** in the name of the object stands for "virtual file system".  SeeŸ9** the [VFS | VFS documentation] for further information.¢**ŸE** The VFS interface is sometimes extended by adding new methods ontoŸC** the end.  Each time such an extension occurs, the iVersion fieldŸ:** is incremented.  The iVersion value started out as 1 inŸ@** SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2ŸD** with SQLite [version 3.7.0] on [dateof:3.7.0], and then increasedŸI** to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fieldsŸC** may be appended to the sqlite3_vfs object and the iVersion valueŸ3** may increase again in future versions of SQLite.∫** Note that the structureŸ;** of the sqlite3_vfs object changes in the transition fromŸ>** SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]Ÿ/** and yet the iVersion field was not modified.¢**ŸB** The szOsFile field is the size of the subclassed [sqlite3_file]ŸC** structure used by this VFS.  mxPathname is the maximum length of∫** a pathname in this VFS.¢**ŸE** Registered sqlite3_vfs objects are kept on a linked list formed byŸ3** the pNext pointer.  The [sqlite3_vfs_register()]Ÿ=** and [sqlite3_vfs_unregister()] interfaces manage this listŸ<** in a thread-safe way.  The [sqlite3_vfs_find()] interfaceŸ?** searches the list.  Neither the application code nor the VFSŸ/** implementation should use the pNext pointer.¢**Ÿ7** The pNext field is the only field in the sqlite3_vfsŸC** structure that SQLite will ever modify.  SQLite will only accessŸ@** or modify this field while holding a particular static mutex.ŸF** The application should never modify anything within the sqlite3_vfsŸ.** object once the object has been registered.¢**ŸC** The zName field holds the name of the VFS module.  The name mustŸ$** be unique across all VFS modules.¢**∏** [[sqlite3_vfs.xOpen]]Ÿ;** ^SQLite guarantees that the zFilename parameter to xOpenŸ.** is either a NULL pointer or string obtainedŸ6** from xFullPathname() with an optional suffix added.Ÿ<** ^If a suffix is added to the zFilename parameter, it willŸ=** consist of a single "-" character followed by no more thanŸ)** 11 alphanumeric and/or "-" characters.Ÿ"** ^SQLite further guarantees thatŸ;** the string will be valid and unchanged until xClose() isŸ,** called. Because of the previous sentence,Ÿ7** the [sqlite3_file] can safely store a pointer to theŸA** filename if it needs to remember the filename for some reason.ŸC** If the zFilename parameter to xOpen is a NULL pointer then xOpenŸC** must invent its own temporary name for the file.  ^Whenever the Ÿ@** xFilename parameter is NULL it will also be the case that theŸ<** flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].¢**Ÿ9** The flags argument to xOpen() includes all bits set inŸE** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]Ÿ>** or [sqlite3_open16()] is used, then flags includes at leastŸ3** [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]. Ÿ?** If xOpen() opens a file read-only then it sets *pOutFlags toŸH** include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.¢**ŸC** ^(SQLite will also add one of the following flags to the xOpen()Ÿ.** call, depending on the object being opened:¢**ß** <ul>æ** <li>  [SQLITE_OPEN_MAIN_DB]Ÿ#** <li>  [SQLITE_OPEN_MAIN_JOURNAL]æ** <li>  [SQLITE_OPEN_TEMP_DB]Ÿ#** <li>  [SQLITE_OPEN_TEMP_JOURNAL]Ÿ#** <li>  [SQLITE_OPEN_TRANSIENT_DB]Ÿ!** <li>  [SQLITE_OPEN_SUBJOURNAL]Ÿ%** <li>  [SQLITE_OPEN_MASTER_JOURNAL]∫** <li>  [SQLITE_OPEN_WAL]™** </ul>)^¢**Ÿ?** The file I/O implementation can use the object type flags toŸC** change the way it deals with files.  For example, an applicationŸA** that does not care about crash recovery or rollback might makeŸD** the open of a journal file a no-op.  Writes to this journal wouldŸC** also be no-ops, and any attempt to read the journal would returnŸG** SQLITE_IOERR.  Or the implementation might recognize that a databaseŸF** file will be doing page-aligned sector reads and writes in a randomŸ2** order and set up its I/O subsystem accordingly.¢**ŸH** SQLite might also add one of the following flags to the xOpen method:¢**ß** <ul>Ÿ#** <li> [SQLITE_OPEN_DELETEONCLOSE]ø** <li> [SQLITE_OPEN_EXCLUSIVE]®** </ul>¢**Ÿ@** The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should beŸ?** deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]Ÿ?** will be set for TEMP databases and their journals, transientæ** databases, and subjournals.¢**ŸB** ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunctionŸ>** with the [SQLITE_OPEN_CREATE] flag, which are both directlyŸ@** analogous to the O_EXCL and O_CREAT flags of the POSIX open()Ÿ>** API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the ŸB** SQLITE_OPEN_CREATE, is used to indicate that file should alwaysŸ<** be created, and that it is an error if it already exists.Ÿ?** It is <i>not</i> used to indicate the file should be opened ∏** for exclusive access.¢**Ÿ=** ^At least szOsFile bytes of memory are allocated by SQLiteŸ<** to hold the  [sqlite3_file] structure passed as the thirdŸ8** argument to xOpen.  The xOpen method does not have toŸ@** allocate the structure; it should just fill it in.  Note thatŸ@** the xOpen method must set the sqlite3_file.pMethods to eitherŸA** a valid [sqlite3_io_methods] object or to NULL.  xOpen must doŸN** this even if the open fails.  SQLite expects that the sqlite3_file.pMethodsŸF** element will be valid after xOpen returns regardless of the successŸ ** or failure of the xOpen call.¢**∫** [[sqlite3_vfs.xAccess]]ŸA** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]ŸG** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] toŸH** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]ŸC** to test whether a file is at least readable.   The file can be a≠** directory.¢**ŸC** ^SQLite will always allocate at least mxPathname+1 bytes for theŸD** output buffer xFullPathname.  The exact size of the output bufferŸG** is also passed as a parameter to both  methods. If the output bufferŸK** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this isŸJ** handled as a fatal error by SQLite, vfs implementations should endeavorŸG** to prevent this by setting mxPathname to a sufficiently large value.¢**ŸG** The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()ŸE** interfaces are not strictly a part of the filesystem, but they areŸ2** included in the VFS structure for completeness.Ÿ=** The xRandomness() function attempts to return nBytes bytesŸ=** of good-quality randomness into zOut.  The return value isŸ5** the actual number of bytes of randomness obtained.Ÿ@** The xSleep() method causes the calling thread to sleep for atŸ?** least the number of microseconds given.  ^The xCurrentTime()ŸF** method returns a Julian Day Number for the current date and time as∫** a floating point value.ŸE** ^The xCurrentTimeInt64() method returns, as an integer, the JulianŸD** Day Number multiplied by 86400000 (the number of milliseconds in ¥** a 24-hour day).  ŸE** ^SQLite will use the xCurrentTimeInt64() method to get the currentŸB** date and time if that method is available (if iVersion is 2 or ŸC** greater and the function pointer is not NULL) and will fall backŸ;** to xCurrentTime() if xCurrentTimeInt64() is unavailable.¢**ŸL** ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfacesŸK** are not used by the SQLite core.  These optional interfaces are providedŸF** by some VFSes to facilitate testing of the VFS code. By overriding ŸD** system calls with functions under its control, a test program canŸI** simulate faults and error conditions that would otherwise be difficultŸK** or impossible to induce.  The set of system calls that can be overriddenŸN** varies from one VFS to another, and from one version of the same VFS to theŸI** next.  Applications that use these interfaces must be prepared for anyŸH** or all of these interfaces to be NULL or for their behavior to changeŸI** from one release to the next.  Applications must not attempt to accessŸB** any of these methods if the iVersion of the VFS is less than 3.¢*/Ÿ'typedef struct sqlite3_vfs sqlite3_vfs;Ÿ*typedef void (*sqlite3_syscall_ptr)(void);¥struct sqlite3_vfs {ŸG  int iVersion;            /* Structure version number (currently 3) */Ÿ@  int szOsFile;            /* Size of subclassed sqlite3_file */Ÿ=  int mxPathname;          /* Maximum file pathname length */Ÿ4  sqlite3_vfs *pNext;      /* Next registered VFS */ŸA  const char *zName;       /* Name of this virtual file system */ŸE  void *pAppData;          /* Pointer to application-specific data */Ÿ>  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,Ÿ*               int flags, int *pOutFlags);Ÿ?  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);ŸK  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);ŸN  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);Ÿ8  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);Ÿ;  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);ŸC  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);Ÿ(  void (*xDlClose)(sqlite3_vfs*, void*);Ÿ:  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);Ÿ0  int (*xSleep)(sqlite3_vfs*, int microseconds);Ÿ-  int (*xCurrentTime)(sqlite3_vfs*, double*);Ÿ2  int (*xGetLastError)(sqlite3_vfs*, int, char *);§  /*Ÿ@  ** The methods above are in version 1 of the sqlite_vfs objectŸC  ** definition.  Those that follow are added in version 2 or later§  */Ÿ9  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);§  /*ŸH  ** The methods above are in versions 1 and 2 of the sqlite_vfs object.Ÿ/  ** Those below are for version 3 and greater.§  */ŸN  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);ŸI  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);ŸB  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);§  /*ŸL  ** The methods above are in versions 1 through 3 of the sqlite_vfs object.ŸA  ** New fields may be appended in future versions.  The iVersionŸ1  ** value will increment whenever this happens. §  */¢};†¢/*Ÿ-** CAPI3REF: Flags for the xAccess VFS method¢**Ÿ@** These integer constants can be used as the third parameter toŸA** the xAccess method of an [sqlite3_vfs] object.  They determineŸ>** what kind of permissions the xAccess method is looking for.Ÿ0** With SQLITE_ACCESS_EXISTS, the xAccess methodŸ)** simply checks whether the file exists.Ÿ3** With SQLITE_ACCESS_READWRITE, the xAccess methodŸC** checks whether the named directory is both readable and writableŸF** (in other words, if files can be added, removed, and renamed within≤** the directory).ŸE** The SQLITE_ACCESS_READWRITE constant is currently used only by theŸF** [temp_store_directory pragma], though this could change in a futureµ** release of SQLite.Ÿ.** With SQLITE_ACCESS_READ, the xAccess methodŸK** checks whether the file is readable.  The SQLITE_ACCESS_READ constant isŸC** currently unused, though it might be used in a future release of™** SQLite.¢*/Ÿ!#define SQLITE_ACCESS_EXISTS    0ŸM#define SQLITE_ACCESS_READWRITE 1   /* Used by PRAGMA temp_store_directory */Ÿ0#define SQLITE_ACCESS_READ      2   /* Unused */†¢/*Ÿ.** CAPI3REF: Flags for the xShmLock VFS method¢**Ÿ@** These integer constants define the various locking operationsŸ?** allowed by the xShmLock method of [sqlite3_io_methods].  TheŸ<** following are the only legal combinations of flags to the≥** xShmLock method:¢**ß** <ul>Ÿ,** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_SHAREDŸ/** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVEŸ.** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_SHAREDŸ1** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE®** </ul>¢**ŸH** When unlocking, the same SHARED or EXCLUSIVE flag must be supplied asŸ)** was given on the corresponding lock.  ¢**ŸD** The xShmLock method can transition between unlocked and SHARED orŸG** between unlocked and EXCLUSIVE.  It cannot transition between SHARED±** and EXCLUSIVE.¢*/Ÿ!#define SQLITE_SHM_UNLOCK       1Ÿ!#define SQLITE_SHM_LOCK         2Ÿ!#define SQLITE_SHM_SHARED       4Ÿ!#define SQLITE_SHM_EXCLUSIVE    8†¢/*Ÿ#** CAPI3REF: Maximum xShmLock index¢**Ÿ=** The xShmLock method on [sqlite3_io_methods] may use valuesŸ;** between 0 and this upper bound as its "offset" argument.Ÿ=** The SQLite core will never attempt to acquire or release aΩ** lock outside of this range¢*/Ÿ!#define SQLITE_SHM_NLOCK        8††¢/*Ÿ*** CAPI3REF: Initialize The SQLite Library¢**Ÿ4** ^The sqlite3_initialize() routine initializes theŸ3** SQLite library.  ^The sqlite3_shutdown() routineŸI** deallocates any resources that were allocated by sqlite3_initialize().ŸC** These routines are designed to aid in process initialization andŸ@** shutdown on embedded systems.  Workstation applications usingŸB** SQLite normally do not need to invoke either of these routines.¢**ŸA** A call to sqlite3_initialize() is an "effective" call if it isŸH** the first time sqlite3_initialize() is invoked during the lifetime ofŸJ** the process, or if it is the first time sqlite3_initialize() is invokedŸD** following a call to sqlite3_shutdown().  ^(Only an effective callŸD** of sqlite3_initialize() does any initialization.  All other callsπ** are harmless no-ops.)^¢**ŸI** A call to sqlite3_shutdown() is an "effective" call if it is the firstŸJ** call to sqlite3_shutdown() since the last sqlite3_initialize().  ^(OnlyŸE** an effective call to sqlite3_shutdown() does any deinitialization.ŸE** All other valid calls to sqlite3_shutdown() are harmless no-ops.)^¢**ŸK** The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown()ŸG** is not.  The sqlite3_shutdown() interface must only be called from aŸI** single thread.  All open [database connections] must be closed and allŸ?** other SQLite resources must be deallocated prior to invoking∂** sqlite3_shutdown().¢**Ÿ8** Among other things, ^sqlite3_initialize() will invokeŸ5** sqlite3_os_init().  Similarly, ^sqlite3_shutdown()Ÿ ** will invoke sqlite3_os_end().¢**ŸD** ^The sqlite3_initialize() routine returns [SQLITE_OK] on success.ŸD** ^If for some reason, sqlite3_initialize() is unable to initializeŸG** the library (perhaps it is unable to allocate a needed resource suchŸA** as a mutex) it returns an [error code] other than [SQLITE_OK].¢**ŸG** ^The sqlite3_initialize() routine is called internally by many otherŸD** SQLite interfaces so that an application usually does not need toŸG** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]ŸI** calls sqlite3_initialize() so the SQLite library will be automaticallyŸK** initialized when [sqlite3_open()] is called if it has not be initializedŸL** already.  ^However, if SQLite is compiled with the [SQLITE_OMIT_AUTOINIT]ŸH** compile-time option, then the automatic calls to sqlite3_initialize()ŸJ** are omitted and the application must call sqlite3_initialize() directlyŸG** prior to using any other SQLite interface.  For maximum portability,ŸI** it is recommended that applications always invoke sqlite3_initialize()ŸG** directly prior to using any other SQLite interface.  Future releasesŸF** of SQLite may require this.  In other words, the behavior exhibitedŸG** when SQLite is compiled with [SQLITE_OMIT_AUTOINIT] might become theŸ5** default behavior in some future release of SQLite.¢**Ÿ?** The sqlite3_os_init() routine does operating-system specificŸ>** initialization of the SQLite library.  The sqlite3_os_end()ŸA** routine undoes the effect of sqlite3_os_init().  Typical tasksŸA** performed by these routines include allocation or deallocationŸ;** of static resources, initialization of global variables,Ÿ;** setting up a default [sqlite3_vfs] module, or setting upŸ4** a default configuration using [sqlite3_config()].¢**Ÿ?** The application should never invoke either sqlite3_os_init()ŸD** or sqlite3_os_end() directly.  The application should only invokeŸF** sqlite3_initialize() and sqlite3_shutdown().  The sqlite3_os_init()Ÿ@** interface is called automatically by sqlite3_initialize() andŸA** sqlite3_os_end() is called by sqlite3_shutdown().  AppropriateŸ=** implementations for sqlite3_os_init() and sqlite3_os_end()ŸH** are built into SQLite when it is compiled for Unix, Windows, or OS/2.Ÿ3** When [custom builds | built for other platforms]Ÿ.** (using the [SQLITE_OS_OTHER=1] compile-timeŸD** option) the application must supply a suitable implementation forŸC** sqlite3_os_init() and sqlite3_os_end().  An application-suppliedŸ:** implementation of sqlite3_os_init() or sqlite3_os_end()ŸF** must return [SQLITE_OK] on success and some other [error code] upon´** failure.¢*/Ÿ(SQLITE_API int sqlite3_initialize(void);Ÿ&SQLITE_API int sqlite3_shutdown(void);Ÿ%SQLITE_API int sqlite3_os_init(void);Ÿ$SQLITE_API int sqlite3_os_end(void);†¢/*Ÿ+** CAPI3REF: Configuring The SQLite Library¢**ŸF** The sqlite3_config() interface is used to make global configurationŸE** changes to SQLite in order to tune SQLite to the specific needs ofŸF** the application.  The default configuration is recommended for mostŸD** applications and so this routine is usually not necessary.  It isŸ<** provided to support rare applications with unusual needs.¢**ŸG** <b>The sqlite3_config() interface is not threadsafe. The applicationŸC** must ensure that no other SQLite interfaces are invoked by otherŸ1** threads while sqlite3_config() is running.</b>¢**Ÿ!** The sqlite3_config() interfaceŸ<** may only be invoked prior to library initialization usingŸD** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].ŸI** ^If sqlite3_config() is called after [sqlite3_initialize()] and beforeŸ:** [sqlite3_shutdown()] then it will return SQLITE_MISUSE.ŸE** Note, however, that ^sqlite3_config() can be called as part of theŸ@** implementation of an application-defined [sqlite3_os_init()].¢**Ÿ7** The first argument to sqlite3_config() is an integerŸ)** [configuration option] that determinesŸE** what property of SQLite is to be configured.  Subsequent argumentsŸ/** vary depending on the [configuration option]π** in the first argument.¢**ŸM** ^When a configuration option is set, sqlite3_config() returns [SQLITE_OK].ŸB** ^If the option is unknown or SQLite is unable to set the optionŸ5** then this routine returns a non-zero [error code].¢*/Ÿ(SQLITE_API int sqlite3_config(int, ...);†¢/*Ÿ+** CAPI3REF: Configure database connections≤** METHOD: sqlite3¢**ŸB** The sqlite3_db_config() interface is used to make configurationŸC** changes to a [database connection].  The interface is similar toŸ?** [sqlite3_config()] except that the changes apply to a singleŸ;** [database connection] (specified in the first argument).¢**Ÿ<** The second argument to sqlite3_db_config(D,V,...)  is theŸF** [SQLITE_DBCONFIG_LOOKASIDE | configuration verb] - an integer code ŸO** that indicates what aspect of the [database connection] is being configured.ŸA** Subsequent arguments vary depending on the configuration verb.¢**Ÿ@** ^Calls to sqlite3_db_config() return SQLITE_OK if and only ifŸ%** the call is considered successful.¢*/Ÿ8SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);†¢/*Ÿ'** CAPI3REF: Memory Allocation Routines¢**ŸB** An instance of this object defines the interface between SQLiteŸ,** and low-level memory allocation routines.¢**ŸA** This object is used in only one place in the SQLite interface.Ÿ=** A pointer to an instance of this object is the argument toŸ6** [sqlite3_config()] when the configuration option isŸ9** [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].  Ÿ)** By creating an instance of this objectŸ=** and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])ŸB** during configuration, an application can specify an alternativeŸ?** memory allocation subsystem for SQLite to use for all of its∏** dynamic memory needs.¢**ŸC** Note that SQLite comes with several [built-in memory allocators]ŸL** that are perfectly adequate for the overwhelming majority of applicationsŸI** and that this object is only useful to a tiny minority of applicationsŸC** with specialized memory allocation requirements.  This object isŸH** also used during testing of SQLite in order to specify an alternativeŸE** memory allocator that simulates memory out-of-memory conditions inŸ<** order to verify that SQLite recovers gracefully from suchÆ** conditions.¢**Ÿ>** The xMalloc, xRealloc, and xFree methods must work like theŸH** malloc(), realloc() and free() functions from the standard C library.Ÿ1** ^SQLite guarantees that the second argument toŸC** xRealloc is always a value returned by a prior call to xRoundup.¢**Ÿ@** xSize should return the allocated size of a memory allocationŸD** previously obtained from xMalloc or xRealloc.  The allocated sizeŸE** is always at least as big as the requested size but may be larger.¢**ŸB** The xRoundup method returns what would be the allocated size ofŸF** a memory allocation given a particular requested size.  Most memoryŸG** allocators round up memory allocations at least to the next multipleŸK** of 8.  Some allocators round up to a larger multiple or to a power of 2.ŸG** Every memory allocation request coming in through [sqlite3_malloc()]ŸH** or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0, Ÿ;** that causes the corresponding memory allocation to fail.¢**ŸC** The xInit method initializes the memory allocator.  For example,ŸD** it might allocate any require mutexes or initialize internal dataŸ?** structures.  The xShutdown method is invoked (indirectly) byŸD** [sqlite3_shutdown()] and should deallocate any resources acquiredŸC** by xInit.  The pAppData pointer is used as the only parameter to∑** xInit and xShutdown.¢**ŸF** SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokesŸE** the xInit method, so the xInit method need not be threadsafe.  TheŸG** xShutdown method is only called from [sqlite3_shutdown()] so it doesŸC** not need to be threadsafe either.  For all other methods, SQLiteŸ;** holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as theŸE** [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (whichŸE** it is by default) and so the methods are automatically serialized.ŸD** However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the otherŸE** methods must be threadsafe or else make their own arrangements for±** serialization.¢**ŸI** SQLite will never invoke xInit() more than once without an intervening∑** call to xShutdown().¢*/Ÿ7typedef struct sqlite3_mem_methods sqlite3_mem_methods;ºstruct sqlite3_mem_methods {ŸA  void *(*xMalloc)(int);         /* Memory allocation function */Ÿ>  void (*xFree)(void*);          /* Free a prior allocation */Ÿ;  void *(*xRealloc)(void*,int);  /* Resize an allocation */ŸG  int (*xSize)(void*);           /* Return the size of an allocation */ŸO  int (*xRoundup)(int);          /* Round up request size to allocation size */ŸF  int (*xInit)(void*);           /* Initialize the memory allocator */ŸH  void (*xShutdown)(void*);      /* Deinitialize the memory allocator */ŸJ  void *pAppData;                /* Argument to xInit() and xShutdown() */¢};†¢/*Ÿ"** CAPI3REF: Configuration OptionsŸ#** KEYWORDS: {configuration option}¢**ŸG** These constants are the available integer configuration options thatŸK** can be passed as the first argument to the [sqlite3_config()] interface.¢**ŸG** New configuration options may be added in future releases of SQLite.ŸF** Existing configuration options might be discontinued.  ApplicationsŸI** should check the return code from [sqlite3_config()] to make sure thatŸC** the call worked.  The [sqlite3_config()] interface will return aŸN** non-zero [error code] if a discontinued or unsupported configuration optionÆ** is invoked.¢**ß** <dl>ŸE** [[SQLITE_CONFIG_SINGLETHREAD]] <dt>SQLITE_CONFIG_SINGLETHREAD</dt>ŸD** <dd>There are no arguments to this option.  ^This option sets theŸB** [threading mode] to Single-thread.  In other words, it disablesŸE** all mutexing and puts SQLite into a mode where it can only be usedŸ4** by a single thread.   ^If SQLite is compiled withŸI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenŸE** it is not possible to change the [threading mode] from its defaultŸ@** value of Single-thread and so [sqlite3_config()] will return Ÿ?** [SQLITE_ERROR] if called with the SQLITE_CONFIG_SINGLETHREADΩ** configuration option.</dd>¢**ŸC** [[SQLITE_CONFIG_MULTITHREAD]] <dt>SQLITE_CONFIG_MULTITHREAD</dt>ŸD** <dd>There are no arguments to this option.  ^This option sets theŸA** [threading mode] to Multi-thread.  In other words, it disablesŸF** mutexing on [database connection] and [prepared statement] objects.Ÿ;** The application is responsible for serializing access toŸG** [database connections] and [prepared statements].  But other mutexesŸE** are enabled so that SQLite will be safe to use in a multi-threadedŸ@** environment as long as no two threads attempt to use the sameŸG** [database connection] at the same time.  ^If SQLite is compiled withŸI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenŸB** it is not possible to set the Multi-thread [threading mode] andŸC** [sqlite3_config()] will return [SQLITE_ERROR] if called with theŸ7** SQLITE_CONFIG_MULTITHREAD configuration option.</dd>¢**ŸA** [[SQLITE_CONFIG_SERIALIZED]] <dt>SQLITE_CONFIG_SERIALIZED</dt>ŸD** <dd>There are no arguments to this option.  ^This option sets theŸF** [threading mode] to Serialized. In other words, this option enablesŸ&** all mutexes including the recursiveŸE** mutexes on [database connection] and [prepared statement] objects.ŸB** In this mode (which is the default when SQLite is compiled withŸI** [SQLITE_THREADSAFE=1]) the SQLite library will itself serialize accessŸB** to [database connections] and [prepared statements] so that theŸC** application is free to use the same [database connection] or theŸC** same [prepared statement] in different threads at the same time.æ** ^If SQLite is compiled withŸI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenŸ@** it is not possible to set the Serialized [threading mode] andŸC** [sqlite3_config()] will return [SQLITE_ERROR] if called with theŸ6** SQLITE_CONFIG_SERIALIZED configuration option.</dd>¢**Ÿ9** [[SQLITE_CONFIG_MALLOC]] <dt>SQLITE_CONFIG_MALLOC</dt>ŸK** <dd> ^(The SQLITE_CONFIG_MALLOC option takes a single argument which is ŸC** a pointer to an instance of the [sqlite3_mem_methods] structure.π** The argument specifiesŸJ** alternative low-level memory allocation routines to be used in place ofŸD** the memory allocation routines built into SQLite.)^ ^SQLite makesŸM** its own private copy of the content of the [sqlite3_mem_methods] structureŸ3** before the [sqlite3_config()] call returns.</dd>¢**Ÿ?** [[SQLITE_CONFIG_GETMALLOC]] <dt>SQLITE_CONFIG_GETMALLOC</dt>ŸJ** <dd> ^(The SQLITE_CONFIG_GETMALLOC option takes a single argument whichŸF** is a pointer to an instance of the [sqlite3_mem_methods] structure.º** The [sqlite3_mem_methods]ŸO** structure is filled with the currently defined memory allocation routines.)^ŸD** This option can be used to overload the default memory allocationŸH** routines with a wrapper that simulations memory allocation failure orŸ*** tracks memory usage, for example. </dd>¢**ŸE** [[SQLITE_CONFIG_SMALL_MALLOC]] <dt>SQLITE_CONFIG_SMALL_MALLOC</dt>ŸG** <dd> ^The SQLITE_CONFIG_SMALL_MALLOC option takes single argument ofŸG** type int, interpreted as a boolean, which if true provides a hint toŸD** SQLite that it should avoid large memory allocations if possible.ŸI** SQLite will run faster if it is free to make large memory allocations,ŸB** but some application might prefer to run slower in exchange forŸC** guarantees about memory fragmentation that are possible if largeŸ7** allocations are avoided.  This hint is normally off.®** </dd>¢**Ÿ?** [[SQLITE_CONFIG_MEMSTATUS]] <dt>SQLITE_CONFIG_MEMSTATUS</dt>ŸN** <dd> ^The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int,ŸH** interpreted as a boolean, which enables or disables the collection ofŸH** memory allocation statistics. ^(When memory allocation statistics areŸD** disabled, the following SQLite interfaces become non-operational:©**   <ul>Ÿ!**   <li> [sqlite3_memory_used()]Ÿ&**   <li> [sqlite3_memory_highwater()]Ÿ'**   <li> [sqlite3_soft_heap_limit64()]æ**   <li> [sqlite3_status64()]¨**   </ul>)^ŸH** ^Memory allocation statistics are enabled by default unless SQLite isŸB** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memoryŸ1** allocation statistics are disabled by default.®** </dd>¢**Ÿ;** [[SQLITE_CONFIG_SCRATCH]] <dt>SQLITE_CONFIG_SCRATCH</dt>Ÿ;** <dd> The SQLITE_CONFIG_SCRATCH option is no longer used.®** </dd>¢**Ÿ?** [[SQLITE_CONFIG_PAGECACHE]] <dt>SQLITE_CONFIG_PAGECACHE</dt>ŸC** <dd> ^The SQLITE_CONFIG_PAGECACHE option specifies a memory poolŸH** that SQLite can use for the database page cache with the default page∫** cache implementation.  ŸE** This configuration option is a no-op if an application-define pageŸD** cache implementation is loaded using the [SQLITE_CONFIG_PCACHE2].ŸF** ^There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer toŸG** 8-byte aligned memory (pMem), the size of each page cache line (sz),Ÿ%** and the number of cache lines (N).ŸB** The sz argument should be the size of the largest database pageŸH** (a power of two between 512 and 65536) plus some extra bytes for eachŸE** page header.  ^The number of extra bytes needed by the page headerŸ8** can be determined using [SQLITE_CONFIG_PCACHE_HDRSZ].Ÿ1** ^It is harmless, apart from the wasted memory,Ÿ>** for the sz parameter to be larger than necessary.  The pMemŸC** argument must be either a NULL pointer or a pointer to an 8-byteŸ<** aligned block of memory of at least sz*N bytes, otherwiseŸ$** subsequent behavior is undefined.ŸH** ^When pMem is not NULL, SQLite will strive to use the memory providedŸE** to satisfy page cache needs, falling back to [sqlite3_malloc()] ifŸI** a page cache line is larger than sz bytes or if all of the pMem buffer∞** is exhausted.ŸD** ^If pMem is NULL and N is non-zero, then each database connectionŸ8** does an initial bulk allocation for page cache memoryŸK** from [sqlite3_malloc()] sufficient for N cache lines if N is positive orŸ6** of -1024*N bytes if N is negative, . ^If additionalŸE** page cache memory is needed beyond what is provided by the initialŸI** allocation, then SQLite goes to [sqlite3_malloc()] separately for eachø** additional cache line. </dd>¢**Ÿ5** [[SQLITE_CONFIG_HEAP]] <dt>SQLITE_CONFIG_HEAP</dt>ŸH** <dd> ^The SQLITE_CONFIG_HEAP option specifies a static memory buffer ŸF** that SQLite will use for all of its dynamic memory allocation needsŸ:** beyond those provided for by [SQLITE_CONFIG_PAGECACHE].ŸI** ^The SQLITE_CONFIG_HEAP option is only available if SQLite is compiledŸM** with either [SQLITE_ENABLE_MEMSYS3] or [SQLITE_ENABLE_MEMSYS5] and returnsŸ'** [SQLITE_ERROR] if invoked otherwise.Ÿ4** ^There are three arguments to SQLITE_CONFIG_HEAP:Ÿ+** An 8-byte aligned pointer to the memory,ŸM** the number of bytes in the memory buffer, and the minimum allocation size.ŸJ** ^If the first pointer (the memory pointer) is NULL, then SQLite revertsŸN** to using its default memory allocator (the system malloc() implementation),ŸC** undoing any prior invocation of [SQLITE_CONFIG_MALLOC].  ^If theŸ9** memory pointer is not NULL then the alternative memoryŸI** allocator is engaged to handle all of SQLites memory allocation needs.ŸF** The first pointer (the memory pointer) must be aligned to an 8-byteŸ?** boundary or subsequent behavior of SQLite will be undefined.ŸD** The minimum allocation size is capped at 2**12. Reasonable valuesŸ>** for the minimum allocation size are 2**5 through 2**8.</dd>¢**Ÿ7** [[SQLITE_CONFIG_MUTEX]] <dt>SQLITE_CONFIG_MUTEX</dt>ŸK** <dd> ^(The SQLITE_CONFIG_MUTEX option takes a single argument which is aŸC** pointer to an instance of the [sqlite3_mutex_methods] structure.ŸI** The argument specifies alternative low-level mutex routines to be usedŸL** in place the mutex routines built into SQLite.)^  ^SQLite makes a copy ofŸJ** the content of the [sqlite3_mutex_methods] structure before the call toŸ:** [sqlite3_config()] returns. ^If SQLite is compiled withŸI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenŸM** the entire mutexing subsystem is omitted from the build and hence calls toŸL** [sqlite3_config()] with the SQLITE_CONFIG_MUTEX configuration option willæ** return [SQLITE_ERROR].</dd>¢**Ÿ=** [[SQLITE_CONFIG_GETMUTEX]] <dt>SQLITE_CONFIG_GETMUTEX</dt>ŸI** <dd> ^(The SQLITE_CONFIG_GETMUTEX option takes a single argument whichŸM** is a pointer to an instance of the [sqlite3_mutex_methods] structure.  The∫** [sqlite3_mutex_methods]ŸC** structure is filled with the currently defined mutex routines.)^ŸC** This option can be used to overload the default mutex allocationŸD** routines with a wrapper used to track mutex usage for performanceŸC** profiling or testing, for example.   ^If SQLite is compiled withŸI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenŸM** the entire mutexing subsystem is omitted from the build and hence calls toŸO** [sqlite3_config()] with the SQLITE_CONFIG_GETMUTEX configuration option willæ** return [SQLITE_ERROR].</dd>¢**Ÿ?** [[SQLITE_CONFIG_LOOKASIDE]] <dt>SQLITE_CONFIG_LOOKASIDE</dt>ŸO** <dd> ^(The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determineŸF** the default size of lookaside memory on each [database connection].º** The first argument is theŸE** size of each lookaside buffer slot and the second is the number ofŸL** slots allocated to each database connection.)^  ^(SQLITE_CONFIG_LOOKASIDEŸJ** sets the <i>default</i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]ŸF** option to [sqlite3_db_config()] can be used to change the lookasideŸ3** configuration on individual connections.)^ </dd>¢**Ÿ;** [[SQLITE_CONFIG_PCACHE2]] <dt>SQLITE_CONFIG_PCACHE2</dt>ŸL** <dd> ^(The SQLITE_CONFIG_PCACHE2 option takes a single argument which is ŸK** a pointer to an [sqlite3_pcache_methods2] object.  This object specifiesŸ9** the interface to a custom page cache implementation.)^ŸE** ^SQLite makes a copy of the [sqlite3_pcache_methods2] object.</dd>¢**ŸA** [[SQLITE_CONFIG_GETPCACHE2]] <dt>SQLITE_CONFIG_GETPCACHE2</dt>ŸK** <dd> ^(The SQLITE_CONFIG_GETPCACHE2 option takes a single argument whichŸI** is a pointer to an [sqlite3_pcache_methods2] object.  SQLite copies ofŸB** the current page cache implementation into that object.)^ </dd>¢**Ÿ3** [[SQLITE_CONFIG_LOG]] <dt>SQLITE_CONFIG_LOG</dt>ŸD** <dd> The SQLITE_CONFIG_LOG option is used to configure the SQLite∂** global [error log].ŸE** (^The SQLITE_CONFIG_LOG option takes two arguments: a pointer to aŸE** function with a call signature of void(*)(void*,int,const char*), ŸE** and a pointer to void. ^If the function pointer is not NULL, it isŸE** invoked by [sqlite3_log()] to process each logging event.  ^If theŸK** function pointer is NULL, the [sqlite3_log()] interface becomes a no-op.ŸH** ^The void pointer that is the second argument to SQLITE_CONFIG_LOG isŸJ** passed through as the first parameter to the application-defined loggerŸH** function whenever that function is invoked.  ^The second parameter toŸL** the logger function is a copy of the first parameter to the correspondingŸC** [sqlite3_log()] call and is intended to be a [result code] or anŸH** [extended result code].  ^The third parameter passed to the logger isŸ9** log message after formatting via [sqlite3_snprintf()].ŸE** The SQLite logging interface is not reentrant; the logger functionŸD** supplied by the application must not invoke any SQLite interface.ŸB** In a multi-threaded application, the application-defined loggerŸ%** function must be threadsafe. </dd>¢**Ÿ.** [[SQLITE_CONFIG_URI]] <dt>SQLITE_CONFIG_URIŸJ** <dd>^(The SQLITE_CONFIG_URI option takes a single argument of type int.ŸP** If non-zero, then URI handling is globally enabled. If the parameter is zero,ŸI** then URI handling is globally disabled.)^ ^If URI handling is globallyŸJ** enabled, all filenames passed to [sqlite3_open()], [sqlite3_open_v2()],∏** [sqlite3_open16()] orŸM** specified as part of [ATTACH] commands are interpreted as URIs, regardlessŸH** of whether or not the [SQLITE_OPEN_URI] flag is set when the databaseŸC** connection is opened. ^If it is globally disabled, filenames areŸG** only interpreted as URIs if the SQLITE_OPEN_URI flag is set when theŸH** database connection is opened. ^(By default, URI handling is globallyŸC** disabled. The default value may be changed by compiling with theŸ%** [SQLITE_USE_URI] symbol defined.)^¢**ŸN** [[SQLITE_CONFIG_COVERING_INDEX_SCAN]] <dt>SQLITE_CONFIG_COVERING_INDEX_SCANŸK** <dd>^The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integerŸK** argument which is interpreted as a boolean in order to enable or disableŸK** the use of covering indices for full table scans in the query optimizer.Ÿ%** ^The default setting is determinedŸL** by the [SQLITE_ALLOW_COVERING_INDEX_SCAN] compile-time option, or is "on"Ÿ*** if that compile-time option is omitted.ŸJ** The ability to disable the use of covering indices for full table scansŸJ** is because some incorrectly coded legacy applications might malfunctionŸ>** when the optimization is enabled.  Providing the ability toŸL** disable the optimization allows the older, buggy application code to workŸ5** without change even with newer versions of SQLite.¢**Ÿ7** [[SQLITE_CONFIG_PCACHE]] [[SQLITE_CONFIG_GETPCACHE]]Ÿ7** <dt>SQLITE_CONFIG_PCACHE and SQLITE_CONFIG_GETPCACHEŸF** <dd> These options are obsolete and should not be used by new code.ŸD** They are retained for backwards compatibility but are now no-ops.®** </dd>¢**ª** [[SQLITE_CONFIG_SQLLOG]]ª** <dt>SQLITE_CONFIG_SQLLOGŸC** <dd>This option is only available if sqlite is compiled with theŸP** [SQLITE_ENABLE_SQLLOG] pre-processor macro defined. The first argument shouldŸO** be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int).ŸO** The second should be of type (void*). The callback is invoked by the libraryŸI** in three separate circumstances, identified by the value passed as theŸO** fourth parameter. If the fourth parameter is 0, then the database connectionŸI** passed as the second argument has just been opened. The third argumentŸK** points to a buffer containing the name of the main database file. If theŸI** fourth parameter is 1, then the SQL statement that the third parameterŸK** points to has just been executed. Or, if the fourth parameter is 2, thenŸK** the connection being passed as the second parameter is being closed. TheŸI** third parameter is passed NULL In this case.  An example of using thisŸI** configuration option can be seen in the "test_sqllog.c" source file inŸ)** the canonical SQLite source tree.</dd>¢**æ** [[SQLITE_CONFIG_MMAP_SIZE]]æ** <dt>SQLITE_CONFIG_MMAP_SIZEŸO** <dd>^SQLITE_CONFIG_MMAP_SIZE takes two 64-bit integer (sqlite3_int64) valuesŸ@** that are the default mmap size limit (the default setting forŸ?** [PRAGMA mmap_size]) and the maximum allowed mmap size limit.ŸK** ^The default setting can be overridden by each database connection usingŸ9** either the [PRAGMA mmap_size] command, or by using theŸJ** [SQLITE_FCNTL_MMAP_SIZE] file control.  ^(The maximum allowed mmap sizeŸI** will be silently truncated if necessary so that it does not exceed theŸ,** compile-time maximum mmap size set by theŸ0** [SQLITE_MAX_MMAP_SIZE] compile-time option.)^ŸH** ^If either argument to this option is negative, then that argument isŸ'** changed to its compile-time default.¢**Ÿ#** [[SQLITE_CONFIG_WIN32_HEAPSIZE]]Ÿ#** <dt>SQLITE_CONFIG_WIN32_HEAPSIZEŸN** <dd>^The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite isŸJ** compiled for Windows with the [SQLITE_WIN32_MALLOC] pre-processor macroŸO** defined. ^SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer valueŸ7** that specifies the maximum size of the created heap.¢**Ÿ!** [[SQLITE_CONFIG_PCACHE_HDRSZ]]Ÿ!** <dt>SQLITE_CONFIG_PCACHE_HDRSZŸL** <dd>^The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter whichŸN** is a pointer to an integer and writes into that integer the number of extraŸF** bytes per page required for each page in [SQLITE_CONFIG_PAGECACHE].ŸK** The amount of extra space required can change depending on the compiler,Ÿ'** target platform, and SQLite version.¢**∫** [[SQLITE_CONFIG_PMASZ]]∫** <dt>SQLITE_CONFIG_PMASZŸE** <dd>^The SQLITE_CONFIG_PMASZ option takes a single parameter whichŸO** is an unsigned integer and sets the "Minimum PMA Size" for the multithreadedŸF** sorter to that integer.  The default minimum PMA Size is set by theŸG** [SQLITE_SORTER_PMASZ] compile-time option.  New threads are launchedŸ:** to help with sort operations when multithreaded sortingŸL** is enabled (using the [PRAGMA threads] command) and the amount of contentŸ>** to be sorted exceeds the page size times the minimum of theŸ.** [PRAGMA cache_size] setting and this value.¢**Ÿ#** [[SQLITE_CONFIG_STMTJRNL_SPILL]]Ÿ#** <dt>SQLITE_CONFIG_STMTJRNL_SPILLŸN** <dd>^The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter whichŸ=** becomes the [statement journal] spill-to-disk threshold.  ŸF** [Statement journals] are held in memory until their size (in bytes)ŸC** exceeds this threshold, at which point they are written to disk.Ÿ@** Or if the threshold is -1, statement journals are always heldπ** exclusively in memory.ŸF** Since many statement journals never become large, setting the spillŸF** threshold to a value such as 64KiB can greatly reduce the amount ofŸ.** I/O required to support statement rollback.Ÿ:** The default value for this setting is controlled by theŸ/** [SQLITE_STMTJRNL_SPILL] compile-time option.®** </dl>¢*/Ÿ0#define SQLITE_CONFIG_SINGLETHREAD  1  /* nil */Ÿ0#define SQLITE_CONFIG_MULTITHREAD   2  /* nil */Ÿ0#define SQLITE_CONFIG_SERIALIZED    3  /* nil */ŸA#define SQLITE_CONFIG_MALLOC        4  /* sqlite3_mem_methods* */ŸA#define SQLITE_CONFIG_GETMALLOC     5  /* sqlite3_mem_methods* */Ÿ;#define SQLITE_CONFIG_SCRATCH       6  /* No longer used */ŸA#define SQLITE_CONFIG_PAGECACHE     7  /* void*, int sz, int N */ŸF#define SQLITE_CONFIG_HEAP          8  /* void*, int nByte, int min */Ÿ4#define SQLITE_CONFIG_MEMSTATUS     9  /* boolean */ŸC#define SQLITE_CONFIG_MUTEX        10  /* sqlite3_mutex_methods* */ŸC#define SQLITE_CONFIG_GETMUTEX     11  /* sqlite3_mutex_methods* */ŸB/* previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. */ Ÿ4#define SQLITE_CONFIG_LOOKASIDE    13  /* int int */Ÿ2#define SQLITE_CONFIG_PCACHE       14  /* no-op */Ÿ2#define SQLITE_CONFIG_GETPCACHE    15  /* no-op */Ÿ9#define SQLITE_CONFIG_LOG          16  /* xFunc, void* */Ÿ0#define SQLITE_CONFIG_URI          17  /* int */ŸE#define SQLITE_CONFIG_PCACHE2      18  /* sqlite3_pcache_methods2* */ŸE#define SQLITE_CONFIG_GETPCACHE2   19  /* sqlite3_pcache_methods2* */Ÿ7#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20  /* int */Ÿ;#define SQLITE_CONFIG_SQLLOG       21  /* xSqllog, void* */ŸI#define SQLITE_CONFIG_MMAP_SIZE    22  /* sqlite3_int64, sqlite3_int64 */Ÿ=#define SQLITE_CONFIG_WIN32_HEAPSIZE      23  /* int nByte */Ÿ<#define SQLITE_CONFIG_PCACHE_HDRSZ        24  /* int *psz */ŸF#define SQLITE_CONFIG_PMASZ               25  /* unsigned int szPma */Ÿ=#define SQLITE_CONFIG_STMTJRNL_SPILL      26  /* int nByte */Ÿ;#define SQLITE_CONFIG_SMALL_MALLOC        27  /* boolean */†¢/*Ÿ6** CAPI3REF: Database Connection Configuration Options¢**ŸG** These constants are the available integer configuration options thatŸO** can be passed as the second argument to the [sqlite3_db_config()] interface.¢**ŸG** New configuration options may be added in future releases of SQLite.ŸF** Existing configuration options might be discontinued.  ApplicationsŸL** should check the return code from [sqlite3_db_config()] to make sure thatŸG** the call worked.  ^The [sqlite3_db_config()] interface will return aŸN** non-zero [error code] if a discontinued or unsupported configuration optionÆ** is invoked.¢**ß** <dl>Ÿ%** <dt>SQLITE_DBCONFIG_LOOKASIDE</dt>ŸI** <dd> ^This option takes three additional arguments that determine the ŸL** [lookaside memory allocator] configuration for the [database connection].ŸI** ^The first argument (the third parameter to [sqlite3_db_config()] is aŸ:** pointer to a memory buffer to use for lookaside memory.Ÿ?** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verbŸ5** may be NULL in which case SQLite will allocate theŸP** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is theŸL** size of each lookaside buffer slot.  ^The third argument is the number ofŸL** slots.  The size of the buffer in the first argument must be greater thanŸI** or equal to the product of the second and third arguments.  The bufferŸE** must be aligned to an 8-byte boundary.  ^If the second argument toŸE** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internallyŸJ** rounded down to the next smaller multiple of 8.  ^(The lookaside memoryŸH** configuration for a database connection can only be changed when thatŸH** connection is not currently using lookaside memory, or in other wordsŸ'** when the "current value" returned byŸ@** [sqlite3_db_status](D,[SQLITE_CONFIG_LOOKASIDE],...) is zero.ŸJ** Any attempt to change the lookaside memory configuration when lookasideŸC** memory is in use leaves the configuration unchanged and returns ∏** [SQLITE_BUSY].)^</dd>¢**Ÿ'** <dt>SQLITE_DBCONFIG_ENABLE_FKEY</dt>ŸD** <dd> ^This option is used to enable or disable the enforcement ofŸH** [foreign key constraints].  There should be two additional arguments.ŸI** The first argument is an integer which is 0 to disable FK enforcement,ŸH** positive to enable FK enforcement or negative to leave FK enforcementŸI** unchanged.  The second parameter is a pointer to an integer into whichŸD** is written 0 or 1 to indicate whether FK enforcement is off or onŸG** following this call.  The second parameter may be a NULL pointer, inŸD** which case the FK enforcement setting is not reported back. </dd>¢**Ÿ*** <dt>SQLITE_DBCONFIG_ENABLE_TRIGGER</dt>ŸN** <dd> ^This option is used to enable or disable [CREATE TRIGGER | triggers].Ÿ,** There should be two additional arguments.ŸC** The first argument is an integer which is 0 to disable triggers,ŸJ** positive to enable triggers or negative to leave the setting unchanged.Ÿ=** The second parameter is a pointer to an integer into whichŸI** is written 0 or 1 to indicate whether triggers are disabled or enabledŸG** following this call.  The second parameter may be a NULL pointer, inŸ=** which case the trigger setting is not reported back. </dd>¢**Ÿ1** <dt>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</dt>ŸB** <dd> ^This option is used to enable or disable the two-argumentŸB** version of the [fts3_tokenizer()] function which is part of theŸ,** [FTS3] full-text search engine extension.Ÿ,** There should be two additional arguments.ŸM** The first argument is an integer which is 0 to disable fts3_tokenizer() orŸG** positive to enable fts3_tokenizer() or negative to leave the setting≠** unchanged.Ÿ=** The second parameter is a pointer to an integer into whichŸN** is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabledŸG** following this call.  The second parameter may be a NULL pointer, inŸ9** which case the new setting is not reported back. </dd>¢**Ÿ1** <dt>SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</dt>ŸP** <dd> ^This option is used to enable or disable the [sqlite3_load_extension()]ŸB** interface independently of the [load_extension()] SQL function.ŸI** The [sqlite3_enable_load_extension()] API enables or disables both theŸL** C-API [sqlite3_load_extension()] and the SQL function [load_extension()].Ÿ,** There should be two additional arguments.ŸI** When the first argument to this interface is 1, then only the C-API isŸK** enabled and the SQL function remains disabled.  If the first argument toŸN** this interface is 0, then both the C-API and the SQL function are disabled.ŸO** If the first argument is -1, then no changes are made to state of either theΩ** C-API or the SQL function.Ÿ=** The second parameter is a pointer to an integer into whichŸM** is written 0 or 1 to indicate whether [sqlite3_load_extension()] interfaceŸH** is disabled or enabled following this call.  The second parameter mayŸI** be a NULL pointer, in which case the new setting is not reported back.®** </dd>¢**Ÿ&** <dt>SQLITE_DBCONFIG_MAINDBNAME</dt>ŸF** <dd> ^This option is used to change the name of the "main" databaseŸE** schema.  ^The sole argument is a pointer to a constant UTF8 stringŸE** which will become the new schema name in place of "main".  ^SQLiteŸN** does not make a copy of the new main schema name string, so the applicationŸN** must ensure that the argument passed into this DBCONFIG option is unchangedŸ.** until after the database connection closes.®** </dd>¢**Ÿ,** <dt>SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</dt>ŸJ** <dd> Usually, when a database in wal mode is closed or detached from a ŸJ** database handle, SQLite checks if this will mean that there are now no ŸG** connections at all to the database. If so, it performs a checkpoint ŸF** operation before closing the connection. This option may be used toŸH** override this behaviour. The first parameter passed to this operationŸI** is an integer - positive to disable checkpoints-on-close, or zero (theŸH** default) to enable them, and negative to leave the setting unchanged.Ÿ2** The second parameter is a pointer to an integerŸH** into which is written 0 or 1 to indicate whether checkpoints-on-closeŸB** have been disabled - 0 if they are not disabled, 1 if they are.®** </dd>¢**Ÿ'** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>ŸH** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivatesŸL** the [query planner stability guarantee] (QPSG).  When the QPSG is active,ŸM** a single SQL query statement will always use the same algorithm regardlessŸP** of values of [bound parameters].)^ The QPSG disables some query optimizationsŸK** that look at the values of bound parameters, which can make some queriesŸN** slower.  But the QPSG has the advantage of more predictable behavior.  WithŸN** the QPSG active, SQLite will always use the same query plan in the field asŸ&** was used during testing in the lab.ŸJ** The first argument to this setting is an integer which is 0 to disable ŸF** the QPSG, positive to enable QPSG, or negative to leave the settingŸH** unchanged. The second parameter is a pointer to an integer into whichŸH** is written 0 or 1 to indicate whether the QPSG is disabled or enabled∑** following this call.®** </dd>¢**Ÿ'** <dt>SQLITE_DBCONFIG_TRIGGER_EQP</dt>ŸG** <dd> By default, the output of EXPLAIN QUERY PLAN commands does not ŸH** include output for any operations performed by trigger programs. ThisŸH** option is used to set or clear (the default) a flag that governs thisŸI** behavior. The first parameter passed to this operation is an integer -ŸI** positive to enable output for trigger programs, or zero to disable it,Ÿ.** or negative to leave the setting unchanged.ŸI** The second parameter is a pointer to an integer into which is written ŸK** 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if Ÿ$** it is not disabled, 1 if it is.  ®** </dd>®** </dl>¢*/ŸD#define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */ŸF#define SQLITE_DBCONFIG_LOOKASIDE             1001 /* void* int int */ŸA#define SQLITE_DBCONFIG_ENABLE_FKEY           1002 /* int int* */ŸA#define SQLITE_DBCONFIG_ENABLE_TRIGGER        1003 /* int int* */ŸA#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004 /* int int* */ŸA#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005 /* int int* */ŸA#define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      1006 /* int int* */ŸA#define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */ŸA#define SQLITE_DBCONFIG_TRIGGER_EQP           1008 /* int int* */ŸI#define SQLITE_DBCONFIG_MAX                   1008 /* Largest DBCONFIG */†¢/*Ÿ4** CAPI3REF: Enable Or Disable Extended Result Codes≤** METHOD: sqlite3¢**ŸG** ^The sqlite3_extended_result_codes() routine enables or disables theŸB** [extended result codes] feature of SQLite. ^The extended resultŸ>** codes are disabled by default for historical compatibility.¢*/ŸBSQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);†¢/*æ** CAPI3REF: Last Insert Rowid≤** METHOD: sqlite3¢**ŸH** ^Each entry in most SQLite tables (except for [WITHOUT ROWID] tables)Ω** has a unique 64-bit signedŸK** integer key called the [ROWID | "rowid"]. ^The rowid is always availableŸH** as an undeclared column named ROWID, OID, or _ROWID_ as long as thoseŸ>** names are not also used by explicitly declared columns. ^IfŸH** the table has a column of type [INTEGER PRIMARY KEY] then that columnŸ"** is another alias for the rowid.¢**ŸM** ^The sqlite3_last_insert_rowid(D) interface usually returns the [rowid] ofŸL** the most recent successful [INSERT] into a rowid table or [virtual table]ŸI** on database connection D. ^Inserts into [WITHOUT ROWID] tables are notŸN** recorded. ^If no successful [INSERT]s into rowid tables have ever occurred ŸK** on the database connection D, then sqlite3_last_insert_rowid(D) returns ®** zero.¢**ŸH** As well as being set automatically as rows are inserted into databaseŸG** tables, the value returned by this function may be set explicitly byŸ$** [sqlite3_set_last_insert_rowid()]¢**ŸJ** Some virtual table implementations may INSERT rows into rowid tables asŸM** part of committing a transaction (e.g. to flush data accumulated in memoryŸL** to disk). In this case subsequent calls to this function return the rowidŸD** associated with these internal INSERT operations, which leads to ŸL** unintuitive results. Virtual table implementations that do write to rowidŸG** tables in this way can avoid this problem by restoring the original ŸH** rowid value using [sqlite3_set_last_insert_rowid()] before returning ∑** control to the user.¢**ŸC** ^(If an [INSERT] occurs within a trigger then this routine will ŸD** return the [rowid] of the inserted row as long as the trigger is Ÿ>** running. Once the trigger program ends, the value returned ŸI** by this routine reverts to what it was before the trigger was fired.)^¢**ŸA** ^An [INSERT] that fails due to a constraint violation is not aŸE** successful [INSERT] and does not change the value returned by thisŸH** routine.  ^Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK,ŸB** and INSERT OR ABORT make no changes to the return value of thisŸ@** routine when their insertion fails.  ^(When INSERT OR REPLACEŸ<** encounters a constraint violation, it does not fail.  TheŸA** INSERT continues to completion after deleting rows that causedŸA** the constraint problem so INSERT OR REPLACE will always changeŸ(** the return value of this interface.)^¢**ŸB** ^For the purposes of this routine, an [INSERT] is considered toŸ8** be successful even if it is subsequently rolled back.¢**Ÿ8** This function is accessible to SQL statements via theŸ&** [last_insert_rowid() SQL function].¢**Ÿ;** If a separate thread performs a new [INSERT] on the sameŸ>** database connection while the [sqlite3_last_insert_rowid()]Ÿ@** function is running and thus changes the last insert [rowid],Ÿ>** then the value returned by [sqlite3_last_insert_rowid()] isŸ>** unpredictable and might not equal either the old or the new∑** last insert [rowid].¢*/Ÿ=SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);†¢/*Ÿ-** CAPI3REF: Set the Last Insert Rowid value.≤** METHOD: sqlite3¢**ŸK** The sqlite3_set_last_insert_rowid(D, R) method allows the application toŸG** set the value returned by calling sqlite3_last_insert_rowid(D) to R Ÿ-** without inserting a row into the database.¢*/ŸFSQLITE_API void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);†¢/*Ÿ.** CAPI3REF: Count The Number Of Rows Modified≤** METHOD: sqlite3¢**ŸB** ^This function returns the number of rows modified, inserted orŸB** deleted by the most recently completed INSERT, UPDATE or DELETEŸH** statement on the database connection specified by the only parameter.ŸG** ^Executing any other type of SQL statement does not modify the valueΩ** returned by this function.¢**ŸL** ^Only changes made directly by the INSERT, UPDATE or DELETE statement areŸI** considered - auxiliary changes caused by [CREATE TRIGGER | triggers], ŸL** [foreign key actions] or [REPLACE] constraint resolution are not counted.£** Ÿ-** Changes to a view that are intercepted by ŸJ** [INSTEAD OF trigger | INSTEAD OF triggers] are not counted. ^The value ŸH** returned by sqlite3_changes() immediately after an INSERT, UPDATE or ŸL** DELETE statement run on a view is always zero. Only changes made to real ∂** tables are counted.¢**ŸC** Things are more complicated if the sqlite3_changes() function isŸF** executed while a trigger program is running. This may happen if theŸG** program uses the [changes() SQL function], or if some other callbackŸ<** function invokes sqlite3_changes() directly. Essentially:£** ß** <ul>ŸC**   <li> ^(Before entering a trigger program the value returned byŸI**        sqlite3_changes() function is saved. After the trigger program Ÿ9**        has finished, the original value is restored.)^£** ŸD**   <li> ^(Within a trigger program each INSERT, UPDATE and DELETE ŸA**        statement sets the value returned by sqlite3_changes() ŸL**        upon completion as normal. Of course, this value will not include ŸJ**        any changes performed by sub-triggers, as the sqlite3_changes() ŸL**        value will be saved and restored after each sub-trigger has run.)^®** </ul>£** ŸF** ^This means that if the changes() SQL function (or similar) is usedŸH** by the first INSERT, UPDATE or DELETE statement within a trigger, it ŸG** returns the value as set when the calling statement began executing.ŸN** ^If it is used by the second or subsequent such statement within a trigger ŸK** program, the value returned reflects the number of rows modified by the ŸG** previous INSERT, UPDATE or DELETE statement within the same trigger.¢**Ÿ8** See also the [sqlite3_total_changes()] interface, theŸ<** [count_changes pragma], and the [changes() SQL function].¢**ŸE** If a separate thread makes changes on the same database connectionŸ?** while [sqlite3_changes()] is running then the value returnedŸ'** is unpredictable and not meaningful.¢*/Ÿ)SQLITE_API int sqlite3_changes(sqlite3*);†¢/*Ÿ*** CAPI3REF: Total Number Of Rows Modified≤** METHOD: sqlite3¢**ŸH** ^This function returns the total number of rows inserted, modified orŸE** deleted by all [INSERT], [UPDATE] or [DELETE] statements completedŸH** since the database connection was opened, including those executed asŸG** part of trigger programs. ^Executing any other type of SQL statementŸA** does not affect the value returned by sqlite3_total_changes().£** ŸE** ^Changes made as part of [foreign key actions] are included in theŸE** count, but those made as part of REPLACE constraint resolution areŸG** not. ^Changes to a view that are intercepted by INSTEAD OF triggers ≥** are not counted.£** Ÿ2** See also the [sqlite3_changes()] interface, theŸB** [count_changes pragma], and the [total_changes() SQL function].¢**ŸE** If a separate thread makes changes on the same database connectionŸ<** while [sqlite3_total_changes()] is running then the valueŸ0** returned is unpredictable and not meaningful.¢*/Ÿ/SQLITE_API int sqlite3_total_changes(sqlite3*);†¢/*Ÿ+** CAPI3REF: Interrupt A Long-Running Query≤** METHOD: sqlite3¢**ŸD** ^This function causes any pending database operation to abort andŸ@** return at its earliest opportunity. This routine is typicallyŸ@** called in response to a user action such as pressing "Cancel"Ÿ@** or Ctrl-C where the user wants a long query operation to haltØ** immediately.¢**ŸD** ^It is safe to call this routine from a thread different from theŸC** thread that is currently running the database operation.  But itŸE** is not safe to call this routine with a [database connection] thatŸ?** is closed or might close before sqlite3_interrupt() returns.¢**Ÿ@** ^If an SQL operation is very nearly finished at the time whenŸG** sqlite3_interrupt() is called, then it might not have an opportunityŸ6** to be interrupted and might continue to completion.¢**ŸH** ^An SQL operation that is interrupted will return [SQLITE_INTERRUPT].ŸD** ^If the interrupted SQL operation is an INSERT, UPDATE, or DELETEŸF** that is inside an explicit transaction, then the entire transactionŸ%** will be rolled back automatically.¢**ŸJ** ^The sqlite3_interrupt(D) call is in effect until all currently runningŸO** SQL statements on [database connection] D complete.  ^Any new SQL statementsŸF** that are started after the sqlite3_interrupt() call and before the ŸF** running statements reaches zero are interrupted as if they had beenŸF** running prior to the sqlite3_interrupt() call.  ^New SQL statementsŸF** that are started after the running statement count reaches zero areŸ+** not effected by the sqlite3_interrupt().ŸH** ^A call to sqlite3_interrupt(D) that occurs when there are no runningŸ@** SQL statements is a no-op and has no effect on SQL statementsŸ?** that are started after the sqlite3_interrupt() call returns.¢*/Ÿ,SQLITE_API void sqlite3_interrupt(sqlite3*);†¢/*Ÿ6** CAPI3REF: Determine If An SQL Statement Is Complete¢**ŸJ** These routines are useful during command-line input to determine if theŸC** currently entered text seems to form a complete SQL statement orŸ=** if additional input is needed before sending the text intoŸD** SQLite for parsing.  ^These routines return 1 if the input stringŸH** appears to be a complete SQL statement.  ^A statement is judged to beŸF** complete if it ends with a semicolon token and is not a prefix of aŸN** well-formed CREATE TRIGGER statement.  ^Semicolons that are embedded withinŸA** string literals or quoted identifier names or comments are notŸC** independent tokens (they are part of the token in which they areŸJ** embedded) and thus do not count as a statement terminator.  ^WhitespaceŸ<** and comments that follow the final semicolon are ignored.¢**ŸB** ^These routines return 0 if the statement is incomplete.  ^If aŸ:** memory allocation fails, then SQLITE_NOMEM is returned.¢**Ÿ7** ^These routines do not parse the SQL statements thusŸ/** will not detect syntactically incorrect SQL.¢**ŸK** ^(If SQLite has not been initialized using [sqlite3_initialize()] prior ŸH** to invoking sqlite3_complete16() then sqlite3_initialize() is invokedŸH** automatically by sqlite3_complete16().  If that initialization fails,ŸC** then the return value from sqlite3_complete16() will be non-zeroŸ<** regardless of whether or not the input SQL is complete.)^¢**Ÿ>** The input to [sqlite3_complete()] must be a zero-terminated∞** UTF-8 string.¢**Ÿ@** The input to [sqlite3_complete16()] must be a zero-terminatedŸ&** UTF-16 string in native byte order.¢*/Ÿ1SQLITE_API int sqlite3_complete(const char *sql);Ÿ3SQLITE_API int sqlite3_complete16(const void *sql);†¢/*Ÿ=** CAPI3REF: Register A Callback To Handle SQLITE_BUSY ErrorsŸ3** KEYWORDS: {busy-handler callback} {busy handler}≤** METHOD: sqlite3¢**ŸF** ^The sqlite3_busy_handler(D,X,P) routine sets a callback function XŸ1** that might be invoked with argument P wheneverŸ@** an attempt is made to access a database table associated withŸ.** [database connection] D when another threadŸ#** or process has the table locked.Ÿ<** The sqlite3_busy_handler() interface is used to implementŸ6** [sqlite3_busy_timeout()] and [PRAGMA busy_timeout].¢**Ÿ4** ^If the busy callback is NULL, then [SQLITE_BUSY]ŸM** is returned immediately upon encountering the lock.  ^If the busy callbackŸF** is not NULL, then the callback might be invoked with two arguments.¢**ŸO** ^The first argument to the busy handler is a copy of the void* pointer whichŸL** is the third argument to sqlite3_busy_handler().  ^The second argument toŸM** the busy handler callback is the number of times that the busy handler hasŸ?** been invoked previously for the same locking event.  ^If theŸC** busy callback returns 0, then no additional attempts are made toŸ4** access the database and [SQLITE_BUSY] is returned∂** to the application.Ÿ:** ^If the callback returns non-zero, then another attemptŸ8** is made to access the database and the cycle repeats.¢**ŸL** The presence of a busy handler does not guarantee that it will be invokedŸN** when there is lock contention. ^If SQLite determines that invoking the busyŸP** handler could result in a deadlock, it will go ahead and return [SQLITE_BUSY]Ÿ.** to the application instead of invoking the ∞** busy handler.ŸD** Consider a scenario where one process is holding a read lock thatŸ1** it is trying to promote to a reserved lock andŸ@** a second process is holding a reserved lock that it is tryingŸE** to promote to an exclusive lock.  The first process cannot proceedŸD** because it is blocked by the second and the second process cannotŸA** proceed because it is blocked by the first.  If both processesŸH** invoke the busy handlers, neither will make any progress.  Therefore,ŸG** SQLite returns [SQLITE_BUSY] for the first process, hoping that thisŸC** will induce the first process to release its read lock and allowŸ!** the second process to proceed.¢**Ÿ&** ^The default busy callback is NULL.¢**Ÿ=** ^(There can only be a single busy handler defined for eachŸ@** [database connection].  Setting a new busy handler clears anyŸI** previously set handler.)^  ^Note that calling [sqlite3_busy_timeout()]Ÿ8** or evaluating [PRAGMA busy_timeout=N] will change theŸ?** busy handler and thus clear any previously set busy handler.¢**ŸA** The busy callback should not take any actions which modify theŸF** database connection that invoked the busy handler.  In other words,Ÿ7** the busy handler is not reentrant.  Any such actionsŸ ** result in undefined behavior.£** Ÿ8** A busy handler must not close the database connectionŸ9** or [prepared statement] that invoked the busy handler.¢*/ŸFSQLITE_API int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);†¢/*ø** CAPI3REF: Set A Busy Timeout≤** METHOD: sqlite3¢**ŸI** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleepsŸG** for a specified amount of time when a table is locked.  ^The handlerŸI** will sleep multiple times until at least "ms" milliseconds of sleepingŸD** have accumulated.  ^After at least "ms" milliseconds of sleeping,Ÿ@** the handler returns 0 which causes [sqlite3_step()] to return±** [SQLITE_BUSY].¢**ŸD** ^Calling this routine with an argument less than or equal to zeroø** turns off all busy handlers.¢**Ÿ=** ^(There can only be a single busy handler for a particularŸF** [database connection] at any given moment.  If another busy handlerŸA** was defined  (using [sqlite3_busy_handler()]) prior to callingŸ6** this routine, that other busy handler is cleared.)^¢**Ÿ#** See also:  [PRAGMA busy_timeout]¢*/Ÿ6SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);†¢/*Ÿ5** CAPI3REF: Convenience Routines For Running Queries≤** METHOD: sqlite3¢**ŸL** This is a legacy interface that is preserved for backwards compatibility.Ÿ,** Use of this interface is not recommended.¢**ŸL** Definition: A <b>result table</b> is memory data structure created by theŸ?** [sqlite3_get_table()] interface.  A result table records theŸ3** complete query results from one or more queries.¢**Ÿ@** The table conceptually has a number of rows and columns.  ButŸ@** these numbers are not part of the result table itself.  TheseŸ@** numbers are obtained separately.  Let N be the number of rowsŸ"** and M be the number of columns.¢**ŸK** A result table is an array of pointers to zero-terminated UTF-8 strings.ŸG** There are (N+1)*M elements in the array.  The first M pointers pointŸE** to zero-terminated strings that  contain the names of the columns.ŸH** The remaining entries all point to query results.  NULL values resultŸI** in NULL pointers.  All other values are in their UTF-8 zero-terminatedŸ@** string representation as returned by [sqlite3_column_text()].¢**ŸB** A result table might consist of one or more memory allocations.ŸF** It is not safe to pass a result table directly to [sqlite3_free()].ŸE** A result table should be deallocated using [sqlite3_free_table()].¢**ŸE** ^(As an example of the result table format, suppose a query result±** is as follows:¢**¥** <blockquote><pre>ª**        Name        | AgeŸ!**        -----------------------∫**        Alice       | 43∫**        Bob         | 28∫**        Cindy       | 21∂** </pre></blockquote>¢**Ÿ?** There are two column (M==2) and three rows (N==3).  Thus theŸB** result table has 8 entries.  Suppose the result table is storedŸA** in an array names azResult.  Then azResult holds this content:¢**¥** <blockquote><pre>Ÿ#**        azResult&#91;0] = "Name";Ÿ"**        azResult&#91;1] = "Age";Ÿ$**        azResult&#91;2] = "Alice";Ÿ!**        azResult&#91;3] = "43";Ÿ"**        azResult&#91;4] = "Bob";Ÿ!**        azResult&#91;5] = "28";Ÿ$**        azResult&#91;6] = "Cindy";Ÿ!**        azResult&#91;7] = "21";∏** </pre></blockquote>)^¢**Ÿ:** ^The sqlite3_get_table() function evaluates one or moreŸB** semicolon-separated SQL statements in the zero-terminated UTF-8Ÿ@** string of its 2nd parameter and returns a result table to theŸ&** pointer given in its 3rd parameter.¢**ŸO** After the application has finished with the result from sqlite3_get_table(),ŸL** it must pass the result table pointer to sqlite3_free_table() in order toŸ@** release the memory that was malloced.  Because of the way theŸE** [sqlite3_malloc()] happens within sqlite3_get_table(), the callingŸA** function must not try to call [sqlite3_free()] directly.  OnlyŸL** [sqlite3_free_table()] is able to release the memory properly and safely.¢**ŸG** The sqlite3_get_table() interface is implemented as a wrapper aroundŸJ** [sqlite3_exec()].  The sqlite3_get_table() routine does not have accessŸF** to any internal data structures of SQLite.  It uses only the publicŸF** interface defined here.  As a consequence, errors that occur in theŸF** wrapper layer outside of the internal [sqlite3_exec()] call are notŸ:** reflected in subsequent calls to [sqlite3_errcode()] or∂** [sqlite3_errmsg()].¢*/Ÿ!SQLITE_API int sqlite3_get_table(Ÿ.  sqlite3 *db,          /* An open database */Ÿ1  const char *zSql,     /* SQL to be evaluated */Ÿ2  char ***pazResult,    /* Results of the query */Ÿ@  int *pnRow,           /* Number of result rows written here */ŸC  int *pnColumn,        /* Number of result columns written here */Ÿ4  char **pzErrmsg       /* Error msg written here */¢);Ÿ2SQLITE_API void sqlite3_free_table(char **result);†¢/*Ÿ0** CAPI3REF: Formatted String Printing Functions¢**ŸG** These routines are work-alikes of the "printf()" family of functionsø** from the standard C library.ŸG** These routines understand most of the common formatting options fromŸ!** the standard library printf() ŸJ** plus some additional non-standard formats ([%q], [%Q], [%w], and [%z]).Ÿ9** See the [built-in printf()] documentation for details.¢**ŸE** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write theirŸ:** results into memory obtained from [sqlite3_malloc64()].Ÿ7** The strings returned by these two routines should beŸ9** released by [sqlite3_free()].  ^Both routines return aŸD** NULL pointer if [sqlite3_malloc64()] is unable to allocate enoughŸ'** memory to hold the resulting string.¢**ŸC** ^(The sqlite3_snprintf() routine is similar to "snprintf()" fromŸ:** the standard C library.  The result is written into theŸA** buffer supplied as the second parameter whose size is given byŸ2** the first parameter. Note that the order of theŸB** first two parameters is reversed from snprintf().)^  This is anŸ<** historical accident that cannot be fixed without breakingŸ@** backwards compatibility.  ^(Note also that sqlite3_snprintf()Ÿ;** returns a pointer to its buffer instead of the number ofŸ@** characters actually written into the buffer.)^  We admit thatŸA** the number of characters written would be a more useful returnŸF** value but we cannot change the implementation of sqlite3_snprintf()Ÿ&** now without breaking compatibility.¢**ŸG** ^As long as the buffer size is greater than zero, sqlite3_snprintf()ŸD** guarantees that the buffer is always zero-terminated.  ^The firstŸE** parameter "n" is the total size of the buffer, including space forŸE** the zero terminator.  So the longest string that can be completelyŸ"** written will be n-1 characters.¢**ŸO** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().¢**Ÿ:** See also:  [built-in printf()], [printf() SQL function]¢*/Ÿ2SQLITE_API char *sqlite3_mprintf(const char*,...);Ÿ8SQLITE_API char *sqlite3_vmprintf(const char*, va_list);Ÿ>SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);ŸCSQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);†¢/*Ÿ(** CAPI3REF: Memory Allocation Subsystem¢**Ÿ?** The SQLite core uses these three routines for all of its ownŸD** internal memory allocation needs. "Core" in the previous sentenceŸF** does not include operating-system specific VFS implementation.  TheŸC** Windows VFS uses native malloc() and free() for some operations.¢**Ÿ=** ^The sqlite3_malloc() routine returns a pointer to a blockŸB** of memory at least N bytes in length, where N is the parameter.Ÿ;** ^If sqlite3_malloc() is unable to obtain sufficient freeŸ=** memory, it returns a NULL pointer.  ^If the parameter N toŸE** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns≤** a NULL pointer.¢**Ÿ3** ^The sqlite3_malloc64(N) routine works just likeŸH** sqlite3_malloc(N) except that N is an unsigned 64-bit integer insteadæ** of a signed 32-bit integer.¢**Ÿ=** ^Calling sqlite3_free() with a pointer previously returnedŸC** by sqlite3_malloc() or sqlite3_realloc() releases that memory soŸ;** that it might be reused.  ^The sqlite3_free() routine isŸD** a no-op if is called with a NULL pointer.  Passing a NULL pointerŸ<** to sqlite3_free() is harmless.  After being freed, memoryŸE** should neither be read nor written.  Even reading previously freedŸE** memory might result in a segmentation fault or other severe error.ŸA** Memory corruption, a segmentation fault, or other severe errorŸH** might result if sqlite3_free() is called with a non-NULL pointer thatŸ?** was not obtained from sqlite3_malloc() or sqlite3_realloc().¢**Ÿ;** ^The sqlite3_realloc(X,N) interface attempts to resize aŸ4** prior memory allocation X to be at least N bytes.Ÿ.** ^If the X parameter to sqlite3_realloc(X,N)Ÿ>** is a NULL pointer then its behavior is identical to callingµ** sqlite3_malloc(N).Ÿ9** ^If the N parameter to sqlite3_realloc(X,N) is zero orŸ<** negative then the behavior is exactly the same as calling≥** sqlite3_free(X).ŸA** ^sqlite3_realloc(X,N) returns a pointer to a memory allocationŸK** of at least N bytes in size or NULL if insufficient memory is available.ŸA** ^If M is the size of the prior allocation, then min(N,M) bytesŸK** of the prior allocation are copied into the beginning of buffer returnedŸ=** by sqlite3_realloc(X,N) and the prior allocation is freed.ŸD** ^If sqlite3_realloc(X,N) returns NULL and N is positive, then theŸ!** prior allocation is not freed.¢**Ÿ;** ^The sqlite3_realloc64(X,N) interfaces works the same asŸJ** sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer insteadæ** of a 32-bit signed integer.¢**ŸJ** ^If X is a memory allocation previously obtained from sqlite3_malloc(),ŸF** sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), thenŸH** sqlite3_msize(X) returns the size of that memory allocation in bytes.ŸJ** ^The value returned by sqlite3_msize(X) might be larger than the numberŸI** of bytes requested when X was allocated.  ^If X is a NULL pointer thenŸG** sqlite3_msize(X) returns zero.  If X points to something that is notŸD** the beginning of memory allocation, or if it points to a formerlyŸE** valid memory allocation that has now been freed, then the behaviorŸ9** of sqlite3_msize(X) is undefined and possibly harmful.¢**Ÿ?** ^The memory returned by sqlite3_malloc(), sqlite3_realloc(),Ÿ.** sqlite3_malloc64(), and sqlite3_realloc64()Ÿ<** is always aligned to at least an 8 byte boundary, or to aŸE** 4 byte boundary if the [SQLITE_4_BYTE_ALIGNED_MALLOC] compile-time≤** option is used.¢**Ÿ?** In SQLite version 3.5.0 and 3.5.1, it was possible to defineŸC** the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-inŸC** implementation of these routines to be omitted.  That capabilityŸG** is no longer provided.  Only built-in memory allocators can be used.¢**ŸH** Prior to SQLite version 3.7.10, the Windows OS interface layer calledŸ:** the system malloc() and free() directly when convertingŸ6** filenames between the UTF-8 encoding used by SQLiteŸC** and whatever filename encoding is used by the particular WindowsŸ=** installation.  Memory allocation errors were detected, butŸ2** they were reported back as [SQLITE_CANTOPEN] orŸ-** [SQLITE_IOERR] rather than [SQLITE_NOMEM].¢**ŸD** The pointer arguments to [sqlite3_free()] and [sqlite3_realloc()]Ÿ=** must be either NULL or else pointers obtained from a priorŸD** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that haveπ** not yet been released.¢**Ÿ5** The application must not read or write any part ofŸ5** a block of memory after it has been released usingŸ+** [sqlite3_free()] or [sqlite3_realloc()].¢*/Ÿ%SQLITE_API void *sqlite3_malloc(int);Ÿ2SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);Ÿ-SQLITE_API void *sqlite3_realloc(void*, int);Ÿ:SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);Ÿ$SQLITE_API void sqlite3_free(void*);Ÿ/SQLITE_API sqlite3_uint64 sqlite3_msize(void*);†¢/*Ÿ(** CAPI3REF: Memory Allocator Statistics¢**ŸC** SQLite provides these two interfaces for reporting on the statusŸG** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]ŸA** routines, which form the built-in memory allocation subsystem.¢**ŸC** ^The [sqlite3_memory_used()] routine returns the number of bytesŸ<** of memory currently outstanding (malloced but not freed).Ÿ@** ^The [sqlite3_memory_highwater()] routine returns the maximumŸ=** value of [sqlite3_memory_used()] since the high-water markŸG** was last reset.  ^The values returned by [sqlite3_memory_used()] andŸ4** [sqlite3_memory_highwater()] include any overheadŸ?** added by SQLite in its implementation of [sqlite3_malloc()],Ÿ>** but not overhead added by the any underlying system libraryŸ-** routines that [sqlite3_malloc()] may call.¢**Ÿ?** ^The memory high-water mark is reset to the current value ofŸ:** [sqlite3_memory_used()] if and only if the parameter toŸ=** [sqlite3_memory_highwater()] is true.  ^The value returnedŸ:** by [sqlite3_memory_highwater(1)] is the high-water mark∂** prior to the reset.¢*/Ÿ3SQLITE_API sqlite3_int64 sqlite3_memory_used(void);ŸASQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);†¢/*Ÿ+** CAPI3REF: Pseudo-Random Number Generator¢**ŸO** SQLite contains a high-quality pseudo-random number generator (PRNG) used toŸN** select random [ROWID | ROWIDs] when inserting new records into a table thatŸH** already uses the largest possible [ROWID].  The PRNG is also used forŸO** the build-in random() and randomblob() SQL functions.  This interface allowsŸ;** applications to access the same PRNG for other purposes.¢**ŸF** ^A call to this routine stores N bytes of randomness into buffer P.Ÿ*** ^The P parameter can be a NULL pointer.¢**ŸE** ^If this routine has not been previously called or if the previousŸE** call had N less than one or a NULL pointer for P, then the PRNG isŸB** seeded using randomness obtained from the xRandomness method ofŸ$** the default [sqlite3_vfs] object.ŸD** ^If the previous call to this routine had an N of 1 or more and aŸ5** non-NULL P then the pseudo-randomness is generatedŸC** internally and without recourse to the [sqlite3_vfs] xRandomness™** method.¢*/Ÿ3SQLITE_API void sqlite3_randomness(int N, void *P);†¢/*Ÿ1** CAPI3REF: Compile-Time Authorization Callbacks≤** METHOD: sqlite3Ÿ"** KEYWORDS: {authorizer callback}¢**ŸC** ^This routine registers an authorizer callback with a particularŸ9** [database connection], supplied in the first argument.ŸK** ^The authorizer callback is invoked as SQL statements are being compiledŸA** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],ŸK** [sqlite3_prepare_v3()], [sqlite3_prepare16()], [sqlite3_prepare16_v2()],Ÿ-** and [sqlite3_prepare16_v3()].  ^At variousŸC** points during the compilation process, as logic is being createdŸD** to perform various actions, the authorizer callback is invoked toŸE** see if those actions are allowed.  ^The authorizer callback shouldŸJ** return [SQLITE_OK] to allow the action, [SQLITE_IGNORE] to disallow theŸ@** specific action but allow the SQL statement to continue to beŸE** compiled, or [SQLITE_DENY] to cause the entire SQL statement to beŸ?** rejected with an error.  ^If the authorizer callback returnsŸF** any value other than [SQLITE_IGNORE], [SQLITE_OK], or [SQLITE_DENY]ŸD** then the [sqlite3_prepare_v2()] or equivalent call that triggeredŸ2** the authorizer will fail with an error message.¢**ŸB** When the callback returns [SQLITE_OK], that means the operationŸB** requested is ok.  ^When the callback returns [SQLITE_DENY], theŸ?** [sqlite3_prepare_v2()] or equivalent call that triggered theŸ=** authorizer will fail with an error message explaining thatµ** access is denied. ¢**ŸI** ^The first parameter to the authorizer callback is a copy of the thirdŸM** parameter to the sqlite3_set_authorizer() interface. ^The second parameterŸK** to the callback is an integer [SQLITE_COPY | action code] that specifiesŸN** the particular action to be authorized. ^The third through sixth parametersŸF** to the callback are either NULL pointers or zero-terminated stringsŸE** that contain additional details about the action to be authorized.ŸJ** Applications must always be prepared to encounter a NULL pointer in anyŸK** of the third through the sixth parameters of the authorization callback.¢**Ÿ'** ^If the action code is [SQLITE_READ]Ÿ4** and the callback returns [SQLITE_IGNORE] then theŸ>** [prepared statement] statement is constructed to substituteŸ<** a NULL value in place of the table column that would haveŸC** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]ŸD** return can be used to deny an untrusted user access to individual∂** columns of a table.ŸE** ^When a table is referenced by a [SELECT] but no column values areŸ9** extracted from that table (for example in a query likeŸI** "SELECT count(*) FROM tab") then the [SQLITE_READ] authorizer callbackŸM** is invoked once for that table with a column name that is an empty string.ŸB** ^If the action code is [SQLITE_DELETE] and the callback returnsŸ?** [SQLITE_IGNORE] then the [DELETE] operation proceeds but theŸM** [truncate optimization] is disabled and all rows are deleted individually.¢**Ÿ;** An authorizer is used when [sqlite3_prepare | preparing]ŸM** SQL statements from an untrusted source, to ensure that the SQL statementsŸM** do not try to access data they are not allowed to see, or that they do notŸE** try to execute malicious statements that damage the database.  ForŸ>** example, an application may allow a user to enter arbitraryŸF** SQL queries for evaluation by a database.  But the application doesŸ@** not want the user to be able to make arbitrary changes to theŸ@** database.  An authorizer could then be put in place while theŸ>** user-entered SQL is being [sqlite3_prepare | prepared] thatŸ3** disallows everything except [SELECT] statements.¢**Ÿ?** Applications that need to process SQL from untrusted sourcesŸG** might also consider lowering resource limits using [sqlite3_limit()]ŸA** and limiting database size using the [max_page_count] [PRAGMA]Ÿ&** in addition to using an authorizer.¢**ŸF** ^(Only a single authorizer can be in place on a database connectionŸ@** at a time.  Each call to sqlite3_set_authorizer overrides theŸK** previous call.)^  ^Disable the authorizer by installing a NULL callback.Ÿ)** The authorizer is disabled by default.¢**Ÿ@** The authorizer callback must not do anything that will modifyŸ@** the database connection that invoked the authorizer callback.ŸJ** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify theirŸF** database connections for the meaning of "modify" in this paragraph.¢**ŸC** ^When [sqlite3_prepare_v2()] is used to prepare a statement, theŸC** statement might be re-prepared during [sqlite3_step()] due to a Ÿ@** schema change.  Hence, the application should ensure that theŸL** correct authorizer callback remains in place during the [sqlite3_step()].¢**Ÿ<** ^Note that the authorizer callback is invoked only duringŸ=** [sqlite3_prepare()] or its variants.  Authorization is notŸD** performed during statement evaluation in [sqlite3_step()], unlessŸ>** as stated in the previous paragraph, sqlite3_step() invokesŸG** sqlite3_prepare_v2() to reprepare a statement after a schema change.¢*/Ÿ&SQLITE_API int sqlite3_set_authorizer(´  sqlite3*,ŸJ  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),±  void *pUserData¢);†¢/*Ÿ$** CAPI3REF: Authorizer Return Codes¢**ŸC** The [sqlite3_set_authorizer | authorizer callback function] mustŸC** return either [SQLITE_OK] or one of these two constants in orderŸD** to signal SQLite whether or not the action is permitted.  See theŸE** [sqlite3_set_authorizer | authorizer documentation] for additionalØ** information.¢**ŸG** Note that SQLITE_IGNORE is also used as a [conflict resolution mode]Ÿ<** returned from the [sqlite3_vtab_on_conflict()] interface.¢*/ŸE#define SQLITE_DENY   1   /* Abort the SQL statement with an error */ŸO#define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */†¢/*Ÿ$** CAPI3REF: Authorizer Action Codes¢**ŸI** The [sqlite3_set_authorizer()] interface registers a callback functionŸC** that is invoked to authorize certain SQL statement actions.  TheŸE** second parameter to the callback is an integer code that specifiesŸL** what action is being authorized.  These are the integer action codes thatŸ)** the authorizer callback may be passed.¢**ŸC** These action code values signify what kind of operation is to beŸ?** authorized.  The 3rd and 4th parameters to the authorizationŸK** callback function will be parameters or NULL depending on which of theseŸE** codes is used as the second parameter.  ^(The 5th parameter to theŸC** authorizer callback is the name of the database ("main", "temp",ŸH** etc.) if applicable.)^  ^The 6th parameter to the authorizer callbackŸH** is the name of the inner-most trigger or view that is responsible forŸE** the access attempt or NULL if this access attempt is directly from∂** top-level SQL code.¢*/ŸN/******************************************* 3rd ************ 4th ***********/ŸN#define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */ŸN#define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */ŸN#define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */ŸN#define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */ŸN#define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */ŸN#define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */ŸN#define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */ŸN#define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */ŸN#define SQLITE_DELETE                9   /* Table Name      NULL            */ŸN#define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */ŸN#define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */ŸN#define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */ŸN#define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */ŸN#define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */ŸN#define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */ŸN#define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */ŸN#define SQLITE_DROP_VIEW            17   /* View Name       NULL            */ŸN#define SQLITE_INSERT               18   /* Table Name      NULL            */ŸN#define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */ŸN#define SQLITE_READ                 20   /* Table Name      Column Name     */ŸN#define SQLITE_SELECT               21   /* NULL            NULL            */ŸN#define SQLITE_TRANSACTION          22   /* Operation       NULL            */ŸN#define SQLITE_UPDATE               23   /* Table Name      Column Name     */ŸN#define SQLITE_ATTACH               24   /* Filename        NULL            */ŸN#define SQLITE_DETACH               25   /* Database Name   NULL            */ŸN#define SQLITE_ALTER_TABLE          26   /* Database Name   Table Name      */ŸN#define SQLITE_REINDEX              27   /* Index Name      NULL            */ŸN#define SQLITE_ANALYZE              28   /* Table Name      NULL            */ŸN#define SQLITE_CREATE_VTABLE        29   /* Table Name      Module Name     */ŸN#define SQLITE_DROP_VTABLE          30   /* Table Name      Module Name     */ŸN#define SQLITE_FUNCTION             31   /* NULL            Function Name   */ŸN#define SQLITE_SAVEPOINT            32   /* Operation       Savepoint Name  */Ÿ=#define SQLITE_COPY                  0   /* No longer used */ŸN#define SQLITE_RECURSIVE            33   /* NULL            NULL            */†¢/*Ÿ,** CAPI3REF: Tracing And Profiling Functions≤** METHOD: sqlite3¢**ŸH** These routines are deprecated. Use the [sqlite3_trace_v2()] interfaceŸ*** instead of the routines described here.¢**ŸB** These routines register callback functions that can be used forŸ9** tracing and profiling the execution of SQL statements.¢**ŸE** ^The callback function registered by sqlite3_trace() is invoked atŸH** various times when an SQL statement is being run by [sqlite3_step()].ŸI** ^The sqlite3_trace() callback is invoked with a UTF-8 rendering of theŸ>** SQL statement text as the statement first begins executing.Ÿ5** ^(Additional sqlite3_trace() callbacks might occurŸG** as each triggered subprogram is entered.  The callbacks for triggersŸ=** contain a UTF-8 SQL comment that identifies the trigger.)^¢**ŸI** The [SQLITE_TRACE_SIZE_LIMIT] compile-time option can be used to limitŸN** the length of [bound parameter] expansion in the output of sqlite3_trace().¢**ŸD** ^The callback function registered by sqlite3_profile() is invokedŸB** as each SQL statement finishes.  ^The profile callback containsŸA** the original statement text and an estimate of wall-clock timeŸA** of how long that statement took to run.  ^The profile callbackŸF** time is in units of nanoseconds, however the current implementationŸI** is only capable of millisecond resolution so the six least significantŸA** digits in the time are meaningless.  Future versions of SQLiteŸB** might provide greater resolution on the profiler callback.  TheŸ?** sqlite3_profile() function is considered experimental and isŸ2** subject to change in future versions of SQLite.¢*/Ÿ:SQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3*,Ÿ,   void(*xTrace)(void*,const char*), void*);Ÿ<SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*,Ÿ=   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);†¢/*Ÿ"** CAPI3REF: SQL Trace Event Codesπ** KEYWORDS: SQLITE_TRACE¢**ŸC** These constants identify classes of events that can be monitoredŸ@** using the [sqlite3_trace_v2()] tracing logic.  The M argumentŸK** to [sqlite3_trace_v2(D,M,X,P)] is an OR-ed combination of one or more ofŸF** the following constants.  ^The first argument to the trace callbackŸ%** is one of the following constants.¢**Ÿ9** New tracing constants may be added in future releases.¢**Ÿ<** ^A trace callback has four arguments: xCallback(T,C,P,X).Ÿ:** ^The T argument is one of the integer type codes above.ŸD** ^The C argument is a copy of the context pointer passed in as theŸ+** fourth argument to [sqlite3_trace_v2()].ŸA** The P and X arguments are pointers whose meanings depend on T.¢**ß** <dl>Ÿ3** [[SQLITE_TRACE_STMT]] <dt>SQLITE_TRACE_STMT</dt>ŸJ** <dd>^An SQLITE_TRACE_STMT callback is invoked when a prepared statementŸ>** first begins running and possibly at other times during theŸD** execution of the prepared statement, such as at the start of eachŸ:** trigger subprogram. ^The P argument is a pointer to theŸG** [prepared statement]. ^The X argument is a pointer to a string whichŸJ** is the unexpanded SQL text of the prepared statement or an SQL comment ŸI** that indicates the invocation of a trigger.  ^The callback can computeŸN** the same text that would have been returned by the legacy [sqlite3_trace()]ŸI** interface by using the X argument when X begins with "--" and invokingŸ'** [sqlite3_expanded_sql(P)] otherwise.¢**Ÿ9** [[SQLITE_TRACE_PROFILE]] <dt>SQLITE_TRACE_PROFILE</dt>ŸH** <dd>^An SQLITE_TRACE_PROFILE callback provides approximately the sameŸB** information as is provided by the [sqlite3_profile()] callback.ŸC** ^The P argument is a pointer to the [prepared statement] and theŸB** X argument points to a 64-bit integer which is the estimated ofŸD** the number of nanosecond that the prepared statement took to run.ŸM** ^The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.¢**Ÿ1** [[SQLITE_TRACE_ROW]] <dt>SQLITE_TRACE_ROW</dt>ŸC** <dd>^An SQLITE_TRACE_ROW callback is invoked whenever a preparedŸ0** statement generates a single row of result.  ŸC** ^The P argument is a pointer to the [prepared statement] and the∏** X argument is unused.¢**Ÿ5** [[SQLITE_TRACE_CLOSE]] <dt>SQLITE_TRACE_CLOSE</dt>ŸA** <dd>^An SQLITE_TRACE_CLOSE callback is invoked when a databaseµ** connection closes.ŸC** ^The P argument is a pointer to the [database connection] objectŸ ** and the X argument is unused.®** </dl>¢*/Ÿ$#define SQLITE_TRACE_STMT       0x01Ÿ$#define SQLITE_TRACE_PROFILE    0x02Ÿ$#define SQLITE_TRACE_ROW        0x04Ÿ$#define SQLITE_TRACE_CLOSE      0x08†¢/*ª** CAPI3REF: SQL Trace Hook≤** METHOD: sqlite3¢**ŸF** ^The sqlite3_trace_v2(D,M,X,P) interface registers a trace callbackŸD** function X against [database connection] D, using property mask MŸ0** and context pointer P.  ^If the X callback isŸ@** NULL or if the M mask is zero, then tracing is disabled.  TheŸ8** M argument should be the bitwise OR-ed combination ofŸ)** zero or more [SQLITE_TRACE] constants.¢**ŸH** ^Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides ŸF** (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().¢**ŸG** ^The X callback is invoked whenever any of the events identified by ŸJ** mask M occur.  ^The integer return value from the callback is currentlyŸ@** ignored, though this may change in future releases.  CallbackŸE** implementations should return zero to ensure future compatibility.¢**ŸG** ^A trace callback is invoked with four arguments: callback(T,C,P,X).Ÿ/** ^The T argument is one of the [SQLITE_TRACE]Ÿ6** constants to indicate why the callback was invoked.Ÿ4** ^The C argument is a copy of the context pointer.ŸA** The P and X arguments are pointers whose meanings depend on T.¢**ŸE** The sqlite3_trace_v2() interface is intended to replace the legacyŸF** interfaces [sqlite3_trace()] and [sqlite3_profile()], both of which≤** are deprecated.¢*/Ÿ SQLITE_API int sqlite3_trace_v2(´  sqlite3*,±  unsigned uMask,Ÿ.  int(*xCallback)(unsigned,void*,void*,void*),¨  void *pCtx¢);†¢/*Ÿ%** CAPI3REF: Query Progress Callbacks≤** METHOD: sqlite3¢**ŸG** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callbackŸE** function X to be invoked periodically during long running calls toŸC** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] forŸ2** database connection D.  An example use for thisŸ;** interface is to keep a GUI updated during a large query.¢**ŸC** ^The parameter P is passed through as the only parameter to the ŸG** callback function X.  ^The parameter N is the approximate number of ŸG** [virtual machine instructions] that are evaluated between successiveŸK** invocations of the callback X.  ^If N is less than one then the progress∑** handler is disabled.¢**ŸA** ^Only a single progress handler may be defined at one time perŸD** [database connection]; setting a new progress handler cancels theŸH** old one.  ^Setting parameter X to NULL disables the progress handler.ŸF** ^The progress handler is also disabled by setting N to a value less™** than 1.¢**Ÿ?** ^If the progress callback returns non-zero, the operation isŸ8** interrupted.  This feature can be used to implement aŸ0** "Cancel" button on a GUI progress dialog box.¢**ŸF** The progress handler callback must not do anything that will modifyŸ=** the database connection that invoked the progress handler.ŸJ** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify theirŸF** database connections for the meaning of "modify" in this paragraph.¢**¢*/ŸNSQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);†¢/*Ÿ.** CAPI3REF: Opening A New Database Connection∑** CONSTRUCTOR: sqlite3¢**ŸD** ^These routines open an SQLite database file as specified by the ŸH** filename argument. ^The filename argument is interpreted as UTF-8 forŸH** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byteŸJ** order for sqlite3_open16(). ^(A [database connection] handle is usuallyŸJ** returned in *ppDb, even if an error occurs.  The only exception is thatŸG** if SQLite is unable to allocate memory to hold the [sqlite3] object,ŸJ** a NULL will be written into *ppDb instead of a pointer to the [sqlite3]ŸL** object.)^ ^(If the database is opened (and/or created) successfully, thenŸJ** [SQLITE_OK] is returned.  Otherwise an [error code] is returned.)^ ^TheŸL** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtainŸJ** an English language description of the error following a failure of anyŸ"** of the sqlite3_open() routines.¢**ŸB** ^The default encoding will be UTF-8 for databases created usingŸL** sqlite3_open() or sqlite3_open_v2().  ^The default encoding for databasesŸJ** created using sqlite3_open16() will be UTF-16 in the native byte order.¢**Ÿ>** Whether or not an error occurs when it is opened, resourcesŸI** associated with the [database connection] handle should be released byŸA** passing it to [sqlite3_close()] when it is no longer required.¢**Ÿ<** The sqlite3_open_v2() interface works like sqlite3_open()ŸJ** except that it accepts two additional parameters for additional controlŸ>** over the new database connection.  ^(The flags parameter toŸ$** sqlite3_open_v2() can take one ofŸ<** the following three values, optionally combined with the ŸM** [SQLITE_OPEN_NOMUTEX], [SQLITE_OPEN_FULLMUTEX], [SQLITE_OPEN_SHAREDCACHE],Ÿ@** [SQLITE_OPEN_PRIVATECACHE], and/or [SQLITE_OPEN_URI] flags:)^¢**ß** <dl>Ÿ$** ^(<dt>[SQLITE_OPEN_READONLY]</dt>ŸJ** <dd>The database is opened in read-only mode.  If the database does notŸ.** already exist, an error is returned.</dd>)^¢**Ÿ%** ^(<dt>[SQLITE_OPEN_READWRITE]</dt>ŸM** <dd>The database is opened for reading and writing if possible, or readingŸJ** only if the file is write protected by the operating system.  In eitherŸO** case the database must already exist, otherwise an error is returned.</dd>)^¢**Ÿ<** ^(<dt>[SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]</dt>ŸH** <dd>The database is opened for reading and writing, and is created ifŸJ** it does not already exist. This is the behavior that is always used forŸ.** sqlite3_open() and sqlite3_open16().</dd>)^®** </dl>¢**Ÿ>** If the 3rd parameter to sqlite3_open_v2() is not one of theŸ:** combinations shown above optionally combined with otherŸ.** [SQLITE_OPEN_READONLY | SQLITE_OPEN_* bits]Ÿ"** then the behavior is undefined.¢**ŸJ** ^If the [SQLITE_OPEN_NOMUTEX] flag is set, then the database connectionŸJ** opens in the multi-thread [threading mode] as long as the single-threadŸ@** mode has not been set at compile-time or start-time.  ^If theŸI** [SQLITE_OPEN_FULLMUTEX] flag is set then the database connection opensŸ>** in the serialized [threading mode] unless single-thread wasŸ5** previously selected at compile-time or start-time.ŸK** ^The [SQLITE_OPEN_SHAREDCACHE] flag causes the database connection to beŸK** eligible to use [shared cache mode], regardless of whether or not sharedŸ@** cache is enabled using [sqlite3_enable_shared_cache()].  ^TheŸH** [SQLITE_OPEN_PRIVATECACHE] flag causes the database connection to notŸ<** participate in [shared cache mode] even if it is enabled.¢**Ÿ@** ^The fourth parameter to sqlite3_open_v2() is the name of theŸH** [sqlite3_vfs] object that defines the operating system interface thatŸG** the new database connection should use.  ^If the fourth parameter isŸ@** a NULL pointer then the default [sqlite3_vfs] object is used.¢**ŸO** ^If the filename is ":memory:", then a private, temporary in-memory databaseŸL** is created for the connection.  ^This in-memory database will vanish whenŸF** the database connection is closed.  Future versions of SQLite mightŸN** make use of additional special filenames that begin with the ":" character.ŸK** It is recommended that when a database filename actually does begin withŸI** a ":" character you should prefix the filename with a pathname such asª** "./" to avoid ambiguity.¢**ŸA** ^If the filename is an empty string, then a private, temporaryŸD** on-disk database will be created.  ^This private database will beŸF** automatically deleted as soon as the database connection is closed.¢**Ÿ=** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>¢**ŸJ** ^If [URI filename] interpretation is enabled, and the filename argumentŸG** begins with "file:", then the filename is interpreted as a URI. ^URIŸF** filename interpretation is enabled if the [SQLITE_OPEN_URI] flag isŸ?** set in the third argument to sqlite3_open_v2(), or if it hasŸF** been enabled globally using the [SQLITE_CONFIG_URI] option with theŸL** [sqlite3_config()] method or by the [SQLITE_USE_URI] compile-time option.Ÿ,** URI filename interpretation is turned offŸF** by default, but future releases of SQLite might enable URI filenameŸC** interpretation by default.  See "[URI filenames]" for additionalØ** information.¢**ŸJ** URI filenames are parsed according to RFC 3986. ^If the URI contains anŸC** authority, then it must be either an empty string or the string ŸL** "localhost". ^If the authority is not an empty string or "localhost", an ŸI** error is returned to the caller. ^The fragment component of a URI, if ∑** present, is ignored.¢**ŸJ** ^SQLite uses the path component of the URI as the name of the disk fileŸJ** which contains the database. ^If the path begins with a '/' character, ŸK** then it is interpreted as an absolute path. ^If the path does not begin ŸJ** with a '/' (meaning that the authority section is omitted from the URI)Ÿ4** then the path is interpreted as a relative path. Ÿ9** ^(On windows, the first component of an absolute path Ÿ*** is a drive specification (e.g. "C:").)^¢**Ÿ ** [[core URI query parameters]]ŸK** The query component of a URI may contain parameters that are interpretedŸF** either by SQLite itself, or by a [VFS | custom VFS implementation].Ÿ0** SQLite and its built-in [VFSes] interpret theæ** following query parameters:¢**ß** <ul>ŸM**   <li> <b>vfs</b>: ^The "vfs" parameter may be used to specify the name ofŸL**     a VFS object that provides the operating system interface that shouldŸM**     be used to access the database file on disk. ^If this option is set toŸM**     an empty string the default VFS object is used. ^Specifying an unknownŸK**     VFS is an error. ^If sqlite3_open_v2() is used and the vfs option isŸJ**     present, then the VFS specified by the option takes precedence overŸE**     the value passed as the fourth parameter to sqlite3_open_v2().¢**ŸL**   <li> <b>mode</b>: ^(The mode parameter may be set to either "ro", "rw",ŸE**     "rwc", or "memory". Attempting to set it to any other value is≥**     an error)^. ŸH**     ^If "ro" is specified, then the database is opened for read-only ŸN**     access, just as if the [SQLITE_OPEN_READONLY] flag had been set in the ŸJ**     third argument to sqlite3_open_v2(). ^If the mode option is set to ŸI**     "rw", then the database is opened for read-write (but not create) ŸL**     access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had Ÿ<**     been set. ^Value "rwc" is equivalent to setting both ŸL**     SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.  ^If the mode option isŸH**     set to "memory" then a pure [in-memory database] that never readsŸJ**     or writes from disk is used. ^It is an error to specify a value forŸI**     the mode parameter that is less restrictive than that specified byŸD**     the flags passed in the third parameter to sqlite3_open_v2().¢**ŸM**   <li> <b>cache</b>: ^The cache parameter may be set to either "shared" orŸF**     "private". ^Setting it to "shared" is equivalent to setting theŸB**     SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed toŸG**     sqlite3_open_v2(). ^Setting the cache parameter to "private" is Ÿ>**     equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit.ŸL**     ^If sqlite3_open_v2() is used and the "cache" parameter is present inŸL**     a URI filename, its value overrides any behavior requested by settingŸ@**     SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.¢**ŸF**  <li> <b>psow</b>: ^The psow parameter indicates whether or not theŸC**     [powersafe overwrite] property does or does not apply to theŸ8**     storage media on which the database file resides.¢**ŸJ**  <li> <b>nolock</b>: ^The nolock parameter is a boolean query parameterŸJ**     which if set disables file locking in rollback journal modes.  ThisŸG**     is useful for accessing a database on a filesystem that does notŸJ**     support locking.  Caution:  Database corruption might result if twoŸH**     or more processes write to the same database and any one of thoseø**     processes uses nolock=1.¢**ŸF**  <li> <b>immutable</b>: ^The immutable parameter is a boolean queryŸC**     parameter that indicates that the database file is stored onŸH**     read-only media.  ^When immutable is set, SQLite assumes that theŸE**     database file cannot be changed, even by a process with higherŸI**     privilege, and so the database is opened read-only and all lockingŸH**     and change detection is disabled.  Caution: Setting the immutableŸF**     property on a database file that does in fact change can resultŸA**     in incorrect query results and/or [SQLITE_CORRUPT] errors.Ÿ***     See also: [SQLITE_IOCAP_IMMUTABLE].©**       ®** </ul>¢**ŸM** ^Specifying an unknown parameter in the query component of a URI is not anŸF** error.  Future versions of SQLite might understand additional queryŸK** parameters.  See "[query parameters with special meaning to SQLite]" for∫** additional information.¢**Ÿ;** [[URI filename examples]] <h3>URI filename examples</h3>¢**Ÿ0** <table border="1" align=center cellpadding=5>Ÿ&** <tr><th> URI filenames <th> Resultsæ** <tr><td> file:data.db <td> Ÿ=**          Open the file "data.db" in the current directory.Ÿ'** <tr><td> file:/home/fred/data.db<br>Ÿ+**          file:///home/fred/data.db <br> Ÿ9**          file://localhost/home/fred/data.db <br> <td> Ÿ8**          Open the database file "/home/fred/data.db".Ÿ3** <tr><td> file://darkstar/home/fred/data.db <td> Ÿ?**          An error. "darkstar" is not a recognized authority.Ÿ'** <tr><td style="white-space:nowrap"> ŸF**          file:///C:/Documents%20and%20Settings/fred/Desktop/data.dbŸL**     <td> Windows only: Open the file "data.db" on fred's desktop on driveŸK**          C:. Note that the %20 escaping in this example is not strictly Ÿ>**          necessary - space characters can be used literallyΩ**          in URI filenames.Ÿ4** <tr><td> file:data.db?mode=ro&cache=private <td> ŸN**          Open file "data.db" in the current directory for read-only access.ŸH**          Regardless of whether or not shared-cache mode is enabled byŸ)**          default, use a private cache.Ÿ9** <tr><td> file:/home/fred/data.db?vfs=unix-dotfile <td>ŸN**          Open file "/home/fred/data.db". Use the special VFS "unix-dotfile"ŸC**          that uses dot-files in place of posix advisory locking.Ÿ,** <tr><td> file:data.db?mode=readonly <td> ŸP**          An error. "readonly" is not a valid option for the "mode" parameter.´** </table>¢**ŸL** ^URI hexadecimal escape sequences (%HH) are supported within the path andŸI** query components of a URI. A hexadecimal escape sequence consists of aŸC** percent sign - "%" - followed by exactly two hexadecimal digits ŸG** specifying an octet value. ^Before the path or query components of aŸF** URI filename are interpreted, they are encoded using UTF-8 and all ŸH** hexadecimal escape sequences replaced by a single byte containing theŸL** corresponding octet. If this process generates an invalid UTF-8 encoding,Ω** the results are undefined.¢**ŸM** <b>Note to Windows users:</b>  The encoding used for the filename argumentŸF** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whateverŸE** codepage is currently defined.  Filenames containing internationalŸC** characters must be converted to UTF-8 prior to passing them intoŸ'** sqlite3_open() or sqlite3_open_v2().¢**ŸM** <b>Note to Windows Runtime users:</b>  The temporary directory must be setŸL** prior to calling sqlite3_open() or sqlite3_open_v2().  Otherwise, variousŸ=** features that require the use of temporary files may fail.¢**Ÿ%** See also: [sqlite3_temp_directory]¢*/ºSQLITE_API int sqlite3_open(Ÿ9  const char *filename,   /* Database filename (UTF-8) */Ÿ5  sqlite3 **ppDb          /* OUT: SQLite db handle */¢);æSQLITE_API int sqlite3_open16(Ÿ:  const void *filename,   /* Database filename (UTF-16) */Ÿ5  sqlite3 **ppDb          /* OUT: SQLite db handle */¢);øSQLITE_API int sqlite3_open_v2(Ÿ9  const char *filename,   /* Database filename (UTF-8) */Ÿ5  sqlite3 **ppDb,         /* OUT: SQLite db handle */Ÿ%  int flags,              /* Flags */Ÿ9  const char *zVfs        /* Name of VFS module to use */¢);†¢/*Ÿ-** CAPI3REF: Obtain Values For URI Parameters¢**ŸH** These are utility routines, useful to VFS implementations, that checkŸG** to see if a database file was a URI that contained a specific query ŸB** parameter, and if so obtains the value of that query parameter.¢**ŸK** If F is the database filename pointer passed into the xOpen() method of ŸG** a VFS implementation when the flags parameter to xOpen() has one or ŸF** more of the [SQLITE_OPEN_URI] or [SQLITE_OPEN_MAIN_DB] bits set andŸ-** P is the name of the query parameter, thenŸ8** sqlite3_uri_parameter(F,P) returns the value of the PŸF** parameter if it exists or a NULL pointer if P does not appear as a Ÿ8** query parameter on F.  If P is a query parameter of FŸA** has no explicit value, then sqlite3_uri_parameter(F,P) returnsŸ ** a pointer to an empty string.¢**ŸE** The sqlite3_uri_boolean(F,P,B) routine assumes that P is a booleanŸE** parameter and returns true (1) or false (0) according to the valueŸH** of P.  The sqlite3_uri_boolean(F,P,B) routine returns true (1) if theŸE** value of query parameter P is one of "yes", "true", or "on" in anyŸ<** case or if the value begins with a non-zero number.  The ŸH** sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value ofŸE** query parameter P is one of "no", "false", or "off" in any case orŸ@** if the value begins with a numeric zero.  If P is not a queryŸC** parameter on F or if the value of P is does not match any of theŸ9** above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).¢**ŸF** The sqlite3_uri_int64(F,P,D) routine converts the value of P into aŸE** 64-bit signed integer and returns that integer, or D if P does notŸE** exist.  If the value of P is something other than an integer, then¥** zero is returned.£** ŸK** If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL andŸH** sqlite3_uri_boolean(F,P,B) returns B.  If F is not a NULL pointer andŸL** is not a database file pathname pointer that SQLite passed into the xOpenŸJ** VFS method, then the behavior of this routine is undefined and probablyØ** undesirable.¢*/ŸXSQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);ŸXSQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);ŸTSQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);††¢/*Ÿ%** CAPI3REF: Error Codes And Messages≤** METHOD: sqlite3¢**Ÿ:** ^If the most recent sqlite3_* API call associated with ŸH** [database connection] D failed, then the sqlite3_errcode(D) interfaceŸG** returns the numeric [result code] or [extended result code] for that¨** API call.Ÿ.** If the most recent API call was successful,Ÿ=** then the return value from sqlite3_errcode() is undefined.Ÿ"** ^The sqlite3_extended_errcode()Ÿ;** interface is the same except that it always returns the Ÿ=** [extended result code] even when extended result codes are¨** disabled.¢**ŸG** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-languageŸI** text that describes the error, as either UTF-8 or UTF-16 respectively.ŸC** ^(Memory to hold the error message string is managed internally.ŸC** The application does not need to worry about freeing the result.ŸC** However, the error string might be overwritten or deallocated byŸ:** subsequent calls to other SQLite interface functions.)^¢**ŸD** ^The sqlite3_errstr() interface returns the English-language textŸ.** that describes the [result code], as UTF-8.ŸB** ^(Memory to hold the error message string is managed internallyŸ.** and must not be freed by the application)^.¢**ŸB** When the serialized [threading mode] is in use, it might be theŸB** case that a second error occurs on a separate thread in betweenŸ@** the time of the first error and the call to these interfaces.ŸC** When that happens, the second error will be reported since theseŸ=** interfaces always report the most recent result.  To avoidŸL** this, each thread can obtain exclusive use of the [database connection] DŸL** by invoking [sqlite3_mutex_enter]([sqlite3_db_mutex](D)) before beginningŸK** to use D and invoking [sqlite3_mutex_leave]([sqlite3_db_mutex](D)) afterŸ9** all calls to the interfaces listed here are completed.¢**ŸE** If an interface fails with SQLITE_MISUSE, that means the interfaceŸA** was invoked incorrectly by the application.  In that case, theŸ0** error code and message may or may not be set.¢*/Ÿ,SQLITE_API int sqlite3_errcode(sqlite3 *db);Ÿ5SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);Ÿ0SQLITE_API const char *sqlite3_errmsg(sqlite3*);Ÿ2SQLITE_API const void *sqlite3_errmsg16(sqlite3*);Ÿ+SQLITE_API const char *sqlite3_errstr(int);†¢/*Ÿ&** CAPI3REF: Prepared Statement ObjectŸ7** KEYWORDS: {prepared statement} {prepared statements}¢**ŸD** An instance of this object represents a single SQL statement thatŸC** has been compiled into binary form and is ready to be evaluated.¢**ŸC** Think of each SQL statement as a separate computer program.  TheŸB** original SQL text is source code.  A prepared statement object ŸA** is the compiled object code.  All SQL must be converted into aŸ+** prepared statement before it can be run.¢**ŸH** The life-cycle of a prepared statement object usually goes like this:¢**ß** <ol>ŸJ** <li> Create the prepared statement object using [sqlite3_prepare_v2()].Ÿ>** <li> Bind values to [parameters] using the sqlite3_bind_*()≥**      interfaces.ŸB** <li> Run the SQL by calling [sqlite3_step()] one or more times.ŸI** <li> Reset the prepared statement using [sqlite3_reset()] then go backŸ/**      to step 2.  Do this zero or more times.Ÿ6** <li> Destroy the object using [sqlite3_finalize()].®** </ol>¢*/Ÿ)typedef struct sqlite3_stmt sqlite3_stmt;†¢/*º** CAPI3REF: Run-time Limits≤** METHOD: sqlite3¢**ŸG** ^(This interface allows the size of various constructs to be limitedŸC** on a connection by connection basis.  The first parameter is theŸB** [database connection] whose limit is to be set or queried.  TheŸB** second parameter is one of the [limit categories] that define aŸF** class of constructs to be size limited.  The third parameter is theŸ"** new limit for that construct.)^¢**ŸB** ^If the new limit is a negative number, the limit is unchanged.ŸA** ^(For each limit category SQLITE_LIMIT_<i>NAME</i> there is a æ** [limits | hard upper bound]Ÿ7** set at compile-time by a C preprocessor macro calledŸ%** [limits | SQLITE_MAX_<i>NAME</i>].Ÿ7** (The "_LIMIT_" in the name is changed to "_MAX_".))^Ÿ?** ^Attempts to increase a limit above its hard upper bound areŸ.** silently truncated to the hard upper bound.¢**Ÿ<** ^Regardless of whether or not the limit was changed, the ŸD** [sqlite3_limit()] interface returns the prior value of the limit.ŸD** ^Hence, to find the current value of a limit without changing it,ŸC** simply invoke this interface with the third parameter set to -1.¢**ŸC** Run-time limits are intended for use in applications that manageŸJ** both their own internal database and also databases that are controlledŸD** by untrusted external sources.  An example application might be aŸA** web browser that has its own databases for storing history andŸF** separate databases controlled by JavaScript applications downloadedŸ=** off the Internet.  The internal databases can be given theŸD** large, default limits.  Databases managed by external sources canŸG** be given much smaller limits designed to prevent a denial of serviceŸL** attack.  Developers might also want to use the [sqlite3_set_authorizer()]ŸH** interface to further control untrusted SQL.  The size of the databaseŸ<** created by an untrusted script can be contained using theΩ** [max_page_count] [PRAGMA].¢**ŸA** New run-time limit categories may be added in future releases.¢*/Ÿ;SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);†¢/*Ÿ&** CAPI3REF: Run-Time Limit CategoriesŸ1** KEYWORDS: {limit category} {*limit categories}¢**Ÿ4** These constants define various performance limitsŸ;** that can be lowered at run-time using [sqlite3_limit()].ŸE** The synopsis of the meanings of the various limits is shown below.ŸF** Additional information is available at [limits | Limits in SQLite].¢**ß** <dl>Ÿ9** [[SQLITE_LIMIT_LENGTH]] ^(<dt>SQLITE_LIMIT_LENGTH</dt>ŸK** <dd>The maximum size of any string or BLOB or table row, in bytes.<dd>)^¢**ŸA** [[SQLITE_LIMIT_SQL_LENGTH]] ^(<dt>SQLITE_LIMIT_SQL_LENGTH</dt>Ÿ?** <dd>The maximum length of an SQL statement, in bytes.</dd>)^¢**Ÿ9** [[SQLITE_LIMIT_COLUMN]] ^(<dt>SQLITE_LIMIT_COLUMN</dt>ŸD** <dd>The maximum number of columns in a table definition or in theŸH** result set of a [SELECT] or the maximum number of columns in an indexŸ/** or in an ORDER BY or GROUP BY clause.</dd>)^¢**ŸA** [[SQLITE_LIMIT_EXPR_DEPTH]] ^(<dt>SQLITE_LIMIT_EXPR_DEPTH</dt>ŸD** <dd>The maximum depth of the parse tree on any expression.</dd>)^¢**ŸK** [[SQLITE_LIMIT_COMPOUND_SELECT]] ^(<dt>SQLITE_LIMIT_COMPOUND_SELECT</dt>ŸI** <dd>The maximum number of terms in a compound SELECT statement.</dd>)^¢**Ÿ;** [[SQLITE_LIMIT_VDBE_OP]] ^(<dt>SQLITE_LIMIT_VDBE_OP</dt>ŸF** <dd>The maximum number of instructions in a virtual machine programŸD** used to implement an SQL statement.  If [sqlite3_prepare_v2()] orŸI** the equivalent tries to allocate space for more than this many opcodesŸL** in a single prepared statement, an SQLITE_NOMEM error is returned.</dd>)^¢**ŸE** [[SQLITE_LIMIT_FUNCTION_ARG]] ^(<dt>SQLITE_LIMIT_FUNCTION_ARG</dt>Ÿ<** <dd>The maximum number of arguments on a function.</dd>)^¢**Ÿ=** [[SQLITE_LIMIT_ATTACHED]] ^(<dt>SQLITE_LIMIT_ATTACHED</dt>ŸB** <dd>The maximum number of [ATTACH | attached databases].)^</dd>¢**Ÿ'** [[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]]Ÿ.** ^(<dt>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</dt>ŸB** <dd>The maximum length of the pattern argument to the [LIKE] orª** [GLOB] operators.</dd>)^¢**Ÿ#** [[SQLITE_LIMIT_VARIABLE_NUMBER]]Ÿ*** ^(<dt>SQLITE_LIMIT_VARIABLE_NUMBER</dt>ŸI** <dd>The maximum index number of any [parameter] in an SQL statement.)^¢**ŸG** [[SQLITE_LIMIT_TRIGGER_DEPTH]] ^(<dt>SQLITE_LIMIT_TRIGGER_DEPTH</dt>Ÿ:** <dd>The maximum depth of recursion for triggers.</dd>)^¢**ŸI** [[SQLITE_LIMIT_WORKER_THREADS]] ^(<dt>SQLITE_LIMIT_WORKER_THREADS</dt>ŸC** <dd>The maximum number of auxiliary worker threads that a singleŸ)** [prepared statement] may start.</dd>)^®** </dl>¢*/Ÿ0#define SQLITE_LIMIT_LENGTH                    0Ÿ0#define SQLITE_LIMIT_SQL_LENGTH                1Ÿ0#define SQLITE_LIMIT_COLUMN                    2Ÿ0#define SQLITE_LIMIT_EXPR_DEPTH                3Ÿ0#define SQLITE_LIMIT_COMPOUND_SELECT           4Ÿ0#define SQLITE_LIMIT_VDBE_OP                   5Ÿ0#define SQLITE_LIMIT_FUNCTION_ARG              6Ÿ0#define SQLITE_LIMIT_ATTACHED                  7Ÿ0#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8Ÿ0#define SQLITE_LIMIT_VARIABLE_NUMBER           9Ÿ0#define SQLITE_LIMIT_TRIGGER_DEPTH            10Ÿ0#define SQLITE_LIMIT_WORKER_THREADS           11†¢/*∫** CAPI3REF: Prepare Flags¢**Ÿ?** These constants define various flags that can be passed intoŸ:** "prepFlags" parameter of the [sqlite3_prepare_v3()] andŸ'** [sqlite3_prepare16_v3()] interfaces.¢**Ÿ7** New flags may be added in future releases of SQLite.¢**ß** <dl>ŸE** [[SQLITE_PREPARE_PERSISTENT]] ^(<dt>SQLITE_PREPARE_PERSISTENT</dt>ŸH** <dd>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query plannerŸC** that the prepared statement will be retained for a long time andŸK** probably reused many times.)^ ^Without this flag, [sqlite3_prepare_v3()]ŸH** and [sqlite3_prepare16_v3()] assume that the prepared statement will ŸD** be used just once or at most a few times and then destroyed usingŸH** [sqlite3_finalize()] relatively soon. The current implementation actsŸF** on this hint by avoiding the use of [lookaside memory] so as not toŸD** deplete the limited store of lookaside memory. Future versions ofŸ+** SQLite may act on this hint differently.®** </dl>¢*/Ÿ3#define SQLITE_PREPARE_PERSISTENT              0x01†¢/*Ÿ'** CAPI3REF: Compiling An SQL StatementŸ%** KEYWORDS: {SQL statement compiler}≤** METHOD: sqlite3º** CONSTRUCTOR: sqlite3_stmt¢**ŸJ** To execute an SQL statement, it must first be compiled into a byte-codeŸK** program using one of these routines.  Or, in other words, these routinesŸ8** are constructors for the [prepared statement] object.¢**Ÿ?** The preferred routine to use is [sqlite3_prepare_v2()].  TheŸA** [sqlite3_prepare()] interface is legacy and should be avoided.ŸF** [sqlite3_prepare_v3()] has an extra "prepFlags" option that is used∏** for special purposes.¢**ŸD** The use of the UTF-8 interfaces is preferred, as SQLite currentlyŸD** does all parsing using UTF-8.  The UTF-16 interfaces are providedŸB** as a convenience.  The UTF-16 interfaces work by converting theŸJ** input text into UTF-8, then invoking the corresponding UTF-8 interface.¢**ŸG** The first argument, "db", is a [database connection] obtained from aŸD** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] orŸJ** [sqlite3_open16()].  The database connection must not have been closed.¢**ŸH** The second argument, "zSql", is the statement to be compiled, encodedŸK** as either UTF-8 or UTF-16.  The sqlite3_prepare(), sqlite3_prepare_v2(),ª** and sqlite3_prepare_v3()ŸI** interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(),Ÿ)** and sqlite3_prepare16_v3() use UTF-16.¢**ŸB** ^If the nByte argument is negative, then zSql is read up to theŸ?** first zero terminator. ^If nByte is positive, then it is theŸG** number of bytes read from zSql.  ^If nByte is zero, then no prepared∫** statement is generated.ŸG** If the caller knows that the supplied string is nul-terminated, thenŸL** there is a small performance advantage to passing an nByte parameter thatŸ>** is the number of bytes in the input string <i>including</i>∂** the nul-terminator.¢**ŸI** ^If pzTail is not NULL then *pzTail is made to point to the first byteŸH** past the end of the first SQL statement in zSql.  These routines onlyŸF** compile the first statement in zSql, so *pzTail is left pointing toª** what remains uncompiled.¢**ŸK** ^*ppStmt is left pointing to a compiled [prepared statement] that can beŸJ** executed using [sqlite3_step()].  ^If there is an error, *ppStmt is setŸI** to NULL.  ^If the input text contains no SQL (if the input is an emptyŸ4** string or a comment) then *ppStmt is set to NULL.ŸA** The calling procedure is responsible for deleting the compiledŸJ** SQL statement using [sqlite3_finalize()] after it has finished with it.∫** ppStmt may not be NULL.¢**ŸL** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];Ÿ)** otherwise an [error code] is returned.¢**ŸJ** The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(),ŸN** and sqlite3_prepare16_v3() interfaces are recommended for all new programs.ŸC** The older interfaces (sqlite3_prepare() and sqlite3_prepare16())ŸJ** are retained for backwards compatibility, but their use is discouraged.Ÿ2** ^In the "vX" interfaces, the prepared statementŸF** that is returned (the [sqlite3_stmt] object) contains a copy of theŸC** original SQL text. This causes the [sqlite3_step()] interface toŸ$** behave differently in three ways:¢**ß** <ol>ß** <li>ŸN** ^If the database schema changes, instead of returning [SQLITE_SCHEMA] as itŸK** always used to do, [sqlite3_step()] will automatically recompile the SQLŸJ** statement and try to run it again. As many as [SQLITE_MAX_SCHEMA_RETRY]ŸJ** retries will occur before sqlite3_step() gives up and returns an error.®** </li>¢**ß** <li>ŸJ** ^When an error occurs, [sqlite3_step()] will return one of the detailedŸJ** [error codes] or [extended error codes].  ^The legacy behavior was thatŸJ** [sqlite3_step()] would only return a generic [SQLITE_ERROR] result codeŸL** and the application would have to make a second call to [sqlite3_reset()]ŸN** in order to find the underlying cause of the problem. With the "v2" prepareŸK** interfaces, the underlying reason for the error is returned immediately.®** </li>¢**ß** <li>ŸG** ^If the specific value bound to [parameter | host parameter] in the ŸI** WHERE clause might influence the choice of query plan for a statement,ŸM** then the statement will be automatically recompiled, as if there had been ŸL** a schema change, on the first  [sqlite3_step()] call following any changeŸ>** to the [sqlite3_bind_text | bindings] of that [parameter]. ŸG** ^The specific value of WHERE-clause [parameter] might influence the ŸJ** choice of query plan if the parameter is the left-hand side of a [LIKE]ŸJ** or [GLOB] operator or if the parameter is compared to an indexed columnŸ@** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.®** </li>®** </ol>¢**ŸL** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in havingŸL** the extra prepFlags parameter, which is a bit array consisting of zero orŸH** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^TheŸ;** sqlite3_prepare_v2() interface works exactly the same asŸ8** sqlite3_prepare_v3() with a zero prepFlags parameter.¢*/øSQLITE_API int sqlite3_prepare(Ÿ/  sqlite3 *db,            /* Database handle */Ÿ<  const char *zSql,       /* SQL statement, UTF-8 encoded */Ÿ@  int nByte,              /* Maximum length of zSql in bytes. */Ÿ5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ŸF  const char **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ÿ"SQLITE_API int sqlite3_prepare_v2(Ÿ/  sqlite3 *db,            /* Database handle */Ÿ<  const char *zSql,       /* SQL statement, UTF-8 encoded */Ÿ@  int nByte,              /* Maximum length of zSql in bytes. */Ÿ5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ŸF  const char **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ÿ"SQLITE_API int sqlite3_prepare_v3(Ÿ/  sqlite3 *db,            /* Database handle */Ÿ<  const char *zSql,       /* SQL statement, UTF-8 encoded */Ÿ@  int nByte,              /* Maximum length of zSql in bytes. */ŸB  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */Ÿ5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ŸF  const char **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ÿ!SQLITE_API int sqlite3_prepare16(Ÿ/  sqlite3 *db,            /* Database handle */Ÿ=  const void *zSql,       /* SQL statement, UTF-16 encoded */Ÿ@  int nByte,              /* Maximum length of zSql in bytes. */Ÿ5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ŸF  const void **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ÿ$SQLITE_API int sqlite3_prepare16_v2(Ÿ/  sqlite3 *db,            /* Database handle */Ÿ=  const void *zSql,       /* SQL statement, UTF-16 encoded */Ÿ@  int nByte,              /* Maximum length of zSql in bytes. */Ÿ5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ŸF  const void **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ÿ$SQLITE_API int sqlite3_prepare16_v3(Ÿ/  sqlite3 *db,            /* Database handle */Ÿ=  const void *zSql,       /* SQL statement, UTF-16 encoded */Ÿ@  int nByte,              /* Maximum length of zSql in bytes. */ŸB  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */Ÿ5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ŸF  const void **pzTail     /* OUT: Pointer to unused portion of zSql */¢);†¢/*Ÿ%** CAPI3REF: Retrieving Statement SQL∑** METHOD: sqlite3_stmt¢**ŸI** ^The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8Ÿ:** SQL text used to create [prepared statement] P if P wasŸ=** created by [sqlite3_prepare_v2()], [sqlite3_prepare_v3()],Ÿ9** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].ŸF** ^The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8Ÿ>** string containing the SQL text of prepared statement P withø** [bound parameters] expanded.¢**ŸB** ^(For example, if a prepared statement is created using the SQLŸI** text "SELECT $abc,:xyz" and if parameter $abc is bound to integer 2345Ÿ@** and parameter :xyz is unbound, then sqlite3_sql() will returnŸE** the original string, "SELECT $abc,:xyz" but sqlite3_expanded_sql()Ÿ$** will return "SELECT 2345,NULL".)^¢**ŸL** ^The sqlite3_expanded_sql() interface returns NULL if insufficient memoryŸE** is available to hold the result, or if the result would exceed theŸE** the maximum string length determined by the [SQLITE_LIMIT_LENGTH].¢**ŸH** ^The [SQLITE_TRACE_SIZE_LIMIT] compile-time option limits the size ofŸE** bound parameter expansions.  ^The [SQLITE_OMIT_TRACE] compile-timeŸ>** option causes sqlite3_expanded_sql() to always return NULL.¢**ŸE** ^The string returned by sqlite3_sql(P) is managed by SQLite and isŸ@** automatically freed when the prepared statement is finalized.ŸF** ^The string returned by sqlite3_expanded_sql(P), on the other hand,ŸJ** is obtained from [sqlite3_malloc()] and must be free by the applicationŸ%** by passing it to [sqlite3_free()].¢*/Ÿ8SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);Ÿ;SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);†¢/*Ÿ>** CAPI3REF: Determine If An SQL Statement Writes The Database∑** METHOD: sqlite3_stmt¢**ŸE** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) ifŸD** and only if the [prepared statement] X makes no direct changes toŸ$** the content of the database file.¢**Ÿ3** Note that [application-defined SQL functions] orŸL** [virtual tables] might change the database indirectly as a side effect.  ŸE** ^(For example, if an application defines a function "eval()" that ŸA** calls [sqlite3_exec()], then the following SQL statement wouldŸ1** change the database file through side-effects:¢**¥** <blockquote><pre>Ÿ,**    SELECT eval('DELETE FROM t1') FROM t2;∂** </pre></blockquote>¢**ŸG** But because the [SELECT] statement does not change the database fileŸ?** directly, sqlite3_stmt_readonly() would still return true.)^¢**ŸI** ^Transaction control statements such as [BEGIN], [COMMIT], [ROLLBACK],ŸK** [SAVEPOINT], and [RELEASE] cause sqlite3_stmt_readonly() to return true,ŸJ** since the statements themselves do not actually modify the database butŸF** rather they control the timing of when other statements modify the Ÿ>** database.  ^The [ATTACH] and [DETACH] statements also causeŸG** sqlite3_stmt_readonly() to return true since, while those statementsŸG** change the configuration of a database connection, they do not make Ÿ8** changes to the content of the database files on disk.ŸH** ^The sqlite3_stmt_readonly() interface returns true for [BEGIN] sinceŸJ** [BEGIN] merely sets internal flags, but the [BEGIN|BEGIN IMMEDIATE] andŸ@** [BEGIN|BEGIN EXCLUSIVE] commands do touch the database and soŸ<** sqlite3_stmt_readonly() returns false for those commands.¢*/Ÿ:SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);†¢/*Ÿ=** CAPI3REF: Determine If A Prepared Statement Has Been Reset∑** METHOD: sqlite3_stmt¢**ŸE** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if theŸ?** [prepared statement] S has been stepped at least once using Ÿ@** [sqlite3_step(S)] but has neither run to completion (returnedŸ,** [SQLITE_DONE] from [sqlite3_step(S)]) norŸB** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)ŸB** interface returns false if S is a NULL pointer.  If S is not a ŸD** NULL pointer and is not a pointer to a valid [prepared statement]ŸC** object, then the behavior is undefined and probably undesirable.¢**ŸB** This interface can be used in combination [sqlite3_next_stmt()]Ÿ@** to locate all prepared statements associated with a database ŸA** connection that are in need of being reset.  This can be used,Ÿ>** for example, in diagnostic routines to search for prepared Ÿ2** statements that are holding a transaction open.¢*/Ÿ0SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);†¢/*Ÿ+** CAPI3REF: Dynamically Typed Value ObjectŸB** KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}¢**Ÿ?** SQLite uses the sqlite3_value object to represent all valuesŸE** that can be stored in a database table. SQLite uses dynamic typingŸE** for the values it stores.  ^Values stored in sqlite3_value objectsŸC** can be integers, floating point values, strings, BLOBs, or NULL.¢**ŸF** An sqlite3_value object may be either "protected" or "unprotected".ŸG** Some interfaces require a protected sqlite3_value.  Other interfacesŸB** will accept either a protected or an unprotected sqlite3_value.ŸA** Every interface that accepts sqlite3_value arguments specifiesŸ=** whether or not it requires a protected sqlite3_value.  TheŸB** [sqlite3_value_dup()] interface can be used to construct a new Ÿ=** protected sqlite3_value from an unprotected sqlite3_value.¢**ŸB** The terms "protected" and "unprotected" refer to whether or notŸ>** a mutex is held.  An internal mutex is held for a protectedŸ?** sqlite3_value object but no mutex is held for an unprotectedŸE** sqlite3_value object.  If SQLite is compiled to be single-threadedŸK** (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)Ÿ5** or if SQLite is run in one of reduced mutex modes Ÿ>** [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]ŸA** then there is no distinction between protected and unprotectedŸH** sqlite3_value objects and they can be used interchangeably.  However,ŸC** for maximum code portability it is recommended that applicationsŸ?** still make the distinction between protected and unprotectedŸ9** sqlite3_value objects even when not strictly required.¢**ŸD** ^The sqlite3_value objects that are passed as parameters into theŸG** implementation of [application-defined SQL functions] are protected.Ÿ(** ^The sqlite3_value object returned byŸ+** [sqlite3_column_value()] is unprotected.ŸB** Unprotected sqlite3_value objects may only be used as argumentsŸ;** to [sqlite3_result_value()], [sqlite3_bind_value()], andπ** [sqlite3_value_dup()].Ÿ<** The [sqlite3_value_blob | sqlite3_value_type()] family ofŸ6** interfaces require protected sqlite3_value objects.¢*/Ÿ+typedef struct sqlite3_value sqlite3_value;†¢/*Ÿ(** CAPI3REF: SQL Function Context Object¢**Ÿ@** The context in which an SQL function executes is stored in anŸC** sqlite3_context object.  ^A pointer to an sqlite3_context objectŸD** is always first parameter to [application-defined SQL functions].ŸE** The application-defined SQL function implementation will pass thisŸI** pointer through into calls to [sqlite3_result_int | sqlite3_result()],Ÿ8** [sqlite3_aggregate_context()], [sqlite3_user_data()],Ÿ:** [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],Ÿ"** and/or [sqlite3_set_auxdata()].¢*/Ÿ/typedef struct sqlite3_context sqlite3_context;†¢/*Ÿ2** CAPI3REF: Binding Values To Prepared StatementsŸE** KEYWORDS: {host parameter} {host parameters} {host parameter name}ŸA** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}∑** METHOD: sqlite3_stmt¢**ŸP** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,ŸJ** literals may be replaced by a [parameter] that matches one of following≠** templates:¢**ß** <ul>™** <li>  ?≠** <li>  ?NNN≠** <li>  :VVV≠** <li>  @VVV≠** <li>  $VVV®** </ul>¢**Ÿ=** In the templates above, NNN represents an integer literal,ŸI** and VVV represents an alphanumeric identifier.)^  ^The values of theseŸF** parameters (also called "host parameter names" or "SQL parameters")Ÿ?** can be set using the sqlite3_bind_*() routines defined here.¢**ŸA** ^The first argument to the sqlite3_bind_*() routines is alwaysŸ7** a pointer to the [sqlite3_stmt] object returned fromŸ*** [sqlite3_prepare_v2()] or its variants.¢**ŸD** ^The second argument is the index of the SQL parameter to be set.ŸG** ^The leftmost SQL parameter has an index of 1.  ^When the same namedŸ>** SQL parameter is used more than once, second and subsequentŸ;** occurrences have the same index as the first occurrence.Ÿ=** ^The index for named parameters can be looked up using theŸ?** [sqlite3_bind_parameter_index()] API if desired.  ^The indexŸ-** for "?NNN" parameters is the value of NNN.Ÿ=** ^The NNN value must be between 1 and the [sqlite3_limit()]ŸA** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 999).¢**Ÿ=** ^The third argument is the value to bind to the parameter.ŸJ** ^If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16()ŸE** or sqlite3_bind_blob() is a NULL pointer then the fourth parameterŸD** is ignored and the end result is the same as sqlite3_bind_null().¢**ŸD** ^(In those routines that have a fourth argument, its value is theŸC** number of bytes in the parameter.  To be clear: the value is theŸG** number of <u>bytes</u> in the value, not the number of characters.)^ŸK** ^If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16()Ÿ0** is negative, then the length of the string isŸ7** the number of bytes up to the first zero terminator.ŸC** If the fourth parameter to sqlite3_bind_blob() is negative, thenΩ** the behavior is undefined.ŸH** If a non-negative fourth parameter is provided to sqlite3_bind_text()Ÿ9** or sqlite3_bind_text16() or sqlite3_bind_text64() thenŸ)** that parameter must be the byte offsetŸD** where the NUL terminator would occur assuming the string were NULŸF** terminated.  If any NUL characters occur at byte offsets less than ŸI** the value of the fourth parameter then the resulting string value willŸF** contain embedded NULs.  The result of expressions involving stringsŸ#** with embedded NULs is undefined.¢**Ÿ@** ^The fifth argument to the BLOB and string binding interfacesŸ1** is a destructor used to dispose of the BLOB orŸG** string after SQLite has finished with it.  ^The destructor is calledŸG** to dispose of the BLOB or string even if the call to bind API fails.º** ^If the fifth argument isŸB** the special value [SQLITE_STATIC], then SQLite assumes that theŸK** information is in static, unmanaged space and does not need to be freed.Ÿ@** ^If the fifth argument has the value [SQLITE_TRANSIENT], thenŸD** SQLite makes its own private copy of the data immediately, beforeŸ(** the sqlite3_bind_*() routine returns.¢**Ÿ>** ^The sixth argument to sqlite3_bind_text64() must be one ofŸG** [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE]ŸB** to specify the encoding of the text in the third parameter.  IfŸ@** the sixth argument to sqlite3_bind_text64() is not one of theŸC** allowed values shown above, or if the text encoding is differentŸH** from the encoding specified by the sixth parameter, then the behavior∞** is undefined.¢**ŸE** ^The sqlite3_bind_zeroblob() routine binds a BLOB of length N thatŸD** is filled with zeroes.  ^A zeroblob uses a fixed amount of memoryŸB** (just an integer to hold its size) while it is being processed.ŸB** Zeroblobs are intended to serve as placeholders for BLOBs whoseŸ!** content is later written usingŸ7** [sqlite3_blob_open | incremental BLOB I/O] routines.ŸD** ^A negative value for the zeroblob results in a zero-length BLOB.¢**ŸL** ^The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter inŸF** [prepared statement] S to have an SQL value of NULL, but to also beŸK** associated with the pointer P of type T.  ^D is either a NULL pointer orŸD** a pointer to a destructor function for P. ^SQLite will invoke theŸE** destructor D with a single argument of P when it is finished usingŸE** P.  The T parameter should be a static string, preferably a stringŸ=** literal. The sqlite3_bind_pointer() routine is part of theŸ7** [pointer passing interface] added for SQLite 3.20.0.¢**ŸJ** ^If any of the sqlite3_bind_*() routines are called with a NULL pointerŸF** for the [prepared statement] or with a prepared statement for whichŸI** [sqlite3_step()] has been called more recently than [sqlite3_reset()],ŸE** then the call will return [SQLITE_MISUSE].  If any sqlite3_bind_()ŸH** routine is passed a [prepared statement] that has been finalized, theŸ,** result is undefined and probably harmful.¢**Ÿ>** ^Bindings are not cleared by the [sqlite3_reset()] routine.Ÿ/** ^Unbound parameters are interpreted as NULL.¢**ŸC** ^The sqlite3_bind_* routines return [SQLITE_OK] on success or anŸ'** [error code] if anything goes wrong.ŸE** ^[SQLITE_TOOBIG] might be returned if the size of a string or BLOBŸF** exceeds limits imposed by [sqlite3_limit]([SQLITE_LIMIT_LENGTH]) or∑** [SQLITE_MAX_LENGTH].Ÿ/** ^[SQLITE_RANGE] is returned if the parameterŸI** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.¢**Ÿ.** See also: [sqlite3_bind_parameter_count()],ŸI** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].¢*/ŸYSQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));ŸSSQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,Ÿ(                        void(*)(void*));Ÿ?SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);Ÿ9SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);ŸESQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);Ÿ5SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);ŸSSQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));ŸYSQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));ŸSSQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,ŸA                         void(*)(void*), unsigned char encoding);ŸLSQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);Ÿ[SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));Ÿ@SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);ŸKSQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);†¢/*Ÿ%** CAPI3REF: Number Of SQL Parameters∑** METHOD: sqlite3_stmt¢**ŸC** ^This routine can be used to find the number of [SQL parameters]Ÿ?** in a [prepared statement].  SQL parameters are tokens of theŸ<** form "?", "?NNN", ":AAA", "$AAA", or "@AAA" that serve asŸ?** placeholders for values that are [sqlite3_bind_blob | bound]Ÿ%** to the parameters at a later time.¢**ŸG** ^(This routine actually returns the index of the largest (rightmost)ŸD** parameter. For all forms except ?NNN, this will correspond to theŸI** number of unique parameters.  If parameters of the ?NNN form are used,Ÿ#** there may be gaps in the list.)^¢**Ÿ0** See also: [sqlite3_bind_blob|sqlite3_bind()],Ÿ'** [sqlite3_bind_parameter_name()], andŸ$** [sqlite3_bind_parameter_index()].¢*/Ÿ;SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);†¢/*Ÿ%** CAPI3REF: Name Of A Host Parameter∑** METHOD: sqlite3_stmt¢**Ÿ:** ^The sqlite3_bind_parameter_name(P,N) interface returnsŸF** the name of the N-th [SQL parameter] in the [prepared statement] P.ŸD** ^(SQL parameters of the form "?NNN" or ":AAA" or "@AAA" or "$AAA"ŸG** have a name which is the string "?NNN" or ":AAA" or "@AAA" or "$AAA"∞** respectively.Ÿ7** In other words, the initial ":" or "$" or "@" or "?"Ÿ%** is included as part of the name.)^ŸG** ^Parameters of the form "?" without a following integer have no nameŸ?** and are referred to as "nameless" or "anonymous parameters".¢**Ÿ6** ^The first host parameter has an index of 1, not 0.¢**Ÿ>** ^If the value N is out of range or if the N-th parameter isŸ<** nameless, then NULL is returned.  ^The returned string isŸ;** always in UTF-8 encoding even if the named parameter wasŸ;** originally specified as UTF-16 in [sqlite3_prepare16()],Ÿ9** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].¢**Ÿ0** See also: [sqlite3_bind_blob|sqlite3_bind()],Ÿ(** [sqlite3_bind_parameter_count()], andŸ$** [sqlite3_bind_parameter_index()].¢*/ŸGSQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);†¢/*Ÿ3** CAPI3REF: Index Of A Parameter With A Given Name∑** METHOD: sqlite3_stmt¢**Ÿ>** ^Return the index of an SQL parameter given its name.  ^TheŸ9** index value returned is suitable for use as the secondŸ<** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zeroŸA** is returned if no matching parameter is found.  ^The parameterŸ=** name must be given in UTF-8 even if the original statementŸB** was prepared from UTF-16 text using [sqlite3_prepare16_v2()] orº** [sqlite3_prepare16_v3()].¢**Ÿ0** See also: [sqlite3_bind_blob|sqlite3_bind()],Ÿ(** [sqlite3_bind_parameter_count()], andŸ#** [sqlite3_bind_parameter_name()].¢*/ŸNSQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);†¢/*Ÿ7** CAPI3REF: Reset All Bindings On A Prepared Statement∑** METHOD: sqlite3_stmt¢**ŸG** ^Contrary to the intuition of many, [sqlite3_reset()] does not resetŸ@** the [sqlite3_bind_blob | bindings] on a [prepared statement].Ÿ:** ^Use this routine to reset all host parameters to NULL.¢*/Ÿ5SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);†¢/*Ÿ.** CAPI3REF: Number Of Columns In A Result Set∑** METHOD: sqlite3_stmt¢**ŸB** ^Return the number of columns in the result set returned by theŸD** [prepared statement]. ^If this routine returns 0, that means the ŸB** [prepared statement] returns no data (for example an [UPDATE]).ŸI** ^However, just because this routine returns a positive number does notŸL** mean that one or more rows of data will be returned.  ^A SELECT statementŸJ** will always have a positive sqlite3_column_count() but depending on theŸK** WHERE clause constraints and the table content, it might return no rows.¢**Ÿ#** See also: [sqlite3_data_count()]¢*/Ÿ9SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);†¢/*Ÿ)** CAPI3REF: Column Names In A Result Set∑** METHOD: sqlite3_stmt¢**ŸB** ^These routines return the name assigned to a particular columnŸI** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()Ÿ@** interface returns a pointer to a zero-terminated UTF-8 stringŸE** and sqlite3_column_name16() returns a pointer to a zero-terminatedŸC** UTF-16 string.  ^The first parameter is the [prepared statement]ŸG** that implements the [SELECT] statement. ^The second parameter is theŸ4** column number.  ^The leftmost column is number 0.¢**ŸN** ^The returned string pointer is valid until either the [prepared statement]ŸO** is destroyed by [sqlite3_finalize()] or until the statement is automaticallyŸH** reprepared by the first call to [sqlite3_step()] for a particular runº** or until the next call toŸG** sqlite3_column_name() or sqlite3_column_name16() on the same column.¢**ŸE** ^If sqlite3_malloc() fails during the processing of either routineŸ@** (for example during a conversion from UTF-8 to UTF-16) then aº** NULL pointer is returned.¢**ŸC** ^The name of a result column is the value of the "AS" clause forŸC** that column, if there is an AS clause.  If there is no AS clauseŸA** then the name of the column is unspecified and may change fromŸ%** one release of SQLite to the next.¢*/ŸASQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);ŸCSQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);†¢/*Ÿ-** CAPI3REF: Source Of Data In A Query Result∑** METHOD: sqlite3_stmt¢**ŸH** ^These routines provide a means to determine the database, table, andŸC** table column that is the origin of a particular result column in∂** [SELECT] statement.ŸB** ^The name of the database or table or column can be returned asŸD** either a UTF-8 or UTF-16 string.  ^The _database_ routines returnŸE** the database name, the _table_ routines return the table name, andŸ/** the origin_ routines return the column name.ŸL** ^The returned string is valid until the [prepared statement] is destroyedŸE** using [sqlite3_finalize()] or until the statement is automaticallyŸH** reprepared by the first call to [sqlite3_step()] for a particular runŸ-** or until the same information is requestedŸ!** again in a different encoding.¢**Ÿ?** ^The names returned are the original un-aliased names of theø** database, table, and column.¢**ŸE** ^The first argument to these interfaces is a [prepared statement].ŸN** ^These functions return information about the Nth result column returned byŸ:** the statement, where N is the second function argument.Ÿ8** ^The left-most column is column 0 for these routines.¢**ŸC** ^If the Nth column returned by the statement is an expression orŸI** subquery and is not a column value, then all of these functions returnŸL** NULL.  ^These routine might also return NULL if a memory allocation errorŸM** occurs.  ^Otherwise, they return the name of the attached database, table,Ÿ9** or column that query result column was extracted from.¢**ŸI** ^As with all other SQLite APIs, those whose names end with "16" returnŸ?** UTF-16 encoded strings and the other functions return UTF-8.¢**ŸF** ^These APIs are only available if the library was compiled with theŸ9** [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol.¢**ŸM** If two or more threads call one or more of these routines against the sameŸF** prepared statement and column at the same time then the results are≠** undefined.¢**Ÿ*** If two or more threads call one or moreŸ>** [sqlite3_column_database_name | column metadata interfaces]Ÿ6** for the same [prepared statement] and result columnŸ3** at the same time then the results are undefined.¢*/ŸGSQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);ŸISQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);ŸDSQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);ŸFSQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);ŸESQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);ŸGSQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);†¢/*Ÿ0** CAPI3REF: Declared Datatype Of A Query Result∑** METHOD: sqlite3_stmt¢**Ÿ3** ^(The first parameter is a [prepared statement].ŸF** If this statement is a [SELECT] statement and the Nth column of theŸA** returned result set of that [SELECT] is a table column (not anŸ>** expression or subquery) then the declared type of the tableŸD** column is returned.)^  ^If the Nth column of the result set is anŸ;** expression or subquery, then a NULL pointer is returned.Ÿ0** ^The returned string is always UTF-8 encoded.¢**Ÿ,** ^(For example, given the database schema:¢**ø** CREATE TABLE t1(c1 VARIANT);¢**Ÿ.** and the following statement to be compiled:¢**Ω** SELECT c1 + 1, c1 FROM t1;¢**ŸG** this routine would return the string "VARIANT" for the second resultŸJ** column (i==1), and a NULL pointer for the first result column (i==0).)^¢**ŸC** ^SQLite uses dynamic run-time typing.  ^So just because a columnŸB** is declared to contain a particular type does not mean that theŸA** data stored in that column is of the declared type.  SQLite isŸ?** strongly typed, but the typing is dynamic not static.  ^TypeŸ@** is associated with individual values, not with the containersΩ** used to hold those values.¢*/ŸBSQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);ŸDSQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);†¢/*Ÿ&** CAPI3REF: Evaluate An SQL Statement∑** METHOD: sqlite3_stmt¢**Ÿ>** After a [prepared statement] has been prepared using any ofŸL** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],Ÿ3** or [sqlite3_prepare16_v3()] or one of the legacyŸI** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this functionŸ>** must be called one or more times to evaluate the statement.¢**ŸE** The details of the behavior of the sqlite3_step() interface dependŸH** on whether the statement was prepared using the newer "vX" interfacesŸL** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],Ÿ/** [sqlite3_prepare16_v2()] or the older legacyŸL** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of theŸH** new "vX" interface is recommended for new applications but the legacyŸ+** interface will continue to be supported.¢**ŸK** ^In the legacy interface, the return value will be either [SQLITE_BUSY],ŸC** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].Ÿ?** ^With the "v2" interface, any of the other [result codes] orŸ5** [extended result codes] might be returned as well.¢**ŸJ** ^[SQLITE_BUSY] means that the database engine was unable to acquire theŸJ** database locks it needs to do its job.  ^If the statement is a [COMMIT]ŸG** or occurs outside of an explicit transaction, then you can retry theŸF** statement.  If the statement is not a [COMMIT] and occurs within anŸG** explicit transaction then you should rollback the transaction beforeÆ** continuing.¢**ŸA** ^[SQLITE_DONE] means that the statement has finished executingŸK** successfully.  sqlite3_step() should not be called again on this virtualŸG** machine without first calling [sqlite3_reset()] to reset the virtualŸ%** machine back to its initial state.¢**ŸK** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]ŸI** is returned each time a new row of data is ready for processing by theŸJ** caller. The values may be accessed using the [column access functions].ŸC** sqlite3_step() is called again to retrieve the next row of data.¢**ŸD** ^[SQLITE_ERROR] means that a run-time error (such as a constraintŸI** violation) has occurred.  sqlite3_step() should not be called again onŸG** the VM. More information may be found by calling [sqlite3_errmsg()].ŸG** ^With the legacy interface, a more specific error code (for example,ŸG** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)Ÿ6** can be obtained by calling [sqlite3_reset()] on theŸ1** [prepared statement].  ^In the "v2" interface,ŸG** the more specific error code is returned directly by sqlite3_step().¢**ŸJ** [SQLITE_MISUSE] means that the this routine was called inappropriately.Ÿ;** Perhaps it was called on a [prepared statement] that hasŸA** already been [sqlite3_finalize | finalized] or on one that hadŸD** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it couldŸH** be the case that the same database connection is being used by two orŸ+** more threads at the same moment in time.¢**ŸE** For all versions of SQLite up to and including 3.6.23.1, a call toŸH** [sqlite3_reset()] was required after sqlite3_step() returned anythingŸ>** other than [SQLITE_ROW] before any subsequent invocation ofŸB** sqlite3_step().  Failure to reset the prepared statement using ŸC** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return fromŸD** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],∑** sqlite3_step() beganŸF** calling [sqlite3_reset()] automatically in this circumstance ratherŸJ** than returning [SQLITE_MISUSE].  This is not considered a compatibilityŸJ** break because any application that ever receives an SQLITE_MISUSE errorŸL** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time optionŸ.** can be used to restore the legacy behavior.¢**ŸL** <b>Goofy Interface Alert:</b> In the legacy interface, the sqlite3_step()ŸI** API always returns a generic error code, [SQLITE_ERROR], following anyŸE** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must callŸH** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of theŸ:** specific [error codes] that better describes the error.ŸD** We admit that this is a goofy design.  The problem has been fixedŸF** with the "v2" interface.  If you prepare all of your SQL statementsŸ9** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]ŸB** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] insteadŸJ** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,Ÿ=** then the more specific [error codes] are returned directlyŸE** by sqlite3_step().  The use of the "vX" interfaces is recommended.¢*/Ÿ+SQLITE_API int sqlite3_step(sqlite3_stmt*);†¢/*Ÿ.** CAPI3REF: Number of columns in a result set∑** METHOD: sqlite3_stmt¢**ŸL** ^The sqlite3_data_count(P) interface returns the number of columns in theŸ;** current row of the result set of [prepared statement] P.ŸA** ^If prepared statement P does not have results ready to returnŸA** (via calls to the [sqlite3_column_int | sqlite3_column_*()] ofŸ4** interfaces) then sqlite3_data_count(P) returns 0.ŸL** ^The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer.ŸG** ^The sqlite3_data_count(P) routine returns 0 if the previous call toŸH** [sqlite3_step](P) returned [SQLITE_DONE].  ^The sqlite3_data_count(P)ŸF** will return non-zero if previous call to [sqlite3_step](P) returnedŸF** [SQLITE_ROW], except in the case of the [PRAGMA incremental_vacuum]ŸB** where it always returns zero since each step of that multi-stepŸ$** pragma returns 0 columns of data.¢**Ÿ%** See also: [sqlite3_column_count()]¢*/Ÿ7SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);†¢/*Ÿ"** CAPI3REF: Fundamental Datatypes∏** KEYWORDS: SQLITE_TEXT¢**ŸA** ^(Every value in SQLite has one of five fundamental datatypes:¢**ß** <ul>Ω** <li> 64-bit signed integerŸ)** <li> 64-bit IEEE floating point numberÆ** <li> string¨** <li> BLOB¨** <li> NULL™** </ul>)^¢**Ÿ5** These constants are codes for each of those types.¢**ŸG** Note that the SQLITE_TEXT constant was also used in SQLite version 2ŸH** for a completely different meaning.  Software that links against bothŸE** SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, notØ** SQLITE_TEXT.¢*/π#define SQLITE_INTEGER  1π#define SQLITE_FLOAT    2π#define SQLITE_BLOB     4π#define SQLITE_NULL     5≤#ifdef SQLITE_TEXT≥# undef SQLITE_TEXT•#else∫# define SQLITE_TEXT     3¶#endif∫#define SQLITE3_TEXT     3†¢/*Ÿ'** CAPI3REF: Result Values From A QueryŸ&** KEYWORDS: {column access functions}∑** METHOD: sqlite3_stmt¢**≤** <b>Summary:</b>Ÿ;** <blockquote><table border=0 cellpadding=0 cellspacing=0>Ÿ>** <tr><td><b>sqlite3_column_blob</b><td>&rarr;<td>BLOB resultŸ@** <tr><td><b>sqlite3_column_double</b><td>&rarr;<td>REAL resultŸG** <tr><td><b>sqlite3_column_int</b><td>&rarr;<td>32-bit INTEGER resultŸI** <tr><td><b>sqlite3_column_int64</b><td>&rarr;<td>64-bit INTEGER resultŸD** <tr><td><b>sqlite3_column_text</b><td>&rarr;<td>UTF-8 TEXT resultŸG** <tr><td><b>sqlite3_column_text16</b><td>&rarr;<td>UTF-16 TEXT resultŸE** <tr><td><b>sqlite3_column_value</b><td>&rarr;<td>The result as an Ÿ4** [sqlite3_value|unprotected sqlite3_value] object.Ÿ%** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;ŸB** <tr><td><b>sqlite3_column_bytes</b><td>&rarr;<td>Size of a BLOBŸ"** or a UTF-8 TEXT result in bytesŸ4** <tr><td><b>sqlite3_column_bytes16&nbsp;&nbsp;</b>Ÿ+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16∞** TEXT in bytesŸ:** <tr><td><b>sqlite3_column_type</b><td>&rarr;<td>Defaultπ** datatype of the result∏** </table></blockquote>¢**≤** <b>Details:</b>¢**ŸJ** ^These routines return information about a single column of the currentŸI** result row of a query.  ^In every case the first argument is a pointerŸK** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]ŸH** that was returned from [sqlite3_prepare_v2()] or one of its variants)ŸK** and the second argument is the index of the column for which informationŸN** should be returned. ^The leftmost column of the result set has the index 0.Ÿ?** ^The number of columns in the result can be determined usingº** [sqlite3_column_count()].¢**ŸJ** If the SQL statement does not currently point to a valid row, or if theŸ9** column index is out of range, the result is undefined.ŸA** These routines may only be called when the most recent call toŸ9** [sqlite3_step()] has returned [SQLITE_ROW] and neitherŸL** [sqlite3_reset()] nor [sqlite3_finalize()] have been called subsequently.ŸA** If any of these routines are called after [sqlite3_reset()] orŸ>** [sqlite3_finalize()] or after [sqlite3_step()] has returnedŸ@** something other than [SQLITE_ROW], the results are undefined.ŸC** If [sqlite3_step()] or [sqlite3_reset()] or [sqlite3_finalize()]ŸA** are called from a different thread while any of these routinesŸ/** are pending, then the results are undefined.¢**ŸN** The first six interfaces (_blob, _double, _int, _int64, _text, and _text16)ŸJ** each return the value of a result column in a specific data format.  IfŸK** the result column is not initially in the requested format (for example,ŸJ** if the query returns an integer but the sqlite3_column_text() interfaceŸP** is used to extract the value) then an automatic type conversion is performed.¢**Ÿ1** ^The sqlite3_column_type() routine returns theŸ=** [SQLITE_INTEGER | datatype code] for the initial data typeŸI** of the result column.  ^The returned value is one of [SQLITE_INTEGER],ŸB** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].ŸH** The return value of sqlite3_column_type() can be used to decide whichŸI** of the first six interface should be used to extract the column value.ŸG** The value returned by sqlite3_column_type() is only meaningful if noŸH** automatic type conversions have occurred for the value in question.  ŸG** After a type conversion, the result of calling sqlite3_column_type()Ÿ)** is undefined, though harmless.  FutureŸF** versions of SQLite may change the behavior of sqlite3_column_type()ø** following a type conversion.¢**ŸL** If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes()ŸK** or sqlite3_column_bytes16() interfaces can be used to determine the size∫** of that BLOB or string.¢**ŸK** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()Ÿ>** routine returns the number of bytes in that BLOB or string.ŸJ** ^If the result is a UTF-16 string, then sqlite3_column_bytes() convertsŸ<** the string to UTF-8 and then returns the number of bytes.ŸE** ^If the result is a numeric value then sqlite3_column_bytes() usesŸK** [sqlite3_snprintf()] to convert that value to a UTF-8 string and returnsŸ&** the number of bytes in that string.ŸD** ^If the result is NULL, then sqlite3_column_bytes() returns zero.¢**ŸN** ^If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16()Ÿ>** routine returns the number of bytes in that BLOB or string.ŸK** ^If the result is a UTF-8 string, then sqlite3_column_bytes16() convertsŸ=** the string to UTF-16 and then returns the number of bytes.ŸG** ^If the result is a numeric value then sqlite3_column_bytes16() usesŸL** [sqlite3_snprintf()] to convert that value to a UTF-16 string and returnsŸ&** the number of bytes in that string.ŸF** ^If the result is NULL, then sqlite3_column_bytes16() returns zero.¢**Ÿ8** ^The values returned by [sqlite3_column_bytes()] and ŸL** [sqlite3_column_bytes16()] do not include the zero terminators at the endŸ7** of the string.  ^For clarity: the values returned byŸL** [sqlite3_column_bytes()] and [sqlite3_column_bytes16()] are the number ofŸ5** bytes in the string, not the number of characters.¢**ŸJ** ^Strings returned by sqlite3_column_text() and sqlite3_column_text16(),Ÿ?** even empty strings, are always zero-terminated.  ^The returnŸM** value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.¢**ŸI** <b>Warning:</b> ^The object returned by [sqlite3_column_value()] is anŸG** [unprotected sqlite3_value] object.  In a multithreaded environment,ŸC** an unprotected sqlite3_value object may only be used safely withŸ7** [sqlite3_bind_value()] and [sqlite3_result_value()].Ÿ8** If the [unprotected sqlite3_value] object returned byŸE** [sqlite3_column_value()] is used in any other way, including callsŸB** to routines like [sqlite3_value_int()], [sqlite3_value_text()],Ÿ>** or [sqlite3_value_bytes()], the behavior is not threadsafe.Ÿ.** Hence, the sqlite3_column_value() interfaceŸ8** is normally only useful within the implementation of ŸF** [application-defined SQL functions] or [virtual tables], not withinæ** top-level application code.¢**ŸH** The these routines may attempt to convert the datatype of the result.ŸJ** ^For example, if the internal representation is FLOAT and a text resultŸG** is requested, [sqlite3_snprintf()] is used internally to perform theŸK** conversion automatically.  ^(The following table details the conversions¥** that are applied:¢**Ø** <blockquote>µ** <table border="1">ŸD** <tr><th> Internal<br>Type <th> Requested<br>Type <th>  Conversion¢**Ÿ4** <tr><td>  NULL    <td> INTEGER   <td> Result is 0Ÿ6** <tr><td>  NULL    <td>  FLOAT    <td> Result is 0.0ŸA** <tr><td>  NULL    <td>   TEXT    <td> Result is a NULL pointerŸA** <tr><td>  NULL    <td>   BLOB    <td> Result is a NULL pointerŸF** <tr><td> INTEGER  <td>  FLOAT    <td> Convert from integer to floatŸG** <tr><td> INTEGER  <td>   TEXT    <td> ASCII rendering of the integerŸ>** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXTŸ:** <tr><td>  FLOAT   <td> INTEGER   <td> [CAST] to INTEGERŸE** <tr><td>  FLOAT   <td>   TEXT    <td> ASCII rendering of the floatŸ7** <tr><td>  FLOAT   <td>   BLOB    <td> [CAST] to BLOBŸ:** <tr><td>  TEXT    <td> INTEGER   <td> [CAST] to INTEGERŸ7** <tr><td>  TEXT    <td>  FLOAT    <td> [CAST] to REALŸ2** <tr><td>  TEXT    <td>   BLOB    <td> No changeŸ:** <tr><td>  BLOB    <td> INTEGER   <td> [CAST] to INTEGERŸ7** <tr><td>  BLOB    <td>  FLOAT    <td> [CAST] to REALŸH** <tr><td>  BLOB    <td>   TEXT    <td> Add a zero terminator if needed´** </table>≤** </blockquote>)^¢**ŸD** Note that when type conversions occur, pointers returned by priorŸ@** calls to sqlite3_column_blob(), sqlite3_column_text(), and/orŸ.** sqlite3_column_text16() may be invalidated.Ÿ9** Type conversions and pointer invalidations might occur∫** in the following cases:¢**ß** <ul>ŸB** <li> The initial content is a BLOB and sqlite3_column_text() orŸC**      sqlite3_column_text16() is called.  A zero-terminator mightŸ,**      need to be added to the string.</li>ŸI** <li> The initial content is UTF-8 text and sqlite3_column_bytes16() orŸI**      sqlite3_column_text16() is called.  The content must be converted∑**      to UTF-16.</li>ŸH** <li> The initial content is UTF-16 text and sqlite3_column_bytes() orŸG**      sqlite3_column_text() is called.  The content must be converted∂**      to UTF-8.</li>®** </ul>¢**ŸM** ^Conversions between UTF-16be and UTF-16le are always done in place and doŸM** not invalidate a prior pointer, though of course the content of the bufferŸJ** that the prior pointer references will have been modified.  Other kindsŸJ** of conversion are done in place when it is possible, but sometimes theyŸF** are not possible and in those cases prior pointers are invalidated.¢**Ÿ0** The safest policy is to invoke these routinesŸ ** in one of the following ways:¢**ß** <ul>ŸE**  <li>sqlite3_column_text() followed by sqlite3_column_bytes()</li>ŸE**  <li>sqlite3_column_blob() followed by sqlite3_column_bytes()</li>ŸI**  <li>sqlite3_column_text16() followed by sqlite3_column_bytes16()</li>®** </ul>¢**Ÿ9** In other words, you should call sqlite3_column_text(),ŸN** sqlite3_column_blob(), or sqlite3_column_text16() first to force the resultŸA** into the desired format, then invoke sqlite3_column_bytes() orŸM** sqlite3_column_bytes16() to find the size of the result.  Do not mix callsŸB** to sqlite3_column_text() or sqlite3_column_blob() with calls toŸL** sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16()Ÿ(** with calls to sqlite3_column_bytes().¢**ŸE** ^The pointers returned are valid until a type conversion occurs asŸE** described above, or until [sqlite3_step()] or [sqlite3_reset()] orŸJ** [sqlite3_finalize()] is called.  ^The memory space used to hold stringsŸG** and BLOBs is freed automatically.  Do not pass the pointers returnedŸC** from [sqlite3_column_blob()], [sqlite3_column_text()], etc. into¥** [sqlite3_free()].¢**ŸE** ^(If a memory allocation error occurs during the evaluation of anyŸE** of these routines, a default value is returned.  The default valueŸD** is either the integer 0, the floating point number 0.0, or a NULLŸ@** pointer.  Subsequent calls to [sqlite3_errcode()] will return¥** [SQLITE_NOMEM].)^¢*/ŸDSQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);ŸASQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);Ÿ;SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);ŸGSQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);ŸMSQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);ŸFSQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);ŸHSQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);Ÿ=SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);Ÿ?SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);Ÿ<SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);†¢/*Ÿ0** CAPI3REF: Destroy A Prepared Statement Objectª** DESTRUCTOR: sqlite3_stmt¢**ŸO** ^The sqlite3_finalize() function is called to delete a [prepared statement].ŸH** ^If the most recent evaluation of the statement encountered no errorsŸO** or if the statement is never been evaluated, then sqlite3_finalize() returnsŸI** SQLITE_OK.  ^If the most recent evaluation of statement S failed, thenŸ>** sqlite3_finalize(S) returns the appropriate [error code] orπ** [extended error code].¢**ŸE** ^The sqlite3_finalize(S) routine can be called at any point duringŸ,** the life cycle of [prepared statement] S:Ÿ.** before statement S is ever evaluated, afterŸ<** one or more calls to [sqlite3_reset()], or after any callŸE** to [sqlite3_step()] regardless of whether or not the statement has∑** completed execution.¢**ŸF** ^Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.¢**ŸM** The application must finalize every [prepared statement] in order to avoidŸL** resource leaks.  It is a grievous error for the application to try to useŸK** a prepared statement after it has been finalized.  Any use of a preparedŸD** statement after it has been finalized can result in undefined andŸ>** undesirable behavior such as segfaults and heap corruption.¢*/Ÿ5SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);†¢/*Ÿ.** CAPI3REF: Reset A Prepared Statement Object∑** METHOD: sqlite3_stmt¢**ŸI** The sqlite3_reset() function is called to reset a [prepared statement]Ÿ=** object back to its initial state, ready to be re-executed.ŸC** ^Any SQL statement variables that had values bound to them usingŸF** the [sqlite3_bind_blob | sqlite3_bind_*() API] retain their values.Ÿ8** Use [sqlite3_clear_bindings()] to reset the bindings.¢**ŸF** ^The [sqlite3_reset(S)] interface resets the [prepared statement] SŸ(** back to the beginning of its program.¢**Ÿ8** ^If the most recent call to [sqlite3_step(S)] for theŸA** [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],Ÿ=** or if [sqlite3_step(S)] has never before been called on S,Ÿ/** then [sqlite3_reset(S)] returns [SQLITE_OK].¢**Ÿ8** ^If the most recent call to [sqlite3_step(S)] for theŸ2** [prepared statement] S indicated an error, thenŸ:** [sqlite3_reset(S)] returns an appropriate [error code].¢**Ÿ?** ^The [sqlite3_reset(S)] interface does not change the valuesŸE** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.¢*/Ÿ2SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);†¢/*Ÿ-** CAPI3REF: Create Or Redefine SQL FunctionsŸ)** KEYWORDS: {function creation routines}Ÿ/** KEYWORDS: {application-defined SQL function}Ÿ0** KEYWORDS: {application-defined SQL functions}≤** METHOD: sqlite3¢**ŸH** ^These functions (collectively known as "function creation routines")ŸJ** are used to add SQL functions or aggregates or to redefine the behaviorŸI** of existing SQL functions or aggregates.  The only differences betweenŸ4** these routines are the text encoding expected forŸ@** the second parameter (the name of the function being created)Ÿ;** and the presence or absence of a destructor callback forŸ ** the application data pointer.¢**ŸE** ^The first parameter is the [database connection] to which the SQLŸK** function is to be added.  ^If an application uses more than one databaseŸB** connection then application-defined SQL functions must be addedŸ*** to each database connection separately.¢**ŸI** ^The second parameter is the name of the SQL function to be created orŸI** redefined.  ^The length of the name is limited to 255 bytes in a UTF-8ŸI** representation, exclusive of the zero-terminator.  ^Note that the nameŸE** length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.  Ÿ7** ^Any attempt to create a function with a longer nameŸ1** will result in [SQLITE_MISUSE] being returned.¢**æ** ^The third parameter (nArg)Ÿ6** is the number of arguments that the SQL function orŸF** aggregate takes. ^If this parameter is -1, then the SQL function orŸE** aggregate may take any number of arguments between 0 and the limitŸE** set by [sqlite3_limit]([SQLITE_LIMIT_FUNCTION_ARG]).  If the thirdŸE** parameter is less than -1 or greater than 127 then the behavior is≠** undefined.¢**Ÿ2** ^The fourth parameter, eTextRep, specifies whatŸ>** [SQLITE_UTF8 | text encoding] this SQL function prefers forŸ@** its parameters.  The application should set this parameter toŸ;** [SQLITE_UTF16LE] if the function implementation invokes ŸE** [sqlite3_value_text16le()] on an input, or [SQLITE_UTF16BE] if theŸD** implementation invokes [sqlite3_value_text16be()] on an input, orŸG** [SQLITE_UTF16] if [sqlite3_value_text16()] is used, or [SQLITE_UTF8]ŸL** otherwise.  ^The same SQL function may be registered multiple times usingŸI** different preferred text encodings, with different implementations for±** each encoding.ŸL** ^When multiple implementations of the same function are available, SQLiteŸG** will pick the one that involves the least amount of data conversion.¢**ŸK** ^The fourth parameter may optionally be ORed with [SQLITE_DETERMINISTIC]ŸG** to signal that the function will always return the same result givenŸI** the same inputs within a single SQL statement.  Most SQL functions areŸJ** deterministic.  The built-in [random()] SQL function is an example of aŸK** function that is not deterministic.  The SQLite query planner is able toŸF** perform additional optimizations on deterministic functions, so useŸD** of the [SQLITE_DETERMINISTIC] flag is recommended where possible.¢**ŸL** ^(The fifth parameter is an arbitrary pointer.  The implementation of theŸJ** function can gain access to this pointer using [sqlite3_user_data()].)^¢**ŸJ** ^The sixth, seventh and eighth parameters, xFunc, xStep and xFinal, areŸF** pointers to C-language functions that implement the SQL function orŸL** aggregate. ^A scalar SQL function requires an implementation of the xFuncŸF** callback only; NULL pointers must be passed as the xStep and xFinalŸM** parameters. ^An aggregate SQL function requires an implementation of xStepŸO** and xFinal and NULL pointer must be passed for xFunc. ^To delete an existingŸG** SQL function or aggregate, pass NULL pointers for all three function≠** callbacks.¢**ŸH** ^(If the ninth parameter to sqlite3_create_function_v2() is not NULL,Ÿ;** then it is destructor for the application data pointer. ŸJ** The destructor is invoked when the function is deleted, either by beingŸ7** overloaded or when the database connection closes.)^Ÿ1** ^The destructor is also invoked if the call toŸ&** sqlite3_create_function_v2() fails.ŸF** ^When the destructor callback of the tenth parameter is invoked, itŸG** is passed a single argument which is a copy of the application data ŸI** pointer which was the fifth parameter to sqlite3_create_function_v2().¢**ŸD** ^It is permitted to register multiple implementations of the sameŸD** functions with the same name but with either differing numbers ofŸE** arguments or differing preferred text encodings.  ^SQLite will useŸD** the implementation that most closely matches the way in which theŸH** SQL function is used.  ^A function implementation with a non-negativeŸG** nArg parameter is a better match than a function implementation withŸB** a negative nArg.  ^A function where the preferred text encodingŸ,** matches the database encoding is a betterŸ;** match than a function where the encoding is different.  ŸK** ^A function where the encoding difference is between UTF16le and UTF16beŸE** is a closer match than a function where the encoding difference is∫** between UTF8 and UTF16.¢**ŸN** ^Built-in functions may be overloaded by new application-defined functions.¢**Ÿ>** ^An application-defined function is permitted to call otherŸ3** SQLite interfaces.  However, such calls must notŸC** close the database connection nor finalize or reset the preparedŸ.** statement in which the function is running.¢*/Ÿ'SQLITE_API int sqlite3_create_function(Æ  sqlite3 *db,º  const char *zFunctionName,´  int nArg,Ø  int eTextRep,≠  void *pApp,Ÿ6  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),Ÿ6  void (*xStep)(sqlite3_context*,int,sqlite3_value**),Ÿ"  void (*xFinal)(sqlite3_context*)¢);Ÿ)SQLITE_API int sqlite3_create_function16(Æ  sqlite3 *db,º  const void *zFunctionName,´  int nArg,Ø  int eTextRep,≠  void *pApp,Ÿ6  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),Ÿ6  void (*xStep)(sqlite3_context*,int,sqlite3_value**),Ÿ"  void (*xFinal)(sqlite3_context*)¢);Ÿ*SQLITE_API int sqlite3_create_function_v2(Æ  sqlite3 *db,º  const char *zFunctionName,´  int nArg,Ø  int eTextRep,≠  void *pApp,Ÿ6  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),Ÿ6  void (*xStep)(sqlite3_context*,int,sqlite3_value**),Ÿ#  void (*xFinal)(sqlite3_context*),∏  void(*xDestroy)(void*)¢);†¢/*ª** CAPI3REF: Text Encodings¢**ŸA** These constant define integer codes that represent the variousŸ&** text encodings supported by SQLite.¢*/Ÿ;#define SQLITE_UTF8           1    /* IMP: R-37514-35566 */Ÿ;#define SQLITE_UTF16LE        2    /* IMP: R-03371-37637 */Ÿ;#define SQLITE_UTF16BE        3    /* IMP: R-51971-34154 */Ÿ>#define SQLITE_UTF16          4    /* Use native byte order */Ÿ3#define SQLITE_ANY            5    /* Deprecated */ŸF#define SQLITE_UTF16_ALIGNED  8    /* sqlite3_create_collation only */†¢/*ª** CAPI3REF: Function Flags¢**Ÿ1** These constants may be ORed together with the ŸA** [SQLITE_UTF8 | preferred text encoding] as the fourth argumentŸD** to [sqlite3_create_function()], [sqlite3_create_function16()], orŸ"** [sqlite3_create_function_v2()].¢*/Ÿ%#define SQLITE_DETERMINISTIC    0x800†¢/*Ÿ!** CAPI3REF: Deprecated Functions≠** DEPRECATED¢**Ÿ:** These functions are [deprecated].  In order to maintainŸE** backwards compatibility with older code, these functions continue Ÿ;** to be supported.  However, new applications should avoidŸA** the use of these functions.  To encourage programmers to avoidŸ5** these functions, we will not explain what they do.¢*/æ#ifndef SQLITE_OMIT_DEPRECATEDŸKSQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);Ÿ@SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);ŸYSQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);Ÿ>SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);Ÿ?SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);ŸWSQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),Ÿ+                      void*,sqlite3_int64);¶#endif†¢/*Ÿ!** CAPI3REF: Obtaining SQL Values∏** METHOD: sqlite3_value¢**≤** <b>Summary:</b>Ÿ;** <blockquote><table border=0 cellpadding=0 cellspacing=0>Ÿ<** <tr><td><b>sqlite3_value_blob</b><td>&rarr;<td>BLOB valueŸ>** <tr><td><b>sqlite3_value_double</b><td>&rarr;<td>REAL valueŸE** <tr><td><b>sqlite3_value_int</b><td>&rarr;<td>32-bit INTEGER valueŸG** <tr><td><b>sqlite3_value_int64</b><td>&rarr;<td>64-bit INTEGER valueŸB** <tr><td><b>sqlite3_value_pointer</b><td>&rarr;<td>Pointer valueŸB** <tr><td><b>sqlite3_value_text</b><td>&rarr;<td>UTF-8 TEXT valueŸH** <tr><td><b>sqlite3_value_text16</b><td>&rarr;<td>UTF-16 TEXT value in∑** the native byteorderŸI** <tr><td><b>sqlite3_value_text16be</b><td>&rarr;<td>UTF-16be TEXT valueŸI** <tr><td><b>sqlite3_value_text16le</b><td>&rarr;<td>UTF-16le TEXT valueŸ%** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;ŸA** <tr><td><b>sqlite3_value_bytes</b><td>&rarr;<td>Size of a BLOBª** or a UTF-8 TEXT in bytesŸ3** <tr><td><b>sqlite3_value_bytes16&nbsp;&nbsp;</b>Ÿ+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16∞** TEXT in bytesŸ9** <tr><td><b>sqlite3_value_type</b><td>&rarr;<td>Default∏** datatype of the valueŸ8** <tr><td><b>sqlite3_value_numeric_type&nbsp;&nbsp;</b>Ÿ?** <td>&rarr;&nbsp;&nbsp;<td>Best numeric datatype of the valueŸ4** <tr><td><b>sqlite3_value_nochange&nbsp;&nbsp;</b>ŸI** <td>&rarr;&nbsp;&nbsp;<td>True if the column is unchanged in an UPDATEª** against a virtual table.∏** </table></blockquote>¢**≤** <b>Details:</b>¢**ŸB** These routines extract type, size, and content information fromŸF** [protected sqlite3_value] objects.  Protected sqlite3_value objectsŸ@** are used to pass parameter information into implementation ofŸ<** [application-defined SQL functions] and [virtual tables].¢**ŸC** These routines work only with [protected sqlite3_value] objects.ŸF** Any attempt to use these routines on an [unprotected sqlite3_value]µ** is not threadsafe.¢**ŸM** ^These routines work just like the corresponding [column access functions]ŸL** except that these routines take a single [protected sqlite3_value] objectŸM** pointer instead of a [sqlite3_stmt*] pointer and an integer column number.¢**ŸA** ^The sqlite3_value_text16() interface extracts a UTF-16 stringŸ6** in the native byte-order of the host machine.  ^TheŸC** sqlite3_value_text16be() and sqlite3_value_text16le() interfacesŸG** extract UTF-16 strings as big-endian and little-endian respectively.¢**Ÿ0** ^If [sqlite3_value] object V was initialized ŸO** using [sqlite3_bind_pointer(S,I,P,X,D)] or [sqlite3_result_pointer(C,P,X,D)]ŸJ** and if X and Y are strings that compare equal according to strcmp(X,Y),ŸJ** then sqlite3_value_pointer(V,Y) will return the pointer P.  ^Otherwise,ŸI** sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() ŸN** routine is part of the [pointer passing interface] added for SQLite 3.20.0.¢**Ÿ4** ^(The sqlite3_value_type(V) interface returns theŸC** [SQLITE_INTEGER | datatype code] for the initial datatype of theŸK** [sqlite3_value] object V. The returned value is one of [SQLITE_INTEGER],ŸD** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].)^ŸJ** Other interfaces might change the datatype for an sqlite3_value object.Ÿ?** For example, if the datatype is initially SQLITE_INTEGER andŸC** sqlite3_value_text(V) is called to extract a text value for thatŸG** integer, then subsequent calls to sqlite3_value_type(V) might returnŸI** SQLITE_TEXT.  Whether or not a persistent internal datatype conversionŸM** occurs is undefined and may change from one release of SQLite to the next.¢**ŸA** ^(The sqlite3_value_numeric_type() interface attempts to applyŸ@** numeric affinity to the value.  This means that an attempt isŸA** made to convert the value to an integer or floating point.  IfŸF** such a conversion is possible without loss of information (in otherŸ<** words, if the value is a string that looks like a number)ŸE** then the conversion is performed.  Otherwise no conversion occurs.ŸB** The [SQLITE_INTEGER | datatype] after conversion is returned.)^¢**Ÿ9** ^Within the [xUpdate] method of a [virtual table], theŸB** sqlite3_value_nochange(X) interface returns true if and only ifŸE** the column corresponding to X is unchanged by the UPDATE operationŸ?** that the xUpdate method call was invoked to implement and ifŸD** and the prior [xColumn] method call that was invoked to extractedŸH** the value for that column returned without setting a result (probablyŸI** because it queried [sqlite3_vtab_nochange()] and found that the columnŸE** was unchanging).  ^Within an [xUpdate] method, any value for whichŸF** sqlite3_value_nochange(X) is true will in all other respects appearŸN** to be a NULL value.  If sqlite3_value_nochange(X) is invoked anywhere otherŸE** than within an [xUpdate] method call for an UPDATE statement, thenŸ1** the return value is arbitrary and meaningless.¢**ŸH** Please pay particular attention to the fact that the pointer returnedŸ:** from [sqlite3_value_blob()], [sqlite3_value_text()], orŸF** [sqlite3_value_text16()] can be invalidated by a subsequent call toŸN** [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite3_value_text()],ø** or [sqlite3_value_text16()].¢**Ÿ8** These routines must be called from the same thread asŸB** the SQL function that supplied the [sqlite3_value*] parameters.¢*/Ÿ:SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);Ÿ7SQLITE_API double sqlite3_value_double(sqlite3_value*);Ÿ1SQLITE_API int sqlite3_value_int(sqlite3_value*);Ÿ=SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);ŸDSQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);ŸCSQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);Ÿ<SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);Ÿ>SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);Ÿ>SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);Ÿ3SQLITE_API int sqlite3_value_bytes(sqlite3_value*);Ÿ5SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);Ÿ2SQLITE_API int sqlite3_value_type(sqlite3_value*);Ÿ:SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);Ÿ6SQLITE_API int sqlite3_value_nochange(sqlite3_value*);†¢/*Ÿ.** CAPI3REF: Finding The Subtype Of SQL Values∏** METHOD: sqlite3_value¢**Ÿ@** The sqlite3_value_subtype(V) function returns the subtype forŸA** an [application-defined SQL function] argument V.  The subtypeŸC** information can be used to pass a limited amount of context fromŸC** one SQL function to another.  Use the [sqlite3_result_subtype()]ŸF** routine to set the subtype for the return value of an SQL function.¢*/Ÿ>SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);†¢/*Ÿ%** CAPI3REF: Copy And Free SQL Values∏** METHOD: sqlite3_value¢**ŸJ** ^The sqlite3_value_dup(V) interface makes a copy of the [sqlite3_value]ŸN** object D and returns a pointer to that copy.  ^The [sqlite3_value] returnedŸB** is a [protected sqlite3_value] object even if the input is not.ŸH** ^The sqlite3_value_dup(V) interface returns NULL if V is NULL or if aª** memory allocation fails.¢**ŸG** ^The sqlite3_value_free(V) interface frees an [sqlite3_value] objectŸK** previously obtained from [sqlite3_value_dup()].  ^If V is a NULL pointerŸ2** then sqlite3_value_free(V) is a harmless no-op.¢*/ŸBSQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*);Ÿ3SQLITE_API void sqlite3_value_free(sqlite3_value*);†¢/*Ÿ.** CAPI3REF: Obtain Aggregate Function Context∫** METHOD: sqlite3_context¢**Ÿ6** Implementations of aggregate SQL functions use thisŸ6** routine to allocate memory for storing their state.¢**ŸH** ^The first time the sqlite3_aggregate_context(C,N) routine is called Ÿ.** for a particular aggregate function, SQLiteŸG** allocates N of memory, zeroes out that memory, and returns a pointerŸ8** to the new memory. ^On second and subsequent calls toŸH** sqlite3_aggregate_context() for the same aggregate function instance,ŸH** the same buffer is returned.  Sqlite3_aggregate_context() is normallyŸE** called once for each invocation of the xStep callback and then oneŸG** last time when the xFinal callback is invoked.  ^(When no rows matchŸE** an aggregate query, the xStep() callback of the aggregate functionŸF** implementation is never called and xFinal() is called exactly once.ŸF** In those cases, sqlite3_aggregate_context() might be called for theŸ%** first time from within xFinal().)^¢**ŸF** ^The sqlite3_aggregate_context(C,N) routine returns a NULL pointer ŸF** when first called if N is less than or equal to zero or if a memoryπ** allocate error occurs.¢**ŸG** ^(The amount of space allocated by sqlite3_aggregate_context(C,N) isŸH** determined by the N parameter on first successful call.  Changing theŸF** value of N in subsequent call to sqlite3_aggregate_context() withinŸB** the same aggregate function instance will not resize the memoryŸD** allocation.)^  Within the xFinal callback, it is customary to setŸ=** N=0 in calls to sqlite3_aggregate_context(C,N) so that no Ÿ&** pointless memory allocations occur.¢**Ÿ7** ^SQLite automatically frees the memory allocated by ŸB** sqlite3_aggregate_context() when the aggregate query concludes.¢**Ÿ,** The first parameter must be a copy of theŸG** [sqlite3_context | SQL function context] that is the first parameterŸH** to the xStep or xFinal callback routine that implements the aggregate¨** function.¢**Ÿ<** This routine must be called from the same thread in whichŸ)** the aggregate SQL function is running.¢*/ŸISQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);†¢/*Ÿ$** CAPI3REF: User Data For Functions∫** METHOD: sqlite3_context¢**Ÿ7** ^The sqlite3_user_data() interface returns a copy ofŸC** the pointer that was the pUserData parameter (the 5th parameter)Ÿ%** of the [sqlite3_create_function()]Ÿ=** and [sqlite3_create_function16()] routines that originallyŸ/** registered the application defined function.¢**Ÿ<** This routine must be called from the same thread in whichŸ/** the application-defined function is running.¢*/Ÿ5SQLITE_API void *sqlite3_user_data(sqlite3_context*);†¢/*Ÿ.** CAPI3REF: Database Connection For Functions∫** METHOD: sqlite3_context¢**Ÿ?** ^The sqlite3_context_db_handle() interface returns a copy ofŸ?** the pointer to the [database connection] (the 1st parameter)Ÿ%** of the [sqlite3_create_function()]Ÿ=** and [sqlite3_create_function16()] routines that originallyŸ/** registered the application defined function.¢*/Ÿ@SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);†¢/*Ÿ$** CAPI3REF: Function Auxiliary Data∫** METHOD: sqlite3_context¢**ŸB** These functions may be used by (non-aggregate) SQL functions toŸJ** associate metadata with argument values. If the same value is passed toŸN** multiple invocations of the same SQL function during query execution, underŸK** some circumstances the associated metadata may be preserved.  An exampleŸD** of where this might be useful is in a regular-expression matchingŸL** function. The compiled version of the regular expression can be stored asŸ1** metadata associated with the pattern string.  Ÿ7** Then as long as the pattern string remains the same,Ÿ<** the compiled regular expression can be reused on multipleŸ$** invocations of the same function.¢**ŸL** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadataŸP** associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argumentŸK** value to the application-defined function.  ^N is zero for the left-mostŸ/** function argument.  ^If there is no metadataŸP** associated with the function argument, the sqlite3_get_auxdata(C,N) interface∫** returns a NULL pointer.¢**ŸO** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-thŸ=** argument of the application-defined function.  ^SubsequentŸB** calls to sqlite3_get_auxdata(C,N) return P from the most recentŸF** sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid orŸ+** NULL if the metadata has been discarded.ŸH** ^After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL,ŸH** SQLite will invoke the destructor function X with parameter P exactlyŸ(** once, when the metadata is discarded.ŸF** SQLite is free to discard the metadata at any time, including: <ul>ŸA** <li> ^(when the corresponding function parameter changes)^, orŸJ** <li> ^(when [sqlite3_reset()] or [sqlite3_finalize()] is called for theª**      SQL statement)^, orŸA** <li> ^(when sqlite3_set_auxdata() is invoked again on the same∏**       parameter)^, orŸG** <li> ^(during the original sqlite3_set_auxdata() call when a memory Ÿ(**      allocation error occurs.)^ </ul>¢**Ÿ<** Note the last bullet in particular.  The destructor X in ŸG** sqlite3_set_auxdata(C,N,P,X) might be called immediately, before theŸM** sqlite3_set_auxdata() interface even returns.  Hence sqlite3_set_auxdata()ŸG** should be called near the end of the function implementation and theŸ=** function implementation should not make any use of P afterŸ)** sqlite3_set_auxdata() has been called.¢**ŸB** ^(In practice, metadata is preserved between function calls forŸI** function parameters that are compile-time constants, including literalŸD** values and [parameters] and expressions composed from the same.)^¢**ŸK** The value of the N parameter to these interfaces should be non-negative.ŸF** Future enhancements may make use of negative N values to define newŸ&** kinds of function caching behavior.¢**Ÿ>** These routines must be called from the same thread in whichø** the SQL function is running.¢*/Ÿ>SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);ŸUSQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));††¢/*Ÿ;** CAPI3REF: Constants Defining Special Destructor Behavior¢**ŸG** These are special values for the destructor that is passed in as theŸO** final argument to routines like [sqlite3_result_blob()].  ^If the destructorŸK** argument is SQLITE_STATIC, it means that the content pointer is constantŸB** and will never change.  It does not need to be destroyed.  ^TheŸF** SQLITE_TRANSIENT value means that the content will likely change inŸF** the near future and that SQLite should make its own private copy ofŸ ** the content before returning.¢**Ÿ>** The typedef is necessary to work around problems in certain±** C++ compilers.¢*/Ÿ/typedef void (*sqlite3_destructor_type)(void*);Ÿ7#define SQLITE_STATIC      ((sqlite3_destructor_type)0)Ÿ8#define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1)†¢/*Ÿ2** CAPI3REF: Setting The Result Of An SQL Function∫** METHOD: sqlite3_context¢**Ÿ@** These routines are used by the xFunc or xFinal callbacks thatŸ/** implement SQL functions and aggregates.  SeeŸ@** [sqlite3_create_function()] and [sqlite3_create_function16()]æ** for additional information.¢**ŸH** These functions work very much like the [parameter binding] family ofŸK** functions used to bind values to host parameters in prepared statements.ŸI** Refer to the [SQL parameter] documentation for additional information.¢**Ÿ<** ^The sqlite3_result_blob() interface sets the result fromŸJ** an application-defined function to be the BLOB whose content is pointedŸF** to by the second parameter and which is N bytes long where N is the≥** third parameter.¢**ŸG** ^The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N)ŸF** interfaces set the result of the application-defined function to beŸ8** a BLOB containing all zero bytes and N bytes in size.¢**Ÿ>** ^The sqlite3_result_double() interface sets the result fromŸI** an application-defined function to be a floating point value specified∑** by its 2nd argument.¢**ŸE** ^The sqlite3_result_error() and sqlite3_result_error16() functionsŸ<** cause the implemented SQL function to throw an exception.Ÿ,** ^SQLite uses the string pointed to by theŸF** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()ŸA** as the text of an error message.  ^SQLite interprets the errorŸ?** message string from sqlite3_result_error() as UTF-8. ^SQLiteŸJ** interprets the string from sqlite3_result_error16() as UTF-16 in nativeŸA** byte order.  ^If the third parameter to sqlite3_result_error()ŸI** or sqlite3_result_error16() is negative then SQLite takes as the errorŸ8** message all text up through the first zero character.Ÿ7** ^If the third parameter to sqlite3_result_error() orŸG** sqlite3_result_error16() is non-negative then SQLite takes that manyŸF** bytes (not characters) from the 2nd parameter as the error message.Ÿ;** ^The sqlite3_result_error() and sqlite3_result_error16()Ÿ@** routines make a private copy of the error message text beforeŸ>** they return.  Hence, the calling function can deallocate orŸ2** modify the text after they return without harm.ŸC** ^The sqlite3_result_error_code() function changes the error codeŸJ** returned by SQLite as a result of an error in a function.  ^By default,ŸP** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()ŸE** or sqlite3_result_error16() resets the error code to SQLITE_ERROR.¢**ŸI** ^The sqlite3_result_error_toobig() interface causes SQLite to throw anŸC** error indicating that a string or BLOB is too long to represent.¢**ŸH** ^The sqlite3_result_error_nomem() interface causes SQLite to throw anŸ4** error indicating that a memory allocation failed.¢**Ÿ<** ^The sqlite3_result_int() interface sets the return valueŸF** of the application-defined function to be the 32-bit signed integerŸ#** value given in the 2nd argument.Ÿ>** ^The sqlite3_result_int64() interface sets the return valueŸF** of the application-defined function to be the 64-bit signed integerŸ#** value given in the 2nd argument.¢**Ÿ=** ^The sqlite3_result_null() interface sets the return valueŸ2** of the application-defined function to be NULL.¢**Ÿ7** ^The sqlite3_result_text(), sqlite3_result_text16(),ŸF** sqlite3_result_text16le(), and sqlite3_result_text16be() interfacesŸA** set the return value of the application-defined function to beŸI** a text string which is represented as UTF-8, UTF-16 native byte order,Ÿ<** UTF-16 little endian, or UTF-16 big endian, respectively.ŸE** ^The sqlite3_result_text64() interface sets the return value of anŸB** application-defined function to be a text string in an encodingŸA** specified by the fifth (and last) parameter, which must be oneŸK** of [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE].Ÿ:** ^SQLite takes the text result from the application fromŸ<** the 2nd parameter of the sqlite3_result_text* interfaces.Ÿ?** ^If the 3rd parameter to the sqlite3_result_text* interfacesŸD** is negative, then SQLite takes result text from the 2nd parameterŸ$** through the first zero character.Ÿ?** ^If the 3rd parameter to the sqlite3_result_text* interfacesŸC** is non-negative, then as many bytes (not characters) of the textŸG** pointed to by the 2nd parameter are taken as the application-definedŸB** function result.  If the 3rd parameter is non-negative, then itŸI** must be the byte offset into the string where the NUL terminator wouldŸJ** appear if the string where NUL terminated.  If any NUL characters occurŸH** in the string at a byte offset that is less than the value of the 3rdŸJ** parameter, then the resulting string will contain embedded NULs and theŸN** result of expressions operating on strings with embedded NULs is undefined.Ÿ?** ^If the 4th parameter to the sqlite3_result_text* interfacesŸG** or sqlite3_result_blob is a non-NULL pointer, then SQLite calls thatŸD** function as the destructor on the text or BLOB result when it hasæ** finished using that result.ŸE** ^If the 4th parameter to the sqlite3_result_text* interfaces or toŸI** sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLiteŸI** assumes that the text or BLOB result is in constant space and does notŸI** copy the content of the parameter nor call a destructor on the contentŸ*** when it has finished using that result.Ÿ?** ^If the 4th parameter to the sqlite3_result_text* interfacesŸB** or sqlite3_result_blob is the special constant SQLITE_TRANSIENTŸ=** then SQLite makes a copy of the result into space obtainedŸ-** from [sqlite3_malloc()] before it returns.¢**Ÿ;** ^The sqlite3_result_value() interface sets the result ofŸ7** the application-defined function to be a copy of theŸK** [unprotected sqlite3_value] object specified by the 2nd parameter.  ^TheŸG** sqlite3_result_value() interface makes a copy of the [sqlite3_value]ŸG** so that the [sqlite3_value] specified in the parameter may change orŸD** be deallocated after sqlite3_result_value() returns without harm.ŸB** ^A [protected sqlite3_value] object may always be used where anŸ<** [unprotected sqlite3_value] object is required, so eitherŸB** kind of [sqlite3_value] object can be used with this interface.¢**ŸG** ^The sqlite3_result_pointer(C,P,T,D) interface sets the result to anŸE** SQL NULL value, just like [sqlite3_result_null(C)], except that itŸC** also associates the host-language pointer P or type T with that Ÿ>** NULL value such that the pointer can be retrieved within anŸF** [application-defined SQL function] using [sqlite3_value_pointer()].ŸH** ^If the D parameter is not NULL, then it is a pointer to a destructorŸF** for the P parameter.  ^SQLite invokes D with P as its only argumentŸF** when SQLite is finished with P.  The T parameter should be a staticŸG** string and preferably a string literal. The sqlite3_result_pointer()ŸN** routine is part of the [pointer passing interface] added for SQLite 3.20.0.¢**Ÿ@** If these routines are called from within the different threadŸI** than the one containing the application-defined function that receivedŸ<** the [sqlite3_context] pointer, the results are undefined.¢*/ŸXSQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));ŸCSQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,Ÿ:                           sqlite3_uint64,void(*)(void*));Ÿ@SQLITE_API void sqlite3_result_double(sqlite3_context*, double);ŸISQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);ŸKSQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);Ÿ>SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);Ÿ=SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);ŸASQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);Ÿ:SQLITE_API void sqlite3_result_int(sqlite3_context*, int);ŸFSQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);Ÿ6SQLITE_API void sqlite3_result_null(sqlite3_context*);ŸXSQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));ŸSSQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,ŸC                           void(*)(void*), unsigned char encoding);ŸZSQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));Ÿ[SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));Ÿ[SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));ŸGSQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);Ÿ[SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));ŸASQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);ŸMSQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);††¢/*Ÿ3** CAPI3REF: Setting The Subtype Of An SQL Function∫** METHOD: sqlite3_context¢**ŸA** The sqlite3_result_subtype(C,T) function causes the subtype ofŸ?** the result from the [application-defined SQL function] with ŸA** [sqlite3_context] C to be the value T.  Only the lower 8 bits Ÿ@** of the subtype T are preserved in current versions of SQLite;Ÿ#** higher order bits are discarded.ŸA** The number of subtype bytes preserved by SQLite might increaseŸ ** in future releases of SQLite.¢*/ŸFSQLITE_API void sqlite3_result_subtype(sqlite3_context*,unsigned int);†¢/*Ÿ+** CAPI3REF: Define New Collating Sequences≤** METHOD: sqlite3¢**ŸC** ^These functions add, remove, or modify a [collation] associatedŸB** with the [database connection] specified as the first argument.¢**Ÿ/** ^The name of the collation is a UTF-8 stringŸC** for sqlite3_create_collation() and sqlite3_create_collation_v2()ŸM** and a UTF-16 string in native byte order for sqlite3_create_collation16().ŸL** ^Collation names that compare equal according to [sqlite3_strnicmp()] areŸ"** considered to be the same name.¢**Ÿ@** ^(The third argument (eTextRep) must be one of the constants:ß** <ul>∂** <li> [SQLITE_UTF8],π** <li> [SQLITE_UTF16LE],π** <li> [SQLITE_UTF16BE],∫** <li> [SQLITE_UTF16], orø** <li> [SQLITE_UTF16_ALIGNED].™** </ul>)^ŸC** ^The eTextRep argument determines the encoding of strings passedŸ1** to the collating function callback, xCallback.ŸE** ^The [SQLITE_UTF16] and [SQLITE_UTF16_ALIGNED] values for eTextRepŸ4** force strings to be UTF16 with native byte order.ŸI** ^The [SQLITE_UTF16_ALIGNED] value for eTextRep forces strings to beginª** on an even byte address.¢**ŸL** ^The fourth argument, pArg, is an application data pointer that is passedŸD** through as the first argument to the collating function callback.¢**ŸJ** ^The fifth argument, xCallback, is a pointer to the collating function.ŸJ** ^Multiple collating functions can be registered using the same name butŸC** with different eTextRep parameters and SQLite will use whicheverŸ=** function requires the least amount of data transformation.ŸD** ^If the xCallback argument is NULL then the collating function isŸL** deleted.  ^When all collating functions having the same name are deleted,Ÿ&** that collation is no longer usable.¢**ŸG** ^The collating function callback is invoked with a copy of the pArg ŸJ** application data pointer and with two strings in the encoding specifiedŸC** by the eTextRep argument.  The collating function must return anŸ.** integer that is negative, zero, or positiveŸJ** if the first string is less than, equal to, or greater than the second,ŸI** respectively.  A collating function must always return the same answerŸL** given the same inputs.  If two or more collating functions are registeredŸH** to the same collation name (using different eTextRep values) then allŸG** must give an equivalent answer when invoked with equivalent strings.ŸD** The collating function must obey the following properties for all∑** strings A, B, and C:¢**ß** <ol>∫** <li> If A==B then B==A.Ÿ#** <li> If A==B and B==C then A==C.æ** <li> If A&lt;B THEN B&gt;A.Ÿ)** <li> If A&lt;B and B&lt;C then A&lt;C.®** </ol>¢**ŸF** If a collating function fails any of the above constraints and thatŸJ** collating function is  registered and used, then the behavior of SQLite∞** is undefined.¢**ŸK** ^The sqlite3_create_collation_v2() works like sqlite3_create_collation()ŸG** with the addition that the xDestroy callback is invoked on pArg whenŸ%** the collating function is deleted.ŸE** ^Collating functions are deleted when they are overridden by laterŸ8** calls to the collation creation functions or when theŸ;** [database connection] is closed using [sqlite3_close()].¢**Ÿ6** ^The xDestroy callback is <u>not</u> called if the ŸJ** sqlite3_create_collation_v2() function fails.  Applications that invokeŸJ** sqlite3_create_collation_v2() with a non-NULL xDestroy argument should ŸD** check the return code and dispose of the application data pointerŸD** themselves rather than expecting SQLite to deal with it for them.ŸK** This is different from every other SQLite interface.  The inconsistency ŸC** is unfortunate but cannot be changed without breaking backwards ±** compatibility.¢**ŸN** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].¢*/Ÿ(SQLITE_API int sqlite3_create_collation(¨  sqlite3*, µ  const char *zName, ∞  int eTextRep, ≠  void *pArg,Ÿ7  int(*xCompare)(void*,int,const void*,int,const void*)¢);Ÿ+SQLITE_API int sqlite3_create_collation_v2(¨  sqlite3*, µ  const char *zName, ∞  int eTextRep, ≠  void *pArg,Ÿ8  int(*xCompare)(void*,int,const void*,int,const void*),∏  void(*xDestroy)(void*)¢);Ÿ*SQLITE_API int sqlite3_create_collation16(¨  sqlite3*, ¥  const void *zName,∞  int eTextRep, ≠  void *pArg,Ÿ7  int(*xCompare)(void*,int,const void*,int,const void*)¢);†¢/*Ÿ'** CAPI3REF: Collation Needed Callbacks≤** METHOD: sqlite3¢**ŸI** ^To avoid having to register all collation sequences before a databaseŸE** can be used, a single callback function may be registered with theŸF** [database connection] to be invoked whenever an undefined collation∏** sequence is required.¢**ŸK** ^If the function is registered using the sqlite3_collation_needed() API,ŸJ** then it is passed the names of undefined collation sequences as stringsŸ>** encoded in UTF-8. ^If sqlite3_collation_needed16() is used,Ÿ?** the names are passed as UTF-16 in machine native byte order.ŸN** ^A call to either function replaces the existing collation-needed callback.¢**ŸF** ^(When the callback is invoked, the first argument passed is a copyŸ:** of the second argument to sqlite3_collation_needed() orŸE** sqlite3_collation_needed16().  The second argument is the databaseŸM** connection.  The third argument is one of [SQLITE_UTF8], [SQLITE_UTF16BE],ŸK** or [SQLITE_UTF16LE], indicating the most desirable form of the collationŸG** sequence function required.  The fourth parameter is the name of theŸ!** required collation sequence.)^¢**ŸD** The callback function should register the desired collation usingŸC** [sqlite3_create_collation()], [sqlite3_create_collation16()], orŸ#** [sqlite3_create_collation_v2()].¢*/Ÿ(SQLITE_API int sqlite3_collation_needed(¨  sqlite3*, ©  void*, Ÿ2  void(*)(void*,sqlite3*,int eTextRep,const char*)¢);Ÿ*SQLITE_API int sqlite3_collation_needed16(¨  sqlite3*, ®  void*,Ÿ2  void(*)(void*,sqlite3*,int eTextRep,const void*)¢);†∑#ifdef SQLITE_HAS_CODEC¢/*ŸE** Specify the key for an encrypted database.  This routine should beŸ%** called right after sqlite3_open().¢**ŸH** The code to implement this API is not available in the public release≠** of SQLite.¢*/ªSQLITE_API int sqlite3_key(Ÿ=  sqlite3 *db,                   /* Database to be rekeyed */Ÿ.  const void *pKey, int nKey     /* The key */¢);æSQLITE_API int sqlite3_key_v2(Ÿ=  sqlite3 *db,                   /* Database to be rekeyed */Ÿ;  const char *zDbName,           /* Name of the database */Ÿ.  const void *pKey, int nKey     /* The key */¢);†¢/*ŸF** Change the key on an open database.  If the current database is notŸG** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, theπ** database is decrypted.¢**ŸH** The code to implement this API is not available in the public release≠** of SQLite.¢*/ΩSQLITE_API int sqlite3_rekey(Ÿ=  sqlite3 *db,                   /* Database to be rekeyed */Ÿ2  const void *pKey, int nKey     /* The new key */¢);Ÿ SQLITE_API int sqlite3_rekey_v2(Ÿ=  sqlite3 *db,                   /* Database to be rekeyed */Ÿ;  const char *zDbName,           /* Name of the database */Ÿ2  const void *pKey, int nKey     /* The new key */¢);†¢/*Ÿ:** Specify the activation key for a SEE database.  Unless Ÿ1** activated, none of the SEE routines will work.¢*/Ÿ%SQLITE_API void sqlite3_activate_see(Ÿ8  const char *zPassPhrase        /* Activation phrase */¢);¶#endif†∫#ifdef SQLITE_ENABLE_CEROD¢/*Ÿ<** Specify the activation key for a CEROD database.  Unless Ÿ3** activated, none of the CEROD routines will work.¢*/Ÿ'SQLITE_API void sqlite3_activate_cerod(Ÿ8  const char *zPassPhrase        /* Activation phrase */¢);¶#endif†¢/*Ÿ/** CAPI3REF: Suspend Execution For A Short Time¢**ŸN** The sqlite3_sleep() function causes the current thread to suspend executionŸD** for at least a number of milliseconds specified in its parameter.¢**Ÿ?** If the operating system does not support sleep requests withŸC** millisecond time resolution, then the time will be rounded up toŸC** the nearest second. The number of milliseconds of sleep actuallyŸ3** requested from the operating system is returned.¢**Ÿ<** ^SQLite implements this interface by calling the xSleep()ŸF** method of the default [sqlite3_vfs] object.  If the xSleep() methodŸI** of the default VFS is not implemented correctly, or not implemented atŸM** all, then the behavior of sqlite3_sleep() may deviate from the descriptionæ** in the previous paragraphs.¢*/Ÿ"SQLITE_API int sqlite3_sleep(int);†¢/*Ÿ7** CAPI3REF: Name Of The Folder Holding Temporary Files¢**ŸB** ^(If this global variable is made to point to a string which isŸD** the name of a folder (a.k.a. directory), then all temporary filesŸ>** created by SQLite when using a built-in [sqlite3_vfs | VFS]Ÿ9** will be placed in that directory.)^  ^If this variableŸF** is a NULL pointer, then SQLite performs a search for an appropriateº** temporary file directory.¢**ŸI** Applications are strongly discouraged from using this global variable.ŸG** It is required to set a temporary folder on Windows Runtime (WinRT).ŸJ** But for all other platforms, it is highly recommended that applicationsŸI** neither read nor write this variable.  This global variable is a relicŸL** that exists for backwards compatibility of legacy applications and shouldæ** be avoided in new projects.¢**ŸB** It is not safe to read or modify this variable in more than oneŸD** thread at a time.  It is not safe to read or modify this variableŸJ** if a [database connection] is being used at the same time in a separate™** thread.Ÿ0** It is intended that this variable be set onceŸD** as part of process initialization and before any SQLite interfaceŸD** routines have been called and that this variable remain unchangedÆ** thereafter.¢**ŸH** ^The [temp_store_directory pragma] may modify this variable and causeŸG** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,ŸC** the [temp_store_directory pragma] always assumes that any stringŸ@** that this variable points to is held in memory obtained from ŸB** [sqlite3_malloc] and the pragma may attempt to free that memory∏** using [sqlite3_free].ŸD** Hence, if this variable is modified directly, either it should beŸF** made NULL or made to point to memory obtained from [sqlite3_malloc]ŸJ** or else the use of the [temp_store_directory pragma] should be avoided.ŸE** Except when requested by the [temp_store_directory pragma], SQLiteŸF** does not free the memory that sqlite3_temp_directory points to.  IfŸ<** the application wants that memory to be freed, it must doŸG** so itself, taking care to only do so after all [database connection]ø** objects have been destroyed.¢**ŸM** <b>Note to Windows Runtime users:</b>  The temporary directory must be setŸL** prior to calling [sqlite3_open] or [sqlite3_open_v2].  Otherwise, variousŸI** features that require the use of temporary files may fail.  Here is anŸ@** example of how to do this using C++ with the Windows Runtime:¢**¥** <blockquote><pre>Ÿ?** LPCWSTR zPath = Windows::Storage::ApplicationData::Current->Ÿ,** &nbsp;     TemporaryFolder->Path->Data();Ÿ'** char zPathBuf&#91;MAX_PATH + 1&#93;;Ÿ)** memset(zPathBuf, 0, sizeof(zPathBuf));ŸI** WideCharToMultiByte(CP_UTF8, 0, zPath, -1, zPathBuf, sizeof(zPathBuf),∫** &nbsp;     NULL, NULL);Ÿ<** sqlite3_temp_directory = sqlite3_mprintf("%s", zPathBuf);∂** </pre></blockquote>¢*/Ÿ(SQLITE_API char *sqlite3_temp_directory;†¢/*Ÿ6** CAPI3REF: Name Of The Folder Holding Database Files¢**ŸB** ^(If this global variable is made to point to a string which isŸC** the name of a folder (a.k.a. directory), then all database filesŸ@** specified with a relative pathname and created or accessed byŸK** SQLite when using a built-in windows [sqlite3_vfs | VFS] will be assumedŸB** to be relative to that directory.)^ ^If this variable is a NULLŸA** pointer, then SQLite assumes that all database files specifiedŸA** with a relative pathname are relative to the current directoryŸB** for the process.  Only the windows VFS makes use of this globalŸ+** variable; it is ignored by the unix VFS.¢**ŸE** Changing the value of this variable while a database connection isŸ)** open can result in a corrupt database.¢**ŸB** It is not safe to read or modify this variable in more than oneŸD** thread at a time.  It is not safe to read or modify this variableŸJ** if a [database connection] is being used at the same time in a separate™** thread.Ÿ0** It is intended that this variable be set onceŸD** as part of process initialization and before any SQLite interfaceŸD** routines have been called and that this variable remain unchangedÆ** thereafter.¢**ŸH** ^The [data_store_directory pragma] may modify this variable and causeŸG** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,ŸC** the [data_store_directory pragma] always assumes that any stringŸ@** that this variable points to is held in memory obtained from ŸB** [sqlite3_malloc] and the pragma may attempt to free that memory∏** using [sqlite3_free].ŸD** Hence, if this variable is modified directly, either it should beŸF** made NULL or made to point to memory obtained from [sqlite3_malloc]ŸJ** or else the use of the [data_store_directory pragma] should be avoided.¢*/Ÿ(SQLITE_API char *sqlite3_data_directory;†¢/*Ÿ&** CAPI3REF: Test For Auto-Commit Modeæ** KEYWORDS: {autocommit mode}≤** METHOD: sqlite3¢**Ÿ>** ^The sqlite3_get_autocommit() interface returns non-zero orŸI** zero if the given database connection is or is not in autocommit mode,Ÿ4** respectively.  ^Autocommit mode is on by default.Ÿ7** ^Autocommit mode is disabled by a [BEGIN] statement.Ÿ>** ^Autocommit mode is re-enabled by a [COMMIT] or [ROLLBACK].¢**ŸK** If certain kinds of errors occur on a statement within a multi-statementŸ?** transaction (errors including [SQLITE_FULL], [SQLITE_IOERR],ŸB** [SQLITE_NOMEM], [SQLITE_BUSY], and [SQLITE_INTERRUPT]) then theŸC** transaction might be rolled back automatically.  The only way toŸJ** find out whether SQLite automatically rolled back the transaction afterŸ$** an error is to use this function.¢**ŸB** If another thread changes the autocommit status of the databaseŸB** connection while this routine is running, then the return value∞** is undefined.¢*/Ÿ0SQLITE_API int sqlite3_get_autocommit(sqlite3*);†¢/*Ÿ=** CAPI3REF: Find The Database Handle Of A Prepared Statement∑** METHOD: sqlite3_stmt¢**ŸL** ^The sqlite3_db_handle interface returns the [database connection] handleŸG** to which a [prepared statement] belongs.  ^The [database connection]ŸB** returned by sqlite3_db_handle is the same [database connection]æ** that was the first argumentŸH** to the [sqlite3_prepare_v2()] call (or its variants) that was used toŸ+** create the statement in the first place.¢*/Ÿ5SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);†¢/*Ÿ:** CAPI3REF: Return The Filename For A Database Connection≤** METHOD: sqlite3¢**ŸJ** ^The sqlite3_db_filename(D,N) interface returns a pointer to a filenameŸG** associated with database N of connection D.  ^The main database fileŸK** has the name "main".  If there is no attached database N on the databaseŸL** connection D, or if database N is a temporary or in-memory database, thenæ** a NULL pointer is returned.¢**Ÿ?** ^The filename returned by this function is the output of theŸD** xFullPathname method of the [VFS].  ^In other words, the filenameŸ:** will be an absolute pathname, even if the filename usedŸB** to open the database originally was a URI or relative pathname.¢*/ŸMSQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);†¢/*Ÿ1** CAPI3REF: Determine if a database is read-only≤** METHOD: sqlite3¢**ŸF** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database NŸI** of connection D is read-only, 0 if it is read/write, or -1 if N is notŸ*** the name of a database on connection D.¢*/ŸESQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);†¢/*Ÿ-** CAPI3REF: Find the next prepared statement≤** METHOD: sqlite3¢**ŸK** ^This interface returns a pointer to the next [prepared statement] afterŸJ** pStmt associated with the [database connection] pDb.  ^If pStmt is NULLŸH** then this interface returns a pointer to the first prepared statementŸJ** associated with the database connection pDb.  ^If no prepared statementŸ=** satisfies the conditions of this routine, it returns NULL.¢**Ÿ3** The [database connection] pointer D in a call toŸ:** [sqlite3_next_stmt(D,S)] must refer to an open databaseŸ;** connection and in particular must not be a NULL pointer.¢*/ŸNSQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);†¢/*Ÿ7** CAPI3REF: Commit And Rollback Notification Callbacks≤** METHOD: sqlite3¢**Ÿ<** ^The sqlite3_commit_hook() interface registers a callbackŸI** function to be invoked whenever a transaction is [COMMIT | committed].Ÿ@** ^Any callback set by a previous call to sqlite3_commit_hook()Ÿ2** for the same database connection is overridden.Ÿ>** ^The sqlite3_rollback_hook() interface registers a callbackŸM** function to be invoked whenever a transaction is [ROLLBACK | rolled back].ŸB** ^Any callback set by a previous call to sqlite3_rollback_hook()Ÿ2** for the same database connection is overridden.Ÿ8** ^The pArg argument is passed through to the callback.Ÿ?** ^If the callback on a commit hook function returns non-zero,Ÿ0** then the commit is converted into a rollback.¢**ŸM** ^The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functionsŸD** return the P argument from the previous call of the same functionŸ3** on the same [database connection] D, or NULL forŸ)** the first call for each function on D.¢**Ÿ<** The commit and rollback hook callbacks are not reentrant.ŸD** The callback implementation must not do anything that will modifyŸB** the database connection that invoked the callback.  Any actionsŸE** to modify the database connection must be deferred until after theŸD** completion of the [sqlite3_step()] call that triggered the commitŸ'** or rollback hook in the first place.ŸK** Note that running any other SQL statements, including SELECT statements,ŸL** or merely calling [sqlite3_prepare_v2()] and [sqlite3_step()] will modifyŸJ** the database connections for the meaning of "modify" in this paragraph.¢**Ÿ6** ^Registering a NULL function disables the callback.¢**ŸD** ^When the commit hook callback routine returns zero, the [COMMIT]ŸB** operation is allowed to continue normally.  ^If the commit hookŸF** returns non-zero, then the [COMMIT] is converted into a [ROLLBACK].ŸI** ^The rollback hook is invoked on a rollback that results from a commitŸH** hook returning non-zero, just as it would be with any other rollback.¢**ŸD** ^For the purposes of this API, a transaction is said to have beenŸB** rolled back if an explicit "ROLLBACK" statement is executed, orŸ?** an error or constraint causes an implicit rollback to occur.Ÿ<** ^The rollback callback is not invoked if a transaction isŸG** automatically rolled back because the database connection is closed.¢**Ÿ2** See also the [sqlite3_update_hook()] interface.¢*/ŸESQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);ŸISQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);†¢/*Ÿ/** CAPI3REF: Data Change Notification Callbacks≤** METHOD: sqlite3¢**ŸE** ^The sqlite3_update_hook() interface registers a callback functionŸB** with the [database connection] identified by the first argumentŸB** to be invoked whenever a row is updated, inserted or deleted in≥** a [rowid table].Ÿ8** ^Any callback set by a previous call to this functionŸ2** for the same database connection is overridden.¢**ŸE** ^The second argument is a pointer to the function to invoke when aŸ8** row is updated, inserted or deleted in a rowid table.ŸF** ^The first argument to the callback is a copy of the third argumentº** to sqlite3_update_hook().ŸL** ^The second callback argument is one of [SQLITE_INSERT], [SQLITE_DELETE],ŸJ** or [SQLITE_UPDATE], depending on the operation that caused the callback±** to be invoked.ŸJ** ^The third and fourth arguments to the callback contain pointers to theŸ7** database and table name containing the affected row.Ÿ;** ^The final callback parameter is the [rowid] of the row.ŸO** ^In the case of an update, this is the [rowid] after the update takes place.¢**ŸC** ^(The update hook is not invoked when internal system tables areŸ7** modified (i.e. sqlite_master and sqlite_sequence).)^ŸL** ^The update hook is not invoked when [WITHOUT ROWID] tables are modified.¢**Ÿ2** ^In the current implementation, the update hookŸA** is not invoked when conflicting rows are deleted because of anŸG** [ON CONFLICT | ON CONFLICT REPLACE] clause.  ^Nor is the update hookŸC** invoked when rows are deleted using the [truncate optimization].ŸD** The exceptions defined in this paragraph might change in a futureµ** release of SQLite.¢**ŸG** The update hook implementation must not do anything that will modifyŸE** the database connection that invoked the update hook.  Any actionsŸE** to modify the database connection must be deferred until after theŸJ** completion of the [sqlite3_step()] call that triggered the update hook.ŸJ** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify theirŸF** database connections for the meaning of "modify" in this paragraph.¢**Ÿ+** ^The sqlite3_update_hook(D,C,P) functionŸ0** returns the P argument from the previous callŸ3** on the same [database connection] D, or NULL for∑** the first call on D.¢**ŸC** See also the [sqlite3_commit_hook()], [sqlite3_rollback_hook()],Ÿ-** and [sqlite3_preupdate_hook()] interfaces.¢*/Ÿ%SQLITE_API void *sqlite3_update_hook(¨  sqlite3*, Ÿ?  void(*)(void *,int ,char const *,char const *,sqlite3_int64),ß  void*¢);†¢/*Ÿ1** CAPI3REF: Enable Or Disable Shared Pager Cache¢**ŸG** ^(This routine enables or disables the sharing of the database cacheŸI** and schema data structures between [database connection | connections]ŸC** to the same database. Sharing is enabled if the argument is trueŸ+** and disabled if the argument is false.)^¢**Ÿ@** ^Cache sharing is enabled and disabled for an entire process.ŸC** This is a change as of SQLite [version 3.5.0] ([dateof:3.5.0]). ø** In prior versions of SQLite,Ÿ>** sharing was enabled or disabled for each thread separately.¢**ŸH** ^(The cache sharing mode set by this interface effects all subsequentŸJ** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].Ÿ>** Existing database connections continue use the sharing modeŸ5** that was in effect at the time they were opened.)^¢**ŸM** ^(This routine returns [SQLITE_OK] if shared cache was enabled or disabledŸ:** successfully.  An [error code] is returned otherwise.)^¢**ŸA** ^Shared cache is disabled by default. But this might change inŸB** future releases of SQLite.  Applications that care about sharedŸ*** cache setting should set it explicitly.¢**ŸD** Note: This method is disabled on MacOS X 10.7 and iOS version 5.0Ÿ;** and will always return SQLITE_MISUSE. On those systems, ŸC** shared cache mode should be enabled per-database connection via Ÿ6** [sqlite3_open_v2()] with [SQLITE_OPEN_SHAREDCACHE].¢**Ÿ=** This interface is threadsafe on processors where writing aº** 32-bit integer is atomic.¢**Ÿ(** See Also:  [SQLite Shared-Cache Mode]¢*/Ÿ0SQLITE_API int sqlite3_enable_shared_cache(int);†¢/*Ÿ(** CAPI3REF: Attempt To Free Heap Memory¢**ŸC** ^The sqlite3_release_memory() interface attempts to free N bytesŸB** of heap memory by deallocating non-essential memory allocationsŸ@** held by the database library.   Memory used to cache databaseŸF** pages to improve performance is an example of non-essential memory.ŸH** ^sqlite3_release_memory() returns the number of bytes actually freed,Ÿ9** which might be more or less than the amount requested.ŸB** ^The sqlite3_release_memory() routine is a no-op returning zeroŸD** if SQLite is not compiled with [SQLITE_ENABLE_MEMORY_MANAGEMENT].¢**Ÿ*** See also: [sqlite3_db_release_memory()]¢*/Ÿ+SQLITE_API int sqlite3_release_memory(int);†¢/*Ÿ6** CAPI3REF: Free Memory Used By A Database Connection≤** METHOD: sqlite3¢**ŸL** ^The sqlite3_db_release_memory(D) interface attempts to free as much heapŸ<** memory as possible from database connection D. Unlike theŸI** [sqlite3_release_memory()] interface, this interface is in effect evenŸD** when the [SQLITE_ENABLE_MEMORY_MANAGEMENT] compile-time option is´** omitted.¢**Ÿ'** See also: [sqlite3_release_memory()]¢*/Ÿ3SQLITE_API int sqlite3_db_release_memory(sqlite3*);†¢/*Ÿ(** CAPI3REF: Impose A Limit On Heap Size¢**ŸE** ^The sqlite3_soft_heap_limit64() interface sets and/or queries theŸK** soft limit on the amount of heap memory that may be allocated by SQLite.ŸF** ^SQLite strives to keep heap memory utilization below the soft heapŸ?** limit by reducing the number of pages held in the page cacheŸ.** as heap memory usages approaches the limit.ŸL** ^The soft heap limit is "soft" because even though SQLite strives to stayŸA** below the limit, it will exceed the limit rather than generateŸA** an [SQLITE_NOMEM] error.  In other words, the soft heap limit ¥** is advisory only.¢**ŸD** ^The return value from sqlite3_soft_heap_limit64() is the size ofŸG** the soft heap limit prior to the call, or negative in the case of anŸ)** error.  ^If the argument N is negativeŸE** then no change is made to the soft heap limit.  Hence, the currentŸ<** size of the soft heap limit can be determined by invokingŸ8** sqlite3_soft_heap_limit64() with a negative argument.¢**ŸC** ^If the argument N is zero then the soft heap limit is disabled.¢**ŸF** ^(The soft heap limit is not enforced in the current implementationŸ3** if one or more of following conditions are true:¢**ß** <ul>Ÿ+** <li> The soft heap limit is set to zero.Ÿ@** <li> Memory accounting is disabled using a combination of theŸM**      [sqlite3_config]([SQLITE_CONFIG_MEMSTATUS],...) start-time option andŸ;**      the [SQLITE_DEFAULT_MEMSTATUS] compile-time option.ŸC** <li> An alternative page cache implementation is specified usingŸ6**      [sqlite3_config]([SQLITE_CONFIG_PCACHE2],...).ŸB** <li> The page cache allocates from its own memory pool suppliedŸF**      by [sqlite3_config]([SQLITE_CONFIG_PAGECACHE],...) rather than∂**      from the heap.™** </ul>)^¢**Ÿ;** Beginning with SQLite [version 3.7.3] ([dateof:3.7.3]), Ÿ"** the soft heap limit is enforcedŸE** regardless of whether or not the [SQLITE_ENABLE_MEMORY_MANAGEMENT]ŸK** compile-time option is invoked.  With [SQLITE_ENABLE_MEMORY_MANAGEMENT],ŸG** the soft heap limit is enforced on every memory allocation.  WithoutŸJ** [SQLITE_ENABLE_MEMORY_MANAGEMENT], the soft heap limit is only enforcedŸM** when memory is allocated by the page cache.  Testing suggests that becauseŸ@** the page cache is the predominate memory user in SQLite, mostŸI** applications will achieve adequate soft heap limit enforcement withoutŸ0** the use of [SQLITE_ENABLE_MEMORY_MANAGEMENT].¢**ŸL** The circumstances under which SQLite will enforce the soft heap limit mayŸ(** changes in future releases of SQLite.¢*/ŸDSQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);†¢/*Ÿ1** CAPI3REF: Deprecated Soft Heap Limit Interface≠** DEPRECATED¢**ŸD** This is a deprecated version of the [sqlite3_soft_heap_limit64()]ŸD** interface.  This routine is provided for historical compatibilityŸ-** only.  All new applications should use theŸ@** [sqlite3_soft_heap_limit64()] interface rather than this one.¢*/ŸASQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);††¢/*Ÿ7** CAPI3REF: Extract Metadata About A Column Of A Table≤** METHOD: sqlite3¢**ŸD** ^(The sqlite3_table_column_metadata(X,D,T,C,....) routine returnsŸ6** information about column C of table T in database DŸF** on [database connection] X.)^  ^The sqlite3_table_column_metadata()ŸD** interface returns SQLITE_OK and fills in the non-NULL pointers inŸD** the final five arguments with appropriate values if the specifiedŸI** column exists.  ^The sqlite3_table_column_metadata() interface returnsŸ;** SQLITE_ERROR and if the specified column does not exist.ŸH** ^If the column-name parameter to sqlite3_table_column_metadata() is aŸI** NULL pointer, then this routine simply checks for the existence of theŸI** table and returns SQLITE_OK if the table exists and SQLITE_ERROR if itŸ8** does not.  If the table name parameter T in a call toŸH** sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is∂** undefined behavior.¢**ŸJ** ^The column is identified by the second, third and fourth parameters toŸK** this function. ^(The second parameter is either the name of the databaseŸJ** (i.e. "main", "temp", or an attached database) containing the specifiedŸL** table or NULL.)^ ^If it is NULL, then all attached databases are searchedŸH** for the table using the same algorithm used by the database engine toŸ(** resolve unqualified table references.¢**ŸM** ^The third and fourth parameters to this function are the table and columnŸ,** name of the desired column, respectively.¢**ŸM** ^Metadata is returned by writing to the memory locations passed as the 5thŸM** and subsequent parameters to this function. ^Any of these arguments may beŸH** NULL, in which case the corresponding element of metadata is omitted.¢**±** ^(<blockquote>µ** <table border="1">Ÿ;** <tr><th> Parameter <th> Output<br>Type <th>  Description¢**Ÿ/** <tr><td> 5th <td> const char* <td> Data typeŸH** <tr><td> 6th <td> const char* <td> Name of default collation sequenceŸN** <tr><td> 7th <td> int         <td> True if column has a NOT NULL constraintŸO** <tr><td> 8th <td> int         <td> True if column is part of the PRIMARY KEYŸG** <tr><td> 9th <td> int         <td> True if column is [AUTOINCREMENT]´** </table>≤** </blockquote>)^¢**ŸD** ^The memory pointed to by the character pointers returned for theŸB** declaration type and collation sequence is valid until the nextŸ#** call to any SQLite API function.¢**ŸK** ^If the specified table is actually a view, an [error code] is returned.¢**ŸI** ^If the specified column is "rowid", "oid" or "_rowid_" and the table Ÿ(** is not a [WITHOUT ROWID] table and anŸM** [INTEGER PRIMARY KEY] column has been explicitly declared, then the outputŸJ** parameters are set for the explicitly declared column. ^(If there is noŸ1** [INTEGER PRIMARY KEY] column, then the outputsŸ&** for the [rowid] are set as follows:¢**®** <pre>ª**     data type: "INTEGER"Ÿ#**     collation sequence: "BINARY"≤**     not null: 0µ**     primary key: 1∏**     auto increment: 0´** </pre>)^¢**ŸF** ^This function causes all database schemas to be read from disk andŸE** parsed, if that has not already been done, and returns an error ifŸ7** any errors are encountered while loading the schema.¢*/Ÿ-SQLITE_API int sqlite3_table_column_metadata(Ÿ5  sqlite3 *db,                /* Connection handle */Ÿ9  const char *zDbName,        /* Database name or NULL */Ÿ.  const char *zTableName,     /* Table name */Ÿ/  const char *zColumnName,    /* Column name */Ÿ>  char const **pzDataType,    /* OUTPUT: Declared data type */ŸC  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */ŸN  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */ŸE  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */ŸL  int *pAutoinc               /* OUTPUT: True if column is auto-increment */¢);†¢/*æ** CAPI3REF: Load An Extension≤** METHOD: sqlite3¢**ŸI** ^This interface loads an SQLite extension library from the named file.¢**Ÿ>** ^The sqlite3_load_extension() interface attempts to load anŸ>** [SQLite extension] library contained in the file zFile.  IfŸ@** the file cannot be loaded directly, attempts are made to loadŸ;** with various operating-system specific extensions added.ŸC** So for example, if "samplelib" cannot be loaded, then names likeŸ?** "samplelib.so" or "samplelib.dylib" or "samplelib.dll" might±** be tried also.¢**Ω** ^The entry point is zProc.ŸE** ^(zProc may be 0, in which case SQLite will try to come up with anŸI** entry point name on its own.  It first tries "sqlite3_extension_init".ŸI** If that does not work, it constructs a name "sqlite3_X_init" where theŸE** X is consists of the lower-case equivalent of all ASCII alphabeticŸF** characters in the filename from the last "/" to the first followingŸ(** "." and omitting any initial "lib".)^Ÿ2** ^The sqlite3_load_extension() interface returnsŸE** [SQLITE_OK] on success and [SQLITE_ERROR] if something goes wrong.Ÿ6** ^If an error occurs and pzErrMsg is not 0, then theŸ8** [sqlite3_load_extension()] interface shall attempt toŸ:** fill *pzErrMsg with error message text stored in memoryŸ9** obtained from [sqlite3_malloc()]. The calling functionŸ7** should free this memory by calling [sqlite3_free()].¢**Ÿ+** ^Extension loading must be enabled usingŸ'** [sqlite3_enable_load_extension()] orŸI** [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],1,NULL)Ω** prior to calling this API,Ÿ'** otherwise an error will be returned.¢**Ÿ7** <b>Security warning:</b> It is recommended that the ŸM** [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method be used to enable only thisŸI** interface.  The use of the [sqlite3_enable_load_extension()] interfaceŸI** should be avoided.  This will keep the SQL function [load_extension()]Ÿ<** disabled and prevent SQL injections from giving attackersŸ,** access to extension loading capabilities.¢**Ÿ0** See also the [load_extension() SQL function].¢*/Ÿ&SQLITE_API int sqlite3_load_extension(ŸN  sqlite3 *db,          /* Load the extension into this database connection */ŸM  const char *zFile,    /* Name of the shared library containing extension */ŸC  const char *zProc,    /* Entry point.  Derived from zFile if 0 */Ÿ=  char **pzErrMsg       /* Put error message here if not 0 */¢);†¢/*Ÿ0** CAPI3REF: Enable Or Disable Extension Loading≤** METHOD: sqlite3¢**ŸC** ^So as not to open security holes in older applications that areŸK** unprepared to deal with [extension loading], and as a means of disablingŸK** [extension loading] while evaluating user-entered SQL, the following APIŸK** is provided to turn the [sqlite3_load_extension()] mechanism on and off.¢**Ÿ(** ^Extension loading is off by default.ŸB** ^Call the sqlite3_enable_load_extension() routine with onoff==1ŸA** to turn extension loading on and call it with onoff==0 to turnµ** it back off again.¢**Ÿ5** ^This interface enables or disables both the C-APIŸF** [sqlite3_load_extension()] and the SQL function [load_extension()].ŸK** ^(Use [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],..)Ÿ)** to enable or disable only the C-API.)^¢**ŸD** <b>Security warning:</b> It is recommended that extension loadingŸG** be disabled using the [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] methodŸE** rather than this interface, so the [load_extension()] SQL functionŸK** remains disabled. This will prevent SQL injections from giving attackersŸ,** access to extension loading capabilities.¢*/ŸESQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);†¢/*Ÿ<** CAPI3REF: Automatically Load Statically Linked Extensions¢**ŸF** ^This interface causes the xEntryPoint() function to be invoked forŸI** each new [database connection] that is created.  The idea here is thatŸN** xEntryPoint() is the entry point for a statically linked [SQLite extension]ŸH** that is to be automatically loaded into all new database connections.¢**ŸF** ^(Even though the function prototype shows that xEntryPoint() takesŸI** no arguments and returns void, SQLite invokes xEntryPoint() with threeŸE** arguments and expects an integer result as if the signature of theŸ ** entry point where as follows:¢**¥** <blockquote><pre>ª** &nbsp;  int xEntryPoint(π** &nbsp;    sqlite3 *db,Ÿ#** &nbsp;    const char **pzErrMsg,Ÿ6** &nbsp;    const struct sqlite3_api_routines *pThunk≠** &nbsp;  );∏** </pre></blockquote>)^¢**ŸK** If the xEntryPoint routine encounters an error, it should make *pzErrMsgŸL** point to an appropriate error message (obtained from [sqlite3_mprintf()])ŸJ** and return an appropriate [error code].  ^SQLite ensures that *pzErrMsgŸA** is NULL before calling the xEntryPoint().  ^SQLite will invokeŸF** [sqlite3_free()] on *pzErrMsg after xEntryPoint() returns.  ^If anyŸL** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],ŸI** or [sqlite3_open_v2()] call that provoked the xEntryPoint() will fail.¢**ŸK** ^Calling sqlite3_auto_extension(X) with an entry point X that is alreadyŸK** on the list of automatic extensions is a harmless no-op. ^No entry pointŸM** will be called more than once for each database connection that is opened.¢**Ÿ-** See also: [sqlite3_reset_auto_extension()]Ÿ(** and [sqlite3_cancel_auto_extension()]¢*/Ÿ@SQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void));†¢/*Ÿ/** CAPI3REF: Cancel Automatic Extension Loading¢**ŸD** ^The [sqlite3_cancel_auto_extension(X)] interface unregisters theŸE** initialization routine X that was registered using a prior call toŸH** [sqlite3_auto_extension(X)].  ^The [sqlite3_cancel_auto_extension(X)]ŸB** routine returns 1 if initialization routine X was successfully ŸK** unregistered and it returns 0 if X was not on the list of initialization¨** routines.¢*/ŸGSQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));†¢/*Ÿ.** CAPI3REF: Reset Automatic Extension Loading¢**Ÿ?** ^This interface disables all automatic extensions previouslyŸ/** registered using [sqlite3_auto_extension()].¢*/Ÿ3SQLITE_API void sqlite3_reset_auto_extension(void);†¢/*ŸG** The interface to the virtual-table mechanism is currently consideredŸH** to be experimental.  The interface might change in incompatible ways.ŸG** If this is a problem for you, do not use the interface at this time.¢**ŸC** When the virtual-table mechanism stabilizes, we will declare theŸE** interface fixed, support it indefinitely, and remove this comment.¢*/†¢/*Ÿ1** Structures used by the virtual table interface¢*/Ÿ)typedef struct sqlite3_vtab sqlite3_vtab;Ÿ5typedef struct sqlite3_index_info sqlite3_index_info;Ÿ7typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;Ÿ-typedef struct sqlite3_module sqlite3_module;†¢/*Ÿ!** CAPI3REF: Virtual Table ObjectŸ2** KEYWORDS: sqlite3_module {virtual table module}¢**Ÿ>** This structure, sometimes called a "virtual table module", Ÿ6** defines the implementation of a [virtual tables].  Ÿ<** This structure consists mostly of methods for the module.¢**Ÿ@** ^A virtual table module is created by filling in a persistentŸD** instance of this structure and passing a pointer to that instanceŸ@** to [sqlite3_create_module()] or [sqlite3_create_module_v2()].ŸF** ^The registration remains valid until it is replaced by a differentŸA** module or until the [database connection] closes.  The contentŸ@** of this structure must not change while it is registered withª** any database connection.¢*/∑struct sqlite3_module {Ø  int iVersion;Ÿ&  int (*xCreate)(sqlite3*, void *pAux,Ÿ0               int argc, const char *const*argv,Ÿ.               sqlite3_vtab **ppVTab, char**);Ÿ'  int (*xConnect)(sqlite3*, void *pAux,Ÿ0               int argc, const char *const*argv,Ÿ.               sqlite3_vtab **ppVTab, char**);Ÿ>  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);Ÿ*  int (*xDisconnect)(sqlite3_vtab *pVTab);Ÿ'  int (*xDestroy)(sqlite3_vtab *pVTab);ŸD  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);Ÿ&  int (*xClose)(sqlite3_vtab_cursor*);ŸF  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,Ÿ0                int argc, sqlite3_value **argv);Ÿ%  int (*xNext)(sqlite3_vtab_cursor*);Ÿ$  int (*xEof)(sqlite3_vtab_cursor*);Ÿ>  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);Ÿ=  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);ŸI  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);Ÿ%  int (*xBegin)(sqlite3_vtab *pVTab);Ÿ$  int (*xSync)(sqlite3_vtab *pVTab);Ÿ&  int (*xCommit)(sqlite3_vtab *pVTab);Ÿ(  int (*xRollback)(sqlite3_vtab *pVTab);ŸH  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,ŸM                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),Ÿ%                       void **ppArg);Ÿ8  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);ŸK  /* The methods above are in version 1 of the sqlite_module object. Those Ÿ,  ** below are for version 2 and greater. */Ÿ.  int (*xSavepoint)(sqlite3_vtab *pVTab, int);Ÿ,  int (*xRelease)(sqlite3_vtab *pVTab, int);Ÿ/  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);¢};†¢/*Ÿ/** CAPI3REF: Virtual Table Indexing Informationø** KEYWORDS: sqlite3_index_info¢**ŸI** The sqlite3_index_info structure and its substructures is used as partŸ&** of the [virtual table] interface toŸD** pass information into and receive the reply from the [xBestIndex]ŸK** method of a [virtual table module].  The fields under **Inputs** are theŸB** inputs to xBestIndex and are read-only.  xBestIndex inserts itsŸ'** results into the **Outputs** fields.¢**ŸJ** ^(The aConstraint[] array records WHERE clause constraints of the form:¢**Ÿ*** <blockquote>column OP expr</blockquote>¢**ŸN** where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator isŸ.** stored in aConstraint[].op using one of theŸD** [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^Ÿ)** ^(The index of the column is stored inŸB** aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if theŸH** expr on the right-hand side can be evaluated (and thus the constraintŸ'** is usable) and false if it cannot.)^¢**ŸJ** ^The optimizer automatically inverts terms of the form "expr OP column"ŸG** and makes other simplifications to the WHERE clause in an attempt toŸH** get as many WHERE clause terms into the form shown above as possible.ŸD** ^The aConstraint[] array only reports WHERE clause terms that areŸ:** relevant to the particular virtual table being queried.¢**ŸB** ^Information about the ORDER BY clause is stored in aOrderBy[].ŸB** ^Each term of aOrderBy records a column of the ORDER BY clause.¢**ŸH** The colUsed field indicates which columns of the virtual table may beŸH** required by the current scan. Virtual table columns are numbered fromŸK** zero in the order in which they appear within the CREATE TABLE statementŸM** passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),ŸL** the corresponding bit is set within the colUsed mask if the column may beŸJ** required by SQLite. If the table has at least 64 columns and any columnŸK** to the right of the first 63 is required, then bit 63 of colUsed is alsoŸE** set. In other words, column iCol may be required if the expressionŸJ** (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to ¨** non-zero.¢**ŸH** The [xBestIndex] method must fill aConstraintUsage[] with informationŸB** about what parameters to pass to xFilter.  ^If argvIndex>0 thenŸF** the right-hand side of the corresponding aConstraint[] is evaluatedŸL** and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omitŸE** is true, then the constraint is assumed to be fully handled by theŸ6** virtual table and is not checked again by SQLite.)^¢**ŸA** ^The idxNum and idxPtr values are recorded and passed into the¥** [xFilter] method.Ÿ:** ^[sqlite3_free()] is used to free idxPtr if and only ifº** needToFreeIdxPtr is true.¢**ŸN** ^The orderByConsumed means that output from [xFilter]/[xNext] will occur inŸG** the correct order to satisfy the ORDER BY clause so that no separateº** sorting step is required.¢**ŸF** ^The estimatedCost value is an estimate of the cost of a particularŸK** strategy. A cost of N indicates that the cost of the strategy is similarŸE** to a linear scan of an SQLite table with N rows. A cost of log(N) ŸF** indicates that the expense of the operation is similar to that of aŸJ** binary search on a unique indexed field of an SQLite table with N rows.¢**ŸE** ^The estimatedRows value is an estimate of the number of rows thatŸ$** will be returned by the strategy.¢**ŸK** The xBestIndex method may optionally populate the idxFlags field with a ŸM** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -ŸL** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLiteŸ8** assumes that the strategy may visit at most one row. ¢**ŸK** Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, thenŸH** SQLite also assumes that if a call to the xUpdate() method is made asŸM** part of the same statement to delete or update a virtual table row and theŸN** implementation returns SQLITE_CONSTRAINT, then there is no need to rollbackŸA** any database changes. In other words, if the xUpdate() returnsŸH** SQLITE_CONSTRAINT, the database contents must be exactly as they wereŸM** before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is notŸJ** set and xUpdate returns SQLITE_CONSTRAINT, any database changes made byŸ>** the xUpdate method are automatically rolled back by SQLite.¢**ŸI** IMPORTANT: The estimatedRows field was added to the sqlite3_index_infoŸ:** structure for SQLite [version 3.8.2] ([dateof:3.8.2]). Ÿ"** If a virtual table extension isŸM** used with an SQLite version earlier than 3.8.2, the results of attempting ŸJ** to read or write the estimatedRows field are undefined (but are likely ŸH** to included crashing the application). The estimatedRows field shouldŸD** therefore only be used if [sqlite3_libversion_number()] returns aŸH** value greater than or equal to 3008002. Similarly, the idxFlags fieldŸ3** was added for [version 3.9.0] ([dateof:3.9.0]). Ÿ#** It may therefore only be used ifŸG** sqlite3_libversion_number() returns a value greater than or equal to´** 3009000.¢*/ªstruct sqlite3_index_info {Æ  /* Inputs */ŸC  int nConstraint;           /* Number of entries in aConstraint */Ÿ#  struct sqlite3_index_constraint {ŸF     int iColumn;              /* Column constrained.  -1 for ROWID */Ÿ8     unsigned char op;         /* Constraint operator */ŸF     unsigned char usable;     /* True if this constraint is usable */ŸO     int iTermOffset;          /* Used internally - xBestIndex should ignore */ŸD  } *aConstraint;            /* Table of WHERE clause constraints */ŸI  int nOrderBy;              /* Number of terms in the ORDER BY clause */Ÿ   struct sqlite3_index_orderby {Ÿ2     int iColumn;              /* Column number */ŸC     unsigned char desc;       /* True for DESC.  False for ASC. */Ÿ6  } *aOrderBy;               /* The ORDER BY clause */Ø  /* Outputs */Ÿ)  struct sqlite3_index_constraint_usage {ŸO    int argvIndex;           /* if >0, constraint is part of argv to xFilter */ŸI    unsigned char omit;      /* Do not code a test for this constraint */∂  } *aConstraintUsage;ŸD  int idxNum;                /* Number used to identify the index */ŸP  char *idxStr;              /* String, possibly obtained from sqlite3_malloc */ŸK  int needToFreeIdxStr;      /* Free idxStr using sqlite3_free() if true */ŸD  int orderByConsumed;       /* True if output is already ordered */ŸJ  double estimatedCost;           /* Estimated cost of using this index */ŸA  /* Fields below are only available in SQLite 3.8.2 and later */ŸI  sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */ŸA  /* Fields below are only available in SQLite 3.9.0 and later */ŸD  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */ŸB  /* Fields below are only available in SQLite 3.10.0 and later */ŸK  sqlite3_uint64 colUsed;    /* Input: Mask of columns used by statement */¢};†¢/*Ÿ%** CAPI3REF: Virtual Table Scan Flags¢*/ŸK#define SQLITE_INDEX_SCAN_UNIQUE      1     /* Scan visits at most 1 row */†¢/*Ÿ4** CAPI3REF: Virtual Table Constraint Operator Codes¢**Ÿ2** These macros defined the allowed values for theŸF** [sqlite3_index_info].aConstraint[].op field.  Each value representsŸG** an operator that is part of a constraint term in the wHERE clause ofŸ'** a query that uses a [virtual table].¢*/Ÿ,#define SQLITE_INDEX_CONSTRAINT_EQ         2Ÿ,#define SQLITE_INDEX_CONSTRAINT_GT         4Ÿ,#define SQLITE_INDEX_CONSTRAINT_LE         8Ÿ,#define SQLITE_INDEX_CONSTRAINT_LT        16Ÿ,#define SQLITE_INDEX_CONSTRAINT_GE        32Ÿ,#define SQLITE_INDEX_CONSTRAINT_MATCH     64Ÿ,#define SQLITE_INDEX_CONSTRAINT_LIKE      65Ÿ,#define SQLITE_INDEX_CONSTRAINT_GLOB      66Ÿ,#define SQLITE_INDEX_CONSTRAINT_REGEXP    67Ÿ,#define SQLITE_INDEX_CONSTRAINT_NE        68Ÿ,#define SQLITE_INDEX_CONSTRAINT_ISNOT     69Ÿ,#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70Ÿ,#define SQLITE_INDEX_CONSTRAINT_ISNULL    71Ÿ,#define SQLITE_INDEX_CONSTRAINT_IS        72†¢/*Ÿ4** CAPI3REF: Register A Virtual Table Implementation≤** METHOD: sqlite3¢**ŸJ** ^These routines are used to register a new [virtual table module] name.Ÿ*** ^Module names must be registered beforeŸE** creating a new [virtual table] using the module and before using aŸ.** preexisting [virtual table] for the module.¢**ŸH** ^The module name is registered on the [database connection] specifiedŸD** by the first parameter.  ^The name of the module is given by the Ÿ:** second parameter.  ^The third parameter is a pointer toŸB** the implementation of the [virtual table module].   ^The fourthŸG** parameter is an arbitrary client data pointer that is passed throughŸH** into the [xCreate] and [xConnect] methods of the virtual table moduleŸA** when a new virtual table is be being created or reinitialized.¢**ŸH** ^The sqlite3_create_module_v2() interface has a fifth parameter whichŸB** is a pointer to a destructor for the pClientData.  ^SQLite willŸA** invoke the destructor function (if it is not NULL) when SQLiteŸF** no longer needs the pClientData pointer.  ^The destructor will alsoŸ>** be invoked if the call to sqlite3_create_module_v2() fails.ø** ^The sqlite3_create_module()ŸD** interface is equivalent to sqlite3_create_module_v2() with a NULLÆ** destructor.¢*/Ÿ%SQLITE_API int sqlite3_create_module(ŸL  sqlite3 *db,               /* SQLite connection to register module with */Ÿ5  const char *zName,         /* Name of the module */Ÿ9  const sqlite3_module *p,   /* Methods for the module */ŸC  void *pClientData          /* Client data for xCreate/xConnect */¢);Ÿ(SQLITE_API int sqlite3_create_module_v2(ŸL  sqlite3 *db,               /* SQLite connection to register module with */Ÿ5  const char *zName,         /* Name of the module */Ÿ9  const sqlite3_module *p,   /* Methods for the module */ŸC  void *pClientData,         /* Client data for xCreate/xConnect */Ÿ=  void(*xDestroy)(void*)     /* Module destructor function */¢);†¢/*Ÿ*** CAPI3REF: Virtual Table Instance Objectπ** KEYWORDS: sqlite3_vtab¢**Ÿ>** Every [virtual table module] implementation uses a subclassŸ3** of this object to describe a particular instanceŸ.** of the [virtual table].  Each subclass willŸB** be tailored to the specific needs of the module implementation.ŸF** The purpose of this superclass is to define certain fields that areŸ(** common to all module implementations.¢**ŸB** ^Virtual tables methods can set an error message by assigning aŸJ** string obtained from [sqlite3_mprintf()] to zErrMsg.  The method shouldŸI** take care that any prior string is freed by a call to [sqlite3_free()]ŸH** prior to assigning a new string to zErrMsg.  ^After the error messageŸN** is delivered up to the client application, the string will be automaticallyŸ@** freed by sqlite3_free() and the zErrMsg field will be zeroed.¢*/µstruct sqlite3_vtab {ŸI  const sqlite3_module *pModule;  /* The module for this virtual table */Ÿ>  int nRef;                       /* Number of open cursors */ŸL  char *zErrMsg;                  /* Error message from sqlite3_mprintf() */ŸJ  /* Virtual table implementations will typically add additional fields */¢};†¢/*Ÿ(** CAPI3REF: Virtual Table Cursor ObjectŸ7** KEYWORDS: sqlite3_vtab_cursor {virtual table cursor}¢**ŸE** Every [virtual table module] implementation uses a subclass of theŸ>** following structure to describe cursors that point into theø** [virtual table] and are usedŸD** to loop through the virtual table.  Cursors are created using theŸH** [sqlite3_module.xOpen | xOpen] method of the module and are destroyedŸD** by the [sqlite3_module.xClose | xClose] method.  Cursors are usedŸE** by the [xFilter], [xNext], [xEof], [xColumn], and [xRowid] methodsŸ9** of the module.  Each module implementation will defineŸ;** the content of a cursor structure to suit its own needs.¢**ŸF** This superclass exists in order to define fields of the cursor thatŸ%** are common to all implementations.¢*/ºstruct sqlite3_vtab_cursor {Ÿ>  sqlite3_vtab *pVtab;      /* Virtual table of this cursor */ŸJ  /* Virtual table implementations will typically add additional fields */¢};†¢/*Ÿ2** CAPI3REF: Declare The Schema Of A Virtual Table¢**Ÿ-** ^The [xCreate] and [xConnect] methods of aŸ-** [virtual table module] call this interfaceŸD** to declare the format (the names and datatypes of the columns) ofŸ%** the virtual tables they implement.¢*/Ÿ@SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);†¢/*Ÿ4** CAPI3REF: Overload A Function For A Virtual Table≤** METHOD: sqlite3¢**ŸH** ^(Virtual tables can provide alternative implementations of functionsŸD** using the [xFindFunction] method of the [virtual table module].  Ÿ)** But global versions of those functionsŸ*** must exist in order to be overloaded.)^¢**ŸI** ^(This API makes sure a global version of a function with a particularŸD** name and number of parameters exists.  If no such function existsŸO** before this API is called, a new function is created.)^  ^The implementationŸC** of the new function always causes an exception to be thrown.  SoŸA** the new function is not good for anything by itself.  Its onlyŸA** purpose is to be a placeholder function that can be overloaded∏** by a [virtual table].¢*/ŸTSQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);†¢/*ŸF** The interface to the virtual-table mechanism defined above (back upŸG** to a comment remarkably similar to this one) is currently consideredŸH** to be experimental.  The interface might change in incompatible ways.ŸG** If this is a problem for you, do not use the interface at this time.¢**ŸC** When the virtual-table mechanism stabilizes, we will declare theŸE** interface fixed, support it indefinitely, and remove this comment.¢*/†¢/*Ÿ%** CAPI3REF: A Handle To An Open BLOBŸ)** KEYWORDS: {BLOB handle} {BLOB handles}¢**Ÿ>** An instance of this object represents an open BLOB on whichŸ?** [sqlite3_blob_open | incremental BLOB I/O] can be performed.Ÿ=** ^Objects of this type are created by [sqlite3_blob_open()]Ÿ+** and destroyed by [sqlite3_blob_close()].ŸC** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfacesŸ>** can be used to read or write small subsections of the BLOB.ŸO** ^The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.¢*/Ÿ)typedef struct sqlite3_blob sqlite3_blob;†¢/*Ÿ,** CAPI3REF: Open A BLOB For Incremental I/O≤** METHOD: sqlite3º** CONSTRUCTOR: sqlite3_blob¢**ŸG** ^(This interfaces opens a [BLOB handle | handle] to the BLOB locatedŸ=** in row iRow, column zColumn, table zTable in database zDb;Ÿ;** in other words, the same BLOB that would be selected by:¢**®** <pre>Ÿ;**     SELECT zColumn FROM zDb.zTable WHERE [rowid] = iRow;´** </pre>)^¢**ŸG** ^(Parameter zDb is not the filename that contains the database, but ŸL** rather the symbolic name of the database. For attached databases, this isŸH** the name that appears after the AS keyword in the [ATTACH] statement.ŸD** For the main database file, the database name is "main". For TEMPŸ)** tables, the database name is "temp".)^¢**ŸH** ^If the flags parameter is non-zero, then the BLOB is opened for readŸL** and write access. ^If the flags parameter is zero, the BLOB is opened for¥** read-only access.¢**ŸL** ^(On success, [SQLITE_OK] is returned and the new [BLOB handle] is storedŸJ** in *ppBlob. Otherwise an [error code] is returned and, unless the errorŸN** code is SQLITE_MISUSE, *ppBlob is set to NULL.)^ ^This means that, providedŸL** the API is not misused, it is always safe to call [sqlite3_blob_close()] Ÿ-** on *ppBlob after this function it returns.¢**ŸJ** This function fails with SQLITE_ERROR if any of the following are true:ß** <ul>Ÿ+**   <li> ^(Database zDb does not exist)^, Ÿ?**   <li> ^(Table zTable does not exist within database zDb)^, Ÿ5**   <li> ^(Table zTable is a WITHOUT ROWID table)^, Ÿ,**   <li> ^(Column zColumn does not exist)^,Ÿ3**   <li> ^(Row iRow is not present in the table)^,ŸI**   <li> ^(The specified column of row iRow contains a value that is notŸ"**         a TEXT or BLOB value)^,ŸF**   <li> ^(Column zColumn is part of an index, PRIMARY KEY or UNIQUE ŸK**         constraint and the blob is being opened for read/write access)^,ŸM**   <li> ^([foreign key constraints | Foreign key constraints] are enabled, ŸM**         column zColumn is part of a [child key] definition and the blob isŸ0**         being opened for read/write access)^.®** </ul>¢**Ÿ<** ^Unless it returns SQLITE_MISUSE, this function sets the Ÿ?** [database connection] error code and message accessible via ŸE** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions. ¢**ŸA** A BLOB referenced by sqlite3_blob_open() may be read using theŸ8** [sqlite3_blob_read()] interface and modified by usingŸ?** [sqlite3_blob_write()].  The [BLOB handle] can be moved to aŸD** different row of the same table using the [sqlite3_blob_reopen()]ŸI** interface.  However, the column, table, or database of a [BLOB handle]Ÿ7** cannot be changed after the [BLOB handle] is opened.¢**Ÿ>** ^(If the row that a BLOB handle points to is modified by anŸ7** [UPDATE], [DELETE], or by [ON CONFLICT] side-effectsŸ/** then the BLOB handle is marked as "expired".ŸB** This is true if any column of the row is changed, even a columnŸ3** other than the one the BLOB handle is open on.)^ŸA** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] forŸD** an expired BLOB handle fail with a return code of [SQLITE_ABORT].ŸC** ^(Changes written into a BLOB prior to the BLOB expiring are notŸK** rolled back by the expiration of the BLOB.  Such changes will eventuallyŸ7** commit if the transaction continues to completion.)^¢**ŸE** ^Use the [sqlite3_blob_bytes()] interface to determine the size ofŸC** the opened blob.  ^The size of a blob may not be changed by thisŸC** interface.  Use the [UPDATE] SQL command to change the size of a®** blob.¢**ŸL** ^The [sqlite3_bind_zeroblob()] and [sqlite3_result_zeroblob()] interfacesŸD** and the built-in [zeroblob] SQL function may be used to create a ŸJ** zero-filled blob to read or write using the incremental-blob interface.¢**ŸG** To avoid a resource leak, every open [BLOB handle] should eventuallyŸ3** be released by a call to [sqlite3_blob_close()].¢**Ÿ$** See also: [sqlite3_blob_close()],Ÿ2** [sqlite3_blob_reopen()], [sqlite3_blob_read()],Ÿ2** [sqlite3_blob_bytes()], [sqlite3_blob_write()].¢*/Ÿ!SQLITE_API int sqlite3_blob_open(´  sqlite3*,≤  const char *zDb,µ  const char *zTable,∂  const char *zColumn,µ  sqlite3_int64 iRow,¨  int flags,∑  sqlite3_blob **ppBlob¢);†¢/*Ÿ,** CAPI3REF: Move a BLOB Handle to a New Row∑** METHOD: sqlite3_blob¢**ŸM** ^This function is used to move an existing [BLOB handle] so that it pointsŸL** to a different row of the same database table. ^The new row is identifiedŸH** by the rowid value passed as the second argument. Only the row can beŸL** changed. ^The database, table and column on which the blob handle is openŸD** remain the same. Moving an existing [BLOB handle] to a new row isŸA** faster than closing the existing handle and opening a new one.¢**ŸK** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -ŸH** it must exist and there must be either a blob or text value stored inŸM** the nominated column.)^ ^If the new row is not present in the table, or ifŸK** it does not contain a blob or text value, or if another error occurs, anŸK** SQLite error code is returned and the blob handle is considered aborted.ŸL** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] orŸG** [sqlite3_blob_reopen()] on an aborted blob handle immediately returnŸJ** SQLITE_ABORT. ^Calling [sqlite3_blob_bytes()] on an aborted blob handle∑** always returns zero.¢**ŸB** ^This function sets the database handle error code and message.¢*/ŸBSQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);†¢/*Ÿ ** CAPI3REF: Close A BLOB Handleª** DESTRUCTOR: sqlite3_blob¢**ŸK** ^This function closes an open [BLOB handle]. ^(The BLOB handle is closedŸE** unconditionally.  Even if this routine returns an error code, the º** handle is still closed.)^¢**ŸL** ^If the blob handle being closed was opened for read-write access, and ifŸM** the database is in auto-commit mode and there are no other open read-writeŸF** blob handles or active write statements, the current transaction isŸL** committed. ^If an error occurs while committing the transaction, an errorŸ4** code is returned and the transaction rolled back.¢**ŸJ** Calling this function with an argument that is not a NULL pointer or anŸJ** open blob handle results in undefined behaviour. ^Calling this routine ŸF** with a null pointer (such as would be returned by a failed call to ŸK** [sqlite3_blob_open()]) is a harmless no-op. ^Otherwise, if this functionŸB** is passed a valid open blob handle, the values returned by the ŸM** sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.¢*/Ÿ2SQLITE_API int sqlite3_blob_close(sqlite3_blob *);†¢/*Ÿ,** CAPI3REF: Return The Size Of An Open BLOB∑** METHOD: sqlite3_blob¢**Ÿ=** ^Returns the size in bytes of the BLOB accessible via the Ÿ@** successfully opened [BLOB handle] in its only argument.  ^TheŸF** incremental blob I/O routines can only read or overwriting existingŸ7** blob content; they cannot change the size of a blob.¢**ŸD** This routine only works on a [BLOB handle] which has been createdŸH** by a prior successful call to [sqlite3_blob_open()] and which has notŸG** been closed by [sqlite3_blob_close()].  Passing any other pointer inŸJ** to this routine results in undefined and probably undesirable behavior.¢*/Ÿ2SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);†¢/*Ÿ0** CAPI3REF: Read Data From A BLOB Incrementally∑** METHOD: sqlite3_blob¢**ŸI** ^(This function is used to read data from an open [BLOB handle] into aŸC** caller-supplied buffer. N bytes of data are copied into buffer ZŸ4** from the open BLOB, starting at offset iOffset.)^¢**ŸD** ^If offset iOffset is less than N bytes from the end of the BLOB,ŸG** [SQLITE_ERROR] is returned and no data is read.  ^If N or iOffset isŸB** less than zero, [SQLITE_ERROR] is returned and no data is read.ŸC** ^The size of the blob (and hence the maximum value of N+iOffset)Ÿ@** can be determined using the [sqlite3_blob_bytes()] interface.¢**ŸB** ^An attempt to read from an expired [BLOB handle] fails with anŸ ** error code of [SQLITE_ABORT].¢**Ÿ7** ^(On success, sqlite3_blob_read() returns SQLITE_OK.ŸH** Otherwise, an [error code] or an [extended error code] is returned.)^¢**ŸD** This routine only works on a [BLOB handle] which has been createdŸH** by a prior successful call to [sqlite3_blob_open()] and which has notŸG** been closed by [sqlite3_blob_close()].  Passing any other pointer inŸJ** to this routine results in undefined and probably undesirable behavior.¢**Ÿ$** See also: [sqlite3_blob_write()].¢*/ŸNSQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);†¢/*Ÿ1** CAPI3REF: Write Data Into A BLOB Incrementally∑** METHOD: sqlite3_blob¢**ŸJ** ^(This function is used to write data into an open [BLOB handle] from aŸG** caller-supplied buffer. N bytes of data are copied from the buffer ZŸ4** into the open BLOB, starting at offset iOffset.)^¢**Ÿ8** ^(On success, sqlite3_blob_write() returns SQLITE_OK.ŸI** Otherwise, an  [error code] or an [extended error code] is returned.)^Ÿ=** ^Unless SQLITE_MISUSE is returned, this function sets the Ÿ?** [database connection] error code and message accessible via ŸE** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions. ¢**ŸH** ^If the [BLOB handle] passed as the first argument was not opened forŸC** writing (the flags parameter to [sqlite3_blob_open()] was zero),Ÿ+** this function returns [SQLITE_READONLY].¢**Ÿ@** This function may only modify the contents of the BLOB; it isŸ>** not possible to increase the size of a BLOB using this API.ŸD** ^If offset iOffset is less than N bytes from the end of the BLOB,ŸF** [SQLITE_ERROR] is returned and no data is written. The size of the ŸE** BLOB (and hence the maximum value of N+iOffset) can be determined ŸI** using the [sqlite3_blob_bytes()] interface. ^If N or iOffset are less Ÿ?** than zero [SQLITE_ERROR] is returned and no data is written.¢**ŸA** ^An attempt to write to an expired [BLOB handle] fails with anŸC** error code of [SQLITE_ABORT].  ^Writes to the BLOB that occurredŸ>** before the [BLOB handle] expired are not rolled back by theŸA** expiration of the handle, though of course those changes mightŸF** have been overwritten by the statement that expired the BLOB handleŸ&** or by other independent statements.¢**ŸD** This routine only works on a [BLOB handle] which has been createdŸH** by a prior successful call to [sqlite3_blob_open()] and which has notŸG** been closed by [sqlite3_blob_close()].  Passing any other pointer inŸJ** to this routine results in undefined and probably undesirable behavior.¢**Ÿ#** See also: [sqlite3_blob_read()].¢*/ŸUSQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);†¢/*Ÿ(** CAPI3REF: Virtual File System Objects¢**Ÿ8** A virtual filesystem (VFS) is an [sqlite3_vfs] objectø** that SQLite uses to interactŸH** with the underlying operating system.  Most SQLite builds come with aŸ@** single default VFS that is appropriate for the host computer.ŸF** New VFSes can be registered and existing VFSes can be unregistered.Ÿ)** The following interfaces are provided.¢**ŸO** ^The sqlite3_vfs_find() interface returns a pointer to a VFS given its name.Ω** ^Names are case sensitive.Ÿ,** ^Names are zero-terminated UTF-8 strings.Ÿ5** ^If there is no match, a NULL pointer is returned.Ÿ9** ^If zVfsName is NULL then the default VFS is returned.¢**Ÿ9** ^New VFSes are registered with sqlite3_vfs_register().ŸE** ^Each new VFS becomes the default VFS if the makeDflt flag is set.ŸA** ^The same VFS can be registered multiple times without injury.ŸC** ^To make an existing VFS into the default VFS, register it againŸ?** with the makeDflt flag set.  If two different VFSes with theŸ=** same name are registered, the behavior is undefined.  If aŸA** VFS is registered with a name that is NULL or an empty string,Ÿ"** then the behavior is undefined.¢**ŸA** ^Unregister a VFS with the sqlite3_vfs_unregister() interface.ŸA** ^(If the default VFS is unregistered, another VFS is chosen asŸ;** the default.  The choice for the new VFS is arbitrary.)^¢*/Ÿ?SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);Ÿ@SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);Ÿ4SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);†¢/*¥** CAPI3REF: Mutexes¢**Ÿ1** The SQLite core uses these routines for threadŸ9** synchronization. Though they are intended for internalŸ3** use by SQLite, code that links against SQLite isŸ*** permitted to use any of these routines.¢**Ÿ;** The SQLite source code contains multiple implementationsŸ:** of these mutex routines.  An appropriate implementationŸ<** is selected automatically at compile-time.  The followingŸ4** implementations are available in the SQLite core:¢**ß** <ul>ø** <li>   SQLITE_MUTEX_PTHREADS∫** <li>   SQLITE_MUTEX_W32ª** <li>   SQLITE_MUTEX_NOOP®** </ul>¢**Ÿ<** The SQLITE_MUTEX_NOOP implementation is a set of routinesŸ:** that does no real locking and is appropriate for use inŸ@** a single-threaded application.  The SQLITE_MUTEX_PTHREADS andŸC** SQLITE_MUTEX_W32 implementations are appropriate for use on UnixØ** and Windows.¢**ŸB** If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessorŸ@** macro defined (with "-DSQLITE_MUTEX_APPDEF=1"), then no mutexŸ@** implementation is included with the library. In this case theŸB** application must supply a custom mutex implementation using theŸ@** [SQLITE_CONFIG_MUTEX] option of the sqlite3_config() functionŸC** before calling sqlite3_initialize() or any other public sqlite3_Ÿ,** function that calls sqlite3_initialize().¢**Ÿ5** ^The sqlite3_mutex_alloc() routine allocates a newŸ@** mutex and returns a pointer to it. ^The sqlite3_mutex_alloc()ŸA** routine returns NULL if it is unable to allocate the requestedŸB** mutex.  The argument to sqlite3_mutex_alloc() must one of theseµ** integer constants:¢**ß** <ul>∫** <li>  SQLITE_MUTEX_FASTø** <li>  SQLITE_MUTEX_RECURSIVEŸ#** <li>  SQLITE_MUTEX_STATIC_MASTERŸ ** <li>  SQLITE_MUTEX_STATIC_MEMŸ!** <li>  SQLITE_MUTEX_STATIC_OPENŸ!** <li>  SQLITE_MUTEX_STATIC_PRNGŸ ** <li>  SQLITE_MUTEX_STATIC_LRUŸ!** <li>  SQLITE_MUTEX_STATIC_PMEMŸ!** <li>  SQLITE_MUTEX_STATIC_APP1Ÿ!** <li>  SQLITE_MUTEX_STATIC_APP2Ÿ!** <li>  SQLITE_MUTEX_STATIC_APP3Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS1Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS2Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS3®** </ul>¢**ŸJ** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)Ÿ(** cause sqlite3_mutex_alloc() to createŸH** a new mutex.  ^The new mutex is recursive when SQLITE_MUTEX_RECURSIVEŸA** is used but not necessarily so when SQLITE_MUTEX_FAST is used.Ÿ?** The mutex implementation does not need to make a distinctionŸB** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it doesŸ>** not want to.  SQLite will only request a recursive mutex inŸD** cases where it really needs one.  If a faster non-recursive mutexŸH** implementation is available on the host platform, the mutex subsystemŸ>** might return such a mutex in response to SQLITE_MUTEX_FAST.¢**ŸI** ^The other allowed parameters to sqlite3_mutex_alloc() (anything otherŸA** than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each returnŸE** a pointer to a static preexisting mutex.  ^Nine static mutexes areŸD** used by the current version of SQLite.  Future versions of SQLiteŸF** may add additional static mutexes.  Static mutexes are for internalŸC** use by SQLite only.  Applications that use SQLite mutexes shouldŸ@** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or∫** SQLITE_MUTEX_RECURSIVE.¢**ŸG** ^Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FASTŸ@** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()Ÿ<** returns a different mutex on every call.  ^For the staticŸA** mutex types, the same mutex is returned on every call that has∏** the same type number.¢**Ÿ=** ^The sqlite3_mutex_free() routine deallocates a previouslyŸ>** allocated dynamic mutex.  Attempting to deallocate a staticŸ'** mutex results in undefined behavior.¢**ŸF** ^The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptŸE** to enter a mutex.  ^If another thread is already within the mutex,ŸG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnŸG** SQLITE_BUSY.  ^The sqlite3_mutex_try() interface returns [SQLITE_OK]Ÿ2** upon successful entry.  ^(Mutexes created usingŸK** SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread.µ** In such cases, theŸF** mutex must be exited an equal number of times before another threadŸB** can enter.)^  If the same thread tries to enter any mutex otherŸL** than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.¢**ŸH** ^(Some systems (for example, Windows 95) do not support the operationŸM** implemented by sqlite3_mutex_try().  On those systems, sqlite3_mutex_try()ŸA** will always return SQLITE_BUSY. The SQLite core only ever usesŸ@** sqlite3_mutex_try() as an optimization so this is acceptable Æ** behavior.)^¢**Ÿ<** ^The sqlite3_mutex_leave() routine exits a mutex that wasŸ8** previously entered by the same thread.   The behaviorŸ<** is undefined if the mutex is not currently entered by theŸ0** calling thread or is not currently allocated.¢**ŸE** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), orŸC** sqlite3_mutex_leave() is a NULL pointer, then all three routines¥** behave as no-ops.¢**ŸB** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].¢*/Ÿ3SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);Ÿ3SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);Ÿ4SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);Ÿ1SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);Ÿ4SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);†¢/*Ÿ!** CAPI3REF: Mutex Methods Object¢**Ÿ?** An instance of this structure defines the low-level routinesŸ$** used to allocate and use mutexes.¢**ŸD** Usually, the default mutex implementations provided by SQLite areŸN** sufficient, however the application has the option of substituting a customŸI** implementation for specialized deployments or systems for which SQLiteŸL** does not provide a suitable implementation. In this case, the applicationŸ>** creates and populates an instance of this structure to passŸC** to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.Ÿ@** Additionally, an instance of this structure can be used as anŸA** output variable when querying the system for the current mutexŸ=** implementation, using the [SQLITE_CONFIG_GETMUTEX] option.¢**ŸA** ^The xMutexInit method defined by this structure is invoked asŸF** part of system initialization by the sqlite3_initialize() function.ŸD** ^The xMutexInit routine is called by SQLite exactly once for eachŸ,** effective call to [sqlite3_initialize()].¢**Ÿ@** ^The xMutexEnd method defined by this structure is invoked asŸB** part of system shutdown by the sqlite3_shutdown() function. TheŸG** implementation of this method is expected to release all outstandingŸE** resources obtained by the mutex methods implementation, especiallyŸ=** those obtained by the xMutexInit method.  ^The xMutexEnd()ŸK** interface is invoked exactly once for each call to [sqlite3_shutdown()].¢**ŸH** ^(The remaining seven methods defined by this structure (xMutexAlloc,ŸB** xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld andŸD** xMutexNotheld) implement the following interfaces (respectively):¢**ß** <ul>Ÿ(**   <li>  [sqlite3_mutex_alloc()] </li>Ÿ'**   <li>  [sqlite3_mutex_free()] </li>Ÿ(**   <li>  [sqlite3_mutex_enter()] </li>Ÿ&**   <li>  [sqlite3_mutex_try()] </li>Ÿ(**   <li>  [sqlite3_mutex_leave()] </li>Ÿ'**   <li>  [sqlite3_mutex_held()] </li>Ÿ***   <li>  [sqlite3_mutex_notheld()] </li>™** </ul>)^¢**ŸJ** The only difference is that the public sqlite3_XXX functions enumeratedŸI** above silently ignore any invocations that pass a NULL pointer insteadŸF** of a valid mutex handle. The implementations of the methods definedŸF** by this structure are not required to handle this case, the resultsŸJ** of passing a NULL pointer instead of a valid mutex handle are undefinedŸH** (i.e. it is acceptable to provide an implementation that segfaults ifŸ ** it is passed a NULL pointer).¢**ŸF** The xMutexInit() method must be threadsafe.  It must be harmless toŸI** invoke xMutexInit() multiple times within the same process and withoutŸD** intervening calls to xMutexEnd().  Second and subsequent calls toø** xMutexInit() must be no-ops.¢**ŸI** xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]ŸL** and its associates).  Similarly, xMutexAlloc() must not use SQLite memoryŸH** allocation for a static mutex.  ^However xMutexAlloc() may use SQLiteŸ3** memory allocation for a fast or recursive mutex.¢**ŸJ** ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] isŸG** called, but only if the prior call to xMutexInit returned SQLITE_OK.ŸJ** If xMutexInit fails in any way, it is expected to clean up after itself∂** prior to returning.¢*/Ÿ;typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;æstruct sqlite3_mutex_methods {∫  int (*xMutexInit)(void);π  int (*xMutexEnd)(void);Ÿ%  sqlite3_mutex *(*xMutexAlloc)(int);Ÿ&  void (*xMutexFree)(sqlite3_mutex *);Ÿ'  void (*xMutexEnter)(sqlite3_mutex *);Ÿ$  int (*xMutexTry)(sqlite3_mutex *);Ÿ'  void (*xMutexLeave)(sqlite3_mutex *);Ÿ%  int (*xMutexHeld)(sqlite3_mutex *);Ÿ(  int (*xMutexNotheld)(sqlite3_mutex *);¢};†¢/*Ÿ(** CAPI3REF: Mutex Verification Routines¢**Ÿ@** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routinesŸD** are intended for use inside assert() statements.  The SQLite coreŸG** never uses these routines except inside an assert() and applicationsŸD** are advised to follow the lead of the core.  The SQLite core onlyŸB** provides implementations for these routines when it is compiledŸ>** with the SQLITE_DEBUG flag.  External mutex implementationsŸA** are only required to provide these routines if SQLITE_DEBUG isŸ(** defined and if NDEBUG is not defined.¢**ŸC** These routines should return true if the mutex in their argumentŸ<** is held or not held, respectively, by the calling thread.¢**ŸB** The implementation is not required to provide versions of theseŸN** routines that actually work. If the implementation does not provide workingŸK** versions of these routines, it should at least provide stubs that alwaysŸD** return true so that one does not get spurious assertion failures.¢**ŸA** If the argument to sqlite3_mutex_held() is a NULL pointer thenŸD** the routine should return 1.   This seems counter-intuitive sinceŸ>** clearly the mutex cannot be held if it does not exist.  ButŸB** the reason the mutex does not exist is because the build is notŸA** using mutexes.  And we do not want the assert() containing theŸ@** call to sqlite3_mutex_held() to fail, so a non-zero return isŸ<** the appropriate thing to do.  The sqlite3_mutex_notheld()Ÿ<** interface should also return 1 when given a NULL pointer.¢*/Æ#ifndef NDEBUGŸ2SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);Ÿ5SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);¶#endif†¢/*∏** CAPI3REF: Mutex Types¢**Ÿ@** The [sqlite3_mutex_alloc()] interface takes a single argumentŸ+** which is one of these integer constants.¢**ŸF** The set of static mutexes may change from one SQLite release to theŸE** next.  Applications that override the built-in mutex logic must beŸ5** prepared to accommodate additional static mutexes.¢*/Ÿ'#define SQLITE_MUTEX_FAST             0Ÿ'#define SQLITE_MUTEX_RECURSIVE        1Ÿ'#define SQLITE_MUTEX_STATIC_MASTER    2Ÿ?#define SQLITE_MUTEX_STATIC_MEM       3  /* sqlite3_malloc() */Ÿ7#define SQLITE_MUTEX_STATIC_MEM2      4  /* NOT USED */ŸA#define SQLITE_MUTEX_STATIC_OPEN      4  /* sqlite3BtreeOpen() */ŸC#define SQLITE_MUTEX_STATIC_PRNG      5  /* sqlite3_randomness() */Ÿ<#define SQLITE_MUTEX_STATIC_LRU       6  /* lru page list */Ÿ7#define SQLITE_MUTEX_STATIC_LRU2      7  /* NOT USED */ŸB#define SQLITE_MUTEX_STATIC_PMEM      7  /* sqlite3PageMalloc() */ŸE#define SQLITE_MUTEX_STATIC_APP1      8  /* For use by application */ŸE#define SQLITE_MUTEX_STATIC_APP2      9  /* For use by application */ŸE#define SQLITE_MUTEX_STATIC_APP3     10  /* For use by application */ŸF#define SQLITE_MUTEX_STATIC_VFS1     11  /* For use by built-in VFS */ŸG#define SQLITE_MUTEX_STATIC_VFS2     12  /* For use by extension VFS */ŸI#define SQLITE_MUTEX_STATIC_VFS3     13  /* For use by application VFS */†¢/*Ÿ9** CAPI3REF: Retrieve the mutex for a database connection≤** METHOD: sqlite3¢**ŸE** ^This interface returns a pointer the [sqlite3_mutex] object that ŸG** serializes access to the [database connection] given in the argumentŸ+** when the [threading mode] is Serialized.ŸF** ^If the [threading mode] is Single-thread or Multi-thread then thisŸ"** routine returns a NULL pointer.¢*/Ÿ5SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);†¢/*Ÿ0** CAPI3REF: Low-Level Control Of Database Files≤** METHOD: sqlite3¢**ŸE** ^The [sqlite3_file_control()] interface makes a direct call to theŸE** xFileControl method for the [sqlite3_io_methods] object associatedŸE** with a particular database identified by the second argument. ^TheŸI** name of the database is "main" for the main database or "temp" for theŸC** TEMP database, or the name that appears after the AS keyword forŸ;** databases that are added using the [ATTACH] SQL command.ŸA** ^A NULL pointer can be used in place of "main" to refer to the∂** main database file.Ÿ3** ^The third and fourth parameters to this routineŸD** are passed directly through to the second and third parameters ofŸB** the xFileControl method.  ^The return value of the xFileControlŸ3** method becomes the return value of this routine.¢**ŸE** ^The [SQLITE_FCNTL_FILE_POINTER] value for the op parameter causesŸG** a pointer to the underlying [sqlite3_file] object to be written intoŸO** the space pointed to by the 4th parameter.  ^The [SQLITE_FCNTL_FILE_POINTER]ŸB** case is a short-circuit path which does not actually invoke theŸ5** underlying sqlite3_io_methods.xFileControl method.¢**ŸD** ^If the second parameter (zDbName) does not match the name of anyŸB** open database file, then SQLITE_ERROR is returned.  ^This errorŸI** code is not remembered and will not be recalled by [sqlite3_errcode()]ŸC** or [sqlite3_errmsg()].  The underlying xFileControl method mightŸD** also return SQLITE_ERROR.  There is no way to distinguish betweenŸF** an incorrect zDbName and an SQLITE_ERROR return from the underlying∑** xFileControl method.¢**Ÿ#** See also: [file control opcodes]¢*/ŸRSQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);†¢/*æ** CAPI3REF: Testing Interface¢**ŸE** ^The sqlite3_test_control() interface is used to read out internalŸ?** state of SQLite and to inject faults into SQLite for testingŸG** purposes.  ^The first parameter is an operation code that determinesŸC** the number, meaning, and operation of all subsequent parameters.¢**ŸC** This interface is not for use by applications.  It exists solelyŸH** for verifying the correct operation of the SQLite library.  DependingŸI** on how the SQLite library is compiled, this interface might not exist.¢**ŸE** The details of the operation codes, their meanings, the parametersŸH** they take, and what they do are all subject to change without notice.ŸD** Unlike most of the SQLite API, this function is not guaranteed toŸ5** operate consistently from one release to the next.¢*/Ÿ1SQLITE_API int sqlite3_test_control(int op, ...);†¢/*Ÿ.** CAPI3REF: Testing Interface Operation Codes¢**Ÿ?** These constants are the valid operation code parameters usedŸ5** as the first argument to [sqlite3_test_control()].¢**Ÿ<** These parameters and their meanings are subject to changeŸ?** without notice.  These values are for testing purposes only.Ÿ=** Applications should not use any of these parameters or theŸ&** [sqlite3_test_control()] interface.¢*/Ÿ2#define SQLITE_TESTCTRL_FIRST                    5Ÿ2#define SQLITE_TESTCTRL_PRNG_SAVE                5Ÿ2#define SQLITE_TESTCTRL_PRNG_RESTORE             6Ÿ2#define SQLITE_TESTCTRL_PRNG_RESET               7Ÿ2#define SQLITE_TESTCTRL_BITVEC_TEST              8Ÿ2#define SQLITE_TESTCTRL_FAULT_INSTALL            9Ÿ2#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10Ÿ2#define SQLITE_TESTCTRL_PENDING_BYTE            11Ÿ2#define SQLITE_TESTCTRL_ASSERT                  12Ÿ2#define SQLITE_TESTCTRL_ALWAYS                  13Ÿ2#define SQLITE_TESTCTRL_RESERVE                 14Ÿ2#define SQLITE_TESTCTRL_OPTIMIZATIONS           15Ÿ2#define SQLITE_TESTCTRL_ISKEYWORD               16ŸB#define SQLITE_TESTCTRL_SCRATCHMALLOC           17  /* NOT USED */Ÿ2#define SQLITE_TESTCTRL_LOCALTIME_FAULT         18ŸB#define SQLITE_TESTCTRL_EXPLAIN_STMT            19  /* NOT USED */Ÿ2#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD    19Ÿ2#define SQLITE_TESTCTRL_NEVER_CORRUPT           20Ÿ2#define SQLITE_TESTCTRL_VDBE_COVERAGE           21Ÿ2#define SQLITE_TESTCTRL_BYTEORDER               22Ÿ2#define SQLITE_TESTCTRL_ISINIT                  23Ÿ2#define SQLITE_TESTCTRL_SORTER_MMAP             24Ÿ2#define SQLITE_TESTCTRL_IMPOSTER                25Ÿ2#define SQLITE_TESTCTRL_PARSER_COVERAGE         26ŸJ#define SQLITE_TESTCTRL_LAST                    26  /* Largest TESTCTRL */†¢/*Ÿ"** CAPI3REF: SQLite Runtime Status¢**ŸD** ^These interfaces are used to retrieve runtime status informationŸC** about the performance of SQLite, and optionally to reset variousŸ?** highwater marks.  ^The first argument is an integer code forŸA** the specific parameter to measure.  ^(Recognized integer codesŸ=** are of the form [status parameters | SQLITE_STATUS_...].)^ŸB** ^The current value of the parameter is returned into *pCurrent.ŸC** ^The highest recorded value is returned in *pHighwater.  ^If theŸB** resetFlag is true, then the highest record value is reset afterŸG** *pHighwater is written.  ^(Some parameters do not record the highestø** value.  For those parametersŸF** nothing is written into *pHighwater and the resetFlag is ignored.)^ŸH** ^(Other parameters record only the highwater mark and not the currentŸK** value.  For these latter parameters nothing is written into *pCurrent.)^¢**Ÿ?** ^The sqlite3_status() and sqlite3_status64() routines returnŸ?** SQLITE_OK on success and a non-zero [error code] on failure.¢**ŸD** If either the current value or the highwater mark is too large toŸB** be represented by a 32-bit integer, then the values returned byŸ"** sqlite3_status() are undefined.¢**Ÿ"** See also: [sqlite3_db_status()]¢*/ŸUSQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);Ÿ SQLITE_API int sqlite3_status64(©  int op,∫  sqlite3_int64 *pCurrent,º  sqlite3_int64 *pHighwater,Ø  int resetFlag¢);††¢/*æ** CAPI3REF: Status ParametersŸ ** KEYWORDS: {status parameters}¢**ŸG** These integer constants designate various run-time status parametersŸ.** that can be returned by [sqlite3_status()].¢**ß** <dl>ŸE** [[SQLITE_STATUS_MEMORY_USED]] ^(<dt>SQLITE_STATUS_MEMORY_USED</dt>ŸA** <dd>This parameter is the current amount of memory checked outŸ@** using [sqlite3_malloc()], either directly or indirectly.  TheŸF** figure includes calls made to [sqlite3_malloc()] by the applicationŸI** and internal memory usage by the SQLite library.  Auxiliary page-cacheŸD** memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included inŸD** this parameter.  The amount returned is the sum of the allocationŸI** sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>)^¢**ŸE** [[SQLITE_STATUS_MALLOC_SIZE]] ^(<dt>SQLITE_STATUS_MALLOC_SIZE</dt>ŸC** <dd>This parameter records the largest memory allocation requestŸ@** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or theirŸ9** internal equivalents).  Only the value returned in theŸ@** *pHighwater parameter to [sqlite3_status()] is of interest.  ŸF** The value written into the *pCurrent parameter is undefined.</dd>)^¢**ŸG** [[SQLITE_STATUS_MALLOC_COUNT]] ^(<dt>SQLITE_STATUS_MALLOC_COUNT</dt>ŸG** <dd>This parameter records the number of separate memory allocationsŸ ** currently checked out.</dd>)^¢**ŸK** [[SQLITE_STATUS_PAGECACHE_USED]] ^(<dt>SQLITE_STATUS_PAGECACHE_USED</dt>ŸA** <dd>This parameter returns the number of pages used out of theŸ:** [pagecache memory allocator] that was configured using Ÿ"** [SQLITE_CONFIG_PAGECACHE].  TheŸ3** value returned is in pages, not in bytes.</dd>)^¢**Ÿ(** [[SQLITE_STATUS_PAGECACHE_OVERFLOW]] Ÿ.** ^(<dt>SQLITE_STATUS_PAGECACHE_OVERFLOW</dt>Ÿ?** <dd>This parameter returns the number of bytes of page cacheŸK** allocation which could not be satisfied by the [SQLITE_CONFIG_PAGECACHE]ŸB** buffer and where forced to overflow to [sqlite3_malloc()].  TheŸC** returned value includes allocations that overflowed because theyŸ?** where too large (they were larger than the "sz" parameter toŸE** [SQLITE_CONFIG_PAGECACHE]) and allocations that overflowed becauseŸ.** no space was left in the page cache.</dd>)^¢**ŸK** [[SQLITE_STATUS_PAGECACHE_SIZE]] ^(<dt>SQLITE_STATUS_PAGECACHE_SIZE</dt>ŸC** <dd>This parameter records the largest memory allocation requestŸJ** handed to [pagecache memory allocator].  Only the value returned in theŸ@** *pHighwater parameter to [sqlite3_status()] is of interest.  ŸF** The value written into the *pCurrent parameter is undefined.</dd>)^¢**ŸE** [[SQLITE_STATUS_SCRATCH_USED]] <dt>SQLITE_STATUS_SCRATCH_USED</dt>ª** <dd>No longer used.</dd>¢**ŸO** [[SQLITE_STATUS_SCRATCH_OVERFLOW]] ^(<dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>ª** <dd>No longer used.</dd>¢**ŸE** [[SQLITE_STATUS_SCRATCH_SIZE]] <dt>SQLITE_STATUS_SCRATCH_SIZE</dt>ª** <dd>No longer used.</dd>¢**ŸG** [[SQLITE_STATUS_PARSER_STACK]] ^(<dt>SQLITE_STATUS_PARSER_STACK</dt>ŸC** <dd>The *pHighwater parameter records the deepest parser stack. ŸC** The *pCurrent value is undefined.  The *pHighwater value is onlyŸG** meaningful if SQLite is compiled with [YYTRACKMAXSTACKDEPTH].</dd>)^®** </dl>¢**Ÿ8** New status parameters may be added from time to time.¢*/Ÿ,#define SQLITE_STATUS_MEMORY_USED          0Ÿ,#define SQLITE_STATUS_PAGECACHE_USED       1Ÿ,#define SQLITE_STATUS_PAGECACHE_OVERFLOW   2Ÿ<#define SQLITE_STATUS_SCRATCH_USED         3  /* NOT USED */Ÿ<#define SQLITE_STATUS_SCRATCH_OVERFLOW     4  /* NOT USED */Ÿ,#define SQLITE_STATUS_MALLOC_SIZE          5Ÿ,#define SQLITE_STATUS_PARSER_STACK         6Ÿ,#define SQLITE_STATUS_PAGECACHE_SIZE       7Ÿ<#define SQLITE_STATUS_SCRATCH_SIZE         8  /* NOT USED */Ÿ,#define SQLITE_STATUS_MALLOC_COUNT         9†¢/*Ÿ'** CAPI3REF: Database Connection Status≤** METHOD: sqlite3¢**ŸB** ^This interface is used to retrieve runtime status information ŸD** about a single [database connection].  ^The first argument is theŸG** database connection object to be interrogated.  ^The second argumentŸ0** is an integer constant, taken from the set ofŸ"** [SQLITE_DBSTATUS options], thatŸ8** determines the parameter to interrogate.  The set of Ÿ&** [SQLITE_DBSTATUS options] is likelyŸ(** to grow in future releases of SQLite.¢**ŸF** ^The current value of the requested parameter is written into *pCurŸD** and the highest instantaneous value is written into *pHiwtr.  ^IfŸ@** the resetFlg is true, then the highest instantaneous value isŸ(** reset back down to the current value.¢**ŸF** ^The sqlite3_db_status() routine returns SQLITE_OK on success and aŸ$** non-zero [error code] on failure.¢**Ÿ<** See also: [sqlite3_status()] and [sqlite3_stmt_status()].¢*/ŸYSQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);†¢/*Ÿ7** CAPI3REF: Status Parameters for database connectionsŸ&** KEYWORDS: {SQLITE_DBSTATUS options}¢**ŸJ** These constants are the available integer "verbs" that can be passed asŸ>** the second argument to the [sqlite3_db_status()] interface.¢**ŸF** New verbs may be added in future releases of SQLite. Existing verbsŸH** might be discontinued. Applications should check the return code fromŸ;** [sqlite3_db_status()] to make sure that the call worked.ŸH** The [sqlite3_db_status()] interface will return a non-zero error codeŸ4** if a discontinued or unsupported verb is invoked.¢**ß** <dl>ŸO** [[SQLITE_DBSTATUS_LOOKASIDE_USED]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_USED</dt>ŸL** <dd>This parameter returns the number of lookaside memory slots currently∂** checked out.</dd>)^¢**ŸM** [[SQLITE_DBSTATUS_LOOKASIDE_HIT]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_HIT</dt>ŸC** <dd>This parameter returns the number malloc attempts that were ŸM** satisfied using lookaside memory. Only the high-water value is meaningful;Ÿ&** the current value is always zero.)^¢**Ÿ*** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE]]Ÿ1** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE</dt>ŸH** <dd>This parameter returns the number malloc attempts that might haveŸH** been satisfied using lookaside memory but failed due to the amount ofŸ>** memory requested being larger than the lookaside slot size.Ÿ+** Only the high-water value is meaningful;Ÿ&** the current value is always zero.)^¢**Ÿ*** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL]]Ÿ1** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL</dt>ŸH** <dd>This parameter returns the number malloc attempts that might haveŸH** been satisfied using lookaside memory but failed due to all lookasideø** memory already being in use.Ÿ+** Only the high-water value is meaningful;Ÿ&** the current value is always zero.)^¢**ŸG** [[SQLITE_DBSTATUS_CACHE_USED]] ^(<dt>SQLITE_DBSTATUS_CACHE_USED</dt>ŸE** <dd>This parameter returns the approximate number of bytes of heapŸM** memory used by all pager caches associated with the database connection.)^ŸN** ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.¢**Ÿ)** [[SQLITE_DBSTATUS_CACHE_USED_SHARED]] Ÿ/** ^(<dt>SQLITE_DBSTATUS_CACHE_USED_SHARED</dt>ŸI** <dd>This parameter is similar to DBSTATUS_CACHE_USED, except that if aŸJ** pager cache is shared between two or more connections the bytes of heapŸI** memory used by that pager cache is divided evenly between the attachedŸI** connections.)^  In other words, if none of the pager caches associatedŸI** with the database connection are shared, this request returns the sameŸK** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches areŸM** shared, the value returned by this call will be smaller than that returnedŸ>** by DBSTATUS_CACHE_USED. ^The highwater mark associated withŸ1** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.¢**ŸI** [[SQLITE_DBSTATUS_SCHEMA_USED]] ^(<dt>SQLITE_DBSTATUS_SCHEMA_USED</dt>ŸE** <dd>This parameter returns the approximate number of bytes of heapŸ?** memory used to store the schema for all databases associatedŸF** with the connection - main, temp, and any [ATTACH]-ed databases.)^ ŸJ** ^The full amount of memory used by the schemas is reported, even if theŸA** schema memory is shared with other database connections due toŸ%** [shared cache mode] being enabled.ŸO** ^The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.¢**ŸE** [[SQLITE_DBSTATUS_STMT_USED]] ^(<dt>SQLITE_DBSTATUS_STMT_USED</dt>ŸE** <dd>This parameter returns the approximate number of bytes of heapŸG** and lookaside memory used by all prepared statements associated withΩ** the database connection.)^ŸM** ^The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.®** </dd>¢**ŸE** [[SQLITE_DBSTATUS_CACHE_HIT]] ^(<dt>SQLITE_DBSTATUS_CACHE_HIT</dt>ŸF** <dd>This parameter returns the number of pager cache hits that haveŸM** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT Ø** is always 0.®** </dd>¢**ŸG** [[SQLITE_DBSTATUS_CACHE_MISS]] ^(<dt>SQLITE_DBSTATUS_CACHE_MISS</dt>ŸH** <dd>This parameter returns the number of pager cache misses that haveŸN** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS Ø** is always 0.®** </dd>¢**ŸI** [[SQLITE_DBSTATUS_CACHE_WRITE]] ^(<dt>SQLITE_DBSTATUS_CACHE_WRITE</dt>ŸI** <dd>This parameter returns the number of dirty cache entries that haveŸI** been written to disk. Specifically, the number of pages written to theŸH** wal file in wal mode databases, or the number of pages written to theŸI** database file in rollback mode databases. Any pages written as part ofŸI** transaction rollback or database recovery operations are not included.ŸJ** If an IO or other error occurs while writing a page to disk, the effectŸJ** on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined.)^ ^TheŸJ** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.®** </dd>¢**ŸI** [[SQLITE_DBSTATUS_CACHE_SPILL]] ^(<dt>SQLITE_DBSTATUS_CACHE_SPILL</dt>ŸI** <dd>This parameter returns the number of dirty cache entries that haveŸF** been written to disk in the middle of a transaction due to the pageŸI** cache overflowing. Transactions are more efficient if they are writtenŸI** to disk all at once. When pages spill mid-transaction, that introducesŸ@** additional overhead. This parameter can be used help identifyŸC** inefficiencies that can be resolve by increasing the cache size.®** </dd>¢**ŸK** [[SQLITE_DBSTATUS_DEFERRED_FKS]] ^(<dt>SQLITE_DBSTATUS_DEFERRED_FKS</dt>ŸG** <dd>This parameter returns zero for the current value if and only ifŸ@** all foreign key constraints (deferred or immediate) have beenŸ0** resolved.)^  ^The highwater mark is always 0.®** </dd>®** </dl>¢*/Ÿ.#define SQLITE_DBSTATUS_LOOKASIDE_USED       0Ÿ.#define SQLITE_DBSTATUS_CACHE_USED           1Ÿ.#define SQLITE_DBSTATUS_SCHEMA_USED          2Ÿ.#define SQLITE_DBSTATUS_STMT_USED            3Ÿ.#define SQLITE_DBSTATUS_LOOKASIDE_HIT        4Ÿ.#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE  5Ÿ.#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL  6Ÿ.#define SQLITE_DBSTATUS_CACHE_HIT            7Ÿ.#define SQLITE_DBSTATUS_CACHE_MISS           8Ÿ.#define SQLITE_DBSTATUS_CACHE_WRITE          9Ÿ.#define SQLITE_DBSTATUS_DEFERRED_FKS        10Ÿ.#define SQLITE_DBSTATUS_CACHE_USED_SHARED   11Ÿ.#define SQLITE_DBSTATUS_CACHE_SPILL         12ŸO#define SQLITE_DBSTATUS_MAX                 12   /* Largest defined DBSTATUS */††¢/*Ÿ&** CAPI3REF: Prepared Statement Status∑** METHOD: sqlite3_stmt¢**Ÿ.** ^(Each prepared statement maintains variousŸ7** [SQLITE_STMTSTATUS counters] that measure the numberŸG** of times it has performed specific operations.)^  These counters canŸE** be used to monitor the performance characteristics of the preparedŸI** statements.  For example, if the number of table steps greatly exceedsŸK** the number of table searches or result rows, that would tend to indicateŸE** that the prepared statement is using a full table scan rather thanÆ** an index.  ¢**ŸE** ^(This interface is used to retrieve and reset counter values fromŸH** a [prepared statement].  The first argument is the prepared statementŸ2** object to be interrogated.  The second argumentŸ@** is an integer code for a specific [SQLITE_STMTSTATUS counter]∏** to be interrogated.)^Ÿ;** ^The current value of the requested counter is returned.ŸI** ^If the resetFlg is true, then the counter is reset to zero after this∫** interface call returns.¢**Ÿ:** See also: [sqlite3_status()] and [sqlite3_db_status()].¢*/ŸGSQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);†¢/*Ÿ6** CAPI3REF: Status Parameters for prepared statementsŸE** KEYWORDS: {SQLITE_STMTSTATUS counter} {SQLITE_STMTSTATUS counters}¢**ŸC** These preprocessor macros define integer codes that name counterŸ@** values associated with the [sqlite3_stmt_status()] interface.Ÿ7** The meanings of the various counters are as follows:¢**ß** <dl>ŸO** [[SQLITE_STMTSTATUS_FULLSCAN_STEP]] <dt>SQLITE_STMTSTATUS_FULLSCAN_STEP</dt>ŸF** <dd>^This is the number of times that SQLite has stepped forward inŸH** a table as part of a full table scan.  Large numbers for this counterŸB** may indicate opportunities for performance improvement through ø** careful use of indices.</dd>¢**Ÿ=** [[SQLITE_STMTSTATUS_SORT]] <dt>SQLITE_STMTSTATUS_SORT</dt>ŸA** <dd>^This is the number of sort operations that have occurred.ŸB** A non-zero value in this counter may indicate an opportunity toŸ?** improvement performance through careful use of indices.</dd>¢**ŸG** [[SQLITE_STMTSTATUS_AUTOINDEX]] <dt>SQLITE_STMTSTATUS_AUTOINDEX</dt>ŸG** <dd>^This is the number of rows inserted into transient indices thatŸ@** were created automatically in order to help joins run faster.ŸB** A non-zero value in this counter may indicate an opportunity toŸB** improvement performance by adding permanent indices that do notŸ@** need to be reinitialized each time the statement is run.</dd>¢**ŸC** [[SQLITE_STMTSTATUS_VM_STEP]] <dt>SQLITE_STMTSTATUS_VM_STEP</dt>ŸA** <dd>^This is the number of virtual machine operations executedŸA** by the prepared statement if that number is less than or equalŸC** to 2147483647.  The number of virtual machine operations can be ŸE** used as a proxy for the total work done by the prepared statement.ŸA** If the number of virtual machine operations exceeds 2147483647ŸF** then the value returned by this statement status code is undefined.¢**ŸG** [[SQLITE_STMTSTATUS_REPREPARE]] <dt>SQLITE_STMTSTATUS_REPREPARE</dt>ŸG** <dd>^This is the number of times that the prepare statement has beenŸ@** automatically regenerated due to schema changes or change to Ÿ7** [bound parameters] that might affect the query plan.¢**Ÿ;** [[SQLITE_STMTSTATUS_RUN]] <dt>SQLITE_STMTSTATUS_RUN</dt>ŸC** <dd>^This is the number of times that the prepared statement hasŸD** been run.  A single "run" for the purposes of this counter is oneŸM** or more calls to [sqlite3_step()] followed by a call to [sqlite3_reset()].ŸH** The counter is incremented on the first [sqlite3_step()] call of each©** cycle.¢**ŸC** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>Ÿ>** <dd>^This is the approximate number of bytes of heap memoryŸE** used to store the prepared statement.  ^This value is not actuallyŸD** a counter, and so the resetFlg parameter to sqlite3_stmt_status()Ÿ;** is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.®** </dd>®** </dl>¢*/Ÿ-#define SQLITE_STMTSTATUS_FULLSCAN_STEP     1Ÿ-#define SQLITE_STMTSTATUS_SORT              2Ÿ-#define SQLITE_STMTSTATUS_AUTOINDEX         3Ÿ-#define SQLITE_STMTSTATUS_VM_STEP           4Ÿ-#define SQLITE_STMTSTATUS_REPREPARE         5Ÿ-#define SQLITE_STMTSTATUS_RUN               6Ÿ.#define SQLITE_STMTSTATUS_MEMUSED           99†¢/*Ÿ%** CAPI3REF: Custom Page Cache Object¢**Ÿ;** The sqlite3_pcache type is opaque.  It is implemented byŸ=** the pluggable module.  The SQLite core has no knowledge ofŸ:** its size or internal structure and never deals with theŸ?** sqlite3_pcache object except by holding and passing pointers±** to the object.¢**Ÿ<** See [sqlite3_pcache_methods2] for additional information.¢*/Ÿ-typedef struct sqlite3_pcache sqlite3_pcache;†¢/*Ÿ%** CAPI3REF: Custom Page Cache Object¢**ŸA** The sqlite3_pcache_page object represents a single page in theŸ>** page cache.  The page cache will allocate instances of thisŸG** object.  Various methods of the page cache use pointers to instancesŸ9** of this object as parameters or as their return value.¢**Ÿ<** See [sqlite3_pcache_methods2] for additional information.¢*/Ÿ7typedef struct sqlite3_pcache_page sqlite3_pcache_page;ºstruct sqlite3_pcache_page {Ÿ2  void *pBuf;        /* The content of the page */ŸE  void *pExtra;      /* Extra information associated with the page */¢};†¢/*Ÿ,** CAPI3REF: Application Defined Page Cache.π** KEYWORDS: {page cache}¢**ŸE** ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface canŸF** register an alternative page cache implementation by passing in an Ÿ7** instance of the sqlite3_pcache_methods2 structure.)^Ÿ>** In many applications, most of the heap memory allocated by Ÿ%** SQLite is used for the page cache.µ** By implementing a ŸF** custom page cache using this API, an application can better controlŸ=** the amount of memory consumed by SQLite, the way in which ŸC** that memory is allocated and released, and the policies used to ŸG** determine exactly which parts of a database file are cached and for ¨** how long.¢**Ÿ-** The alternative page cache mechanism is anŸJ** extreme measure that is only needed by the most demanding applications.Ÿ8** The built-in page cache is recommended for most uses.¢**ŸK** ^(The contents of the sqlite3_pcache_methods2 structure are copied to anŸH** internal buffer by SQLite within the call to [sqlite3_config].  HenceŸ>** the application may discard the parameter after the call toŸ ** [sqlite3_config()] returns.)^¢**Ÿ$** [[the xInit() page cache method]]Ÿ:** ^(The xInit() method is called once for each effective Ÿ#** call to [sqlite3_initialize()])^ŸH** (usually only once during the lifetime of the process). ^(The xInit()ŸG** method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^ŸH** The intent of the xInit() method is to set up global data structures Ÿ5** required by the custom page cache implementation. Ÿ-** ^(If the xInit() method is NULL, then the ŸI** built-in default page cache is used instead of the application defined∞** page cache.)^¢**Ÿ(** [[the xShutdown() page cache method]]Ÿ=** ^The xShutdown() method is called by [sqlite3_shutdown()].æ** It can be used to clean up ŸB** any outstanding resources before process shutdown, if required.Ÿ'** ^The xShutdown() method may be NULL.¢**Ÿ>** ^SQLite automatically serializes calls to the xInit method,Ÿ4** so the xInit method need not be threadsafe.  ^TheŸG** xShutdown method is only called from [sqlite3_shutdown()] so it doesŸJ** not need to be threadsafe either.  All other methods must be threadsafeŸ!** in multithreaded applications.¢**ŸJ** ^SQLite will never invoke xInit() more than once without an intervening∑** call to xShutdown().¢**Ÿ'** [[the xCreate() page cache methods]]ŸJ** ^SQLite invokes the xCreate() method to construct a new cache instance.ŸO** SQLite will typically create one cache instance for each open database file,Ÿ&** though this is not guaranteed. ^TheŸG** first parameter, szPage, is the size in bytes of the pages that mustŸH** be allocated by the cache.  ^szPage will always a power of two.  ^TheŸB** second parameter szExtra is a number of bytes of extra storage ŸF** associated with each page cache entry.  ^The szExtra parameter willŸ/** a number less than 250.  SQLite will use theŸJ** extra szExtra bytes on each page to store metadata about the underlyingŸ@** database page on disk.  The value passed into szExtra dependsŸK** on the SQLite version, the target platform, and how SQLite was compiled.ŸK** ^The third argument to xCreate(), bPurgeable, is true if the cache beingŸL** created will be used to cache database pages of a file stored on disk, orŸJ** false if it is used for an in-memory database. The cache implementationŸK** does not have to do anything special based with the value of bPurgeable;ŸM** it is purely advisory.  ^On a cache where bPurgeable is false, SQLite willŸ>** never invoke xUnpin() except to deliberately delete a page.ŸG** ^In other words, calls to xUnpin() on a cache with bPurgeable set toŸ;** false will always have the "discard" flag set to true.  Ÿ5** ^Hence, a cache created with bPurgeable false willŸ$** never contain any unpinned pages.¢**Ÿ)** [[the xCachesize() page cache method]]ŸK** ^(The xCachesize() method may be called at any time by SQLite to set theŸE** suggested maximum cache-size (number of pages stored by) the cacheŸL** instance passed as the first argument. This is the value configured usingŸF** the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeableŸI** parameter, the implementation is not required to do anything with thisæ** value; it is advisory only.¢**Ÿ*** [[the xPagecount() page cache methods]]ŸD** The xPagecount() method must return the number of pages currentlyŸ1** stored in the cache, both pinned and unpinned.£** Ÿ&** [[the xFetch() page cache methods]]ŸL** The xFetch() method locates a page in the cache and returns a pointer to ŸN** an sqlite3_pcache_page object associated with that page, or a NULL pointer.ŸH** The pBuf element of the returned sqlite3_pcache_page object will be aŸF** pointer to a buffer of szPage bytes used to store the content of a ŸK** single database page.  The pExtra element of sqlite3_pcache_page will beŸL** a pointer to the szExtra bytes of extra storage that SQLite has requestedŸ$** for each entry in the page cache.¢**ŸJ** The page to be fetched is determined by the key. ^The minimum key valueŸJ** is 1.  After it has been retrieved using xFetch, the page is considered≤** to be "pinned".¢**ŸJ** If the requested page is already in the page cache, then the page cacheŸK** implementation must return a pointer to the page buffer with its contentŸG** intact.  If the requested page is not already in the cache, then theŸ>** cache implementation should use the value of the createFlagŸ7** parameter to help it determined what action to take:¢**Ÿ*** <table border=1 width=85% align=center>ŸF** <tr><th> createFlag <th> Behavior when page is not already in cacheŸ<** <tr><td> 0 <td> Do not allocate a new page.  Return NULL.ŸJ** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.Ÿ)**                 Otherwise return NULL.ŸI** <tr><td> 2 <td> Make every effort to allocate a new page.  Only returnŸK**                 NULL if allocating a new page is effectively impossible.´** </table>¢**ŸN** ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLiteŸL** will only use a createFlag of 2 after a prior call with a createFlag of 1Ÿ:** failed.)^  In between the to xFetch() calls, SQLite mayŸF** attempt to unpin one or more cache pages by spilling the content ofŸE** pinned pages to disk and synching the operating system disk cache.¢**Ÿ%** [[the xUnpin() page cache method]]ŸJ** ^xUnpin() is called by SQLite with a pointer to a currently pinned pageŸI** as its second argument.  If the third parameter, discard, is non-zero,Ÿ0** then the page must be evicted from the cache.ø** ^If the discard parameter isŸH** zero, then the page may be discarded or retained at the discretion ofŸ<** page cache implementation. ^The page cache implementationŸ2** may choose to evict unpinned pages at any time.¢**Ÿ?** The cache must not perform any reference counting. A single ŸL** call to xUnpin() unpins the page regardless of the number of prior calls Ø** to xFetch().¢**Ÿ&** [[the xRekey() page cache methods]]ŸJ** The xRekey() method is used to change the key value associated with theŸ3** page passed as the second argument. If the cacheŸB** previously contains an entry associated with newKey, it must beŸM** discarded. ^Any prior cache entry associated with newKey is guaranteed not∞** to be pinned.¢**ŸG** When SQLite calls the xTruncate() method, the cache must discard allŸH** existing cache entries with page numbers (keys) greater than or equalŸE** to the value of the iLimit parameter passed to xTruncate(). If anyŸH** of these pages are pinned, they are implicitly unpinned, meaning thatŸ ** they can be safely discarded.¢**Ÿ'** [[the xDestroy() page cache method]]ŸK** ^The xDestroy() method is used to delete a cache allocated by xCreate().ŸL** All resources associated with the specified cache should be freed. ^AfterŸH** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]ŸM** handle invalid, and will not use it with any other sqlite3_pcache_methods2≠** functions.¢**Ÿ&** [[the xShrink() page cache method]]ŸG** ^SQLite invokes the xShrink() method when it wants the page cache toŸM** free up as much of heap memory as possible.  The page cache implementationŸO** is not obligated to free any memory, but well-behaved implementations should±** do their best.¢*/Ÿ?typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;Ÿ struct sqlite3_pcache_methods2 {Ø  int iVersion;≠  void *pArg;∂  int (*xInit)(void*);ª  void (*xShutdown)(void*);ŸF  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);Ÿ6  void (*xCachesize)(sqlite3_pcache*, int nCachesize);Ÿ%  int (*xPagecount)(sqlite3_pcache*);ŸP  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);ŸE  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);Ÿ8  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*, Ÿ(      unsigned oldKey, unsigned newKey);Ÿ6  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);Ÿ$  void (*xDestroy)(sqlite3_pcache*);Ÿ#  void (*xShrink)(sqlite3_pcache*);¢};†¢/*ŸH** This is the obsolete pcache_methods object that has now been replacedŸI** by sqlite3_pcache_methods2.  This object is not used by SQLite.  It isŸ@** retained in the header file for backwards compatibility only.¢*/Ÿ=typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;østruct sqlite3_pcache_methods {≠  void *pArg;∂  int (*xInit)(void*);ª  void (*xShutdown)(void*);Ÿ9  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);Ÿ6  void (*xCachesize)(sqlite3_pcache*, int nCachesize);Ÿ%  int (*xPagecount)(sqlite3_pcache*);ŸA  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);Ÿ6  void (*xUnpin)(sqlite3_pcache*, void*, int discard);ŸK  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);Ÿ6  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);Ÿ$  void (*xDestroy)(sqlite3_pcache*);¢};††¢/*Ÿ!** CAPI3REF: Online Backup Object¢**ŸG** The sqlite3_backup object records state information about an ongoingŸE** online backup operation.  ^The sqlite3_backup object is created byŸB** a call to [sqlite3_backup_init()] and is destroyed by a call toΩ** [sqlite3_backup_finish()].¢**Ÿ1** See Also: [Using the SQLite Online Backup API]¢*/Ÿ-typedef struct sqlite3_backup sqlite3_backup;†¢/*ø** CAPI3REF: Online Backup API.¢**ŸB** The backup API copies the content of one database into another.Ÿ;** It is useful either for creating backups of databases orŸ@** for copying in-memory databases to or from persistent files. ¢**Ÿ1** See Also: [Using the SQLite Online Backup API]¢**ŸJ** ^SQLite holds a write transaction open on the destination database fileŸ,** for the duration of the backup operation.ŸC** ^The source database is read-locked only while it is being read;ŸA** it is not locked continuously for the entire backup operation.ŸG** ^Thus, the backup may be performed on a live source database withoutŸ-** preventing other database connections fromŸJ** reading or writing to the source database while the backup is underway.£** Ÿ$** ^(To perform a backup operation: ©**   <ol>ŸH**     <li><b>sqlite3_backup_init()</b> is called once to initialize the≥**         backup, ŸP**     <li><b>sqlite3_backup_step()</b> is called one or more times to transfer Ÿ:**         the data between the two databases, and finallyŸM**     <li><b>sqlite3_backup_finish()</b> is called to release all resources Ÿ1**         associated with the backup operation. ¨**   </ol>)^ŸG** There should be exactly one call to sqlite3_backup_finish() for eachŸ,** successful call to sqlite3_backup_init().¢**Ÿ9** [[sqlite3_backup_init()]] <b>sqlite3_backup_init()</b>¢**ŸB** ^The D and N arguments to sqlite3_backup_init(D,N,S,M) are the ŸB** [database connection] associated with the destination database Ÿ'** and the database name, respectively.ŸE** ^The database name is "main" for the main database, "temp" for theŸD** temporary database, or the name specified after the AS keyword inŸ2** an [ATTACH] statement for an attached database.Ÿ$** ^The S and M arguments passed to ŸB** sqlite3_backup_init(D,N,S,M) identify the [database connection]Ÿ:** and database name of the source database, respectively.ŸJ** ^The source and destination [database connections] (parameters S and D)ŸH** must be different or else sqlite3_backup_init(D,N,S,M) will fail with¨** an error.¢**ŸB** ^A call to sqlite3_backup_init() will fail, returning NULL, if ŸA** there is already a read or read-write transaction open on the ∏** destination database.¢**ŸH** ^If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL isŸA** returned and an error code and error message are stored in theŸ'** destination [database connection] D.ŸK** ^The error code and message for the failed call to sqlite3_backup_init()ŸM** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/orŸ"** [sqlite3_errmsg16()] functions.ŸF** ^A successful call to sqlite3_backup_init() returns a pointer to anª** [sqlite3_backup] object.ŸN** ^The [sqlite3_backup] object may be used with the sqlite3_backup_step() andŸE** sqlite3_backup_finish() functions to perform the specified backup ≠** operation.¢**Ÿ9** [[sqlite3_backup_step()]] <b>sqlite3_backup_step()</b>¢**ŸF** ^Function sqlite3_backup_step(B,N) will copy up to N pages between ŸO** the source and destination databases specified by [sqlite3_backup] object B.Ÿ=** ^If N is negative, all remaining source pages are copied. ŸE** ^If sqlite3_backup_step(B,N) successfully copies N pages and thereŸL** are still more pages to be copied, then the function returns [SQLITE_OK].ŸG** ^If sqlite3_backup_step(B,N) successfully finishes copying all pagesŸ=** from source to destination, then it returns [SQLITE_DONE].Ÿ>** ^If an error occurs while running sqlite3_backup_step(B,N),Ÿ@** then an [error code] is returned. ^As well as [SQLITE_OK] andŸO** [SQLITE_DONE], a call to sqlite3_backup_step() may return [SQLITE_READONLY],Ÿ8** [SQLITE_NOMEM], [SQLITE_BUSY], [SQLITE_LOCKED], or anŸ@** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.¢**Ÿ@** ^(The sqlite3_backup_step() might return [SQLITE_READONLY] ifß** <ol>Ÿ9** <li> the destination database was opened read-only, orŸD** <li> the destination database is using write-ahead-log journalingŸ7** and the destination and source page sizes differ, orŸA** <li> the destination database is an in-memory database and theŸ,** destination and source page sizes differ.™** </ol>)^¢**ŸL** ^If sqlite3_backup_step() cannot obtain a required file-system lock, thenŸ5** the [sqlite3_busy_handler | busy-handler function]Ÿ-** is invoked (if one is specified). ^If the ŸD** busy-handler returns non-zero before the lock is available, then ŸE** [SQLITE_BUSY] is returned to the caller. ^In this case the call toŸ=** sqlite3_backup_step() can be retried later. ^If the source∏** [database connection]ŸK** is being used to write to the source database when sqlite3_backup_step()ŸK** is called, then [SQLITE_LOCKED] is returned immediately. ^Again, in thisŸG** case the call to sqlite3_backup_step() can be retried later on. ^(IfŸ?** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], orŸ'** [SQLITE_READONLY] is returned, then ŸJ** there is no point in retrying the call to sqlite3_backup_step(). These Ÿ?** errors are considered fatal.)^  The application must accept ŸM** that the backup operation has failed and pass the backup operation handle ŸB** to the sqlite3_backup_finish() to release associated resources.¢**ŸE** ^The first call to sqlite3_backup_step() obtains an exclusive lockŸM** on the destination file. ^The exclusive lock is not released until either ŸI** sqlite3_backup_finish() is called or the backup operation is complete ŸC** and sqlite3_backup_step() returns [SQLITE_DONE].  ^Every call toŸL** sqlite3_backup_step() obtains a [shared lock] on the source database thatŸ<** lasts for the duration of the sqlite3_backup_step() call.Ÿ>** ^Because the source database is not locked between calls toŸE** sqlite3_backup_step(), the source database may be modified mid-wayŸI** through the backup process.  ^If the source database is modified by anŸI** external process or via a database connection other than the one beingŸF** used by the backup operation, then the backup will be automaticallyŸG** restarted by the next call to sqlite3_backup_step(). ^If the source ŸL** database is modified by the using the same database connection as is usedŸE** by the backup operation, then the backup database is automaticallyº** updated at the same time.¢**Ÿ=** [[sqlite3_backup_finish()]] <b>sqlite3_backup_finish()</b>¢**ŸF** When sqlite3_backup_step() has returned [SQLITE_DONE], or when the ŸF** application wishes to abandon the backup operation, the applicationŸP** should destroy the [sqlite3_backup] by passing it to sqlite3_backup_finish().Ÿ7** ^The sqlite3_backup_finish() interfaces releases allŸ:** resources associated with the [sqlite3_backup] object. ŸI** ^If sqlite3_backup_step() has not yet returned [SQLITE_DONE], then anyŸG** active write-transaction on the destination database is rolled back.Ÿ)** The [sqlite3_backup] object is invalidŸC** and may not be used following a call to sqlite3_backup_finish().¢**ŸD** ^The value returned by sqlite3_backup_finish is [SQLITE_OK] if noŸF** sqlite3_backup_step() errors occurred, regardless or whether or notŸ#** sqlite3_backup_step() completed.ŸG** ^If an out-of-memory condition or IO error occurred during any priorŸG** sqlite3_backup_step() call on the same [sqlite3_backup] object, thenŸB** sqlite3_backup_finish() returns the corresponding [error code].¢**ŸK** ^A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step()ŸC** is not a permanent error and does not affect the return value ofª** sqlite3_backup_finish().¢**Ÿ@** [[sqlite3_backup_remaining()]] [[sqlite3_backup_pagecount()]]ŸC** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>¢**ŸL** ^The sqlite3_backup_remaining() routine returns the number of pages stillŸN** to be backed up at the conclusion of the most recent sqlite3_backup_step().ŸL** ^The sqlite3_backup_pagecount() routine returns the total number of pagesŸ>** in the source database at the conclusion of the most recentπ** sqlite3_backup_step().Ÿ?** ^(The values returned by these functions are only updated byŸJ** sqlite3_backup_step(). If the source database is modified in a way thatŸL** changes the size of the source database or the number of pages remaining,ŸN** those changes are not reflected in the output of sqlite3_backup_pagecount()Ÿ6** and sqlite3_backup_remaining() until after the nextª** sqlite3_backup_step().)^¢**Ÿ.** <b>Concurrent Usage of Database Handles</b>¢**ŸM** ^The source [database connection] may be used by the application for otherŸF** purposes while a backup operation is underway or being initialized.ŸG** ^If SQLite is compiled and configured to support threadsafe databaseŸL** connections, then the source database connection may be used concurrentlyΩ** from within other threads.¢**Ÿ@** However, the application must guarantee that the destination ŸN** [database connection] is not passed to any other API (by any thread) after ŸG** sqlite3_backup_init() is called and before the corresponding call toŸC** sqlite3_backup_finish().  SQLite does not currently check to seeŸP** if the application incorrectly accesses the destination [database connection]ŸG** and so no error code is reported, but the operations may malfunctionŸD** nevertheless.  Use of the destination database connection while aŸ@** backup is in progress might also also cause a mutex deadlock.¢**Ÿ:** If running in [shared cache mode], the application mustŸC** guarantee that the shared cache used by the destination databaseŸF** is not accessed while the backup is running. In practice this meansŸ@** that the application must guarantee that the disk file being ŸE** backed up to is not accessed by any connection within the process,ŸM** not just the specific connection that was passed to sqlite3_backup_init().¢**ŸH** The [sqlite3_backup] object itself is partially threadsafe. Multiple ŸN** threads may safely make multiple concurrent calls to sqlite3_backup_step().ŸI** However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount()ŸH** APIs are not strictly speaking threadsafe. If they are invoked at theŸF** same time as another thread is invoking sqlite3_backup_step() it isŸ,** possible that they return invalid values.¢*/Ÿ/SQLITE_API sqlite3_backup *sqlite3_backup_init(ŸJ  sqlite3 *pDest,                        /* Destination database handle */ŸH  const char *zDestName,                 /* Destination database name */ŸE  sqlite3 *pSource,                      /* Source database handle */ŸC  const char *zSourceName                /* Source database name */¢);ŸASQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);Ÿ8SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);Ÿ;SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);Ÿ;SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);†¢/*Ÿ ** CAPI3REF: Unlock Notification≤** METHOD: sqlite3¢**ŸI** ^When running in shared-cache mode, a database operation may fail withŸH** an [SQLITE_LOCKED] error if the required locks on the shared-cache orŸD** individual tables within the shared-cache cannot be obtained. SeeŸI** [SQLite Shared-Cache Mode] for a description of shared-cache locking. ŸH** ^This API may be used to register a callback that SQLite will invoke ŸK** when the connection currently holding the required lock relinquishes it.ŸC** ^This API is only available if the library was compiled with theŸ?** [SQLITE_ENABLE_UNLOCK_NOTIFY] C-preprocessor symbol defined.¢**Ÿ<** See Also: [Using the SQLite Unlock Notification Feature].¢**ŸH** ^Shared-cache locks are released when a database connection concludesŸH** its current transaction, either by committing it or rolling it back. ¢**ŸI** ^When a connection (known as the blocked connection) fails to obtain aŸE** shared-cache lock and SQLITE_LOCKED is returned to the caller, theŸE** identity of the database connection (the blocking connection) thatŸD** has locked the required resource is stored internally. ^After an Ÿ?** application receives an SQLITE_LOCKED error, it may call theŸH** sqlite3_unlock_notify() method with the blocked connection handle as ŸE** the first argument to register for a callback that will be invokedŸG** when the blocking connections current transaction is concluded. ^TheŸH** callback is invoked from within the [sqlite3_step] or [sqlite3_close]Ÿ<** call that concludes the blocking connections transaction.¢**ŸJ** ^(If sqlite3_unlock_notify() is called in a multi-threaded application,ŸC** there is a chance that the blocking connection will have alreadyŸL** concluded its transaction by the time sqlite3_unlock_notify() is invoked.ŸG** If this happens, then the specified callback is invoked immediately,Ÿ5** from within the call to sqlite3_unlock_notify().)^¢**ŸG** ^If the blocked connection is attempting to obtain a write-lock on aŸI** shared-cache table, and more than one other connection currently holdsŸI** a read-lock on the same table, then SQLite arbitrarily selects one of Ÿ;** the other connections to use as the blocking connection.¢**ŸE** ^(There may be at most one unlock-notify callback registered by a ŸD** blocked connection. If sqlite3_unlock_notify() is called when theŸF** blocked connection already has a registered unlock-notify callback,ŸK** then the new callback replaces the old.)^ ^If sqlite3_unlock_notify() isŸG** called with a NULL pointer as its second argument, then any existingŸ@** unlock-notify callback is canceled. ^The blocked connections ŸE** unlock-notify callback may also be canceled by closing the blockedŸ&** connection using [sqlite3_close()].¢**ŸI** The unlock-notify callback is not reentrant. If an application invokesŸI** any sqlite3_xxx API functions from within an unlock-notify callback, aŸ'** crash or deadlock may be the result.¢**ŸK** ^Unless deadlock is detected (see below), sqlite3_unlock_notify() alwaysµ** returns SQLITE_OK.¢**Ÿ%** <b>Callback Invocation Details</b>¢**ŸL** When an unlock-notify callback is registered, the application provides a ŸJ** single void* pointer that is passed to the callback when it is invoked.ŸH** However, the signature of the callback function allows SQLite to passŸF** it an array of void* context pointers. The first argument passed toŸH** an unlock-notify callback is a pointer to an array of void* pointers,Ÿ8** and the second is the number of entries in the array.¢**ŸE** When a blocking connections transaction is concluded, there may beŸL** more than one blocked connection that has registered for an unlock-notifyŸH** callback. ^If two or more such blocked connections have specified theŸI** same callback function, then instead of invoking the callback functionŸL** multiple times, it is invoked once with the set of void* context pointersŸG** specified by the blocked connections bundled together into an array.ŸG** This gives the application an opportunity to prioritize any actions Ÿ8** related to the set of unblocked database connections.¢**º** <b>Deadlock Detection</b>¢**ŸC** Assuming that after registering for an unlock-notify callback a ŸI** database waits for the callback to be issued before taking any furtherŸF** action (a reasonable assumption), then using this API may cause theŸG** application to deadlock. For example, if connection X is waiting forŸG** connection Y's transaction to be concluded, and similarly connectionŸF** Y is waiting on connection X's transaction, then neither connectionŸB** will proceed and the system may remain deadlocked indefinitely.¢**ŸH** To avoid this scenario, the sqlite3_unlock_notify() performs deadlockŸG** detection. ^If a given call to sqlite3_unlock_notify() would put theŸF** system in a deadlocked state, then SQLITE_LOCKED is returned and noŸD** unlock-notify callback is registered. The system is said to be inŸI** a deadlocked state if connection A has registered for an unlock-notifyŸK** callback on the conclusion of connection B's transaction, and connectionŸH** B has itself registered for an unlock-notify callback when connectionŸH** A's transaction is concluded. ^Indirect deadlock is also detected, soŸE** the system is also considered to be deadlocked if connection B hasŸK** registered for an unlock-notify callback on the conclusion of connectionŸG** C's transaction, where connection C is waiting on connection A. ^AnyŸ/** number of levels of indirection are allowed.¢**Ÿ$** <b>The "DROP TABLE" Exception</b>¢**ŸG** When a call to [sqlite3_step()] returns SQLITE_LOCKED, it is almost ŸH** always appropriate to call sqlite3_unlock_notify(). There is however,ŸJ** one exception. When executing a "DROP TABLE" or "DROP INDEX" statement,ŸG** SQLite checks if there are any currently executing SELECT statementsŸE** that belong to the same connection. If there are, SQLITE_LOCKED isŸH** returned. In this case there is no "blocking connection", so invokingŸF** sqlite3_unlock_notify() results in the unlock-notify callback beingŸL** invoked immediately. If the application then re-attempts the "DROP TABLE"Ÿ?** or "DROP INDEX" query, an infinite loop might be the result.¢**ŸK** One way around this problem is to check the extended error code returnedŸK** by an sqlite3_step() call. ^(If there is a blocking connection, then theŸI** extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, inŸH** the special "DROP TABLE/INDEX" case, the extended error code is just ≥** SQLITE_LOCKED.)^¢*/Ÿ%SQLITE_API int sqlite3_unlock_notify(ŸF  sqlite3 *pBlocked,                          /* Waiting connection */ŸO  void (*xNotify)(void **apArg, int nArg),    /* Callback function to invoke */ŸO  void *pNotifyArg                            /* Argument to pass to xNotify */¢);††¢/*æ** CAPI3REF: String Comparison¢**ŸL** ^The [sqlite3_stricmp()] and [sqlite3_strnicmp()] APIs allow applicationsŸI** and extensions to compare the contents of two buffers containing UTF-8ŸL** strings in a case-independent fashion, using the same definition of "caseŸH** independence" that SQLite uses internally when comparing identifiers.¢*/Ÿ;SQLITE_API int sqlite3_stricmp(const char *, const char *);ŸASQLITE_API int sqlite3_strnicmp(const char *, const char *, int);†¢/*º** CAPI3REF: String Globbing°*ŸD** ^The [sqlite3_strglob(P,X)] interface returns zero if and only ifŸ)** string X matches the [GLOB] pattern P.Ÿ5** ^The definition of [GLOB] pattern matching used inŸK** [sqlite3_strglob(P,X)] is the same as for the "X GLOB P" operator in theŸJ** SQL dialect understood by SQLite.  ^The [sqlite3_strglob(P,X)] functionµ** is case sensitive.¢**ŸM** Note that this routine returns zero on a match and non-zero if the stringsŸJ** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].¢**Ÿ!** See also: [sqlite3_strlike()].¢*/ŸDSQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);†¢/*Ÿ!** CAPI3REF: String LIKE Matching°*ŸF** ^The [sqlite3_strlike(P,X,E)] interface returns zero if and only ifŸA** string X matches the [LIKE] pattern P with escape character E.Ÿ5** ^The definition of [LIKE] pattern matching used inŸF** [sqlite3_strlike(P,X,E)] is the same as for the "X LIKE P ESCAPE E"ŸM** operator in the SQL dialect understood by SQLite.  ^For "X LIKE P" withoutŸK** the ESCAPE clause, set the E parameter of [sqlite3_strlike(P,X,E)] to 0.ŸL** ^As with the LIKE operator, the [sqlite3_strlike(P,X,E)] function is caseŸG** insensitive - equivalent upper and lower case ASCII characters matchØ** one another.¢**ŸL** ^The [sqlite3_strlike(P,X,E)] function matches Unicode characters, thoughŸ)** only ASCII characters are case folded.¢**ŸM** Note that this routine returns zero on a match and non-zero if the stringsŸJ** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].¢**Ÿ!** See also: [sqlite3_strglob()].¢*/ŸWSQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);†¢/*Ÿ$** CAPI3REF: Error Logging Interface¢**ŸG** ^The [sqlite3_log()] interface writes a message into the [error log]ŸG** established by the [SQLITE_CONFIG_LOG] option to [sqlite3_config()].ŸJ** ^If logging is enabled, the zFormat string and subsequent arguments areŸF** used with [sqlite3_snprintf()] to generate the final output string.¢**ŸH** The sqlite3_log() interface is intended for use by extensions such asŸJ** virtual tables, collating functions, and SQL functions.  While there isŸI** nothing to prevent an application from calling sqlite3_log(), doing so∫** is considered bad form.¢**Ÿ'** The zFormat string must not be NULL.¢**ŸM** To avoid deadlocks and other threading problems, the sqlite3_log() routineŸK** will not use dynamically allocated memory.  The log message is stored inŸI** a fixed-length buffer on the stack.  If the log message is longer thanŸF** a few hundred characters, it will be truncated to the length of the™** buffer.¢*/ŸDSQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);†¢/*Ÿ(** CAPI3REF: Write-Ahead Log Commit Hook≤** METHOD: sqlite3¢**ŸI** ^The [sqlite3_wal_hook()] function is used to register a callback thatŸD** is invoked each time data is committed to a database in wal mode.¢**ŸL** ^(The callback is invoked by SQLite after the commit has taken place and ŸO** the associated write-lock on the database released)^, so the implementation Ÿ<** may read, write or [checkpoint] the database as required.¢**ŸJ** ^The first parameter passed to the callback function when it is invokedŸE** is a copy of the third parameter passed to sqlite3_wal_hook() whenŸJ** registering the callback. ^The second is a copy of the database handle.ŸI** ^The third parameter is the name of the database that was written to -ŸN** either "main" or the name of an [ATTACH]-ed database. ^The fourth parameterŸ@** is the number of pages currently in the write-ahead log file,Ÿ,** including those that were just committed.¢**ŸJ** The callback function should normally return [SQLITE_OK].  ^If an errorŸB** code is returned, that error will propagate back up through theŸE** SQLite code base to cause the statement that provoked the callbackŸI** to report an error, though the commit will have still occurred. If theŸK** callback returns [SQLITE_ROW] or [SQLITE_DONE], or if it returns a valueŸG** that does not correspond to any valid SQLite error code, the results±** are undefined.¢**ŸO** A single database handle may have at most a single write-ahead log callback ŸE** registered at one time. ^Calling [sqlite3_wal_hook()] replaces anyŸA** previously registered write-ahead log callback. ^Note that theŸ3** [sqlite3_wal_autocheckpoint()] interface and theŸH** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and willŸ5** overwrite any prior [sqlite3_wal_hook()] settings.¢*/Ÿ"SQLITE_API void *sqlite3_wal_hook(¨  sqlite3*, Ÿ*  int(*)(void *,sqlite3*,const char*,int),ß  void*¢);†¢/*Ÿ)** CAPI3REF: Configure an auto-checkpoint≤** METHOD: sqlite3¢**Ÿ=** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper aroundŸK** [sqlite3_wal_hook()] that causes any database on [database connection] DŸ ** to automatically [checkpoint]Ÿ3** after committing a transaction if there are N orŸ@** more frames in the [write-ahead log] file.  ^Passing zero or Ÿ>** a negative value as the nFrame parameter disables automatic∏** checkpoints entirely.¢**ŸK** ^The callback registered by this function replaces any existing callbackŸL** registered using [sqlite3_wal_hook()].  ^Likewise, registering a callbackŸI** using [sqlite3_wal_hook()] disables the automatic checkpoint mechanismø** configured by this function.¢**ŸH** ^The [wal_autocheckpoint pragma] can be used to invoke this interface¨** from SQL.¢**Ÿ/** ^Checkpoints initiated by this mechanism areŸ'** [sqlite3_wal_checkpoint_v2|PASSIVE].¢**ŸJ** ^Every new [database connection] defaults to having the auto-checkpointŸJ** enabled with a threshold of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT]Ÿ$** pages.  The use of this interfaceŸE** is only necessary if the default setting is found to be suboptimalŸ ** for a particular application.¢*/Ÿ>SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);†¢/*Ÿ"** CAPI3REF: Checkpoint a database≤** METHOD: sqlite3¢**Ÿ5** ^(The sqlite3_wal_checkpoint(D,X) is equivalent toŸF** [sqlite3_wal_checkpoint_v2](D,X,[SQLITE_CHECKPOINT_PASSIVE],0,0).)^¢**ŸC** In brief, sqlite3_wal_checkpoint(D,X) causes the content in the ŸD** [write-ahead log] for database X on [database connection] D to beŸD** transferred into the database file and for the write-ahead log toŸ@** be reset.  See the [checkpointing] documentation for additionØ** information.¢**ŸB** This interface used to be the only way to cause a checkpoint toŸM** occur.  But then the newer and more powerful [sqlite3_wal_checkpoint_v2()]ŸA** interface was added.  This interface is retained for backwardsŸL** compatibility and as a convenience for applications that need to manuallyŸK** start a callback but which do not need the full power (and correspondingŸ2** complication) of [sqlite3_wal_checkpoint_v2()].¢*/ŸDSQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);†¢/*Ÿ"** CAPI3REF: Checkpoint a database≤** METHOD: sqlite3¢**ŸI** ^(The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpointŸH** operation on database X of [database connection] D in mode M.  StatusŸE** information is written back into integers pointed to by L and C.)^Ÿ9** ^(The M parameter must be a valid [checkpoint mode]:)^¢**ß** <dl>Ÿ$** <dt>SQLITE_CHECKPOINT_PASSIVE<dd>ŸM**   ^Checkpoint as many frames as possible without waiting for any database ŸM**   readers or writers to finish, then sync the database file if all frames Ÿ?**   in the log were checkpointed. ^The [busy-handler callback]Ÿ>**   is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode.  ŸK**   ^On the other hand, passive mode might leave the checkpoint unfinishedŸ0**   if there are concurrent readers or writers.¢**Ÿ!** <dt>SQLITE_CHECKPOINT_FULL<dd>Ÿ&**   ^This mode blocks (it invokes theŸD**   [sqlite3_busy_handler|busy-handler callback]) until there is noŸN**   database writer and all readers are reading from the most recent databaseŸL**   snapshot. ^It then checkpoints all frames in the log file and syncs theŸO**   database file. ^This mode blocks new database writers while it is pending,Ÿ@**   but new database readers are allowed to continue unimpeded.¢**Ÿ$** <dt>SQLITE_CHECKPOINT_RESTART<dd>ŸN**   ^This mode works the same way as SQLITE_CHECKPOINT_FULL with the additionŸ@**   that after checkpointing the log file it blocks (calls the Ω**   [busy-handler callback])ŸN**   until all readers are reading from the database file only. ^This ensures ŸG**   that the next writer will restart the log file from the beginning.Ÿ7**   ^Like SQLITE_CHECKPOINT_FULL, this mode blocks newŸO**   database writer attempts while it is pending, but does not impede readers.¢**Ÿ%** <dt>SQLITE_CHECKPOINT_TRUNCATE<dd>ŸH**   ^This mode works the same way as SQLITE_CHECKPOINT_RESTART with theŸJ**   addition that it also truncates the log file to zero bytes just priorº**   to a successful return.®** </dl>¢**ŸM** ^If pnLog is not NULL, then *pnLog is set to the total number of frames inŸ@** the log file or to -1 if the checkpoint could not run becauseŸN** of an error or because the database is not in [WAL mode]. ^If pnCkpt is notŸM** NULL,then *pnCkpt is set to the total number of checkpointed frames in theŸM** log file (including any that were already checkpointed before the functionŸJ** was called) or to -1 if the checkpoint could not run due to an error orŸF** because the database is not in WAL mode. ^Note that upon successfulŸK** completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have beenŸN** truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.¢**ŸM** ^All calls obtain an exclusive "checkpoint" lock on the database file. ^IfŸM** any other process is running a checkpoint operation at the same time, the ŸL** lock cannot be obtained and SQLITE_BUSY is returned. ^Even if there is a Ÿ@** busy-handler configured, it will not be invoked in this case.¢**ŸK** ^The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the ŸN** exclusive "writer" lock on the database file. ^If the writer lock cannot beŸL** obtained immediately, and a busy-handler is configured, it is invoked andŸN** the writer lock retried until either the busy-handler returns 0 or the lockŸP** is successfully obtained. ^The busy-handler is also invoked while waiting forŸM** database readers as described above. ^If the busy-handler returns 0 beforeŸI** the writer lock is obtained or while waiting for database readers, theŸD** checkpoint operation proceeds from that point in the same way as ŸH** SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible ŸG** without blocking any further. ^SQLITE_BUSY is returned in this case.¢**ŸH** ^If parameter zDb is NULL or points to a zero length string, then theŸG** specified operation is attempted on all WAL databases [attached] to Ÿ.** [database connection] db.  In this case theŸM** values written to output parameters *pnLog and *pnCkpt are undefined. ^If ŸJ** an SQLITE_BUSY error is encountered when processing one or more of the ŸM** attached WAL databases, the operation is still attempted on any remaining ŸL** attached databases and SQLITE_BUSY is returned at the end. ^If any other ŸO** error occurs while processing an attached database, processing is abandoned ŸJ** and the error code is returned to the caller immediately. ^If no error ŸK** (SQLITE_BUSY or otherwise) is encountered while processing the attached Ÿ$** databases, SQLITE_OK is returned.¢**ŸJ** ^If database zDb is the name of an attached database that is not in WALŸI** mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. ^IfŸG** zDb is not NULL (or a zero length string) and is not the name of anyŸ=** attached database, SQLITE_ERROR is returned to the caller.¢**Ÿ$** ^Unless it returns SQLITE_MISUSE,Ÿ,** the sqlite3_wal_checkpoint_v2() interfaceŸ0** sets the error information that is queried byŸ.** [sqlite3_errcode()] and [sqlite3_errmsg()].¢**ŸL** ^The [PRAGMA wal_checkpoint] command can be used to invoke this interface¨** from SQL.¢*/Ÿ)SQLITE_API int sqlite3_wal_checkpoint_v2(Ÿ7  sqlite3 *db,                    /* Database handle */ŸK  const char *zDb,                /* Name of attached database (or NULL) */ŸA  int eMode,                      /* SQLITE_CHECKPOINT_* value */ŸF  int *pnLog,                     /* OUT: Size of WAL log in frames */ŸP  int *pnCkpt                     /* OUT: Total number of frames checkpointed */¢);†¢/*Ÿ#** CAPI3REF: Checkpoint Mode Valuesæ** KEYWORDS: {checkpoint mode}¢**ŸK** These constants define all valid values for the "checkpoint mode" passedŸI** as the third parameter to the [sqlite3_wal_checkpoint_v2()] interface.ŸI** See the [sqlite3_wal_checkpoint_v2()] documentation for details on theŸ-** meaning of each of these checkpoint modes.¢*/ŸO#define SQLITE_CHECKPOINT_PASSIVE  0  /* Do as much as possible w/o blocking */ŸM#define SQLITE_CHECKPOINT_FULL     1  /* Wait for writers, then checkpoint */ŸN#define SQLITE_CHECKPOINT_RESTART  2  /* Like FULL but wait for for readers */ŸN#define SQLITE_CHECKPOINT_TRUNCATE 3  /* Like RESTART but also truncate WAL */†¢/*Ÿ2** CAPI3REF: Virtual Table Interface Configuration¢**ŸK** This function may be called by either the [xConnect] or [xCreate] methodŸ3** of a [virtual table] implementation to configureŸ1** various facets of the virtual table interface.¢**ŸE** If this interface is invoked outside the context of an xConnect orŸ?** xCreate virtual table method then the behavior is undefined.¢**ŸD** At present, there is only one option that may be configured usingŸJ** this function. (See [SQLITE_VTAB_CONSTRAINT_SUPPORT].)  Further optionsæ** may be added in the future.¢*/Ÿ:SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);†¢/*Ÿ0** CAPI3REF: Virtual Table Configuration Options¢**Ÿ1** These macros define the various options to theŸI** [sqlite3_vtab_config()] interface that [virtual table] implementationsŸ4** can use to customize and optimize their behavior.¢**ß** <dl>Ÿ%** <dt>SQLITE_VTAB_CONSTRAINT_SUPPORT∏** <dd>Calls of the formŸL** [sqlite3_vtab_config](db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported,ŸG** where X is an integer.  If X is zero, then the [virtual table] whoseŸJ** [xCreate] or [xConnect] method invoked [sqlite3_vtab_config()] does notŸH** support constraints.  In this configuration (which is the default) ifŸN** a call to the [xUpdate] method returns [SQLITE_CONSTRAINT], then the entireŸC** statement is rolled back as if [ON CONFLICT | OR ABORT] had beenŸI** specified as part of the users SQL statement, regardless of the actualæ** ON CONFLICT mode specified.¢**ŸE** If X is non-zero, then the virtual table implementation guaranteesŸF** that if [xUpdate] returns [SQLITE_CONSTRAINT], it will do so beforeŸN** any modifications to internal or persistent data structures have been made.ŸH** If the [ON CONFLICT] mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite ŸH** is able to roll back a statement or database transaction, and abandonŸD** or continue processing the current SQL statement as appropriate. ŸF** If the ON CONFLICT mode is REPLACE and the [xUpdate] method returnsŸF** [SQLITE_CONSTRAINT], SQLite handles this as if the ON CONFLICT mode≤** had been ABORT.¢**ŸG** Virtual table implementations that are required to handle OR REPLACEŸ<** must do so within the [xUpdate] method. If a call to the ŸG** [sqlite3_vtab_on_conflict()] function indicates that the current ON ŸG** CONFLICT policy is REPLACE, the virtual table implementation should ŸH** silently replace the appropriate rows within the xUpdate callback andŸ?** return SQLITE_OK. Or, if this is not possible, it may returnŸB** SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT ∑** constraint handling.®** </dl>¢*/Ÿ(#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1†¢/*Ÿ8** CAPI3REF: Determine The Virtual Table Conflict Policy¢**ŸN** This function may only be called from within a call to the [xUpdate] methodŸN** of a [virtual table] implementation for an INSERT or UPDATE operation. ^TheŸN** value returned is one of [SQLITE_ROLLBACK], [SQLITE_IGNORE], [SQLITE_FAIL],ŸK** [SQLITE_ABORT], or [SQLITE_REPLACE], according to the [ON CONFLICT] modeŸN** of the SQL statement that triggered the call to the [xUpdate] method of the≥** [virtual table].¢*/Ÿ3SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);†¢/*ŸC** CAPI3REF: Determine If Virtual Table Column Access Is For UPDATE¢**ŸI** If the sqlite3_vtab_nochange(X) routine is called within the [xColumn]ŸG** method of a [virtual table], then it returns true if and only if theŸJ** column is being fetched as part of an UPDATE operation during which theŸK** column value will not change.  Applications might use this to substituteŸK** a lighter-weight value to return that the corresponding [xUpdate] methodŸ&** understands as a "no-change" value.¢**ŸG** If the [xColumn] method calls sqlite3_vtab_nochange() and finds thatŸF** the column is not changed by the UPDATE statement, they the xColumnŸI** method can optionally return without setting a result, without callingŸE** any of the [sqlite3_result_int|sqlite3_result_xxxxx() interfaces].ŸE** In that case, [sqlite3_value_nochange(X)] will return true for theŸ'** same column in the [xUpdate] method.¢*/Ÿ7SQLITE_API int sqlite3_vtab_nochange(sqlite3_context*);†¢/*ŸC** CAPI3REF: Determine The Collation For a Virtual Table Constraint¢**ŸJ** This function may only be called from within a call to the [xBestIndex]Ÿ ** method of a [virtual table]. ¢**ŸG** The first argument must be the sqlite3_index_info object that is theŸJ** first parameter to the xBestIndex() method. The second argument must beŸL** an index into the aConstraint[] array belonging to the sqlite3_index_infoŸO** structure passed to xBestIndex. This function returns a pointer to a buffer ŸF** containing the name of the collation sequence for the correspondingÆ** constraint.¢*/Ÿ[SQLITE_API SQLITE_EXPERIMENTAL const char *sqlite3_vtab_collation(sqlite3_index_info*,int);†¢/*Ÿ&** CAPI3REF: Conflict resolution modesŸ'** KEYWORDS: {conflict resolution mode}¢**ŸB** These constants are returned by [sqlite3_vtab_on_conflict()] toŸF** inform a [virtual table] implementation what the [ON CONFLICT] modeŸ,** is for the SQL statement being evaluated.¢**ŸE** Note that the [SQLITE_IGNORE] constant is also used as a potentialŸE** return value from the [sqlite3_set_authorizer()] callback and thatŸ*** [SQLITE_ABORT] is also a [result code].¢*/π#define SQLITE_ROLLBACK 1ŸK/* #define SQLITE_IGNORE 2 // Also used by sqlite3_authorizer() callback */π#define SQLITE_FAIL     3Ÿ3/* #define SQLITE_ABORT 4  // Also an error code */π#define SQLITE_REPLACE  5†¢/*Ÿ3** CAPI3REF: Prepared Statement Scan Status OpcodesŸ!** KEYWORDS: {scanstatus options}¢**ŸA** The following constants can be used for the T parameter to theŸL** [sqlite3_stmt_scanstatus(S,X,T,V)] interface.  Each constant designates aŸ<** different metric for sqlite3_stmt_scanstatus() to return.¢**ŸI** When the value returned to V is a string, space to hold that string isŸK** managed by the prepared statement S and will be automatically freed when≤** S is finalized.¢**ß** <dl>Ÿ;** [[SQLITE_SCANSTAT_NLOOP]] <dt>SQLITE_SCANSTAT_NLOOP</dt>ŸJ** <dd>^The [sqlite3_int64] variable pointed to by the T parameter will beŸD** set to the total number of times that the X-th loop has run.</dd>¢**Ÿ=** [[SQLITE_SCANSTAT_NVISIT]] <dt>SQLITE_SCANSTAT_NVISIT</dt>ŸN** <dd>^The [sqlite3_int64] variable pointed to by the T parameter will be setŸP** to the total number of rows examined by all iterations of the X-th loop.</dd>¢**Ÿ7** [[SQLITE_SCANSTAT_EST]] <dt>SQLITE_SCANSTAT_EST</dt>ŸN** <dd>^The "double" variable pointed to by the T parameter will be set to theŸK** query planner's estimate for the average number of rows output from eachŸN** iteration of the X-th loop.  If the query planner's estimates was accurate,ŸE** then this value will approximate the quotient NVISIT/NLOOP and theŸH** product of this value for all prior loops with the same SELECTID willŸ+** be the NLOOP value for the current loop.¢**Ÿ9** [[SQLITE_SCANSTAT_NAME]] <dt>SQLITE_SCANSTAT_NAME</dt>ŸM** <dd>^The "const char *" variable pointed to by the T parameter will be setŸN** to a zero-terminated UTF-8 string containing the name of the index or table∫** used for the X-th loop.¢**Ÿ?** [[SQLITE_SCANSTAT_EXPLAIN]] <dt>SQLITE_SCANSTAT_EXPLAIN</dt>ŸM** <dd>^The "const char *" variable pointed to by the T parameter will be setŸH** to a zero-terminated UTF-8 string containing the [EXPLAIN QUERY PLAN]Ÿ!** description for the X-th loop.¢**Ÿ?** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECT</dt>ŸK** <dd>^The "int" variable pointed to by the T parameter will be set to theŸJ** "select-id" for the X-th loop.  The select-id identifies which query orŸI** subquery the loop is part of.  The main query has a select-id of zero.ŸC** The select-id is the same value as is output in the first columnŸ$** of an [EXPLAIN QUERY PLAN] query.®** </dl>¢*/Ÿ"#define SQLITE_SCANSTAT_NLOOP    0Ÿ"#define SQLITE_SCANSTAT_NVISIT   1Ÿ"#define SQLITE_SCANSTAT_EST      2Ÿ"#define SQLITE_SCANSTAT_NAME     3Ÿ"#define SQLITE_SCANSTAT_EXPLAIN  4Ÿ"#define SQLITE_SCANSTAT_SELECTID 5†¢/*Ÿ+** CAPI3REF: Prepared Statement Scan Status∑** METHOD: sqlite3_stmt¢**ŸF** This interface returns information about the predicted and measuredŸ=** performance for pStmt.  Advanced applications can use thisŸF** interface to compare the predicted and the measured performance andŸD** issue warnings and/or rerun [ANALYZE] if discrepancies are found.¢**ŸA** Since this interface is expected to be rarely used, it is onlyŸL** available if SQLite is compiled using the [SQLITE_ENABLE_STMT_SCANSTATUS]∑** compile-time option.¢**ŸO** The "iScanStatusOp" parameter determines which status information to return.ŸN** The "iScanStatusOp" must be one of the [scanstatus options] or the behaviorŸ"** of this interface is undefined.ŸF** ^The requested measurement is written into a variable pointed to by∏** the "pOut" parameter.ŸK** Parameter "idx" identifies the specific loop to retrieve statistics for.ŸM** Loops are numbered starting from zero. ^If idx is out of range - less thanŸO** zero or greater than or equal to the total number of loops used to implementŸJ** the statement - a non-zero value is returned and the variable that pOut∫** points to is unchanged.¢**ŸP** ^Statistics might not be available for all loops in all statements. ^In casesŸN** where there exist loops with no available statistics, this function behavesŸL** as if the loop did not exist - it returns non-zero and leave the variableŸ!** that pOut points to unchanged.¢**Ÿ.** See also: [sqlite3_stmt_scanstatus_reset()]¢*/Ÿ'SQLITE_API int sqlite3_stmt_scanstatus(ŸK  sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */Ÿ<  int idx,                  /* Index of loop to report on */ŸI  int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */Ÿ5  void *pOut                /* Result written here */ß);     †¢/*Ÿ&** CAPI3REF: Zero Scan-Status Counters∑** METHOD: sqlite3_stmt¢**Ÿ@** ^Zero all [sqlite3_stmt_scanstatus()] related event counters.¢**ŸH** This API is only available if the library is built with pre-processorŸ2** symbol [SQLITE_ENABLE_STMT_SCANSTATUS] defined.¢*/Ÿ=SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);†¢/*Ÿ1** CAPI3REF: Flush caches to disk mid-transaction¢**ŸF** ^If a write-transaction is open on [database connection] D when theŸ:** [sqlite3_db_cacheflush(D)] interface invoked, any dirtyŸJ** pages in the pager-cache that are not currently in use are written out ŸI** to disk. A dirty page may be in use if a database cursor created by anŸL** active SQL statement is reading from it, or if it is page 1 of a databaseŸE** file (page 1 is always "in use").  ^The [sqlite3_db_cacheflush(D)]ŸA** interface flushes caches for all schemas - "main", "temp", andº** any [attached] databases.¢**ŸM** ^If this function needs to obtain extra database locks before dirty pages ŸJ** can be flushed to disk, it does so. ^If those locks cannot be obtained ŸM** immediately and there is a busy-handler callback configured, it is invokedŸL** in the usual manner. ^If the required lock still cannot be obtained, thenŸG** the database is skipped and an attempt made to flush any dirty pagesŸI** belonging to the next (if any) database. ^If any databases are skippedŸD** because locks cannot be obtained, but no other error occurs, thisŸ ** function returns SQLITE_BUSY.¢**ŸE** ^If any other error occurs while flushing dirty pages to disk (forŸF** example an IO error or out-of-memory condition), then processing isŸN** abandoned and an SQLite [error code] is returned to the caller immediately.¢**ŸO** ^Otherwise, if no error occurs, [sqlite3_db_cacheflush()] returns SQLITE_OK.¢**ŸH** ^This function does not set the database handle error code or messageŸH** returned by the [sqlite3_errcode()] and [sqlite3_errmsg()] functions.¢*/Ÿ/SQLITE_API int sqlite3_db_cacheflush(sqlite3*);†¢/*Ÿ!** CAPI3REF: The pre-update hook.¢**ŸG** ^These interfaces are only available if SQLite is compiled using theŸ6** [SQLITE_ENABLE_PREUPDATE_HOOK] compile-time option.¢**ŸJ** ^The [sqlite3_preupdate_hook()] interface registers a callback functionŸK** that is invoked prior to each [INSERT], [UPDATE], and [DELETE] operation∑** on a database table.ŸF** ^At most one preupdate hook may be registered at a time on a singleŸK** [database connection]; each call to [sqlite3_preupdate_hook()] overrides∏** the previous setting.ŸI** ^The preupdate hook is disabled by invoking [sqlite3_preupdate_hook()]Ÿ/** with a NULL pointer as the second parameter.ŸJ** ^The third parameter to [sqlite3_preupdate_hook()] is passed through asŸ$** the first parameter to callbacks.¢**ŸJ** ^The preupdate hook only fires for changes to real database tables; theŸF** preupdate hook is not invoked for changes to [virtual tables] or toŸ4** system tables like sqlite_master or sqlite_stat1.¢**ŸB** ^The second parameter to the preupdate callback is a pointer toŸ@** the [database connection] that registered the preupdate hook.ŸI** ^The third parameter to the preupdate callback is one of the constantsŸG** [SQLITE_INSERT], [SQLITE_DELETE], or [SQLITE_UPDATE] to identify theŸ3** kind of update operation that is about to occur.ŸF** ^(The fourth parameter to the preupdate callback is the name of theŸH** database within the database connection that is being modified.  ThisŸE** will be "main" for the main database or "temp" for TEMP tables or ŸM** the name given after the AS keyword in the [ATTACH] statement for attachedØ** databases.)^ŸD** ^The fifth parameter to the preupdate callback is the name of theŸ ** table that is being modified.¢**ŸB** For an UPDATE or DELETE operation on a [rowid table], the sixthŸL** parameter passed to the preupdate callback is the initial [rowid] of the ŸK** row being modified or deleted. For an INSERT operation on a rowid table,ŸE** or any operation on a WITHOUT ROWID table, the value of the sixth ŸG** parameter is undefined. For an INSERT or UPDATE on a rowid table theŸG** seventh parameter is the final rowid value of the row being insertedŸH** or updated. The value of the seventh parameter passed to the callbackŸI** function is not defined for operations on WITHOUT ROWID tables, or forŸ%** INSERT operations on rowid tables.¢**Ÿ<** The [sqlite3_preupdate_old()], [sqlite3_preupdate_new()],ŸJ** [sqlite3_preupdate_count()], and [sqlite3_preupdate_depth()] interfacesŸI** provide additional information about a preupdate event. These routinesŸH** may only be called from within a preupdate callback.  Invoking any ofŸ@** these routines from outside of a preupdate callback or with aŸH** [database connection] pointer that is different from the one suppliedŸJ** to the preupdate callback results in undefined and probably undesirable¨** behavior.¢**ŸL** ^The [sqlite3_preupdate_count(D)] interface returns the number of columnsŸ:** in the row that is being inserted, updated, or deleted.¢**ŸK** ^The [sqlite3_preupdate_old(D,N,P)] interface writes into P a pointer toŸK** a [protected sqlite3_value] that contains the value of the Nth column ofŸI** the table row before it is updated.  The N parameter must be between 0ŸB** and one less than the number of columns or the behavior will beŸK** undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETEŸK** preupdate callbacks; if it is used by an SQLITE_INSERT callback then theŸ?** behavior is undefined.  The [sqlite3_value] that P points toŸ9** will be destroyed when the preupdate callback returns.¢**ŸK** ^The [sqlite3_preupdate_new(D,N,P)] interface writes into P a pointer toŸK** a [protected sqlite3_value] that contains the value of the Nth column ofŸH** the table row after it is updated.  The N parameter must be between 0ŸB** and one less than the number of columns or the behavior will beŸK** undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATEŸK** preupdate callbacks; if it is used by an SQLITE_DELETE callback then theŸ?** behavior is undefined.  The [sqlite3_value] that P points toŸ9** will be destroyed when the preupdate callback returns.¢**ŸI** ^The [sqlite3_preupdate_depth(D)] interface returns 0 if the preupdateŸI** callback was invoked as a result of a direct insert, update, or deleteŸI** operation; or 1 for inserts, updates, or deletes invoked by top-level ŸI** triggers; or 2 for changes resulting from triggers called by top-level∫** triggers; and so forth.¢**Ÿ%** See also:  [sqlite3_update_hook()]¢*/Ÿ)#if defined(SQLITE_ENABLE_PREUPDATE_HOOK)Ÿ(SQLITE_API void *sqlite3_preupdate_hook(Æ  sqlite3 *db,¥  void(*xPreUpdate)(ŸM    void *pCtx,                   /* Copy of third arg to preupdate_hook() */Ÿ7    sqlite3 *db,                  /* Database handle */ŸG    int op,                       /* SQLITE_UPDATE, DELETE or INSERT */Ÿ5    char const *zDb,              /* Database name */Ÿ2    char const *zName,            /* Table name */ŸP    sqlite3_int64 iKey1,          /* Rowid of row about to be deleted/updated */ŸL    sqlite3_int64 iKey2           /* New rowid value (for a rowid UPDATE) */§  ),ß  void*¢);ŸGSQLITE_API int sqlite3_preupdate_old(sqlite3 *, int, sqlite3_value **);Ÿ2SQLITE_API int sqlite3_preupdate_count(sqlite3 *);Ÿ2SQLITE_API int sqlite3_preupdate_depth(sqlite3 *);ŸGSQLITE_API int sqlite3_preupdate_new(sqlite3 *, int, sqlite3_value **);¶#endif†¢/*Ÿ(** CAPI3REF: Low-level system error code¢**ŸI** ^Attempt to return the underlying operating system error code or errorŸJ** number that caused the most recent I/O error or failure to open a file.ŸI** The return value is OS-dependent.  For example, on unix systems, afterŸI** [sqlite3_open_v2()] returns [SQLITE_CANTOPEN], this interface could beŸJ** called to get back the underlying "errno" that caused the problem, suchŸ,** as ENOSPC, EAUTH, EISDIR, and so forth.  ¢*/Ÿ.SQLITE_API int sqlite3_system_errno(sqlite3*);†¢/*æ** CAPI3REF: Database SnapshotŸ*** KEYWORDS: {snapshot} {sqlite3_snapshot}Ø** EXPERIMENTAL¢**ŸG** An instance of the snapshot object records the state of a [WAL mode]Ÿ/** database for some specific point in history.¢**ŸF** In [WAL mode], multiple [database connections] that are open on theŸH** same database file can each be reading a different historical versionŸD** of the database file.  When a [database connection] begins a readŸG** transaction, that connection sees an unchanging copy of the databaseŸJ** as it existed for the point in time when the transaction first started.ŸI** Subsequent changes to the database from other connections are not seenŸ9** by the reader until a new read transaction is started.¢**ŸL** The sqlite3_snapshot object records state information about an historicalŸO** version of the database file so that it is possible to later open a new readŸL** transaction that sees that historical version of the database rather thanª** the most recent version.¢**ŸD** The constructor for this object is [sqlite3_snapshot_get()].  TheŸL** [sqlite3_snapshot_open()] method causes a fresh read transaction to referŸ@** to an historical snapshot (if possible).  The destructor for Ÿ9** sqlite3_snapshot objects is [sqlite3_snapshot_free()].¢*/Ÿ!typedef struct sqlite3_snapshot {ª  unsigned char hidden[48];≥} sqlite3_snapshot;†¢/*Ÿ'** CAPI3REF: Record A Database SnapshotØ** EXPERIMENTAL¢**ŸB** ^The [sqlite3_snapshot_get(D,S,P)] interface attempts to make aŸB** new [sqlite3_snapshot] object that records the current state ofŸ7** schema S in database connection D.  ^On success, theŸH** [sqlite3_snapshot_get(D,S,P)] interface writes a pointer to the newlyŸC** created [sqlite3_snapshot] object into *P and returns SQLITE_OK.ŸC** If there is not already a read-transaction open on schema S whenŸ9** this function is called, one is opened automatically. ¢**ŸE** The following must be true for this function to succeed. If any ofŸD** the following statements are false when sqlite3_snapshot_get() isŸG** called, SQLITE_ERROR is returned. The final value of *P is undefined±** in this case. ¢**ß** <ul>Ÿ;**   <li> The database handle must be in [autocommit mode].¢**ŸL**   <li> Schema S of [database connection] D must be a [WAL mode] database.¢**ŸL**   <li> There must not be a write transaction open on schema S of database∑**        connection D.¢**ŸL**   <li> One or more transactions must have been written to the current walŸK**        file since it was created on disk (by any connection). This meansŸM**        that a snapshot cannot be taken on a wal mode database with no wal ŸM**        file immediately after it is first opened. At least one transactionŸ&**        must be written to it first.®** </ul>¢**ŸH** This function may also return SQLITE_NOMEM.  If it is called with theŸG** database handle in autocommit mode but fails for some other reason, ŸH** whether or not a read transaction is opened on schema S is undefined.¢**ŸC** The [sqlite3_snapshot] object returned from a successful call toŸI** [sqlite3_snapshot_get()] must be freed using [sqlite3_snapshot_free()]∫** to avoid a memory leak.¢**ŸD** The [sqlite3_snapshot_get()] interface is only available when theŸ6** SQLITE_ENABLE_SNAPSHOT compile-time option is used.¢*/Ÿ8SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_get(Æ  sqlite3 *db,∂  const char *zSchema,ø  sqlite3_snapshot **ppSnapshot¢);†¢/*Ÿ?** CAPI3REF: Start a read transaction on an historical snapshotØ** EXPERIMENTAL¢**Ÿ9** ^The [sqlite3_snapshot_open(D,S,P)] interface starts aŸ#** read transaction for schema S ofŸ9** [database connection] D such that the read transactionŸ:** refers to historical [snapshot] P, rather than the mostŸ!** recent change to the database.ŸH** ^The [sqlite3_snapshot_open()] interface returns SQLITE_OK on successŸ.** or an appropriate [error code] if it fails.¢**ŸI** ^In order to succeed, a call to [sqlite3_snapshot_open(D,S,P)] must beŸD** the first operation following the [BEGIN] that takes the schema Sº** out of [autocommit mode].Ÿ5** ^In other words, schema S must not currently be inŸD** a transaction for [sqlite3_snapshot_open(D,S,P)] to work, but theŸ:** database connection D must be out of [autocommit mode].ŸB** ^A [snapshot] will fail to open if it has been overwritten by a∞** [checkpoint].Ÿ>** ^(A call to [sqlite3_snapshot_open(D,S,P)] will fail if theŸA** database connection D does not know that the database file forŸC** schema S is in [WAL mode].  A database connection might not knowŸE** that the database file is in [WAL mode] if there has been no priorŸJ** I/O on that database connection, or if the database entered [WAL mode] Ÿ:** after the most recent I/O on the database connection.)^Ÿ>** (Hint: Run "[PRAGMA application_id]" against a newly openedŸC** database connection in order to make it ready to use snapshots.)¢**ŸE** The [sqlite3_snapshot_open()] interface is only available when theŸ6** SQLITE_ENABLE_SNAPSHOT compile-time option is used.¢*/Ÿ9SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_open(Æ  sqlite3 *db,∂  const char *zSchema,Ω  sqlite3_snapshot *pSnapshot¢);†¢/*ø** CAPI3REF: Destroy a snapshotØ** EXPERIMENTAL¢**ŸK** ^The [sqlite3_snapshot_free(P)] interface destroys [sqlite3_snapshot] P.ŸG** The application must eventually free every [sqlite3_snapshot] objectŸ-** using this routine to avoid a memory leak.¢**ŸE** The [sqlite3_snapshot_free()] interface is only available when theŸ6** SQLITE_ENABLE_SNAPSHOT compile-time option is used.¢*/ŸMSQLITE_API SQLITE_EXPERIMENTAL void sqlite3_snapshot_free(sqlite3_snapshot*);†¢/*Ÿ6** CAPI3REF: Compare the ages of two snapshot handles.Ø** EXPERIMENTAL¢**ŸI** The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the agesŸ"** of two valid snapshot handles. ¢**ŸI** If the two snapshot handles are not associated with the same database Ÿ4** file, the result of the comparison is undefined. ¢**ŸJ** Additionally, the result of the comparison is only valid if both of theŸM** snapshot handles were obtained by calling sqlite3_snapshot_get() since theŸG** last time the wal file was deleted. The wal file is deleted when theŸK** database is changed back to rollback mode or when the number of databaseŸL** clients drops to zero. If either snapshot handle was obtained before the ŸB** wal file was last deleted, the value returned by this function ∞** is undefined.¢**ŸH** Otherwise, this API returns a negative value if P1 refers to an olderŸG** snapshot than P2, zero if the two handles refer to the same databaseŸD** snapshot, and a positive value if P1 is a newer snapshot than P2.¢*/Ÿ8SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_cmp(∑  sqlite3_snapshot *p1,∂  sqlite3_snapshot *p2¢);†¢/*Ÿ.** CAPI3REF: Recover snapshots from a wal fileØ** EXPERIMENTAL¢**ŸH** If all connections disconnect from a database file but do not performŸH** a checkpoint, the existing wal file is opened along with the databaseŸF** file the next time the database is opened. At this point it is onlyŸI** possible to successfully call sqlite3_snapshot_open() to open the mostŸI** recent snapshot of the database (the one at the head of the wal file),ŸG** even though the wal file may contain other valid snapshots for whichŸ)** clients have sqlite3_snapshot handles.¢**ŸK** This function attempts to scan the wal file associated with database zDbŸB** of database handle db and make all valid snapshots available toŸE** sqlite3_snapshot_open(). It is an error if there is already a readŸI** transaction open on the database, or if the database is not a wal mode¨** database.¢**ŸJ** SQLITE_OK is returned if successful, or an SQLite error code otherwise.¢*/ŸZSQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);†¢/*Ÿ!** CAPI3REF: Serialize a database¢**ŸG** The sqlite3_serialize(D,S,P,F) interface returns a pointer to memoryŸH** that is a serialization of the S database on [database connection] D.ŸE** If P is not a NULL pointer, then the size of the database in bytes∂** is written into *P.¢**ŸE** For an ordinary on-disk database file, the serialization is just aŸJ** copy of the disk file.  For an in-memory database or a "TEMP" database,ŸI** the serialization is the same sequence of bytes which would be writtenŸ4** to disk if that database where backed up to disk.¢**ŸI** The usual case is that sqlite3_serialize() copies the serialization ofŸJ** the database into memory obtained from [sqlite3_malloc64()] and returnsŸG** a pointer to that memory.  The caller is responsible for freeing theŸE** returned value to avoid a memory leak.  However, if the F argumentŸG** contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocationsŸG** are made, and the sqlite3_serialize() function will return a pointerŸF** to the contiguous memory representation of the database that SQLiteŸJ** is currently using for that database, or NULL if the no such contiguousŸE** memory representation of the database exists.  A contiguous memoryŸF** representation of the database will usually only exist if there hasŸD** been a prior call to [sqlite3_deserialize(D,S,...)] with the sameµ** values of D and S.Ÿ;** The size of the database is written into *P even if the Ÿ<** SQLITE_SERIALIZE_NOCOPY bit is set but no contigious copy∫** of the database exists.¢**ŸE** A call to sqlite3_serialize(D,S,P,F) might return NULL even if theŸE** SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memoryª** allocation error occurs.¢**ŸB** This interface is only available if SQLite is compiled with theŸ&** [SQLITE_ENABLE_DESERIALIZE] option.¢*/Ÿ,SQLITE_API unsigned char *sqlite3_serialize(Ÿ6  sqlite3 *db,           /* The database connection */ŸM  const char *zSchema,   /* Which DB to serialize. ex: "main", "temp", ... */ŸE  sqlite3_int64 *piSize, /* Write size of the DB here, if not NULL */ŸD  unsigned int mFlags    /* Zero or more SQLITE_SERIALIZE_* flags */¢);†¢/*Ÿ(** CAPI3REF: Flags for sqlite3_serialize¢**ŸD** Zero or more of the following constants can be OR-ed together forŸ2** the F argument to [sqlite3_serialize(D,S,P,F)].¢**ŸG** SQLITE_SERIALIZE_NOCOPY means that [sqlite3_serialize()] will returnŸI** a pointer to contiguous in-memory database that it is currently using,ŸK** without making a copy of the database.  If SQLite is not currently usingŸ;** a contiguous in-memory database, then this option causesŸG** [sqlite3_serialize()] to return a NULL pointer.  SQLite will only beŸH** using a contiguous in-memory database if it has been initialized by aŸ)** prior call to [sqlite3_deserialize()].¢*/ŸF#define SQLITE_SERIALIZE_NOCOPY 0x001   /* Do no memory allocations */†¢/*Ÿ#** CAPI3REF: Deserialize a database¢**Ÿ=** The sqlite3_deserialize(D,S,P,N,M,F) interface causes the ŸA** [database connection] D to disconnect from database S and thenŸI** reopen S as an in-memory database based on the serialization containedŸI** in P.  The serialized database P is N bytes in size.  M is the size ofŸJ** the buffer P, which might be larger than N.  If M is larger than N, andŸF** the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite isŸJ** permitted to add content to the in-memory database as long as the totalŸ ** size does not exceed M bytes.¢**ŸJ** If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite willŸF** invoke sqlite3_free() on the serialization buffer when the databaseŸL** connection closes.  If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, thenŸH** SQLite will try to increase the buffer size using sqlite3_realloc64()ŸB** if writes on the database cause it to grow larger than M bytes.¢**ŸH** The sqlite3_deserialize() interface will fail with SQLITE_BUSY if theŸI** database is currently in a read transaction or is involved in a backup≠** operation.¢**ŸG** If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the Ÿ@** SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, thenŸ@** [sqlite3_free()] is invoked on argument P prior to returning.¢**ŸB** This interface is only available if SQLite is compiled with theŸ&** [SQLITE_ENABLE_DESERIALIZE] option.¢*/Ÿ#SQLITE_API int sqlite3_deserialize(Ÿ7  sqlite3 *db,            /* The database connection */ŸK  const char *zSchema,    /* Which DB to reopen with the deserialization */Ÿ?  unsigned char *pData,   /* The serialized database content */ŸC  sqlite3_int64 szDb,     /* Number bytes in the deserialization */Ÿ<  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */ŸG  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */¢);†¢/*Ÿ,** CAPI3REF: Flags for sqlite3_deserialize()¢**ŸH** The following are allowed values for 6th argument (the F argument) toŸ4** the [sqlite3_deserialize(D,S,P,N,M,F)] interface.¢**ŸK** The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serializationŸI** in the P argument is held in memory obtained from [sqlite3_malloc64()]ŸI** and that SQLite should take ownership of this memory and automaticallyŸH** free it when it has finished using it.  Without this flag, the callerŸ>** is resposible for freeing any dynamically allocated memory.¢**ŸI** The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed toŸL** grow the size of the database using calls to [sqlite3_realloc64()].  ThisŸK** flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.ŸN** Without this flag, the deserialized database cannot increase in size beyondŸ4** the number of bytes specified by the M parameter.¢**ŸL** The SQLITE_DESERIALIZE_READONLY flag means that the deserialized databaseŸ"** should be treated as read-only.¢*/ŸK#define SQLITE_DESERIALIZE_FREEONCLOSE 1 /* Call sqlite3_free() on close */ŸO#define SQLITE_DESERIALIZE_RESIZEABLE  2 /* Resize using sqlite3_realloc64() */ŸD#define SQLITE_DESERIALIZE_READONLY    4 /* Database is read-only */†¢/*ŸB** Undo the hack that converts floating point types to integer forŸ7** builds on processors without floating point support.¢*/Ÿ!#ifdef SQLITE_OMIT_FLOATING_POINTÆ# undef double¶#endif†•#if 0Ÿ&}  /* End of the 'extern "C"' block */¶#endif∂#endif /* SQLITE3_H */†Ÿ./******** Begin file sqlite3rtree.h *********/¢/*±** 2010 August 30¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢*/†∏#ifndef _SQLITE3RTREE_H_∏#define _SQLITE3RTREE_H_††•#if 0¨extern "C" {¶#endif†Ÿ=typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;ŸAtypedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;†Ÿ=/* The double-precision datatype used by RTree depends on theŸ-** SQLITE_RTREE_INT_ONLY compile-time option.¢*/º#ifdef SQLITE_RTREE_INT_ONLYŸ*  typedef sqlite3_int64 sqlite3_rtree_dbl;•#elseŸ#  typedef double sqlite3_rtree_dbl;¶#endif†¢/*ŸJ** Register a geometry callback named zGeom that can be used as part of anŸ$** R-Tree geometry query as follows:¢**ŸK**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zGeom(... params ...)¢*/Ÿ/SQLITE_API int sqlite3_rtree_geometry_callback(Æ  sqlite3 *db,¥  const char *zGeom,ŸF  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),∞  void *pContext¢);††¢/*ŸH** A pointer to a structure of the following type is passed as the firstŸD** argument to callbacks registered using rtree_geometry_callback().¢*/østruct sqlite3_rtree_geometry {ŸL  void *pContext;                 /* Copy of pContext passed to s_r_g_c() */Ÿ>  int nParam;                     /* Size of array aParam[] */ŸN  sqlite3_rtree_dbl *aParam;      /* Parameters passed to SQL geom function */ŸI  void *pUser;                    /* Callback implementation user data */ŸJ  void (*xDelUser)(void *);       /* Called by SQLite to clean up pUser */¢};†¢/*ŸH** Register a 2nd-generation geometry callback named zScore that can be Ÿ7** used as part of an R-Tree geometry query as follows:¢**ŸP**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zQueryFunc(... params ...)¢*/Ÿ,SQLITE_API int sqlite3_rtree_query_callback(Æ  sqlite3 *db,π  const char *zQueryFunc,Ÿ/  int (*xQueryFunc)(sqlite3_rtree_query_info*),±  void *pContext,º  void (*xDestructor)(void*)¢);††¢/*ŸC** A pointer to a structure of the following type is passed as the Ÿ8** argument to scored geometry callback registered usingŸ"** sqlite3_rtree_query_callback().¢**ŸB** Note that the first 5 fields of this structure are identical toŸ;** sqlite3_rtree_geometry.  This structure is a subclass of∫** sqlite3_rtree_geometry.¢*/Ÿ!struct sqlite3_rtree_query_info {ŸP  void *pContext;                   /* pContext from when function registered */ŸG  int nParam;                       /* Number of function parameters */ŸF  sqlite3_rtree_dbl *aParam;        /* value of function parameters */ŸK  void *pUser;                      /* callback can use this, if desired */Ÿ@  void (*xDelUser)(void*);          /* function to free pUser */ŸO  sqlite3_rtree_dbl *aCoord;        /* Coordinates of node or entry to check */ŸP  unsigned int *anQueue;            /* Number of pending entries in the queue */Ÿ?  int nCoord;                       /* Number of coordinates */ŸH  int iLevel;                       /* Level of current node or entry */ŸN  int mxLevel;                      /* The largest iLevel value in the tree */ŸA  sqlite3_int64 iRowid;             /* Rowid for current entry */Ÿ>  sqlite3_rtree_dbl rParentScore;   /* Score of parent node */ŸC  int eParentWithin;                /* Visibility of parent node */Ÿ8  int eWithin;                      /* OUT: Visiblity */ŸC  sqlite3_rtree_dbl rScore;         /* OUT: Write the score here */ŸC  /* The following fields are only available in 3.8.11 and later */ŸK  sqlite3_value **apSqlParam;       /* Original SQL values of parameters */¢};†¢/*ŸE** Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.¢*/ŸL#define NOT_WITHIN       0   /* Object completely outside of query region */ŸI#define PARTLY_WITHIN    1   /* Object partially overlaps query region */ŸM#define FULLY_WITHIN     2   /* Object fully contained within query region */††•#if 0Ÿ&}  /* end of the 'extern "C"' block */¶#endif†Ÿ%#endif  /* ifndef _SQLITE3RTREE_H_ */†Ÿ*/******** End of sqlite3rtree.h *********/Ÿ0/******** Begin file sqlite3session.h *********/†ŸB#if !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION)º#define __SQLITESESSION_H_ 1†¢/*Ÿ-** Make sure we can call this stuff from C++.¢*/•#if 0¨extern "C" {¶#endif††¢/*Ÿ"** CAPI3REF: Session Object Handle¢**Ÿ@** An instance of this object is a [session] that can be used toŸ ** record changes to a database.¢*/Ÿ/typedef struct sqlite3_session sqlite3_session;†¢/*Ÿ&** CAPI3REF: Changeset Iterator Handle¢**Ÿ<** An instance of this object acts as a cursor for iteratingŸ4** over the elements of a [changeset] or [patchset].¢*/Ÿ=typedef struct sqlite3_changeset_iter sqlite3_changeset_iter;†¢/*Ÿ(** CAPI3REF: Create A New Session Objectø** CONSTRUCTOR: sqlite3_session¢**ŸM** Create a new session object attached to database handle db. If successful,ŸH** a pointer to the new object is written to *ppSession and SQLITE_OK isŸH** returned. If an error occurs, *ppSession is set to NULL and an SQLiteŸ.** error code (e.g. SQLITE_NOMEM) is returned.¢**ŸI** It is possible to create multiple session objects attached to a single≥** database handle.¢**ŸJ** Session objects created using this function should be deleted using theŸJ** [sqlite3session_delete()] function before the database handle that theyŸL** are attached to is itself closed. If the database handle is closed beforeŸI** the session object is deleted, then the results of calling any sessionŸM** module function, including [sqlite3session_delete()] on the session object±** are undefined.¢**ŸI** Because the session module uses the [sqlite3_preupdate_hook()] API, itŸH** is not possible for an application to register a pre-update hook on aŸH** database handle that has one or more session objects attached. Nor isŸK** it possible to create a session object attached to a database handle forŸI** which a pre-update hook is already defined. The results of attempting Ÿ(** either of these things are undefined.¢**ŸE** The session object will be used to create changesets for tables inŸI** database zDb, where zDb is either "main", or "temp", or the name of anŸH** attached database. It is not an error if database zDb is not attachedŸ6** to the database when the session object is created.¢*/Ÿ%SQLITE_API int sqlite3session_create(Ÿ7  sqlite3 *db,                    /* Database handle */Ÿ@  const char *zDb,                /* Name of db (e.g. "main") */Ÿ?  sqlite3_session **ppSession     /* OUT: New session object */¢);†¢/*Ÿ$** CAPI3REF: Delete A Session Objectæ** DESTRUCTOR: sqlite3_session¢**Ÿ6** Delete a session object previously allocated using ŸI** [sqlite3session_create()]. Once a session object has been deleted, theŸF** results of attempting to use pSession with any other session module∫** function are undefined.¢**ŸK** Session objects must be deleted before the database handle to which theyŸ:** are attached is closed. Refer to the documentation for Ÿ)** [sqlite3session_create()] for details.¢*/ŸASQLITE_API void sqlite3session_delete(sqlite3_session *pSession);††¢/*Ÿ/** CAPI3REF: Enable Or Disable A Session Object∫** METHOD: sqlite3_session¢**ŸG** Enable or disable the recording of changes by a session object. WhenŸG** enabled, a session object records changes made to the database. WhenŸE** disabled - it does not. A newly created session object is enabled.ŸJ** Refer to the documentation for [sqlite3session_changeset()] for furtherŸH** details regarding how enabling and disabling a session object affectsª** the eventual changesets.¢**ŸF** Passing zero to this function disables the session. Passing a valueŸE** greater than zero enables it. Passing a value less than zero is a ŸD** no-op, and may be used to query the current state of the session.¢**ŸJ** The return value indicates the final state of the session object: 0 if Ÿ2** the session is disabled, or 1 if it is enabled.¢*/ŸMSQLITE_API int sqlite3session_enable(sqlite3_session *pSession, int bEnable);†¢/*Ÿ2** CAPI3REF: Set Or Clear the Indirect Change Flag∫** METHOD: sqlite3_session¢**ŸI** Each change recorded by a session object is marked as either direct orŸ6** indirect. A change is marked as indirect if either:¢**ß** <ul>ŸF**   <li> The session object "indirect" flag is set when the change is≤**        made, orŸE**   <li> The change is made by an SQL trigger or foreign key action ŸC**        instead of directly as a result of a users SQL statement.®** </ul>¢**ŸK** If a single row is affected by more than one operation within a session,ŸM** then the change is considered indirect if all operations meet the criteriaŸ5** for an indirect change above, or direct otherwise.¢**ŸK** This function is used to set, clear or query the session object indirectŸJ** flag.  If the second argument passed to this function is zero, then theŸJ** indirect flag is cleared. If it is greater than zero, the indirect flagŸK** is set. Passing a value less than zero does not modify the current valueŸK** of the indirect flag, and may be used to query the current state of the Ÿ2** indirect flag for the specified session object.¢**ŸI** The return value indicates the final state of the indirect flag: 0 if Ÿ"** it is clear, or 1 if it is set.¢*/ŸQSQLITE_API int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect);†¢/*Ÿ/** CAPI3REF: Attach A Table To A Session Object∫** METHOD: sqlite3_session¢**ŸI** If argument zTab is not NULL, then it is the name of a table to attachŸN** to the session object passed as the first argument. All subsequent changes ŸO** made to the table while the session object is enabled will be recorded. See ŸF** documentation for [sqlite3session_changeset()] for further details.¢**ŸI** Or, if argument zTab is NULL, then changes are recorded for all tablesŸG** in the database. If additional tables are added to the database (by ŸM** executing "CREATE TABLE" statements) after this call is made, changes for Ÿ$** the new tables are also recorded.¢**ŸM** Changes can only be recorded for tables that have a PRIMARY KEY explicitlyŸN** defined as part of their CREATE TABLE statement. It does not matter if the ŸL** PRIMARY KEY is an "INTEGER PRIMARY KEY" (rowid alias) or not. The PRIMARYŸA** KEY may consist of a single column, or may be a composite key.£** ŸL** It is not an error if the named table does not exist in the database. NorŸJ** is it an error if the named table does not have a PRIMARY KEY. However,Ÿ<** no changes will be recorded in either of these scenarios.¢**ŸL** Changes are not recorded for individual rows that have NULL values storedŸ/** in one or more of their PRIMARY KEY columns.¢**ŸN** SQLITE_OK is returned if the call completes without error. Or, if an error Ÿ@** occurs, an SQLite error code (e.g. SQLITE_NOMEM) is returned.¢**Ÿ)** <h3>Special sqlite_stat1 Handling</h3>¢**ŸL** As of SQLite version 3.22.0, the "sqlite_stat1" table is an exception to ŸE** some of the rules above. In SQLite, the schema of sqlite_stat1 is:©**  <pre>Ÿ8**  &nbsp;     CREATE TABLE sqlite_stat1(tbl,idx,stat)  ™**  </pre>¢**ŸE** Even though sqlite_stat1 does not have a PRIMARY KEY, changes are ŸM** recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes ŸK** are recorded for rows for which (idx IS NULL) is true. However, for suchŸH** rows a zero-length blob (SQL value X'') is stored in the changeset orŸF** patchset instead of a NULL value. This allows such changesets to beŸF** manipulated by legacy implementations of sqlite3changeset_invert(),∏** concat() and similar.¢**ŸD** The sqlite3changeset_apply() function automatically converts the ŸG** zero-length blob back to a NULL value when updating the sqlite_stat1ŸC** table. However, if the application calls sqlite3changeset_new(),ŸF** sqlite3changeset_old() or sqlite3changeset_conflict on a changeset ŸC** iterator directly (including on a changeset iterator passed to aŸM** conflict-handler callback) then the X'' value is returned. The applicationŸ1** must translate X'' to NULL itself if required.¢**ŸL** Legacy (older than 3.22.0) versions of the sessions module cannot captureŸA** changes made to the sqlite_stat1 table. Legacy versions of theŸM** sqlite3changeset_apply() function silently ignore any modifications to theŸ?** sqlite_stat1 table that are part of a changeset or patchset.¢*/Ÿ%SQLITE_API int sqlite3session_attach(Ÿ6  sqlite3_session *pSession,      /* Session object */Ÿ2  const char *zTab                /* Table name */¢);†¢/*Ÿ4** CAPI3REF: Set a table filter on a Session Object.∫** METHOD: sqlite3_session¢**ŸO** The second argument (xFilter) is the "filter callback". For changes to rows ŸN** in tables that are not attached to the Session object, the filter is calledŸN** to determine whether changes to the table's rows should be tracked or not. ŸK** If xFilter returns 0, changes is not tracked. Note that once a table is Ÿ.** attached, xFilter will not be called again.¢*/Ÿ,SQLITE_API void sqlite3session_table_filter(Ÿ6  sqlite3_session *pSession,      /* Session object */∞  int(*xFilter)(ŸL    void *pCtx,                   /* Copy of third arg to _filter_table() */Ÿ2    const char *zTab              /* Table name */§  ),ŸH  void *pCtx                      /* First argument passed to xFilter */¢);†¢/*Ÿ7** CAPI3REF: Generate A Changeset From A Session Object∫** METHOD: sqlite3_session¢**ŸG** Obtain a changeset containing changes to the tables attached to the Ÿ?** session object passed as the first argument. If successful, ŸB** set *ppChangeset to point to a buffer containing the changeset ŸJ** and *pnChangeset to the size of the changeset in bytes before returningŸK** SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset toŸ(** zero and return an SQLite error code.¢**ŸM** A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes,ŸM** each representing a change to a single row of an attached table. An INSERTŸK** change contains the values of each field of a new database row. A DELETEŸK** contains the original values of each field of a deleted database row. AnŸI** UPDATE change contains the original values of each field of an updatedŸN** database row along with the updated values for each updated non-primary-keyŸM** column. It is not possible for an UPDATE change to represent a change thatŸK** modifies the values of primary key columns. If such a change is made, itŸC** is represented in a changeset as a DELETE followed by an INSERT.¢**ŸL** Changes are not recorded for rows that have NULL values stored in one or ŸK** more of their PRIMARY KEY columns. If such a row is inserted or deleted,ŸH** no corresponding change is present in the changesets returned by thisŸF** function. If an existing row with one or more NULL values stored inŸO** PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL,ŸL** only an INSERT is appears in the changeset. Similarly, if an existing rowŸI** with non-NULL PRIMARY KEY values is updated so that one or more of itsŸJ** PRIMARY KEY columns are set to NULL, the resulting changeset contains a∂** DELETE change only.¢**ŸI** The contents of a changeset may be traversed using an iterator createdŸJ** using the [sqlite3changeset_start()] API. A changeset may be applied toŸK** a database with a compatible schema using the [sqlite3changeset_apply()]ß** API.¢**ŸJ** Within a changeset generated by this function, all changes related to aŸL** single table are grouped together. In other words, when iterating throughŸN** a changeset or when applying a changeset to a database, all changes relatedŸM** to a single table are processed before moving on to the next table. TablesŸN** are sorted in the same order in which they were attached (or auto-attached)ŸK** to the sqlite3_session object. The order in which the changes related toŸ*** a single table are stored is undefined.¢**ŸL** Following a successful call to this function, it is the responsibility ofŸM** the caller to eventually free the buffer that *ppChangeset points to using¥** [sqlite3_free()].¢**Ÿ ** <h3>Changeset Generation</h3>¢**ŸI** Once a table has been attached to a session object, the session objectŸJ** records the primary key values of all new rows inserted into the table.ŸJ** It also records the original primary key and other column values of anyŸK** deleted or updated rows. For each unique primary key value, data is onlyŸJ** recorded once - the first time a row with said primary key is inserted,Ÿ5** updated or deleted in the lifetime of the session.¢**ŸL** There is one exception to the previous paragraph: when a row is inserted,ŸJ** updated or deleted, if one or more of its primary key columns contain aŸ/** NULL value, no record of the change is made.¢**ŸH** The session object therefore accumulates two types of records - thoseŸI** that consist of primary key values only (created when the user insertsŸI** a new record) and those that consist of the primary key values and theŸI** original values of other table columns (created when the users deletes∏** or updates a record).¢**ŸI** When this function is called, the requested changeset is created usingŸH** both the accumulated records and the current contents of the database∂** file. Specifically:¢**ß** <ul>ŸI**   <li> For each record generated by an insert, the database is queriedŸK**        for a row with a matching primary key. If one is found, an INSERTŸO**        change is added to the changeset. If no such row is found, no change Ÿ$**        is added to the changeset.¢**ŸL**   <li> For each record generated by an update or delete, the database is ŸI**        queried for a row with a matching primary key. If such a row isŸG**        found and one or more of the non-primary key fields have beenŸL**        modified from their original values, an UPDATE change is added to ŸL**        the changeset. Or, if no such row is found in the table, a DELETE ŸM**        change is added to the changeset. If there is a row with a matchingŸL**        primary key in the database, but all fields contain their originalŸ6**        values, no change is added to the changeset.®** </ul>¢**ŸM** This means, amongst other things, that if a row is inserted and then laterŸN** deleted while a session object is active, neither the insert nor the deleteŸM** will be present in the changeset. Or if a row is deleted and then later a ŸJ** row with the same primary key values inserted while a session object isŸK** active, the resulting changeset will contain an UPDATE change instead of∫** a DELETE and an INSERT.¢**ŸM** When a session object is disabled (see the [sqlite3session_enable()] API),ŸM** it does not accumulate records when rows are inserted, updated or deleted.ŸI** This may appear to have some counter-intuitive effects if a single rowŸG** is written to more than once during a session. For example, if a rowŸK** is inserted while a session object is enabled, then later deleted while ŸK** the same session object is disabled, no INSERT record will appear in theŸO** changeset, even though the delete took place while the session was disabled.ŸI** Or, if one field of a row is updated while a session is disabled, and ŸM** another field of the same row is updated while the session is enabled, theŸN** resulting changeset will contain an UPDATE change that updates both fields.¢*/Ÿ(SQLITE_API int sqlite3session_changeset(Ÿ6  sqlite3_session *pSession,      /* Session object */ŸK  int *pnChangeset,               /* OUT: Size of buffer at *ppChangeset */ŸH  void **ppChangeset              /* OUT: Buffer containing changeset */¢);†¢/*Ÿ>** CAPI3REF: Load The Difference Between Tables Into A Session∫** METHOD: sqlite3_session¢**ŸJ** If it is not already attached to the session object passed as the firstŸH** argument, this function attaches table zTbl in the same manner as theŸG** [sqlite3session_attach()] function. If zTbl does not exist, or if itŸM** does not have a primary key, this function is a no-op (but does not return≠** an error).¢**ŸH** Argument zFromDb must be the name of a database ("main", "temp" etc.)ŸL** attached to the same database handle as the session object that contains ŸN** a table compatible with the table attached to the session by this function.Ÿ*** A table is considered compatible if it:¢**ß** <ul>º**   <li> Has the same name,ŸE**   <li> Has the same set of columns declared in the same order, andŸ.**   <li> Has the same PRIMARY KEY definition.®** </ul>¢**ŸM** If the tables are not compatible, SQLITE_SCHEMA is returned. If the tablesŸM** are compatible but do not have any PRIMARY KEY columns, it is not an errorŸH** but no changes are added to the session object. As with other sessionŸ8** APIs, tables without PRIMARY KEYs are simply ignored.¢**ŸJ** This function adds a set of changes to the session object that could beŸK** used to update the table in database zFrom (call this the "from-table") ŸH** so that its content is the same as the table attached to the session Ÿ3** object (call this the "to-table"). Specifically:¢**ß** <ul>ŸL**   <li> For each row (primary key) that exists in the to-table but not in ŸG**     the from-table, an INSERT record is added to the session object.¢**ŸL**   <li> For each row (primary key) that exists in the to-table but not in ŸF**     the from-table, a DELETE record is added to the session object.¢**ŸN**   <li> For each row (primary key) that exists in both tables, but features ŸH**     different non-PK values in each, an UPDATE record is added to the±**     session.  ®** </ul>¢**ŸJ** To clarify, if this function is called and then a changeset constructedŸM** using [sqlite3session_changeset()], then after applying that changeset to ŸE** database zFrom the contents of the two compatible tables would be ≠** identical.¢**ŸG** It an error if database zFrom does not exist or does not contain theΩ** required compatible table.¢**ŸK** If the operation successful, SQLITE_OK is returned. Otherwise, an SQLiteŸH** error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsgŸH** may be set to point to a buffer containing an English language error ŸL** message. It is the responsibility of the caller to free this buffer using≤** sqlite3_free().¢*/Ÿ#SQLITE_API int sqlite3session_diff(º  sqlite3_session *pSession,∂  const char *zFromDb,≥  const char *zTbl,±  char **pzErrMsg¢);††¢/*Ÿ6** CAPI3REF: Generate A Patchset From A Session Object∫** METHOD: sqlite3_session¢**Ÿ?** The differences between a patchset and a changeset are that:¢**ß** <ul>ŸE**   <li> DELETE records consist of the primary key fields only. The Ÿ6**        original values of other fields are omitted.ŸF**   <li> The original values of any modified fields are omitted from π**        UPDATE records.®** </ul>¢**Ÿ?** A patchset blob may be used with up to date versions of all ŸL** sqlite3changeset_xxx API functions except for sqlite3changeset_invert(), ŸF** which returns SQLITE_CORRUPT if it is passed a patchset. Similarly,Ÿ=** attempting to use a patchset blob with old versions of theŸD** sqlite3changeset_xxx APIs also provokes an SQLITE_CORRUPT error. ¢**Ÿ>** Because the non-primary key "old.*" fields are omitted, no ŸL** SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchsetŸK** is passed to the sqlite3changeset_apply() API. Other conflict types workŸ%** in the same way as for changesets.¢**ŸJ** Changes within a patchset are ordered in the same way as for changesetsŸM** generated by the sqlite3session_changeset() function (i.e. all changes forŸK** a single table are grouped together, tables appear in the order in whichŸ-** they were attached to the session object).¢*/Ÿ'SQLITE_API int sqlite3session_patchset(Ÿ6  sqlite3_session *pSession,      /* Session object */ŸJ  int *pnPatchset,                /* OUT: Size of buffer at *ppPatchset */ŸG  void **ppPatchset               /* OUT: Buffer containing patchset */¢);†¢/*Ÿ:** CAPI3REF: Test if a changeset has recorded any changes.¢**ŸJ** Return non-zero if no changes to attached tables have been recorded by ŸI** the session object passed as the first argument. Otherwise, if one or Ÿ0** more changes have been recorded, return zero.¢**ŸB** Even if this function returns zero, it is possible that callingŸH** [sqlite3session_changeset()] on the session handle may still return aŸE** changeset that contains no changes. This can happen when a row in ŸG** an attached table is modified and then later on the original values ŸG** are restored. However, if this function returns non-zero, then it isŸF** guaranteed that a call to sqlite3session_changeset() will return a Ÿ%** changeset containing zero changes.¢*/ŸASQLITE_API int sqlite3session_isempty(sqlite3_session *pSession);†¢/*Ÿ8** CAPI3REF: Create An Iterator To Traverse A Changeset Ÿ&** CONSTRUCTOR: sqlite3_changeset_iter¢**ŸJ** Create an iterator used to iterate through the contents of a changeset.ŸJ** If successful, *pp is set to point to the iterator handle and SQLITE_OKŸH** is returned. Otherwise, if an error occurs, *pp is set to zero and anŸ!** SQLite error code is returned.¢**ŸH** The following functions can be used to advance and query a changeset Ÿ%** iterator created by this function:¢**ß** <ul>Ÿ#**   <li> [sqlite3changeset_next()]Ÿ!**   <li> [sqlite3changeset_op()]Ÿ"**   <li> [sqlite3changeset_new()]Ÿ"**   <li> [sqlite3changeset_old()]®** </ul>¢**ŸL** It is the responsibility of the caller to eventually destroy the iteratorŸL** by passing it to [sqlite3changeset_finalize()]. The buffer containing theŸG** changeset (pChangeset) must remain valid until after the iterator is≠** destroyed.¢**Ÿ8** Assuming the changeset blob was created by one of theŸ?** [sqlite3session_changeset()], [sqlite3changeset_concat()] orŸK** [sqlite3changeset_invert()] functions, all changes within the changeset ŸK** that apply to a single table are grouped together. This means that when ŸL** an application iterates through a changeset using an iterator created by ŸH** this function, all changes that relate to a single table are visited ŸK** consecutively. There is no chance that the iterator will visit a change ŸI** the applies to table X, then one for table Y, and then later on visit æ** another change for table X.¢*/Ÿ&SQLITE_API int sqlite3changeset_start(ŸJ  sqlite3_changeset_iter **pp,    /* OUT: New changeset iterator handle */ŸG  int nChangeset,                 /* Size of changeset blob in bytes */ŸL  void *pChangeset                /* Pointer to blob containing changeset */¢);††¢/*Ÿ)** CAPI3REF: Advance A Changeset IteratorŸ!** METHOD: sqlite3_changeset_iter¢**ŸD** This function may only be used with iterators created by functionŸG** [sqlite3changeset_start()]. If it is called on an iterator passed toŸK** a conflict-handler callback by [sqlite3changeset_apply()], SQLITE_MISUSEŸ*** is returned and the call has no effect.¢**ŸK** Immediately after an iterator is created by sqlite3changeset_start(), itŸH** does not point to any change in the changeset. Assuming the changesetŸI** is not empty, the first call to this function advances the iterator toŸL** point to the first change in the changeset. Each subsequent call advancesŸI** the iterator to point to the next change in the changeset (if any). IfŸI** no error occurs and the iterator points to a valid change after a callŸG** to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. ŸH** Otherwise, if all changes in the changeset have already been visited,ª** SQLITE_DONE is returned.¢**ŸH** If an error occurs, an SQLite error code is returned. Possible error ŸH** codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or ∞** SQLITE_NOMEM.¢*/ŸDSQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *pIter);†¢/*ŸC** CAPI3REF: Obtain The Current Operation From A Changeset IteratorŸ!** METHOD: sqlite3_changeset_iter¢**ŸG** The pIter argument passed to this function may either be an iteratorŸM** passed to a conflict-handler by [sqlite3changeset_apply()], or an iteratorŸM** created by [sqlite3changeset_start()]. In the latter case, the most recentŸM** call to [sqlite3changeset_next()] must have returned [SQLITE_ROW]. If thisŸ:** is not the case, this function returns [SQLITE_MISUSE].¢**ŸB** If argument pzTab is not NULL, then *pzTab is set to point to aŸG** nul-terminated utf-8 encoded string containing the name of the tableŸH** affected by the current change. The buffer remains valid until eitherŸB** sqlite3changeset_next() is called on the iterator or until the ŸK** conflict-handler function returns. If pnCol is not NULL, then *pnCol is ŸG** set to the number of columns in the table affected by the change. IfŸM** pbIncorrect is not NULL, then *pbIndirect is set to true (1) if the changeŸK** is an indirect change, or false (0) otherwise. See the documentation forŸG** [sqlite3session_indirect()] for a description of direct and indirectŸD** changes. Finally, if pOp is not NULL, then *pOp is set to one of ŸI** [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE], depending on the Ÿ8** type of change that the iterator currently points to.¢**ŸH** If no error occurs, SQLITE_OK is returned. If an error does occur, anŸL** SQLite error code is returned. The values of the output variables may notª** be trusted in this case.¢*/Ÿ#SQLITE_API int sqlite3changeset_op(Ÿ7  sqlite3_changeset_iter *pIter,  /* Iterator object */ŸB  const char **pzTab,             /* OUT: Pointer to table name */ŸG  int *pnCol,                     /* OUT: Number of columns in table */ŸL  int *pOp,                       /* OUT: SQLITE_INSERT, DELETE or UPDATE */ŸJ  int *pbIndirect                 /* OUT: True for an 'indirect' change */¢);†¢/*Ÿ9** CAPI3REF: Obtain The Primary Key Definition Of A TableŸ!** METHOD: sqlite3_changeset_iter¢**Ÿ?** For each modified table, a changeset includes the following:¢**ß** <ul>Ÿ1**   <li> The number of columns in the table, andŸ@**   <li> Which of those columns make up the tables PRIMARY KEY.®** </ul>¢**ŸJ** This function is used to find which columns comprise the PRIMARY KEY ofŸL** the table modified by the change that iterator pIter currently points to.ŸK** If successful, *pabPK is set to point to an array of nCol entries, whereŸL** nCol is the number of columns in the table. Elements of *pabPK are set toŸI** 0x01 if the corresponding column is part of the tables primary key, orµ** 0x00 if it is not.¢**ŸM** If argument pnCol is not NULL, then *pnCol is set to the number of columns∞** in the table.¢**ŸI** If this function is called when the iterator does not point to a validŸO** entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise,ŸH** SQLITE_OK is returned and the output variables populated as described©** above.¢*/Ÿ#SQLITE_API int sqlite3changeset_pk(Ÿ7  sqlite3_changeset_iter *pIter,  /* Iterator object */ŸP  unsigned char **pabPK,          /* OUT: Array of boolean - true for PK cols */ŸN  int *pnCol                      /* OUT: Number of entries in output array */¢);†¢/*Ÿ:** CAPI3REF: Obtain old.* Values From A Changeset IteratorŸ!** METHOD: sqlite3_changeset_iter¢**ŸG** The pIter argument passed to this function may either be an iteratorŸM** passed to a conflict-handler by [sqlite3changeset_apply()], or an iteratorŸM** created by [sqlite3changeset_start()]. In the latter case, the most recentŸD** call to [sqlite3changeset_next()] must have returned SQLITE_ROW. ŸM** Furthermore, it may only be called if the type of change that the iteratorŸO** currently points to is either [SQLITE_DELETE] or [SQLITE_UPDATE]. Otherwise,ŸC** this function returns [SQLITE_MISUSE] and sets *ppValue to NULL.¢**ŸM** Argument iVal must be greater than or equal to 0, and less than the numberŸE** of columns in the table affected by the current change. Otherwise,Ÿ:** [SQLITE_RANGE] is returned and *ppValue is set to NULL.¢**ŸE** If successful, this function sets *ppValue to point to a protectedŸH** sqlite3_value object containing the iVal'th value from the vector of ŸH** original row values stored as part of the UPDATE or DELETE change andŸM** returns SQLITE_OK. The name of the function comes from the fact that this ŸL** is similar to the "old.*" columns available to update or delete triggers.¢**ŸK** If some other error occurs (e.g. an OOM condition), an SQLite error codeŸ+** is returned and *ppValue is set to NULL.¢*/Ÿ$SQLITE_API int sqlite3changeset_old(Ÿ:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */Ÿ5  int iVal,                       /* Column number */ŸH  sqlite3_value **ppValue         /* OUT: Old value (or NULL pointer) */¢);†¢/*Ÿ:** CAPI3REF: Obtain new.* Values From A Changeset IteratorŸ!** METHOD: sqlite3_changeset_iter¢**ŸG** The pIter argument passed to this function may either be an iteratorŸM** passed to a conflict-handler by [sqlite3changeset_apply()], or an iteratorŸM** created by [sqlite3changeset_start()]. In the latter case, the most recentŸD** call to [sqlite3changeset_next()] must have returned SQLITE_ROW. ŸM** Furthermore, it may only be called if the type of change that the iteratorŸO** currently points to is either [SQLITE_UPDATE] or [SQLITE_INSERT]. Otherwise,ŸC** this function returns [SQLITE_MISUSE] and sets *ppValue to NULL.¢**ŸM** Argument iVal must be greater than or equal to 0, and less than the numberŸE** of columns in the table affected by the current change. Otherwise,Ÿ:** [SQLITE_RANGE] is returned and *ppValue is set to NULL.¢**ŸE** If successful, this function sets *ppValue to point to a protectedŸH** sqlite3_value object containing the iVal'th value from the vector of ŸC** new row values stored as part of the UPDATE or INSERT change andŸE** returns SQLITE_OK. If the change is an UPDATE and does not includeŸE** a new value for the requested column, *ppValue is set to NULL and ŸI** SQLITE_OK returned. The name of the function comes from the fact that ŸH** this is similar to the "new.*" columns available to update or delete ¨** triggers.¢**ŸK** If some other error occurs (e.g. an OOM condition), an SQLite error codeŸ+** is returned and *ppValue is set to NULL.¢*/Ÿ$SQLITE_API int sqlite3changeset_new(Ÿ:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */Ÿ5  int iVal,                       /* Column number */ŸH  sqlite3_value **ppValue         /* OUT: New value (or NULL pointer) */¢);†¢/*ŸD** CAPI3REF: Obtain Conflicting Row Values From A Changeset IteratorŸ!** METHOD: sqlite3_changeset_iter¢**ŸF** This function should only be used with iterator objects passed to aŸF** conflict-handler callback by [sqlite3changeset_apply()] with eitherŸK** [SQLITE_CHANGESET_DATA] or [SQLITE_CHANGESET_CONFLICT]. If this functionŸL** is called on any other iterator, [SQLITE_MISUSE] is returned and *ppValue≤** is set to NULL.¢**ŸM** Argument iVal must be greater than or equal to 0, and less than the numberŸE** of columns in the table affected by the current change. Otherwise,Ÿ:** [SQLITE_RANGE] is returned and *ppValue is set to NULL.¢**ŸE** If successful, this function sets *ppValue to point to a protectedŸ>** sqlite3_value object containing the iVal'th value from the ŸJ** "conflicting row" associated with the current conflict-handler callbackπ** and returns SQLITE_OK.¢**ŸK** If some other error occurs (e.g. an OOM condition), an SQLite error codeŸ+** is returned and *ppValue is set to NULL.¢*/Ÿ)SQLITE_API int sqlite3changeset_conflict(Ÿ:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */Ÿ5  int iVal,                       /* Column number */ŸG  sqlite3_value **ppValue         /* OUT: Value from conflicting row */¢);†¢/*ŸF** CAPI3REF: Determine The Number Of Foreign Key Constraint ViolationsŸ!** METHOD: sqlite3_changeset_iter¢**ŸA** This function may only be called with an iterator passed to anŸG** SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this caseŸG** it sets the output variable to the total number of known foreign keyŸ@** violations in the destination database and returns SQLITE_OK.¢**Ÿ:** In all other cases this function returns SQLITE_MISUSE.¢*/Ÿ-SQLITE_API int sqlite3changeset_fk_conflicts(Ÿ:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */ŸD  int *pnOut                      /* OUT: Number of FK violations */¢);††¢/*Ÿ*** CAPI3REF: Finalize A Changeset IteratorŸ!** METHOD: sqlite3_changeset_iter¢**Ÿ?** This function is used to finalize an iterator allocated withæ** [sqlite3changeset_start()].¢**ŸE** This function should only be called on iterators created using theŸD** [sqlite3changeset_start()] function. If an application calls thisŸ<** function with an iterator passed to a conflict-handler byŸN** [sqlite3changeset_apply()], [SQLITE_MISUSE] is immediately returned and the∂** call has no effect.¢**ŸI** If an error was encountered within a call to an sqlite3changeset_xxx()ŸP** function (for example an [SQLITE_CORRUPT] in [sqlite3changeset_next()] or an ŸO** [SQLITE_NOMEM] in [sqlite3changeset_new()]) then an error code correspondingŸF** to that error is returned by this function. Otherwise, SQLITE_OK isŸB** returned. This is to allow the following pattern (pseudo-code):¢**®** <pre>æ**   sqlite3changeset_start();Ÿ2**   while( SQLITE_ROW==sqlite3changeset_next() ){Ÿ#**     // Do something with change.¶**   }Ÿ&**   rc = sqlite3changeset_finalize();π**   if( rc!=SQLITE_OK ){Ÿ **     // An error has occurred ¶**   }©** </pre>¢*/ŸHSQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter);†¢/*ø** CAPI3REF: Invert A Changeset¢**ŸM** This function is used to "invert" a changeset object. Applying an invertedŸJ** changeset to a database reverses the effects of applying the uninvertedª** changeset. Specifically:¢**ß** <ul>Ÿ9**   <li> Each DELETE change is changed to an INSERT, andŸ8**   <li> Each INSERT change is changed to a DELETE, andŸK**   <li> For each UPDATE change, the old.* and new.* values are exchanged.®** </ul>¢**ŸI** This function does not change the order in which changes appear withinŸI** the changeset. It merely reverses the sense of each individual change.¢**ŸI** If successful, a pointer to a buffer containing the inverted changesetŸL** is stored in *ppOut, the size of the same buffer is stored in *pnOut, andŸH** SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut areŸ,** zeroed and an SQLite error code returned.¢**ŸK** It is the responsibility of the caller to eventually call sqlite3_free()ŸN** on the *ppOut pointer to free the buffer allocation following a successful π** call to this function.¢**ŸJ** WARNING/TODO: This function currently assumes that the input is a validŸ6** changeset. If it is not, the results are undefined.¢*/Ÿ'SQLITE_API int sqlite3changeset_invert(Ÿ7  int nIn, const void *pIn,       /* Input changeset */Ÿ=  int *pnOut, void **ppOut        /* OUT: Inverse of input */¢);†¢/*Ÿ.** CAPI3REF: Concatenate Two Changeset Objects¢**ŸH** This function is used to concatenate two changesets, A and B, into a ŸE** single changeset. The result is a changeset equivalent to applyingŸ(** changeset A followed by changeset B. ¢**Ÿ<** This function combines the two input changesets using an ŸI** sqlite3_changegroup object. Calling it produces similar results as theª** following code fragment:¢**®** <pre>ø**   sqlite3_changegroup *pGrp;Ÿ)**   rc = sqlite3_changegroup_new(&pGrp);ŸC**   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nA, pA);ŸC**   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nB, pB);π**   if( rc==SQLITE_OK ){Ÿ:**     rc = sqlite3changegroup_output(pGrp, pnOut, ppOut);´**   }else{≤**     *ppOut = 0;≤**     *pnOut = 0;¶**   }©** </pre>¢**ŸD** Refer to the sqlite3_changegroup documentation below for details.¢*/Ÿ'SQLITE_API int sqlite3changeset_concat(ŸD  int nA,                         /* Number of bytes in buffer pA */ŸP  void *pA,                       /* Pointer to buffer containing changeset A */ŸD  int nB,                         /* Number of bytes in buffer pB */ŸP  void *pB,                       /* Pointer to buffer containing changeset B */ŸP  int *pnOut,                     /* OUT: Number of bytes in output changeset */ŸO  void **ppOut                    /* OUT: Buffer containing output changeset */¢);††¢/*ø** CAPI3REF: Changegroup Handle¢**Ÿ:** A changegroup is an object used to combine two or more æ** [changesets] or [patchsets]¢*/Ÿ7typedef struct sqlite3_changegroup sqlite3_changegroup;†¢/*Ÿ,** CAPI3REF: Create A New Changegroup ObjectŸ#** CONSTRUCTOR: sqlite3_changegroup¢**ŸJ** An sqlite3_changegroup object is used to combine two or more changesetsŸM** (or patchsets) into a single changeset (or patchset). A single changegroupŸJ** object may combine changesets or patchsets, but not both. The output isŸ*** always in the same format as the input.¢**ŸJ** If successful, this function returns SQLITE_OK and populates (*pp) withŸM** a pointer to a new sqlite3_changegroup object before returning. The callerŸ>** should eventually free the returned object using a call to ŸH** sqlite3changegroup_delete(). If an error occurs, an SQLite error codeŸ:** (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.¢**ŸK** The usual usage pattern for an sqlite3_changegroup object is as follows:¢**ß** <ul>ŸA**   <li> It is created using a call to sqlite3changegroup_new().¢**ŸH**   <li> Zero or more changesets (or patchsets) are added to the objectŸ.**        by calling sqlite3changegroup_add().¢**ŸL**   <li> The result of combining all input changesets together is obtained ŸG**        by the application via a call to sqlite3changegroup_output().¢**ŸL**   <li> The object is deleted using a call to sqlite3changegroup_delete().®** </ul>¢**ŸM** Any number of calls to add() and output() may be made between the calls toŸ(** new() and delete(), and in any order.¢**Ÿ7** As well as the regular sqlite3changegroup_add() and ŸJ** sqlite3changegroup_output() functions, also available are the streamingŸO** versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().¢*/Ÿ@SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp);†¢/*Ÿ-** CAPI3REF: Add A Changeset To A Changegroupæ** METHOD: sqlite3_changegroup¢**ŸK** Add all changes within the changeset (or patchset) in buffer pData (sizeŸ$** nData bytes) to the changegroup. ¢**ŸK** If the buffer contains a patchset, then all prior calls to this functionŸL** on the same changegroup object must also have specified patchsets. Or, ifŸJ** the buffer contains a changeset, so must have the earlier calls to thisŸI** function. Otherwise, SQLITE_ERROR is returned and no changes are added∂** to the changegroup.¢**ŸL** Rows within the changeset and changegroup are identified by the values inŸH** their PRIMARY KEY columns. A change in the changeset is considered toŸJ** apply to the same row as a change already present in the changegroup ifŸ*** the two rows have the same primary key.¢**ŸD** Changes to rows that do not already appear in the changegroup areŸK** simply copied into it. Or, if both the new changeset and the changegroupŸH** contain changes that apply to a single row, the final contents of theŸ>** changegroup depends on the type of each change, as follows:¢**Ÿ<** <table border=1 style="margin-left:8ex;margin-right:8ex">Ÿ;**   <tr><th style="white-space:pre">Existing Change  </th>Ÿ;**       <th style="white-space:pre">New Change       </th>∫**       <th>Output ChangeŸ#**   <tr><td>INSERT <td>INSERT <td>ŸG**       The new change is ignored. This case does not occur if the newŸH**       changeset was recorded immediately after the changesets alreadyŸ"**       added to the changegroup.Ÿ#**   <tr><td>INSERT <td>UPDATE <td>ŸI**       The INSERT change remains in the changegroup. The values in the ŸE**       INSERT change are modified as if the row was inserted by theŸF**       existing change and then updated according to the new change.Ÿ#**   <tr><td>INSERT <td>DELETE <td>ŸK**       The existing INSERT is removed from the changegroup. The DELETE is≥**       not added.Ÿ#**   <tr><td>UPDATE <td>INSERT <td>ŸG**       The new change is ignored. This case does not occur if the newŸH**       changeset was recorded immediately after the changesets alreadyŸ"**       added to the changegroup.Ÿ#**   <tr><td>UPDATE <td>UPDATE <td>ŸK**       The existing UPDATE remains within the changegroup. It is amended ŸL**       so that the accompanying values are as if the row was updated once ŸA**       by the existing change and then again by the new change.Ÿ#**   <tr><td>UPDATE <td>DELETE <td>ŸE**       The existing UPDATE is replaced by the new DELETE within theµ**       changegroup.Ÿ#**   <tr><td>DELETE <td>INSERT <td>ŸG**       If one or more of the column values in the row inserted by theŸI**       new change differ from those in the row deleted by the existing ŸH**       change, the existing DELETE is replaced by an UPDATE within theŸI**       changegroup. Otherwise, if the inserted row is exactly the same ŸE**       as the deleted row, the existing DELETE is simply discarded.Ÿ#**   <tr><td>DELETE <td>UPDATE <td>ŸG**       The new change is ignored. This case does not occur if the newŸH**       changeset was recorded immediately after the changesets alreadyŸ"**       added to the changegroup.Ÿ#**   <tr><td>DELETE <td>DELETE <td>ŸG**       The new change is ignored. This case does not occur if the newŸH**       changeset was recorded immediately after the changesets alreadyŸ"**       added to the changegroup.´** </table>¢**ŸK** If the new changeset contains changes to a table that is already presentŸI** in the changegroup, then the number of columns and the position of theŸK** primary key columns for the table must be consistent. If this is not theŸG** case, this function fails with SQLITE_SCHEMA. If the input changesetŸJ** appears to be corrupt and the corruption is detected, SQLITE_CORRUPT isŸM** returned. Or, if an out-of-memory condition occurs during processing, thisŸF** function returns SQLITE_NOMEM. In all cases, if an error occurs theŸ2** final contents of the changegroup is undefined.¢**Ÿ-** If no error occurs, SQLITE_OK is returned.¢*/ŸTSQLITE_API int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);†¢/*Ÿ<** CAPI3REF: Obtain A Composite Changeset From A Changegroupæ** METHOD: sqlite3_changegroup¢**ŸH** Obtain a buffer containing a changeset (or patchset) representing theŸH** current contents of the changegroup. If the inputs to the changegroupŸD** were themselves changesets, the output is a changeset. Or, if theŸ8** inputs were patchsets, the output is also a patchset.¢**Ÿ;** As with the output of the sqlite3session_changeset() andŸG** sqlite3session_patchset() functions, all changes related to a singleŸK** table are grouped together in the output of this function. Tables appearŸN** in the same order as for the very first changeset added to the changegroup.ŸJ** If the second or subsequent changesets added to the changegroup containŸI** changes for tables that do not appear in the first changeset, they areŸG** appended onto the end of the output changeset, again in the order inŸ$** which they are first encountered.¢**ŸF** If an error occurs, an SQLite error code is returned and the outputŸG** variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OKŸE** is returned and the output variables are set to the size of and a ŸE** pointer to the output buffer, respectively. In this case it is theŸE** responsibility of the caller to eventually free the buffer using a∫** call to sqlite3_free().¢*/Ÿ)SQLITE_API int sqlite3changegroup_output(∑  sqlite3_changegroup*,ŸK  int *pnData,                    /* OUT: Size of output buffer in bytes */ŸE  void **ppData                   /* OUT: Pointer to output buffer */¢);†¢/*Ÿ(** CAPI3REF: Delete A Changegroup ObjectŸ"** DESTRUCTOR: sqlite3_changegroup¢*/Ÿ@SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*);†¢/*Ÿ,** CAPI3REF: Apply A Changeset To A Database¢**ŸJ** Apply a changeset or patchset to a database. These functions attempt toŸM** update the "main" database attached to handle db with the changes found inŸ<** the changeset passed via the second and third arguments. ¢**ŸI** The fourth argument (xFilter) passed to these functions is the "filterŸM** callback". If it is not NULL, then for each table affected by at least oneŸ?** change in the changeset, the filter callback is invoked withŸK** the table name as the second argument, and a copy of the context pointerŸF** passed as the sixth argument as the first. If the "filter callback"ŸK** returns zero, then no attempt is made to apply any changes to the table.ŸH** Otherwise, if the return value is non-zero or the xFilter argument toŸ;** is NULL, all changes related to the table are attempted.¢**ŸM** For each table that is not excluded by the filter callback, this function ŸJ** tests that the target database contains a compatible table. A table is Ÿ:** considered compatible if all of the following are true:¢**ß** <ul>ŸB**   <li> The table has the same name as the name recorded in the ∏**        changeset, andŸD**   <li> The table has at least as many columns as recorded in the ∏**        changeset, andŸD**   <li> The table has primary key columns in the same position as Ÿ$**        recorded in the changeset.®** </ul>¢**ŸG** If there is no compatible table, it is not an error, but none of theŸM** changes associated with the table are applied. A warning message is issuedŸM** via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At mostŸ>** one such warning is issued for each table in the changeset.¢**ŸM** For each change for which there is a compatible table, an attempt is made ŸJ** to modify the table contents according to the UPDATE, INSERT or DELETE ŸG** change. If a change cannot be applied cleanly, the conflict handler ŸL** function passed as the fifth argument to sqlite3changeset_apply() may be ŸN** invoked. A description of exactly when the conflict handler is invoked for Ÿ ** each type of change is below.¢**ŸM** Unlike the xFilter argument, xConflict may not be passed NULL. The resultsŸK** of passing anything other than a valid function pointer as the xConflict∫** argument are undefined.¢**ŸI** Each time the conflict handler function is invoked, it must return oneŸ;** of [SQLITE_CHANGESET_OMIT], [SQLITE_CHANGESET_ABORT] or ŸL** [SQLITE_CHANGESET_REPLACE]. SQLITE_CHANGESET_REPLACE may only be returnedŸB** if the second argument passed to the conflict handler is eitherŸN** SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handlerŸI** returns an illegal value, any changes already made are rolled back andŸI** the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different ŸG** actions are taken by sqlite3changeset_apply() depending on the valueŸI** returned by each invocation of the conflict-handler function. Refer toŸ#** the documentation for the three Ÿ?** [SQLITE_CHANGESET_OMIT|available return values] for details.¢**ß** <dl>π** <dt>DELETE Changes<dd>ŸH**   For each DELETE change, the function checks if the target database ŸG**   contains a row with the same primary key value (or values) as the ŸM**   original row values stored in the changeset. If it does, and the values ŸK**   stored in all non-primary key columns also match the values stored in Ÿ?**   the changeset the row is deleted from the target database.¢**ŸK**   If a row with matching primary key values is found, but one or more ofŸL**   the non-primary key fields contains a value different from the originalŸH**   row value stored in the changeset, the conflict-handler function isŸH**   invoked with [SQLITE_CHANGESET_DATA] as the second argument. If theŸH**   database table has more columns than are recorded in the changeset,ŸI**   only the values of those non-primary key fields are compared againstŸH**   the current database contents - any trailing database table columns±**   are ignored.¢**ŸI**   If no row with matching primary key values is found in the database,ŸN**   the conflict-handler function is invoked with [SQLITE_CHANGESET_NOTFOUND]Ÿ#**   passed as the second argument.¢**ŸO**   If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINTŸI**   (which can only happen if a foreign key constraint is violated), theŸL**   conflict-handler function is invoked with [SQLITE_CHANGESET_CONSTRAINT]ŸK**   passed as the second argument. This includes the case where the DELETEŸK**   operation is attempted because an earlier call to the conflict handlerŸ2**   function returned [SQLITE_CHANGESET_REPLACE].¢**π** <dt>INSERT Changes<dd>ŸJ**   For each INSERT change, an attempt is made to insert the new row intoŸF**   the database. If the changeset row contains fewer fields than theŸI**   database table, the trailing fields are populated with their default¨**   values.¢**ŸI**   If the attempt to insert the row fails because the database already ŸJ**   contains a row with the same primary key values, the conflict handlerŸ9**   function is invoked with the second argument set to Ÿ!**   [SQLITE_CHANGESET_CONFLICT].¢**ŸL**   If the attempt to insert the row fails because of some other constraintŸK**   violation (e.g. NOT NULL or UNIQUE), the conflict handler function is ŸK**   invoked with the second argument set to [SQLITE_CHANGESET_CONSTRAINT].ŸO**   This includes the case where the INSERT operation is re-attempted because Ÿ?**   an earlier call to the conflict handler function returned Ÿ **   [SQLITE_CHANGESET_REPLACE].¢**π** <dt>UPDATE Changes<dd>ŸH**   For each UPDATE change, the function checks if the target database ŸG**   contains a row with the same primary key value (or values) as the ŸM**   original row values stored in the changeset. If it does, and the values ŸI**   stored in all modified non-primary key columns also match the valuesŸK**   stored in the changeset the row is updated within the target database.¢**ŸK**   If a row with matching primary key values is found, but one or more ofŸK**   the modified non-primary key fields contains a value different from anŸN**   original row value stored in the changeset, the conflict-handler functionŸJ**   is invoked with [SQLITE_CHANGESET_DATA] as the second argument. SinceŸK**   UPDATE changes only contain values for non-primary key fields that areŸK**   to be modified, only those fields need to match the original values toŸ?**   avoid the SQLITE_CHANGESET_DATA conflict-handler callback.¢**ŸI**   If no row with matching primary key values is found in the database,ŸN**   the conflict-handler function is invoked with [SQLITE_CHANGESET_NOTFOUND]Ÿ#**   passed as the second argument.¢**Ÿ>**   If the UPDATE operation is attempted, but SQLite returns ŸF**   SQLITE_CONSTRAINT, the conflict-handler function is invoked with ŸA**   [SQLITE_CHANGESET_CONSTRAINT] passed as the second argument.ŸJ**   This includes the case where the UPDATE operation is attempted after Ÿ>**   an earlier call to the conflict handler function returnedŸ"**   [SQLITE_CHANGESET_REPLACE].  ®** </dl>¢**ŸJ** It is safe to execute SQL statements, including those that write to theŸJ** table that the callback related to, from within the xConflict callback.ŸB** This can be used to further customize the applications conflict∑** resolution strategy.¢**ŸO** All changes made by these functions are enclosed in a savepoint transaction.ŸI** If any other error (aside from a constraint failure when attempting toŸJ** write to the target database) occurs, then the savepoint transaction isŸL** rolled back, restoring the target database to its original state, and an æ** SQLite error code returned.¢**ŸF** If the output parameters (ppRebase) and (pnRebase) are non-NULL andŸN** the input is a changeset (not a patchset), then sqlite3changeset_apply_v2()ŸH** may set (*ppRebase) to point to a "rebase" that may be used with the ŸI** sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase)ŸM** is set to the size of the buffer in bytes. It is the responsibility of theŸM** caller to eventually free any such buffer using sqlite3_free(). The bufferŸL** is only allocated and populated if one or more conflicts were encounteredŸL** while applying the patchset. See comments surrounding the sqlite3_rebaserº** APIs for further details.¢**ŸK** The behavior of sqlite3changeset_apply_v2() and its streaming equivalentŸ.** may be modified by passing a combination ofŸN** [SQLITE_CHANGESETAPPLY_NOSAVEPOINT | supported flags] as the 9th parameter.¢**ŸM** Note that the sqlite3changeset_apply_v2() API is still <b>experimental</b>Ÿ#** and therefore subject to change.¢*/Ÿ&SQLITE_API int sqlite3changeset_apply(ŸP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ŸB  int nChangeset,                 /* Size of changeset in bytes */Ÿ6  void *pChangeset,               /* Changeset blob */∞  int(*xFilter)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ÿ2    const char *zTab              /* Table name */§  ),≤  int(*xConflict)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */ŸK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ŸM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */§  ),ŸJ  void *pCtx                      /* First argument passed to xConflict */¢);Ÿ)SQLITE_API int sqlite3changeset_apply_v2(ŸP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ŸB  int nChangeset,                 /* Size of changeset in bytes */Ÿ6  void *pChangeset,               /* Changeset blob */∞  int(*xFilter)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ÿ2    const char *zTab              /* Table name */§  ),≤  int(*xConflict)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */ŸK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ŸM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */§  ),ŸJ  void *pCtx,                     /* First argument passed to xConflict */Ÿ8  void **ppRebase, int *pnRebase, /* OUT: Rebase data */ŸL  int flags                       /* Combination of SESSION_APPLY_* flags */¢);†¢/*Ÿ0** CAPI3REF: Flags for sqlite3changeset_apply_v2¢**Ÿ:** The following flags may passed via the 9th parameter toŸD** [sqlite3changeset_apply_v2] and [sqlite3changeset_apply_v2_strm]:¢**ß** <dl>Ÿ-** <dt>SQLITE_CHANGESETAPPLY_NOSAVEPOINT <dd>ŸF**   Usually, the sessions module encloses all operations performed byŸI**   a single call to apply_v2() or apply_v2_strm() in a [SAVEPOINT]. TheŸH**   SAVEPOINT is committed if the changeset or patchset is successfullyŸE**   applied, or rolled back if an error occurs. Specifying this flagŸL**   causes the sessions module to omit this savepoint. In this case, if theŸL**   caller has an open transaction or savepoint when apply_v2() is called, ŸF**   it may revert the partially applied changeset by rolling it back.¢*/Ÿ2#define SQLITE_CHANGESETAPPLY_NOSAVEPOINT   0x0001†£/* Ÿ5** CAPI3REF: Constants Passed To The Conflict Handler¢**ŸJ** Values that may be passed as the second argument to a conflict-handler.¢**ß** <dl>Ÿ ** <dt>SQLITE_CHANGESET_DATA<dd>ŸO**   The conflict handler is invoked with CHANGESET_DATA as the second argumentŸI**   when processing a DELETE or UPDATE change if a row with the requiredŸJ**   PRIMARY KEY fields is present in the database, but one or more other ŸH**   (non primary-key) fields modified by the update do not contain the æ**   expected "before" values.£** ŸM**   The conflicting row, in this case, is the database row with the matching±**   primary key.£** Ÿ$** <dt>SQLITE_CHANGESET_NOTFOUND<dd>ŸJ**   The conflict handler is invoked with CHANGESET_NOTFOUND as the secondŸI**   argument when processing a DELETE or UPDATE change if a row with theŸ@**   required PRIMARY KEY fields is not present in the database.£** ŸJ**   There is no conflicting row in this case. The results of invoking theŸ3**   sqlite3changeset_conflict() API are undefined.£** Ÿ$** <dt>SQLITE_CHANGESET_CONFLICT<dd>ŸH**   CHANGESET_CONFLICT is passed as the second argument to the conflictŸM**   handler while processing an INSERT change if the operation would result Ÿ%**   in duplicate primary key values.£** ŸK**   The conflicting row in this case is the database row with the matching±**   primary key.¢**Ÿ'** <dt>SQLITE_CHANGESET_FOREIGN_KEY<dd>ŸL**   If foreign key handling is enabled, and applying a changeset leaves theŸI**   database in a state containing foreign key violations, the conflict ŸI**   handler is invoked with CHANGESET_FOREIGN_KEY as the second argumentŸL**   exactly once before the changeset is committed. If the conflict handlerŸI**   returns CHANGESET_OMIT, the changes, including those that caused theŸG**   foreign key constraint violation, are committed. Or, if it returnsŸ3**   CHANGESET_ABORT, the changeset is rolled back.¢**ŸM**   No current or conflicting row information is provided. The only functionŸI**   it is possible to call on the supplied sqlite3_changeset_iter handleŸ(**   is sqlite3changeset_fk_conflicts().£** Ÿ&** <dt>SQLITE_CHANGESET_CONSTRAINT<dd>ŸL**   If any other constraint violation occurs while applying a change (i.e. ŸF**   a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is Ÿ>**   invoked with CHANGESET_CONSTRAINT as the second argument.£** ŸJ**   There is no conflicting row in this case. The results of invoking theŸ3**   sqlite3changeset_conflict() API are undefined.¢**®** </dl>¢*/Ÿ&#define SQLITE_CHANGESET_DATA        1Ÿ&#define SQLITE_CHANGESET_NOTFOUND    2Ÿ&#define SQLITE_CHANGESET_CONFLICT    3Ÿ&#define SQLITE_CHANGESET_CONSTRAINT  4Ÿ&#define SQLITE_CHANGESET_FOREIGN_KEY 5†£/* Ÿ7** CAPI3REF: Constants Returned By The Conflict Handler¢**ŸM** A conflict handler callback must return one of the following three values.¢**ß** <dl>Ÿ ** <dt>SQLITE_CHANGESET_OMIT<dd>ŸM**   If a conflict handler returns this value no special action is taken. TheŸH**   change that caused the conflict is not applied. The session module Ÿ3**   continues to the next change in the changeset.¢**Ÿ#** <dt>SQLITE_CHANGESET_REPLACE<dd>ŸK**   This value may only be returned if the second argument to the conflictŸL**   handler was SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If thisŸI**   is not the case, any changes applied so far are rolled back and the Ÿ<**   call to sqlite3changeset_apply() returns SQLITE_MISUSE.¢**ŸJ**   If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflictŸN**   handler, then the conflicting row is either updated or deleted, dependingª**   on the type of change.¢**ŸN**   If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflictŸI**   handler, then the conflicting row is removed from the database and aŸN**   second attempt to apply the change is made. If this second attempt fails,ŸD**   the original row is restored to the database before continuing.¢**Ÿ!** <dt>SQLITE_CHANGESET_ABORT<dd>ŸK**   If this value is returned, any changes applied so far are rolled back ŸC**   and the call to sqlite3changeset_apply() returns SQLITE_ABORT.®** </dl>¢*/Ÿ%#define SQLITE_CHANGESET_OMIT       0Ÿ%#define SQLITE_CHANGESET_REPLACE    1Ÿ%#define SQLITE_CHANGESET_ABORT      2†£/* Ÿ ** CAPI3REF: Rebasing changesetsØ** EXPERIMENTAL¢**ŸC** Suppose there is a site hosting a database in state S0. And thatŸC** modifications are made that move that database to state S1 and aŸF** changeset recorded (the "local" changeset). Then, a changeset basedŸD** on S0 is received from another site (the "remote" changeset) and Ÿ:** applied to the database. The database is then in state Ÿ?** (S1+"remote"), where the exact state depends on any conflictŸG** resolution decisions (OMIT or REPLACE) made while applying "remote".Ÿ?** Rebasing a changeset is to update it to take those conflict Ÿ@** resolution decisions into account, so that the same conflictsŸ8** do not have to be resolved elsewhere in the network. ¢**ŸB** For example, if both the local and remote changesets contain anŸA** INSERT of the same key on "CREATE TABLE t1(a PRIMARY KEY, b)":¢**Ÿ,**   local:  INSERT INTO t1 VALUES(1, 'v1');Ÿ,**   remote: INSERT INTO t1 VALUES(1, 'v2');¢**ŸD** and the conflict resolution is REPLACE, then the INSERT change isŸC** removed from the local changeset (it was overridden). Or, if theŸG** conflict resolution was "OMIT", then the local changeset is modified∂** to instead contain:¢**Ÿ.**           UPDATE t1 SET b = 'v2' WHERE a=1;¢**Ÿ=** Changes within the local changeset are rebased as follows:¢**ß** <dl>∑** <dt>Local INSERT<dd>ŸB**   This may only conflict with a remote INSERT. If the conflict ŸB**   resolution was OMIT, then add an UPDATE change to the rebasedŸ?**   changeset. Or, if the conflict resolution was REPLACE, addŸ&**   nothing to the rebased changeset.¢**∑** <dt>Local DELETE<dd>ŸH**   This may conflict with a remote UPDATE or DELETE. In both cases theŸD**   only possible resolution is OMIT. If the remote operation was aŸG**   DELETE, then add no change to the rebased changeset. If the remoteŸI**   operation was an UPDATE, then the old.* fields of change are updatedŸ/**   to reflect the new.* values in the UPDATE.¢**∑** <dt>Local UPDATE<dd>ŸF**   This may conflict with a remote UPDATE or DELETE. If it conflictsŸI**   with a DELETE, and the conflict resolution was OMIT, then the updateŸH**   is changed into an INSERT. Any undefined values in the new.* recordŸE**   from the update change are filled in using the old.* values fromŸH**   the conflicting DELETE. Or, if the conflict resolution was REPLACE,ŸD**   the UPDATE change is simply omitted from the rebased changeset.¢**ŸI**   If conflict is with a remote UPDATE and the resolution is OMIT, thenŸF**   the old.* values are rebased using the new.* values in the remoteŸH**   change. Or, if the resolution is REPLACE, then the change is copiedŸG**   into the rebased changeset with updates to columns also updated byŸK**   the conflicting remote UPDATE removed. If this means no columns would Ÿ'**   be updated, the change is omitted.®** </dl>¢**ŸA** A local change may be rebased against multiple remote changes ŸB** simultaneously. If a single key is modified by multiple remote ŸF** changesets, they are combined as follows before the local changesetÆ** is rebased:¢**ß** <ul>ŸA**    <li> If there has been one or more REPLACE resolutions on aŸ5**         key, it is rebased according to a REPLACE.¢**ŸC**    <li> If there have been no REPLACE resolutions on a key, thenŸF**         the local changeset is rebased according to the most recentŸ#**         of the OMIT resolutions.®** </ul>¢**ŸF** Note that conflict resolutions from multiple remote changesets are ŸF** combined on a per-field basis, not per-row. This means that in the ŸF** case of multiple remote UPDATE operations, some fields of a single ŸH** local change may be rebased for REPLACE while others are rebased for ®** OMIT.¢**ŸH** In order to rebase a local changeset, the remote changeset must firstŸI** be applied to the local database using sqlite3changeset_apply_v2() andŸ3** the buffer of rebase information captured. Then:¢**ß** <ol>Ÿ:**   <li> An sqlite3_rebaser object is created by calling Ÿ"**        sqlite3rebaser_create().ŸK**   <li> The new object is configured with the rebase buffer obtained fromŸL**        sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure().ŸI**        If the local changeset is to be rebased against multiple remoteŸF**        changesets, then sqlite3rebaser_configure() should be calledŸ=**        multiple times, in the same order that the multipleŸ6**        sqlite3changeset_apply_v2() calls were made.ŸM**   <li> Each local changeset is rebased by calling sqlite3rebaser_rebase().Ÿ:**   <li> The sqlite3_rebaser object is deleted by callingŸ"**        sqlite3rebaser_delete().®** </ol>¢*/Ÿ/typedef struct sqlite3_rebaser sqlite3_rebaser;†¢/*Ÿ/** CAPI3REF: Create a changeset rebaser object.Ø** EXPERIMENTAL¢**ŸJ** Allocate a new changeset rebaser object. If successful, set (*ppNew) toŸG** point to the new object and return SQLITE_OK. Otherwise, if an errorŸL** occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) ¨** to NULL. ¢*/Ÿ>SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew);†¢/*Ÿ2** CAPI3REF: Configure a changeset rebaser object.Ø** EXPERIMENTAL¢**ŸH** Configure the changeset rebaser object to rebase changesets accordingŸH** to the conflict resolutions described by buffer pRebase (size nRebaseŸ@** bytes), which must have been obtained from a previous call toø** sqlite3changeset_apply_v2().¢*/Ÿ(SQLITE_API int sqlite3rebaser_configure(¥  sqlite3_rebaser*, Ÿ"  int nRebase, const void *pRebase£); †¢/*ø** CAPI3REF: Rebase a changesetØ** EXPERIMENTAL¢**ŸG** Argument pIn must point to a buffer containing a changeset nIn bytesŸF** in size. This function allocates and populates a buffer with a copyŸI** of the changeset rebased rebased according to the configuration of theŸG** rebaser object passed as the first argument. If successful, (*ppOut)ŸI** is set to point to the new buffer containing the rebased changset and ŸB** (*pnOut) to its size in bytes and SQLITE_OK returned. It is theŸG** responsibility of the caller to eventually free the new buffer usingŸG** sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut)Ÿ5** are set to zero and an SQLite error code returned.¢*/Ÿ%SQLITE_API int sqlite3rebaser_rebase(≥  sqlite3_rebaser*,º  int nIn, const void *pIn, ª  int *pnOut, void **ppOut ¢);†¢/*Ÿ/** CAPI3REF: Delete a changeset rebaser object.Ø** EXPERIMENTAL¢**ŸJ** Delete the changeset rebaser object and all associated resources. ThereŸE** should be one call to this function for each successful invocationæ** of sqlite3rebaser_create().¢*/Ÿ;SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p); †¢/*Ÿ1** CAPI3REF: Streaming Versions of API functions.¢**ŸL** The six streaming API xxx_strm() functions serve similar purposes to the Ÿ-** corresponding non-streaming API functions:¢**Ÿ<** <table border=1 style="margin-left:8ex;margin-right:8ex">Ÿ@**   <tr><th>Streaming function<th>Non-streaming equivalent</th>ŸE**   <tr><td>sqlite3changeset_apply_strm<td>[sqlite3changeset_apply] ŸK**   <tr><td>sqlite3changeset_apply_strm_v2<td>[sqlite3changeset_apply_v2] ŸG**   <tr><td>sqlite3changeset_concat_strm<td>[sqlite3changeset_concat] ŸG**   <tr><td>sqlite3changeset_invert_strm<td>[sqlite3changeset_invert] ŸE**   <tr><td>sqlite3changeset_start_strm<td>[sqlite3changeset_start] ŸI**   <tr><td>sqlite3session_changeset_strm<td>[sqlite3session_changeset] ŸG**   <tr><td>sqlite3session_patchset_strm<td>[sqlite3session_patchset] ´** </table>¢**ŸI** Non-streaming functions that accept changesets (or patchsets) as inputŸM** require that the entire changeset be stored in a single buffer in memory. ŸK** Similarly, those that return a changeset or patchset do so by returning ŸH** a pointer to a single large buffer allocated using sqlite3_malloc(). ŸH** Normally this is convenient. However, if an application running in a ŸJ** low-memory environment is required to handle very large changesets, theŸC** large contiguous memory allocations required can become onerous.¢**ŸJ** In order to avoid this problem, instead of a single large buffer, inputŸL** is passed to a streaming API functions by way of a callback function thatŸK** the sessions module invokes to incrementally request input data as it isŸD** required. In all cases, a pair of API function parameters such as¢**©**  <pre>æ**  &nbsp;     int nChangeset,Ÿ **  &nbsp;     void *pChangeset,™**  </pre>¢**≤** Is replaced by:¢**©**  <pre>ŸB**  &nbsp;     int (*xInput)(void *pIn, void *pData, int *pnData),π**  &nbsp;     void *pIn,™**  </pre>¢**ŸM** Each time the xInput callback is invoked by the sessions module, the firstŸM** argument passed is a copy of the supplied pIn context pointer. The second ŸL** argument, pData, points to a buffer (*pnData) bytes in size. Assuming no ŸL** error occurs the xInput method should copy up to (*pnData) bytes of data ŸJ** into the buffer and set (*pnData) to the actual number of bytes copied ŸO** before returning SQLITE_OK. If the input is completely exhausted, (*pnData) ŸM** should be set to zero to indicate this. Or, if an error occurs, an SQLite ŸM** error code should be returned. In all cases, if an xInput callback returnsŸG** an error, all processing is abandoned and the streaming API functionŸ2** returns a copy of the error code to the caller.¢**ŸK** In the case of sqlite3changeset_start_strm(), the xInput callback may beŸI** invoked by the sessions module at any point during the lifetime of theŸM** iterator. If such an xInput callback returns an error, the iterator entersŸF** an error state, whereby all subsequent calls to iterator functions ŸC** immediately fail with the same error code as returned by xInput.¢**ŸK** Similarly, streaming API functions that return changesets (or patchsets)ŸG** return them in chunks by way of a callback function instead of via aŸL** pointer to a single large buffer. In this case, a pair of parameters such¶** as:¢**©**  <pre>Ÿ **  &nbsp;     int *pnChangeset,Ÿ"**  &nbsp;     void **ppChangeset,™**  </pre>¢**≤** Is replaced by:¢**©**  <pre>ŸH**  &nbsp;     int (*xOutput)(void *pOut, const void *pData, int nData),π**  &nbsp;     void *pOut™**  </pre>¢**ŸG** The xOutput callback is invoked zero or more times to return data toŸL** the application. The first parameter passed to each call is a copy of theŸI** pOut pointer supplied by the application. The second parameter, pData,ŸH** points to a buffer nData bytes in size containing the chunk of outputŸJ** data being returned. If the xOutput callback successfully processes theŸL** supplied data, it should return SQLITE_OK to indicate success. Otherwise,ŸI** it should return some other SQLite error code. In this case processingŸI** is immediately abandoned and the streaming API function returns a copyŸ0** of the xOutput error code to the application.¢**ŸH** The sessions module never invokes an xOutput callback with the third ŸH** parameter set to a value less than or equal to zero. Other than this,ŸH** no guarantees are made as to the size of the chunks of data returned.¢*/Ÿ+SQLITE_API int sqlite3changeset_apply_strm(ŸP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ŸJ  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */ŸP  void *pIn,                                          /* First arg for xInput */∞  int(*xFilter)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ÿ2    const char *zTab              /* Table name */§  ),≤  int(*xConflict)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */ŸK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ŸM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */§  ),ŸJ  void *pCtx                      /* First argument passed to xConflict */¢);Ÿ.SQLITE_API int sqlite3changeset_apply_v2_strm(ŸP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ŸJ  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */ŸP  void *pIn,                                          /* First arg for xInput */∞  int(*xFilter)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ÿ2    const char *zTab              /* Table name */§  ),≤  int(*xConflict)(ŸE    void *pCtx,                   /* Copy of sixth arg to _apply() */ŸK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ŸM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */§  ),ŸJ  void *pCtx,                     /* First argument passed to xConflict */Ÿ!  void **ppRebase, int *pnRebase,´  int flags¢);Ÿ,SQLITE_API int sqlite3changeset_concat_strm(Ÿ6  int (*xInputA)(void *pIn, void *pData, int *pnData),≠  void *pInA,Ÿ6  int (*xInputB)(void *pIn, void *pData, int *pnData),≠  void *pInB,Ÿ;  int (*xOutput)(void *pOut, const void *pData, int nData),¨  void *pOut¢);Ÿ,SQLITE_API int sqlite3changeset_invert_strm(Ÿ5  int (*xInput)(void *pIn, void *pData, int *pnData),¨  void *pIn,Ÿ;  int (*xOutput)(void *pOut, const void *pData, int nData),¨  void *pOut¢);Ÿ+SQLITE_API int sqlite3changeset_start_strm(æ  sqlite3_changeset_iter **pp,Ÿ5  int (*xInput)(void *pIn, void *pData, int *pnData),´  void *pIn¢);Ÿ-SQLITE_API int sqlite3session_changeset_strm(º  sqlite3_session *pSession,Ÿ;  int (*xOutput)(void *pOut, const void *pData, int nData),¨  void *pOut¢);Ÿ,SQLITE_API int sqlite3session_patchset_strm(º  sqlite3_session *pSession,Ÿ;  int (*xOutput)(void *pOut, const void *pData, int nData),¨  void *pOut¢);ŸASQLITE_API int sqlite3changegroup_add_strm(sqlite3_changegroup*, Ÿ7    int (*xInput)(void *pIn, void *pData, int *pnData),≠    void *pIn¢);ŸCSQLITE_API int sqlite3changegroup_output_strm(sqlite3_changegroup*,Ÿ>    int (*xOutput)(void *pOut, const void *pData, int nData), Æ    void *pOut¢);Ÿ*SQLITE_API int sqlite3rebaser_rebase_strm(º  sqlite3_rebaser *pRebaser,Ÿ5  int (*xInput)(void *pIn, void *pData, int *pnData),¨  void *pIn,Ÿ;  int (*xOutput)(void *pOut, const void *pData, int nData),¨  void *pOut¢);††¢/*Ÿ-** Make sure we can call this stuff from C++.¢*/•#if 0°}¶#endif†ŸL#endif  /* !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION) */†Ÿ,/******** End of sqlite3session.h *********/Ÿ&/******** Begin file fts5.h *********/¢/*Æ** 2014 May 31¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸI** Interfaces to extend FTS5. Using the interfaces defined in this file, Ω** FTS5 may be extended with:¢**ø**     * custom tokenizers, andŸ$**     * custom auxiliary functions.¢*/††Ø#ifndef _FTS5_HØ#define _FTS5_H††•#if 0¨extern "C" {¶#endif†ŸJ/*************************************************************************Ω** CUSTOM AUXILIARY FUNCTIONS¢**ŸK** Virtual table implementations may overload SQL functions by implementingŸ-** the sqlite3_module.xFindFunction() method.¢*/†Ÿ1typedef struct Fts5ExtensionApi Fts5ExtensionApi;Ÿ'typedef struct Fts5Context Fts5Context;Ÿ-typedef struct Fts5PhraseIter Fts5PhraseIter;†Ÿ(typedef void (*fts5_extension_function)(ŸJ  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */ŸK  Fts5Context *pFts,              /* First arg to pass to pApi functions */ŸJ  sqlite3_context *pCtx,          /* Context for returning result/error */ŸI  int nVal,                       /* Number of values in apVal[] array */ŸC  sqlite3_value **apVal           /* Array of trailing arguments */¢);†∑struct Fts5PhraseIter {π  const unsigned char *a;π  const unsigned char *b;¢};†¢/*∫** EXTENSION API FUNCTIONS¢**≥** xUserData(pFts):ŸE**   Return a copy of the context pointer the extension function was µ**   registered with.¢**Ÿ)** xColumnTotalSize(pFts, iCol, pnToken):ŸF**   If parameter iCol is less than zero, set output variable *pnTokenŸD**   to the total number of tokens in the FTS5 table. Or, if iCol isŸJ**   non-negative but less than the number of columns in the table, returnŸH**   the total number of tokens in column iCol, considering all rows in ¥**   the FTS5 table.¢**ŸH**   If parameter iCol is greater than or equal to the number of columnsŸI**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.ŸH**   an OOM condition or IO error), an appropriate SQLite error code is Æ**   returned.¢**∂** xColumnCount(pFts):Ÿ/**   Return the number of columns in the table.¢**Ÿ$** xColumnSize(pFts, iCol, pnToken):ŸF**   If parameter iCol is less than zero, set output variable *pnTokenŸE**   to the total number of tokens in the current row. Or, if iCol isŸG**   non-negative but less than the number of columns in the table, setŸH**   *pnToken to the number of tokens in column iCol of the current row.¢**ŸH**   If parameter iCol is greater than or equal to the number of columnsŸI**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.ŸH**   an OOM condition or IO error), an appropriate SQLite error code is Æ**   returned.¢**ŸF**   This function may be quite inefficient if used with an FTS5 tableŸ,**   created with the "columnsize=0" option.¢**Ø** xColumnText:ŸF**   This function attempts to retrieve the text of column iCol of theŸG**   current document. If successful, (*pz) is set to point to a bufferŸM**   containing the text in utf-8 encoding, (*pn) is set to the size in bytesŸI**   (not characters) of the buffer and SQLITE_OK is returned. Otherwise,ŸN**   if an error occurs, an SQLite error code is returned and the final valuesŸ&**   of (*pz) and (*pn) are undefined.¢**∞** xPhraseCount:ŸC**   Returns the number of phrases in the current query expression.¢**Ø** xPhraseSize:ŸI**   Returns the number of tokens in phrase iPhrase of the query. PhrasesŸ%**   are numbered starting from zero.¢**Æ** xInstCount:ŸI**   Set *pnInst to the total number of occurrences of all phrases withinŸI**   the query within the current row. Return SQLITE_OK if successful, orŸ:**   an error code (i.e. SQLITE_NOMEM) if an error occurs.¢**ŸK**   This API can be quite slow if used with an FTS5 table created with theŸK**   "detail=none" or "detail=column" option. If the FTS5 table is created ŸH**   with either "detail=none" or "detail=column" and "content=" option ŸI**   (i.e. if it is a contentless table), then this API always returns 0.¢**©** xInst:ŸG**   Query for the details of phrase match iIdx within the current row.ŸI**   Phrase matches are numbered starting from zero, so the iIdx argumentŸG**   should be greater than or equal to zero and smaller than the valueº**   output by xInstCount().¢**ŸL**   Usually, output parameter *piPhrase is set to the phrase number, *piColŸH**   to the column in which it occurs and *piOff the token offset of theŸI**   first token of the phrase. The exception is if the table was createdŸG**   with the offsets=0 option specified. In this case *piOff is alwaysØ**   set to -1.¢**ŸK**   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) ∏**   if an error occurs.¢**ŸK**   This API can be quite slow if used with an FTS5 table created with theŸ.**   "detail=none" or "detail=column" option. ¢**™** xRowid:Ÿ***   Returns the rowid of the current row.¢**≠** xTokenize:ŸC**   Tokenize text using the tokenizer belonging to the FTS5 table.¢**Ÿ6** xQueryPhrase(pFts5, iPhrase, pUserData, xCallback):ŸH**   This API function is used to query the FTS table for phrase iPhraseŸ?**   of the current query. Specifically, a query equivalent to:¢**ŸA**       ... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid¢**ŸD**   with $p set to a phrase equivalent to the phrase iPhrase of theŸA**   current query is executed. Any column filter that applies toŸE**   phrase iPhrase of the current query is included in $p. For each ŸF**   row visited, the callback function passed as the fourth argument ŸD**   is invoked. The context and API objects passed to the callback ŸG**   function may be used to access the properties of each matched row.ŸF**   Invoking Api.xUserData() returns a copy of the pointer passed as Ÿ%**   the third argument to pUserData.¢**ŸI**   If the callback function returns any value other than SQLITE_OK, theŸJ**   query is abandoned and the xQueryPhrase function returns immediately.ŸJ**   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.Ÿ5**   Otherwise, the error code is propagated upwards.¢**ŸM**   If the query runs to completion without incident, SQLITE_OK is returned.ŸI**   Or, if some error occurs before the query completes or is aborted byŸ4**   the callback, an SQLite error code is returned.¢**¢**Ÿ$** xSetAuxdata(pFts5, pAux, xDelete)¢**ŸO**   Save the pointer passed as the second argument as the extension functions ŸN**   "auxiliary data". The pointer may then be retrieved by the current or anyŸJ**   future invocation of the same fts5 extension function made as part ofŸ9**   of the same MATCH query using the xGetAuxdata() API.¢**ŸJ**   Each extension function is allocated a single auxiliary data slot forŸM**   each FTS query (MATCH expression). If the extension function is invoked ŸI**   more than once for a single FTS query, then all invocations share a Ÿ#**   single auxiliary data context.¢**ŸH**   If there is already an auxiliary data pointer when this function isŸL**   invoked, then it is replaced by the new pointer. If an xDelete callbackŸI**   was specified along with the original pointer, it is invoked at this´**   point.¢**ŸF**   The xDelete callback, if one is specified, is also invoked on theŸ>**   auxiliary data pointer after the FTS5 query has finished.¢**ŸH**   If an error (e.g. an OOM condition) occurs within this function, anŸI**   the auxiliary data is set to NULL and an error code returned. If theŸH**   xDelete parameter was not NULL, it is invoked on the auxiliary dataæ**   pointer before returning.¢**¢**Ω** xGetAuxdata(pFts5, bClear)¢**ŸG**   Returns the current auxiliary data pointer for the fts5 extension Ÿ8**   function. See the xSetAuxdata() method for details.¢**ŸK**   If the bClear argument is non-zero, then the auxiliary data is clearedŸJ**   (set to NULL) before this function returns. In this case the xDelete,º**   if any, is not invoked.¢**¢**∫** xRowCount(pFts5, pnRow)¢**ŸM**   This function is used to retrieve the total number of rows in the table.Ÿ>**   In other words, the same value that would be returned by:¢**Ÿ(**        SELECT count(*) FROM ftstable;¢**±** xPhraseFirst()ŸN**   This function is used, along with type Fts5PhraseIter and the xPhraseNextŸM**   method, to iterate through all instances of a single query phrase withinŸK**   the current row. This is the same information as is accessible via theŸO**   xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenientŸI**   to use, this API may be faster under some circumstances. To iterate ŸA**   through instances of phrase iPhrase, use the following code:¢**Ω**       Fts5PhraseIter iter;∏**       int iCol, iOff;ŸD**       for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);µ**           iCol>=0;Ÿ9**           pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)´**       ){ŸI**         // An instance of phrase iPhrase at offset iOff of column iCol™**       }¢**ŸK**   The Fts5PhraseIter structure is defined above. Applications should notŸK**   modify this structure directly - it should only be used as shown aboveŸB**   with the xPhraseFirst() and xPhraseNext() API methods (and byŸH**   xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).¢**ŸK**   This API can be quite slow if used with an FTS5 table created with theŸK**   "detail=none" or "detail=column" option. If the FTS5 table is created ŸH**   with either "detail=none" or "detail=column" and "content=" option ŸG**   (i.e. if it is a contentless table), then this API always iteratesŸG**   through an empty set (all calls to xPhraseFirst() set iCol to -1).¢**∞** xPhraseNext()º**   See xPhraseFirst above.¢**∑** xPhraseFirstColumn()ŸL**   This function and xPhraseNextColumn() are similar to the xPhraseFirst()ŸK**   and xPhraseNext() APIs described above. The difference is that insteadŸM**   of iterating through all instances of a phrase in the current row, theseŸK**   APIs are used to iterate through the set of columns in the current rowŸK**   that contain one or more instances of a specified phrase. For example:¢**Ω**       Fts5PhraseIter iter;≤**       int iCol;ŸC**       for(pApi->xPhraseFirstColumn(pFts, iPhrase, &iter, &iCol);µ**           iCol>=0;Ÿ8**           pApi->xPhraseNextColumn(pFts, &iter, &iCol)´**       ){ŸJ**         // Column iCol contains at least one instance of phrase iPhrase™**       }¢**ŸK**   This API can be quite slow if used with an FTS5 table created with theŸD**   "detail=none" option. If the FTS5 table is created with either ŸJ**   "detail=none" "content=" option (i.e. if it is a contentless table), ŸF**   then this API always iterates through an empty set (all calls to Ÿ***   xPhraseFirstColumn() set iCol to -1).¢**Ÿ>**   The information accessed using this API and its companionŸM**   xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNextŸI**   (or xInst/xInstCount). The chief advantage of this API is that it isŸH**   significantly more efficient than those alternatives when used withæ**   "detail=column" tables.  ¢**∂** xPhraseNextColumn()Ÿ"**   See xPhraseFirstColumn above.¢*/πstruct Fts5ExtensionApi {ŸA  int iVersion;                   /* Currently always set to 3 */†Ÿ#  void *(*xUserData)(Fts5Context*);†Ÿ$  int (*xColumnCount)(Fts5Context*);Ÿ7  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);ŸJ  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);†Ÿ!  int (*xTokenize)(Fts5Context*, Ÿ8    const char *pText, int nText, /* Text to tokenize */ŸB    void *pCtx,                   /* Context passed to xToken() */ŸN    int (*xToken)(void*, int, const char*, int, int, int)       /* Callback */§  );†Ÿ$  int (*xPhraseCount)(Fts5Context*);Ÿ0  int (*xPhraseSize)(Fts5Context*, int iPhrase);†Ÿ/  int (*xInstCount)(Fts5Context*, int *pnInst);ŸN  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);†Ÿ(  sqlite3_int64 (*xRowid)(Fts5Context*);ŸG  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);Ÿ;  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);†ŸA  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,Ÿ6    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)§  );ŸF  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));Ÿ1  void *(*xGetAuxdata)(Fts5Context*, int bClear);†ŸN  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);ŸM  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);†ŸN  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);ŸG  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);¢};†£/* Ω** CUSTOM AUXILIARY FUNCTIONSŸJ*************************************************************************/†ŸJ/*************************************************************************¥** CUSTOM TOKENIZERS¢**ŸF** Applications may also register custom tokenizer types. A tokenizer ŸD** is registered by providing fts5 with a populated instance of the ŸF** following structure. All structure methods must be defined, settingŸE** any member of the fts5_tokenizer struct to NULL leads to undefinedŸH** behaviour. The structure methods are expected to function as follows:¢**´** xCreate:ŸK**   This function is used to allocate and initialize a tokenizer instance.Ÿ@**   A tokenizer instance is required to actually tokenize text.¢**ŸH**   The first argument passed to this function is a copy of the (void*)ŸG**   pointer provided by the application when the fts5_tokenizer objectŸJ**   was registered with FTS5 (the third argument to xCreateTokenizer()). ŸJ**   The second and third arguments are an array of nul-terminated stringsŸH**   containing the tokenizer arguments, if any, specified following theŸF**   tokenizer name as part of the CREATE VIRTUAL TABLE statement usedæ**   to create the FTS5 table.¢**ŸG**   The final argument is an output variable. If successful, (*ppOut) ŸE**   should be set to point to the new tokenizer handle and SQLITE_OKŸI**   returned. If an error occurs, some value other than SQLITE_OK shouldŸL**   be returned. In this case, fts5 assumes that the final value of *ppOut ≤**   is undefined.¢**´** xDelete:ŸE**   This function is invoked to delete a tokenizer handle previouslyŸG**   allocated using xCreate(). Fts5 guarantees that this function willŸC**   be invoked exactly once for each successful call to xCreate().¢**≠** xTokenize:ŸK**   This function is expected to tokenize the nText byte string indicated ŸI**   by argument pText. pText may or may not be nul-terminated. The firstŸM**   argument passed to this function is a pointer to an Fts5Tokenizer objectŸ.**   returned by an earlier call to xCreate().¢**ŸE**   The second argument indicates the reason that FTS5 is requestingŸK**   tokenization of the supplied text. This is always one of the following±**   four values:¢**ŸO**   <ul><li> <b>FTS5_TOKENIZE_DOCUMENT</b> - A document is being inserted intoŸN**            or removed from the FTS table. The tokenizer is being invoked toŸH**            determine the set of tokens to add to (or delete from) the∏**            FTS index.¢**ŸK**       <li> <b>FTS5_TOKENIZE_QUERY</b> - A MATCH query is being executed ŸO**            against the FTS index. The tokenizer is being called to tokenize ŸI**            a bareword or quoted string specified as part of the query.¢**ŸK**       <li> <b>(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)</b> - Same asŸO**            FTS5_TOKENIZE_QUERY, except that the bareword or quoted string isŸI**            followed by a "*" character, indicating that the last tokenŸJ**            returned by the tokenizer will be treated as a token prefix.¢**ŸK**       <li> <b>FTS5_TOKENIZE_AUX</b> - The tokenizer is being invoked to ŸJ**            satisfy an fts5_api.xTokenize() request made by an auxiliaryŸM**            function. Or an fts5_api.xColumnSize() request made by the sameŸ+**            on a columnsize=0 database.  ™**   </ul>¢**ŸL**   For each token in the input string, the supplied callback xToken() mustŸI**   be invoked. The first argument to it should be a copy of the pointerŸG**   passed as the second argument to xTokenize(). The third and fourthŸK**   arguments are a pointer to a buffer containing the token text, and theŸO**   size of the token in bytes. The 4th and 5th arguments are the byte offsetsŸL**   of the first byte of and first byte immediately following the text fromŸ1**   which the token is derived within the input.¢**ŸJ**   The second argument passed to the xToken() callback ("tflags") shouldŸF**   normally be set to 0. The exception is if the tokenizer supports ŸA**   synonyms. In this case see the discussion below for details.¢**ŸI**   FTS5 assumes the xToken() callback is invoked for each token in the Ÿ1**   order that they occur within the input text.¢**ŸI**   If an xToken() callback returns any value other than SQLITE_OK, thenŸK**   the tokenization should be abandoned and the xTokenize() method shouldŸG**   immediately return a copy of the xToken() return value. Or, if theŸM**   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,ŸF**   if an error occurs with the xTokenize() implementation itself, itŸF**   may abandon the tokenization and return any error code other thanæ**   SQLITE_OK or SQLITE_DONE.¢**≤** SYNONYM SUPPORT¢**ŸL**   Custom tokenizers may also support synonyms. Consider a case in which aŸH**   user wishes to query for a phrase such as "first place". Using the ŸM**   built-in tokenizers, the FTS5 query 'first + place' will match instancesŸH**   of "first place" within the document set, but not alternative formsŸK**   such as "1st place". In some applications, it would be better to matchŸK**   all instances of "first place" or "1st place" regardless of which formŸ0**   the user specified in the MATCH query text.¢**Ÿ5**   There are several ways to approach this in FTS5:¢**ŸK**   <ol><li> By mapping all synonyms to a single token. In this case, the ŸM**            In the above example, this means that the tokenizer returns theŸK**            same token for inputs "first" and "1st". Say that token is inŸM**            fact "first", so that when the user inserts the document "I wonŸN**            1st place" entries are added to the index for tokens "i", "won",ŸN**            "first" and "place". If the user then queries for '1st + place',ŸM**            the tokenizer substitutes "first" for "1st" and the query works∫**            as expected.¢**ŸM**       <li> By adding multiple synonyms for a single term to the FTS index.ŸJ**            In this case, when tokenizing query text, the tokenizer may ŸN**            provide multiple synonyms for a single term within the document.ŸL**            FTS5 then queries the index for each synonym individually. ForŸ,**            example, faced with the query:¢**∞**   <codeblock>Ÿ***     ... MATCH 'first place'</codeblock>¢**ŸM**            the tokenizer offers both "1st" and "first" as synonyms for theŸO**            first token in the MATCH query and FTS5 effectively runs a query π**            similar to:¢**∞**   <codeblock>Ÿ3**     ... MATCH '(first OR 1st) place'</codeblock>¢**ŸM**            except that, for the purposes of auxiliary functions, the queryŸK**            still appears to contain just two phrases - "(first OR 1st)" Ÿ/**            being treated as a single phrase.¢**ŸM**       <li> By adding multiple synonyms for a single term to the FTS index.ŸM**            Using this method, when tokenizing document text, the tokenizerŸH**            provides multiple synonyms for each token. So that when a ŸL**            document such as "I won first place" is tokenized, entries areŸG**            added to the FTS index for "i", "won", "first", "1st" and∂**            "place".¢**ŸG**            This way, even if the tokenizer does not provide synonymsŸH**            when tokenizing query text (it should not - to do would beŸF**            inefficient), it doesn't matter if the user queries for ŸK**            'first + place' or '1st + place', as there are entires in theŸG**            FTS index corresponding to both forms of the first token.™**   </ol>¢**ŸJ**   Whether it is parsing document or query text, any call to xToken thatŸI**   specifies a <i>tflags</i> argument with the FTS5_TOKEN_COLOCATED bitŸK**   is considered to supply a synonym for the previous token. For example,ŸM**   when parsing the document "I won first place", a tokenizer that supportsŸ6**   synonyms would call xToken() 5 times, as follows:¢**∞**   <codeblock>Ÿ>**       xToken(pCtx, 0, "i",                      1,  0,  1);Ÿ>**       xToken(pCtx, 0, "won",                    3,  2,  5);Ÿ>**       xToken(pCtx, 0, "first",                  5,  6, 11);Ÿ>**       xToken(pCtx, FTS5_TOKEN_COLOCATED, "1st", 3,  6, 11);Ÿ>**       xToken(pCtx, 0, "place",                  5, 12, 17);Æ**</codeblock>¢**ŸK**   It is an error to specify the FTS5_TOKEN_COLOCATED flag the first timeŸN**   xToken() is called. Multiple synonyms may be specified for a single tokenŸK**   by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. ŸK**   There is no limit to the number of synonyms that may be provided for a≤**   single token.¢**ŸK**   In many cases, method (1) above is the best approach. It does not add ŸM**   extra data to the FTS index or require FTS5 to query for multiple terms,ŸK**   so it is efficient in terms of disk space and query speed. However, itŸK**   does not support prefix queries very well. If, as suggested above, theŸL**   token "first" is subsituted for "1st" by the tokenizer, then the query:¢**∞**   <codeblock>Ÿ"**     ... MATCH '1s*'</codeblock>¢**ŸL**   will not match documents that contain the token "1st" (as the tokenizerŸ:**   will probably not map "1s" to any prefix of "first").¢**ŸI**   For full prefix support, method (3) may be preferred. In this case, ŸJ**   because the index contains entries for both "first" and "1st", prefixŸJ**   queries such as 'fi*' or '1s*' will match correctly. However, becauseŸJ**   extra entries are added to the FTS index, this method uses more spaceπ**   within the database.¢**ŸI**   Method (2) offers a midpoint between (1) and (3). Using this method,ŸI**   a query such as '1s*' will match documents that contain the literal ŸH**   token "1st", but not "first" (assuming the tokenizer is not able toŸK**   provide synonyms for prefixes). However, a non-prefix query like '1st'ŸG**   will match against "1st" and "first". This method does not requireŸG**   extra disk space, as no extra entries are added to the FTS index. ŸL**   On the other hand, it may require more CPU cycles to run MATCH queries,ŸH**   as separate queries of the FTS index are required for each synonym.¢**ŸK**   When using methods (2) or (3), it is important that the tokenizer onlyŸI**   provide synonyms when tokenizing document text (method (2)) or queryŸL**   text (method (3)), not both. Doing so will not cause any errors, but is±**   inefficient.¢*/Ÿ+typedef struct Fts5Tokenizer Fts5Tokenizer;Ÿ-typedef struct fts5_tokenizer fts5_tokenizer;∑struct fts5_tokenizer {ŸM  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);Ÿ"  void (*xDelete)(Fts5Tokenizer*);Ÿ#  int (*xTokenize)(Fts5Tokenizer*, ±      void *pCtx,Ÿ?      int flags,            /* Mask of FTS5_TOKENIZE_* flags */Ÿ$      const char *pText, int nText, ¥      int (*xToken)(ŸE        void *pCtx,         /* Copy of 2nd argument to xTokenize() */Ÿ<        int tflags,         /* Mask of FTS5_TOKEN_* flags */ŸD        const char *pToken, /* Pointer to buffer containing token */Ÿ8        int nToken,         /* Size of token in bytes */ŸH        int iStart,         /* Byte offset of token within input text */ŸO        int iEnd            /* Byte offset of end of token within input text */ß      )§  );¢};†ŸC/* Flags that may be passed as the third argument to xTokenize() */Ÿ&#define FTS5_TOKENIZE_QUERY     0x0001Ÿ&#define FTS5_TOKENIZE_PREFIX    0x0002Ÿ&#define FTS5_TOKENIZE_DOCUMENT  0x0004Ÿ&#define FTS5_TOKENIZE_AUX       0x0008†ŸH/* Flags that may be passed by the tokenizer implementation back to FTS5Ÿ<** as the third argument to the supplied xToken callback. */ŸN#define FTS5_TOKEN_COLOCATED    0x0001      /* Same position as prev. token */†¢/*ª** END OF CUSTOM TOKENIZERSŸJ*************************************************************************/†ŸJ/*************************************************************************Ÿ"** FTS5 EXTENSION REGISTRATION API¢*/Ÿ!typedef struct fts5_api fts5_api;±struct fts5_api {ŸA  int iVersion;                   /* Currently always set to 2 */†æ  /* Create a new tokenizer */∫  int (*xCreateTokenizer)(≥    fts5_api *pApi,∂    const char *zName,≥    void *pContext,ø    fts5_tokenizer *pTokenizer,ª    void (*xDestroy)(void*)§  );†Ÿ"  /* Find an existing tokenizer */∏  int (*xFindTokenizer)(≥    fts5_api *pApi,∂    const char *zName,µ    void **ppContext,æ    fts5_tokenizer *pTokenizer§  );†Ÿ'  /* Create a new auxiliary function */π  int (*xCreateFunction)(≥    fts5_api *pApi,∂    const char *zName,≥    void *pContext,Ÿ&    fts5_extension_function xFunction,ª    void (*xDestroy)(void*)§  );¢};†¢/*∫** END OF REGISTRATION APIŸJ*************************************************************************/†•#if 0Ÿ&}  /* end of the 'extern "C"' block */¶#endif†¥#endif /* _FTS5_H */†Ÿ"/******** End of fts5.h *********/†ŸO/************** End of sqlite3.h *********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/†¢/*ŸL** Include the configuration header output by 'configure' if we're using the∑** autoconf-based build¢*/Ÿ>#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)π/* #include "config.h" */∏#define SQLITECONFIG_H 1¶#endif†ŸO/************** Include sqliteLimit.h in the middle of sqliteInt.h ***********/ŸO/************** Begin file sqliteLimit.h *************************************/¢/*≠** 2007 May 7¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************£** Ÿ?** This file defines various limits of what SQLite can process.¢*/†¢/*Ÿ=** The maximum length of a TEXT or BLOB in bytes.   This alsoŸ0** limits the size of a row in a table or index.¢**Ÿ;** The hard limit is the ability of a 32-bit signed integerŸ+** to count the size: 2^31-1 or 2147483647.¢*/π#ifndef SQLITE_MAX_LENGTHŸ%# define SQLITE_MAX_LENGTH 1000000000¶#endif†¢/*Ÿ ** This is the maximum number of¢**∫**    * Columns in a tableª**    * Columns in an indexπ**    * Columns in a viewŸ6**    * Terms in the SET clause of an UPDATE statementŸ5**    * Terms in the result set of a SELECT statementŸH**    * Terms in the GROUP BY or ORDER BY clauses of a SELECT statement.Ÿ9**    * Terms in the VALUES clause of an INSERT statement¢**ŸA** The hard upper limit here is 32676.  Most database people willŸB** tell you that in a well-normalized database, you usually shouldŸA** not have more than a dozen or so columns in any table.  And ifŸ@** that is the case, there is no point in having more than a fewŸ?** dozen values in any of the other situations described above.¢*/π#ifndef SQLITE_MAX_COLUMNø# define SQLITE_MAX_COLUMN 2000¶#endif†¢/*Ÿ9** The maximum length of a single SQL statement in bytes.¢**Ÿ?** It used to be the case that setting this value to zero wouldŸC** turn the limit off.  That is no longer true.  It is not possible∫** to turn this limit off.¢*/Ω#ifndef SQLITE_MAX_SQL_LENGTHŸ)# define SQLITE_MAX_SQL_LENGTH 1000000000¶#endif†¢/*Ÿ?** The maximum depth of an expression tree. This is limited to Ÿ@** some extent by SQLITE_MAX_SQL_LENGTH. But sometime you might Ÿ<** want to place more severe limits on the complexity of an Æ** expression.¢**Ÿ=** A value of 0 used to mean that the limit was not enforced.ŸB** But that is no longer true.  The limit is now strictly enforced∞** at all times.¢*/Ω#ifndef SQLITE_MAX_EXPR_DEPTHŸ## define SQLITE_MAX_EXPR_DEPTH 1000¶#endif†¢/*Ÿ>** The maximum number of terms in a compound SELECT statement.Ÿ=** The code generator for compound SELECT statements does oneŸA** level of recursion for each term.  A stack overflow can resultŸ>** if the number of terms is too large.  In practice, most SQLŸA** never has more than 3 or 4 terms.  Use a value of 0 to disableŸ9** any limit on the number of terms in a compount SELECT.¢*/Ÿ"#ifndef SQLITE_MAX_COMPOUND_SELECTŸ'# define SQLITE_MAX_COMPOUND_SELECT 500¶#endif†¢/*Ÿ3** The maximum number of opcodes in a VDBE program.∫** Not currently enforced.¢*/∫#ifndef SQLITE_MAX_VDBE_OPŸ%# define SQLITE_MAX_VDBE_OP 250000000¶#endif†¢/*Ÿ6** The maximum number of arguments to an SQL function.¢*/ø#ifndef SQLITE_MAX_FUNCTION_ARGŸ$# define SQLITE_MAX_FUNCTION_ARG 127¶#endif†¢/*Ÿ=** The suggested maximum number of in-memory pages to use forŸ4** the main database table and for temporary tables.¢**ŸN** IMPLEMENTATION-OF: R-30185-15359 The default suggested cache size is -2000,ŸD** which means the cache size is limited to 2048000 bytes of memory.ŸK** IMPLEMENTATION-OF: R-48205-43578 The default suggested cache size can beŸD** altered using the SQLITE_DEFAULT_CACHE_SIZE compile-time options.¢*/Ÿ!#ifndef SQLITE_DEFAULT_CACHE_SIZEŸ)# define SQLITE_DEFAULT_CACHE_SIZE  -2000¶#endif†¢/*ŸD** The default number of frames to accumulate in the log file beforeŸ*** checkpointing the database in WAL mode.¢*/Ÿ)#ifndef SQLITE_DEFAULT_WAL_AUTOCHECKPOINTŸ0# define SQLITE_DEFAULT_WAL_AUTOCHECKPOINT  1000¶#endif†¢/*ŸD** The maximum number of attached databases.  This must be between 0ŸI** and 125.  The upper bound of 125 is because the attached databases areŸH** counted using a signed 8-bit integer which has a maximum value of 127ŸK** and we have to allow 2 extra counts for the "main" and "temp" databases.¢*/ª#ifndef SQLITE_MAX_ATTACHEDø# define SQLITE_MAX_ATTACHED 10¶#endif††¢/*ŸD** The maximum value of a ?nnn wildcard that the parser will accept.¢*/Ÿ"#ifndef SQLITE_MAX_VARIABLE_NUMBERŸ'# define SQLITE_MAX_VARIABLE_NUMBER 999¶#endif†ŸL/* Maximum page size.  The upper bound on this value is 65536.  This a limitŸ9** imposed by the use of 16-bit offsets within each page.¢**ŸF** Earlier versions of SQLite allowed the user to change this value atŸL** compile time. This is no longer permitted, on the grounds that it createsŸE** a library that is technically incompatible with an SQLite library ŸI** compiled with a different limit. If a process operating on a database ŸG** with a page-size of 65536 bytes crashes, then an instance of SQLite ŸJ** compiled with the default page-size limit will not be able to rollback ŸC** the aborted transaction. This could lead to database corruption.¢*/ª#ifdef SQLITE_MAX_PAGE_SIZEº# undef SQLITE_MAX_PAGE_SIZE¶#endifŸ"#define SQLITE_MAX_PAGE_SIZE 65536††¢/*Ÿ'** The default size of a database page.¢*/Ÿ #ifndef SQLITE_DEFAULT_PAGE_SIZEŸ&# define SQLITE_DEFAULT_PAGE_SIZE 4096¶#endifŸ1#if SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZEŸ # undef SQLITE_DEFAULT_PAGE_SIZEŸ6# define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE¶#endif†¢/*ŸK** Ordinarily, if no value is explicitly provided, SQLite creates databasesŸE** with page size SQLITE_DEFAULT_PAGE_SIZE. However, based on certainŸC** device characteristics (sector-size and atomic write() support),ŸG** SQLite may choose a larger value. This constant is the maximum valueŸ!** SQLite will choose on its own.¢*/Ÿ$#ifndef SQLITE_MAX_DEFAULT_PAGE_SIZEŸ*# define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192¶#endifŸ5#if SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZEŸ$# undef SQLITE_MAX_DEFAULT_PAGE_SIZEŸ:# define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE¶#endif††¢/*Ÿ0** Maximum number of pages in one database file.¢**ŸG** This is really just the default value for the max_page_count pragma.ŸC** This value can be lowered (or raised) at run-time using that the∏** max_page_count macro.¢*/Ω#ifndef SQLITE_MAX_PAGE_COUNTŸ)# define SQLITE_MAX_PAGE_COUNT 1073741823¶#endif†¢/*Ÿ=** Maximum length (in bytes) of the pattern in a LIKE or GLOB¨** operator.¢*/Ÿ&#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTHŸ-# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000¶#endif†¢/*Ÿ+** Maximum depth of recursion for triggers.¢**ŸG** A value of 1 means that a trigger program will not be able to itselfŸI** fire any triggers. A value of 0 means that no trigger programs at all ≥** may be executed.¢*/Ÿ #ifndef SQLITE_MAX_TRIGGER_DEPTHŸ&# define SQLITE_MAX_TRIGGER_DEPTH 1000¶#endif†ŸO/************** End of sqliteLimit.h *****************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/†Ÿ4/* Disable nuisance warnings on Borland compilers */π#if defined(__BORLANDC__)Ÿ(#pragma warn -rch /* unreachable code */Ÿ9#pragma warn -ccc /* Condition is always true or false */Ÿ4#pragma warn -aus /* Assigned value is never used */Ÿ5#pragma warn -csu /* Comparing signed and unsigned */Ÿ5#pragma warn -spa /* Suspicious pointer arithmetic */¶#endif†¢/*Ÿ-** Include standard header files as necessary¢*/¥#ifdef HAVE_STDINT_H≥#include <stdint.h>¶#endif∂#ifdef HAVE_INTTYPES_Hµ#include <inttypes.h>¶#endif†¢/*ŸA** The following macros are used to cast pointers to integers andŸF** integers to pointers.  The way you do this varies from one compilerŸH** to the next, so we have developed the following set of #if statementsŸ@** to generate appropriate macros for a wide range of compilers.¢**ŸA** The correct "ANSI" way to do this is to use the intptr_t type.ŸD** Unfortunately, that typedef is not available on all compilers, orŸB** if it is available, it requires an #include of specific headersŸ*** that vary from one machine to the next.¢**Ÿ@** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes onŸK** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).ŸE** So we have to define the macros in different ways depending on the¨** compiler.¢*/ŸB#if defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */Ÿ=# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))Ÿ;# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))ŸH#elif !defined(__GNUC__)       /* Works for compilers other than LLVM */Ÿ6# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])Ÿ;# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))ŸJ#elif defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */Ÿ5# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))Ÿ3# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))ŸN#else                          /* Generates a warning - but it always works */Ÿ+# define SQLITE_INT_TO_PTR(X)  ((void*)(X))Ÿ)# define SQLITE_PTR_TO_INT(X)  ((int)(X))¶#endif†¢/*Ÿ@** A macro to hint to the compiler that a function should not be´** inlined.¢*/µ#if defined(__GNUC__)Ÿ4#  define SQLITE_NOINLINE  __attribute__((noinline))Ÿ)#elif defined(_MSC_VER) && _MSC_VER>=1310Ÿ/#  define SQLITE_NOINLINE  __declspec(noinline)•#elseπ#  define SQLITE_NOINLINE¶#endif†¢/*ŸD** Make sure that the compiler intrinsics we desire are enabled whenŸD** compiling with an appropriate version of MSVC unless prevented byŸ'** the SQLITE_DISABLE_INTRINSIC define.¢*/Ÿ&#if !defined(SQLITE_DISABLE_INTRINSIC)Ÿ)#  if defined(_MSC_VER) && _MSC_VER>=1400º#    if !defined(_WIN32_WCE)π#      include <intrin.h>Ÿ)#      pragma intrinsic(_byteswap_ushort)Ÿ(#      pragma intrinsic(_byteswap_ulong)Ÿ)#      pragma intrinsic(_byteswap_uint64)Ÿ*#      pragma intrinsic(_ReadWriteBarrier)©#    elseº#      include <cmnintrin.h>™#    endif®#  endif¶#endif†¢/*Ÿ=** The SQLITE_THREADSAFE macro must be defined as 0, 1, or 2.ŸC** 0 means mutexes are permanently disable and the library is neverŸF** threadsafe.  1 means the library is serialized which is the highestŸJ** level of threadsafety.  2 means the library is multithreaded - multipleŸG** threads can use SQLite as long as no two threads try to use the sameŸ(** database connection at the same time.¢**Ÿ>** Older versions of SQLite used an optional THREADSAFE macro.æ** We support that for legacy.¢**ŸM** To ensure that the correct value of "THREADSAFE" is reported when queryingŸL** for compile-time options at runtime (e.g. "PRAGMA compile_options"), thisŸM** logic is partially replicated in ctime.c. If it is updated here, it shouldπ** also be updated there.¢*/ø#if !defined(SQLITE_THREADSAFE)∏# if defined(THREADSAFE)Ÿ'#   define SQLITE_THREADSAFE THREADSAFE¶# elseŸ7#   define SQLITE_THREADSAFE 1 /* IMP: R-07272-22309 */ß# endif¶#endif†¢/*ŸE** Powersafe overwrite is on by default.  But can be turned off usingŸ:** the -DSQLITE_POWERSAFE_OVERWRITE=0 command-line option.¢*/Ÿ"#ifndef SQLITE_POWERSAFE_OVERWRITEŸ%# define SQLITE_POWERSAFE_OVERWRITE 1¶#endif†¢/*ŸI** EVIDENCE-OF: R-25715-37072 Memory allocation statistics are enabled byŸG** default unless SQLite is compiled with SQLITE_DEFAULT_MEMSTATUS=0 inŸC** which case memory allocation statistics are disabled by default.¢*/Ÿ&#if !defined(SQLITE_DEFAULT_MEMSTATUS)Ÿ## define SQLITE_DEFAULT_MEMSTATUS 1¶#endif†¢/*ŸB** Exactly one of the following macros must be defined in order toŸ4** specify which memory allocation subsystem to use.¢**ŸB**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()ŸA**     SQLITE_WIN32_MALLOC           // Use Win32 native heap APIŸN**     SQLITE_ZERO_MALLOC            // Use a stub allocator that always failsŸL**     SQLITE_MEMDEBUG               // Debugging version of system malloc()¢**ŸK** On Windows, if the SQLITE_WIN32_MALLOC_VALIDATE macro is defined and theŸL** assert() macro is enabled, each call into the Win32 native heap subsystemŸL** will cause HeapValidate to be called.  If heap validation should fail, anø** assertion will be triggered.¢**ŸE** If none of the above are defined, then set SQLITE_SYSTEM_MALLOC asØ** the default.¢*/Ÿ##if defined(SQLITE_SYSTEM_MALLOC) \Ÿ"  + defined(SQLITE_WIN32_MALLOC) \Ÿ!  + defined(SQLITE_ZERO_MALLOC) \æ  + defined(SQLITE_MEMDEBUG)>1ŸI# error "Two or more of the following compile-time configuration options\Ÿ) are defined but at most one is allowed:\Ÿ= SQLITE_SYSTEM_MALLOC, SQLITE_WIN32_MALLOC, SQLITE_MEMDEBUG,\¥ SQLITE_ZERO_MALLOC"¶#endifŸ##if defined(SQLITE_SYSTEM_MALLOC) \Ÿ"  + defined(SQLITE_WIN32_MALLOC) \Ÿ!  + defined(SQLITE_ZERO_MALLOC) \ø  + defined(SQLITE_MEMDEBUG)==0ø# define SQLITE_SYSTEM_MALLOC 1¶#endif†¢/*Ÿ@** If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep theŸ?** sizes of memory allocations below this value where possible.¢*/Ÿ&#if !defined(SQLITE_MALLOC_SOFT_LIMIT)Ÿ&# define SQLITE_MALLOC_SOFT_LIMIT 1024¶#endif†¢/*Ÿ@** We need to define _XOPEN_SOURCE as follows in order to enableŸB** recursive mutexes on most Unix systems and fchmod() on OpenBSD.ŸA** But _XOPEN_SOURCE define causes problems for Mac OS X, so omit¶** it.¢*/ŸJ#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__)ª#  define _XOPEN_SOURCE 600¶#endif†¢/*ŸH** NDEBUG and SQLITE_DEBUG are opposites.  It should always be true thatŸK** defined(NDEBUG)==!defined(SQLITE_DEBUG).  If this is not currently true,Ÿ1** make it true by defining or undefining NDEBUG.¢**ŸD** Setting NDEBUG makes the code smaller and faster by disabling theŸB** assert() statements in the code.  So we want the default actionŸM** to be for NDEBUG to be set and NDEBUG to be undefined only if SQLITE_DEBUGŸ@** is set.  Thus NDEBUG becomes an opt-in rather than an opt-out´** feature.¢*/Ÿ.#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)±# define NDEBUG 1¶#endifŸ,#if defined(NDEBUG) && defined(SQLITE_DEBUG)Æ# undef NDEBUG¶#endif†¢/*ŸF** Enable SQLITE_ENABLE_EXPLAIN_COMMENTS if SQLITE_DEBUG is turned on.¢*/ŸE#if !defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) && defined(SQLITE_DEBUG)Ÿ)# define SQLITE_ENABLE_EXPLAIN_COMMENTS 1¶#endif†¢/*ŸA** The testcase() macro is used to aid in coverage testing.  WhenŸ?** doing coverage testing, the condition inside the argument toŸ?** testcase() must be evaluated both true and false in order toŸ>** get full branch coverage.  The testcase() macro is insertedŸ?** to help ensure adequate test coverage in places where simpleŸF** condition/decision coverage is inadequate.  For example, testcase()Ÿ<** can be used to make sure boundary values are tested.  ForŸ>** bitmask tests, testcase() can be used to make sure each bitŸ?** is significant and used at least once.  On switch statementsŸ@** where multiple cases go to the same block of code, testcase()Ÿ+** can insure that all cases are evaluated.¢**¢*/ª#ifdef SQLITE_COVERAGE_TESTŸ+SQLITE_PRIVATE   void sqlite3Coverage(int);Ÿ;# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }•#else¥# define testcase(X)¶#endif†¢/*ŸA** The TESTONLY macro is used to enclose variable declarations orŸ>** other bits of code that are needed to support the argumentsŸ)** within testcase() and assert() macros.¢*/Ÿ5#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)∑# define TESTONLY(X)  X•#else¥# define TESTONLY(X)¶#endif†¢/*ŸM** Sometimes we need a small amount of code such as a variable initializationŸH** to setup for a later assert() statement.  We do not want this code toŸF** appear when assert() is disabled.  The following macro is thereforeŸA** used to contain that setup code.  The "VVA" acronym stands forŸF** "Verification, Validation, and Accreditation".  In other words, theŸF** code within VVA_ONLY() will only run during verification processes.¢*/Æ#ifndef NDEBUG∑# define VVA_ONLY(X)  X•#else¥# define VVA_ONLY(X)¶#endif†¢/*ŸA** The ALWAYS and NEVER macros surround boolean expressions whichŸ?** are intended to always be true or false, respectively.  SuchŸC** expressions could be omitted from the code completely.  But theyŸA** are included in a few cases in order to enhance the resilienceŸE** of SQLite to unexpected behavior - to make the code "self-healing"ŸE** or "ductile" rather than being "brittle" and crashing at the firstæ** hint of unplanned behavior.¢**ŸA** In other words, ALWAYS and NEVER are added for defensive code.¢**ŸA** When doing coverage testing ALWAYS and NEVER are hard-coded toŸC** be true and false so that the unreachable code they specify willŸ#** not be counted as untested code.¢*/ŸB#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)ª# define ALWAYS(X)      (1)ª# define NEVER(X)       (0)∂#elif !defined(NDEBUG)Ÿ-# define ALWAYS(X)      ((X)?1:(assert(0),0))Ÿ-# define NEVER(X)       ((X)?(assert(0),1):0)•#elseª# define ALWAYS(X)      (X)ª# define NEVER(X)       (X)¶#endif†¢/*ŸD** Some conditionals are optimizations only.  In other words, if theŸG** conditionals are replaced with a constant 1 (true) or 0 (false) thenŸG** the correct answer is still obtained, though perhaps not as quickly.¢**Ÿ>** The following macros mark these optimizations conditionals.¢*/Ÿ!#if defined(SQLITE_MUTATION_TEST)Ÿ"# define OK_IF_ALWAYS_TRUE(X)  (1)Ÿ"# define OK_IF_ALWAYS_FALSE(X) (0)•#elseŸ"# define OK_IF_ALWAYS_TRUE(X)  (X)Ÿ"# define OK_IF_ALWAYS_FALSE(X) (X)¶#endif†¢/*ŸJ** Some malloc failures are only possible if SQLITE_TEST_REALLOC_STRESS isŸG** defined.  We need to defend against those failures when testing withŸI** SQLITE_TEST_REALLOC_STRESS, but we don't want the unreachable branchesŸK** during a normal build.  The following macro can be used to disable testsŸG** that are always false except when SQLITE_TEST_REALLOC_STRESS is set.¢*/Ÿ'#if defined(SQLITE_TEST_REALLOC_STRESS)Ÿ'# define ONLY_IF_REALLOC_STRESS(X)  (X)∂#elif !defined(NDEBUG)Ÿ9# define ONLY_IF_REALLOC_STRESS(X)  ((X)?(assert(0),1):0)•#elseŸ'# define ONLY_IF_REALLOC_STRESS(X)  (0)¶#endif†¢/*ŸA** Declarations used for tracing the operating system interfaces.¢*/Ÿ?#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) || \Ÿ,    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)º  extern int sqlite3OSTrace;ŸF# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf XΩ# define SQLITE_HAVE_OS_TRACE•#else≥# define OSTRACE(X)Ω# undef  SQLITE_HAVE_OS_TRACE¶#endif†¢/*ŸD** Is the sqlite3ErrName() function needed in the build?  Currently,ŸC** it is needed by "mutex_w32.c" (when debugging), "os_win.c" (whenŸA** OSTRACE is enabled), and by several "test*.c" files (which areø** compiled using SQLITE_TEST).¢*/Ÿ>#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) || \Ÿ,    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)Ω# define SQLITE_NEED_ERR_NAME•#elseΩ# undef  SQLITE_NEED_ERR_NAME¶#endif†¢/*ŸJ** SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN¢*/∫#ifdef SQLITE_OMIT_EXPLAINŸ&# undef SQLITE_ENABLE_EXPLAIN_COMMENTS¶#endif†¢/*ŸF** Return true (non-zero) if the input is an integer that is too largeŸF** to fit in 32-bits.  This macro is used inside of various testcase()ŸF** macros to verify that we have tested SQLite for large-file support.¢*/Ÿ2#define IS_BIG_INT(X)  (((X)&~(i64)0xffffffff)!=0)†¢/*Ÿ:** The macro unlikely() is a hint that surrounds a booleanŸ>** expression that is usually false.  Macro likely() surroundsŸA** a boolean expression that is usually true.  These hints could,ŸB** in theory, be used by the compiler to generate better code, butŸ6** currently they are just comments for human readers.¢*/∏#define likely(X)    (X)∏#define unlikely(X)  (X)†ŸO/************** Include hash.h in the middle of sqliteInt.h ******************/ŸO/************** Begin file hash.h ********************************************/¢/*¥** 2001 September 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸD** This is the header file for the generic hash-table implementation≤** used in SQLite.¢*/µ#ifndef SQLITE_HASH_Hµ#define SQLITE_HASH_H†Ÿ)/* Forward declarations of structures. */πtypedef struct Hash Hash;Ÿ!typedef struct HashElem HashElem;†ŸC/* A complete hash table is an instance of the following structure.ŸF** The internals of this structure are intended to be opaque -- clientŸK** code should not attempt to access or modify the fields of this structureŸE** directly.  Change this structure only by using the routines below.ŸF** However, some of the "procedures" and "functions" for modifying andŸF** accessing this structure are really macros, so we can't really makeπ** this structure opaque.¢**ŸE** All elements of the hash table are on a single doubly-linked list.Ÿ.** Hash.first points to the head of this list.¢**ŸB** There are Hash.htsize buckets.  Each bucket points to a spot inŸE** the global doubly-linked list.  The contents of the bucket are theŸE** element pointed to plus the next _ht.count-1 elements in the list.¢**ŸD** Hash.htsize and Hash.ht may be zero.  In that case lookup is doneŸA** by a linear search of the global list.  For small tables, the ŸE** Hash.ht table is never allocated because if there are few elementsŸB** in the table, it is faster to do a linear search than to manage≤** the hash table.¢*/≠struct Hash {ŸE  unsigned int htsize;      /* Number of buckets in the hash table */ŸA  unsigned int count;       /* Number of entries in this table */Ÿ@  HashElem *first;          /* The first element of the array */Ÿ0  struct _ht {              /* the hash table */ŸE    int count;                 /* Number of entries with this hash */ŸJ    HashElem *chain;           /* Pointer to first entry with this hash */®  } *ht;¢};†ŸB/* Each element in the hash table is an instance of the following ŸF** structure.  All elements are stored on a single doubly-linked list.¢**ŸF** Again, this structure is intended to be opaque, but it can't reallyŸ*** be opaque because it is used by macros.¢*/±struct HashElem {ŸL  HashElem *next, *prev;       /* Next and previous elements in the table */ŸF  void *data;                  /* Data associated with this element */ŸE  const char *pKey;            /* Key associated with this element */¢};†¢/*Ÿ6** Access routines.  To delete, insert a NULL pointer.¢*/Ÿ+SQLITE_PRIVATE void sqlite3HashInit(Hash*);ŸMSQLITE_PRIVATE void *sqlite3HashInsert(Hash*, const char *pKey, void *pData);ŸDSQLITE_PRIVATE void *sqlite3HashFind(const Hash*, const char *pKey);Ÿ,SQLITE_PRIVATE void sqlite3HashClear(Hash*);†¢/*ŸF** Macros for looping over all elements of a hash table.  The idiom is≠** like this:¢**¨**   Hash h;±**   HashElem *p;®**   ...Ÿ8**   for(p=sqliteHashFirst(&h); p; p=sqliteHashNext(p)){Ÿ0**     SomeStructure *pData = sqliteHashData(p);Ÿ!**     // do something with pData¶**   }¢*/Ÿ(#define sqliteHashFirst(H)  ((H)->first)Ÿ'#define sqliteHashNext(E)   ((E)->next)Ÿ'#define sqliteHashData(E)   ((E)->data)Ÿ9/* #define sqliteHashKey(E)    ((E)->pKey) // NOT USED */Ÿ;/* #define sqliteHashKeysize(E) ((E)->nKey)  // NOT USED */†¢/*Ÿ$** Number of entries in a hash table¢*/Ÿ:/* #define sqliteHashCount(H)  ((H)->count) // NOT USED */†∫#endif /* SQLITE_HASH_H */†ŸO/************** End of hash.h ************************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/ŸO/************** Include parse.h in the middle of sqliteInt.h *****************/ŸO/************** Begin file parse.h *******************************************/Ÿ-#define TK_SEMI                             1Ÿ-#define TK_EXPLAIN                          2Ÿ-#define TK_QUERY                            3Ÿ-#define TK_PLAN                             4Ÿ-#define TK_BEGIN                            5Ÿ-#define TK_TRANSACTION                      6Ÿ-#define TK_DEFERRED                         7Ÿ-#define TK_IMMEDIATE                        8Ÿ-#define TK_EXCLUSIVE                        9Ÿ-#define TK_COMMIT                          10Ÿ-#define TK_END                             11Ÿ-#define TK_ROLLBACK                        12Ÿ-#define TK_SAVEPOINT                       13Ÿ-#define TK_RELEASE                         14Ÿ-#define TK_TO                              15Ÿ-#define TK_TABLE                           16Ÿ-#define TK_CREATE                          17Ÿ-#define TK_IF                              18Ÿ-#define TK_NOT                             19Ÿ-#define TK_EXISTS                          20Ÿ-#define TK_TEMP                            21Ÿ-#define TK_LP                              22Ÿ-#define TK_RP                              23Ÿ-#define TK_AS                              24Ÿ-#define TK_WITHOUT                         25Ÿ-#define TK_COMMA                           26Ÿ-#define TK_ABORT                           27Ÿ-#define TK_ACTION                          28Ÿ-#define TK_AFTER                           29Ÿ-#define TK_ANALYZE                         30Ÿ-#define TK_ASC                             31Ÿ-#define TK_ATTACH                          32Ÿ-#define TK_BEFORE                          33Ÿ-#define TK_BY                              34Ÿ-#define TK_CASCADE                         35Ÿ-#define TK_CAST                            36Ÿ-#define TK_CONFLICT                        37Ÿ-#define TK_DATABASE                        38Ÿ-#define TK_DESC                            39Ÿ-#define TK_DETACH                          40Ÿ-#define TK_EACH                            41Ÿ-#define TK_FAIL                            42Ÿ-#define TK_OR                              43Ÿ-#define TK_AND                             44Ÿ-#define TK_IS                              45Ÿ-#define TK_MATCH                           46Ÿ-#define TK_LIKE_KW                         47Ÿ-#define TK_BETWEEN                         48Ÿ-#define TK_IN                              49Ÿ-#define TK_ISNULL                          50Ÿ-#define TK_NOTNULL                         51Ÿ-#define TK_NE                              52Ÿ-#define TK_EQ                              53Ÿ-#define TK_GT                              54Ÿ-#define TK_LE                              55Ÿ-#define TK_LT                              56Ÿ-#define TK_GE                              57Ÿ-#define TK_ESCAPE                          58Ÿ-#define TK_ID                              59Ÿ-#define TK_COLUMNKW                        60Ÿ-#define TK_FOR                             61Ÿ-#define TK_IGNORE                          62Ÿ-#define TK_INITIALLY                       63Ÿ-#define TK_INSTEAD                         64Ÿ-#define TK_NO                              65Ÿ-#define TK_KEY                             66Ÿ-#define TK_OF                              67Ÿ-#define TK_OFFSET                          68Ÿ-#define TK_PRAGMA                          69Ÿ-#define TK_RAISE                           70Ÿ-#define TK_RECURSIVE                       71Ÿ-#define TK_REPLACE                         72Ÿ-#define TK_RESTRICT                        73Ÿ-#define TK_ROW                             74Ÿ-#define TK_TRIGGER                         75Ÿ-#define TK_VACUUM                          76Ÿ-#define TK_VIEW                            77Ÿ-#define TK_VIRTUAL                         78Ÿ-#define TK_WITH                            79Ÿ-#define TK_REINDEX                         80Ÿ-#define TK_RENAME                          81Ÿ-#define TK_CTIME_KW                        82Ÿ-#define TK_ANY                             83Ÿ-#define TK_BITAND                          84Ÿ-#define TK_BITOR                           85Ÿ-#define TK_LSHIFT                          86Ÿ-#define TK_RSHIFT                          87Ÿ-#define TK_PLUS                            88Ÿ-#define TK_MINUS                           89Ÿ-#define TK_STAR                            90Ÿ-#define TK_SLASH                           91Ÿ-#define TK_REM                             92Ÿ-#define TK_CONCAT                          93Ÿ-#define TK_COLLATE                         94Ÿ-#define TK_BITNOT                          95Ÿ-#define TK_INDEXED                         96Ÿ-#define TK_STRING                          97Ÿ-#define TK_JOIN_KW                         98Ÿ-#define TK_CONSTRAINT                      99Ÿ-#define TK_DEFAULT                        100Ÿ-#define TK_NULL                           101Ÿ-#define TK_PRIMARY                        102Ÿ-#define TK_UNIQUE                         103Ÿ-#define TK_CHECK                          104Ÿ-#define TK_REFERENCES                     105Ÿ-#define TK_AUTOINCR                       106Ÿ-#define TK_ON                             107Ÿ-#define TK_INSERT                         108Ÿ-#define TK_DELETE                         109Ÿ-#define TK_UPDATE                         110Ÿ-#define TK_SET                            111Ÿ-#define TK_DEFERRABLE                     112Ÿ-#define TK_FOREIGN                        113Ÿ-#define TK_DROP                           114Ÿ-#define TK_UNION                          115Ÿ-#define TK_ALL                            116Ÿ-#define TK_EXCEPT                         117Ÿ-#define TK_INTERSECT                      118Ÿ-#define TK_SELECT                         119Ÿ-#define TK_VALUES                         120Ÿ-#define TK_DISTINCT                       121Ÿ-#define TK_DOT                            122Ÿ-#define TK_FROM                           123Ÿ-#define TK_JOIN                           124Ÿ-#define TK_USING                          125Ÿ-#define TK_ORDER                          126Ÿ-#define TK_GROUP                          127Ÿ-#define TK_HAVING                         128Ÿ-#define TK_LIMIT                          129Ÿ-#define TK_WHERE                          130Ÿ-#define TK_INTO                           131Ÿ-#define TK_FLOAT                          132Ÿ-#define TK_BLOB                           133Ÿ-#define TK_INTEGER                        134Ÿ-#define TK_VARIABLE                       135Ÿ-#define TK_CASE                           136Ÿ-#define TK_WHEN                           137Ÿ-#define TK_THEN                           138Ÿ-#define TK_ELSE                           139Ÿ-#define TK_INDEX                          140Ÿ-#define TK_ALTER                          141Ÿ-#define TK_ADD                            142Ÿ-#define TK_TRUEFALSE                      143Ÿ-#define TK_ISNOT                          144Ÿ-#define TK_FUNCTION                       145Ÿ-#define TK_COLUMN                         146Ÿ-#define TK_AGG_FUNCTION                   147Ÿ-#define TK_AGG_COLUMN                     148Ÿ-#define TK_UMINUS                         149Ÿ-#define TK_UPLUS                          150Ÿ-#define TK_TRUTH                          151Ÿ-#define TK_REGISTER                       152Ÿ-#define TK_VECTOR                         153Ÿ-#define TK_SELECT_COLUMN                  154Ÿ-#define TK_IF_NULL_ROW                    155Ÿ-#define TK_ASTERISK                       156Ÿ-#define TK_SPAN                           157Ÿ-#define TK_END_OF_FILE                    158Ÿ-#define TK_UNCLOSED_STRING                159Ÿ-#define TK_SPACE                          160Ÿ-#define TK_ILLEGAL                        161†Ÿ2/* The token codes above must all fit in 8 bits */Ÿ##define TKFLG_MASK           0xff  †Ÿ9/* Flags that can be added to a token code when it is notª** being stored in a u8: */ŸM#define TKFLG_DONTFOLD       0x100  /* Omit constant folding optimizations */†ŸO/************** End of parse.h ***********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/≤#include <stdio.h>≥#include <stdlib.h>≥#include <string.h>≥#include <assert.h>≥#include <stddef.h>†¢/*ŸI** Use a macro to replace memcpy() if compiled with SQLITE_INLINE_MEMCPY.ŸI** This allows better measurements of where memcpy() is used when runningŸE** cachegrind.  But this macro version of memcpy() is very slow so itŸG** should not be used in production.  This is a performance measurement≠** hack only.¢*/ª#ifdef SQLITE_INLINE_MEMCPYŸM# define memcpy(D,S,N) {char*xxd=(char*)(D);const char*xxs=(const char*)(S);\ŸE                        int xxn=(N);while(xxn-->0)*(xxd++)=*(xxs++);}¶#endif†¢/*ŸB** If compiling for a processor that lacks floating point support,Ÿ(** substitute integer for floating-point¢*/Ÿ!#ifdef SQLITE_OMIT_FLOATING_POINTº# define double sqlite_int64ª# define float sqlite_int64Ÿ%# define LONGDOUBLE_TYPE sqlite_int64∑# ifndef SQLITE_BIG_DBLŸ2#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)ß# endifŸ%# define SQLITE_OMIT_DATETIME_FUNCS 1º# define SQLITE_OMIT_TRACE 1Ÿ'# undef SQLITE_MIXED_ENDIAN_64BIT_FLOATπ# undef SQLITE_HAVE_ISNAN¶#endif∂#ifndef SQLITE_BIG_DBLæ# define SQLITE_BIG_DBL (1e99)¶#endif†¢/*ŸA** OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0ŸA** afterward. Having this macro allows us to cause the C compilerŸE** to omit code used by TEMP tables without messy #ifndef statements.¢*/π#ifdef SQLITE_OMIT_TEMPDBµ#define OMIT_TEMPDB 1•#elseµ#define OMIT_TEMPDB 0¶#endif†¢/*ŸF** The "file format" number is an integer that is incremented wheneverŸG** the VDBE-level file format changes.  The following macros define theŸH** the default file format for new databases and the maximum file formatΩ** that the library can read.¢*/Ÿ #define SQLITE_MAX_FILE_FORMAT 4Ÿ"#ifndef SQLITE_DEFAULT_FILE_FORMATŸ%# define SQLITE_DEFAULT_FILE_FORMAT 4¶#endif†¢/*ŸD** Determine whether triggers are recursive by default.  This can beŸ&** changed at run-time using a pragma.¢*/Ÿ)#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERSŸ,# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0¶#endif†¢/*ŸL** Provide a default value for SQLITE_TEMP_STORE in case it is not specified∂** on the command-line¢*/π#ifndef SQLITE_TEMP_STOREº# define SQLITE_TEMP_STORE 1¶#endif†¢/*ŸE** If no value has been provided for SQLITE_MAX_WORKER_THREADS, or ifŸD** SQLITE_TEMP_STORE is set to 3 (never use temporary files), set it´** to zero.¢*/Ÿ0#if SQLITE_TEMP_STORE==3 || SQLITE_THREADSAFE==0Ÿ!# undef SQLITE_MAX_WORKER_THREADSŸ$# define SQLITE_MAX_WORKER_THREADS 0¶#endifŸ!#ifndef SQLITE_MAX_WORKER_THREADSŸ$# define SQLITE_MAX_WORKER_THREADS 8¶#endifŸ%#ifndef SQLITE_DEFAULT_WORKER_THREADSŸ(# define SQLITE_DEFAULT_WORKER_THREADS 0¶#endifŸ;#if SQLITE_DEFAULT_WORKER_THREADS>SQLITE_MAX_WORKER_THREADSŸ!# undef SQLITE_MAX_WORKER_THREADSŸ@# define SQLITE_MAX_WORKER_THREADS SQLITE_DEFAULT_WORKER_THREADS¶#endif†¢/*ŸG** The default initial allocation for the pagecache when using separateŸE** pagecaches for each database connection.  A positive number is theŸI** number of pages.  A negative number N translations means that a bufferŸL** of -1024*N bytes is allocated and used for as many pages as it will hold.¢**ŸH** The default value of "20" was choosen to minimize the run-time of theŸD** speedtest1 test program with options: --shrink-memory --reprepare¢*/Ÿ$#ifndef SQLITE_DEFAULT_PCACHE_INITSZŸ(# define SQLITE_DEFAULT_PCACHE_INITSZ 20¶#endif†¢/*Ÿ6** The compile-time options SQLITE_MMAP_READWRITE and ŸH** SQLITE_ENABLE_BATCH_ATOMIC_WRITE are not compatible with one another.Ÿ>** You must choose one or the other (or neither) but not both.¢*/ŸO#if defined(SQLITE_MMAP_READWRITE) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)ŸQ#error Cannot use both SQLITE_MMAP_READWRITE and SQLITE_ENABLE_BATCH_ATOMIC_WRITE¶#endif†¢/*ŸB** GCC does not define the offsetof() macro so we'll have to do it≠** ourselves.¢*/∞#ifndef offsetofŸI#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))¶#endif†¢/*Ÿ8** Macros to compute minimum and maximum of two numbers.¢*/´#ifndef MINŸ## define MIN(A,B) ((A)<(B)?(A):(B))¶#endif´#ifndef MAXŸ## define MAX(A,B) ((A)>(B)?(A):(B))¶#endif†¢/*Ÿ!** Swap two objects of type TYPE.¢*/Ÿ,#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}†¢/*ŸA** Check to see if this machine uses EBCDIC.  (Yes, believe it orŸ<** not, there are still machines out there that use EBCDIC.)¢*/±#if 'A' == '\301'∏# define SQLITE_EBCDIC 1•#else∑# define SQLITE_ASCII 1¶#endif†¢/*ŸJ** Integers of known sizes.  These typedefs might change for architecturesŸG** where the sizes very.  Preprocessor macros are available so that theŸC** types can be conveniently redefined at compile-type.  Like this:¢**Ÿ0**         cc '-DUINTPTR_TYPE=long long int' ...¢*/≥#ifndef UINT32_TYPEµ# ifdef HAVE_UINT32_Tæ#  define UINT32_TYPE uint32_t¶# elseŸ"#  define UINT32_TYPE unsigned intß# endif¶#endif≥#ifndef UINT16_TYPEµ# ifdef HAVE_UINT16_Tæ#  define UINT16_TYPE uint16_t¶# elseŸ(#  define UINT16_TYPE unsigned short intß# endif¶#endif≤#ifndef INT16_TYPE¥# ifdef HAVE_INT16_Tº#  define INT16_TYPE int16_t¶# elseæ#  define INT16_TYPE short intß# endif¶#endif≤#ifndef UINT8_TYPE¥# ifdef HAVE_UINT8_Tº#  define UINT8_TYPE uint8_t¶# elseŸ"#  define UINT8_TYPE unsigned charß# endif¶#endif±#ifndef INT8_TYPE≥# ifdef HAVE_INT8_T∫#  define INT8_TYPE int8_t¶# elseø#  define INT8_TYPE signed charß# endif¶#endif∑#ifndef LONGDOUBLE_TYPEŸ$# define LONGDOUBLE_TYPE long double¶#endifŸ>typedef sqlite_int64 i64;          /* 8-byte signed integer */Ÿ@typedef sqlite_uint64 u64;         /* 8-byte unsigned integer */Ÿ@typedef UINT32_TYPE u32;           /* 4-byte unsigned integer */Ÿ@typedef UINT16_TYPE u16;           /* 2-byte unsigned integer */Ÿ>typedef INT16_TYPE i16;            /* 2-byte signed integer */Ÿ@typedef UINT8_TYPE u8;             /* 1-byte unsigned integer */Ÿ>typedef INT8_TYPE i8;              /* 1-byte signed integer */†¢/*ŸA** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 valueŸ?** that can be stored in a u32 without loss of data.  The valueŸF** is 0x00000000ffffffff.  But because of quirks of some compilers, weŸ@** have to specify the value in the less intuitive manner shown:¢*/Ÿ*#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)†¢/*ŸB** The datatype used to store estimates of the number of rows in aŸC** table or index.  This is an unsigned integer type.  For 99.9% ofŸC** the world, a 32-bit integer is sufficient.  But a 64-bit integerŸ*** can be used at compile-time if desired.¢*/π#ifdef SQLITE_64BIT_STATSŸG typedef u64 tRowcnt;    /* 64-bit only if requested at compile-time */•#elseŸ4 typedef u32 tRowcnt;    /* 32-bit is the default */¶#endif†¢/*ŸD** Estimated quantities used for query planning are stored as 16-bitŸE** logarithms.  For quantity X, the value stored is 10*log2(X).  ThisŸG** gives a possible range of values of approximately 1.0e986 to 1e-986.ŸJ** But the allowed values are "grainy".  Not every value is representable.ŸE** For example, quantities 16 and 17 are both represented by a LogEstŸH** of 40.  However, since LogEst quantities are suppose to be estimates,Ÿ7** not exact values, this imprecision is not a problem.¢**Ÿ0** "LogEst" is short for "Logarithmic Estimate".¢**¨** Examples:Ÿ:**      1 -> 0              20 -> 43          10000 -> 132Ÿ:**      2 -> 10             25 -> 46          25000 -> 146Ÿ:**      3 -> 16            100 -> 66        1000000 -> 199Ÿ:**      4 -> 20           1000 -> 99        1048576 -> 200Ÿ:**     10 -> 33           1024 -> 100    4294967296 -> 320¢**Ÿ<** The LogEst can be negative to indicate fractional values.¨** Examples:¢**Ÿ:**    0.5 -> -10           0.1 -> -33        0.0625 -> -40¢*/∫typedef INT16_TYPE LogEst;†¢/*ŸC** Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer¢*/∂#ifndef SQLITE_PTRSIZEŸ # if defined(__SIZEOF_POINTER__)Ÿ,#   define SQLITE_PTRSIZE __SIZEOF_POINTER__ŸK# elif defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \ŸA       defined(_M_ARM)   || defined(__arm__)    || defined(__x86)ª#   define SQLITE_PTRSIZE 4¶# elseª#   define SQLITE_PTRSIZE 8ß# endif¶#endif†ŸF/* The uptr type is an unsigned integer large enough to hold a pointer¢*/∫#if defined(HAVE_STDINT_H)π  typedef uintptr_t uptr;∑#elif SQLITE_PTRSIZE==4≥  typedef u32 uptr;•#else≥  typedef u64 uptr;¶#endif†¢/*ŸF** The SQLITE_WITHIN(P,S,E) macro checks to see if pointer P points toŸ5** something between S (inclusive) and E (exclusive).¢**ŸK** In other words, S is a buffer and E is a pointer to the first byte afterŸI** the end of buffer S.  This macro returns true if P points to somethingŸ!** contained within the buffer S.¢*/ŸL#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))††¢/*ŸC** Macros to determine whether the machine is big or little endian,ŸE** and whether or not that determination is run-time or compile-time.¢**ŸF** For best performance, an attempt is made to guess at the byte-orderŸ?** using C-preprocessor macros.  If that is unsuccessful, or ifŸ=** -DSQLITE_BYTEORDER=0 is set, then byte-order is determinedØ** at run-time.¢*/∏#ifndef SQLITE_BYTEORDERŸI# if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \ŸI     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \ŸI     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \µ     defined(__arm__)Ÿ##   define SQLITE_BYTEORDER    1234Ÿ,# elif defined(sparc)    || defined(__ppc__)Ÿ##   define SQLITE_BYTEORDER    4321¶# elseΩ#   define SQLITE_BYTEORDER 0ß# endif¶#endif∫#if SQLITE_BYTEORDER==4321æ# define SQLITE_BIGENDIAN    1æ# define SQLITE_LITTLEENDIAN 0Ÿ+# define SQLITE_UTF16NATIVE  SQLITE_UTF16BEº#elif SQLITE_BYTEORDER==1234æ# define SQLITE_BIGENDIAN    0æ# define SQLITE_LITTLEENDIAN 1Ÿ+# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE•#elseª# ifdef SQLITE_AMALGAMATIONª  const int sqlite3one = 1;¶# elseæ  extern const int sqlite3one;ß# endifŸ8# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)Ÿ8# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)ŸM# define SQLITE_UTF16NATIVE  (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)¶#endif†¢/*ŸJ** Constants for the largest and smallest possible 64-bit signed integers.ŸH** These macros are designed to work correctly on both 32-bit and 64-bit≠** compilers.¢*/Ÿ;#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))Ÿ2#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)†¢/*ŸD** Round up a number to the next larger multiple of 8.  This is usedŸ5** to force 8-byte alignment on 64-bit architectures.¢*/Ÿ"#define ROUND8(x)     (((x)+7)&~7)†¢/*Ÿ*** Round down to the nearest multiple of 8¢*/æ#define ROUNDDOWN8(x) ((x)&~7)†¢/*ŸD** Assert that the pointer X is aligned to an 8-byte boundary.  ThisŸB** macro is used only within assert() to verify that the code getsŸ&** all alignment restrictions correct.¢**Ÿ?** Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then theŸD** underlying malloc() implementation might return us 4-byte alignedŸ9** pointers.  In that case, only verify 4-byte alignment.¢*/Ÿ##ifdef SQLITE_4_BYTE_ALIGNED_MALLOCŸC# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)•#elseŸC# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)¶#endif†¢/*Ÿ:** Disable MMAP on platforms where it is known to not work¢*/Ÿ/#if defined(__OpenBSD__) || defined(__QNXNTO__)º# undef SQLITE_MAX_MMAP_SIZEø# define SQLITE_MAX_MMAP_SIZE 0¶#endif†¢/*ŸF** Default maximum size of memory used by memory-mapped I/O in the VFS¢*/∞#ifdef __APPLE__Ÿ # include <TargetConditionals.h>¶#endifº#ifndef SQLITE_MAX_MMAP_SIZEπ# if defined(__linux__) \∂  || defined(_WIN32) \Ÿ0  || (defined(__APPLE__) && defined(__MACH__)) \µ  || defined(__sun) \ª  || defined(__FreeBSD__) \ª  || defined(__DragonFly__)Ÿ<#   define SQLITE_MAX_MMAP_SIZE 0x7fff0000  /* 2147418112 */¶# elseŸ!#   define SQLITE_MAX_MMAP_SIZE 0ß# endif¶#endif†¢/*ŸH** The default MMAP_SIZE is zero on all platforms.  Or, even if a largerŸI** default MMAP_SIZE is specified at compile-time, make sure that it doesŸ$** not exceed the maximum mmap size.¢*/Ÿ #ifndef SQLITE_DEFAULT_MMAP_SIZEŸ## define SQLITE_DEFAULT_MMAP_SIZE 0¶#endifŸ1#if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZEŸ # undef SQLITE_DEFAULT_MMAP_SIZEŸ6# define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE¶#endif†¢/*ŸI** Only one of SQLITE_ENABLE_STAT3 or SQLITE_ENABLE_STAT4 can be defined.ŸI** Priority is given to SQLITE_ENABLE_STAT4.  If either are defined, alsoŸ&** define SQLITE_ENABLE_STAT3_OR_STAT4¢*/∫#ifdef SQLITE_ENABLE_STAT4ª# undef SQLITE_ENABLE_STAT3Ÿ'# define SQLITE_ENABLE_STAT3_OR_STAT4 1π#elif SQLITE_ENABLE_STAT3Ÿ'# define SQLITE_ENABLE_STAT3_OR_STAT4 1Ÿ"#elif SQLITE_ENABLE_STAT3_OR_STAT4Ÿ$# undef SQLITE_ENABLE_STAT3_OR_STAT4¶#endif†¢/*ŸH** SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or notŸ9** the Select query generator tracing logic is turned on.¢*/Ÿ&#if defined(SQLITE_ENABLE_SELECTTRACE)æ# define SELECTTRACE_ENABLED 1•#elseæ# define SELECTTRACE_ENABLED 0¶#endif†¢/*ŸK** An instance of the following structure is used to store the busy-handlerŸ&** callback for a given sqlite handle.¢**ŸG** The sqlite.busyHandler member of the sqlite struct contains the busyŸE** callback for the database handle. Each pager opened via the sqliteŸE** handle is passed a pointer to sqlite.busyHandler. The busy-handlerŸ:** callback is currently invoked only from within pager.c.¢*/Ÿ'typedef struct BusyHandler BusyHandler;¥struct BusyHandler {Ÿ;  int (*xBusyHandler)(void *,int);  /* The busy callback */ŸD  void *pBusyArg;                   /* First arg to busy callback */ŸI  int nBusy;                        /* Incremented with each busy call */ŸN  u8 bExtraFileArg;                 /* Include sqlite3_file as callback arg */¢};†¢/*Ÿ@** Name of the master database table.  The master database tableŸ@** is a special table that holds the names and attributes of allª** user tables and indices.¢*/Ÿ)#define MASTER_NAME       "sqlite_master"Ÿ.#define TEMP_MASTER_NAME  "sqlite_temp_master"†¢/*Ÿ.** The root-page of the master database table.¢*/ª#define MASTER_ROOT       1†¢/*Ÿ ** The name of the schema table.¢*/ŸN#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)†¢/*Ÿ=** A convenience macro that returns the number of elements in¨** an array.¢*/Ÿ7#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))†¢/*Ÿ.** Determine if the argument is a power of two¢*/Ÿ*#define IsPowerOfTwo(X) (((X)&((X)-1))==0)†¢/*ŸD** The following value as a destructor means to use sqlite3DbFree().ŸE** The sqlite3DbFree() routine requires two parameters instead of theŸI** one parameter that destructors normally want.  So we have to introduceŸC** this magic value that the code knows to handle differently.  AnyŸF** pointer will work here as long as it is distinct from SQLITE_STATIC∏** and SQLITE_TRANSIENT.¢*/ŸE#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3MallocSize)†¢/*ŸJ** When SQLITE_OMIT_WSD is defined, it means that the target platform doesŸN** not support Writable Static Data (WSD) such as global and static variables.ŸJ** All variables must either be on the stack or dynamically allocated fromŸJ** the heap.  When WSD is unsupported, the variable declarations scatteredŸL** throughout the SQLite code must become constants instead.  The SQLITE_WSDŸK** macro is used for this purpose.  And instead of referencing the variableŸJ** directly, we use its constant as a key to lookup the run-time allocatedŸI** buffer that holds real variable.  The constant is also the initializerŸ%** for the run-time allocated buffer.¢**ŸF** In the usual case where WSD is supported, the SQLITE_WSD and GLOBALŸ9** macros become no-ops and have zero performance impact.¢*/∂#ifdef SQLITE_OMIT_WSD∫  #define SQLITE_WSD constŸE  #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))ŸI  #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)Ÿ.SQLITE_API int sqlite3_wsd_init(int N, int J);Ÿ2SQLITE_API void *sqlite3_wsd_find(void *K, int L);•#else¥  #define SQLITE_WSD∑  #define GLOBAL(t,v) vŸ+  #define sqlite3GlobalConfig sqlite3Config¶#endif†¢/*ŸE** The following macros are used to suppress compiler warnings and toŸK** make it clear to human readers when a function parameter is deliberatelyŸG** left unused within the body of a function. This usually happens whenŸ?** a function is called via a function pointer. For example theŸC** implementation of an SQL aggregate step callback may not use theŸH** parameter indicating the number of arguments passed to the aggregate,Ÿ/** if it knows that this is enforced elsewhere.¢**ŸN** When a function parameter is not used at all within the body of a function,ŸM** it is generally named "NotUsed" or "NotUsed2" to make things even clearer.ŸI** However, these macros may also be used to suppress warnings related toŸK** parameters that may or may not be used depending on compilation options.ŸJ** For example those parameters only used in assert() statements. In theseŸ?** cases the parameters are named as per the usual conventions.¢*/Ÿ%#define UNUSED_PARAMETER(x) (void)(x)ŸF#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)†¢/*Ÿ#** Forward references to structures¢*/øtypedef struct AggInfo AggInfo;Ÿ'typedef struct AuthContext AuthContext;Ÿ'typedef struct AutoincInfo AutoincInfo;Ωtypedef struct Bitvec Bitvec;øtypedef struct CollSeq CollSeq;Ωtypedef struct Column Column;µtypedef struct Db Db;Ωtypedef struct Schema Schema;πtypedef struct Expr Expr;Ÿ!typedef struct ExprList ExprList;πtypedef struct FKey FKey;Ÿ-typedef struct FuncDestructor FuncDestructor;øtypedef struct FuncDef FuncDef;Ÿ'typedef struct FuncDefHash FuncDefHash;Ωtypedef struct IdList IdList;ªtypedef struct Index Index;Ÿ'typedef struct IndexSample IndexSample;Ÿ!typedef struct KeyClass KeyClass;øtypedef struct KeyInfo KeyInfo;Ÿ#typedef struct Lookaside Lookaside;Ÿ+typedef struct LookasideSlot LookasideSlot;Ωtypedef struct Module Module;Ÿ'typedef struct NameContext NameContext;ªtypedef struct Parse Parse;Ÿ#typedef struct PreUpdate PreUpdate;Ÿ/typedef struct PrintfArguments PrintfArguments;Ωtypedef struct RowSet RowSet;Ÿ#typedef struct Savepoint Savepoint;Ωtypedef struct Select Select;Ÿ)typedef struct SQLiteThread SQLiteThread;Ÿ%typedef struct SelectDest SelectDest;øtypedef struct SrcList SrcList;Ÿ!typedef struct StrAccum StrAccum;ªtypedef struct Table Table;Ÿ#typedef struct TableLock TableLock;ªtypedef struct Token Token;Ÿ!typedef struct TreeView TreeView;øtypedef struct Trigger Trigger;Ÿ%typedef struct TriggerPrg TriggerPrg;Ÿ'typedef struct TriggerStep TriggerStep;Ÿ-typedef struct UnpackedRecord UnpackedRecord;Ωtypedef struct VTable VTable;øtypedef struct VtabCtx VtabCtx;Ωtypedef struct Walker Walker;Ÿ#typedef struct WhereInfo WhereInfo;πtypedef struct With With;†ŸJ/* A VList object records a mapping between parameters/variables/wildcardsŸE** in the SQL statement (such as $abc, @pqr, or :xyz) and the integerŸN** variable number associated with that parameter.  See the format descriptionŸL** on the sqlite3VListAdd() routine for more information.  A VList is reallyΩ** just an array of integers.¢*/≤typedef int VList;†¢/*Ÿ=** Defer sourcing vdbe.h and btree.h until after the "u8" andŸC** "BusyHandler" typedefs. vdbe.h also requires a few of the opaqueŸ.** pointer types (i.e. FuncDef) defined above.¢*/ŸO/************** Include btree.h in the middle of sqliteInt.h *****************/ŸO/************** Begin file btree.h *******************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸE** This header file defines the interface that the sqlite B-Tree fileŸI** subsystem.  See comments in the source code for a detailed descriptionŸ'** of what each interface routine does.¢*/∂#ifndef SQLITE_BTREE_H∂#define SQLITE_BTREE_H†ŸF/* TODO: This definition is just included so other modules compile. Itπ** needs to be revisited.¢*/æ#define SQLITE_N_BTREE_META 16†¢/*ŸG** If defined as non-zero, auto-vacuum is enabled by default. OtherwiseŸI** it must be turned on for each database using "PRAGMA auto_vacuum = 1".¢*/Ÿ!#ifndef SQLITE_DEFAULT_AUTOVACUUMŸ%  #define SQLITE_DEFAULT_AUTOVACUUM 0¶#endif†ŸB#define BTREE_AUTOVACUUM_NONE 0        /* Do not do auto-vacuum */Ÿ@#define BTREE_AUTOVACUUM_FULL 1        /* Do full auto-vacuum */Ÿ?#define BTREE_AUTOVACUUM_INCR 2        /* Incremental vacuum */†¢/*Ÿ$** Forward declarations of structure¢*/ªtypedef struct Btree Btree;Ÿ!typedef struct BtCursor BtCursor;Ÿ!typedef struct BtShared BtShared;Ÿ)typedef struct BtreePayload BtreePayload;††Ÿ$SQLITE_PRIVATE int sqlite3BtreeOpen(Ÿ<  sqlite3_vfs *pVfs,       /* VFS to use with this b-tree */Ÿ>  const char *zFilename,   /* Name of database file to open */Ÿ?  sqlite3 *db,             /* Associated database connection */Ÿ8  Btree **ppBtree,         /* Return open Btree* here */Ÿ&  int flags,               /* Flags */ŸA  int vfsFlags             /* Flags passed through to VFS open */¢);†ŸG/* The flags parameter to sqlite3BtreeOpen can be the bitwise or of the¥** following values.¢**ŸD** NOTE:  These values must match the corresponding PAGER_ values in´** pager.h.¢*/ŸL#define BTREE_OMIT_JOURNAL  1  /* Do not create or use a rollback journal */Ÿ<#define BTREE_MEMORY        2  /* This is an in-memory DB */ŸG#define BTREE_SINGLE        4  /* The file contains at most 1 b-tree */ŸG#define BTREE_UNORDERED     8  /* Use of a hash implementation is OK */†Ÿ-SQLITE_PRIVATE int sqlite3BtreeClose(Btree*);Ÿ8SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree*,int);Ÿ8SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree*,int);∫#if SQLITE_MAX_MMAP_SIZE>0ŸDSQLITE_PRIVATE   int sqlite3BtreeSetMmapLimit(Btree*,sqlite3_int64);¶#endifŸ>SQLITE_PRIVATE int sqlite3BtreeSetPagerFlags(Btree*,unsigned);Ÿ\SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);Ÿ3SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*);Ÿ8SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int);Ÿ0SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);Ÿ8SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*,int);Ÿ9SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree*);Ÿ;SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p);Ÿ;SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int);Ÿ6SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *);Ÿ6SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int);ŸKSQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);Ÿ;SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree*, int);Ÿ.SQLITE_PRIVATE int sqlite3BtreeCommit(Btree*);Ÿ8SQLITE_PRIVATE int sqlite3BtreeRollback(Btree*,int,int);Ÿ5SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree*,int);ŸDSQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, int*, int flags);Ÿ1SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree*);Ÿ5SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree*);Ÿ2SQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree*);ŸGSQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));Ÿ;SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *pBtree);Ÿ #ifndef SQLITE_OMIT_SHARED_CACHEŸRSQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);¶#endifŸ<SQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *, int, int);†Ÿ<SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *);Ÿ?SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *);Ÿ:SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *, Btree *);†Ÿ3SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *);†ŸG/* The flags parameter to sqlite3BtreeCreateTable can be the bitwise ORº** of the flags shown below.¢**ŸI** Every SQLite table must have either BTREE_INTKEY or BTREE_BLOBKEY set.ŸJ** With BTREE_INTKEY, the table key is a 64-bit integer and arbitrary dataŸI** is stored in the leaves.  (BTREE_INTKEY is used for SQL tables.)  WithŸG** BTREE_BLOBKEY, the key is an arbitrary BLOB and no content is storedŸE** anywhere - the key is the content.  (BTREE_BLOBKEY is used for SQL¨** indices.)¢*/ŸM#define BTREE_INTKEY     1    /* Table has only 64-bit signed integer keys */ŸA#define BTREE_BLOBKEY    2    /* Table has keys only - no data */†Ÿ<SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree*, int, int*);Ÿ=SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, int*);Ÿ=SQLITE_PRIVATE int sqlite3BtreeClearTableOfCursor(BtCursor*);Ÿ@SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree*, int, int);†ŸMSQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);ŸFSQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);†Ÿ/SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p);†¢/*ŸH** The second parameter to sqlite3BtreeGetMeta or sqlite3BtreeUpdateMetaŸJ** should be one of the following values. The integer values are assigned ŸC** to constants so that the offset of the corresponding field in anŸC** SQLite database header may be found using the following formula:¢**º**   offset = 36 + (idx * 4)¢**ŸI** For example, the free-page-count field is located at byte offset 36 ofŸE** the database file header. The incr-vacuum-flag field is located atæ** byte offset 64 (== 36+4*7).¢**ŸK** The BTREE_DATA_VERSION value is not really a value stored in the header.ŸH** It is a read-only number computed by the pager.  But we merge it withŸI** the header value access routines since its access pattern is the same.Ÿ"** Call it a "virtual meta value".¢*/Ÿ##define BTREE_FREE_PAGE_COUNT     0Ÿ##define BTREE_SCHEMA_VERSION      1Ÿ##define BTREE_FILE_FORMAT         2Ÿ##define BTREE_DEFAULT_CACHE_SIZE  3Ÿ##define BTREE_LARGEST_ROOT_PAGE   4Ÿ##define BTREE_TEXT_ENCODING       5Ÿ##define BTREE_USER_VERSION        6Ÿ##define BTREE_INCR_VACUUM         7Ÿ##define BTREE_APPLICATION_ID      8Ÿ@#define BTREE_DATA_VERSION        15  /* A virtual meta-value */†¢/*ŸF** Kinds of hints that can be passed into the sqlite3BtreeCursorHint()≠** interface.¢**Ÿ-** BTREE_HINT_RANGE  (arguments: Expr*, Mem*)¢**ŸM**     The first argument is an Expr* (which is guaranteed to be constant forŸI**     the lifetime of the cursor) that defines constraints on which rowsŸE**     might be fetched with this cursor.  The Expr* tree may containŸN**     TK_REGISTER nodes that refer to values stored in the array of registersŸO**     passed as the second parameter.  In other words, if Expr.op==TK_REGISTERŸI**     then the value of the node is the value in Mem[pExpr.iTable].  AnyŸJ**     TK_COLUMN node in the expression tree refers to the Expr.iColumn-thŸJ**     column of the b-tree of the cursor.  The Expr tree will not containŸM**     any function calls nor subqueries nor references to b-trees other thanø**     the cursor being hinted.¢**ŸK**     The design of the _RANGE hint is aid b-tree implementations that tryŸB**     to prefetch content from remote machines - to provide thoseŸM**     implementations with limits on what needs to be prefetched and therebyŸ **     reduce network bandwidth.¢**ŸJ** Note that BTREE_HINT_FLAGS with BTREE_BULKLOAD is the only hint used byŸI** standard SQLite.  The other hints are provided for extentions that useŸH** the SQLite parser and code generator but substitute their own storage™** engine.¢*/ŸC#define BTREE_HINT_RANGE 0       /* Range constraints on queries */†¢/*Ÿ?** Values that may be OR'd together to form the argument to theŸ6** BTREE_HINT_FLAGS hint for sqlite3BtreeCursorHint():¢**ŸJ** The BTREE_BULKLOAD flag is set on index cursors when the index is goingŸ=** to be filled with content that is already in sorted order.¢**ŸF** The BTREE_SEEK_EQ flag is set on cursors that will get OP_SeekGE orŸG** OP_SeekLE opcodes for a range search, but where the range of entriesŸH** selected will all have the same key.  In other words, the cursor willŸ*** be used only for equality key searches.¢**¢*/ŸK#define BTREE_BULKLOAD 0x00000001  /* Used to full index in sorted order */ŸG#define BTREE_SEEK_EQ  0x00000002  /* EQ seeks only - no range seeks */†£/* Ÿ>** Flags passed as the third argument to sqlite3BtreeCursor().¢**ŸK** For read-only cursors the wrFlag argument is always zero. For read-writeŸH** cursors it may be set to either (BTREE_WRCSR|BTREE_FORDELETE) or justŸI** (BTREE_WRCSR). If the BTREE_FORDELETE bit is set, then the cursor willŸ,** only be used by SQLite for the following:¢**Ÿ:**   * to seek to and then delete specific entries, and/or¢**ŸA**   * to read values that will be used to create keys that otherŸ7**     BTREE_FORDELETE cursors will seek to and delete.¢**ŸG** The BTREE_FORDELETE flag is an optimization hint.  It is not used byŸF** by this, the native b-tree engine of SQLite, but it is available toŸI** alternative storage engines that might be substituted in place of thisŸG** b-tree system.  For alternative storage engines in which a delete ofŸE** the main table row automatically deletes corresponding index rows,ŸF** the FORDELETE flag hint allows those alternative storage engines toŸE** skip a lot of work.  Namely:  FORDELETE cursors may treat all SEEKŸD** and DELETE operations as no-ops, and any READ operation against aŸ5** FORDELETE cursor may return a null row: 0x01 0x00.¢*/Ÿ>#define BTREE_WRCSR     0x00000004     /* read-write cursor */ŸK#define BTREE_FORDELETE 0x00000008     /* Cursor is for seek/delete only */†Ÿ&SQLITE_PRIVATE int sqlite3BtreeCursor(ŸK  Btree*,                              /* BTree containing table to open */Ÿ?  int iTable,                          /* Index of root page */ŸL  int wrFlag,                          /* 1 for writing.  0 for read-only */ŸO  struct KeyInfo*,                     /* First argument to compare function */ŸL  BtCursor *pCursor                    /* Space to write cursor structure */¢);Ÿ;SQLITE_PRIVATE BtCursor *sqlite3BtreeFakeValidCursor(void);Ÿ0SQLITE_PRIVATE int sqlite3BtreeCursorSize(void);Ÿ6SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor*);ŸESQLITE_PRIVATE void sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);Ÿ!#ifdef SQLITE_ENABLE_CURSOR_HINTSŸ@SQLITE_PRIVATE void sqlite3BtreeCursorHint(BtCursor*, int, ...);¶#endif†Ÿ6SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor*);Ÿ.SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(¨  BtCursor*,π  UnpackedRecord *pUnKey,≠  i64 intKey,´  int bias,´  int *pRes¢);Ÿ9SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*);Ÿ>SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor*, int*);Ÿ;SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*, u8 flags);†ŸE/* Allowed flags for sqlite3BtreeDelete() and sqlite3BtreeInsert() */ŸL#define BTREE_SAVEPOSITION 0x02  /* Leave cursor pointing at NEXT or PREV */ŸG#define BTREE_AUXDELETE    0x04  /* not the primary delete operation */ŸA#define BTREE_APPEND       0x08  /* Insert is likely an append */†ŸK/* An instance of the BtreePayload object describes the content of a singleŸ+** entry in either an index or table btree.¢**ŸH** Index btrees (used for indexes and also WITHOUT ROWID tables) containŸJ** an arbitrary key and no data.  These btrees have pKey,nKey set to theirŸ)** key and pData,nData,nZero set to zero.¢**ŸH** Table btrees (used for rowid tables) contain an integer rowid used asŸC** the key and passed in the nKey field.  The pKey field is zero.  ŸI** pData,nData hold the content of the new entry.  nZero extra zero bytesŸF** are appended to the end of the content when constructing the entry.¢**ŸJ** This object is used to pass information into sqlite3BtreeInsert().  TheŸO** same information used to be passed as five separate parameters.  But placingŸE** the information into this object helps to keep the interface more ŸH** organized and understandable, and it also helps the resulting code toŸF** run a little faster by using fewer registers for parameter passing.¢*/µstruct BtreePayload {ŸI  const void *pKey;       /* Key content for indexes.  NULL for tables */ŸO  sqlite3_int64 nKey;     /* Size of pKey for indexes.  PRIMARY KEY for tabs */ŸB  const void *pData;      /* Data for tables.  NULL for indexes */ŸH  sqlite3_value *aMem;    /* First of nMem value in the unpacked pKey */ŸF  u16 nMem;               /* Number of aMem[] value.  Might be zero */Ÿ:  int nData;              /* Size of pData.  0 if none. */ŸJ  int nZero;              /* Extra zero data appended after pData,nData */¢};†ŸNSQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,Ÿ2                       int flags, int seekResult);Ÿ;SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes);Ÿ:SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes);Ÿ:SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int flags);Ÿ.SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*);Ÿ>SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int flags);Ÿ5SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor*);Ÿ$#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNCŸ1SQLITE_PRIVATE i64 sqlite3BtreeOffset(BtCursor*);¶#endifŸNSQLITE_PRIVATE int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);ŸJSQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);Ÿ6SQLITE_PRIVATE u32 sqlite3BtreePayloadSize(BtCursor*);†ŸZSQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);Ÿ7SQLITE_PRIVATE struct Pager *sqlite3BtreePager(Btree*);Ÿ6SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor*);†º#ifndef SQLITE_OMIT_INCRBLOBŸUSQLITE_PRIVATE int sqlite3BtreePayloadChecked(BtCursor*, u32 offset, u32 amt, void*);ŸNSQLITE_PRIVATE int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);Ÿ;SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *);¶#endifŸ8SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *);ŸDSQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);ŸKSQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);Ÿ6SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *pBt);Ÿ0SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void);†Æ#ifndef NDEBUGŸ8SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor*);¶#endifŸ:SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor*);†æ#ifndef SQLITE_OMIT_BTREECOUNTŸ8SQLITE_PRIVATE int sqlite3BtreeCount(BtCursor *, i64 *);¶#endif†≤#ifdef SQLITE_TESTŸ@SQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int);Ÿ3SQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*);¶#endif†∑#ifndef SQLITE_OMIT_WALŸGSQLITE_PRIVATE   int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);¶#endif†¢/*Ÿ=** If we are not using shared cache, then there is no need toŸ>** use mutexes to access the BtShared structures.  So make theŸ%** Enter and Leave procedures no-ops.¢*/Ÿ #ifndef SQLITE_OMIT_SHARED_CACHEŸ0SQLITE_PRIVATE   void sqlite3BtreeEnter(Btree*);Ÿ5SQLITE_PRIVATE   void sqlite3BtreeEnterAll(sqlite3*);Ÿ2SQLITE_PRIVATE   int sqlite3BtreeSharable(Btree*);Ÿ9SQLITE_PRIVATE   void sqlite3BtreeEnterCursor(BtCursor*);Ÿ9SQLITE_PRIVATE   int sqlite3BtreeConnectionCount(Btree*);•#elseæ# define sqlite3BtreeEnter(X) Ÿ # define sqlite3BtreeEnterAll(X)Ÿ"# define sqlite3BtreeSharable(X) 0Ÿ## define sqlite3BtreeEnterCursor(X)Ÿ)# define sqlite3BtreeConnectionCount(X) 1¶#endif†Ÿ;#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFEŸ0SQLITE_PRIVATE   void sqlite3BtreeLeave(Btree*);Ÿ9SQLITE_PRIVATE   void sqlite3BtreeLeaveCursor(BtCursor*);Ÿ5SQLITE_PRIVATE   void sqlite3BtreeLeaveAll(sqlite3*);Æ#ifndef NDEBUGŸ@  /* These routines are used inside assert() statements only. */Ÿ4SQLITE_PRIVATE   int sqlite3BtreeHoldsMutex(Btree*);Ÿ;SQLITE_PRIVATE   int sqlite3BtreeHoldsAllMutexes(sqlite3*);ŸBSQLITE_PRIVATE   int sqlite3SchemaMutexHeld(sqlite3*,int,Schema*);¶#endif•#else†Ω# define sqlite3BtreeLeave(X)Ÿ## define sqlite3BtreeLeaveCursor(X)Ÿ # define sqlite3BtreeLeaveAll(X)†Ÿ$# define sqlite3BtreeHoldsMutex(X) 1Ÿ)# define sqlite3BtreeHoldsAllMutexes(X) 1Ÿ(# define sqlite3SchemaMutexHeld(X,Y,Z) 1¶#endif††ª#endif /* SQLITE_BTREE_H */†ŸO/************** End of btree.h ***********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/ŸO/************** Include vdbe.h in the middle of sqliteInt.h ******************/ŸO/************** Begin file vdbe.h ********************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ5** Header file for the Virtual DataBase Engine (VDBE)¢**ŸC** This header defines the interface to the virtual database engineŸ@** or VDBE.  The VDBE implements an abstract machine that runs aŸ?** simple program to access and modify the underlying database.¢*/µ#ifndef SQLITE_VDBE_Hµ#define SQLITE_VDBE_H∏/* #include <stdio.h> */†¢/*ŸD** A single VDBE is an opaque structure named "Vdbe".  Only routinesŸA** in the source file sqliteVdbe.c are allowed to see the insidesµ** of this structure.¢*/πtypedef struct Vdbe Vdbe;†¢/*ŸF** The names of the following types declared in vdbeInt.h are requiredΩ** for the VdbeOp definition.¢*/Ÿ!typedef struct sqlite3_value Mem;Ÿ%typedef struct SubProgram SubProgram;†¢/*Ÿ<** A single instruction of the virtual machine has an opcodeŸ>** and as many as three operands.  The instruction is recordedŸ-** as an instance of the following structure:¢*/Østruct VdbeOp {Ÿ5  u8 opcode;          /* What operation to perform */Ÿ>  signed char p4type; /* One of the P4_xxx constants for p4 */ŸI  u16 p5;             /* Fifth parameter is an unsigned 16-bit integer */Ÿ)  int p1;             /* First operand */ŸI  int p2;             /* Second parameter (often the jump destination) */Ÿ/  int p3;             /* The third parameter */Ÿ,  union p4union {     /* fourth parameter */ŸB    int i;                 /* Integer value if p4type==P4_INT32 */Ÿ0    void *p;               /* Generic pointer */ŸN    char *z;               /* Pointer to data for string (char array) types */Ÿ=    i64 *pI64;             /* Used when p4type is P4_INT64 */Ÿ<    double *pReal;         /* Used when p4type is P4_REAL */Ÿ?    FuncDef *pFunc;        /* Used when p4type is P4_FUNCDEF */Ÿ?    sqlite3_context *pCtx; /* Used when p4type is P4_FUNCCTX */Ÿ?    CollSeq *pColl;        /* Used when p4type is P4_COLLSEQ */Ÿ;    Mem *pMem;             /* Used when p4type is P4_MEM */Ÿ<    VTable *pVtab;         /* Used when p4type is P4_VTAB */Ÿ?    KeyInfo *pKeyInfo;     /* Used when p4type is P4_KEYINFO */Ÿ@    int *ai;               /* Used when p4type is P4_INTARRAY */ŸB    SubProgram *pProgram;  /* Used when p4type is P4_SUBPROGRAM */Ÿ=    Table *pTab;           /* Used when p4type is P4_TABLE */Ÿ!#ifdef SQLITE_ENABLE_CURSOR_HINTSŸ<    Expr *pExpr;           /* Used when p4type is P4_EXPR */¶#endifŸ%    int (*xAdvance)(BtCursor *, int);ß  } p4;Ÿ%#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTSŸ?  char *zComment;          /* Comment to improve readability */¶#endif≥#ifdef VDBE_PROFILEŸN  u32 cnt;                 /* Number of times this instruction was executed */ŸL  u64 cycles;              /* Total time spent executing this instruction */¶#endifª#ifdef SQLITE_VDBE_COVERAGEŸL  int iSrcLine;            /* Source-code line that generated this opcode */¶#endif¢};Ωtypedef struct VdbeOp VdbeOp;††¢/*Ÿ5** A sub-routine used to implement a trigger program.¢*/≥struct SubProgram {ŸF  VdbeOp *aOp;                  /* Array of opcodes for sub-program */Ÿ7  int nOp;                      /* Elements in aOp[] */ŸE  int nMem;                     /* Number of memory cells required */Ÿ@  int nCsr;                     /* Number of cursors required */Ÿ<  u8 *aOnce;                    /* Array of OP_Once flags */ŸO  void *token;                  /* id that may be used to recursive triggers */ŸF  SubProgram *pNext;            /* Next sub-program already visited */¢};†¢/*ŸL** A smaller version of VdbeOp used for the VdbeAddOpList() function because∫** it takes up less space.¢*/≥struct VdbeOpList {Ÿ5  u8 opcode;          /* What operation to perform */Ÿ)  signed char p1;     /* First operand */ŸI  signed char p2;     /* Second parameter (often the jump destination) */Ÿ+  signed char p3;     /* Third parameter */¢};Ÿ%typedef struct VdbeOpList VdbeOpList;†¢/*Ÿ"** Allowed values of VdbeOp.p4type¢*/Ÿ>#define P4_NOTUSED      0   /* The P4 parameter is not used */ŸG#define P4_TRANSIENT    0   /* P4 is a pointer to a transient string */Ÿ<#define P4_STATIC     (-1)  /* Pointer to a static string */ŸH#define P4_COLLSEQ    (-2)  /* P4 is a pointer to a CollSeq structure */Ÿ?#define P4_INT32      (-3)  /* P4 is a 32-bit signed integer */ŸK#define P4_SUBPROGRAM (-4)  /* P4 is a pointer to a SubProgram structure */ŸO#define P4_ADVANCE    (-5)  /* P4 is a pointer to BtreeNext() or BtreePrev() */ŸF#define P4_TABLE      (-6)  /* P4 is a pointer to a Table structure */Ÿ</* Above do not own any resources.  Must free those below */∫#define P4_FREE_IF_LE (-7)ŸG#define P4_DYNAMIC    (-7)  /* Pointer to memory from sqliteMalloc() */ŸH#define P4_FUNCDEF    (-8)  /* P4 is a pointer to a FuncDef structure */ŸH#define P4_KEYINFO    (-9)  /* P4 is a pointer to a KeyInfo structure */ŸA#define P4_EXPR       (-10) /* P4 is a pointer to an Expr tree */ŸH#define P4_MEM        (-11) /* P4 is a pointer to a Mem*    structure */ŸN#define P4_VTAB       (-12) /* P4 is a pointer to an sqlite3_vtab structure */ŸE#define P4_REAL       (-13) /* P4 is a 64-bit floating point value */Ÿ?#define P4_INT64      (-14) /* P4 is a 64-bit signed integer */ŸC#define P4_INTARRAY   (-15) /* P4 is a vector of 32-bit integers */ŸN#define P4_FUNCCTX    (-16) /* P4 is a pointer to an sqlite3_context object */ŸG#define P4_DYNBLOB    (-17) /* Pointer to memory from sqliteMalloc() */†Ÿ%/* Error message codes for OP_Halt */æ#define P5_ConstraintNotNull 1æ#define P5_ConstraintUnique  2æ#define P5_ConstraintCheck   3æ#define P5_ConstraintFK      4†¢/*ŸF** The Vdbe.aColName array contains 5n Mem structures, where n is the Ÿ7** number of columns of data returned by the statement.¢*/∫#define COLNAME_NAME     0∫#define COLNAME_DECLTYPE 1∫#define COLNAME_DATABASE 2∫#define COLNAME_TABLE    3∫#define COLNAME_COLUMN   4Ÿ$#ifdef SQLITE_ENABLE_COLUMN_METADATAŸD# define COLNAME_N        5      /* Number of COLNAME_xxx symbols */•#elseº# ifdef SQLITE_OMIT_DECLTYPEŸ:#   define COLNAME_N      1      /* Store only the name */¶# elseŸB#   define COLNAME_N      2      /* Store the name and decltype */ß# endif¶#endif†¢/*ŸB** The following macro converts a relative address in the p2 fieldŸ8** of a VdbeOp structure into a negative number so that ŸF** sqlite3VdbeAddOpList() knows that the address is relative.  CallingŸ(** the macro again restores the address.¢*/π#define ADDR(X)  (-1-(X))†¢/*ŸH** The makefile scans the vdbe.c source file and creates the "opcodes.h"ŸF** header file that defines a number for each opcode used by the VDBE.¢*/ŸO/************** Include opcodes.h in the middle of vdbe.h ********************/ŸO/************** Begin file opcodes.h *****************************************/Ÿ+/* Automatically generated.  Do not edit */Ÿ3/* See the tool/mkopcodeh.tcl script for details */º#define OP_Savepoint       0º#define OP_AutoCommit      1º#define OP_Transaction     2ŸM#define OP_SorterNext      3 /* jump                                       */ŸM#define OP_PrevIfOpen      4 /* jump                                       */ŸM#define OP_NextIfOpen      5 /* jump                                       */ŸM#define OP_Prev            6 /* jump                                       */ŸM#define OP_Next            7 /* jump                                       */º#define OP_Checkpoint      8º#define OP_JournalMode     9º#define OP_Vacuum         10ŸM#define OP_VFilter        11 /* jump, synopsis: iplan=r[P3] zplan='P4'     */ŸM#define OP_VUpdate        12 /* synopsis: data=r[P3@P2]                    */ŸM#define OP_Goto           13 /* jump                                       */ŸM#define OP_Gosub          14 /* jump                                       */ŸM#define OP_InitCoroutine  15 /* jump                                       */ŸM#define OP_Yield          16 /* jump                                       */ŸM#define OP_MustBeInt      17 /* jump                                       */ŸM#define OP_Jump           18 /* jump                                       */ŸM#define OP_Not            19 /* same as TK_NOT, synopsis: r[P2]= !r[P1]    */ŸM#define OP_Once           20 /* jump                                       */ŸM#define OP_If             21 /* jump                                       */ŸM#define OP_IfNot          22 /* jump                                       */ŸY#define OP_IfNullRow      23 /* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 */ŸM#define OP_SeekLT         24 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_SeekLE         25 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_SeekGE         26 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_SeekGT         27 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_NoConflict     28 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_NotFound       29 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_Found          30 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_SeekRowid      31 /* jump, synopsis: intkey=r[P3]               */ŸM#define OP_NotExists      32 /* jump, synopsis: intkey=r[P3]               */ŸM#define OP_Last           33 /* jump                                       */ŸM#define OP_IfSmaller      34 /* jump                                       */ŸM#define OP_SorterSort     35 /* jump                                       */ŸM#define OP_Sort           36 /* jump                                       */ŸM#define OP_Rewind         37 /* jump                                       */ŸM#define OP_IdxLE          38 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_IdxGT          39 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_IdxLT          40 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_IdxGE          41 /* jump, synopsis: key=r[P3@P4]               */ŸM#define OP_RowSetRead     42 /* jump, synopsis: r[P3]=rowset(P1)           */ŸR#define OP_Or             43 /* same as TK_OR, synopsis: r[P3]=(r[P1] || r[P2]) */ŸS#define OP_And            44 /* same as TK_AND, synopsis: r[P3]=(r[P1] && r[P2]) */ŸQ#define OP_RowSetTest     45 /* jump, synopsis: if r[P3] in rowset(P1) goto P2 */ŸM#define OP_Program        46 /* jump                                       */ŸM#define OP_FkIfZero       47 /* jump, synopsis: if fkctr[P1]==0 goto P2    */ŸU#define OP_IfPos          48 /* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 */ŸT#define OP_IfNotZero      49 /* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 */Ÿ\#define OP_IsNull         50 /* jump, same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 */Ÿ]#define OP_NotNull        51 /* jump, same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 */ŸQ#define OP_Ne             52 /* jump, same as TK_NE, synopsis: IF r[P3]!=r[P1] */ŸQ#define OP_Eq             53 /* jump, same as TK_EQ, synopsis: IF r[P3]==r[P1] */ŸP#define OP_Gt             54 /* jump, same as TK_GT, synopsis: IF r[P3]>r[P1] */ŸQ#define OP_Le             55 /* jump, same as TK_LE, synopsis: IF r[P3]<=r[P1] */ŸP#define OP_Lt             56 /* jump, same as TK_LT, synopsis: IF r[P3]<r[P1] */ŸQ#define OP_Ge             57 /* jump, same as TK_GE, synopsis: IF r[P3]>=r[P1] */ŸM#define OP_ElseNotEq      58 /* jump, same as TK_ESCAPE                    */ŸM#define OP_DecrJumpZero   59 /* jump, synopsis: if (--r[P1])==0 goto P2    */ŸM#define OP_IncrVacuum     60 /* jump                                       */ŸM#define OP_VNext          61 /* jump                                       */ŸM#define OP_Init           62 /* jump, synopsis: Start at P2                */º#define OP_Return         63º#define OP_EndCoroutine   64ŸM#define OP_HaltIfNull     65 /* synopsis: if r[P3]=null halt               */º#define OP_Halt           66ŸM#define OP_Integer        67 /* synopsis: r[P2]=P1                         */ŸM#define OP_Int64          68 /* synopsis: r[P2]=P4                         */ŸM#define OP_String         69 /* synopsis: r[P2]='P4' (len=P1)              */ŸM#define OP_Null           70 /* synopsis: r[P2..P3]=NULL                   */ŸM#define OP_SoftNull       71 /* synopsis: r[P1]=NULL                       */ŸM#define OP_Blob           72 /* synopsis: r[P2]=P4 (len=P1)                */ŸM#define OP_Variable       73 /* synopsis: r[P2]=parameter(P1,P4)           */ŸM#define OP_Move           74 /* synopsis: r[P2@P3]=r[P1@P3]                */ŸM#define OP_Copy           75 /* synopsis: r[P2@P3+1]=r[P1@P3+1]            */ŸM#define OP_SCopy          76 /* synopsis: r[P2]=r[P1]                      */ŸM#define OP_IntCopy        77 /* synopsis: r[P2]=r[P1]                      */ŸM#define OP_ResultRow      78 /* synopsis: output=r[P1@P2]                  */º#define OP_CollSeq        79ŸM#define OP_AddImm         80 /* synopsis: r[P1]=r[P1]+P2                   */º#define OP_RealAffinity   81ŸM#define OP_Cast           82 /* synopsis: affinity(r[P1])                  */º#define OP_Permutation    83ŸQ#define OP_BitAnd         84 /* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] */ŸP#define OP_BitOr          85 /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */ŸR#define OP_ShiftLeft      86 /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] */ŸR#define OP_ShiftRight     87 /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] */ŸO#define OP_Add            88 /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */ŸP#define OP_Subtract       89 /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */ŸO#define OP_Multiply       90 /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */ŸP#define OP_Divide         91 /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */ŸN#define OP_Remainder      92 /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */ŸQ#define OP_Concat         93 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */ŸM#define OP_Compare        94 /* synopsis: r[P1@P3] <-> r[P2@P3]            */ŸM#define OP_BitNot         95 /* same as TK_BITNOT, synopsis: r[P1]= ~r[P1] */ŸR#define OP_IsTrue         96 /* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 */ŸM#define OP_String8        97 /* same as TK_STRING, synopsis: r[P2]='P4'    */ŸM#define OP_Offset         98 /* synopsis: r[P3] = sqlite_offset(P1)        */ŸM#define OP_Column         99 /* synopsis: r[P3]=PX                         */ŸM#define OP_Affinity      100 /* synopsis: affinity(r[P1@P2])               */ŸM#define OP_MakeRecord    101 /* synopsis: r[P3]=mkrec(r[P1@P2])            */ŸM#define OP_Count         102 /* synopsis: r[P2]=count()                    */º#define OP_ReadCookie    103º#define OP_SetCookie     104ŸM#define OP_ReopenIdx     105 /* synopsis: root=P2 iDb=P3                   */ŸM#define OP_OpenRead      106 /* synopsis: root=P2 iDb=P3                   */ŸM#define OP_OpenWrite     107 /* synopsis: root=P2 iDb=P3                   */º#define OP_OpenDup       108ŸM#define OP_OpenAutoindex 109 /* synopsis: nColumn=P2                       */ŸM#define OP_OpenEphemeral 110 /* synopsis: nColumn=P2                       */º#define OP_SorterOpen    111ŸM#define OP_SequenceTest  112 /* synopsis: if( cursor[P1].ctr++ ) pc = P2   */ŸM#define OP_OpenPseudo    113 /* synopsis: P3 columns in r[P2]              */º#define OP_Close         114º#define OP_ColumnsUsed   115ŸM#define OP_Sequence      116 /* synopsis: r[P2]=cursor[P1].ctr++           */ŸM#define OP_NewRowid      117 /* synopsis: r[P2]=rowid                      */ŸM#define OP_Insert        118 /* synopsis: intkey=r[P3] data=r[P2]          */ŸM#define OP_InsertInt     119 /* synopsis: intkey=P3 data=r[P2]             */º#define OP_Delete        120º#define OP_ResetCount    121ŸO#define OP_SorterCompare 122 /* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 */ŸM#define OP_SorterData    123 /* synopsis: r[P2]=data                       */ŸM#define OP_RowData       124 /* synopsis: r[P2]=data                       */ŸM#define OP_Rowid         125 /* synopsis: r[P2]=rowid                      */º#define OP_NullRow       126º#define OP_SeekEnd       127ŸM#define OP_SorterInsert  128 /* synopsis: key=r[P2]                        */ŸM#define OP_IdxInsert     129 /* synopsis: key=r[P2]                        */ŸM#define OP_IdxDelete     130 /* synopsis: key=r[P2@P3]                     */ŸM#define OP_DeferredSeek  131 /* synopsis: Move P3 to P1.rowid if needed    */ŸM#define OP_Real          132 /* same as TK_FLOAT, synopsis: r[P2]=P4       */ŸM#define OP_IdxRowid      133 /* synopsis: r[P2]=rowid                      */º#define OP_Destroy       134º#define OP_Clear         135º#define OP_ResetSorter   136ŸM#define OP_CreateBtree   137 /* synopsis: r[P2]=root iDb=P1 flags=P3       */º#define OP_SqlExec       138º#define OP_ParseSchema   139º#define OP_LoadAnalysis  140º#define OP_DropTable     141º#define OP_DropIndex     142º#define OP_DropTrigger   143º#define OP_IntegrityCk   144ŸM#define OP_RowSetAdd     145 /* synopsis: rowset(P1)=r[P2]                 */º#define OP_Param         146ŸM#define OP_FkCounter     147 /* synopsis: fkctr[P1]+=P2                    */ŸM#define OP_MemMax        148 /* synopsis: r[P1]=max(r[P1],r[P2])           */Ÿe#define OP_OffsetLimit   149 /* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */ŸM#define OP_AggStep0      150 /* synopsis: accum=r[P3] step(r[P2@P5])       */ŸM#define OP_AggStep       151 /* synopsis: accum=r[P3] step(r[P2@P5])       */ŸM#define OP_AggFinal      152 /* synopsis: accum=r[P1] N=P2                 */º#define OP_Expire        153ŸM#define OP_TableLock     154 /* synopsis: iDb=P1 root=P2 write=P3          */º#define OP_VBegin        155º#define OP_VCreate       156º#define OP_VDestroy      157º#define OP_VOpen         158ŸM#define OP_VColumn       159 /* synopsis: r[P3]=vcolumn(P2)                */º#define OP_VRename       160º#define OP_Pagecount     161º#define OP_MaxPgcnt      162º#define OP_PureFunc0     163ŸM#define OP_Function0     164 /* synopsis: r[P3]=func(r[P2@P5])             */º#define OP_PureFunc      165ŸM#define OP_Function      166 /* synopsis: r[P3]=func(r[P2@P5])             */º#define OP_Trace         167º#define OP_CursorHint    168º#define OP_Noop          169º#define OP_Explain       170†Ÿ</* Properties such as "out2" or "jump" that are specified inŸ>** comments following the "case" for each opcode in the vdbe.cŸ*** are encoded into bitvectors as follows:¢*/Ÿ@#define OPFLG_JUMP        0x01  /* jump:  P2 holds jmp target */Ÿ;#define OPFLG_IN1         0x02  /* in1:   P1 is an input */Ÿ;#define OPFLG_IN2         0x04  /* in2:   P2 is an input */Ÿ;#define OPFLG_IN3         0x08  /* in3:   P3 is an input */Ÿ<#define OPFLG_OUT2        0x10  /* out2:  P2 is an output */Ÿ<#define OPFLG_OUT3        0x20  /* out3:  P3 is an output */º#define OPFLG_INITIALIZER {\Ÿ:/*   0 */ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,\Ÿ:/*   8 */ 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01,\Ÿ:/*  16 */ 0x03, 0x03, 0x01, 0x12, 0x01, 0x03, 0x03, 0x01,\Ÿ:/*  24 */ 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,\Ÿ:/*  32 */ 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\Ÿ:/*  40 */ 0x01, 0x01, 0x23, 0x26, 0x26, 0x0b, 0x01, 0x01,\Ÿ:/*  48 */ 0x03, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\Ÿ:/*  56 */ 0x0b, 0x0b, 0x01, 0x03, 0x01, 0x01, 0x01, 0x02,\Ÿ:/*  64 */ 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00,\Ÿ:/*  72 */ 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\Ÿ:/*  80 */ 0x02, 0x02, 0x02, 0x00, 0x26, 0x26, 0x26, 0x26,\Ÿ:/*  88 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12,\Ÿ:/*  96 */ 0x12, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10, 0x10,\Ÿ:/* 104 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\Ÿ:/* 112 */ 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\Ÿ:/* 120 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,\Ÿ:/* 128 */ 0x04, 0x04, 0x00, 0x00, 0x10, 0x10, 0x10, 0x00,\Ÿ:/* 136 */ 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\Ÿ:/* 144 */ 0x00, 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00,\Ÿ:/* 152 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\Ÿ:/* 160 */ 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,\º/* 168 */ 0x00, 0x00, 0x00,}†ŸB/* The sqlite3P2Values() routine is able to run faster if it knowsŸA** the value of the largest JUMP opcode.  The smaller the maximumŸ;** JUMP opcode the better, so the mkopcodeh.tcl script thatŸ@** generated this include file strives to group all JUMP opcodesŸ+** together near the beginning of the list.¢*/Ÿ<#define SQLITE_MX_JUMP_OPCODE  62  /* Maximum JUMP opcode */†ŸO/************** End of opcodes.h *********************************************/ŸO/************** Continuing where we left off in vdbe.h ***********************/†¢/*Ÿ/** Additional non-public SQLITE_PREPARE_* flags¢*/Ÿ=#define SQLITE_PREPARE_SAVESQL  0x80  /* Preserve SQL text */Ÿ@#define SQLITE_PREPARE_MASK     0x0f  /* Mask of public flags */†¢/*ŸI** Prototypes for the VDBE interface.  See comments on the implementationŸ9** for a description of what each of these routines does.¢*/Ÿ/SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse*);Ÿ0SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*,int);Ÿ4SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*,int,int);Ÿ8SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*,int,int,int);Ÿ.SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe*,int);Ÿ@SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe*,int,const char*);ŸDSQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);Ÿ<SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);ŸPSQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);ŸNSQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);ŸCSQLITE_PRIVATE int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);Ÿ7SQLITE_PRIVATE void sqlite3VdbeEndCoroutine(Vdbe*,int);ŸA#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)ŸHSQLITE_PRIVATE   void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);Ÿ<SQLITE_PRIVATE   void sqlite3VdbeVerifyNoResultRow(Vdbe *p);•#elseŸ/# define sqlite3VdbeVerifyNoMallocRequired(A,B)Ÿ(# define sqlite3VdbeVerifyNoResultRow(A)¶#endifŸ`SQLITE_PRIVATE VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp, int iLineno);ŸASQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*,int,char*);ŸASQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, u32 addr, u8);ŸASQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, u32 addr, int P1);ŸASQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, u32 addr, int P2);ŸASQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, u32 addr, int P3);Ÿ7SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u16 P5);Ÿ9SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr);Ÿ<SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe*, int addr);Ÿ>SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);ŸQSQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);ŸFSQLITE_PRIVATE void sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type);Ÿ<SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse*, Index*);Ÿ5SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe*, int);Ÿ4SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);Ÿ/SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe*);Ÿ2SQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe*);Ÿ/SQLITE_PRIVATE void sqlite3VdbeReusable(Vdbe*);Ÿ-SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe*);Ÿ;SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3*,Vdbe*);Ÿ7SQLITE_PRIVATE void sqlite3VdbeMakeReady(Vdbe*,Parse*);Ÿ.SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe*);Ÿ8SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe*, int);Ÿ1SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe*);≥#ifdef SQLITE_DEBUGŸ<SQLITE_PRIVATE   int sqlite3VdbeAssertMayAbort(Vdbe *, int);¶#endifŸ6SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe*);Ÿ-SQLITE_PRIVATE void sqlite3VdbeRewind(Vdbe*);Ÿ+SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe*);Ÿ5SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*,int);ŸXSQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));Ÿ3SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*);Ÿ-SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*);Ÿ1SQLITE_PRIVATE u8 sqlite3VdbePrepareFlags(Vdbe*);ŸGSQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);Ÿ1SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*,Vdbe*);ŸASQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);ŸGSQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);Ÿ6SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe*, int);π#ifndef SQLITE_OMIT_TRACEŸ@SQLITE_PRIVATE   char *sqlite3VdbeExpandSql(Vdbe*, const char*);¶#endifŸMSQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);†ŸVSQLITE_PRIVATE void sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,UnpackedRecord*);ŸMSQLITE_PRIVATE int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);Ÿ^SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);ŸHSQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*);†Ÿ>typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);ŸESQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);†ª#ifndef SQLITE_OMIT_TRIGGERŸDSQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);¶#endif†Ÿ8SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context*);†ŸG/* Use SQLITE_ENABLE_COMMENTS to enable generation of extra comments on¥** each VDBE opcode.¢**ŸF** Use the SQLITE_ENABLE_MODULE_COMMENTS macro to see some extra no-opŸF** comments in VDBE programs that show key decision points in the code≠** generator.¢*/Ÿ%#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTSŸBSQLITE_PRIVATE   void sqlite3VdbeComment(Vdbe*, const char*, ...);Ÿ-# define VdbeComment(X)  sqlite3VdbeComment XŸFSQLITE_PRIVATE   void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);Ÿ5# define VdbeNoopComment(X)  sqlite3VdbeNoopComment XŸ%# ifdef SQLITE_ENABLE_MODULE_COMMENTSŸ9#   define VdbeModuleComment(X)  sqlite3VdbeNoopComment X¶# elseø#   define VdbeModuleComment(X)ß# endif•#else∑# define VdbeComment(X)ª# define VdbeNoopComment(X)Ω# define VdbeModuleComment(X)¶#endif†¢/*ŸC** The VdbeCoverage macros are used to set a coverage testing pointŸF** for VDBE branch instructions.  The coverage testing points are lineŸF** numbers in the sqlite3.c source file.  VDBE branch coverage testingŸH** only works with an amalagmation build.  That's ok since a VDBE branchŸK** coverage build designed for testing the test suite only.  No applicationŸB** should ever ship with VDBE branch coverage measuring turned on.¢**ŸO**    VdbeCoverage(v)                  // Mark the previously coded instructionŸ5**                                     // as a branch¢**ŸK**    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true¢**ŸI**    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken¢**ŸH**    VdbeCoverageNeverTaken(v)        // Previous branch is never taken¢**ŸK** Every VDBE branch operation must be tagged with one of the macros above.ŸG** If not, then when "make test" is run with -DSQLITE_VDBE_COVERAGE andŸD** -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()Ÿ?** routine in vdbe.c, alerting the developer to the missed tag.¢*/ª#ifdef SQLITE_VDBE_COVERAGEŸ:SQLITE_PRIVATE   void sqlite3VdbeSetLineNumber(Vdbe*,int);Ÿ=# define VdbeCoverage(v) sqlite3VdbeSetLineNumber(v,__LINE__)ŸF# define VdbeCoverageIf(v,x) if(x)sqlite3VdbeSetLineNumber(v,__LINE__)ŸB# define VdbeCoverageAlwaysTaken(v) sqlite3VdbeSetLineNumber(v,2);ŸA# define VdbeCoverageNeverTaken(v) sqlite3VdbeSetLineNumber(v,1);Ÿ+# define VDBE_OFFSET_LINENO(x) (__LINE__+x)•#else∏# define VdbeCoverage(v)º# define VdbeCoverageIf(v,x)Ÿ## define VdbeCoverageAlwaysTaken(v)Ÿ"# define VdbeCoverageNeverTaken(v)Ÿ # define VDBE_OFFSET_LINENO(x) 0¶#endif†Ÿ$#ifdef SQLITE_ENABLE_STMT_SCANSTATUSŸUSQLITE_PRIVATE void sqlite3VdbeScanStatus(Vdbe*, int, int, int, LogEst, const char*);•#elseŸ)# define sqlite3VdbeScanStatus(a,b,c,d,e)¶#endif†∫#endif /* SQLITE_VDBE_H */†ŸO/************** End of vdbe.h ************************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/ŸO/************** Include pager.h in the middle of sqliteInt.h *****************/ŸO/************** Begin file pager.h *******************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸD** This header file defines the interface that the sqlite page cacheŸF** subsystem.  The page cache subsystem reads and writes a file a pageŸ1** at a time and provides a journal for rollback.¢*/†∂#ifndef SQLITE_PAGER_H∂#define SQLITE_PAGER_H†¢/*ŸA** Default maximum size for persistent journal files. A negative Ÿ@** value means no limit. This value may be overridden using the ŸL** sqlite3PagerJournalSizeLimit() API. See also "PRAGMA journal_size_limit".¢*/Ÿ)#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMITŸ.  #define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1¶#endif†¢/*ŸF** The type used to represent a page number.  The first page in a fileŸ:** is called page 1.  0 is used to represent "not a page".¢*/±typedef u32 Pgno;†¢/*ŸM** Each open file is managed by a separate instance of the "Pager" structure.¢*/ªtypedef struct Pager Pager;†¢/*π** Handle type for pages.¢*/ºtypedef struct PgHdr DbPage;†¢/*ŸG** Page number PAGER_MJ_PGNO is never used in an SQLite database (it isŸF** reserved for working around a windows/posix incompatibility). It isŸI** used in the journal to signify that the remainder of the journal file ŸK** is devoted to storing a master journal name - there are no more pages toŸH** roll back. See comments for function writeMasterJournal() in pager.c Ø** for details.¢*/ŸC#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1))†¢/*Ÿ@** Allowed values for the flags parameter to sqlite3PagerOpen().¢**ŸL** NOTE: These values must match the corresponding BTREE_ values in btree.h.¢*/ŸI#define PAGER_OMIT_JOURNAL  0x0001    /* Do not use a rollback journal */Ÿ>#define PAGER_MEMORY        0x0002    /* In-memory database */†¢/*ŸE** Valid values for the second argument to sqlite3PagerLockingMode().¢*/Ÿ'#define PAGER_LOCKINGMODE_QUERY      -1Ÿ'#define PAGER_LOCKINGMODE_NORMAL      0Ÿ'#define PAGER_LOCKINGMODE_EXCLUSIVE   1†¢/*Ÿ1** Numeric constants that encode the journalmode.¢**ŸG** The numeric values encoded here (other than PAGER_JOURNALMODE_QUERY)ŸC** are exposed in the API via the "PRAGMA journal_mode" command andŸ=** therefore cannot be changed without a compatibility break.¢*/ŸN#define PAGER_JOURNALMODE_QUERY     (-1)  /* Query the value of journalmode */ŸO#define PAGER_JOURNALMODE_DELETE      0   /* Commit by deleting journal file */ŸP#define PAGER_JOURNALMODE_PERSIST     1   /* Commit by zeroing journal header */ŸA#define PAGER_JOURNALMODE_OFF         2   /* Journal omitted.  */ŸL#define PAGER_JOURNALMODE_TRUNCATE    3   /* Commit by truncating journal */ŸF#define PAGER_JOURNALMODE_MEMORY      4   /* In-memory journal file */ŸG#define PAGER_JOURNALMODE_WAL         5   /* Use write-ahead logging */†¢/*Ÿ;** Flags that make up the mask passed to sqlite3PagerGet().¢*/ŸF#define PAGER_GET_NOCONTENT     0x01  /* Do not load data from disk */ŸH#define PAGER_GET_READONLY      0x02  /* Read-only page is acceptable */†¢/*Ÿ#** Flags for sqlite3PagerSetFlags()¢**Ÿ-** Value constraints (enforced via assert()):Ÿ.**    PAGER_FULLFSYNC      == SQLITE_FullFSyncŸ2**    PAGER_CKPT_FULLFSYNC == SQLITE_CkptFullFSyncŸ/**    PAGER_CACHE_SPILL    == SQLITE_CacheSpill¢*/ŸF#define PAGER_SYNCHRONOUS_OFF       0x01  /* PRAGMA synchronous=OFF */ŸI#define PAGER_SYNCHRONOUS_NORMAL    0x02  /* PRAGMA synchronous=NORMAL */ŸG#define PAGER_SYNCHRONOUS_FULL      0x03  /* PRAGMA synchronous=FULL */ŸH#define PAGER_SYNCHRONOUS_EXTRA     0x04  /* PRAGMA synchronous=EXTRA */ŸJ#define PAGER_SYNCHRONOUS_MASK      0x07  /* Mask for four values above */ŸC#define PAGER_FULLFSYNC             0x08  /* PRAGMA fullfsync=ON */ŸN#define PAGER_CKPT_FULLFSYNC        0x10  /* PRAGMA checkpoint_fullfsync=ON */ŸE#define PAGER_CACHESPILL            0x20  /* PRAGMA cache_spill=ON */ŸL#define PAGER_FLAGS_MASK            0x38  /* All above except SYNCHRONOUS */†¢/*ŸH** The remainder of this file contains the declarations of the functionsŸG** that make up the Pager sub-system API. See source code comments for Ÿ*** a detailed description of each routine.¢*/†Ÿ)/* Open and close a Pager connection. */ Ÿ$SQLITE_PRIVATE int sqlite3PagerOpen(Ø  sqlite3_vfs*,≤  Pager **ppPager,Æ  const char*,¶  int,¶  int,¶  int,≤  void(*)(DbPage*)¢);Ÿ>SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3*);ŸKSQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);†Ÿ1/* Functions used to configure a Pager object. */ŸOSQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);Ÿ>SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);∑#ifdef SQLITE_HAS_CODECŸ<SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager*,Pager*);¶#endifŸ9SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);Ÿ:SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);Ÿ9SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int);ŸESQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);Ÿ/SQLITE_PRIVATE void sqlite3PagerShrink(Pager*);Ÿ:SQLITE_PRIVATE void sqlite3PagerSetFlags(Pager*,unsigned);Ÿ9SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int);Ÿ<SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int);Ÿ6SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*);Ÿ=SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*);Ÿ>SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64);Ÿ>SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*);Ÿ-SQLITE_PRIVATE int sqlite3PagerFlush(Pager*);†Ÿ</* Functions used to obtain and release page references. */ Ÿ[SQLITE_PRIVATE int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);ŸDSQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);Ÿ-SQLITE_PRIVATE void sqlite3PagerRef(DbPage*);Ÿ/SQLITE_PRIVATE void sqlite3PagerUnref(DbPage*);Ÿ6SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage*);Ÿ6SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage*);†Ÿ$/* Operations on page references. */Ÿ.SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*);Ÿ3SQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*);ŸASQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);Ÿ5SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*);Ÿ4SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *); Ÿ5SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *); †ŸA/* Functions used to manage pager transactions and savepoints. */Ÿ8SQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*);Ÿ>SQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int);ŸOSQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, int);Ÿ5SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*);ŸHSQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster);Ÿ6SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*);Ÿ0SQLITE_PRIVATE int sqlite3PagerRollback(Pager*);ŸCSQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n);ŸPSQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);Ÿ9SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager);†∑#ifndef SQLITE_OMIT_WALŸVSQLITE_PRIVATE   int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*);Ÿ=SQLITE_PRIVATE   int sqlite3PagerWalSupported(Pager *pPager);Ÿ<SQLITE_PRIVATE   int sqlite3PagerWalCallback(Pager *pPager);ŸFSQLITE_PRIVATE   int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);ŸCSQLITE_PRIVATE   int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);Ÿ## ifdef SQLITE_DIRECT_OVERFLOW_READŸ=SQLITE_PRIVATE   int sqlite3PagerUseWal(Pager *pPager, Pgno);ß# endifæ# ifdef SQLITE_ENABLE_SNAPSHOTŸ[SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot);ŸZSQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot);Ÿ@SQLITE_PRIVATE   int sqlite3PagerSnapshotRecover(Pager *pPager);ß# endif•#elseŸ"# define sqlite3PagerUseWal(x,y) 0¶#endif†ª#ifdef SQLITE_ENABLE_ZIPVFSŸ=SQLITE_PRIVATE   int sqlite3PagerWalFramesize(Pager *pPager);¶#endif†Ÿ</* Functions used to query pager state and configuration. */Ÿ1SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*);Ÿ3SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager*);≥#ifdef SQLITE_DEBUGŸ2SQLITE_PRIVATE   int sqlite3PagerRefcount(Pager*);¶#endifŸ/SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*);Ÿ=SQLITE_PRIVATE const char *sqlite3PagerFilename(Pager*, int);Ÿ4SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager*);Ÿ6SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*);Ÿ:SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager*);Ÿ;SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*);Ÿ3SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);Ÿ/SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);ŸDSQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);Ÿ3SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);Ÿ5SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);Ÿ"#ifdef SQLITE_ENABLE_SETLK_TIMEOUTŸ@SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager);•#elseŸ(# define sqlite3PagerResetLockTimeout(X)¶#endif†Ÿ3/* Functions used to truncate the database file. */Ÿ;SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno);†Ÿ:SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16);†Ÿ:#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_OMIT_WAL)Ÿ1SQLITE_PRIVATE void *sqlite3PagerCodec(DbPage *);¶#endif†Ÿ1/* Functions to support testing and debugging. */Ÿ,#if !defined(NDEBUG) || defined(SQLITE_TEST)Ÿ6SQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);Ÿ6SQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);¶#endif≤#ifdef SQLITE_TESTŸ0SQLITE_PRIVATE   int *sqlite3PagerStats(Pager*);Ÿ2SQLITE_PRIVATE   void sqlite3PagerRefdump(Pager*);Ÿ)  void disable_simulated_io_errors(void);Ÿ(  void enable_simulated_io_errors(void);•#elseŸ&# define disable_simulated_io_errors()Ÿ%# define enable_simulated_io_errors()¶#endif†ª#endif /* SQLITE_PAGER_H */†ŸO/************** End of pager.h ***********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/ŸO/************** Include pcache.h in the middle of sqliteInt.h ****************/ŸO/************** Begin file pcache.h ******************************************/¢/*±** 2008 August 05¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸD** This header file defines the interface that the sqlite page cacheÆ** subsystem. ¢*/†≤#ifndef _PCACHE_H_†ªtypedef struct PgHdr PgHdr;Ωtypedef struct PCache PCache;†¢/*ŸH** Every page in the cache is controlled by an instance of the following≠** structure.¢*/Æstruct PgHdr {Ÿ@  sqlite3_pcache_page *pPage;    /* Pcache object page handle */Ÿ0  void *pData;                   /* Page data */Ÿ4  void *pExtra;                  /* Extra content */ŸI  PCache *pCache;                /* PRIVATE: Cache that owns this page */ŸM  PgHdr *pDirty;                 /* Transient list of dirty sorted by pgno */ŸE  Pager *pPager;                 /* The pager this page is part of */Ÿ@  Pgno pgno;                     /* Page number for this page */π#ifdef SQLITE_CHECK_PAGESŸ;  u32 pageHash;                  /* Hash of page content */¶#endifŸ@  u16 flags;                     /* PGHDR flags defined below */†ŸI  /**********************************************************************ŸE  ** Elements above, except pCache, are public.  All that follow are ŸE  ** private to pcache.c and should not be accessed by other modules.Ÿ?  ** pCache is grouped with the public elements for efficiency.§  */ŸC  i16 nRef;                      /* Number of users of this page */ŸJ  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */ŸN  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */ŸO                          /* NB: pDirtyNext and pDirtyPrev are undefined if theŸ9                          ** PgHdr object is not dirty */¢};†Ÿ /* Bit values for PgHdr.flags */ŸM#define PGHDR_CLEAN           0x001  /* Page not on the PCache.pDirty list */ŸL#define PGHDR_DIRTY           0x002  /* Page is on the PCache.pDirty list */ŸH#define PGHDR_WRITEABLE       0x004  /* Journaled and ready to modify */ŸI#define PGHDR_NEED_SYNC       0x008  /* Fsync the rollback journal beforeŸL                                     ** writing this page to the database */ŸG#define PGHDR_DONT_WRITE      0x010  /* Do not write content to disk */ŸF#define PGHDR_MMAP            0x020  /* This is an mmap page object */†Ÿ?#define PGHDR_WAL_APPEND      0x040  /* Appended to wal file */†Ÿ6/* Initialize and shutdown the page cache subsystem */Ÿ1SQLITE_PRIVATE int sqlite3PcacheInitialize(void);Ÿ0SQLITE_PRIVATE void sqlite3PcacheShutdown(void);†Ÿ /* Page cache buffer management:Ÿ4** These routines implement SQLITE_CONFIG_PAGECACHE.¢*/ŸDSQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *, int sz, int n);†º/* Create a new pager cache.ŸB** Under memory stress, invoke xStress to try to make pages clean.Ÿ2** Only clean and unpinned pages can be reclaimed.¢*/Ÿ%SQLITE_PRIVATE int sqlite3PcacheOpen(Ÿ9  int szPage,                    /* Size of every page */ŸL  int szExtra,                   /* Extra space associated with each page */ŸI  int bPurgeable,                /* True if pages are on backing store */ŸF  int (*xStress)(void*, PgHdr*), /* Call to try to make pages clean */Ÿ:  void *pStress,                 /* Argument to xStress */ŸH  PCache *pToInit                /* Preallocated space for the PCache */¢);†Ÿ</* Modify the page-size after the cache has been created. */Ÿ;SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *, int);†ŸD/* Return the size in bytes of a PCache object.  Used to preallocate±** storage space.¢*/Ÿ+SQLITE_PRIVATE int sqlite3PcacheSize(void);†ŸD/* One release per successful fetch.  Page is pinned until released.∂** Reference counted. ¢*/ŸVSQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(PCache*, Pgno, int createFlag);ŸRSQLITE_PRIVATE int sqlite3PcacheFetchStress(PCache*, Pgno, sqlite3_pcache_page**);ŸZSQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(PCache*, Pgno, sqlite3_pcache_page *pPage);Ÿ1SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr*);†ŸSSQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr*);         /* Remove page from cache */Ÿ[SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr*);    /* Make sure page is marked dirty */ŸXSQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr*);    /* Mark a single page as clean */Ÿ_SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache*);    /* Mark all dirty list pages as clean */Ÿ8SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache*);†Ÿ1/* Change a page number.  Used by incr-vacuum. */Ÿ4SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr*, Pgno);†Ÿ</* Remove all pages with pgno>x.  Reset the cache if x==0 */Ÿ;SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache*, Pgno x);†ŸG/* Get a list of all dirty pages in the cache, sorted by page number */Ÿ6SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache*);†Ÿ&/* Reset and close the cache object */Ÿ0SQLITE_PRIVATE void sqlite3PcacheClose(PCache*);†Ÿ./* Clear flags from pages of the page cache */Ÿ:SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *);†Ÿ'/* Discard the contents of the cache */Ÿ0SQLITE_PRIVATE void sqlite3PcacheClear(PCache*);†Ÿ</* Return the total number of outstanding page references */Ÿ2SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*);†Ÿ7/* Increment the reference count of an existing page */Ÿ-SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr*);†Ÿ5SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*);†Ÿ:/* Return the total number of pages stored in the cache */Ÿ3SQLITE_PRIVATE int sqlite3PcachePagecount(PCache*);†Ÿ8#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)ŸF/* Iterate through all dirty pages currently stored in the cache. ThisŸI** interface is only available if SQLITE_CHECK_PAGES is defined when the ¥** library is built.¢*/ŸVSQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *));¶#endif†π#if defined(SQLITE_DEBUG)Ÿ(/* Check invariants on a PgHdr object */Ÿ3SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr*);¶#endif†ŸF/* Set and get the suggested cache-size for the specified pager-cache.¢**ŸH** If no global maximum is configured, then the system attempts to limitŸH** the total number of pages cached by purgeable pager-caches to the sumŸ ** of the suggested cache-sizes.¢*/Ÿ=SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *, int);≤#ifdef SQLITE_TESTŸ7SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *);¶#endif†ŸE/* Set or get the suggested spill-size for the specified pager-cache.¢**ŸJ** The spill-size is the minimum number of pages in cache before the cacheŸ8** will attempt to spill dirty pages by calling xStress.¢*/Ÿ<SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *, int);†Ÿ</* Free up as much memory as possible from the page cache */Ÿ1SQLITE_PRIVATE void sqlite3PcacheShrink(PCache*);†Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTŸL/* Try to return memory used by the pcache module to the main memory heap */Ÿ3SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int);¶#endif†≤#ifdef SQLITE_TESTŸ<SQLITE_PRIVATE void sqlite3PcacheStats(int*,int*,int*,int*);¶#endif†Ÿ2SQLITE_PRIVATE void sqlite3PCacheSetDefault(void);†º/* Return the header size */Ÿ1SQLITE_PRIVATE int sqlite3HeaderSizePcache(void);Ÿ2SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void);†ŸH/* Number of dirty pages as a percentage of the configured cache size */Ÿ6SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache*);†∑#endif /* _PCACHE_H_ */†ŸO/************** End of pcache.h **********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/ŸO/************** Include os.h in the middle of sqliteInt.h ********************/ŸO/************** Begin file os.h **********************************************/¢/*¥** 2001 September 16¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸB** This header file (together with is companion C source-code fileŸF** "os.c") attempt to abstract the underlying operating system so thatŸB** the SQLite library will work on both POSIX and windows systems.¢**ŸB** This header file is #include-ed by sqliteInt.h and thus ends upŸ'** being included by every source file.¢*/µ#ifndef _SQLITE_OS_H_µ#define _SQLITE_OS_H_†¢/*ŸE** Attempt to automatically detect the operating system and setup theŸ)** necessary pre-processor macros for it.¢*/ŸO/************** Include os_setup.h in the middle of os.h *********************/ŸO/************** Begin file os_setup.h ****************************************/¢/*≥** 2013 November 25¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸJ** This file contains pre-processor directives related to operating system∫** detection and/or setup.¢*/π#ifndef SQLITE_OS_SETUP_Hπ#define SQLITE_OS_SETUP_H†¢/*ŸK** Figure out if we are dealing with Unix, Windows, or some other operating™** system.¢**ŸI** After the following block of preprocess macros, all of SQLITE_OS_UNIX,ŸL** SQLITE_OS_WIN, and SQLITE_OS_OTHER will defined to either 1 or 0.  One ofŸ1** the three will be 1.  The other two will be 0.¢*/º#if defined(SQLITE_OS_OTHER)∏#  if SQLITE_OS_OTHER==1π#    undef SQLITE_OS_UNIXº#    define SQLITE_OS_UNIX 0∏#    undef SQLITE_OS_WINª#    define SQLITE_OS_WIN 0ß#  else∫#    undef SQLITE_OS_OTHER®#  endif¶#endifŸ9#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)ª#  define SQLITE_OS_OTHER 0∑#  ifndef SQLITE_OS_WINŸE#    if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \Ÿ5        defined(__MINGW32__) || defined(__BORLANDC__)Ω#      define SQLITE_OS_WIN 1æ#      define SQLITE_OS_UNIX 0©#    elseΩ#      define SQLITE_OS_WIN 0æ#      define SQLITE_OS_UNIX 1™#    endifß#  elseº#    define SQLITE_OS_UNIX 0®#  endif•#else∑#  ifndef SQLITE_OS_WINª#    define SQLITE_OS_WIN 0®#  endif¶#endif†æ#endif /* SQLITE_OS_SETUP_H */†ŸO/************** End of os_setup.h ********************************************/ŸO/************** Continuing where we left off in os.h *************************/†Ÿ?/* If the SET_FULLSYNC macro is not defined above, then make it™** a no-op¢*/¥#ifndef SET_FULLSYNC∫# define SET_FULLSYNC(x,y)¶#endif†¢/*Ÿ$** The default size of a disk sector¢*/Ÿ"#ifndef SQLITE_DEFAULT_SECTOR_SIZEŸ(# define SQLITE_DEFAULT_SECTOR_SIZE 4096¶#endif†¢/*ŸL** Temporary files are named starting with this prefix followed by 16 randomŸI** alphanumeric characters, and no file extension. They are stored in theŸI** OS's standard temporary file directory, and are deleted prior to exit.ŸM** If sqlite is being embedded in another program, you may wish to change theŸG** prefix to reflect your program's name, so that if your program exitsŸN** prematurely, old temporary files can be easily identified. This can be doneŸJ** using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.¢**ŸB** 2006-10-31:  The default prefix used to be "sqlite_".  But thenŸA** Mcafee started using SQLite in their anti-virus product and itŸF** started putting files with the "sqlite" name in the c:/temp folder.ŸA** This annoyed many windows users.  Those users would then do a Ÿ@** Google search for "sqlite", find the telephone numbers of theŸ=** developers and call to wake them up at night and complain.ŸF** For this reason, the default name prefix is changed to be "sqlite" ŸB** spelled backwards.  So the temp files are still identified, butŸC** anybody smart enough to figure out the code is also likely smartŸB** enough to know that calling the developer will not help get ridØ** of the file.¢*/ø#ifndef SQLITE_TEMP_FILE_PREFIXŸ*# define SQLITE_TEMP_FILE_PREFIX "etilqs_"¶#endif†¢/*Ÿ?** The following values may be passed as the second argument toŸF** sqlite3OsLock(). The various locks exhibit the following semantics:¢**ŸL** SHARED:    Any number of processes may hold a SHARED lock simultaneously.ŸD** RESERVED:  A single process may hold a RESERVED lock on a file atŸM**            any time. Other processes may hold and obtain new SHARED locks.ŸC** PENDING:   A single process may hold a PENDING lock on a file atŸI**            any one time. Existing SHARED locks may persist, but no newŸ>**            SHARED locks may be obtained by other processes.Ÿ:** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.¢**ŸI** PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, aŸH** process that requests an EXCLUSIVE lock may actually obtain a PENDINGŸJ** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to≥** sqlite3OsLock().¢*/π#define NO_LOCK         0π#define SHARED_LOCK     1π#define RESERVED_LOCK   2π#define PENDING_LOCK    3π#define EXCLUSIVE_LOCK  4†¢/*ŸJ** File Locking Notes:  (Mostly about windows but also some info for Unix)¢**ŸF** We cannot use LockFileEx() or UnlockFileEx() on Win95/98/ME becauseŸD** those functions are not available.  So we use only LockFile() and∞** UnlockFile().¢**ŸL** LockFile() prevents not just writing but also reading by other processes.ŸA** A SHARED_LOCK is obtained by locking a single randomly-chosen ŸG** byte out of a specific range of bytes. The lock byte is obtained at ŸF** random so two separate readers can probably access the file at the ŸD** same time, unless they are unlucky and choose the same lock byte.ŸC** An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.ŸH** There can only be one writer.  A RESERVED_LOCK is obtained by lockingŸJ** a single byte of the file that is designated as the reserved lock byte.ŸI** A PENDING_LOCK is obtained by locking a designated byte different from∫** the RESERVED_LOCK byte.¢**ŸI** On WinNT/2K/XP systems, LockFileEx() and UnlockFileEx() are available,ŸH** which means we can use reader/writer locks.  When reader/writer locksŸG** are used, the lock is placed on the same range of bytes that is usedŸG** for probabilistic locking in Win95/98/ME.  Hence, the locking schemeŸG** will support two or more Win95 readers or two or more WinNT readers.ŸI** But a single Win95 reader will lock out all WinNT readers and a singleŸ6** WinNT reader will lock out all other Win95 readers.¢**ŸF** The following #defines specify the range of bytes used for locking.ŸF** SHARED_SIZE is the number of bytes available in the pool from whichŸF** a random byte is selected for a shared lock.  The pool of bytes forŸ(** shared locks begins at SHARED_FIRST. ¢**Ÿ ** The same locking strategy andŸM** byte ranges are used for Unix.  This leaves open the possibility of havingŸH** clients on win95, winNT, and unix all talking to the same shared fileŸM** and all locking correctly.  To do so would require that samba (or whateverŸJ** tool is being used for file sharing) implements locks correctly betweenŸF** windows and unix.  I'm guessing that isn't likely to happen, but byŸH** using the same locking range we are at least open to the possibility.¢**ŸE** Locking in windows is manditory.  For this reason, we cannot storeŸH** actual data in the bytes used for locking.  The pager never allocatesŸG** the pages involved in locking therefore.  SHARED_SIZE is selected soŸJ** that all locks will fit on a single page even at the minimum page size.ŸL** PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTEŸF** is set high so that we don't have to allocate an unused page exceptŸJ** for very large databases.  But one should test the page skipping logic ŸG** by setting PENDING_BYTE low and running the entire regression suite.¢**ŸF** Changing the value of PENDING_BYTE results in a subtly incompatibleŸE** file format.  Depending on how it is changed, you might not noticeŸG** the incompatibility right away, even running a full regression test.ŸB** The default location of PENDING_BYTE is the first byte past the∞** 1GB boundary.¢**¢*/∂#ifdef SQLITE_OMIT_WSDŸ&# define PENDING_BYTE     (0x40000000)•#elseŸ-# define PENDING_BYTE      sqlite3PendingByte¶#endifŸ*#define RESERVED_BYTE     (PENDING_BYTE+1)Ÿ*#define SHARED_FIRST      (PENDING_BYTE+2)Ω#define SHARED_SIZE       510†¢/*Ÿ9** Wrapper around OS specific sqlite3_os_init() function.¢*/Ÿ'SQLITE_PRIVATE int sqlite3OsInit(void);†£/* Ÿ0** Functions for accessing sqlite3_file methods ¢*/Ÿ2SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file*);ŸLSQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);ŸSSQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);Ÿ>SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size);Ÿ5SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int);Ÿ@SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);Ÿ5SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int);Ÿ7SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int);ŸNSQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);ŸASQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*);ŸFSQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file*,int,void*);Ÿ,#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0Ÿ9SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id);ŸDSQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);∑#ifndef SQLITE_OMIT_WALŸPSQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);ŸESQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int);Ÿ:SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id);Ÿ<SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);º#endif /* SQLITE_OMIT_WAL */ŸGSQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);ŸASQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *, i64, void *);††£/* Ÿ/** Functions for accessing sqlite3_vfs methods ¢*/ŸYSQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);ŸESQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int);ŸSSQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);ŸSSQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);Ÿ"#ifndef SQLITE_OMIT_LOAD_EXTENSIONŸBSQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);ŸASQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *);ŸQSQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);Ÿ<SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);Ÿ'#endif /* SQLITE_OMIT_LOAD_EXTENSION */ŸCSQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *);Ÿ6SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int);Ÿ7SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs*);ŸLSQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);†¢/*Ÿ=** Convenience functions for opening and closing files using ŸB** sqlite3_malloc() to obtain space for the file-handle structure.¢*/Ÿ_SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);Ÿ7SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *);†∫#endif /* _SQLITE_OS_H_ */†ŸO/************** End of os.h **************************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/ŸO/************** Include mutex.h in the middle of sqliteInt.h *****************/ŸO/************** Begin file mutex.h *******************************************/¢/*±** 2007 August 28¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸF** This file contains the common header for all mutex implementations.ŸE** The sqliteInt.h header #includes this file so that it is availableŸF** to all source files.  We break it out in an effort to keep the code¥** better organized.¢**ŸG** NOTE:  source files should *not* #include this header file directly.ŸF** Source files should #include the sqliteInt.h file and let that fileø** include this one indirectly.¢*/††¢/*Ÿ?** Figure out what version of the code to use.  The choices are¢**ŸD**   SQLITE_MUTEX_OMIT         No mutex logic.  Not even stubs.  TheŸJ**                             mutexes implementation cannot be overriddenŸ-**                             at start-time.¢**ŸD**   SQLITE_MUTEX_NOOP         For single-threaded applications.  NoŸF**                             mutual exclusion is provided.  But thisŸB**                             implementation can be overridden atŸ***                             start-time.¢**ŸG**   SQLITE_MUTEX_PTHREADS     For multi-threaded applications on Unix.¢**ŸH**   SQLITE_MUTEX_W32          For multi-threaded applications on Win32.¢*/∂#if !SQLITE_THREADSAFE∫# define SQLITE_MUTEX_OMIT¶#endifŸ4#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)¥#  if SQLITE_OS_UNIXŸ!#    define SQLITE_MUTEX_PTHREADSµ#  elif SQLITE_OS_WINº#    define SQLITE_MUTEX_W32ß#  elseΩ#    define SQLITE_MUTEX_NOOP®#  endif¶#endif†∏#ifdef SQLITE_MUTEX_OMIT¢/*ŸE** If this is a no-op implementation, implement everything as macros.¢*/Ÿ5#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)Ω#define sqlite3_mutex_free(X)Ÿ"#define sqlite3_mutex_enter(X)    Ÿ+#define sqlite3_mutex_try(X)      SQLITE_OKŸ"#define sqlite3_mutex_leave(X)    Ÿ/#define sqlite3_mutex_held(X)     ((void)(X),1)Ÿ/#define sqlite3_mutex_notheld(X)  ((void)(X),1)Ÿ5#define sqlite3MutexAlloc(X)      ((sqlite3_mutex*)8)Ÿ+#define sqlite3MutexInit()        SQLITE_OKπ#define sqlite3MutexEnd()∂#define MUTEX_LOGIC(X)•#elseŸ##define MUTEX_LOGIC(X)            XŸ'#endif /* defined(SQLITE_MUTEX_OMIT) */†ŸO/************** End of mutex.h ***********************************************/ŸO/************** Continuing where we left off in sqliteInt.h ******************/†ŸG/* The SQLITE_EXTRA_DURABLE compile-time option used to set the defaultŸ<** synchronous setting to EXTRA.  It is no longer supported.¢*/ª#ifdef SQLITE_EXTRA_DURABLEŸJ# warning Use SQLITE_DEFAULT_SYNCHRONOUS=3 instead of SQLITE_EXTRA_DURABLEŸ%# define SQLITE_DEFAULT_SYNCHRONOUS 3¶#endif†¢/*æ** Default synchronous levels.¢**ŸJ** Note that (for historcal reasons) the PAGER_SYNCHRONOUS_* macros differŸ2** from the SQLITE_DEFAULT_SYNCHRONOUS value by 1.¢**Ÿ8**           PAGER_SYNCHRONOUS       DEFAULT_SYNCHRONOUSŸ.**   OFF           1                         0Ÿ.**   NORMAL        2                         1Ÿ.**   FULL          3                         2Ÿ.**   EXTRA         4                         3¢**ŸG** The "PRAGMA synchronous" statement also uses the zero-based numbers.ŸN** In other words, the zero-based numbers are used for all external interfacesŸ0** and the one-based values are used internally.¢*/Ÿ"#ifndef SQLITE_DEFAULT_SYNCHRONOUSŸ%# define SQLITE_DEFAULT_SYNCHRONOUS 2¶#endifŸ&#ifndef SQLITE_DEFAULT_WAL_SYNCHRONOUSŸB# define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS¶#endif†¢/*ŸA** Each database file to be accessed by the system is an instanceŸJ** of the following structure.  There are normally two of these structuresŸC** in the sqlite.aDb[] array.  aDb[0] is the main database file andŸI** aDb[1] is the database file used to hold temporary tables.  AdditionalΩ** databases may be attached.¢*/´struct Db {ŸO  char *zDbSName;      /* Name of this database. (schema name, not filename) */ŸH  Btree *pBt;          /* The B*Tree structure for this database file */ŸC  u8 safety_level;     /* How aggressive at syncing data to disk */ŸH  u8 bSyncSet;         /* True if "PRAGMA synchronous=N" has been run */ŸI  Schema *pSchema;     /* Pointer to database schema (possibly shared) */¢};†¢/*ŸC** An instance of the following structure stores a database schema.¢**ŸE** Most Schema objects are associated with a Btree.  The exception isŸL** the Schema for the TEMP databaes (sqlite3.aDb[1]) which is free-standing.ŸI** In shared cache mode, a single Schema object can be shared by multipleŸ<** Btrees that refer to the same underlying BtShared object.¢**ŸH** Schema objects are automatically deallocated when the last Btree thatŸG** references them is destroyed.   The TEMP Schema is manually freed by≥** sqlite3_close().°*ŸG** A thread must be holding a mutex on the corresponding Btree in orderŸG** to access Schema content.  This implies that the thread must also beŸI** holding a mutex on the sqlite3 connection pointer that owns the Btree.Ÿ<** For a TEMP Schema, only the connection mutex is required.¢*/Østruct Schema {ŸI  int schema_cookie;   /* Database schema version number for this file */ŸN  int iGeneration;     /* Generation counter.  Incremented with each change */Ÿ7  Hash tblHash;        /* All tables indexed by name */Ÿ@  Hash idxHash;        /* All (named) indices indexed by name */Ÿ9  Hash trigHash;       /* All triggers indexed by name */ŸF  Hash fkeyHash;       /* All foreign keys by referenced table name */ŸL  Table *pSeqTab;      /* The sqlite_sequence table used by AUTOINCREMENT */Ÿ@  u8 file_format;      /* Schema format version for this file */Ÿ@  u8 enc;              /* Text encoding used by this database */Ÿ>  u16 schemaFlags;     /* Flags associated with this schema */Ÿ@  int cache_size;      /* Number of pages to use in the cache */¢};†¢/*Ÿ>** These macros can be used to test, set, or clear bits in theª** Db.pSchema->flags field.¢*/ŸN#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))ŸL#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)ŸF#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->schemaFlags|=(P)ŸG#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->schemaFlags&=~(P)†¢/*Ÿ2** Allowed values for the DB.pSchema->flags field.¢**ŸE** The DB_SchemaLoaded flag is set after the database schema has beenŸ"** read into internal hash tables.¢**ŸF** DB_UnresetViews means that one or more views have column names thatŸI** have been filled out.  If the schema changes, these column names mightŸ1** changes and so the view will need to be reset.¢*/ŸC#define DB_SchemaLoaded    0x0001  /* The schema has been loaded */ŸM#define DB_UnresetViews    0x0002  /* Some views have defined column names */ŸK#define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */ŸM#define DB_ResetWanted     0x0008  /* Reset the schema when nSchemaLock==0 */†¢/*Ÿ>** The number of different kinds of things that can be limitedŸ'** using the sqlite3_limit() interface.¢*/Ÿ6#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1)†¢/*ŸC** Lookaside malloc is a set of fixed-size buffers that can be usedŸD** to satisfy small transient memory allocation requests for objectsŸ@** associated with a particular database connection.  The use ofŸB** lookaside malloc provides a significant performance enhancementŸG** (approx 10%) by avoiding numerous malloc/free requests while parsing≤** SQL statements.¢**ŸD** The Lookaside structure holds configuration information about theŸC** lookaside malloc subsystem.  Each available memory allocation inŸF** the lookaside subsystem is stored on a linked list of LookasideSlot´** objects.¢**ŸI** Lookaside allocations are only allowed for objects that are associatedŸK** with a particular database connection.  Hence, schema information cannotŸM** be stored in lookaside because in shared cache mode the schema informationŸH** is shared by multiple database connections.  Therefore, while parsingŸE** schema information, the Lookaside.bEnabled flag is cleared so thatŸF** lookaside allocations are not used to construct the schema objects.¢*/≤struct Lookaside {ŸD  u32 bDisable;           /* Only operate the lookaside when zero */Ÿ<  u16 sz;                 /* Size of each buffer in bytes */ŸM  u8 bMalloced;           /* True if pStart obtained from sqlite3_malloc() */ŸC  u32 nSlot;              /* Number of lookaside slots allocated */ŸI  u32 anStat[3];          /* 0: hits.  1: size misses.  2: full misses */ŸC  LookasideSlot *pInit;   /* List of buffers not previously used */Ÿ9  LookasideSlot *pFree;   /* List of available buffers */ŸD  void *pStart;           /* First byte of available memory space */ŸF  void *pEnd;             /* First byte past end of available space */¢};∂struct LookasideSlot {ŸH  LookasideSlot *pNext;    /* Next buffer in the list of free buffers */¢};†¢/*ŸH** A hash table for built-in function definitions.  (Application-definedŸ4** functions use a regular table table from hash.h.)¢**ŸE** Hash each FuncDef structure into one of the FuncDefHash.a[] slots.Ÿ/** Collisions are on the FuncDef.u.pHash chain.¢*/æ#define SQLITE_FUNC_HASH_SZ 23¥struct FuncDefHash {ŸG  FuncDef *a[SQLITE_FUNC_HASH_SZ];       /* Hash table for functions */¢};†Ÿ!#ifdef SQLITE_USER_AUTHENTICATION¢/*ŸH** Information held in the "sqlite3" database connection object and usedŸ!** to manage user authentication.¢*/Ÿ1typedef struct sqlite3_userauth sqlite3_userauth;πstruct sqlite3_userauth {ŸB  u8 authLevel;                 /* Current authentication level */ŸB  int nAuthPW;                  /* Size of the zAuthPW in bytes */ŸC  char *zAuthPW;                /* Password used to authenticate */ŸD  char *zAuthUser;              /* User name used to authenticate */¢};†Ÿ3/* Allowed values for sqlite3_userauth.authLevel */ŸD#define UAUTH_Unknown     0     /* Authentication not yet checked */Ÿ@#define UAUTH_Fail        1     /* User authentication failed */ŸD#define UAUTH_User        2     /* Authenticated as a normal user */ŸG#define UAUTH_Admin       3     /* Authenticated as an administrator */†Ÿ5/* Functions used only by user authorization logic */Ÿ5SQLITE_PRIVATE int sqlite3UserAuthTable(const char*);ŸGSQLITE_PRIVATE int sqlite3UserAuthCheckLogin(sqlite3*,const char*,u8*);Ÿ2SQLITE_PRIVATE void sqlite3UserAuthInit(sqlite3*);ŸKSQLITE_PRIVATE void sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**);†Ÿ'#endif /* SQLITE_USER_AUTHENTICATION */†¢/*Ÿ3** typedef for the authorization callback function.¢*/Ÿ!#ifdef SQLITE_USER_AUTHENTICATIONŸM  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,Ÿ9                               const char*, const char*);•#elseŸM  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,Ÿ,                               const char*);¶#endif†æ#ifndef SQLITE_OMIT_DEPRECATEDŸF/* This is an extra SQLITE_TRACE macro that indicates "legacy" tracingŸ"** in the style of sqlite3_trace()¢*/Ÿ!#define SQLITE_TRACE_LEGACY  0x80•#elseæ#define SQLITE_TRACE_LEGACY  0Ÿ##endif /* SQLITE_OMIT_DEPRECATED */††¢/*ŸF** Each database connection is an instance of the following structure.¢*/∞struct sqlite3 {Ÿ2  sqlite3_vfs *pVfs;            /* OS Interface */ŸE  struct Vdbe *pVdbe;           /* List of active virtual machines */ŸM  CollSeq *pDfltColl;           /* The default collating sequence (BINARY) */Ÿ6  sqlite3_mutex *mutex;         /* Connection mutex */Ÿ2  Db *aDb;                      /* All backends */ŸI  int nDb;                      /* Number of backends currently in use */ŸD  u32 mDbFlags;                 /* flags recording internal state */ŸJ  u32 flags;                    /* flags settable by pragmas. See below */ŸM  i64 lastRowid;                /* ROWID of most recent insert (see above) */Ÿ?  i64 szMmap;                   /* Default mmap_size setting */ŸK  u32 nSchemaLock;              /* Do not reset the schema when non-zero */ŸI  unsigned int openFlags;       /* Flags passed to sqlite3_vfs.xOpen() */ŸG  int errCode;                  /* Most recent error code (SQLITE_*) */ŸO  int errMask;                  /* & result codes with this before returning */ŸH  int iSysErrno;                /* Errno value from last system error */ŸK  u16 dbOptFlags;               /* Flags to enable/disable optimizations */Ÿ3  u8 enc;                       /* Text encoding */Ÿ;  u8 autoCommit;                /* The auto-commit flag. */ŸB  u8 temp_store;                /* 1: file 2: memory 0: default */ŸK  u8 mallocFailed;              /* True if we have seen a malloc failure */ŸA  u8 bBenignMalloc;             /* Do not require OOMs if true */ŸK  u8 dfltLockMode;              /* Default locking-mode for attached dbs */ŸI  signed char nextAutovac;      /* Autovac setting after VACUUM if >=0 */ŸI  u8 suppressErr;               /* Do not issue error messages if true */ŸO  u8 vtabOnConflict;            /* Value to return for s3_vtab_on_conflict() */ŸM  u8 isTransactionSavepoint;    /* True if the outermost savepoint is a TS */ŸE  u8 mTrace;                    /* zero or more SQLITE_TRACE flags */ŸF  u8 skipBtreeMutex;            /* True if no shared-cache backends */ŸJ  u8 nSqlExec;                  /* Number of pending OP_SqlExec opcodes */ŸA  int nextPagesize;             /* Pagesize after VACUUM if >0 */ŸL  u32 magic;                    /* Magic number for detect library misuse */ŸI  int nChange;                  /* Value returned by sqlite3_changes() */ŸO  int nTotalChange;             /* Value returned by sqlite3_total_changes() */Ÿ,  int aLimit[SQLITE_N_LIMIT];   /* Limits */ŸN  int nMaxSorterMmap;           /* Maximum size of regions mapped by sorter */ŸL  struct sqlite3InitInfo {      /* Information used during initialization */ŸI    int newTnum;                /* Rootpage of table being initialized */ŸH    u8 iDb;                     /* Which db file is being initialized */ŸD    u8 busy;                    /* TRUE if currently initializing */ŸM    unsigned orphanTrigger : 1; /* Last statement is orphaned TEMP trigger */Ÿ@    unsigned imposterTable : 1; /* Building an imposter table */ŸK    unsigned reopenMemdb : 1;   /* ATTACH is really a reopen using MemDB */©  } init;ŸG  int nVdbeActive;              /* Number of VDBEs currently running */ŸO  int nVdbeRead;                /* Number of active VDBEs that read or write */ŸP  int nVdbeWrite;               /* Number of active VDBEs that read and write */ŸJ  int nVdbeExec;                /* Number of nested calls to VdbeExec() */ŸM  int nVDestroy;                /* Number of active OP_VDestroy operations */ŸA  int nExtension;               /* Number of loaded extensions */ŸE  void **aExtension;            /* Array of shared library handles */Ÿ@  int (*xTrace)(u32,void*,void*,void*);     /* Trace function */ŸP  void *pTraceArg;                          /* Argument to the trace function */ŸD  void (*xProfile)(void*,const char*,u64);  /* Profiling function */ŸN  void *pProfileArg;                        /* Argument to profile function */ŸG  void *pCommitArg;                 /* Argument to xCommitCallback() */ŸB  int (*xCommitCallback)(void*);    /* Invoked at every commit. */ŸI  void *pRollbackArg;               /* Argument to xRollbackCallback() */ŸB  void (*xRollbackCallback)(void*); /* Invoked at every commit. */≥  void *pUpdateArg;ŸK  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);Ÿ##ifdef SQLITE_ENABLE_PREUPDATE_HOOKŸJ  void *pPreUpdateArg;          /* First argument to xPreUpdateCallback */ŸO  void (*xPreUpdateCallback)(   /* Registered using sqlite3_preupdate_hook() */ŸJ    void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64§  );ŸL  PreUpdate *pPreUpdate;        /* Context for active pre-update callback */Ÿ)#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */∑#ifndef SQLITE_OMIT_WALŸ<  int (*xWalCallback)(void *, sqlite3 *, const char *, int);∞  void *pWalArg;¶#endifŸ>  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);Ÿ@  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);∑  void *pCollNeededArg;Ÿ?  sqlite3_value *pErr;          /* Most recent error message */©  union {ŸO    volatile int isInterrupted; /* True if sqlite3_interrupt has been called */Ÿ,    double notUsed1;            /* Spacer */ß  } u1;ŸD  Lookaside lookaside;          /* Lookaside malloc configuration */Ÿ!#ifndef SQLITE_OMIT_AUTHORIZATIONŸC  sqlite3_xauth xAuth;          /* Access authorization function */ŸN  void *pAuthArg;               /* 1st argument to the access auth function */¶#endifŸ%#ifndef SQLITE_OMIT_PROGRESS_CALLBACKŸ;  int (*xProgress)(void *);     /* The progress callback */ŸG  void *pProgressArg;           /* Argument to the progress callback */ŸM  unsigned nProgressOps;        /* Number of opcodes for progress callback */¶#endifŸ #ifndef SQLITE_OMIT_VIRTUALTABLEŸ?  int nVTrans;                  /* Allocated size of aVTrans */ŸJ  Hash aModule;                 /* populated by sqlite3_create_module() */ŸL  VtabCtx *pVtabCtx;            /* Context for active vtab connect/create */ŸK  VTable **aVTrans;             /* Virtual tables with open transactions */ŸP  VTable *pDisconnect;          /* Disconnect these in next sqlite3_prepare() */¶#endifŸH  Hash aFunc;                   /* Hash table of connection functions */Ÿ=  Hash aCollSeq;                /* All collating sequences */Ÿ3  BusyHandler busyHandler;      /* Busy callback */ŸM  Db aDbStatic[2];              /* Static space for the 2 default backends */Ÿ?  Savepoint *pSavepoint;        /* List of active savepoints */ŸC  int busyTimeout;              /* Busy handler timeout, in msec */ŸJ  int nSavepoint;               /* Number of non-transaction savepoints */ŸN  int nStatement;               /* Number of nested statement-transactions  */ŸP  i64 nDeferredCons;            /* Net deferred constraints this transaction. */ŸH  i64 nDeferredImmCons;         /* Net deferred immediate constraints */ŸM  int *pnBytesFreed;            /* If not NULL, increment this in DbFree() */Ÿ"#ifdef SQLITE_ENABLE_UNLOCK_NOTIFYŸC  /* The following variables are all protected by the STATIC_MASTERŸD  ** mutex, not by sqlite3.mutex. They are used by code in notify.c.§  **ŸG  ** When X.pUnlockConnection==Y, that means that X is waiting for Y toŸ#  ** unlock so that it can proceed.§  **ŸJ  ** When X.pBlockingConnection==Y, that means that something that X triedŸI  ** tried to do recently failed with an SQLITE_LOCKED error due to locksØ  ** held by Y.§  */ŸJ  sqlite3 *pBlockingConnection; /* Connection that caused SQLITE_LOCKED */ŸL  sqlite3 *pUnlockConnection;           /* Connection to watch for unlock */ŸG  void *pUnlockArg;                     /* Argument to xUnlockNotify */ŸD  void (*xUnlockNotify)(void **, int);  /* Unlock notify callback */ŸM  sqlite3 *pNextBlocked;        /* Next in list of all blocked connections */¶#endifŸ!#ifdef SQLITE_USER_AUTHENTICATIONŸE  sqlite3_userauth auth;        /* User authentication information */¶#endif¢};†¢/*Ÿ2** A macro to discover the encoding of a database.¢*/Ÿ2#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)Ÿ"#define ENC(db)        ((db)->enc)†¢/*Ÿ)** Possible values for the sqlite3.flags.¢**Ÿ-** Value constraints (enforced via assert()):Ÿ/**      SQLITE_FullFSync     == PAGER_FULLFSYNCŸ4**      SQLITE_CkptFullFSync == PAGER_CKPT_FULLFSYNCŸ1**      SQLITE_CacheSpill    == PAGER_CACHE_SPILL¢*/ŸJ#define SQLITE_WriteSchema    0x00000001  /* OK to update SQLITE_MASTER */ŸP#define SQLITE_LegacyFileFmt  0x00000002  /* Create new databases in format 1 */ŸP#define SQLITE_FullColNames   0x00000004  /* Show full column names on SELECT */ŸM#define SQLITE_FullFSync      0x00000008  /* Use full fsync on the backend */ŸM#define SQLITE_CkptFullFSync  0x00000010  /* Use full fsync for checkpoint */ŸG#define SQLITE_CacheSpill     0x00000020  /* OK to spill pager cache */ŸH#define SQLITE_ShortColNames  0x00000040  /* Show short columns names */ŸM#define SQLITE_CountRows      0x00000080  /* Count rows changed by INSERT, */ŸN                                          /*   DELETE, or UPDATE and return */ŸM                                          /*   the count using a callback. */ŸO#define SQLITE_NullCallback   0x00000100  /* Invoke the callback once if the */ŸE                                          /*   result set is empty */ŸP#define SQLITE_IgnoreChecks   0x00000200  /* Do not enforce check constraints */ŸP#define SQLITE_ReadUncommit   0x00000400  /* READ UNCOMMITTED in shared-cache */ŸO#define SQLITE_NoCkptOnClose  0x00000800  /* No checkpoint on close()/DETACH */ŸI#define SQLITE_ReverseOrder   0x00001000  /* Reverse unordered SELECTs */ŸI#define SQLITE_RecTriggers    0x00002000  /* Enable recursive triggers */ŸP#define SQLITE_ForeignKeys    0x00004000  /* Enforce foreign key constraints  */ŸH#define SQLITE_AutoIndex      0x00008000  /* Enable automatic indexes */ŸE#define SQLITE_LoadExtension  0x00010000  /* Enable load_extension */ŸP#define SQLITE_LoadExtFunc    0x00020000  /* Enable load_extension() SQL func */ŸG#define SQLITE_EnableTrigger  0x00040000  /* True to enable triggers */ŸH#define SQLITE_DeferFKs       0x00080000  /* Defer all FK constraints */ŸH#define SQLITE_QueryOnly      0x00100000  /* Disable database changes */ŸN#define SQLITE_CellSizeCk     0x00200000  /* Check btree cell sizes on load */ŸH#define SQLITE_Fts3Tokenizer  0x00400000  /* Enable fts3_tokenizer(2) */ŸP#define SQLITE_EnableQPSG     0x00800000  /* Query Planner Stability Guarantee*/ŸO#define SQLITE_TriggerEQP     0x01000000  /* Show trigger EXPLAIN QUERY PLAN */†Ÿ"/* Flags used only if debugging */≥#ifdef SQLITE_DEBUGŸN#define SQLITE_SqlTrace       0x08000000  /* Debug print SQL as it executes */ŸO#define SQLITE_VdbeListing    0x10000000  /* Debug listings of VDBE programs */ŸL#define SQLITE_VdbeTrace      0x20000000  /* True to trace VDBE execution */ŸN#define SQLITE_VdbeAddopTrace 0x40000000  /* Trace sqlite3VdbeAddOp() calls */ŸH#define SQLITE_VdbeEQP        0x80000000  /* Debug EXPLAIN QUERY PLAN */¶#endif†¢/*Ÿ&** Allowed values for sqlite3.mDbFlags¢*/ŸJ#define DBFLAG_SchemaChange   0x0001  /* Uncommitted Hash table changes */ŸH#define DBFLAG_PreferBuiltin  0x0002  /* Preference to built-in funcs */ŸA#define DBFLAG_Vacuum         0x0004  /* Currently in a VACUUM */†¢/*Ÿ<** Bits of the sqlite3.dbOptFlags field that are used by theŸG** sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...) interface toŸ-** selectively disable various optimizations.¢*/Ÿ=#define SQLITE_QueryFlattener 0x0001   /* Query flattening */Ÿ9#define SQLITE_ColumnCache    0x0002   /* Column cache */ŸE#define SQLITE_GroupByOrder   0x0004   /* GROUPBY cover of ORDERBY */Ÿ?#define SQLITE_FactorOutConst 0x0008   /* Constant factoring */ŸC#define SQLITE_DistinctOpt    0x0010   /* DISTINCT using indexes */ŸA#define SQLITE_CoverIdxScan   0x0020   /* Covering index scans */ŸH#define SQLITE_OrderByIdxJoin 0x0040   /* ORDER BY of joins via index */ŸC#define SQLITE_Transitive     0x0080   /* Transitive constraints */ŸH#define SQLITE_OmitNoopJoin   0x0100   /* Omit unused tables in joins */ŸK#define SQLITE_CountOfView    0x0200   /* The count-of-view optimization */ŸF#define SQLITE_CursorHints    0x0400   /* Add OP_CursorHint opcodes */ŸD#define SQLITE_Stat34         0x0800   /* Use STAT3 or STAT4 data */ŸL   /* TH3 expects the Stat34  ^^^^^^ value to be 0x0800.  Don't change it */ŸG#define SQLITE_PushDown       0x1000   /* The push-down optimization */ŸF#define SQLITE_SimplifyJoin   0x2000   /* Convert LEFT JOIN to JOIN */Ÿ>#define SQLITE_AllOpts        0xffff   /* All optimizations */†¢/*ŸK** Macros for testing whether or not optimizations are enabled or disabled.¢*/ŸF#define OptimizationDisabled(db, mask)  (((db)->dbOptFlags&(mask))!=0)ŸF#define OptimizationEnabled(db, mask)   (((db)->dbOptFlags&(mask))==0)†¢/*ŸN** Return true if it OK to factor constant expressions into the initializationŸ?** code. The argument is a Parse object for the code generator.¢*/Ÿ-#define ConstFactorOk(P) ((P)->okConstFactor)†¢/*Ÿ.** Possible values for the sqlite.magic field.ŸH** The numbers are obtained at random and have no special meaning, otherŸ(** than being distinct from one another.¢*/Ÿ@#define SQLITE_MAGIC_OPEN     0xa029a697  /* Database is open */ŸB#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /* Database is closed */ŸH#define SQLITE_MAGIC_SICK     0x4b771290  /* Error and awaiting close */ŸI#define SQLITE_MAGIC_BUSY     0xf03b7906  /* Database currently in use */ŸO#define SQLITE_MAGIC_ERROR    0xb5357930  /* An SQLITE_MISUSE error occurred */ŸO#define SQLITE_MAGIC_ZOMBIE   0x64cffc7f  /* Close with last statement close */†¢/*Ÿ?** Each SQL function is defined by an instance of the followingŸK** structure.  For global built-in functions (ex: substr(), max(), count())ŸM** a pointer to this structure is held in the sqlite3BuiltinFunctions object.ŸF** For per-connection application-defined functions, a pointer to thisŸ1** structure is held in the db->aHash hash table.¢**ŸH** The u.pHash field is used by the global built-ins.  The u.pDestructorŸ5** field is used by per-connection app-def functions.¢*/∞struct FuncDef {ŸE  i8 nArg;             /* Number of arguments.  -1 means unlimited */Ÿ>  u16 funcFlags;       /* Some combination of SQLITE_FUNC_* */Ÿ0  void *pUserData;     /* User data parameter */Ÿ9  FuncDef *pNext;      /* Next function with same name */ŸN  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**); /* func or agg-step */ŸK  void (*xFinalize)(sqlite3_context*);                  /* Agg finalizer */Ÿ6  const char *zName;   /* SQL name of the function. */©  union {ŸK    FuncDef *pHash;      /* Next with a different name but the same hash */ŸN    FuncDestructor *pDestructor;   /* Reference counted destructor function */¶  } u;¢};†¢/*ŸF** This structure encapsulates a user-function destructor callback (asŸG** configured using create_function_v2()) and a reference counter. WhenŸI** create_function_v2() is called to create a function with a destructor,ŸK** a single object of this type is allocated. FuncDestructor.nRef is set toŸM** the number of FuncDef objects created (either 1 or 3, depending on whetherŸH** or not the specified encoding is SQLITE_ANY). The FuncDef.pDestructorŸM** member of each of the new FuncDef objects is set to point to the allocated≤** FuncDestructor.¢**ŸH** Thereafter, when one of the FuncDef objects is deleted, the referenceŸI** count on this object is decremented. When it reaches 0, the destructorŸ5** is invoked and the FuncDestructor structure freed.¢*/∑struct FuncDestructor {´  int nRef;ª  void (*xDestroy)(void *);≤  void *pUserData;¢};†¢/*ŸH** Possible values for FuncDef.flags.  Note that the _LENGTH and _TYPEOFŸH** values must correspond to OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG.  AndŸH** SQLITE_FUNC_CONSTANT must be the same as SQLITE_DETERMINISTIC.  ThereŸ6** are assert() statements in the code to verify this.¢**Ÿ-** Value constraints (enforced via assert()):ŸB**     SQLITE_FUNC_MINMAX    ==  NC_MinMaxAgg      == SF_MinMaxAggŸ1**     SQLITE_FUNC_LENGTH    ==  OPFLAG_LENGTHARGŸ1**     SQLITE_FUNC_TYPEOF    ==  OPFLAG_TYPEOFARGŸB**     SQLITE_FUNC_CONSTANT  ==  SQLITE_DETERMINISTIC from the APIŸE**     SQLITE_FUNC_ENCMASK   depends on SQLITE_UTF* macros in the API¢*/ŸP#define SQLITE_FUNC_ENCMASK  0x0003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */ŸM#define SQLITE_FUNC_LIKE     0x0004 /* Candidate for the LIKE optimization */ŸK#define SQLITE_FUNC_CASE     0x0008 /* Case-sensitive LIKE-type function */ŸF#define SQLITE_FUNC_EPHEM    0x0010 /* Ephemeral.  Delete with VDBE */ŸP#define SQLITE_FUNC_NEEDCOLL 0x0020 /* sqlite3GetFuncCollSeq() might be called*/ŸD#define SQLITE_FUNC_LENGTH   0x0040 /* Built-in length() function */ŸD#define SQLITE_FUNC_TYPEOF   0x0080 /* Built-in typeof() function */ŸE#define SQLITE_FUNC_COUNT    0x0100 /* Built-in count(*) aggregate */ŸI#define SQLITE_FUNC_COALESCE 0x0200 /* Built-in coalesce() or ifnull() */ŸF#define SQLITE_FUNC_UNLIKELY 0x0400 /* Built-in unlikely() function */ŸP#define SQLITE_FUNC_CONSTANT 0x0800 /* Constant inputs give a constant output */ŸM#define SQLITE_FUNC_MINMAX   0x1000 /* True for min() and max() aggregates */ŸM#define SQLITE_FUNC_SLOCHNG  0x2000 /* "Slow Change". Value constant during aŸO                                    ** single query - might change over time */ŸF#define SQLITE_FUNC_AFFINITY 0x4000 /* Built-in affinity() function */ŸK#define SQLITE_FUNC_OFFSET   0x8000 /* Built-in sqlite_offset() function */†¢/*ŸI** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() areŸ>** used to create the initializers for the FuncDef structures.¢**Ÿ,**   FUNCTION(zName, nArg, iArg, bNC, xFunc)ŸF**     Used to create a scalar function definition of a function zNameŸG**     implemented by C function xFunc that accepts nArg arguments. TheŸC**     value passed as iArg is cast to a (void*) and made availableŸB**     as the user-data (sqlite3_user_data()) for the function. IfŸG**     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set.¢**Ÿ-**   VFUNCTION(zName, nArg, iArg, bNC, xFunc)ŸC**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag.¢**Ÿ-**   DFUNCTION(zName, nArg, iArg, bNC, xFunc)ŸF**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag andŸI**     adds the SQLITE_FUNC_SLOCHNG flag.  Used for date & time functionsŸJ**     and functions like sqlite_version() that can change, but not duringŸI**     a single query.  The iArg is ignored.  The user-data is always setŸ9**     to a NULL pointer.  The bNC parameter is not used.¢**Ÿ-**   PURE_DATE(zName, nArg, iArg, bNC, xFunc)ŸH**     Used for "pure" date/time functions, this macro is like DFUNCTIONŸG**     except that it does set the SQLITE_FUNC_CONSTANT flags.  iArg isŸB**     ignored and the user-data for these functions is set to an ŸB**     arbitrary non-NULL pointer.  The bNC parameter is not used.¢**Ÿ5**   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)ŸE**     Used to create an aggregate function definition implemented byŸB**     the C functions xStep and xFinal. The first four parametersŸC**     are interpreted in the same way as the first 4 parameters to≤**     FUNCTION().¢**Ÿ'**   LIKEFUNC(zName, nArg, pArg, flags)ŸF**     Used to create a scalar function definition of a function zNameŸD**     that accepts nArg arguments and is implemented by a call to CŸF**     function likeFunc. Argument pArg is cast to a (void *) and madeŸE**     available as the function user-data (sqlite3_user_data()). TheŸE**     FuncDef.flags variable is set to the value passed as the flags±**     parameter.¢*/Ÿ1#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \ŸG  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \Ÿ6   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }Ÿ2#define VFUNCTION(zName, nArg, iArg, bNC, xFunc) \Ÿ2  {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \Ÿ6   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }Ÿ2#define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \Ÿ+  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \Ÿ    0, 0, xFunc, 0, #zName, {0} }Ÿ2#define PURE_DATE(zName, nArg, iArg, bNC, xFunc) \Ÿ@  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \Ÿ4   (void*)&sqlite3Config, 0, xFunc, 0, #zName, {0} }Ÿ>#define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \ŸP  {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\Ÿ6   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }Ÿ5#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \ŸF  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \ø   pArg, 0, xFunc, 0, #zName, }Ÿ+#define LIKEFUNC(zName, nArg, arg, flags) \Ÿ2  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \Ÿ-   (void *)arg, 0, likeFunc, 0, #zName, {0} }Ÿ8#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) \Ÿ1  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL), \Ÿ7   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,#zName, {0}}ŸE#define AGGREGATE2(zName, nArg, arg, nc, xStep, xFinal, extraFlags) \Ÿ<  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|extraFlags, \Ÿ7   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,#zName, {0}}†¢/*ŸA** All current savepoints are stored in a linked list starting atŸI** sqlite3.pSavepoint. The first element in the list is the most recentlyŸA** opened savepoint. Savepoints are added to the list by the vdbeº** OP_Savepoint instruction.¢*/≤struct Savepoint {ŸK  char *zName;                        /* Savepoint name (nul-terminated) */ŸL  i64 nDeferredCons;                  /* Number of deferred fk violations */ŸF  i64 nDeferredImmCons;               /* Number of deferred imm fk. */ŸE  Savepoint *pNext;                   /* Parent savepoint (if any) */¢};†¢/*ŸH** The following are used as the second parameter to sqlite3Savepoint(),Ÿ:** and as the P1 argument to the OP_Savepoint instruction.¢*/æ#define SAVEPOINT_BEGIN      0æ#define SAVEPOINT_RELEASE    1æ#define SAVEPOINT_ROLLBACK   2††¢/*ŸA** Each SQLite module (virtual table definition) is defined by anŸE** instance of the following structure, stored in the sqlite3.aModuleÆ** hash table.¢*/Østruct Module {Ÿ>  const sqlite3_module *pModule;       /* Callback pointers */ŸK  const char *zName;                   /* Name passed to create_module() */ŸK  void *pAux;                          /* pAux passed to create_module() */ŸG  void (*xDestroy)(void *);            /* Module destructor function */ŸL  Table *pEpoTab;                      /* Eponymous table for this module */¢};†¢/*ŸG** information about each column of an SQL table is held in an instanceµ** of this structure.¢*/Østruct Column {ŸA  char *zName;     /* Name of this column, \000, then the type */Ÿ5  Expr *pDflt;     /* Default value of this column */ŸF  char *zColl;     /* Collating sequence.  If NULL, use the default */ŸG  u8 notNull;      /* An OE_ code for handling a NOT NULL constraint */Ÿ9  char affinity;   /* One of the SQLITE_AFF_... values */ŸO  u8 szEst;        /* Estimated size of value in this column. sizeof(INT)==1 */ŸH  u8 colFlags;     /* Boolean properties.  See COLFLAG_ defines below */¢};†Ÿ&/* Allowed values for Column.colFlags:¢*/ŸJ#define COLFLAG_PRIMKEY  0x0001    /* Column is part of the primary key */ŸK#define COLFLAG_HIDDEN   0x0002    /* A hidden column in a virtual table */ŸF#define COLFLAG_HASTYPE  0x0004    /* Type name follows column name */ŸM#define COLFLAG_UNIQUE   0x0008    /* Column def contains "UNIQUE" or "PK" */†¢/*ŸD** A "Collating Sequence" is defined by an instance of the followingŸG** structure. Conceptually, a collating sequence consists of a name andŸ@** a comparison routine that defines the order of that sequence.¢**Ÿ-** If CollSeq.xCmp is NULL, it means that theŸB** collating sequence is undefined.  Indices built on an undefinedŸ1** collating sequence may not be read or written.¢*/∞struct CollSeq {ŸK  char *zName;          /* Name of the collating sequence, UTF-8 encoded */Ÿ=  u8 enc;               /* Text encoding handled by xCmp() */Ÿ6  void *pUser;          /* First argument to xCmp() */Ÿ8  int (*xCmp)(void*,int, const void*, int, const void*);Ÿ2  void (*xDel)(void*);  /* Destructor for pUser */¢};†¢/*Ÿ*** A sort order can be either ASC or DESC.¢*/Ÿ<#define SQLITE_SO_ASC       0  /* Sort in ascending order */Ÿ<#define SQLITE_SO_DESC      1  /* Sort in ascending order */Ÿ<#define SQLITE_SO_UNDEFINED -1 /* No sort order specified */†¢/*π** Column affinity types.¢**ŸG** These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER andŸG** 't' for SQLITE_AFF_TEXT.  But we can save a little space and improveŸ<** the speed a little by numbering the values consecutively.¢**ŸC** But rather than start with 0 or 1, we begin with 'A'.  That way,ŸB** when multiple affinity types are concatenated into a string andŸ6** used as the P4 operand, they will be more readable.¢**ŸH** Note also that the numeric types are grouped together so that testingŸJ** for a numeric type is a single comparison.  And the BLOB type is first.¢*/ø#define SQLITE_AFF_BLOB     'A'ø#define SQLITE_AFF_TEXT     'B'ø#define SQLITE_AFF_NUMERIC  'C'ø#define SQLITE_AFF_INTEGER  'D'ø#define SQLITE_AFF_REAL     'E'†Ÿ>#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)†¢/*ŸB** The SQLITE_AFF_MASK values masks off the significant bits of an≤** affinity value.¢*/Ÿ #define SQLITE_AFF_MASK     0x47†¢/*ŸB** Additional bit values that can be ORed with an affinity withoutπ** changing the affinity.¢**ŸE** The SQLITE_NOTNULL flag is a combination of NULLEQ and JUMPIFNULL.ŸB** It causes an assert() to fire if either operand to a comparisonŸD** operator is NULL.  It is added to certain comparison operators toŸ/** prove that the operands are always NOT NULL.¢*/Ÿ?#define SQLITE_KEEPNULL     0x08  /* Used by vector == or <> */ŸG#define SQLITE_JUMPIFNULL   0x10  /* jumps if either operand is NULL */ŸP#define SQLITE_STOREP2      0x20  /* Store result in reg[P2] rather than jump */Ÿ1#define SQLITE_NULLEQ       0x80  /* NULL=NULL */ŸK#define SQLITE_NOTNULL      0x90  /* Assert that operands are never NULL */†¢/*ŸF** An object of this type is created for each virtual table present in∑** the database schema.¢**ŸG** If the database schema is shared, then there is one instance of thisŸI** structure for each database connection (sqlite3*) that uses the sharedŸK** schema. This is because each database connection requires its own uniqueŸH** instance of the sqlite3_vtab* handle used to access the virtual tableŸB** implementation. sqlite3_vtab* handles can not be shared betweenŸE** database connections, even when the rest of the in-memory databaseŸD** schema is shared, as the implementation often stores the databaseŸH** connection handle passed to it via the xConnect() or xCreate() methodŸH** during initialization internally. This database connection handle mayŸI** then be used by the virtual table implementation to access real tablesŸB** within the database. So that they appear as part of the callersŸD** transaction, these accesses need to be made via the same databaseŸJ** connection as that used to execute SQL operations on the virtual table.¢**ŸC** All VTable objects that correspond to a single table in a sharedŸF** database schema are initially stored in a linked-list pointed to byŸG** the Table.pVTable member variable of the corresponding Table object.ŸH** When an sqlite3_prepare() operation is required to access the virtualŸE** table, it searches the list for the VTable that corresponds to theŸC** database connection doing the preparing so as to use the correctŸ.** sqlite3_vtab* handle in the compiled query.¢**ŸB** When an in-memory Table object is deleted (for example when theŸH** schema is being reloaded for some reason), the VTable objects are notŸ@** deleted and the sqlite3_vtab* handles are not xDisconnect()edŸF** immediately. Instead, they are moved from the Table.pVTable list toŸF** another linked list headed by the sqlite3.pDisconnect member of theŸG** corresponding sqlite3 structure. They are then deleted/xDisconnectedŸF** next time a statement is prepared using said sqlite3*. This is doneŸE** to avoid deadlock issues involving multiple sqlite3.mutex mutexes.ŸB** Refer to comments above function sqlite3VtabUnlockList() for anŸM** explanation as to why it is safe to add an entry to an sqlite3.pDisconnectŸ>** list without holding the corresponding sqlite3.mutex mutex.¢**Ÿ=** The memory for objects of this type is always allocated byŸH** sqlite3DbMalloc(), using the connection handle stored in VTable.db as∂** the first argument.¢*/Østruct VTable {ŸP  sqlite3 *db;              /* Database connection associated with this table */ŸB  Module *pMod;             /* Pointer to module implementation */Ÿ:  sqlite3_vtab *pVtab;      /* Pointer to vtab instance */ŸF  int nRef;                 /* Number of pointers to this structure */ŸC  u8 bConstraint;           /* True if constraints are supported */Ÿ>  int iSavepoint;           /* Depth of the SAVEPOINT stack */ŸA  VTable *pNext;            /* Next in linked list (see above) */¢};†¢/*ŸB** The schema for each SQL table and view is represented in memoryŸ-** by an instance of the following structure.¢*/Æstruct Table {Ÿ6  char *zName;         /* Name of the table or view */Ÿ:  Column *aCol;        /* Information about each column */Ÿ?  Index *pIndex;       /* List of SQL indexes on this table. */ŸN  Select *pSelect;     /* NULL for tables.  Points to definition if a view. */ŸJ  FKey *pFKey;         /* Linked list of all foreign keys in this table */ŸH  char *zColAff;       /* String defining the affinity of each column */Ÿ2  ExprList *pCheck;    /* All CHECK constraints */ŸJ                       /*   ... also used as column name list in a VIEW */Ÿ;  int tnum;            /* Root BTree page for this table */Ÿ=  u32 nTabRef;         /* Number of pointers to this Table */Ÿ0  u32 tabFlags;        /* Mask of TF_* values */ŸJ  i16 iPKey;           /* If not negative, use aCol[iPKey] as the rowid */Ÿ<  i16 nCol;            /* Number of columns in this table */ŸN  LogEst nRowLogEst;   /* Estimated rows in table - from sqlite_stat1 table */ŸF  LogEst szTabRow;     /* Estimated size of each table row in bytes */Ω#ifdef SQLITE_ENABLE_COSTMULTŸA  LogEst costMult;     /* Cost multiplier for using this table */¶#endifŸO  u8 keyConf;          /* What to do in case of uniqueness conflict on iPKey */æ#ifndef SQLITE_OMIT_ALTERTABLEŸL  int addColOffset;    /* Offset in CREATE TABLE stmt to add a new column */¶#endifŸ #ifndef SQLITE_OMIT_VIRTUALTABLEŸ>  int nModuleArg;      /* Number of arguments to the module */ŸH  char **azModuleArg;  /* 0: module 1: schema 2: vtab name 3...: args */Ÿ4  VTable *pVTable;     /* List of VTable objects. */¶#endifŸ?  Trigger *pTrigger;   /* List of triggers stored in pSchema */Ÿ<  Schema *pSchema;     /* Schema that contains this table */Ÿ>  Table *pNextZombie;  /* Next on the Parse.pZombieTab list */¢};†¢/*Ÿ%** Allowed values for Table.tabFlags.¢**ŸK** TF_OOOHidden applies to tables or view that have hidden columns that areŸK** followed by non-hidden columns.  Example:  "CREATE VIRTUAL TABLE x USINGŸM** vtab1(a HIDDEN, b);".  Since "b" is a non-hidden column but "a" is hidden,ŸL** the TF_OOOHidden attribute would apply in this case.  Such tables requireŸ-** special handling during INSERT processing.¢*/ŸA#define TF_Readonly        0x0001    /* Read-only system table */Ÿ=#define TF_Ephemeral       0x0002    /* An ephemeral table */ŸB#define TF_HasPrimaryKey   0x0004    /* Table has a primary key */ŸO#define TF_Autoincrement   0x0008    /* Integer primary key is autoincrement */ŸK#define TF_HasStat1        0x0010    /* nRowLogEst set from sqlite_stat1 */ŸL#define TF_WithoutRowid    0x0020    /* No rowid.  PRIMARY KEY is the key */ŸI#define TF_NoVisibleRowid  0x0040    /* No user-visible "rowid" column */ŸF#define TF_OOOHidden       0x0080    /* Out-of-Order hidden columns */ŸK#define TF_StatsUsed       0x0100    /* Query planner decisions affected byŸE                                     ** Index.aiRowLogEst[] values */ŸH#define TF_HasNotNull      0x0200    /* Contains NOT NULL constraints */†¢/*ŸB** Test to see whether or not a table is a virtual table.  This isŸ@** done as a macro so that it will be optimized out when virtualŸ+** table support is omitted from the build.¢*/Ÿ #ifndef SQLITE_OMIT_VIRTUALTABLEŸ-#  define IsVirtual(X)      ((X)->nModuleArg)•#elseΩ#  define IsVirtual(X)      0¶#endif†¢/*ŸG** Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()ŸG** only works for non-virtual tables (ordinary tables and views) and isŸD** always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  TheŸ-** IsHiddenColumn() macro is general purpose.¢*/Ÿ)#if defined(SQLITE_ENABLE_HIDDEN_COLUMNS)ŸI#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)ŸI#  define IsOrdinaryHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)Ÿ(#elif !defined(SQLITE_OMIT_VIRTUALTABLE)ŸI#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)Ÿ%#  define IsOrdinaryHiddenColumn(X) 0•#elseŸ%#  define IsHiddenColumn(X)         0Ÿ%#  define IsOrdinaryHiddenColumn(X) 0¶#endif††Ÿ!/* Does the table have a rowid */Ÿ>#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)Ÿ@#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0)†¢/*ŸI** Each foreign key constraint is an instance of the following structure.¢**ŸD** A foreign key is associated with two tables.  The "from" table isŸI** the table that contains the REFERENCES clause that creates the foreignŸL** key.  The "to" table is the table that is named in the REFERENCES clause.π** Consider this example:¢**∏**     CREATE TABLE ex1(ø**       a INTEGER PRIMARY KEY,Ÿ3**       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)©**     );¢**ŸL** For foreign key "fk1", the from-table is "ex1" and the to-table is "ex2".¥** Equivalent names:¢**Ÿ **     from-table == child-tableŸ!**       to-table == parent-table¢**ŸJ** Each REFERENCES clause generates an instance of the following structureŸI** which is attached to the from-table.  The to-table need not exist whenŸL** the from-table is created.  The existence of the to-table is not checked.¢**Ÿ@** The list of all parents for child Table X is held at X.pFKey.¢**ŸJ** A list of all children for a table named Z (which might not even exist)Ÿ3** is held in Schema.fkeyHash with a hash key of Z.¢*/≠struct FKey {ŸM  Table *pFrom;     /* Table containing the REFERENCES clause (aka: Child) */ŸP  FKey *pNextFrom;  /* Next FKey with the same in pFrom. Next parent of pFrom */ŸL  char *zTo;        /* Name of table that the key points to (aka: Parent) */ŸD  FKey *pNextTo;    /* Next with the same zTo. Next child of zTo. */Ÿ4  FKey *pPrevTo;    /* Previous with the same zTo */Ÿ7  int nCol;         /* Number of columns in this key */π  /* EV: R-30323-21917 */ŸP  u8 isDeferred;       /* True if constraint checking is deferred till COMMIT */ŸK  u8 aAction[2];        /* ON DELETE and ON UPDATE actions, respectively */Ÿ<  Trigger *apTrigger[2];/* Triggers for aAction[] actions */ŸK  struct sColMap {      /* Mapping of columns in pFrom to columns in zTo */Ÿ8    int iFrom;            /* Index of column in pFrom */ŸO    char *zCol;           /* Name of column in zTo.  If NULL use PRIMARY KEY */Ÿ@  } aCol[1];            /* One entry for each of nCol columns */¢};†¢/*Ÿ>** SQLite supports many different ways to resolve a constraintŸ@** error.  ROLLBACK processing means that a constraint violationŸJ** causes the operation in process to fail and for the current transactionŸF** to be rolled back.  ABORT processing means the operation in processŸF** fails and any prior changes from that one operation are backed out,ŸF** but the transaction is not rolled back.  FAIL processing means thatŸH** the operation in progress stops and returns an error code.  But priorŸG** changes due to the same operation are not backed out and no rollbackŸK** occurs.  IGNORE means that the particular row that caused the constraintŸG** error is not inserted or updated.  Processing continues and no errorŸI** is returned.  REPLACE means that preexisting database rows that causedŸF** a UNIQUE constraint violation are removed so that the new insert orŸF** update can proceed.  Processing continues and no error is reported.¢**ŸE** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.ŸC** RESTRICT is the same as ABORT for IMMEDIATE foreign keys and theŸF** same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreignŸD** key is set to NULL.  CASCADE means that a DELETE or UPDATE of theŸA** referenced table row is propagated into the row that holds theØ** foreign key.¢**Ÿ>** The following symbolic values are used to record which typeµ** of action to take.¢*/Ÿ=#define OE_None     0   /* There is no constraint to check */ŸM#define OE_Rollback 1   /* Fail the operation and rollback the transaction */ŸM#define OE_Abort    2   /* Back out changes but do no rollback transaction */ŸL#define OE_Fail     3   /* Stop the operation but leave all prior changes */ŸN#define OE_Ignore   4   /* Ignore the error. Do not do the INSERT or UPDATE */ŸN#define OE_Replace  5   /* Delete existing record, then do INSERT or UPDATE */†ŸN#define OE_Restrict 6   /* OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED */Ÿ?#define OE_SetNull  7   /* Set the foreign key value to NULL */ŸF#define OE_SetDflt  8   /* Set the foreign key value to its default */Ÿ1#define OE_Cascade  9   /* Cascade the changes */†Ÿ?#define OE_Default  10  /* Do whatever the default action is */††¢/*Ÿ@** An instance of the following structure is passed as the firstŸ?** argument to sqlite3VdbeKeyCompare and is used to control theŸ$** comparison of the two index keys.¢**ŸA** Note that aSortOrder[] and aColl[] have nField+1 slots.  ThereŸC** are nField slots for the columns of an index then one extra slotº** for the rowid at the end.¢*/∞struct KeyInfo {ŸG  u32 nRef;           /* Number of references to this KeyInfo object */ŸI  u8 enc;             /* Text encoding - one of the SQLITE_UTF* values */Ÿ>  u16 nKeyField;      /* Number of key columns in the index */ŸD  u16 nAllField;      /* Total columns, including key plus others */Ÿ3  sqlite3 *db;        /* The database connection */Ÿ7  u8 *aSortOrder;     /* Sort order for each column. */ŸG  CollSeq *aColl[1];  /* Collating sequence for each term of the key */¢};†¢/*ŸG** This object holds a record which has been parsed out into individualŸ2** fields, for the purposes of doing a comparison.¢**ŸB** A record is an object that contains one or more fields of data.ŸD** Records are used to store the content of a table row and to storeŸB** the key of an index.  A blob encoding of a record is created byŸB** the OP_MakeRecord opcode of the VDBE and is disassembled by the¥** OP_Column opcode.¢**ŸE** An instance of this object serves as a "key" for doing a search onŸD** an index b+tree. The goal of the search is to find the entry thatŸI** is closed to the key described by this object.  This object might holdŸ>** just a prefix of the key.  The number of fields is given by¥** pKeyInfo->nField.¢**ŸI** The r1 and r2 fields are the values to return if this key is less thanŸH** or greater than a key in the btree, respectively.  These are normallyŸK** -1 and +1 respectively, but might be inverted to +1 and -1 if the b-tree¥** is in DESC order.¢**ŸI** The key comparison functions actually return default_rc when they findŸG** an equals comparison.  default_rc can be -1, 0, or +1.  If there areŸF** multiple entries in the b-tree with the same key (when only lookingŸG** at the first pKeyInfo->nFields,) then default_rc can be set to -1 toŸH** cause the search to find the last match, or +1 to cause the search to∏** find the first match.¢**ŸD** The key comparison functions will set eqSeen to true if they everŸJ** get and equal results when comparing this structure to a b-tree record.ŸH** When default_rc!=0, the search might end up on the record immediatelyŸC** before the first match or immediately after the last match.  TheŸI** eqSeen field will indicate whether or not an exact match exists in the™** b-tree.¢*/∑struct UnpackedRecord {Ÿ@  KeyInfo *pKeyInfo;  /* Collation and sort-order information */Ÿ"  Mem *aMem;          /* Values */Ÿ8  u16 nField;         /* Number of entries in apMem[] */Ÿ?  i8 default_rc;      /* Comparison result if keys are equal */ŸO  u8 errCode;         /* Error detected by xRecordCompare (CORRUPT or NOMEM) */Ÿ:  i8 r1;              /* Value to return if (lhs < rhs) */Ÿ:  i8 r2;              /* Value to return if (lhs > rhs) */ŸH  u8 eqSeen;          /* True if an equality comparison has been seen */¢};††¢/*Ÿ0** Each SQL index is represented in memory by anŸ'** instance of the following structure.¢**Ÿ@** The columns of the table that are to be indexed are describedŸC** by the aiColumn[] field of this structure.  For example, supposeŸ)** we have the following table and index:¢**Ÿ1**     CREATE TABLE Ex1(c1 int, c2 int, c3 text);Ÿ&**     CREATE INDEX Ex2 ON Ex1(c3,c1);¢**ŸC** In the Table structure describing Ex1, nCol==3 because there areŸA** three columns in the table.  In the Index structure describingŸ?** Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed.Ÿ?** The value of aiColumn is {2, 0}.  aiColumn[0]==2 because theŸC** first column to be indexed (c3) has an index of 2 in Ex1.aCol[].Ÿ<** The second column to be indexed (c1) has an index of 0 inŸ(** Ex1.aCol[], hence Ex2.aiColumn[1]==0.¢**ŸH** The Index.onError field determines whether or not the indexed columnsŸN** must be unique and what to do if they are not.  When Index.onError=OE_None,ŸG** it means this is not a unique index.  Otherwise it is a unique indexŸH** and the value of Index.onError indicate the which conflict resolutionŸI** algorithm to employ whenever an attempt is made to insert a non-unique´** element.¢**ŸE** While parsing a CREATE TABLE or CREATE INDEX statement in order toŸK** generate VDBE code (as opposed to parsing one read from an sqlite_masterŸM** table as part of parsing an existing database schema), transient instancesŸL** of this structure may be created. In this case the Index.tnum variable isŸG** used to store the address of a VDBE instruction, not a database pageŸH** number (it cannot - the database page is not allocated until the VDBEŸF** program is executed). See convertToWithoutRowidTable() for details.¢*/Æstruct Index {Ÿ3  char *zName;             /* Name of this index */ŸP  i16 *aiColumn;           /* Which columns are used by this index.  1st is 0 */ŸP  LogEst *aiRowLogEst;     /* From ANALYZE: Est. rows selected by each column */Ÿ<  Table *pTable;           /* The SQL table being indexed */ŸL  char *zColAff;           /* String defining the affinity of each column */ŸN  Index *pNext;            /* The next index associated with the same table */Ÿ=  Schema *pSchema;         /* Schema containing this index */ŸH  u8 *aSortOrder;          /* for each column: True==DESC, False==ASC */ŸL  const char **azColl;     /* Array of collation sequence names for index */ŸA  Expr *pPartIdxWhere;     /* WHERE clause for partial indices */Ÿ3  ExprList *aColExpr;      /* Column expressions */ŸF  int tnum;                /* DB Page containing root of this index */ŸD  LogEst szIdxRow;         /* Estimated average row size in bytes */ŸB  u16 nKeyCol;             /* Number of columns forming the key */ŸF  u16 nColumn;             /* Number of columns stored in the index */ŸL  u8 onError;              /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */ŸK  unsigned idxType:2;      /* 1==UNIQUE, 2==PRIMARY KEY, 0==CREATE INDEX */ŸI  unsigned bUnordered:1;   /* Use this index for == or IN queries only */ŸL  unsigned uniqNotNull:1;  /* True if UNIQUE and NOT NULL for all columns */ŸL  unsigned isResized:1;    /* True if resizeIndexObject() has been called */ŸA  unsigned isCovering:1;   /* True if this is a covering index */ŸD  unsigned noSkipScan:1;   /* Do not try to use skip-scan if true */ŸJ  unsigned hasStat1:1;     /* aiRowLogEst values come from sqlite_stat1 */ŸJ  unsigned bNoQuery:1;     /* Do not use this index to optimize queries */Ÿ##ifdef SQLITE_ENABLE_STAT3_OR_STAT4Ÿ@  int nSample;             /* Number of elements in aSample[] */ŸE  int nSampleCol;          /* Size of IndexSample.anEq[] and so on */ŸK  tRowcnt *aAvgEq;         /* Average nEq values for keys not in aSample */Ÿ=  IndexSample *aSample;    /* Samples of the left-most key */ŸJ  tRowcnt *aiRowEst;       /* Non-logarithmic stat1 data for this index */ŸL  tRowcnt nRowEst0;        /* Non-logarithmic number of rows in the index */¶#endif¢};†¢/*Ÿ#** Allowed values for Index.idxType¢*/ŸG#define SQLITE_IDXTYPE_APPDEF      0   /* Created using CREATE INDEX */ŸK#define SQLITE_IDXTYPE_UNIQUE      1   /* Implements a UNIQUE constraint */ŸM#define SQLITE_IDXTYPE_PRIMARYKEY  2   /* Is the PRIMARY KEY for the table */†Ÿ3/* Return true if index X is a PRIMARY KEY index */ŸG#define IsPrimaryKeyIndex(X)  ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY)†Ÿ./* Return true if index X is a UNIQUE index */Ÿ5#define IsUniqueIndex(X)      ((X)->onError!=OE_None)†ŸB/* The Index.aiColumn[] values are normally positive integer.  ButŸ<** there are some negative values that have special meaning:¢*/Ÿ?#define XN_ROWID     (-1)     /* Indexed column is the rowid */ŸC#define XN_EXPR      (-2)     /* Indexed column is an expression */†¢/*ŸH** Each sample stored in the sqlite_stat3 table is represented in memoryŸG** using a structure of this type.  See documentation at the top of theŸ4** analyze.c source file for additional information.¢*/¥struct IndexSample {Ÿ3  void *p;          /* Pointer to sampled record */Ÿ1  int n;            /* Size of record in bytes */ŸN  tRowcnt *anEq;    /* Est. number of rows where the key equals this sample */ŸP  tRowcnt *anLt;    /* Est. number of rows where key is less than this sample */ŸL  tRowcnt *anDLt;   /* Est. number of distinct keys less than this sample */¢};†¢/*Ÿ7** Each token coming out of the lexer is an instance ofŸB** this structure.  Tokens are also used as part of an expression.¢**ŸB** Note if Token.z==0 then Token.dyn and Token.n are undefined andŸJ** may contain random values.  Do not make any assumptions about Token.dynø** and Token.n when Token.z==0.¢*/Æstruct Token {ŸC  const char *z;     /* Text of the token.  Not NULL-terminated! */Ÿ=  unsigned int n;    /* Number of characters in this token */¢};†¢/*ŸH** An instance of this structure contains information needed to generateŸ7** code for a SELECT that contains aggregate functions.¢**ŸG** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is aŸE** pointer to this structure.  The Expr.iColumn field is the index inŸF** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate∂** code for that node.¢**ŸF** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within theŸH** original Select structure that describes the SELECT statement.  TheseŸJ** fields do not need to be freed when deallocating the AggInfo structure.¢*/∞struct AggInfo {ŸK  u8 directMode;          /* Direct rendering mode means take data directlyŸP                          ** from source tables rather than from accumulators */ŸO  u8 useSortingIdx;       /* In direct mode, reference the sorting index ratherŸ5                          ** than the source table */ŸB  int sortingIdx;         /* Cursor number of the sorting index */Ÿ=  int sortingIdxPTab;     /* Cursor number of pseudo-table */ŸF  int nSortingColumn;     /* Number of columns in the sorting index */ŸO  int mnReg, mxReg;       /* Range of registers allocated for aCol and aFunc */Ÿ3  ExprList *pGroupBy;     /* The group by clause */ŸE  struct AggInfo_col {    /* For each column used in source tables */Ÿ/    Table *pTab;             /* Source table */ŸD    int iTable;              /* Cursor number of the source table */ŸH    int iColumn;             /* Column number within the source table */ŸE    int iSorterColumn;       /* Column number in the sorting index */ŸK    int iMem;                /* Memory location that acts as accumulator */Ÿ:    Expr *pExpr;             /* The original expression */™  } *aCol;Ÿ@  int nColumn;            /* Number of used entries in aCol[] */ŸO  int nAccumulator;       /* Number of columns that show through to the output.ŸN                          ** Additional columns are used only as parameters toŸ3                          ** aggregate functions */Ÿ;  struct AggInfo_func {   /* For each aggregate function */ŸC    Expr *pExpr;             /* Expression encoding the function */ŸH    FuncDef *pFunc;          /* The aggregate function implementation */ŸK    int iMem;                /* Memory location that acts as accumulator */ŸK    int iDistinct;           /* Ephemeral table used to enforce DISTINCT */´  } *aFunc;Ÿ<  int nFunc;              /* Number of entries in aFunc[] */¢};†¢/*ŸC** The datatype ynVar is a signed integer, either 16-bit or 32-bit.ŸG** Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greaterŸE** than 32767 we have to make it 32-bit.  16-bit is preferred becauseŸE** it uses less memory in the Expr object, which is a big memory userŸE** in systems with lots of prepared statements.  And few applicationsŸH** need more than about 10 or 20 variables.  But some extreme users wantŸF** to have prepared statements with over 32767 variables, and for themŸ-** the option is available (at compile-time).¢*/Ÿ%#if SQLITE_MAX_VARIABLE_NUMBER<=32767≤typedef i16 ynVar;•#else≤typedef int ynVar;¶#endif†¢/*Ÿ>** Each node of an expression in the parse tree is an instanceµ** of this structure.¢**ŸC** Expr.op is the opcode. The integer parser token codes are reusedŸJ** as opcodes here. For example, the parser defines TK_GE to be an integerŸH** code representing the ">=" operator. This same integer code is reusedŸG** to represent the greater-than-or-equal-to operator in the expression®** tree.¢**ŸF** If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB,ŸJ** or TK_STRING), then Expr.token contains the text of the SQL literal. IfŸK** the expression is a variable (TK_VARIABLE), then Expr.token contains theŸN** variable name. Finally, if the expression is an SQL function (TK_FUNCTION),Ÿ5** then Expr.token contains the name of the function.¢**ŸH** Expr.pRight and Expr.pLeft are the left and right subexpressions of aŸ/** binary operator. Either or both may be NULL.¢**ŸL** Expr.x.pList is a list of arguments if the expression is an SQL function,ŸN** a CASE expression or an IN expression of the form "<lhs> IN (<y>, <z>...)".ŸO** Expr.x.pSelect is used if the expression is a sub-select or an expression ofŸJ** the form "<lhs> IN (SELECT ...)". If the EP_xIsSelect bit is set in theŸL** Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is©** valid.¢**ŸG** An expression of the form ID or ID.ID refers to a column in a table.ŸG** For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable isŸH** the integer cursor number of a VDBE cursor pointing to that table andŸE** Expr.iColumn is the column number for the specific column.  If theŸB** expression is used as a result in an aggregate SELECT, then theŸH** value is also stored in the Expr.iAgg column in the aggregate so thatŸ8** it can be accessed after all aggregates are computed.¢**ŸC** If the expression is an unbound variable marker (a question markŸJ** character '?' in the original SQL) then the Expr.iTable holds the indexº** number for that variable.¢**ŸE** If the expression is a subquery then Expr.iColumn holds an integerŸA** register number containing the result of the subquery.  If theŸH** subquery gives a constant result, then iTable is -1.  If the subqueryŸJ** gives a different answer at different times during statement processingŸI** then iTable is the address of a subroutine that computes the subquery.¢**ŸG** If the Expr is of type OP_Column, and the table it is selecting fromŸG** is a disk table or the "old.*" pseudo-table, then pTab points to theŸ"** corresponding table definition.¢**¥** ALLOCATION NOTES:¢**ŸE** Expr objects can use a lot of memory space in database schema.  ToŸD** help reduce memory requirements, sometimes an Expr object will beŸH** truncated.  And to reduce the number of memory allocations, sometimesŸI** two or more Expr objects will be stored in a single memory allocation,Ÿ%** together with Expr.zToken strings.¢**Ÿ8** If the EP_Reduced and EP_TokenOnly flags are set whenŸA** an Expr object is truncated.  When EP_Reduced is set, then allŸD** the child Expr objects in the Expr.pLeft and Expr.pRight subtreesŸH** are contained within the same memory allocation.  Note, however, thatŸG** the subtrees in Expr.x.pList or Expr.x.pSelect are always separatelyŸ=** allocated, regardless of whether or not EP_Reduced is set.¢*/≠struct Expr {Ÿ?  u8 op;                 /* Operation performed by this node */ŸN  char affinity;         /* The affinity of the column or 0 if not a column */Ÿ=  u32 flags;             /* Various flags.  EP_* See below */©  union {ŸJ    char *zToken;          /* Token value. Zero terminated and dequoted */ŸJ    int iValue;            /* Non-negative integer value if EP_IntValue */¶  } u;†ŸD  /* If the EP_TokenOnly flag is set in the Expr.flags mask, then noŸF  ** space is allocated for the fields below this point. An attempt toŸ:  ** access them will result in a segfault or malfunction.ŸH  *********************************************************************/†Ÿ+  Expr *pLeft;           /* Left subnode */Ÿ,  Expr *pRight;          /* Right subnode */©  union {ŸO    ExprList *pList;     /* op = IN, EXISTS, SELECT, CASE, FUNCTION, BETWEEN */ŸG    Select *pSelect;     /* EP_xIsSelect and op = IN, EXISTS, SELECT */¶  } x;†ŸB  /* If the EP_Reduced flag is set in the Expr.flags mask, then noŸF  ** space is allocated for the fields below this point. An attempt toŸ:  ** access them will result in a segfault or malfunction.ŸH  *********************************************************************/†ª#if SQLITE_MAX_EXPR_DEPTH>0ŸE  int nHeight;           /* Height of the tree headed by this node */¶#endifŸL  int iTable;            /* TK_COLUMN: cursor number of table holding columnŸ8                         ** TK_REGISTER: register numberŸ:                         ** TK_TRIGGER: 1 -> new, 0 -> oldŸD                         ** EP_Unlikely:  134217728 times likelihoodŸG                         ** TK_SELECT: 1st register of result vector */ŸC  ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.ŸG                         ** TK_VARIABLE: variable number (always >= 1).ŸL                         ** TK_SELECT_COLUMN: column of the result vector */ŸK  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */ŸJ  i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */ŸB  u8 op2;                /* TK_REGISTER: original value of Expr.opŸD                         ** TK_COLUMN: the value of p5 for OP_ColumnŸ=                         ** TK_AGG_FUNCTION: nesting depth */ŸH  AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */ŸI  Table *pTab;           /* Table for TK_COLUMN expressions.  Can be NULLŸH                         ** for a column of an index on an expression */¢};†¢/*ŸB** The following are the meanings of bits in the Expr.flags field.¢*/ŸO#define EP_FromJoin  0x000001 /* Originates in ON/USING clause of outer join */ŸL#define EP_Agg       0x000002 /* Contains one or more aggregate functions */ŸN#define EP_HasFunc   0x000004 /* Contains one or more functions of any kind */Ÿ5                  /* 0x000008 // available for use */ŸL#define EP_Distinct  0x000010 /* Aggregate function with DISTINCT keyword */ŸG#define EP_VarSelect 0x000020 /* pSelect is correlated, not constant */ŸC#define EP_DblQuoted 0x000040 /* token.z was originally in "..." */ŸO#define EP_InfixFunc 0x000080 /* True for an infix function: LIKE, GLOB, etc */ŸG#define EP_Collate   0x000100 /* Tree contains a TK_COLLATE operator */ŸK#define EP_Generic   0x000200 /* Ignore COLLATE or affinity on this tree */ŸG#define EP_IntValue  0x000400 /* Integer value contained in u.iValue */ŸM#define EP_xIsSelect 0x000800 /* x.pSelect is valid (otherwise x.pList is) */Ÿ<#define EP_Skip      0x001000 /* COLLATE, AS, or UNLIKELY */ŸK#define EP_Reduced   0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */ŸM#define EP_TokenOnly 0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */ŸM#define EP_Static    0x008000 /* Held in memory not obtained from malloc() */ŸG#define EP_MemToken  0x010000 /* Need to sqlite3DbFree() Expr.zToken */ŸC#define EP_NoReduce  0x020000 /* Cannot EXPRDUP_REDUCE this Expr */ŸG#define EP_Unlikely  0x040000 /* unlikely() or likelihood() function */ŸO#define EP_ConstFunc 0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */ŸK#define EP_CanBeNull 0x100000 /* Can be null despite NOT NULL constraint */ŸF#define EP_Subquery  0x200000 /* Tree contains a TK_SELECT operator */ŸG#define EP_Alias     0x400000 /* Is an alias for a result set column */ŸL#define EP_Leaf      0x800000 /* Expr.pLeft, .pRight, .u.pSelect all NULL */†¢/*ŸL** The EP_Propagate mask is a set of properties that automatically propagateΩ** upwards into parent nodes.¢*/Ÿ8#define EP_Propagate (EP_Collate|EP_Subquery|EP_HasFunc)†¢/*Ÿ>** These macros can be used to test, set, or clear bits in the¥** Expr.flags field.¢*/Ÿ6#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)Ÿ8#define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))Ÿ0#define ExprSetProperty(E,P)     (E)->flags|=(P)Ÿ1#define ExprClearProperty(E,P)   (E)->flags&=~(P)†ŸG/* The ExprSetVVAProperty() macro is used for Verification, Validation,ŸF** and Accreditation only.  It works like ExprSetProperty() during VVAŸ)** processes but is a no-op for delivery.¢*/≥#ifdef SQLITE_DEBUGŸ1# define ExprSetVVAProperty(E,P)  (E)->flags|=(P)•#elseŸ # define ExprSetVVAProperty(E,P)¶#endif†¢/*ŸD** Macros to determine the number of bytes required by a normal ExprŸD** struct, an Expr struct with the EP_Reduced flag set in Expr.flagsŸ5** and an Expr struct with the EP_TokenOnly flag set.¢*/ŸF#define EXPR_FULLSIZE           sizeof(Expr)           /* Full size */ŸL#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /* Common features */ŸK#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /* Fewer features */†¢/*ŸH** Flags passed to the sqlite3ExprDup() function. See the header commentŸ&** above sqlite3ExprDup() for details.¢*/ŸI#define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */†¢/*Ÿ@** A list of expressions.  Each expression may optionally have aŸD** name.  An expr/name combination can be used in several ways, suchŸD** as the list of "expr AS ID" fields following a "SELECT" or in theŸE** list of "ID = expr" items in an UPDATE.  A list of expressions canŸH** also be used as the argument to a function, in which case the a.zNameµ** field is not used.¢**ŸH** By default the Expr.zSpan field holds a human-readable description ofŸF** the expression that is used in the generation of error messages andŸF** column labels.  In this case, Expr.zSpan is typically the text of aŸE** column expression as it exists in a SELECT statement.  However, ifŸH** the bSpanIsTab flag is set, then zSpan is overloaded to mean the nameŸG** of the result column in the form: DATABASE.TABLE.COLUMN.  This laterŸ=** form is used for name resolution with nested FROM clauses.¢*/±struct ExprList {Ÿ@  int nExpr;             /* Number of expressions on the list */Ÿ>  struct ExprList_item { /* For each expression in the list */ŸD    Expr *pExpr;            /* The parse tree for this expression */ŸG    char *zName;            /* Token associated with this expression */ŸA    char *zSpan;            /* Original text of the expression */Ÿ9    u8 sortOrder;           /* 1 for DESC or 0 for ASC */ŸP    unsigned done :1;       /* A flag to indicate when processing is finished */Ÿ=    unsigned bSpanIsTab :1; /* zSpan holds DB.TABLE.COLUMN */ŸA    unsigned reusable :1;   /* Constant expression is reusable */´    union {Æ      struct {ŸM        u16 iOrderByCol;      /* For ORDER BY, column number in result set */ŸG        u16 iAlias;           /* Index into Parse.aAlias[] for zName */™      } x;ŸJ      int iConstExprReg;      /* Register in which Expr value is cached */®    } u;ŸI  } a[1];                  /* One slot for each expression in the list */¢};†¢/*ŸG** An instance of this structure can hold a simple list of identifiers,Ÿ8** such as the list "a,b,c" in the following statements:¢**Ÿ(**      INSERT INTO t(a,b,c) VALUES ...;Ÿ%**      CREATE INDEX idx ON t(a,b,c);Ÿ:**      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;¢**ŸH** The IdList.a.idx field is used when the IdList represents the list ofŸL** column names after a table name in an INSERT statement.  In the statement¢**ø**     INSERT INTO t(a,b,c) ...¢**ŸC** If "a" is the k-th column of table "t", then IdList.a[0].idx==k.¢*/Østruct IdList {∂  struct IdList_item {Ÿ2    char *zName;      /* Name of the identifier */ŸN    int idx;          /* Index in some Table.aCol[] of a column named zName */ß  } *a;Ÿ:  int nId;         /* Number of identifiers on the list */¢};†¢/*ŸH** The bitmask datatype defined below is used for various optimizations.¢**ŸD** Changing this from a 64-bit to a 32-bit type limits the number ofŸF** tables in a join to 32 instead of 64.  But it also reduces the sizeŸ'** of the library by 738 bytes on ix86.¢*/∫#ifdef SQLITE_BITMASK_TYPEŸ&  typedef SQLITE_BITMASK_TYPE Bitmask;•#else∂  typedef u64 Bitmask;¶#endif†¢/*Ÿ@** The number of bits in a Bitmask.  "BMS" means "BitMask Size".¢*/Ÿ'#define BMS  ((int)(sizeof(Bitmask)*8))†¢/*µ** A bit in a Bitmask¢*/Ÿ(#define MASKBIT(n)   (((Bitmask)1)<<(n))Ÿ-#define MASKBIT32(n) (((unsigned int)1)<<(n))Ÿ"#define ALLBITS      ((Bitmask)-1)†¢/*ŸK** The following structure describes the FROM clause of a SELECT statement.ŸE** Each table or subquery in the FROM clause is a separate element ofπ** the SrcList.a[] array.¢**ŸJ** With the addition of multiple database support, the following structureŸI** can also be used to describe a particular table such as the table thatŸK** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,ŸH** such a table must be a simple name: ID.  But in SQLite, the table canŸK** now be identified by a database name, a dot, then the table name: ID.ID.¢**ŸJ** The jointype starts out showing the join type between the current tableŸH** and the next table on the list.  The parser builds the list this way.ŸL** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that eachŸH** jointype expresses the join between the table and the previous table.¢**ŸH** In the colUsed field, the high-order bit (bit 63) is set if the tableŸG** contains more than 63 columns and the 64-th or later column is used.¢*/∞struct SrcList {ŸJ  int nSrc;        /* Number of tables or subqueries in the FROM clause */ŸA  u32 nAlloc;      /* Number of entries allocated in a[] below */∑  struct SrcList_item {Ÿ>    Schema *pSchema;  /* Schema to which this item is fixed */Ÿ?    char *zDatabase;  /* Name of database holding this table */Ÿ-    char *zName;      /* Name of the table */ŸP    char *zAlias;     /* The "B" part of a "A AS B" phrase.  zName is the "A" */Ÿ?    Table *pTab;      /* An SQL table corresponding to zName */ŸL    Select *pSelect;  /* A SELECT statement used in place of a table name */ŸH    int addrFillSub;  /* Address of subroutine to manifest a subquery */ŸJ    int regReturn;    /* Register holding return address of addrFillSub */ŸE    int regResult;    /* Registers holding results of a co-routine */¨    struct {ŸN      u8 jointype;      /* Type of join between this table and the previous */ŸL      unsigned notIndexed :1;    /* True if there is a NOT INDEXED clause */ŸL      unsigned isIndexedBy :1;   /* True if there is an INDEXED BY clause */ŸK      unsigned isTabFunc :1;     /* True if table-valued-function syntax */ŸF      unsigned isCorrelated :1;  /* True if sub-query is correlated */ŸB      unsigned viaCoroutine :1;  /* Implemented as a co-routine */ŸK      unsigned isRecursive :1;   /* True for recursive reference in WITH */©    } fg;ª#ifndef SQLITE_OMIT_EXPLAINŸJ    u8 iSelectId;     /* If pSelect!=0, the id of the sub-select in EQP */¶#endifŸL    int iCursor;      /* The VDBE cursor number used to access this table */Ÿ3    Expr *pOn;        /* The ON clause of a join */Ÿ6    IdList *pUsing;   /* The USING clause of a join */ŸH    Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */´    union {ŸM      char *zIndexedBy;    /* Identifier from "INDEXED BY <zIndex>" clause */ŸC      ExprList *pFuncArg;  /* Arguments to table-valued-function */©    } u1;ŸJ    Index *pIBIndex;  /* Index structure corresponding to u1.zIndexedBy */ŸE  } a[1];             /* One entry for each identifier on the list */¢};†¢/*Ÿ3** Permitted values of the SrcList.a.jointype field¢*/ŸD#define JT_INNER     0x0001    /* Any kind of inner or cross join */ŸF#define JT_CROSS     0x0002    /* Explicit use of the CROSS keyword */Ÿ>#define JT_NATURAL   0x0004    /* True for a "natural" join */Ÿ4#define JT_LEFT      0x0008    /* Left outer join */Ÿ5#define JT_RIGHT     0x0010    /* Right outer join */ŸC#define JT_OUTER     0x0020    /* The "OUTER" keyword is present */ŸE#define JT_ERROR     0x0040    /* unknown or unsupported join type */††¢/*ŸH** Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()Ÿ'** and the WhereInfo.wctrlFlags member.¢**Ÿ-** Value constraints (enforced via assert()):Ÿ(**     WHERE_USE_LIMIT  == SF_FixedLimit¢*/Ÿ1#define WHERE_ORDERBY_NORMAL   0x0000 /* No-op */ŸN#define WHERE_ORDERBY_MIN      0x0001 /* ORDER BY processing for min() func */ŸN#define WHERE_ORDERBY_MAX      0x0002 /* ORDER BY processing for max() func */ŸM#define WHERE_ONEPASS_DESIRED  0x0004 /* Want to do one-pass UPDATE/DELETE */ŸL#define WHERE_ONEPASS_MULTIROW 0x0008 /* ONEPASS is ok with multiple rows */ŸM#define WHERE_DUPLICATES_OK    0x0010 /* Ok to return a row more than once */ŸJ#define WHERE_OR_SUBCLAUSE     0x0020 /* Processing a sub-WHERE as part ofŸ@                                      ** the OR optimization  */ŸI#define WHERE_GROUPBY          0x0040 /* pOrderBy is really a GROUP BY */ŸP#define WHERE_DISTINCTBY       0x0080 /* pOrderby is really a DISTINCT clause */ŸK#define WHERE_WANT_DISTINCT    0x0100 /* All output needs to be distinct */ŸJ#define WHERE_SORTBYGROUP      0x0200 /* Support sqlite3WhereIsSorted() */ŸL#define WHERE_SEEK_TABLE       0x0400 /* Do not defer seeks on main table */ŸK#define WHERE_ORDERBY_LIMIT    0x0800 /* ORDERBY+LIMIT on the inner loop */ŸH#define WHERE_SEEK_UNIQ_TABLE  0x1000 /* Do not defer seeks if unique */Ÿ>                        /*     0x2000    not currently used */ŸK#define WHERE_USE_LIMIT        0x4000 /* Use the LIMIT in cost estimates */Ÿ>                        /*     0x8000    not currently used */†Ÿ6/* Allowed return values from sqlite3WhereIsDistinct()¢*/ŸC#define WHERE_DISTINCT_NOOP      0  /* DISTINCT keyword not used */Ÿ7#define WHERE_DISTINCT_UNIQUE    1  /* No duplicates */ŸE#define WHERE_DISTINCT_ORDERED   2  /* All duplicates are adjacent */ŸB#define WHERE_DISTINCT_UNORDERED 3  /* Duplicates are scattered */†¢/*ŸG** A NameContext defines a context in which to resolve table and columnŸL** names.  The context consists of a list of tables (the pSrcList) field andŸF** a list of named expression (pEList).  The named expression list mayŸC** be NULL.  The pSrc corresponds to the FROM clause of a SELECT orŸD** to the table being operated on by INSERT, UPDATE, or DELETE.  TheŸC** pEList corresponds to the result set of a SELECT and is NULL for¥** other statements.¢**ŸD** NameContexts can be nested.  When resolving names, the inner-mostŸC** context is searched first.  If no match is found, the next outerŸD** context is checked.  If there is still no match, the next contextŸD** is checked.  This process continues until either a match is foundŸH** or all contexts are check.  When a match is found, the nRef member ofŸ3** the context containing the match is incremented.¢**ŸG** Each subquery gets a new NameContext.  The pNext field points to theŸE** NameContext in the parent query.  Thus the process of scanning theŸG** NameContext list corresponds to searching through successively outerŸ"** subqueries looking for a match.¢*/¥struct NameContext {Ÿ'  Parse *pParse;       /* The parser */ŸE  SrcList *pSrcList;   /* One or more tables used to resolve names */Ÿ@  ExprList *pEList;    /* Optional list of result-set columns */ŸG  AggInfo *pAggInfo;   /* Information about aggregates at this level */ŸI  NameContext *pNext;  /* Next outer name context.  NULL for outermost */ŸE  int nRef;            /* Number of names resolved by this context */ŸO  int nErr;            /* Number of errors encountered while resolving names */ŸB  u16 ncFlags;         /* Zero or more NC_* flags defined below */¢};†¢/*Ÿ5** Allowed values for the NameContext, ncFlags field.¢**Ÿ0** Value constraints (all checked via assert()):ø**    NC_HasAgg    == SF_HasAggŸ8**    NC_MinMaxAgg == SF_MinMaxAgg == SQLITE_FUNC_MINMAX¢**¢*/ŸG#define NC_AllowAgg  0x0001  /* Aggregate functions are allowed here */ŸJ#define NC_PartIdx   0x0002  /* True if resolving a partial index WHERE */ŸP#define NC_IsCheck   0x0004  /* True if resolving names in a CHECK constraint */ŸM#define NC_InAggFunc 0x0008  /* True if analyzing arguments to an agg func */ŸG#define NC_HasAgg    0x0010  /* One or more aggregate functions seen */ŸL#define NC_IdxExpr   0x0020  /* True if resolving columns of CREATE INDEX */ŸF#define NC_VarSelect 0x0040  /* A correlated subquery has been seen */ŸK#define NC_MinMaxAgg 0x1000  /* min/max aggregates seen.  See note above */ŸF#define NC_Complex   0x2000  /* True if a function or subquery seen */†¢/*ŸB** An instance of the following structure contains all informationŸ9** needed to generate code for a single SELECT statement.¢**ŸI** nLimit is set to -1 if there is no LIMIT clause.  nOffset is set to 0.ŸI** If there is a LIMIT clause, the parser sets nLimit to the value of theŸE** limit and nOffset to the value of the offset (or 0 if there is notŸI** offset).  But later on, nLimit and nOffset become the memory locationsŸ9** in the VDBE that record the limit and offset counters.¢**ŸJ** addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.ŸD** These addresses must be stored so that we can go back and fill inŸC** the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo norŸ?** the number of columns in P2 can be computed at the same timeŸ6** as the OP_OpenEphm instruction is coded because notŸF** enough information about the compound query is known at that point.ŸG** The KeyInfo for addrOpenTran[0] and [1] contains collating sequencesŸJ** for the result set.  The KeyInfo for addrOpenEphm[2] contains collatingŸ%** sequences for the ORDER BY clause.¢*/Østruct Select {Ÿ7  ExprList *pEList;      /* The fields of the result */ŸM  u8 op;                 /* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT */Ÿ>  LogEst nSelectRow;     /* Estimated number of result rows */Ÿ2  u32 selFlags;          /* Various SF_* values */ŸO  int iLimit, iOffset;   /* Memory registers holding LIMIT & OFFSET counters */∑#if SELECTTRACE_ENABLEDŸM  char zSelName[12];     /* Symbolic name of this SELECT use for debugging */¶#endifŸJ  int addrOpenEphm[2];   /* OP_OpenEphem opcodes related to this select */Ÿ.  SrcList *pSrc;         /* The FROM clause */Ÿ/  Expr *pWhere;          /* The WHERE clause */Ÿ2  ExprList *pGroupBy;    /* The GROUP BY clause */Ÿ0  Expr *pHaving;         /* The HAVING clause */Ÿ2  ExprList *pOrderBy;    /* The ORDER BY clause */ŸJ  Select *pPrior;        /* Prior select in a compound select statement */ŸD  Select *pNext;         /* Next select to the left in a compound */ŸE  Expr *pLimit;          /* LIMIT expression. NULL means not used. */ŸL  With *pWith;           /* WITH clause attached to this select. Or NULL. */¢};†¢/*ŸB** Allowed values for Select.selFlags.  The "SF" prefix stands for±** "Select Flag".¢**Ÿ/** Value constraints (all checked via assert())Ÿ!**     SF_HasAgg     == NC_HasAggŸ>**     SF_MinMaxAgg  == NC_MinMaxAgg     == SQLITE_FUNC_MINMAXŸ'**     SF_FixedLimit == WHERE_USE_LIMIT¢*/ŸB#define SF_Distinct       0x00001  /* Output should be DISTINCT */ŸA#define SF_All            0x00002  /* Includes the ALL keyword */ŸG#define SF_Resolved       0x00004  /* Identifiers have been resolved */ŸM#define SF_Aggregate      0x00008  /* Contains agg functions or a GROUP BY */ŸE#define SF_HasAgg         0x00010  /* Contains aggregate functions */ŸF#define SF_UsesEphemeral  0x00020  /* Uses the OpenEphemeral opcode */ŸM#define SF_Expanded       0x00040  /* sqlite3SelectExpand() called on this */ŸL#define SF_HasTypeInfo    0x00080  /* FROM subqueries have Table metadata */ŸA#define SF_Compound       0x00100  /* Part of a compound query */ŸG#define SF_Values         0x00200  /* Synthesized from VALUES clause */ŸN#define SF_MultiValue     0x00400  /* Single VALUES term with multiple rows */ŸL#define SF_NestedFrom     0x00800  /* Part of a parenthesized FROM clause */ŸL#define SF_MinMaxAgg      0x01000  /* Aggregate containing min() or max() */ŸN#define SF_Recursive      0x02000  /* The recursive part of a recursive CTE */ŸK#define SF_FixedLimit     0x04000  /* nSelectRow set by a constant LIMIT */ŸO#define SF_MaybeConvert   0x08000  /* Need convertCompoundSelectToSubquery() */ŸM#define SF_Converted      0x10000  /* By convertCompoundSelectToSubquery() */ŸI#define SF_IncludeHidden  0x20000  /* Include hidden columns in output */ŸQ#define SF_ComplexResult  0x40000  /* Result set contains subquery or function */††¢/*ŸI** The results of a SELECT can be distributed in several ways, as definedŸI** by one of the following macros.  The "SRT" prefix means "SELECT Result©** Type".¢**ŸB**     SRT_Union       Store results as a key in a temporary indexŸ4**                     identified by pDest->iSDParm.¢**ŸN**     SRT_Except      Remove results from the temporary index pDest->iSDParm.¢**ŸL**     SRT_Exists      Store a 1 in memory cell pDest->iSDParm if the resultŸ(**                     set is not empty.¢**ŸF**     SRT_Discard     Throw the results away.  This is used by SELECTŸG**                     statements within triggers whose only purpose isŸ5**                     the side-effects of functions.¢**ŸH** All of the above are free to ignore their ORDER BY clause. Those thatŸ)** follow must honor the ORDER BY clause.¢**ŸG**     SRT_Output      Generate a row of output (using the OP_ResultRowŸ>**                     opcode) for each row in the result set.¢**ŸC**     SRT_Mem         Only valid if the result is a single column.ŸE**                     Store the first column of the first result rowŸG**                     in register pDest->iSDParm then abandon the restŸI**                     of the query.  This destination implies "LIMIT 1".¢**ŸF**     SRT_Set         The result must be a single column.  Store eachŸH**                     row of result as the key in table pDest->iSDParm.ŸG**                     Apply the affinity pDest->affSdst before storingŸE**                     results.  Used to implement "IN (SELECT ...)".¢**ŸI**     SRT_EphemTab    Create an temporary table pDest->iSDParm and storeŸF**                     the result there. The cursor is left open afterŸE**                     returning.  This is like SRT_Table except thatŸG**                     this destination uses OP_OpenEphemeral to createŸ'**                     the table first.¢**ŸF**     SRT_Coroutine   Generate a co-routine that returns a new row ofŸH**                     results each time it is invoked.  The entry pointŸM**                     of the co-routine is stored in register pDest->iSDParmŸM**                     and the result row is stored in pDest->nDest registersŸ2**                     starting with pDest->iSdst.¢**ŸG**     SRT_Table       Store results in temporary table pDest->iSDParm.ŸF**     SRT_Fifo        This is like SRT_EphemTab except that the tableŸC**                     is assumed to already be open.  SRT_Fifo hasŸF**                     the additional property of being able to ignoreŸ+**                     the ORDER BY clause.¢**ŸI**     SRT_DistFifo    Store results in a temporary table pDest->iSDParm.ŸG**                     But also use temporary table pDest->iSDParm+1 asŸM**                     a record of all prior results and ignore any duplicateŸ;**                     rows.  Name means:  "Distinct Fifo".¢**ŸM**     SRT_Queue       Store results in priority queue pDest->iSDParm (reallyŸO**                     an index).  Append a sequence number so that all entriesŸ$**                     are distinct.¢**ŸM**     SRT_DistQueue   Store results in priority queue pDest->iSDParm only ifŸI**                     the same record has never been stored before.  TheŸG**                     index at pDest->iSDParm+1 hold all prior stores.¢*/ŸB#define SRT_Union        1  /* Store result as keys in an index */ŸB#define SRT_Except       2  /* Remove result from a UNION index */ŸD#define SRT_Exists       3  /* Store 1 if the result is not empty */ŸB#define SRT_Discard      4  /* Do not save the results anywhere */ŸN#define SRT_Fifo         5  /* Store result as data with an automatic rowid */ŸH#define SRT_DistFifo     6  /* Like SRT_Fifo, but unique results only */Ÿ:#define SRT_Queue        7  /* Store result in an queue */ŸI#define SRT_DistQueue    8  /* Like SRT_Queue, but unique results only */†Ÿ9/* The ORDER BY clause is ignored for all of the above */Ÿ7#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue)†Ÿ;#define SRT_Output       9  /* Output each row of result */Ÿ?#define SRT_Mem         10  /* Store result in a memory cell */ŸC#define SRT_Set         11  /* Store results as keys in an index */ŸO#define SRT_EphemTab    12  /* Create transient tab and store like SRT_Table */ŸA#define SRT_Coroutine   13  /* Generate a single row of result */ŸN#define SRT_Table       14  /* Store result as data with an automatic rowid */†¢/*ŸF** An instance of this object describes where to put of the results of∂** a SELECT statement.¢*/≥struct SelectDest {ŸO  u8 eDest;            /* How to dispose of the results.  On of SRT_* above. */ŸJ  int iSDParm;         /* A parameter used by the eDest disposal method */ŸD  int iSdst;           /* Base register where results are written */Ÿ:  int nSdst;           /* Number of registers allocated */Ÿ>  char *zAffSdst;      /* Affinity used when eDest==SRT_Set */ŸH  ExprList *pOrderBy;  /* Key columns for SRT_Queue and SRT_DistQueue */¢};†¢/*ŸJ** During code generation of statements that do inserts into AUTOINCREMENTŸI** tables, the following information is attached to the Table.u.autoInc.pŸK** pointer of each autoincrement table to record some side information thatŸE** the code generator needs.  We have to keep per-table autoincrementŸI** information in case inserts are done within triggers.  Triggers do notŸI** normally coordinate their activities, but we do need to coordinate theŸ3** loading and saving of autoincrement information.¢*/¥struct AutoincInfo {ŸC  AutoincInfo *pNext;   /* Next info block in a list of them all */Ÿ=  Table *pTab;          /* Table this info block refers to */ŸM  int iDb;              /* Index in sqlite3.aDb[] of database holding pTab */ŸG  int regCtr;           /* Memory register holding the rowid counter */¢};†¢/*ª** Size of the column cache¢*/π#ifndef SQLITE_N_COLCACHEΩ# define SQLITE_N_COLCACHE 10¶#endif†¢/*ŸG** At least one instance of the following structure is created for eachŸF** trigger that may be fired while parsing an INSERT, UPDATE or DELETEŸF** statement. All such objects are stored in the linked list headed atŸD** Parse.pTriggerPrg and deleted once statement compilation has been≠** completed.¢**ŸI** A Vdbe sub-program that implements the body and WHEN clause of triggerŸ@** TriggerPrg.pTrigger, assuming a default ON CONFLICT clause ofŸD** TriggerPrg.orconf, is stored in the TriggerPrg.pProgram variable.ŸF** The Parse.pTriggerPrg list never contains two entries with the sameŸ'** values for both pTrigger and orconf.¢**ŸH** The TriggerPrg.aColmask[0] variable is set to a mask of old.* columnsŸA** accessed (or set to 0 for triggers fired as a result of INSERTŸH** statements). Similarly, the TriggerPrg.aColmask[1] variable is set toŸ/** a mask of new.* columns used by the program.¢*/≥struct TriggerPrg {ŸC  Trigger *pTrigger;      /* Trigger this program was coded from */ŸD  TriggerPrg *pNext;      /* Next entry in Parse.pTriggerPrg list */ŸD  SubProgram *pProgram;   /* Program implementing pTrigger/orconf */Ÿ:  int orconf;             /* Default ON CONFLICT policy */ŸF  u32 aColmask[2];        /* Masks of old.*, new.* columns accessed */¢};†¢/*ŸB** The yDbMask datatype for the bitmask of all attached databases.¢*/∫#if SQLITE_MAX_ATTACHED>30Ÿ;  typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)/8];Ÿ:# define DbMaskTest(M,I)    (((M)[(I)/8]&(1<<((I)&7)))!=0)Ÿ3# define DbMaskZero(M)      memset((M),0,sizeof(M))Ÿ4# define DbMaskSet(M,I)     (M)[(I)/8]|=(1<<((I)&7))Ÿ3# define DbMaskAllZero(M)   sqlite3DbMaskAllZero(M)Ÿ8# define DbMaskNonZero(M)   (sqlite3DbMaskAllZero(M)==0)•#elseø  typedef unsigned int yDbMask;Ÿ:# define DbMaskTest(M,I)    (((M)&(((yDbMask)1)<<(I)))!=0)Ÿ!# define DbMaskZero(M)      (M)=0Ÿ4# define DbMaskSet(M,I)     (M)|=(((yDbMask)1)<<(I))Ÿ"# define DbMaskAllZero(M)   (M)==0Ÿ"# define DbMaskNonZero(M)   (M)!=0¶#endif†¢/*ŸE** An SQL parser context.  A copy of this structure is passed throughŸE** the parser and down into all the parser action routine in order toŸ?** carry around information that is global to the entire parse.¢**ŸE** The structure is divided into two parts.  When the parser and codeŸH** generate call themselves recursively, the first part of the structureŸG** is constant but the second part is reset at the beginning and end of≤** each recursion.¢**ŸL** The nTableLock and aTableLock variables are only used if the shared-cacheŸH** feature is enabled (if sqlite3Tsd()->useSharedData is true). They areŸG** used to store the set of table-locks required by the statement beingŸF** compiled. Function sqlite3TableLock() is used to add entries to the®** list.¢*/Æstruct Parse {Ÿ8  sqlite3 *db;         /* The main database structure */Ÿ-  char *zErrMsg;       /* An error message */ŸF  Vdbe *pVdbe;         /* An engine for executing database bytecode */Ÿ7  int rc;              /* Return code from execution */ŸN  u8 colNamesSet;      /* TRUE after OP_ColumnName has been issued to pVdbe */ŸF  u8 checkSchema;      /* Causes schema cookie check after an error */ŸP  u8 nested;           /* Number of nested calls to the parser/code generator */ŸH  u8 nTempReg;         /* Number of temporary registers in aTempReg[] */ŸN  u8 isMultiWrite;     /* True if statement may modify/insert multiple rows */ŸK  u8 mayAbort;         /* True if statement may throw an ABORT exception */ŸM  u8 hasCompound;      /* Need to invoke convertCompoundSelectToSubquery() */Ÿ7  u8 okConstFactor;    /* OK to factor out constants */ŸH  u8 disableLookaside; /* Number of times lookaside has been disabled */Ÿ=  u8 nColCache;        /* Number of entries in aColCache[] */ŸA  int nRangeReg;       /* Size of the temporary register block */ŸG  int iRangeReg;       /* First register in temporary register block */Ÿ2  int nErr;            /* Number of errors seen */ŸH  int nTab;            /* Number of previously allocated VDBE cursors */Ÿ?  int nMem;            /* Number of memory cells used so far */ŸE  int nOpAlloc;        /* Number of slots allocated for Vdbe.aOp[] */ŸK  int szOpAlloc;       /* Bytes of memory space allocated for Vdbe.aOp[] */ŸM  int iSelfTab;        /* Table associated with an index on expr, or negativeŸN                       ** of the base register during check-constraint eval */ŸP  int iCacheLevel;     /* ColCache valid when aColCache[].iLevel<=iCacheLevel */ŸL  int iCacheCnt;       /* Counter used to generate aColCache[].lru values */Ÿ2  int nLabel;          /* Number of labels used */Ÿ5  int *aLabel;         /* Space to hold the labels */Ÿ1  ExprList *pConstExpr;/* Constant expressions */ŸJ  Token constraintName;/* Name of the constraint currently being parsed */ŸI  yDbMask writeMask;   /* Start a write transaction on these databases */ŸA  yDbMask cookieMask;  /* Bitmask of schema verified databases */ŸI  int regRowid;        /* Register holding rowid of CREATE TABLE entry */ŸN  int regRoot;         /* Register holding root page number for new objects */ŸL  int nMaxArg;         /* Max args passed to user function by sub-program */∑#if SELECTTRACE_ENABLEDŸ=  int nSelect;         /* Number of SELECT statements seen */¶#endifŸ #ifndef SQLITE_OMIT_SHARED_CACHEŸ<  int nTableLock;        /* Number of locks in aTableLock */ŸI  TableLock *aTableLock; /* Required table locks for shared-cache mode */¶#endifŸE  AutoincInfo *pAinc;  /* Information about AUTOINCREMENT counters */ŸG  Parse *pToplevel;    /* Parse structure for main program (or NULL) */Ÿ?  Table *pTriggerTab;  /* Table triggers are being coded for */ŸM  int addrCrTab;       /* Address of OP_CreateBtree opcode on CREATE TABLE */ŸM  u32 nQueryLoop;      /* Est number of iterations of a query (10*log2(N)) */Ÿ=  u32 oldmask;         /* Mask of old.* columns referenced */Ÿ=  u32 newmask;         /* Mask of new.* columns referenced */Ÿ>  u8 eTriggerOp;       /* TK_UPDATE, TK_INSERT or TK_DELETE */ŸI  u8 eOrconf;          /* Default ON CONFLICT policy for trigger steps */Ÿ5  u8 disableTriggers;  /* True to disable triggers */†ŸM  /**************************************************************************ŸG  ** Fields above must be initialized to zero.  The fields that follow,ŸF  ** down to the beginning of the recursive section, do not need to beŸH  ** initialized as they will be set before being used.  The boundary isŸ-  ** determined by offsetof(Parse,aColCache).ŸM  **************************************************************************/†¥  struct yColCache {Ÿ3    int iTable;           /* Table cursor number */Ÿ3    i16 iColumn;          /* Table column number */ŸN    u8 tempReg;           /* iReg is a temp register that needs to be freed */Ÿ-    int iLevel;           /* Nesting level */ŸL    int iReg;             /* Reg with value of this column. 0 means none. */ŸP    int lru;              /* Least recently used entry has the smallest value */ŸH  } aColCache[SQLITE_N_COLCACHE];  /* One for each column cache entry */ŸD  int aTempReg[8];        /* Holding area for temporary registers */ŸI  Token sNameToken;       /* Token with unqualified schema object name */†ŸK  /************************************************************************ŸK  ** Above is constant between recursions.  Below is reset before and afterŸJ  ** each recursion.  The boundary between these two regions is determinedŸI  ** using offsetof(Parse,sLastToken) so the sLastToken field must be theŸ)  ** first field in the recursive region.ŸK  ************************************************************************/†Ÿ5  Token sLastToken;       /* The last token parsed */ŸP  ynVar nVar;               /* Number of '?' variables seen in the SQL so far */ŸE  u8 iPkSortOrder;          /* ASC or DESC for INTEGER PRIMARY KEY */ŸP  u8 explain;               /* True if the EXPLAIN flag is found on the query */Ÿ #ifndef SQLITE_OMIT_VIRTUALTABLEŸG  u8 declareVtab;           /* True if inside sqlite3_declare_vtab() */ŸB  int nVtabLock;            /* Number of virtual tables to lock */¶#endifŸN  int nHeight;              /* Expression tree height of current sub-select */ª#ifndef SQLITE_OMIT_EXPLAINŸI  int iSelectId;            /* ID of current select for EXPLAIN output */ŸM  int iNextSelectId;        /* Next available select ID for EXPLAIN output */¶#endifŸL  VList *pVList;            /* Mapping between variable names and numbers */ŸJ  Vdbe *pReprepare;         /* VM being reprepared (sqlite3Reprepare()) */ŸM  const char *zTail;        /* All SQL text past the last semicolon parsed */ŸK  Table *pNewTable;         /* A table being constructed by CREATE TABLE */ŸM  Trigger *pNewTrigger;     /* Trigger under construct by a CREATE TRIGGER */ŸJ  const char *zAuthContext; /* The 6th parameter to db->xAuth callbacks */Ÿ #ifndef SQLITE_OMIT_VIRTUALTABLEŸD  Token sArg;               /* Complete text of a module argument */ŸK  Table **apVtabLock;       /* Pointer to virtual tables needing locking */¶#endifŸP  Table *pZombieTab;        /* List of Table objects to delete after code gen */Ÿ?  TriggerPrg *pTriggerPrg;  /* Linked list of coded triggers */Ÿ>  With *pWith;              /* Current WITH clause, or NULL */ŸO  With *pWithToFree;        /* Free this WITH object at the end of the parse */¢};†¢/*Ÿ;** Sizes and pointers of various parts of the Parse object.¢*/ŸP#define PARSE_HDR_SZ offsetof(Parse,aColCache) /* Recursive part w/o aColCache*/ŸK#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)    /* Recursive part */ŸO#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ) /* Non-recursive part */ŸL#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)  /* Pointer to tail */†¢/*ŸB** Return true if currently inside an sqlite3_declare_vtab() call.¢*/ø#ifdef SQLITE_OMIT_VIRTUALTABLEª  #define IN_DECLARE_VTAB 0•#elseŸ/  #define IN_DECLARE_VTAB (pParse->declareVtab)¶#endif†¢/*ŸM** An instance of the following structure can be declared on a stack and usedŸI** to save the Parse.zAuthContext value so that it can be restored later.¢*/¥struct AuthContext {ŸE  const char *zAuthContext;   /* Put saved Parse.zAuthContext here */Ÿ7  Parse *pParse;              /* The Parse structure */¢};†¢/*Ÿ2** Bitfield flags for P5 value in various opcodes.¢**Ÿ-** Value constraints (enforced via assert()):Ÿ/**    OPFLAG_LENGTHARG    == SQLITE_FUNC_LENGTHŸ/**    OPFLAG_TYPEOFARG    == SQLITE_FUNC_TYPEOFŸ+**    OPFLAG_BULKCSR      == BTREE_BULKLOADŸ***    OPFLAG_SEEKEQ       == BTREE_SEEK_EQŸ,**    OPFLAG_FORDELETE    == BTREE_FORDELETEŸ/**    OPFLAG_SAVEPOSITION == BTREE_SAVEPOSITIONŸ,**    OPFLAG_AUXDELETE    == BTREE_AUXDELETE¢*/ŸO#define OPFLAG_NCHANGE       0x01    /* OP_Insert: Set to update db->nChange */ŸP                                     /* Also used in P2 (not P5) of OP_Delete */ŸL#define OPFLAG_EPHEM         0x01    /* OP_Column: Ephemeral output is ok */ŸF#define OPFLAG_LASTROWID     0x20    /* Set to update db->lastRowid */ŸJ#define OPFLAG_ISUPDATE      0x04    /* This OP_Insert is an sql UPDATE */ŸI#define OPFLAG_APPEND        0x08    /* This is likely to be an append */ŸO#define OPFLAG_USESEEKRESULT 0x10    /* Try to avoid a seek in BtreeInsert() */ŸN#define OPFLAG_ISNOOP        0x40    /* OP_Delete does pre-update-hook only */ŸK#define OPFLAG_LENGTHARG     0x40    /* OP_Column only used for length() */ŸK#define OPFLAG_TYPEOFARG     0x80    /* OP_Column only used for typeof() */ŸM#define OPFLAG_BULKCSR       0x01    /* OP_Open** used to open bulk cursor */ŸM#define OPFLAG_SEEKEQ        0x02    /* OP_Open** cursor uses EQ seek only */ŸM#define OPFLAG_FORDELETE     0x08    /* OP_Open should use BTREE_FORDELETE */ŸO#define OPFLAG_P2ISREG       0x10    /* P2 to OP_Open** is a register number */ŸJ#define OPFLAG_PERMUTE       0x01    /* OP_Compare: use the permutation */ŸL#define OPFLAG_SAVEPOSITION  0x02    /* OP_Delete/Insert: save cursor pos */ŸJ#define OPFLAG_AUXDELETE     0x04    /* OP_Delete: index in a DELETE op */ŸM#define OPFLAG_NOCHNG_MAGIC  0x6d    /* OP_MakeRecord: serialtype 10 is ok */†¢/*ŸJ * Each trigger present in the database schema is stored as an instance of≤ * struct Trigger.¢ *ŸB * Pointers to instances of struct Trigger are stored in two ways.ŸL * 1. In the "trigHash" hash table (part of the sqlite3* that represents theŸH *    database). This allows Trigger structures to be retrieved by name.ŸO * 2. All triggers associated with a single table form a linked list, using theŸK *    pNext member of struct Trigger. A pointer to the first element of theŸF *    linked list is stored as the "pTrigger" member of the associated≥ *    struct Table.¢ *ŸF * The "step_list" member points to the first element of a linked listŸB * containing the SQL statements specified as the trigger program.£ */∞struct Trigger {ŸN  char *zName;            /* The name of the trigger                        */ŸN  char *table;            /* The table or view to which the trigger applies */ŸN  u8 op;                  /* One of TK_DELETE, TK_UPDATE, TK_INSERT         */ŸD  u8 tr_tm;               /* One of TRIGGER_BEFORE, TRIGGER_AFTER */ŸO  Expr *pWhen;            /* The WHEN clause of the expression (may be NULL) */ŸK  IdList *pColumns;       /* If this is an UPDATE OF <column-list> trigger,Ÿ@                             the <column-list> is stored here */Ÿ=  Schema *pSchema;        /* Schema containing the trigger */Ÿ;  Schema *pTabSchema;     /* Schema containing the table */ŸN  TriggerStep *step_list; /* Link list of trigger program steps             */ŸF  Trigger *pNext;         /* Next trigger associated with the table */¢};†¢/*ŸM** A trigger is either a BEFORE or an AFTER trigger.  The following constants≥** determine which.¢**ŸK** If there are multiple triggers, you might of some BEFORE and some AFTER.Ÿ;** In that cases, the constants below can be ORed together.¢*/π#define TRIGGER_BEFORE  1π#define TRIGGER_AFTER   2†¢/*ŸL * An instance of struct TriggerStep is used to store a single SQL statementŸ' * that is a part of a trigger-program.¢ *ŸM * Instances of struct TriggerStep are stored in a singly linked list (linkedŸH * using the "pNext" member) referenced by the "step_list" member of theŸN * associated struct Trigger instance. The first element of the linked list isŸ) * the first step of the trigger-program.¢ *ŸN * The "op" member indicates whether this is a "DELETE", "INSERT", "UPDATE" orŸM * "SELECT" statement. The meanings of the other members is determined by theº * value of "op" as follows:¢ *¥ * (op == TK_INSERT)Ÿ0 * orconf    -> stores the ON CONFLICT algorithmŸH * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, thenŸN *              this stores a pointer to the SELECT statement. Otherwise NULL.Ÿ: * zTarget   -> Dequoted name of the table to insert into.ŸH * pExprList -> If this is an INSERT INTO ... VALUES ... statement, thenŸB *              this stores values to be inserted. Otherwise NULL.ŸI * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ...ŸB *              statement, then this stores the column-names to beæ *              inserted into.¢ *¥ * (op == TK_DELETE)Ÿ: * zTarget   -> Dequoted name of the table to delete from.ŸM * pWhere    -> The WHERE clause of the DELETE statement if one is specified.ø *              Otherwise NULL.¢ *¥ * (op == TK_UPDATE)Ÿ5 * zTarget   -> Dequoted name of the table to update.ŸM * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.ø *              Otherwise NULL.ŸM * pExprList -> A list of the columns to update and the expressions to updateŸH *              them to. See sqlite3Update() documentation of "pChanges"π *              argument.¢ *£ */¥struct TriggerStep {ŸN  u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */Ÿ-  u8 orconf;           /* OE_Rollback etc. */ŸD  Trigger *pTrig;      /* The trigger that this step is a part of */ŸN  Select *pSelect;     /* SELECT statement or RHS of INSERT INTO SELECT ... */ŸD  char *zTarget;       /* Target table for DELETE, UPDATE, INSERT */ŸH  Expr *pWhere;        /* The WHERE clause for DELETE or UPDATE steps */Ÿ3  ExprList *pExprList; /* SET clause for UPDATE. */Ÿ4  IdList *pIdList;     /* Column names for INSERT */Ÿ>  char *zSpan;         /* Original SQL text of this command */Ÿ2  TriggerStep *pNext;  /* Next in the link-list */ŸO  TriggerStep *pLast;  /* Last element in link-list. Valid for 1st elem only */¢};†¢/*ŸH** The following structure contains information used by the sqliteFix...ŸC** routines as they walk the parse tree to make database references¨** explicit.¢*/øtypedef struct DbFixer DbFixer;∞struct DbFixer {ŸM  Parse *pParse;      /* The parsing context.  Error messages written here */Ÿ4  Schema *pSchema;    /* Fix items to this schema */Ÿ>  int bVarOnly;       /* Check for variable references only */ŸP  const char *zDb;    /* Make sure all objects are contained in this database */ŸK  const char *zType;  /* Type of the container - used for error messages */ŸK  const Token *pName; /* Name of the container - used for error messages */¢};†¢/*Ÿ?** An objected used to accumulate the text of a string where weŸA** do not necessarily know how big the string will be in the end.¢*/±struct StrAccum {ŸJ  sqlite3 *db;         /* Optional database for lookaside.  Can be NULL */Ÿ8  char *zText;         /* The string collected so far */Ÿ?  u32  nAlloc;         /* Amount of space allocated in zText */ŸO  u32  mxAlloc;        /* Maximum allowed allocation.  0 for no malloc usage */Ÿ8  u32  nChar;          /* Length of the string so far */Ÿ>  u8   accError;       /* STRACCUM_NOMEM or STRACCUM_TOOBIG */Ÿ6  u8   printfFlags;    /* SQLITE_PRINTF flags below */¢};∫#define STRACCUM_NOMEM   1∫#define STRACCUM_TOOBIG  2ŸO#define SQLITE_PRINTF_INTERNAL 0x01  /* Internal-use-only converters allowed */ŸM#define SQLITE_PRINTF_SQLFUNC  0x02  /* SQL function arguments to VXPrintf */ŸK#define SQLITE_PRINTF_MALLOCED 0x04  /* True if xText is allocated space */†ŸG#define isMalloced(X)  (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)††¢/*ŸA** A pointer to this structure is used to communicate informationŸD** from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.¢*/∞typedef struct {Ÿ:  sqlite3 *db;        /* The database being initialized */Ÿ5  char **pzErrMsg;    /* Error message stored here */ŸN  int iDb;            /* 0 for main database.  1 for TEMP, 2.. for ATTACHed */Ÿ3  int rc;             /* Result code stored here */´} InitData;†¢/*ŸI** Structure containing global configuration data for the SQLite library.¢**Ÿ7** This structure also contains some state information.¢*/∂struct Sqlite3Config {ŸF  int bMemstat;                     /* True to enable memory status */ŸF  int bCoreMutex;                   /* True to enable core mutexing */ŸF  int bFullMutex;                   /* True to enable full mutexing */ŸM  int bOpenUri;                     /* True to interpret filenames as URIs */ŸM  int bUseCis;                      /* Use covering indices for full-scans */ŸP  int bSmallMalloc;                 /* Avoid large memory allocations if true */Ÿ?  int mxStrlen;                     /* Maximum string length */ŸH  int neverCorrupt;                 /* Database is always well-formed */ŸG  int szLookaside;                  /* Default lookaside buffer size */ŸH  int nLookaside;                   /* Default lookaside buffer count */ŸN  int nStmtSpill;                   /* Stmt-journal spill-to-disk threshold */ŸO  sqlite3_mem_methods m;            /* Low-level memory allocation interface */ŸC  sqlite3_mutex_methods mutex;      /* Low-level mutex interface */ŸH  sqlite3_pcache_methods2 pcache2;  /* Low-level page-cache interface */Ÿ<  void *pHeap;                      /* Heap storage space */Ÿ9  int nHeap;                        /* Size of pHeap[] */ŸI  int mnReq, mxReq;                 /* Min and max heap requests sizes */ŸD  sqlite3_int64 szMmap;             /* mmap() space per open file */ŸB  sqlite3_int64 mxMmap;             /* Maximum value for szMmap */Ÿ;  void *pPage;                      /* Page cache memory */ŸF  int szPage;                       /* Size of each page in pPage[] */ŸD  int nPage;                        /* Number of pages in pPage[] */ŸK  int mxParserStack;                /* maximum depth of the parser stack */ŸK  int sharedCacheEnabled;           /* true if shared-cache mode enabled */ŸA  u32 szPma;                        /* Maximum Sorter PMA size */ŸN  /* The above might be initialized to non-zero.  The following need to alwaysŸ#  ** initially be zero, however. */ŸP  int isInit;                       /* True after initialization has finished */ŸO  int inProgress;                   /* True while initialization in progress */ŸL  int isMutexInit;                  /* True after mutexes are initialized */ŸJ  int isMallocInit;                 /* True after malloc is initialized */ŸJ  int isPCacheInit;                 /* True after malloc is initialized */ŸG  int nRefInitMutex;                /* Number of users of pInitMutex */ŸL  sqlite3_mutex *pInitMutex;        /* Mutex used by sqlite3_initialize() */ŸA  void (*xLog)(void*,int,const char*); /* Function for logging */ŸE  void *pLogArg;                       /* First argument to xLog() */ª#ifdef SQLITE_ENABLE_SQLLOGŸ2  void(*xSqllog)(void*,sqlite3*,const char*, int);≥  void *pSqllogArg;¶#endifª#ifdef SQLITE_VDBE_COVERAGEŸI  /* The following callback (if not NULL) is invoked on every VDBE branchŸF  ** operation.  Set the callback using SQLITE_TESTCTRL_VDBE_COVERAGE.§  */ŸJ  void (*xVdbeBranch)(void*,int iSrcLine,u8 eThis,u8 eMx);  /* Callback */ŸN  void *pVdbeBranchArg;                                     /* 1st argument */¶#endifπ#ifndef SQLITE_UNTESTABLEŸF  int (*xTestCallback)(int);        /* Invoked by sqlite3FaultSim() */¶#endifŸH  int bLocaltimeFault;              /* True to fail localtime() calls */ŸH  int iOnceResetThreshold;          /* When to reset OP_Once counters */¢};†¢/*ŸD** This macro is used inside of assert() statements to indicate thatŸC** the assert is only valid on a well-formed database.  Instead of:¢**≥**     assert( X );¢**Æ** One writes:¢**Ÿ!**     assert( X || CORRUPT_DB );¢**ŸL** CORRUPT_DB is true during normal operation.  CORRUPT_DB does not indicateŸJ** that the database is definitely corrupt, only that it might be corrupt.ŸB** For most test cases, CORRUPT_DB is set to false using a specialŸE** sqlite3_test_control().  This enables assert() statements to proveŸ9** things that are always true for well-formed databases.¢*/Ÿ3#define CORRUPT_DB  (sqlite3Config.neverCorrupt==0)†¢/*Ÿ5** Context pointer passed down through the tree-walk.¢*/Østruct Walker {ŸB  Parse *pParse;                            /* Parser context.  */ŸJ  int (*xExprCallback)(Walker*, Expr*);     /* Callback for expressions */ŸF  int (*xSelectCallback)(Walker*,Select*);  /* Callback for SELECTs */ŸM  void (*xSelectCallback2)(Walker*,Select*);/* Second callback for SELECTs */ŸF  int walkerDepth;                          /* Number of subqueries */ŸI  u8 eCode;                                 /* A small processing code */ŸI  union {                                   /* Extra data for callback */ŸB    NameContext *pNC;                         /* Naming context */Ÿ=    int n;                                    /* A counter */ŸC    int iCur;                                 /* A cursor number */Ÿ?    SrcList *pSrcList;                        /* FROM clause */ŸN    struct SrcCount *pSrcCount;               /* Counting column references */ŸL    struct CCurHint *pCCurHint;               /* Used by codeCursorHint() */ŸK    int *aiCol;                               /* array of column indexes */ŸL    struct IdxCover *pIdxCover;               /* Check for index coverage */ŸP    struct IdxExprTrans *pIdxTrans;           /* Convert idxed expr to column */ŸC    ExprList *pGroupBy;                       /* GROUP BY clause */ŸN    Select *pSelect;                          /* HAVING to WHERE clause ctx */¶  } u;¢};†∫/* Forward declarations */Ÿ3SQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*);Ÿ;SQLITE_PRIVATE int sqlite3WalkExprList(Walker*, ExprList*);Ÿ7SQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*);Ÿ;SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*);Ÿ;SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*);Ÿ7SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker*, Expr*);Ÿ;SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker*, Select*);Ÿ;SQLITE_PRIVATE int sqlite3SelectWalkFail(Walker*, Select*);≥#ifdef SQLITE_DEBUGŸ?SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker*, Select*);¶#endif†¢/*Ÿ?** Return code from the parse-tree walking primitives and their≠** callbacks.¢*/Ÿ=#define WRC_Continue    0   /* Continue down into children */ŸM#define WRC_Prune       1   /* Omit children but continue walking siblings */Ÿ7#define WRC_Abort       2   /* Abandon the tree walk */†¢/*ŸE** An instance of this structure represents a set of one or more CTEsŸ>** (common table expressions) created by a single WITH clause.¢*/≠struct With {ŸI  int nCte;                       /* Number of CTEs in the WITH clause */ŸG  With *pOuter;                   /* Containing WITH clause, or NULL */ŸK  struct Cte {                    /* For each CTE in the WITH clause.... */Ÿ:    char *zName;                    /* Name of this CTE */ŸP    ExprList *pCols;                /* List of explicit column names, or NULL */ŸD    Select *pSelect;                /* The definition of this CTE */ŸO    const char *zCteErr;            /* Error message for circular references */©  } a[1];¢};†≥#ifdef SQLITE_DEBUG¢/*ŸI** An instance of the TreeView object is used for printing the content ofŸB** data structures on sqlite3DebugPrintf() using a tree-like view.¢*/±struct TreeView {ŸA  int iLevel;             /* Which level of the tree we are on */ŸM  u8  bLine[100];         /* Draw vertical in column i if bLine[i] is true */¢};π#endif /* SQLITE_DEBUG */†¢/*Ÿ>** Assuming zIn points to the first byte of a UTF-8 character,ŸF** advance zIn to point to the first byte of the next UTF-8 character.¢*/Ÿ8#define SQLITE_SKIP_UTF8(zIn) {                        \Ÿ8  if( (*(zIn++))>=0xc0 ){                              \Ÿ8    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \Ÿ8  }                                                    \°}†¢/*ŸD** The SQLITE_*_BKPT macros are substitutes for the error codes withŸC** the same name but without the _BKPT suffix.  These macros invokeŸE** routines that report the line-number on which the error originatedŸE** using sqlite3_log().  The routines also provide a convenient placeŸ ** to set a debugger breakpoint.¢*/ŸOSQLITE_PRIVATE int sqlite3ReportError(int iErr, int lineno, const char *zType);Ÿ,SQLITE_PRIVATE int sqlite3CorruptError(int);Ÿ+SQLITE_PRIVATE int sqlite3MisuseError(int);Ÿ-SQLITE_PRIVATE int sqlite3CantopenError(int);Ÿ9#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)Ÿ7#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)Ÿ;#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)≥#ifdef SQLITE_DEBUGŸ,SQLITE_PRIVATE   int sqlite3NomemError(int);Ÿ1SQLITE_PRIVATE   int sqlite3IoerrnomemError(int);Ÿ7SQLITE_PRIVATE   int sqlite3CorruptPgnoError(int,Pgno);Ÿ6# define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)ŸA# define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)ŸE# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))•#elseŸ'# define SQLITE_NOMEM_BKPT SQLITE_NOMEMŸ3# define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEMŸ=# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)¶#endif†¢/*Ÿ3** FTS3 and FTS4 both require virtual table support¢*/Ÿ%#if defined(SQLITE_OMIT_VIRTUALTABLE)∫# undef SQLITE_ENABLE_FTS3∫# undef SQLITE_ENABLE_FTS4¶#endif†¢/*ŸA** FTS4 is really an extension for FTS3.  It is enabled using theŸA** SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also callŸL** the SQLITE_ENABLE_FTS4 macro to serve as an alias for SQLITE_ENABLE_FTS3.¢*/Ÿ?#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)Ω# define SQLITE_ENABLE_FTS3 1¶#endif†¢/*ŸB** The ctype.h header is needed for non-ASCII systems.  It is alsoŸ<** needed by FTS3 when FTS3 is included in the amalgamation.¢*/ø#if !defined(SQLITE_ASCII) || \ŸA    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))≥# include <ctype.h>¶#endif†¢/*ŸG** The following macros mimic the standard library functions toupper(),ŸD** isspace(), isalnum(), isdigit() and isxdigit(), respectively. TheŸH** sqlite versions only work for ASCII characters, regardless of locale.¢*/≥#ifdef SQLITE_ASCIIŸM# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))ŸG# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)ŸG# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)ŸG# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)ŸG# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)ŸG# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)ŸF# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])ŸG# define sqlite3Isquote(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x80)•#elseŸ8# define sqlite3Toupper(x)   toupper((unsigned char)(x))Ÿ8# define sqlite3Isspace(x)   isspace((unsigned char)(x))Ÿ8# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))Ÿ8# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))Ÿ8# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))Ÿ9# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))Ÿ8# define sqlite3Tolower(x)   tolower((unsigned char)(x))ŸF# define sqlite3Isquote(x)   ((x)=='"'||(x)=='\''||(x)=='['||(x)=='`')¶#endifŸ'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSŸ'SQLITE_PRIVATE int sqlite3IsIdChar(u8);¶#endif†¢/*ø** Internal function prototypes¢*/Ÿ;SQLITE_PRIVATE int sqlite3StrICmp(const char*,const char*);Ÿ0SQLITE_PRIVATE int sqlite3Strlen30(const char*);Ÿ6SQLITE_PRIVATE char *sqlite3ColumnType(Column*,char*);Ÿ(#define sqlite3StrNICmp sqlite3_strnicmp†Ÿ+SQLITE_PRIVATE int sqlite3MallocInit(void);Ÿ+SQLITE_PRIVATE void sqlite3MallocEnd(void);Ÿ(SQLITE_PRIVATE void *sqlite3Malloc(u64);Ÿ,SQLITE_PRIVATE void *sqlite3MallocZero(u64);Ÿ8SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, u64);Ÿ7SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, u64);Ÿ9SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3*, u64);Ÿ;SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*,const char*);ŸASQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, u64);ŸHSQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3*,const char*,const char*);Ÿ0SQLITE_PRIVATE void *sqlite3Realloc(void*, u64);ŸDSQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);Ÿ>SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, u64);Ÿ3SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*);Ÿ5SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3*, void*);Ÿ,SQLITE_PRIVATE int sqlite3MallocSize(void*);Ÿ8SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);Ÿ,SQLITE_PRIVATE void *sqlite3PageMalloc(int);Ÿ+SQLITE_PRIVATE void sqlite3PageFree(void*);Ÿ/SQLITE_PRIVATE void sqlite3MemSetDefault(void);π#ifndef SQLITE_UNTESTABLEŸMSQLITE_PRIVATE void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));¶#endifŸ/SQLITE_PRIVATE int sqlite3HeapNearlyFull(void);†¢/*ŸD** On systems with ample stack space and that support alloca(), makeŸL** use of alloca() to obtain space for large automatic objects.  By default,æ** obtain space from malloc().¢**ŸG** The alloca() routine never returns NULL.  This will cause code pathsŸA** that deal with sqlite3StackAlloc() failures to be unreachable.¢*/∏#ifdef SQLITE_USE_ALLOCAŸ.# define sqlite3StackAllocRaw(D,N)   alloca(N)Ÿ<# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)æ# define sqlite3StackFree(D,P)•#elseŸ<# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)Ÿ=# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)Ÿ7# define sqlite3StackFree(D,P)       sqlite3DbFree(D,P)¶#endif†ŸI/* Do not allow both MEMSYS5 and MEMSYS3 to be defined together.  If they∑** are, disable MEMSYS3¢*/º#ifdef SQLITE_ENABLE_MEMSYS5ŸESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void);º#undef SQLITE_ENABLE_MEMSYS3¶#endifº#ifdef SQLITE_ENABLE_MEMSYS3ŸESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void);¶#endif††π#ifndef SQLITE_MUTEX_OMITŸHSQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3DefaultMutex(void);ŸESQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3NoopMutex(void);Ÿ7SQLITE_PRIVATE   sqlite3_mutex *sqlite3MutexAlloc(int);Ÿ,SQLITE_PRIVATE   int sqlite3MutexInit(void);Ÿ+SQLITE_PRIVATE   int sqlite3MutexEnd(void);¶#endifŸ>#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)Ÿ1SQLITE_PRIVATE   void sqlite3MemoryBarrier(void);•#elseø# define sqlite3MemoryBarrier()¶#endif†Ÿ5SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int);Ÿ.SQLITE_PRIVATE void sqlite3StatusUp(int, int);Ÿ0SQLITE_PRIVATE void sqlite3StatusDown(int, int);Ÿ5SQLITE_PRIVATE void sqlite3StatusHighwater(int, int);Ÿ7SQLITE_PRIVATE int sqlite3LookasideUsed(sqlite3*,int*);†Ÿ0/* Access to mutexes used by sqlite3_status() */Ÿ8SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void);Ÿ7SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void);†ŸN#if defined(SQLITE_ENABLE_MULTITHREADED_CHECKS) && !defined(SQLITE_MUTEX_OMIT)ŸASQLITE_PRIVATE void sqlite3MutexWarnOnContention(sqlite3_mutex*);•#elseŸ(# define sqlite3MutexWarnOnContention(x)¶#endif†Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINTŸ*SQLITE_PRIVATE   int sqlite3IsNaN(double);•#elseª# define sqlite3IsNaN(X)  0¶#endif†¢/*ŸE** An instance of the following structure holds information about SQLŸH** functions arguments that are the parameters to the printf() function.¢*/∏struct PrintfArguments {Ÿ:  int nArg;                /* Total number of arguments */Ÿ@  int nUsed;               /* Number of arguments used so far */Ÿ4  sqlite3_value **apArg;   /* The argument values */¢};†ŸESQLITE_PRIVATE void sqlite3VXPrintf(StrAccum*, const char*, va_list);Ÿ@SQLITE_PRIVATE void sqlite3XPrintf(StrAccum*, const char*, ...);Ÿ?SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*,const char*, ...);ŸDSQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*,const char*, va_list);Ÿ:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)Ÿ;SQLITE_PRIVATE   void sqlite3DebugPrintf(const char*, ...);¶#endif∏#if defined(SQLITE_TEST)Ÿ9SQLITE_PRIVATE   void *sqlite3TestTextToPtr(const char*);¶#endif†π#if defined(SQLITE_DEBUG)ŸFSQLITE_PRIVATE   void sqlite3TreeViewExpr(TreeView*, const Expr*, u8);Ÿ[SQLITE_PRIVATE   void sqlite3TreeViewBareExprList(TreeView*, const ExprList*, const char*);Ÿ[SQLITE_PRIVATE   void sqlite3TreeViewExprList(TreeView*, const ExprList*, u8, const char*);ŸJSQLITE_PRIVATE   void sqlite3TreeViewSelect(TreeView*, const Select*, u8);ŸFSQLITE_PRIVATE   void sqlite3TreeViewWith(TreeView*, const With*, u8);¶#endif††ŸESQLITE_PRIVATE void sqlite3SetString(char **, sqlite3*, const char*);Ÿ>SQLITE_PRIVATE void sqlite3ErrorMsg(Parse*, const char*, ...);Ÿ*SQLITE_PRIVATE void sqlite3Dequote(char*);Ÿ3SQLITE_PRIVATE void sqlite3TokenInit(Token*,char*);ŸASQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char*, int);ŸBSQLITE_PRIVATE int sqlite3RunParser(Parse*, const char*, char **);Ÿ0SQLITE_PRIVATE void sqlite3FinishCoding(Parse*);Ÿ-SQLITE_PRIVATE int sqlite3GetTempReg(Parse*);Ÿ6SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse*,int);Ÿ3SQLITE_PRIVATE int sqlite3GetTempRange(Parse*,int);Ÿ<SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse*,int,int);Ÿ5SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse*);≥#ifdef SQLITE_DEBUGŸ9SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse*,int,int);¶#endifŸESQLITE_PRIVATE Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);Ÿ;SQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*,int,const char*);ŸJSQLITE_PRIVATE void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);Ÿ=SQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*);ŸBSQLITE_PRIVATE void sqlite3PExprAddSelect(Parse*, Expr*, Select*);Ÿ;SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*);ŸCSQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*);ŸCSQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);Ÿ7SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*);ŸGSQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);ŸUSQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);Ÿ?SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*,int);ŸHSQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);ŸUSQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);Ÿ?SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);Ÿ9SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList*);Ÿ1SQLITE_PRIVATE int sqlite3Init(sqlite3*, char**);ŸCSQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**);ŸCSQLITE_PRIVATE void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);Ÿ #ifndef SQLITE_OMIT_VIRTUALTABLEŸMSQLITE_PRIVATE Module *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);¶#endifŸASQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3*);Ÿ8SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3*,int);Ÿ;SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3*);Ÿ;SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*);Ÿ>SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3*,Table*);ŸNSQLITE_PRIVATE int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);ŸRSQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*);Ÿ?SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*);Ÿ9SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);Ÿ5SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table*);Ÿ5SQLITE_PRIVATE i16 sqlite3ColumnOfIndex(Index*, i16);ŸLSQLITE_PRIVATE void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);Ÿ #if SQLITE_ENABLE_HIDDEN_COLUMNSŸGSQLITE_PRIVATE   void sqlite3ColumnPropertiesFromName(Table*, Column*);•#elseŸ9# define sqlite3ColumnPropertiesFromName(T,C) /* no-op */¶#endifŸ;SQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token*,Token*);Ÿ3SQLITE_PRIVATE void sqlite3AddNotNull(Parse*, int);ŸKSQLITE_PRIVATE void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);Ÿ=SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*);ŸQSQLITE_PRIVATE void sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);Ÿ:SQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*);ŸESQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);ŸISQLITE_PRIVATE int sqlite3ParseUri(const char*,const char*,unsigned int*,Ÿ2                    sqlite3_vfs**,char**,char **);ŸASQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3*,const char*);†∏#ifdef SQLITE_UNTESTABLEŸ%# define sqlite3FaultSim(X) SQLITE_OK•#elseŸ*SQLITE_PRIVATE   int sqlite3FaultSim(int);¶#endif†Ÿ0SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32);Ÿ3SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec*, u32);Ÿ:SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec*, u32);Ÿ2SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec*, u32);Ÿ<SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec*, u32, void*);Ÿ2SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec*);Ÿ.SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec*);π#ifndef SQLITE_UNTESTABLEŸ6SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int,int*);¶#endif†ŸHSQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3*, void*, unsigned int);Ÿ0SQLITE_PRIVATE void sqlite3RowSetClear(RowSet*);Ÿ6SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet*, i64);Ÿ?SQLITE_PRIVATE int sqlite3RowSetTest(RowSet*, int iBatch, i64);Ÿ4SQLITE_PRIVATE int sqlite3RowSetNext(RowSet*, i64*);†Ÿ]SQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);†ŸD#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)Ÿ>SQLITE_PRIVATE   int sqlite3ViewGetColumnNames(Parse*,Table*);•#elseŸ)# define sqlite3ViewGetColumnNames(A,B) 0¶#endif†∫#if SQLITE_MAX_ATTACHED>30Ÿ3SQLITE_PRIVATE   int sqlite3DbMaskAllZero(yDbMask);¶#endifŸASQLITE_PRIVATE void sqlite3DropTable(Parse*, SrcList*, int, int);ŸCSQLITE_PRIVATE void sqlite3CodeDropTable(Parse*, Table*, int, int);Ÿ9SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3*, Table*);Ÿ!#ifndef SQLITE_OMIT_AUTOINCREMENTŸ?SQLITE_PRIVATE   void sqlite3AutoincrementBegin(Parse *pParse);Ÿ=SQLITE_PRIVATE   void sqlite3AutoincrementEnd(Parse *pParse);•#elseŸ%# define sqlite3AutoincrementBegin(X)Ÿ## define sqlite3AutoincrementEnd(X)¶#endifŸKSQLITE_PRIVATE void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int);ŸHSQLITE_PRIVATE void *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);ŸFSQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*);Ÿ;SQLITE_PRIVATE int sqlite3IdListIndex(IdList*,const char*);ŸLSQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int);ŸQSQLITE_PRIVATE SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*);ŸVSQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,ŸG                                      Token*, Select*, Expr*, IdList*);ŸISQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);ŸHSQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);ŸJSQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);Ÿ:SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*);ŸBSQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*);Ÿ;SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3*, IdList*);Ÿ=SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3*, SrcList*);ŸJSQLITE_PRIVATE Index *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**);ŸZSQLITE_PRIVATE void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,Ÿ/                          Expr*, int, int, u8);Ÿ<SQLITE_PRIVATE void sqlite3DropIndex(Parse*, SrcList*, int);Ÿ?SQLITE_PRIVATE int sqlite3Select(Parse*, Select*, SelectDest*);ŸRSQLITE_PRIVATE Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,Ÿ4                         Expr*,ExprList*,u32,Expr*);Ÿ;SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3*, Select*);Ÿ=SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse*, SrcList*);Ÿ:SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int);ŸMSQLITE_PRIVATE void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);ŸP#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)ŸTSQLITE_PRIVATE Expr *sqlite3LimitWhere(Parse*,SrcList*,Expr*,ExprList*,Expr*,char*);¶#endifŸQSQLITE_PRIVATE void sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*);ŸYSQLITE_PRIVATE void sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*);Ÿ_SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,ExprList*,u16,int);Ÿ0SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo*);Ÿ=SQLITE_PRIVATE LogEst sqlite3WhereOutputRowCount(WhereInfo*);Ÿ6SQLITE_PRIVATE int sqlite3WhereIsDistinct(WhereInfo*);Ÿ5SQLITE_PRIVATE int sqlite3WhereIsOrdered(WhereInfo*);Ÿ<SQLITE_PRIVATE int sqlite3WhereOrderedInnerLoop(WhereInfo*);Ÿ4SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo*);Ÿ9SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo*);Ÿ6SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo*);Ÿ;SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo*, int*);ŸB#define ONEPASS_OFF      0        /* Use of ONEPASS not allowed */ŸM#define ONEPASS_SINGLE   1        /* ONEPASS valid for a single row update */ŸJ#define ONEPASS_MULTI    2        /* ONEPASS is valid for multiple rows */ŸRSQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);ŸOSQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);ŸQSQLITE_PRIVATE void sqlite3ExprCodeGetColumnToReg(Parse*, Table*, int, int, int);ŸRSQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);Ÿ?SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int);ŸASQLITE_PRIVATE void sqlite3ExprCacheStore(Parse*, int, int, int);Ÿ1SQLITE_PRIVATE void sqlite3ExprCachePush(Parse*);Ÿ0SQLITE_PRIVATE void sqlite3ExprCachePop(Parse*);Ÿ=SQLITE_PRIVATE void sqlite3ExprCacheRemove(Parse*, int, int);Ÿ2SQLITE_PRIVATE void sqlite3ExprCacheClear(Parse*);ŸESQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse*, int, int);Ÿ8SQLITE_PRIVATE void sqlite3ExprCode(Parse*, Expr*, int);Ÿ<SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, Expr*, int);ŸBSQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse*, Expr*, int);Ÿ=SQLITE_PRIVATE int sqlite3ExprCodeAtInit(Parse*, Expr*, int);Ÿ<SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*);Ÿ=SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int);Ÿ@SQLITE_PRIVATE void sqlite3ExprCodeAndCache(Parse*, Expr*, int);ŸLSQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);ŸA#define SQLITE_ECEL_DUP      0x01  /* Deep, not shallow copies */ŸB#define SQLITE_ECEL_FACTOR   0x02  /* Factor out constant terms */ŸE#define SQLITE_ECEL_REF      0x04  /* Use ExprList.u.x.iOrderByCol */ŸI#define SQLITE_ECEL_OMITREF  0x08  /* Omit if ExprList.u.x.iOrderByCol */Ÿ?SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int);Ÿ@SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int);ŸCSQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);ŸJSQLITE_PRIVATE Table *sqlite3FindTable(sqlite3*,const char*, const char*);ª#define LOCATE_VIEW    0x01ª#define LOCATE_NOERR   0x02ŸTSQLITE_PRIVATE Table *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*);ŸUSQLITE_PRIVATE Table *sqlite3LocateTableItem(Parse*,u32 flags,struct SrcList_item *);ŸJSQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3*,const char*, const char*);ŸJSQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);ŸJSQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);Ÿ1SQLITE_PRIVATE void sqlite3Vacuum(Parse*,Token*);Ÿ;SQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*, int);Ÿ<SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*);Ÿ@SQLITE_PRIVATE int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);Ÿ=SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*, Expr*, int);ŸESQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);ŸDSQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);Ÿ;SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int);ŸFSQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);ŸFSQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);ŸKSQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);Ÿ?SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr*, SrcList*);Ÿ,SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*);π#ifndef SQLITE_UNTESTABLEŸ/SQLITE_PRIVATE void sqlite3PrngSaveState(void);Ÿ2SQLITE_PRIVATE void sqlite3PrngRestoreState(void);¶#endifŸ5SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*,int);Ÿ9SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int);ŸJSQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);Ÿ9SQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int);Ÿ6SQLITE_PRIVATE void sqlite3EndTransaction(Parse*,int);Ÿ:SQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*);Ÿ6SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *);Ÿ>SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3*);Ÿ3SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr*);Ÿ6SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr*);Ÿ0SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);Ÿ7SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);Ÿ>SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*, u8);ŸLSQLITE_PRIVATE int sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);Ÿ9SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr*,int);Ÿ!#ifdef SQLITE_ENABLE_CURSOR_HINTSŸ6SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr*);¶#endifŸ5SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*);Ÿ5SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr*);ŸGSQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);Ÿ/SQLITE_PRIVATE int sqlite3IsRowid(const char*);Ÿ-SQLITE_PRIVATE void sqlite3GenerateRowDelete(Ÿ9    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);ŸWSQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);Ÿ[SQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);Ÿ;SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse*,int);ŸWSQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,Ÿ:                                     u8,u8,int,int*,int*);æ#ifdef SQLITE_ENABLE_NULL_TRIMŸ;SQLITE_PRIVATE   void sqlite3SetMakeRecordP5(Vdbe*,Table*);•#elseŸ$# define sqlite3SetMakeRecordP5(A,B)¶#endifŸYSQLITE_PRIVATE void sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int);Ÿ]SQLITE_PRIVATE int sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);ŸASQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse*, int, int);Ÿ.SQLITE_PRIVATE void sqlite3MultiWrite(Parse*);Ÿ,SQLITE_PRIVATE void sqlite3MayAbort(Parse*);ŸKSQLITE_PRIVATE void sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);ŸASQLITE_PRIVATE void sqlite3UniqueConstraint(Parse*, int, Index*);Ÿ@SQLITE_PRIVATE void sqlite3RowidConstraint(Parse*, int, Table*);Ÿ8SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,Expr*,int);ŸDSQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);ŸASQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);Ÿ:SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,IdList*);Ÿ>SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,Select*,int);∑#if SELECTTRACE_ENABLEDŸ>SQLITE_PRIVATE void sqlite3SelectSetName(Select*,const char*);•#elseŸ"# define sqlite3SelectSetName(A,B)¶#endifŸ<SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(FuncDef*,int);ŸLSQLITE_PRIVATE FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8);Ÿ:SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(void);Ÿ;SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void);ŸKSQLITE_PRIVATE void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);Ÿ2SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3*);Ÿ8SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3*);Ÿ5SQLITE_PRIVATE void sqlite3ChangeCookie(Parse*, int);†Ÿ?#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)ŸWSQLITE_PRIVATE void sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);¶#endif†ª#ifndef SQLITE_OMIT_TRIGGERŸYSQLITE_PRIVATE   void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,Ÿ+                           Expr*,int, int);ŸISQLITE_PRIVATE   void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);Ÿ@SQLITE_PRIVATE   void sqlite3DropTrigger(Parse*, SrcList*, int);Ÿ>SQLITE_PRIVATE   void sqlite3DropTriggerPtr(Parse*, Trigger*);Ÿ\SQLITE_PRIVATE   Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);Ÿ?SQLITE_PRIVATE   Trigger *sqlite3TriggerList(Parse *, Table *);Ÿ\SQLITE_PRIVATE   void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,Ÿ+                            int, int, int);Ÿ^SQLITE_PRIVATE   void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);ŸA  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);ŸGSQLITE_PRIVATE   void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);ŸHSQLITE_PRIVATE   TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,ŸA                                        const char*,const char*);ŸPSQLITE_PRIVATE   TriggerStep *sqlite3TriggerInsertStep(sqlite3*,Token*, IdList*,ŸL                                        Select*,u8,const char*,const char*);Ÿ\SQLITE_PRIVATE   TriggerStep *sqlite3TriggerUpdateStep(sqlite3*,Token*,ExprList*, Expr*, u8,ŸA                                        const char*,const char*);ŸNSQLITE_PRIVATE   TriggerStep *sqlite3TriggerDeleteStep(sqlite3*,Token*, Expr*,ŸA                                        const char*,const char*);Ÿ?SQLITE_PRIVATE   void sqlite3DeleteTrigger(sqlite3*, Trigger*);ŸNSQLITE_PRIVATE   void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);ŸYSQLITE_PRIVATE   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);ŸH# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))Ÿ1# define sqlite3IsToplevel(p) ((p)->pToplevel==0)•#elseŸ*# define sqlite3TriggersExist(B,C,D,E,F) 0Ÿ"# define sqlite3DeleteTrigger(A,B)Ÿ## define sqlite3DropTriggerPtr(A,B)Ÿ-# define sqlite3UnlinkAndDeleteTrigger(A,B,C)Ÿ1# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)Ÿ1# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)Ÿ## define sqlite3TriggerList(X, Y) 0Ÿ"# define sqlite3ParseToplevel(p) pø# define sqlite3IsToplevel(p) 1Ÿ/# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0¶#endif†ŸCSQLITE_PRIVATE int sqlite3JoinType(Parse*, Token*, Token*, Token*);ŸWSQLITE_PRIVATE void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);Ÿ8SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse*, int);Ÿ!#ifndef SQLITE_OMIT_AUTHORIZATIONŸESQLITE_PRIVATE   void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);ŸYSQLITE_PRIVATE   int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);ŸPSQLITE_PRIVATE   void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);Ÿ:SQLITE_PRIVATE   void sqlite3AuthContextPop(AuthContext*);ŸQSQLITE_PRIVATE   int sqlite3AuthReadCol(Parse*, const char *, const char *, int);•#elseŸ!# define sqlite3AuthRead(a,b,c,d)Ÿ1# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OKŸ&# define sqlite3AuthContextPush(a,b,c)Ÿ.# define sqlite3AuthContextPop(a)  ((void)(a))¶#endifŸ?SQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);Ÿ1SQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*);ŸUSQLITE_PRIVATE void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);Ÿ9SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*);Ÿ7SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*);Ÿ3SQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*);Ÿ;SQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*);ŸASQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);Ÿ@SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8);Ÿ7SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);Ÿ,SQLITE_PRIVATE int sqlite3Atoi(const char*);π#ifndef SQLITE_OMIT_UTF16ŸESQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);¶#endifŸDSQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);Ÿ/SQLITE_PRIVATE u32 sqlite3Utf8Read(const u8**);Ÿ)SQLITE_PRIVATE LogEst sqlite3LogEst(u64);Ÿ6SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst,LogEst);Ÿ #ifndef SQLITE_OMIT_VIRTUALTABLEŸ6SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);¶#endifŸ/#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \Ÿ.    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \Ÿ*    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)Ÿ.SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);¶#endifŸKSQLITE_PRIVATE VList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);Ÿ=SQLITE_PRIVATE const char *sqlite3VListNumToName(VList*,int);ŸASQLITE_PRIVATE int sqlite3VListNameToNum(VList*,const char*,int);†¢/*ŸF** Routines to read and write variable-length integers.  These used toŸG** be defined locally, but now we use the varint routines in the util.c®** file.¢*/Ÿ9SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64);ŸASQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, u64 *);ŸCSQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *, u32 *);Ÿ+SQLITE_PRIVATE int sqlite3VarintLen(u64 v);†¢/*ŸG** The common case is for a varint to be a single byte.  They followingŸH** macros handle the common case without a procedure call, but then callŸ$** the procedure for larger varints.¢*/ª#define getVarint32(A,B)  \ŸM  (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))ª#define putVarint32(A,B)  \Ÿ9  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\º  sqlite3PutVarint((A),(B)))Ÿ%#define getVarint    sqlite3GetVarintŸ%#define putVarint    sqlite3PutVarint††ŸESQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3*, Index*);Ÿ=SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe*, Table*, int);ŸCSQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2);ŸJSQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);Ÿ;SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table*,int);Ÿ5SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr);Ÿ=SQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*, int, u8);Ÿ;SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char*, i64*);ŸHSQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);Ÿ/SQLITE_PRIVATE void sqlite3Error(sqlite3*,int);Ÿ5SQLITE_PRIVATE void sqlite3SystemError(sqlite3*,int);ŸFSQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n);Ÿ)SQLITE_PRIVATE u8 sqlite3HexToInt(int h);ŸKSQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);†Ÿ!#if defined(SQLITE_NEED_ERR_NAME)Ÿ/SQLITE_PRIVATE const char *sqlite3ErrName(int);¶#endif†Ÿ #ifdef SQLITE_ENABLE_DESERIALIZEŸ*SQLITE_PRIVATE int sqlite3MemdbInit(void);¶#endif†Ÿ.SQLITE_PRIVATE const char *sqlite3ErrStr(int);Ÿ4SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);ŸMSQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);ŸNSQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);ŸGSQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);ŸISQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);Ÿ?SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);ŸYSQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);ŸKSQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);Ÿ3SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*);Ÿ;SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);ŸASQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *);Ÿ:SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);Ÿ-SQLITE_PRIVATE int sqlite3AddInt64(i64*,i64);Ÿ-SQLITE_PRIVATE int sqlite3SubInt64(i64*,i64);Ÿ-SQLITE_PRIVATE int sqlite3MulInt64(i64*,i64);Ÿ(SQLITE_PRIVATE int sqlite3AbsInt32(int);æ#ifdef SQLITE_ENABLE_8_3_NAMESŸ;SQLITE_PRIVATE void sqlite3FileSuffix3(const char*, char*);•#elseŸ # define sqlite3FileSuffix3(X,Y)¶#endifŸ6SQLITE_PRIVATE u8 sqlite3GetBoolean(const char *z,u8);†Ÿ@SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8);Ÿ9SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8);ŸLSQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,Ÿ(                        void(*)(void*));Ÿ8SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value*);Ÿ5SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);Ÿ9SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);π#ifndef SQLITE_OMIT_UTF16ŸFSQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);¶#endifŸUSQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);ŸGSQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);ª#ifndef SQLITE_AMALGAMATIONŸ;SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[];Ÿ-SQLITE_PRIVATE const char sqlite3StrBINARY[];Ÿ9SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[];Ÿ5SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[];Ÿ.SQLITE_PRIVATE const Token sqlite3IntTokens[];Ÿ=SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config;Ÿ3SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;∑#ifndef SQLITE_OMIT_WSDŸ&SQLITE_PRIVATE int sqlite3PendingByte;¶#endif¶#endif≥#ifdef VDBE_PROFILEŸ1SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt;¶#endifŸBSQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, int, int);Ÿ;SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*);Ÿ0SQLITE_PRIVATE void sqlite3AlterFunctions(void);ŸFSQLITE_PRIVATE void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);ŸASQLITE_PRIVATE int sqlite3GetToken(const unsigned char *, int *);ŸASQLITE_PRIVATE void sqlite3NestedParse(Parse*, const char*, ...);Ÿ>SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3*);ŸBSQLITE_PRIVATE int sqlite3CodeSubselect(Parse*, Expr *, int, int);ŸESQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*);ŸNSQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);Ÿ\SQLITE_PRIVATE int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);Ÿ@SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*);ŸHSQLITE_PRIVATE int sqlite3ResolveExprListNames(NameContext*, ExprList*);ŸMSQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);ŸSSQLITE_PRIVATE void sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);ŸWSQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);ŸDSQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *, Table *, int, int);ŸBSQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *, Token *);ŸCSQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *, SrcList *);ŸNSQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);Ÿ:SQLITE_PRIVATE char sqlite3AffinityType(const char*, u8*);Ÿ;SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*);ŸISQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);Ÿ3SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*);Ÿ>SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *);Ÿ9SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB);Ÿ?SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3*,Index*);Ÿ1SQLITE_PRIVATE void sqlite3DefaultRowEst(Index*);Ÿ@SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3*, int);ŸDSQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);Ÿ/SQLITE_PRIVATE void sqlite3SchemaClear(void *);Ÿ<SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *, Btree *);Ÿ?SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *);Ÿ>SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);Ÿ2SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo*);Ÿ4SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo*);Ÿ>SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);≥#ifdef SQLITE_DEBUGŸ7SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo*);¶#endifŸOSQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,Ÿ2  void (*)(sqlite3_context*,int,sqlite3_value **),ŸN  void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*),Ω  FuncDestructor *pDestructor¢);Ÿ.SQLITE_PRIVATE void sqlite3OomFault(sqlite3*);Ÿ.SQLITE_PRIVATE void sqlite3OomClear(sqlite3*);Ÿ4SQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int);Ÿ4SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *);†ŸNSQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);ŸESQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum*,const char*,int);ŸDSQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum*,const char*);Ÿ:SQLITE_PRIVATE void sqlite3AppendChar(StrAccum*,int,char);Ÿ6SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum*);Ÿ4SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum*);Ÿ?SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest*,int,int);ŸMSQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);†Ÿ;SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *);ŸLSQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);†º#ifndef SQLITE_OMIT_SUBQUERYŸ5SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse*, Expr*);•#elseŸ*# define sqlite3ExprCheckIN(x,y) SQLITE_OK¶#endif†Ÿ##ifdef SQLITE_ENABLE_STAT3_OR_STAT4Ÿ2SQLITE_PRIVATE void sqlite3AnalyzeFunctions(void);Ÿ-SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(Ÿ7    Parse*,Index*,UnpackedRecord**,Expr*,int,int,int*);ŸQSQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**);Ÿ;SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord*);ŸXSQLITE_PRIVATE int sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**);ŸFSQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3*, Index*, int);¶#endif†¢/*Ÿ.** The interface to the LEMON-generated parser¢*/ª#ifndef SQLITE_AMALGAMATIONŸ9SQLITE_PRIVATE   void *sqlite3ParserAlloc(void*(*)(u64));Ÿ?SQLITE_PRIVATE   void sqlite3ParserFree(void*, void(*)(void*));¶#endifŸ=SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);ª#ifdef YYTRACKMAXSTACKDEPTHŸ3SQLITE_PRIVATE   int sqlite3ParserStackPeak(void*);¶#endif†Ÿ8SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3*);Ÿ"#ifndef SQLITE_OMIT_LOAD_EXTENSIONŸ7SQLITE_PRIVATE   void sqlite3CloseExtensions(sqlite3*);•#elseŸ"# define sqlite3CloseExtensions(X)¶#endif†Ÿ #ifndef SQLITE_OMIT_SHARED_CACHEŸLSQLITE_PRIVATE   void sqlite3TableLock(Parse *, int, int, u8, const char *);•#elseŸ%  #define sqlite3TableLock(v,w,x,y,z)¶#endif†≤#ifdef SQLITE_TESTŸ4SQLITE_PRIVATE   int sqlite3Utf8To8(unsigned char*);¶#endif†ø#ifdef SQLITE_OMIT_VIRTUALTABLEΩ#  define sqlite3VtabClear(Y)Ÿ(#  define sqlite3VtabSync(X,Y) SQLITE_OKŸ #  define sqlite3VtabRollback(X)æ#  define sqlite3VtabCommit(X)Ÿ!#  define sqlite3VtabInSync(db) 0º#  define sqlite3VtabLock(X)æ#  define sqlite3VtabUnlock(X)Ÿ"#  define sqlite3VtabUnlockList(X)Ÿ1#  define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OKŸ-#  define sqlite3GetVTable(X,Y)  ((VTable*)0)•#elseŸ=SQLITE_PRIVATE    void sqlite3VtabClear(sqlite3 *db, Table*);ŸDSQLITE_PRIVATE    void sqlite3VtabDisconnect(sqlite3 *db, Table *p);Ÿ:SQLITE_PRIVATE    int sqlite3VtabSync(sqlite3 *db, Vdbe*);Ÿ7SQLITE_PRIVATE    int sqlite3VtabRollback(sqlite3 *db);Ÿ5SQLITE_PRIVATE    int sqlite3VtabCommit(sqlite3 *db);Ÿ1SQLITE_PRIVATE    void sqlite3VtabLock(VTable *);Ÿ3SQLITE_PRIVATE    void sqlite3VtabUnlock(VTable *);Ÿ7SQLITE_PRIVATE    void sqlite3VtabUnlockList(sqlite3*);Ÿ@SQLITE_PRIVATE    int sqlite3VtabSavepoint(sqlite3 *, int, int);ŸESQLITE_PRIVATE    void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);Ÿ=SQLITE_PRIVATE    VTable *sqlite3GetVTable(sqlite3*, Table*);Ÿ2SQLITE_PRIVATE    Module *sqlite3VtabCreateModule(Æ     sqlite3*,±     const char*,ª     const sqlite3_module*,´     void*,≥     void(*)(void*)•   );ŸE#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)¶#endifŸASQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse*,Module*);ŸESQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3*,Module*);Ÿ;SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*);ŸOSQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);Ÿ;SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*);Ÿ/SQLITE_PRIVATE void sqlite3VtabArgInit(Parse*);Ÿ9SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse*, Token*);ŸOSQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);Ÿ:SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse*, Table*);ŸGSQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3*, int, const char *);Ÿ9SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *, VTable *);ŸYSQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);ŸQSQLITE_PRIVATE void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**);ŸFSQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);ŸFSQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);ŸKSQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);Ÿ/SQLITE_PRIVATE void sqlite3ParserReset(Parse*);Ÿ+SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*);ŸOSQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);ŸMSQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);Ÿ7SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3*);Ÿ7SQLITE_PRIVATE const char *sqlite3JournalModename(int);∑#ifndef SQLITE_OMIT_WALŸGSQLITE_PRIVATE   int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);ŸKSQLITE_PRIVATE   int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);¶#endif∑#ifndef SQLITE_OMIT_CTEŸMSQLITE_PRIVATE   With *sqlite3WithAdd(Parse*,With*,Token*,ExprList*,Select*);Ÿ8SQLITE_PRIVATE   void sqlite3WithDelete(sqlite3*,With*);Ÿ9SQLITE_PRIVATE   void sqlite3WithPush(Parse*, With*, u8);•#elseæ#define sqlite3WithPush(x,y,z)æ#define sqlite3WithDelete(x,y)¶#endif†ŸE/* Declarations for functions in fkey.c. All of these are replaced byŸG** no-op macros if OMIT_FOREIGN_KEY is defined. In this case no foreignŸA** key functionality is available. If OMIT_TRIGGER is defined butŸF** OMIT_FOREIGN_KEY is not, only some of the functions are no-oped. InŸC** this case foreign keys are parsed, but no other functionality isŸM** provided (enforcement of FK constraints requires the triggers sub-system).¢*/ŸF#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)ŸJSQLITE_PRIVATE   void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);ŸDSQLITE_PRIVATE   void sqlite3FkDropTable(Parse*, SrcList *, Table*);ŸRSQLITE_PRIVATE   void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);ŸBSQLITE_PRIVATE   int sqlite3FkRequired(Parse*, Table*, int*, int);Ÿ6SQLITE_PRIVATE   u32 sqlite3FkOldmask(Parse*, Table*);Ÿ4SQLITE_PRIVATE   FKey *sqlite3FkReferences(Table *);•#elseŸ'  #define sqlite3FkActions(a,b,c,d,e,f)Ÿ%  #define sqlite3FkCheck(a,b,c,d,e,f)Ÿ#  #define sqlite3FkDropTable(a,b,c)Ÿ)  #define sqlite3FkOldmask(a,b)         0Ÿ)  #define sqlite3FkRequired(a,b,c,d)    0Ÿ)  #define sqlite3FkReferences(a)        0¶#endifø#ifndef SQLITE_OMIT_FOREIGN_KEYŸ9SQLITE_PRIVATE   void sqlite3FkDelete(sqlite3 *, Table*);ŸMSQLITE_PRIVATE   int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);•#elseæ  #define sqlite3FkDelete(a,b)Ÿ)  #define sqlite3FkLocateIndex(a,b,c,d,e)¶#endif††¢/*ŸC** Available fault injectors.  Should be numbered beginning with 0.¢*/Ÿ)#define SQLITE_FAULTINJECTOR_MALLOC     0Ÿ)#define SQLITE_FAULTINJECTOR_COUNT      1†¢/*ŸE** The interface to the code in fault.c used for identifying "benign"Ÿ=** malloc failures. This is only present if SQLITE_UNTESTABLE≤** is not defined.¢*/π#ifndef SQLITE_UNTESTABLEŸ5SQLITE_PRIVATE   void sqlite3BeginBenignMalloc(void);Ÿ3SQLITE_PRIVATE   void sqlite3EndBenignMalloc(void);•#elseŸ$  #define sqlite3BeginBenignMalloc()Ÿ"  #define sqlite3EndBenignMalloc()¶#endif†¢/*Ÿ2** Allowed return values from sqlite3FindInIndex()¢*/ŸE#define IN_INDEX_ROWID        1   /* Search the rowid of the table */ŸB#define IN_INDEX_EPH          2   /* Search an ephemeral b-tree */Ÿ@#define IN_INDEX_INDEX_ASC    3   /* Existing index ASCENDING */ŸA#define IN_INDEX_INDEX_DESC   4   /* Existing index DESCENDING */ŸK#define IN_INDEX_NOOP         5   /* No table available. Use comparisons */¢/*Ÿ?** Allowed flags for the 3rd parameter to sqlite3FindInIndex().¢*/ŸE#define IN_INDEX_NOOP_OK     0x0001  /* OK to return IN_INDEX_NOOP */ŸO#define IN_INDEX_MEMBERSHIP  0x0002  /* IN operator used for membership test */ŸE#define IN_INDEX_LOOP        0x0004  /* IN operator used as a loop */ŸHSQLITE_PRIVATE int sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*);†Ÿ]SQLITE_PRIVATE int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);Ÿ5SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *);Ÿ)#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \Ÿ- || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ÿ:SQLITE_PRIVATE   int sqlite3JournalCreate(sqlite3_file *);¶#endif†Ÿ=SQLITE_PRIVATE int sqlite3JournalIsInMemory(sqlite3_file *p);Ÿ:SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *);†ŸISQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);ª#if SQLITE_MAX_EXPR_DEPTH>0Ÿ7SQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);Ÿ9SQLITE_PRIVATE   int sqlite3ExprCheckHeight(Parse*, int);•#elseŸ&  #define sqlite3SelectExprHeight(x) 0Ÿ%  #define sqlite3ExprCheckHeight(x,y)¶#endif†Ÿ.SQLITE_PRIVATE u32 sqlite3Get4byte(const u8*);Ÿ.SQLITE_PRIVATE void sqlite3Put4byte(u8*, u32);†Ÿ"#ifdef SQLITE_ENABLE_UNLOCK_NOTIFYŸESQLITE_PRIVATE   void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);Ÿ=SQLITE_PRIVATE   void sqlite3ConnectionUnlocked(sqlite3 *db);Ÿ;SQLITE_PRIVATE   void sqlite3ConnectionClosed(sqlite3 *db);•#elseŸ'  #define sqlite3ConnectionBlocked(x,y)Ÿ&  #define sqlite3ConnectionUnlocked(x)Ÿ$  #define sqlite3ConnectionClosed(x)¶#endif†≥#ifdef SQLITE_DEBUGŸ8SQLITE_PRIVATE   void sqlite3ParserTrace(FILE*, char *);¶#endif∑#if defined(YYCOVERAGE)Ÿ2SQLITE_PRIVATE   int sqlite3ParserCoverage(FILE*);¶#endif†¢/*Ÿ?** If the SQLITE_ENABLE IOTRACE exists then the global variableŸ?** sqlite3IoTrace is a pointer to a printf-like routine used toæ** print I/O tracing messages.¢*/º#ifdef SQLITE_ENABLE_IOTRACEŸ># define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }Ÿ3SQLITE_PRIVATE   void sqlite3VdbeIOTraceSql(Vdbe*);ŸNSQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);•#else≥# define IOTRACE(A)Ÿ!# define sqlite3VdbeIOTraceSql(X)¶#endif†¢/*ŸI** These routines are available for the mem2.c debugging memory allocatorŸB** only.  They are used to verify that different "types" of memoryŸ2** allocations are properly tracked by the system.¢**ŸF** sqlite3MemdebugSetType() sets the "type" of an allocation to one ofŸG** the MEMTYPE_* macros defined below.  The type must be a bitmask with¥** a single bit set.¢**ŸI** sqlite3MemdebugHasType() returns true if any of the bits in its secondŸH** argument match the type set by the previous sqlite3MemdebugSetType().ŸK** sqlite3MemdebugHasType() is intended for use inside assert() statements.¢**ŸI** sqlite3MemdebugNoType() returns true if none of the bits in its secondŸH** argument match the type set by the previous sqlite3MemdebugSetType().¢**ŸJ** Perhaps the most important point is the difference between MEMTYPE_HEAPŸL** and MEMTYPE_LOOKASIDE.  If an allocation is MEMTYPE_LOOKASIDE, that meansŸG** it might have been allocated by lookaside, except the allocation wasŸF** too large or lookaside was already full.  It is important to verifyŸG** that allocations that might have been satisfied by lookaside are notŸE** passed back to non-lookaside free() routines.  Asserts such as theŸJ** example above are placed on the non-lookaside free() routines to verify≥** this constraint.¢**ŸC** All of this is no-op for a production build.  It only comes intoŸ=** play when the SQLITE_MEMDEBUG compile-time option is used.¢*/∂#ifdef SQLITE_MEMDEBUGŸ7SQLITE_PRIVATE   void sqlite3MemdebugSetType(void*,u8);Ÿ6SQLITE_PRIVATE   int sqlite3MemdebugHasType(void*,u8);Ÿ5SQLITE_PRIVATE   int sqlite3MemdebugNoType(void*,u8);•#elseŸ1# define sqlite3MemdebugSetType(X,Y)  /* no-op */Ÿ'# define sqlite3MemdebugHasType(X,Y)  1Ÿ'# define sqlite3MemdebugNoType(X,Y)   1¶#endifŸ?#define MEMTYPE_HEAP       0x01  /* General heap allocations */ŸJ#define MEMTYPE_LOOKASIDE  0x02  /* Heap that might have been lookaside */Ÿ=#define MEMTYPE_PCACHE     0x04  /* Page cache allocations */†¢/*∂** Threading interface¢*/ø#if SQLITE_MAX_WORKER_THREADS>0ŸMSQLITE_PRIVATE int sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*);Ÿ<SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread*, void**);¶#endif†Ÿ>#if defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)Ÿ3SQLITE_PRIVATE int sqlite3DbpageRegister(sqlite3*);¶#endifŸ>#if defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)Ÿ3SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3*);¶#endif†Ÿ6SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr);Ÿ4SQLITE_PRIVATE int sqlite3ExprIsVector(Expr *pExpr);Ÿ;SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr*, int);ŸASQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*,Expr*,int);Ÿ9SQLITE_PRIVATE void sqlite3VectorErrorMsg(Parse*, Expr*);†Ÿ'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSŸ>SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt);¶#endif†∏#endif /* SQLITEINT_H */†ŸO/************** End of sqliteInt.h *******************************************/ŸO/************** Begin file global.c ******************************************/¢/*Ø** 2008 June 13¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸD** This file contains definitions of global variables and constants.¢*/º/* #include "sqliteInt.h" */†ŸE/* An array to map all upper-case characters into their correspondingπ** lower-case character. ¢**ŸD** SQLite only considers US-ASCII (or EBCDIC) characters.  We do notŸE** handle case conversions for the UTF character set since the tablesŸ;** involved are nearly as big or bigger than SQLite itself.¢*/Ÿ<SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {≥#ifdef SQLITE_ASCIIŸL      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,ŸL     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,ŸL     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,ŸL     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,ŸL    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,ŸL    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,ŸL    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,ŸL    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,ŸL    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,ŸL    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,ŸL    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,ŸL    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,ŸL    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,ŸL    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,≥    252,253,254,255¶#endif¥#ifdef SQLITE_EBCDICŸM      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */ŸM     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */ŸM     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */ŸM     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */ŸM     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */ŸM     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */ŸM     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111, /* 6x */ŸM    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127, /* 7x */ŸM    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */ŸM    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159, /* 9x */ŸM    160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */ŸM    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */ŸM    192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */ŸM    208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */ŸM    224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239, /* Ex */ŸM    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, /* Fx */¶#endif¢};†¢/*ŸJ** The following 256 byte lookup table is used to support SQLites built-inŸ;** equivalents to the following standard library functions:¢**Ÿ***   isspace()                        0x01Ÿ***   isalpha()                        0x02Ÿ***   isdigit()                        0x04Ÿ***   isalnum()                        0x06Ÿ***   isxdigit()                       0x08Ÿ***   toupper()                        0x20Ÿ***   SQLite identifier character      0x40Ÿ***   Quote character                  0x80¢**ŸH** Bit 0x20 is set if the mapped character requires translation to upperŸ?** case. i.e. if the character is a lower-case ASCII character.ŸG** If x is a lower-case ASCII character, then its upper-case equivalentŸ<** is (x - 0x20). Therefore toupper() can be implemented as:¢**π**   (x & ~(map[x]&0x20))¢**ŸM** The equivalent of tolower() is implemented using the sqlite3UpperToLower[]Ÿ@** array. tolower() is used more often than toupper() by SQLite.¢**ŸN** Bit 0x40 is set if the character is non-alphanumeric and can be used in an ŸG** SQLite identifier.  Identifiers are alphanumerics, "_", "$", and anyŸL** non-ASCII UTF character. Hence the test for whether or not a character isŸ!** part of an identifier is 0x46.¢*/≥#ifdef SQLITE_ASCIIŸ;SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {ŸK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */ŸK  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */ŸK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */ŸK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */ŸK  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  /* 20..27     !"#$%&' */ŸK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */ŸK  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */ŸK  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */†ŸK  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */ŸK  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */ŸK  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */ŸK  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  /* 58..5f    XYZ[\]^_ */ŸK  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */ŸK  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */ŸK  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */ŸK  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */†ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 80..87    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 88..8f    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 90..97    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 98..9f    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a0..a7    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a8..af    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b0..b7    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b8..bf    ........ */†ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c0..c7    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c8..cf    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d0..d7    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d8..df    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e0..e7    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e8..ef    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* f0..f7    ........ */ŸK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   /* f8..ff    ........ */¢};¶#endif†ŸA/* EVIDENCE-OF: R-02982-34736 In order to maintain full backwardsŸH** compatibility for legacy applications, the URI filename capability is∑** disabled by default.¢**ŸF** EVIDENCE-OF: R-38799-08373 URI filenames can be enabled or disabledŸG** using the SQLITE_USE_URI=1 or SQLITE_USE_URI=0 compile-time options.¢**ŸB** EVIDENCE-OF: R-43642-56306 By default, URI handling is globallyŸC** disabled. The default value may be changed by compiling with theŸ!** SQLITE_USE_URI symbol defined.¢**Ÿ>** URI filenames are enabled by default if SQLITE_HAS_CODEC is´** enabled.¢*/∂#ifndef SQLITE_USE_URI∏# ifdef SQLITE_HAS_CODEC∫#  define SQLITE_USE_URI 1¶# else∫#  define SQLITE_USE_URI 0ß# endif¶#endif†ŸF/* EVIDENCE-OF: R-38720-18127 The default setting is determined by theŸF** SQLITE_ALLOW_COVERING_INDEX_SCAN compile-time option, or is "on" ifŸ'** that compile-time option is omitted.¢*/Ÿ(#ifndef SQLITE_ALLOW_COVERING_INDEX_SCANŸ+# define SQLITE_ALLOW_COVERING_INDEX_SCAN 1¶#endif†ŸG/* The minimum PMA size is set to this value multiplied by the database∂** page size in bytes.¢*/ª#ifndef SQLITE_SORTER_PMASZŸ # define SQLITE_SORTER_PMASZ 250¶#endif†ŸI/* Statement journals spill to disk when their size exceeds the followingŸH** threshold (in bytes). 0 means that statement journals are created andŸH** written to disk immediately (the default behavior for SQLite versionsŸH** before 3.12.0).  -1 means always keep the entire statement journal inŸI** memory.  (The statement journal is also always held entirely in memoryŸE** if journal_mode=MEMORY or if temp_store=MEMORY, regardless of this¨** setting.)¢*/æ#ifndef SQLITE_STMTJRNL_SPILL Ÿ(# define SQLITE_STMTJRNL_SPILL (64*1024)¶#endif†¢/*ŸE** The default lookaside-configuration, the format "SZ,N".  SZ is theŸE** number of bytes in each lookaside slot (should be a multiple of 8)ŸD** and N is the number of slots.  The lookaside-configuration can beŸF** changed as start-time using sqlite3_config(SQLITE_CONFIG_LOOKASIDE)Ÿ=** or at run-time for an individual database connection usingŸ4** sqlite3_db_config(db, SQLITE_DBCONFIG_LOOKASIDE);¢*/Ÿ #ifndef SQLITE_DEFAULT_LOOKASIDEŸ*# define SQLITE_DEFAULT_LOOKASIDE 1200,100¶#endif††¢/*Ÿ@** The following singleton contains the global configuration for∂** the SQLite library.¢*/Ÿ@SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {Ÿ,   SQLITE_DEFAULT_MEMSTATUS,  /* bMemstat */Ÿ.   1,                         /* bCoreMutex */Ÿ.   SQLITE_THREADSAFE==1,      /* bFullMutex */Ÿ,   SQLITE_USE_URI,            /* bOpenUri */Ÿ4   SQLITE_ALLOW_COVERING_INDEX_SCAN,   /* bUseCis */Ÿ0   0,                         /* bSmallMalloc */Ÿ,   0x7ffffffe,                /* mxStrlen */Ÿ0   0,                         /* neverCorrupt */Ÿ;   SQLITE_DEFAULT_LOOKASIDE,  /* szLookaside, nLookaside */Ÿ.   SQLITE_STMTJRNL_SPILL,     /* nStmtSpill */Ÿ%   {0,0,0,0,0,0,0,0},         /* m */Ÿ)   {0,0,0,0,0,0,0,0,0},       /* mutex */Ÿ,   {0,0,0,0,0,0,0,0,0,0,0,0,0},/* pcache2 */Ÿ)   (void*)0,                  /* pHeap */Ÿ)   0,                         /* nHeap */Ÿ2   0, 0,                      /* mnHeap, mxHeap */Ÿ*   SQLITE_DEFAULT_MMAP_SIZE,  /* szMmap */Ÿ*   SQLITE_MAX_MMAP_SIZE,      /* mxMmap */Ÿ)   (void*)0,                  /* pPage */Ÿ*   0,                         /* szPage */Ÿ,   SQLITE_DEFAULT_PCACHE_INITSZ, /* nPage */Ÿ1   0,                         /* mxParserStack */Ÿ6   0,                         /* sharedCacheEnabled */Ÿ)   SQLITE_SORTER_PMASZ,       /* szPma */Ÿ:   /* All the rest should always be initialized to zero */Ÿ*   0,                         /* isInit */Ÿ.   0,                         /* inProgress */Ÿ/   0,                         /* isMutexInit */Ÿ0   0,                         /* isMallocInit */Ÿ0   0,                         /* isPCacheInit */Ÿ1   0,                         /* nRefInitMutex */Ÿ.   0,                         /* pInitMutex */Ÿ(   0,                         /* xLog */Ÿ+   0,                         /* pLogArg */ª#ifdef SQLITE_ENABLE_SQLLOGŸ+   0,                         /* xSqllog */Ÿ.   0,                         /* pSqllogArg */¶#endifª#ifdef SQLITE_VDBE_COVERAGEŸ/   0,                         /* xVdbeBranch */Ÿ1   0,                         /* pVbeBranchArg */¶#endifπ#ifndef SQLITE_UNTESTABLEŸ1   0,                         /* xTestCallback */¶#endifŸ3   0,                         /* bLocaltimeFault */Ÿ7   0x7ffffffe                 /* iOnceResetThreshold */¢};†¢/*Ÿ<** Hash table for global functions - functions common to allŸ=** database connections.  After initialization, this table is≠** read-only.¢*/Ÿ3SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;†¢/*Ÿ&** Constant tokens for values 0 and 1.¢*/Ÿ1SQLITE_PRIVATE const Token sqlite3IntTokens[] = {Æ   { "0", 1 },≠   { "1", 1 }¢};†≥#ifdef VDBE_PROFILE¢/*Ÿ<** The following performance counter can be used in place ofŸF** sqlite3Hwtime() for profiling.  This is a no-op on standard builds.¢*/Ÿ5SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt = 0;¶#endif†¢/*ŸF** The value of the "pending" byte must be 0x40000000 (1 byte past theŸD** 1-gibabyte boundary) in a compatible database.  SQLite never usesŸG** the database page that contains the pending byte.  It never attemptsŸB** to read or write that page.  The pending byte page is set asideŸ>** for use by the VFS layers as space for managing file locks.¢**ŸD** During testing, it is often desirable to move the pending byte toŸB** a different position in the file.  This allows code that has toŸC** deal with the pending byte to run on files that are much smallerŸC** than 1 GiB.  The sqlite3_test_control() interface can be used toπ** move the pending byte.¢**Ÿ@** IMPORTANT:  Changing the pending byte to any value other thanŸ>** 0x40000000 results in an incompatible database file format!ŸF** Changing the pending byte during operation will result in undefined∫** and incorrect behavior.¢*/∑#ifndef SQLITE_OMIT_WSDŸ3SQLITE_PRIVATE int sqlite3PendingByte = 0x40000000;¶#endif†∫/* #include "opcodes.h" */¢/*Ÿ9** Properties of opcodes.  The OPFLG_INITIALIZER macro isŸA** created by mkopcodeh.awk during compilation.  Data is obtainedŸ@** from the comments following the "case OP_xxxx:" statements inµ** the vdbe.c file.  ¢*/ŸOSQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER;†¢/*Ÿ)** Name of the default collating sequence¢*/Ÿ8SQLITE_PRIVATE const char sqlite3StrBINARY[] = "BINARY";†ŸO/************** End of global.c **********************************************/ŸO/************** Begin file status.c ******************************************/¢/*Ø** 2008 June 18¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸD** This module implements the sqlite3_status() interface and related±** functionality.¢*/º/* #include "sqliteInt.h" */ŸO/************** Include vdbeInt.h in the middle of status.c ******************/ŸO/************** Begin file vdbeInt.h *****************************************/¢/*≥** 2003 September 6¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸA** This is the header file for information that is private to theŸB** VDBE.  This information used to all be at the top of the singleŸB** source code file "vdbe.c".  When that file became too big (overŸB** 6000 lines long) it was split up into several smaller files andŸ,** this header information was factored out.¢*/∏#ifndef SQLITE_VDBEINT_H∏#define SQLITE_VDBEINT_H†¢/*ŸC** The maximum number of times that a statement will try to reparseŸ7** itself before giving up and returning SQLITE_SCHEMA.¢*/ø#ifndef SQLITE_MAX_SCHEMA_RETRYŸ## define SQLITE_MAX_SCHEMA_RETRY 50¶#endif†¢/*ŸC** VDBE_DISPLAY_P4 is true or false depending on whether or not theŸ)** "explain" P4 display logic is enabled.¢*/Ÿ7#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \Ÿ6     || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)∫# define VDBE_DISPLAY_P4 1•#else∫# define VDBE_DISPLAY_P4 0¶#endif†¢/*Ÿ:** SQL is translated into a sequence of instructions to beŸB** executed by a virtual machine.  Each instruction is an instanceæ** of the following structure.¢*/πtypedef struct VdbeOp Op;†¢/*±** Boolean values¢*/∂typedef unsigned Bool;†Ÿ,/* Opaque type used by code in vdbesort.c */Ÿ%typedef struct VdbeSorter VdbeSorter;†Ÿ2/* Elements of the linked list at Vdbe.pAuxData */øtypedef struct AuxData AuxData;†ª/* Types of VDBE cursors */Ω#define CURTYPE_BTREE       0Ω#define CURTYPE_SORTER      1Ω#define CURTYPE_VTAB        2Ω#define CURTYPE_PSEUDO      3†¢/*ŸH** A VdbeCursor is an superclass (a wrapper) for various cursor objects:¢**π**      * A b-tree cursorŸ?**          -  In the main database or in an ephemeral databaseŸ,**          -  On either an index or a table≤**      * A sorterπ**      * A virtual tableŸ=**      * A one-row "pseudotable" stored in a single register¢*/Ÿ%typedef struct VdbeCursor VdbeCursor;≥struct VdbeCursor {ŸA  u8 eCurType;            /* One of the CURTYPE_* values above */ŸM  i8 iDb;                 /* Index of cursor database in db->aDb[] (or -1) */ŸF  u8 nullRow;             /* True if pointing to a row with no data */ŸH  u8 deferredMoveto;      /* A call to sqlite3BtreeMoveto() is needed */ŸI  u8 isTable;             /* True for rowid tables.  False for indexes */≥#ifdef SQLITE_DEBUGŸI  u8 seekOp;              /* Most recent seek operation on this cursor */ŸK  u8 wrFlag;              /* The wrFlag argument to sqlite3BtreeCursor() */¶#endifŸ;  Bool isEphemeral:1;     /* True for an ephemeral table */ŸI  Bool useRandomRowid:1;  /* Generate new record numbers semi-randomly */ŸH  Bool isOrdered:1;       /* True if the table is not BTREE_UNORDERED */ŸE  Btree *pBtx;            /* Separate file holding temporary table */Ÿ0  i64 seqCount;           /* Sequence counter */ŸJ  int *aAltMap;           /* Mapping from table to index column numbers */†ŸL  /* Cached OP_Column parse information is only valid if cacheStatus matchesŸB  ** Vdbe.cacheCtr.  Vdbe.cacheCtr will never take on the value ofŸK  ** CACHE_STALE (0) and so setting cacheStatus=CACHE_STALE guarantees thatŸ!  ** the cache is out of date. */ŸL  u32 cacheStatus;        /* Cache is valid if this matches Vdbe.cacheCtr */ŸI  int seekResult;         /* Result of previous sqlite3BtreeMoveto() or 0ŸP                          ** if there have been no prior seeks on the cursor. */ŸI  /* seekResult does not distinguish between "no seeks have ever occurredŸC  ** on this cursor" and "the most recent seek was an exact match".ŸI  ** For CURTYPE_PSEUDO, seekResult is the register holding the record */†ŸJ  /* When a new VdbeCursor is allocated, only the fields above are zeroed.ŸG  ** The fields that follow are uninitialized, and must be individuallyŸ'  ** initialized prior to first use. */ŸJ  VdbeCursor *pAltCursor; /* Associated index cursor from which to read */©  union {ŸM    BtCursor *pCursor;          /* CURTYPE_BTREE or _PSEUDO.  Btree cursor */ŸL    sqlite3_vtab_cursor *pVCur; /* CURTYPE_VTAB.              Vtab cursor */ŸN    VdbeSorter *pSorter;        /* CURTYPE_SORTER.            Sorter object */ß  } uc;ŸM  KeyInfo *pKeyInfo;      /* Info about index keys needed by index cursors */ŸJ  u32 iHdrOffset;         /* Offset to next unparsed byte of the header */ŸB  Pgno pgnoRoot;          /* Root page of the open btree cursor */Ÿ>  i16 nField;             /* Number of fields in the header */ŸE  u16 nHdrParsed;         /* Number of header fields parsed so far */ŸM  i64 movetoTarget;       /* Argument to the deferred sqlite3BtreeMoveto() */Ÿ8  u32 *aOffset;           /* Pointer to aType[nField] */ŸL  const u8 *aRow;         /* Data for the current row, if all on one page */ŸC  u32 payloadSize;        /* Total number of bytes in the record */Ÿ6  u32 szRow;              /* Byte available in aRow */Ÿ%#ifdef SQLITE_ENABLE_COLUMN_USED_MASKŸC  u64 maskUsed;           /* Mask of columns used by this cursor */¶#endif†ŸH  /* 2*nField extra array elements allocated for aType[], beyond the oneŸL  ** static element declared in the structure.  nField total array slots forŸ6  ** aType[] and nField+1 array slots for aOffset[] */ŸH  u32 aType[1];           /* Type values record decode.  MUST BE LAST */¢};††¢/*ŸM** A value for VdbeCursor.cacheStatus that means the cache is always invalid.¢*/µ#define CACHE_STALE 0†¢/*ŸH** When a sub-program is executed (OP_Program), a structure of this typeŸE** is allocated to store the current value of the program counter, asŸI** well as the current memory cell array and various other frame specificŸG** values stored in the Vdbe struct. When the sub-program is finished, ŸI** these values are copied back to the Vdbe from the VdbeFrame structure,ŸD** restoring the state of the VM to as it was before the sub-program≥** began executing.¢**ŸI** The memory for a VdbeFrame object is allocated and managed by a memoryŸI** cell in the parent (calling) frame. When the memory cell is deleted orŸJ** overwritten, the VdbeFrame object is not freed immediately. Instead, itŸM** is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrameŸK** list is deleted when the VM is reset in VdbeHalt(). The reason for doingŸK** this instead of deleting the VdbeFrame immediately is to avoid recursiveŸJ** calls to sqlite3VdbeMemRelease() when the memory cells belonging to theº** child frame are released.¢**ŸI** The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame isŸD** set to NULL if the currently executing frame is the main program.¢*/Ÿ#typedef struct VdbeFrame VdbeFrame;≤struct VdbeFrame {Ÿ8  Vdbe *v;                /* VM this frame belongs to */ŸO  VdbeFrame *pParent;     /* Parent of this frame, or NULL if parent is main */ŸE  Op *aOp;                /* Program instructions for parent frame */Ÿ@  i64 *anExec;            /* Event counters from parent frame */ŸF  Mem *aMem;              /* Array of memory cells for parent frame */ŸF  VdbeCursor **apCsr;     /* Array of Vdbe cursors for parent frame */Ÿ7  u8 *aOnce;              /* Bitmask used by OP_Once */Ÿ8  void *token;            /* Copy of SubProgram.token */ŸE  i64 lastRowid;          /* Last insert rowid (sqlite3.lastRowid) */ŸB  AuxData *pAuxData;      /* Linked list of auxdata allocations */Ÿ:  int nCursor;            /* Number of entries in apCsr */ŸI  int pc;                 /* Program Counter in parent (calling) frame */Ÿ1  int nOp;                /* Size of aOp array */Ÿ9  int nMem;               /* Number of entries in aMem */ŸF  int nChildMem;          /* Number of memory cells for child frame */ŸA  int nChildCsr;          /* Number of cursors for child frame */ŸD  int nChange;            /* Statement changes (Vdbe.nChange)     */Ÿ4  int nDbChange;          /* Value of db->nChange */¢};†ŸF#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))])†¢/*Ÿ@** Internally, the vdbe manipulates nearly all SQL values as MemŸJ** structures. Each Mem struct may cache multiple representations (string,Ÿ#** integer etc.) of the same value.¢*/∂struct sqlite3_value {≤  union MemValue {ŸK    double r;           /* Real value used when MEM_Real is set in flags */ŸM    i64 i;              /* Integer value used when MEM_Int is set in flags */ŸM    int nZero;          /* Extra zero bytes when MEM_Zero and MEM_Blob set */ŸM    const char *zPType; /* Pointer type when MEM_Term|MEM_Subtype|MEM_Null */Ÿ;    FuncDef *pDef;      /* Used only when flags==MEM_Agg */Ÿ>    RowSet *pRowSet;    /* Used only when flags==MEM_RowSet */Ÿ8    VdbeFrame *pFrame;  /* Used when flags==MEM_Frame */¶  } u;ŸP  u16 flags;          /* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */ŸG  u8  enc;            /* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */Ÿ2  u8  eSubtype;       /* Subtype for this value */ŸP  int n;              /* Number of characters in string value, excluding '\0' */Ÿ0  char *z;            /* String or BLOB value */Ÿ<  /* ShallowCopy only needs to copy the information above */ŸK  char *zMalloc;      /* Space to hold MEM_Str or MEM_Blob if szMalloc>0 */Ÿ:  int szMalloc;       /* Size of the zMalloc allocation */ŸN  u32 uTemp;          /* Transient storage for serial_type in OP_MakeRecord */Ÿ>  sqlite3 *db;        /* The associated database connection */ŸH  void (*xDel)(void*);/* Destructor for Mem.z - only valid if MEM_Dyn */≥#ifdef SQLITE_DEBUGŸD  Mem *pScopyFrom;    /* This Mem is a shallow copy of pScopyFrom */ŸB  void *pFiller;      /* So that sizeof(Mem) is a multiple of 8 */¶#endif¢};†¢/*ŸK** Size of struct Mem not including the Mem.zMalloc member or anything that´** follows.¢*/Ÿ)#define MEMCELLSIZE offsetof(Mem,zMalloc)†ŸE/* One or more of the following flags are set to indicate the validOKŸ9** representations of the value stored in the Mem struct.¢**ŸD** If the MEM_Null flag is set, then the value is an SQL NULL value.Ÿ=** For a pointer type created using sqlite3_bind_pointer() orŸL** sqlite3_result_pointer() the MEM_Term and MEM_Subtype flags are also set.¢**ŸK** If the MEM_Str flag is set then Mem.z points at a string representation.ŸC** Usually this is encoded in the same unicode encoding as the mainŸD** database (see below for exceptions). If the MEM_Term flag is alsoŸD** set, then the string is nul terminated. The MEM_Int and MEM_Real Ÿ+** flags may coexist with the MEM_Str flag.¢*/ŸA#define MEM_Null      0x0001   /* Value is NULL (or a pointer) */Ÿ6#define MEM_Str       0x0002   /* Value is a string */Ÿ8#define MEM_Int       0x0004   /* Value is an integer */Ÿ;#define MEM_Real      0x0008   /* Value is a real number */Ÿ4#define MEM_Blob      0x0010   /* Value is a BLOB */Ÿ:#define MEM_AffMask   0x001f   /* Mask of affinity bits */Ÿ=#define MEM_RowSet    0x0020   /* Value is a RowSet object */Ÿ@#define MEM_Frame     0x0040   /* Value is a VdbeFrame object */Ÿ7#define MEM_Undefined 0x0080   /* Value is undefined */ŸG#define MEM_Cleared   0x0100   /* NULL set by OP_Null, not from data */Ÿ6#define MEM_TypeMask  0xc1ff   /* Mask of type bits */††ŸF/* Whenever Mem contains a valid string or blob representation, one ofŸE** the following flags must be set to determine the memory managementŸC** policy for Mem.z.  The MEM_Term flag tells us whether or not theŸ&** string is \000 or \u0000 terminated¢*/ŸG#define MEM_Term      0x0200   /* String in Mem.z is zero terminated */ŸE#define MEM_Dyn       0x0400   /* Need to call Mem.xDel() on Mem.z */ŸD#define MEM_Static    0x0800   /* Mem.z points to a static string */ŸH#define MEM_Ephem     0x1000   /* Mem.z points to an ephemeral string */ŸL#define MEM_Agg       0x2000   /* Mem.z points to an agg function context */ŸP#define MEM_Zero      0x4000   /* Mem.i contains count of 0s appended to blob */Ÿ:#define MEM_Subtype   0x8000   /* Mem.eSubtype is valid */ª#ifdef SQLITE_OMIT_INCRBLOB±  #undef MEM_Zeroπ  #define MEM_Zero 0x0000¶#endif†ŸI/* Return TRUE if Mem X contains dynamically allocated content - anythingŸ0** that needs to be deallocated to avoid a leak.¢*/º#define VdbeMemDynamic(X)  \Ÿ:  (((X)->flags&(MEM_Agg|MEM_Dyn|MEM_RowSet|MEM_Frame))!=0)†¢/*ŸC** Clear any existing type flags from a Mem and replace them with f¢*/æ#define MemSetTypeFlag(p, f) \Ÿ9   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)†¢/*ŸE** Return true if a memory cell is not marked as invalid.  This macroŸ.** is for use inside assert() statements only.¢*/≥#ifdef SQLITE_DEBUGŸ6#define memIsValid(M)  ((M)->flags & MEM_Undefined)==0¶#endif†¢/*ŸA** Each auxiliary data pointer stored by a user defined function ŸH** implementation calling sqlite3_set_auxdata() is stored in an instanceŸE** of this structure. All such structures associated with a single VMŸI** are stored in a linked list headed at Vdbe.pAuxData. All are destroyedŸ)** when the VM is halted (if not before).¢*/∞struct AuxData {ŸP  int iAuxOp;                     /* Instruction number of OP_Function opcode */ŸC  int iAuxArg;                    /* Index of function argument. */Ÿ8  void *pAux;                     /* Aux data pointer */ŸC  void (*xDeleteAux)(void*);      /* Destructor for the aux data */Ÿ<  AuxData *pNextAux;              /* Next element in list */¢};†¢/*ŸG** The "context" argument for an installable function.  A pointer to anŸH** instance of this structure is the first argument to the routines usedø** implement the SQL functions.¢**ŸG** There is a typedef for this structure in sqlite.h.  So all routines,ŸL** even the public interface to SQLite, can use a pointer to this structure.ŸE** But this file is the only place where the internal details of this∑** structure are known.¢**ŸN** This structure is defined inside of vdbeInt.h because it uses substructuresŸ&** (Mem) which are only defined there.¢*/∏struct sqlite3_context {Ÿ?  Mem *pOut;              /* The return value is stored here */Ÿ?  FuncDef *pFunc;         /* Pointer to function information */ŸK  Mem *pMem;              /* Memory cell used to store aggregate context */Ÿ=  Vdbe *pVdbe;            /* The VM that owns this context */ŸA  int iOp;                /* Instruction number of OP_Function */ŸD  int isError;            /* Error code returned by the function. */Ÿ@  u8 skipFlag;            /* Skip accumulator loading if true */Ÿ3  u8 argc;                /* Number of arguments */Ÿ,  sqlite3_value *argv[1]; /* Argument set */¢};†ŸM/* A bitfield type for use inside of structures.  Always follow with :N whereª** N is the number of bits.¢*/Ÿ+typedef unsigned bft;  /* Bit Field Type */†Ÿ%typedef struct ScanStatus ScanStatus;≥struct ScanStatus {Ÿ;  int addrExplain;                /* OP_Explain for loop */ŸB  int addrLoop;                   /* Address of "loops" counter */ŸI  int addrVisit;                  /* Address of "rows visited" counter */ŸE  int iSelectID;                  /* The "Select-ID" for this loop */ŸF  LogEst nEst;                    /* Estimated output rows per loop */Ÿ>  char *zName;                    /* Name of table or index */¢};†¢/*ŸL** An instance of the virtual machine.  This structure contains the completeŸ ** state of the virtual machine.¢**ŸM** The "sqlite3_stmt" structure pointer that is returned by sqlite3_prepare()Ÿ8** is really a pointer to an instance of this structure.¢*/≠struct Vdbe {ŸP  sqlite3 *db;            /* The database connection that owns this statement */ŸJ  Vdbe *pPrev,*pNext;     /* Linked list of VDBEs with the same Vdbe.db */ŸH  Parse *pParse;          /* Parsing context used to create this Vdbe */Ÿ;  ynVar nVar;             /* Number of entries in aVar[] */Ÿ@  u32 magic;              /* Magic number for sanity checking */ŸN  int nMem;               /* Number of memory locations currently allocated */Ÿ:  int nCursor;            /* Number of slots in apCsr[] */ŸG  u32 cacheCtr;           /* VdbeCursor row cache generation counter */Ÿ3  int pc;                 /* The program counter */Ÿ/  int rc;                 /* Value to return */ŸJ  int nChange;            /* Number of db changes made since last reset */ŸN  int iStatement;         /* Statement number (or 0 if has not opened stmt) */ŸL  i64 iCurrentTime;       /* Value of julianday('now') for this statement */ŸE  i64 nFkConstraint;      /* Number of imm. FK constraints this VM */ŸL  i64 nStmtDefCons;       /* Number of def. constraints when stmt started */ŸP  i64 nStmtDefImmCons;    /* Number of def. imm constraints when stmt started */†ŸI  /* When allocating a new Vdbe object, all of the fields below should beŸ#  ** initialized to zero or NULL */†ŸK  Op *aOp;                /* Space to hold the virtual machine's program */Ÿ4  Mem *aMem;              /* The memory locations */ŸN  Mem **apArg;            /* Arguments to currently executing user function */Ÿ6  Mem *aColName;          /* Column names to return */Ÿ>  Mem *pResultSet;        /* Pointer to an array of results */Ÿ:  char *zErrMsg;          /* Error message written here */ŸN  VdbeCursor **apCsr;     /* One element of this array for each open cursor */ŸB  Mem *aVar;              /* Values for the OP_Variable opcode. */Ÿ1  VList *pVList;          /* Name of variables */π#ifndef SQLITE_OMIT_TRACEŸL  i64 startTime;          /* Time when query started - used for profiling */¶#endifŸE  int nOp;                /* Number of instructions in the program */≥#ifdef SQLITE_DEBUGŸJ  int rcApp;              /* errcode set by sqlite3_result_error_code() */¶#endifŸN  u16 nResColumn;         /* Number of columns in one row of the result set */ŸI  u8 errorAction;         /* Recovery action to do in case of an error */ŸO  u8 minWriteFileFormat;  /* Minimum file format for writable database files */Ÿ6  u8 prepFlags;           /* SQLITE_PREPARE_* flags */ŸE  bft expired:1;          /* True if the VM needs to be recompiled */ŸI  bft doingRerun:1;       /* True if rerunning after an auto-reprepare */ŸF  bft explain:2;          /* True if EXPLAIN present on SQL command */ŸA  bft changeCntOn:1;      /* True to update the change-counter */Ÿ=  bft runOnlyOnce:1;      /* Automatically expire on reset */Ÿ@  bft usesStmtJournal:1;  /* True if uses a statement journal */ŸE  bft readOnly:1;         /* True for statements that do not write */Ÿ=  bft bIsReader:1;        /* True for statements that read */ŸG  yDbMask btreeMask;      /* Bitmask of db->aDb[] entries referenced */ŸH  yDbMask lockMask;       /* Subset of btreeMask that requires a lock */ŸF  u32 aCounter[7];        /* Counters used by sqlite3_stmt_status() */ŸM  char *zSql;             /* Text of the SQL statement that generated this */Ÿ@  void *pFree;            /* Free this when deleting the vdbe */Ÿ,  VdbeFrame *pFrame;      /* Parent frame */ŸI  VdbeFrame *pDelFrame;   /* List of frame objects to free on VM reset */Ÿ?  int nFrame;             /* Number of frames in pFrame list */ŸD  u32 expmask;            /* Binding to these vars invalidates VM */ŸJ  SubProgram *pProgram;   /* Linked list of all sub-programs used by VM */ŸB  AuxData *pAuxData;      /* Linked list of auxdata allocations */Ÿ$#ifdef SQLITE_ENABLE_STMT_SCANSTATUSŸI  i64 *anExec;            /* Number of times each op has been executed */Ÿ2  int nScan;              /* Entries in aScan[] */ŸN  ScanStatus *aScan;      /* Scan definitions for sqlite3_stmt_scanstatus() */¶#endif¢};†¢/*Ÿ2** The following are allowed values for Vdbe.magic¢*/ŸG#define VDBE_MAGIC_INIT     0x16bceaa5    /* Building a VDBE program */ŸH#define VDBE_MAGIC_RUN      0x2df20da3    /* VDBE is ready to execute */ŸL#define VDBE_MAGIC_HALT     0x319c2973    /* VDBE has completed execution */ŸL#define VDBE_MAGIC_RESET    0x48fa9f76    /* Reset and ready to run again */ŸM#define VDBE_MAGIC_DEAD     0x5606c3c8    /* The VDBE has been deallocated */†¢/*Ÿ7** Structure used to store the context required by the Ÿ'** sqlite3_preupdate_*() API functions.¢*/≤struct PreUpdate {™  Vdbe *v;ŸF  VdbeCursor *pCsr;               /* Cursor to read old values from */ŸL  int op;                         /* One of SQLITE_INSERT, UPDATE, DELETE */Ÿ=  u8 *aRecord;                    /* old.* database record */≤  KeyInfo keyinfo;ŸE  UnpackedRecord *pUnpacked;      /* Unpacked version of aRecord[] */ŸH  UnpackedRecord *pNewUnpacked;   /* Unpacked version of new.* record */ŸA  int iNewReg;                    /* Register for new.* values */ŸF  i64 iKey1;                      /* First key value passed to hook */ŸG  i64 iKey2;                      /* Second key value passed to hook */Ÿ=  Mem *aNew;                      /* Array of new.* values */ŸL  Table *pTab;                    /* Schema object being upated */          ŸI  Index *pPk;                     /* PK index if pTab is WITHOUT ROWID */¢};†¢/*∂** Function prototypes¢*/Ÿ?SQLITE_PRIVATE void sqlite3VdbeError(Vdbe*, const char *, ...);Ÿ?SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);Ÿ#void sqliteVdbePopStack(Vdbe*,int);Ÿ?SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);Ÿ9SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor*);Ÿ2#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)Ÿ8SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE*, int, Op*);¶#endifŸ1SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32);Ÿ6SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8);Ÿ:SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem*, int, u32*);ŸCSQLITE_PRIVATE u32 sqlite3VdbeSerialPut(unsigned char*, Mem*, u32);ŸISQLITE_PRIVATE u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);ŸLSQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int);†ŸFint sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);ŸWSQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*);ŸBSQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);Ÿ*SQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*);Ÿ*SQLITE_PRIVATE int sqlite3VdbeList(Vdbe*);Ÿ*SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*);Ÿ9SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int);Ÿ.SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*);Ÿ8SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem*, const Mem*);ŸESQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);Ÿ3SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem*, Mem*);Ÿ4SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem*);ŸTSQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));Ÿ6SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64);Ÿ!#ifdef SQLITE_OMIT_FLOATING_POINTŸ7# define sqlite3VdbeMemSetDouble sqlite3VdbeMemSetInt64•#elseŸ<SQLITE_PRIVATE   void sqlite3VdbeMemSetDouble(Mem*, double);¶#endifŸWSQLITE_PRIVATE void sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*));Ÿ:SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem*,sqlite3*,u16);Ÿ0SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*);Ÿ8SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*,int);Ÿ2SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem*);Ÿ5SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem*);Ÿ9SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem*, u8, u8);Ÿ-SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*);Ÿ2SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*);Ÿ1SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*);Ÿ=SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem*, int ifNull);Ÿ5SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*);Ÿ/SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*);Ÿ0SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*);Ÿ3SQLITE_PRIVATE void sqlite3VdbeMemCast(Mem*,u8,u8);ŸCSQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*);Ÿ2SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p);Ÿ:SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*);Ÿ2SQLITE_PRIVATE const char *sqlite3OpcodeName(int);ŸFSQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);ŸBSQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int n);Ÿ:SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *, int);Ÿ7SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame*);Ÿ8SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *);Ÿ##ifdef SQLITE_ENABLE_PREUPDATE_HOOKŸ_SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(Vdbe*,VdbeCursor*,int,const char*,Table*,i64,int);¶#endifŸ5SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p);†ŸGSQLITE_PRIVATE int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);ŸDSQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);ŸDSQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);ŸFSQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);ŸHSQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *);ŸFSQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *, int *);ŸESQLITE_PRIVATE int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);ŸSSQLITE_PRIVATE int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);†Ÿ'#if !defined(SQLITE_OMIT_SHARED_CACHE) Ÿ.SQLITE_PRIVATE   void sqlite3VdbeEnter(Vdbe*);•#elseº# define sqlite3VdbeEnter(X)¶#endif†Ÿ=#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0Ÿ.SQLITE_PRIVATE   void sqlite3VdbeLeave(Vdbe*);•#elseº# define sqlite3VdbeLeave(X)¶#endif†≥#ifdef SQLITE_DEBUGŸ<SQLITE_PRIVATE void sqlite3VdbeMemAboutToChange(Vdbe*,Mem*);Ÿ7SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem*);¶#endif†ø#ifndef SQLITE_OMIT_FOREIGN_KEYŸ3SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *, int);•#elseŸ"# define sqlite3VdbeCheckFk(p,i) 0¶#endif†≥#ifdef SQLITE_DEBUGŸ1SQLITE_PRIVATE   void sqlite3VdbePrintSql(Vdbe*);ŸGSQLITE_PRIVATE   void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf);¶#endifπ#ifndef SQLITE_OMIT_UTF16Ÿ7SQLITE_PRIVATE   int sqlite3VdbeMemTranslate(Mem*, u8);Ÿ8SQLITE_PRIVATE   int sqlite3VdbeMemHandleBom(Mem *pMem);¶#endif†º#ifndef SQLITE_OMIT_INCRBLOBŸ5SQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);ŸM  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)•#elseŸ/  #define sqlite3VdbeMemExpandBlob(x) SQLITE_OKŸ!  #define ExpandBlob(P) SQLITE_OK¶#endif†Ÿ'#endif /* !defined(SQLITE_VDBEINT_H) */†ŸO/************** End of vdbeInt.h *********************************************/ŸO/************** Continuing where we left off in status.c *********************/†¢/*Ÿ3** Variables in which to record status information.¢*/¥#if SQLITE_PTRSIZE>4Ÿ+typedef sqlite3_int64 sqlite3StatValueType;•#elseŸ!typedef u32 sqlite3StatValueType;¶#endifŸ/typedef struct sqlite3StatType sqlite3StatType;Ÿ*static SQLITE_WSD struct sqlite3StatType {Ÿ9  sqlite3StatValueType nowValue[10];  /* Current value */Ÿ9  sqlite3StatValueType mxValue[10];   /* Maximum value */ø} sqlite3Stat = { {0,}, {0,} };†¢/*ŸI** Elements of sqlite3Stat[] are protected by either the memory allocatorŸI** mutex, or by the pcache1 mutex.  The following array determines which.¢*/Ÿ!static const char statMutex[] = {Ÿ%  0,  /* SQLITE_STATUS_MEMORY_USED */Ÿ(  1,  /* SQLITE_STATUS_PAGECACHE_USED */Ÿ,  1,  /* SQLITE_STATUS_PAGECACHE_OVERFLOW */Ÿ&  0,  /* SQLITE_STATUS_SCRATCH_USED */Ÿ*  0,  /* SQLITE_STATUS_SCRATCH_OVERFLOW */Ÿ%  0,  /* SQLITE_STATUS_MALLOC_SIZE */Ÿ&  0,  /* SQLITE_STATUS_PARSER_STACK */Ÿ(  1,  /* SQLITE_STATUS_PAGECACHE_SIZE */Ÿ&  0,  /* SQLITE_STATUS_SCRATCH_SIZE */Ÿ&  0,  /* SQLITE_STATUS_MALLOC_COUNT */¢};††Ÿ=/* The "wsdStat" macro will resolve to the status informationŸG** state vector.  If writable static data is unsupported on the target,ŸF** we have to locate the state vector at run-time.  In the more commonŸK** case where writable static data is supported, wsdStat can refer directlyŸ4** to the "sqlite3Stat" state vector declared above.¢*/∂#ifdef SQLITE_OMIT_WSDŸO# define wsdStatInit  sqlite3StatType *x = &GLOBAL(sqlite3StatType,sqlite3Stat)µ# define wsdStat x[0]•#else¥# define wsdStatInitº# define wsdStat sqlite3Stat¶#endif†¢/*ŸC** Return the current value of a status parameter.  The caller mustŸ$** be holding the appropriate mutex.¢*/Ÿ8SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int op){Æ  wsdStatInit;Ÿ4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );Ÿ-  assert( op>=0 && op<ArraySize(statMutex) );ŸB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ŸE                                           : sqlite3MallocMutex()) );æ  return wsdStat.nowValue[op];°}†¢/*ŸC** Add N to the value of a status record.  The caller must hold theŸ8** appropriate mutex.  (Locking is checked by assert()).¢**ŸG** The StatusUp() routine can accept positive or negative values for N.ŸI** The value of N is added to the current status value and the high-waterŸ!** mark is adjusted if necessary.¢**ŸI** The StatusDown() routine lowers the current value by N.  The highwaterŸ?** mark is unchanged.  N must be non-negative for StatusDown().¢*/Ÿ3SQLITE_PRIVATE void sqlite3StatusUp(int op, int N){Æ  wsdStatInit;Ÿ4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );Ÿ-  assert( op>=0 && op<ArraySize(statMutex) );ŸB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ŸE                                           : sqlite3MallocMutex()) );º  wsdStat.nowValue[op] += N;Ÿ1  if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){Ÿ/    wsdStat.mxValue[op] = wsdStat.nowValue[op];£  }°}Ÿ5SQLITE_PRIVATE void sqlite3StatusDown(int op, int N){Æ  wsdStatInit;±  assert( N>=0 );Ÿ-  assert( op>=0 && op<ArraySize(statMutex) );ŸB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ŸE                                           : sqlite3MallocMutex()) );Ÿ4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );º  wsdStat.nowValue[op] -= N;°}†¢/*Ÿ*** Adjust the highwater mark if necessary.Ÿ.** The caller must hold the appropriate mutex.¢*/Ÿ:SQLITE_PRIVATE void sqlite3StatusHighwater(int op, int X){Ÿ   sqlite3StatValueType newValue;Æ  wsdStatInit;±  assert( X>=0 );Ÿ%  newValue = (sqlite3StatValueType)X;Ÿ4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );Ÿ-  assert( op>=0 && op<ArraySize(statMutex) );ŸB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ŸE                                           : sqlite3MallocMutex()) );Ÿ'  assert( op==SQLITE_STATUS_MALLOC_SIZEŸ-          || op==SQLITE_STATUS_PAGECACHE_SIZEŸ.          || op==SQLITE_STATUS_PARSER_STACK );Ÿ%  if( newValue>wsdStat.mxValue[op] ){Ÿ#    wsdStat.mxValue[op] = newValue;£  }°}†¢/*º** Query status information.¢*/Ÿ SQLITE_API int sqlite3_status64(©  int op,∫  sqlite3_int64 *pCurrent,º  sqlite3_int64 *pHighwater,Ø  int resetFlag¢){∏  sqlite3_mutex *pMutex;Æ  wsdStatInit;Ÿ0  if( op<0 || op>=ArraySize(wsdStat.nowValue) ){æ    return SQLITE_MISUSE_BKPT;£  }æ#ifdef SQLITE_ENABLE_API_ARMORŸ?  if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;¶#endifŸH  pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();æ  sqlite3_mutex_enter(pMutex);Ÿ#  *pCurrent = wsdStat.nowValue[op];Ÿ$  *pHighwater = wsdStat.mxValue[op];≤  if( resetFlag ){Ÿ/    wsdStat.mxValue[op] = wsdStat.nowValue[op];£  }æ  sqlite3_mutex_leave(pMutex);Ÿ?  (void)pMutex;  /* Prevent warning when SQLITE_THREADSAFE=0 */≥  return SQLITE_OK;°}ŸUSQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){Ÿ$  sqlite3_int64 iCur = 0, iHwtr = 0;©  int rc;æ#ifdef SQLITE_ENABLE_API_ARMORŸ?  if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;¶#endifŸ6  rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);Æ  if( rc==0 ){∫    *pCurrent = (int)iCur;Ω    *pHighwater = (int)iHwtr;£  }¨  return rc;°}†¢/*ŸA** Return the number of LookasideSlot elements on the linked list¢*/Ÿ1static u32 countLookasideSlots(LookasideSlot *p){Æ  u32 cnt = 0;≠  while( p ){±    p = p->pNext;™    cnt++;£  }≠  return cnt;°}†¢/*ŸE** Count the number of slots of lookaside memory that are outstanding¢*/ŸFSQLITE_PRIVATE int sqlite3LookasideUsed(sqlite3 *db, int *pHighwater){Ÿ7  u32 nInit = countLookasideSlots(db->lookaside.pInit);Ÿ7  u32 nFree = countLookasideSlots(db->lookaside.pFree);Ÿ=  if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;Ÿ-  return db->lookaside.nSlot - (nInit+nFree);°}†¢/*Ÿ<** Query status information for a single database connection¢*/Ÿ!SQLITE_API int sqlite3_db_status(ŸM  sqlite3 *db,          /* The database connection whose status is desired */Ÿ)  int op,               /* Status verb */Ÿ6  int *pCurrent,        /* Write current value here */Ÿ8  int *pHighwater,      /* Write high-water mark here */Ÿ;  int resetFlag         /* Reset high-water mark if true */¢){Ÿ)  int rc = SQLITE_OK;   /* Return code */æ#ifdef SQLITE_ENABLE_API_ARMORŸA  if( !sqlite3SafetyCheckOk(db) || pCurrent==0|| pHighwater==0 ){æ    return SQLITE_MISUSE_BKPT;£  }¶#endifŸ!  sqlite3_mutex_enter(db->mutex);Ø  switch( op ){Ÿ*    case SQLITE_DBSTATUS_LOOKASIDE_USED: {Ÿ7      *pCurrent = sqlite3LookasideUsed(db, pHighwater);∂      if( resetFlag ){Ÿ/        LookasideSlot *p = db->lookaside.pFree;∞        if( p ){Ÿ)          while( p->pNext ) p = p->pNext;Ÿ)          p->pNext = db->lookaside.pInit;Ÿ4          db->lookaside.pInit = db->lookaside.pFree;Ÿ"          db->lookaside.pFree = 0;©        }ß      }¨      break;•    }†Ÿ'    case SQLITE_DBSTATUS_LOOKASIDE_HIT:Ÿ-    case SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE:Ÿ/    case SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: {Ÿ4      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_HIT );Ÿ:      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE );Ÿ:      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL );Ÿ6      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 );Ÿ5      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 );¥      *pCurrent = 0;ŸM      *pHighwater = db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT];∂      if( resetFlag ){ŸE        db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT] = 0;ß      }¨      break;•    }†ß    /* ŸF    ** Return an approximation for the amount of memory currently usedŸH    ** by all pagers associated with the given database connection.  TheŸ=    ** highwater mark is meaningless and is returned as zero.¶    */Ÿ+    case SQLITE_DBSTATUS_CACHE_USED_SHARED:Ÿ&    case SQLITE_DBSTATUS_CACHE_USED: {∏      int totalUsed = 0;¨      int i;ø      sqlite3BtreeEnterAll(db);ø      for(i=0; i<db->nDb; i++){Ÿ$        Btree *pBt = db->aDb[i].pBt;≤        if( pBt ){Ÿ1          Pager *pPager = sqlite3BtreePager(pBt);Ÿ2          int nByte = sqlite3PagerMemUsed(pPager);Ÿ6          if( op==SQLITE_DBSTATUS_CACHE_USED_SHARED ){Ÿ=            nByte = nByte / sqlite3BtreeConnectionCount(pBt);´          }Ω          totalUsed += nByte;©        }ß      }ø      sqlite3BtreeLeaveAll(db);º      *pCurrent = totalUsed;∂      *pHighwater = 0;¨      break;•    }†¶    /*ŸG    ** *pCurrent gets an accurate estimate of the amount of memory usedŸJ    ** to store the schema for all databases (main, temp, and any ATTACHedŸ.    ** databases.  *pHighwater is set to zero.¶    */Ÿ'    case SQLITE_DBSTATUS_SCHEMA_USED: {ŸG      int i;                      /* Used to iterate through schemas */ŸG      int nByte = 0;              /* Used to accumulate return value */†ø      sqlite3BtreeEnterAll(db);Ÿ       db->pnBytesFreed = &nByte;ø      for(i=0; i<db->nDb; i++){Ÿ-        Schema *pSchema = db->aDb[i].pSchema;Ÿ!        if( ALWAYS(pSchema!=0) ){∂          HashElem *p;†ŸG          nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (Ÿ%              pSchema->tblHash.count Ÿ%            + pSchema->trigHash.countŸ$            + pSchema->idxHash.countŸ%            + pSchema->fkeyHash.count¨          );Ÿ6          nByte += sqlite3_msize(pSchema->tblHash.ht);Ÿ7          nByte += sqlite3_msize(pSchema->trigHash.ht);Ÿ6          nByte += sqlite3_msize(pSchema->idxHash.ht);Ÿ7          nByte += sqlite3_msize(pSchema->fkeyHash.ht);†ŸM          for(p=sqliteHashFirst(&pSchema->trigHash); p; p=sqliteHashNext(p)){ŸB            sqlite3DeleteTrigger(db, (Trigger*)sqliteHashData(p));´          }ŸL          for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){Ÿ?            sqlite3DeleteTable(db, (Table *)sqliteHashData(p));´          }©        }ß      }ª      db->pnBytesFreed = 0;ø      sqlite3BtreeLeaveAll(db);†∂      *pHighwater = 0;∏      *pCurrent = nByte;¨      break;•    }†¶    /*ŸG    ** *pCurrent gets an accurate estimate of the amount of memory usedŸ(    ** to store all prepared statements.Ÿ"    ** *pHighwater is set to zero.¶    */Ÿ%    case SQLITE_DBSTATUS_STMT_USED: {ŸC      struct Vdbe *pVdbe;         /* Used to iterate through VMs */ŸG      int nByte = 0;              /* Used to accumulate return value */†Ÿ       db->pnBytesFreed = &nByte;Ÿ6      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){Ÿ*        sqlite3VdbeClearObject(db, pVdbe);Ÿ!        sqlite3DbFree(db, pVdbe);ß      }ª      db->pnBytesFreed = 0;†Ÿ0      *pHighwater = 0;  /* IMP: R-64479-57858 */∏      *pCurrent = nByte;†¨      break;•    }†¶    /*ŸI    ** Set *pCurrent to the total cache hits or misses encountered by allŸM    ** pagers the database handle is connected to. *pHighwater is always set Ø    ** to zero.¶    */Ÿ%    case SQLITE_DBSTATUS_CACHE_SPILL:Ÿ)      op = SQLITE_DBSTATUS_CACHE_WRITE+1;Ÿ+      /* Fall through into the next case */Ÿ#    case SQLITE_DBSTATUS_CACHE_HIT:Ÿ$    case SQLITE_DBSTATUS_CACHE_MISS:Ÿ&    case SQLITE_DBSTATUS_CACHE_WRITE:{¨      int i;≥      int nRet = 0;ŸH      assert( SQLITE_DBSTATUS_CACHE_MISS==SQLITE_DBSTATUS_CACHE_HIT+1 );ŸI      assert( SQLITE_DBSTATUS_CACHE_WRITE==SQLITE_DBSTATUS_CACHE_HIT+2 );†ø      for(i=0; i<db->nDb; i++){Ω        if( db->aDb[i].pBt ){Ÿ<          Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);Ÿ>          sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);©        }ß      }Ÿ/      *pHighwater = 0; /* IMP: R-42420-56072 */Ÿ/                       /* IMP: R-54100-20147 */Ÿ/                       /* IMP: R-29431-39229 */∑      *pCurrent = nRet;¨      break;•    }†ŸI    /* Set *pCurrent to non-zero if there are unresolved deferred foreignŸM    ** key constraints.  Set *pCurrent to zero if all foreign key constraintsŸC    ** have been satisfied.  The *pHighwater is always set to zero.¶    */Ÿ(    case SQLITE_DBSTATUS_DEFERRED_FKS: {Ÿ0      *pHighwater = 0;  /* IMP: R-11967-56545 */Ÿ@      *pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;¨      break;•    }†Æ    default: {∏      rc = SQLITE_ERROR;•    }£  }Ÿ!  sqlite3_mutex_leave(db->mutex);¨  return rc;°}†ŸO/************** End of status.c **********************************************/ŸO/************** Begin file date.c ********************************************/¢/*≤** 2003 October 31¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸB** This file contains the C functions that implement date and time∫** functions for SQLite.  ¢**Ÿ@** There is only one exported symbol in this file - the functionŸF** sqlite3RegisterDateTimeFunctions() found at the bottom of the file.Ÿ!** All other code has file scope.¢**ŸC** SQLite processes all times and dates as julian day numbers.  TheŸ>** dates and times are stored as the number of days since noonŸD** in Greenwich on November 24, 4714 B.C. according to the Gregorian¥** calendar system. ¢**Ÿ&** 1970-01-01 00:00:00 is JD 2440587.5Ÿ&** 2000-01-01 00:00:00 is JD 2451544.5¢**ŸI** This implementation requires years to be expressed as a 4-digit numberŸD** which means that only dates between 0000-01-01 and 9999-12-31 canŸD** be represented, even though julian day numbers allow a much wider≤** range of dates.¢**ŸA** The Gregorian calendar system is used for all dates and times,ŸF** even those that predate the Gregorian calendar.  Historians usuallyŸE** use the julian calendar for dates prior to 1582-10-15 and for someŸE** dates afterwards, depending on locale.  Beware of this difference.¢**ŸB** The conversion algorithms are implemented based on descriptionsπ** in the following text:¢**≤**      Jean MeeusŸ2**      Astronomical Algorithms, 2nd Edition, 1998∫**      ISBN 0-943396-61-1∫**      Willmann-Bell, IncŸ **      Richmond, Virginia (USA)¢*/º/* #include "sqliteInt.h" */π/* #include <stdlib.h> */π/* #include <assert.h> */±#include <time.h>†Ÿ"#ifndef SQLITE_OMIT_DATETIME_FUNCS†¢/*ŸB** The MSVC CRT on Windows CE may not have a localtime() function.Ÿ>** So declare a substitute.  The substitute function itself isπ** defined in "os_win.c".¢*/Ÿ?#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) && \ŸG    (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)Ÿ-struct tm *__cdecl localtime(const time_t *);¶#endif†¢/*Ÿ2** A structure for holding a single date and time.¢*/Ÿ!typedef struct DateTime DateTime;±struct DateTime {Ÿ@  sqlite3_int64 iJD;  /* The julian day number times 86400000 */Ÿ0  int Y, M, D;        /* Year, month, and day */Ÿ,  int h, m;           /* Hour and minutes */Ÿ6  int tz;             /* Timezone offset in minutes */Ÿ#  double s;           /* Seconds */Ÿ4  char validJD;       /* True (1) if iJD is valid */Ÿ9  char rawS;          /* Raw numeric value stored in s */Ÿ7  char validYMD;      /* True (1) if Y,M,D are valid */Ÿ7  char validHMS;      /* True (1) if h,m,s are valid */Ÿ3  char validTZ;       /* True (1) if tz is valid */Ÿ7  char tzSet;         /* Timezone was set explicitly */Ÿ4  char isError;       /* An overflow has occurred */¢};††¢/*ŸF** Convert zDate into one or more integers according to the conversionµ** specifier zFormat.¢**ŸI** zFormat[] contains 4 characters for each integer converted, except forŸH** the last integer which is specified by three characters.  The meaningŸ1** of a four-character format specifiers ABCD is:¢**Ÿ;**    A:   number of digits to convert.  Always "2" or "4".Ÿ-**    B:   minimum value.  Always "0" or "1".Ÿ%**    C:   maximum value, decoded as:≥**           a:  12≥**           b:  14≥**           c:  24≥**           d:  31≥**           e:  59µ**           f:  9999ŸC**    D:   the separator character, or \000 to indicate this is theŸ"**         last number to convert.¢**ŸG** Example:  To translate an ISO-8601 date YYYY-MM-DD, the format wouldŸL** be "40f-21a-20c".  The "40f-" indicates the 4-digit year followed by "-".ŸO** The "21a-" indicates the 2-digit month followed by "-".  The "20c" indicatesŸ8** the 2-digit day which is the last integer in the set.¢**Ÿ=** The function returns the number of successful conversions.¢*/ŸBstatic int getDigits(const char *zDate, const char *zFormat, ...){Ÿ@  /* The aMx[] array translates the 3rd character of each formatŸ8  ** spec into a max size:    a   b   c   d   e     f */Ÿ8  static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };≠  va_list ap;Æ  int cnt = 0;≠  char nextC;∏  va_start(ap, zFormat);•  do{æ    char N = zFormat[0] - '0';Ÿ     char min = zFormat[1] - '0';∞    int val = 0;¨    u16 max;†Ÿ1    assert( zFormat[2]>='a' && zFormat[2]<='f' );Ÿ     max = aMx[zFormat[2] - 'a'];∑    nextC = zFormat[3];¨    val = 0;±    while( N-- ){Ÿ$      if( !sqlite3Isdigit(*zDate) ){ª        goto end_getDigits;ß      }Ÿ"      val = val*10 + *zDate - '0';Æ      zDate++;•    }ŸF    if( val<(int)min || val>(int)max || (nextC!=0 && nextC!=*zDate) ){π      goto end_getDigits;•    }ª    *va_arg(ap,int*) = val;¨    zDate++;™    cnt++;±    zFormat += 4;≤  }while( nextC );Æend_getDigits:≠  va_end(ap);≠  return cnt;°}†¢/*Ÿ8** Parse a timezone extension on the end of a date-time.Ÿ ** The extension is of the form:¢**¥**        (+/-)HH:MM¢**∫** Or the "zulu" notation:¢**´**        Z¢**Ÿ:** If the parse is successful, write the number of minutesŸ>** of change in p->tz and return 0.  If a parser error occurs,≥** return non-zero.¢**Ÿ2** A missing specifier is not considered an error.¢*/Ÿ9static int parseTimezone(const char *zDate, DateTime *p){Æ  int sgn = 0;Ø  int nHr, nMn;®  int c;Ÿ-  while( sqlite3Isspace(*zDate) ){ zDate++; }¨  p->tz = 0;≠  c = *zDate;Ø  if( c=='-' ){≠    sgn = -1;µ  }else if( c=='+' ){≠    sgn = +1;ø  }else if( c=='Z' || c=='z' ){¨    zDate++;≥    goto zulu_time;®  }else{∞    return c!=0;£  }™  zDate++;Ÿ3  if( getDigits(zDate, "20b:20e", &nHr, &nMn)!=2 ){≠    return 1;£  }≠  zDate += 5;Ω  p->tz = sgn*(nMn + nHr*60);™zulu_time:Ÿ-  while( sqlite3Isspace(*zDate) ){ zDate++; }Ø  p->tzSet = 1;≥  return *zDate!=0;°}†¢/*Ÿ>** Parse times of the form HH:MM or HH:MM:SS or HH:MM:SS.FFFF.Ÿ9** The HH, MM, and SS must each be exactly 2 digits.  TheŸ5** fractional seconds FFFF can be one or more digits.¢**Ÿ9** Return 1 if there is a parsing error and 0 on success.¢*/Ÿ7static int parseHhMmSs(const char *zDate, DateTime *p){Æ  int h, m, s;≤  double ms = 0.0;Ÿ/  if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){≠    return 1;£  }≠  zDate += 5;¥  if( *zDate==':' ){¨    zDate++;Ÿ)    if( getDigits(zDate, "20e", &s)!=1 ){Ø      return 1;•    }Ø    zDate += 2;Ÿ2    if( *zDate=='.' && sqlite3Isdigit(zDate[1]) ){∫      double rScale = 1.0;Æ      zDate++;Ÿ&      while( sqlite3Isdigit(*zDate) ){Ÿ$        ms = ms*10.0 + *zDate - '0';∑        rScale *= 10.0;∞        zDate++;ß      }≥      ms /= rScale;•    }®  }else{™    s = 0;£  }±  p->validJD = 0;Æ  p->rawS = 0;≤  p->validHMS = 1;´  p->h = h;´  p->m = m;∞  p->s = s + ms;Ÿ)  if( parseTimezone(zDate, p) ) return 1;æ  p->validTZ = (p->tz!=0)?1:0;´  return 0;°}†¢/*Ÿ0** Put the DateTime object into its error state.¢*/Ÿ'static void datetimeError(DateTime *p){ª  memset(p, 0, sizeof(*p));±  p->isError = 1;°}†¢/*ŸD** Convert from YYYY-MM-DD HH:MM:SS to julian day.  We always assumeŸ>** that the YYYY-MM-DD is according to the Gregorian calendar.¢**º** Reference:  Meeus page 61¢*/Ÿ#static void computeJD(DateTime *p){º  int Y, M, D, A, B, X1, X2;†∫  if( p->validJD ) return;¥  if( p->validYMD ){≠    Y = p->Y;≠    M = p->M;≠    D = p->D;®  }else{Ÿ<    Y = 2000;  /* If no YMD specified, assume 2000-Jan-01 */™    M = 1;™    D = 1;£  }Ÿ%  if( Y<-4713 || Y>9999 || p->rawS ){µ    datetimeError(p);´    return;£  }≠  if( M<=2 ){®    Y--;¨    M += 12;£  }¨  A = Y/100;¥  B = 2 - A + (A/4);∫  X1 = 36525*(Y+4716)/100;∫  X2 = 306001*(M+1)/10000;ŸC  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);±  p->validJD = 1;¥  if( p->validHMS ){ŸE    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);µ    if( p->validTZ ){º      p->iJD -= p->tz*60000;∂      p->validYMD = 0;∂      p->validHMS = 0;µ      p->validTZ = 0;•    }£  }°}†¢/*∫** Parse dates of the form¢**æ**     YYYY-MM-DD HH:MM:SS.FFF∫**     YYYY-MM-DD HH:MM:SS∑**     YYYY-MM-DD HH:MM±**     YYYY-MM-DD¢**Ÿ<** Write the result into the DateTime structure and return 0Ÿ<** on success and 1 if the input string is not a well-formed®** date.¢*/Ÿ9static int parseYyyyMmDd(const char *zDate, DateTime *p){≥  int Y, M, D, neg;†∂  if( zDate[0]=='-' ){¨    zDate++;¨    neg = 1;®  }else{¨    neg = 0;£  }Ÿ7  if( getDigits(zDate, "40f-21a-21d", &Y, &M, &D)!=3 ){≠    return 1;£  }Æ  zDate += 10;ŸA  while( sqlite3Isspace(*zDate) || 'T'==*(u8*)zDate ){ zDate++; }Ÿ!  if( parseHhMmSs(zDate, p)==0 ){π    /* We got the time */∏  }else if( *zDate==0 ){¥    p->validHMS = 0;®  }else{≠    return 1;£  }±  p->validJD = 0;≤  p->validYMD = 1;∂  p->Y = neg ? -Y : Y;´  p->M = M;´  p->D = D;≥  if( p->validTZ ){±    computeJD(p);£  }´  return 0;°}†¢/*Ÿ8** Set the time to the current time reported by the VFS.¢**ø** Return the number of errors.¢*/ŸGstatic int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){Ÿ+  p->iJD = sqlite3StmtCurrentTime(context);±  if( p->iJD>0 ){≥    p->validJD = 1;≠    return 0;®  }else{≠    return 1;£  }°}†¢/*ŸF** Input "r" is a numeric quantity which might be a julian day number,ŸD** or the number of seconds since 1970.  If the value if r is withinŸD** range of a julian day number, install it as such and set validJD.ŸJ** If the value is a valid unix timestamp, put it in p->s and set p->rawS.¢*/Ÿ4static void setRawDateNumber(DateTime *p, double r){´  p->s = r;Æ  p->rawS = 1;æ  if( r>=0.0 && r<5373484.5 ){Ÿ1    p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);≥    p->validJD = 1;£  }°}†¢/*ŸF** Attempt to parse the given string into a julian day number.  Return∏** the number of errors.¢**Ÿ;** The following are acceptable forms for the input string:¢**Ÿ)**      YYYY-MM-DD HH:MM:SS.FFF  +/-HH:MM∞**      DDDD.DD ´**      now¢**ŸF** In the first form, the +/-HH:MM is always optional.  The fractionalŸC** seconds extension (the ".FFF") is optional.  The seconds portionŸC** (":SS.FFF") is option.  The year and date can be omitted as longŸE** as there is a time string.  The time string can be omitted as longø** as there is a year and date.¢*/ªstatic int parseDateOrTime(º  sqlite3_context *context, µ  const char *zDate, ≠  DateTime *p¢){´  double r;Ÿ"  if( parseYyyyMmDd(zDate,p)==0 ){≠    return 0;Ÿ'  }else if( parseHhMmSs(zDate, p)==0 ){≠    return 0;ŸL  }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){Ÿ,    return setDateTimeToCurrent(context, p);ŸJ  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8) ){ª    setRawDateNumber(p, r);≠    return 0;£  }´  return 1;°}†ŸH/* The julian day number for 9999-12-31 23:59:59.999 is 5373484.4999999.ŸJ** Multiplying this by 86400000 gives 464269060799999 as the maximum value¥** for DateTime.iJD.¢**ŸK** But some older compilers (ex: gcc 4.2.1 on older Macs) cannot deal with Ÿ9** such a large integer literal, so we have to encode it.¢*/Ÿ>#define INT_464269060799999  ((((i64)0x1a640)<<32)|0x1072fdff)†¢/*Ÿ>** Return TRUE if the given julian day number is within range.¢**Ÿ-** The input is the JulianDay times 86400000.¢*/Ÿ-static int validJulianDay(sqlite3_int64 iJD){Ÿ,  return iJD>=0 && iJD<=INT_464269060799999;°}†¢/*Ÿ?** Compute the Year, Month, and Day from the julian day number.¢*/Ÿ$static void computeYMD(DateTime *p){ª  int Z, A, B, C, D, E, X1;ª  if( p->validYMD ) return;¥  if( !p->validJD ){∞    p->Y = 2000;≠    p->M = 1;≠    p->D = 1;Ÿ&  }else if( !validJulianDay(p->iJD) ){µ    datetimeError(p);´    return;®  }else{Ÿ,    Z = (int)((p->iJD + 43200000)/86400000);Ÿ)    A = (int)((Z - 1867216.25)/36524.25);∫    A = Z + 1 + A - (A/4);±    B = A + 1524;Ÿ"    C = (int)((B - 122.1)/365.25);æ    D = (36525*(C&32767))/100;Ω    E = (int)((B-D)/30.6001);∫    X1 = (int)(30.6001*E);∂    p->D = B - D - X1;Ω    p->M = E<14 ? E-1 : E-13;Ÿ(    p->Y = p->M>2 ? C - 4716 : C - 4715;£  }≤  p->validYMD = 1;°}†¢/*ŸD** Compute the Hour, Minute, and Seconds from the julian day number.¢*/Ÿ$static void computeHMS(DateTime *p){®  int s;ª  if( p->validHMS ) return;Ø  computeJD(p);Ÿ,  s = (int)((p->iJD + 43200000) % 86400000);≤  p->s = s/1000.0;∞  s = (int)p->s;¨  p->s -= s;∞  p->h = s/3600;±  s -= p->h*3600;Æ  p->m = s/60;∂  p->s += s - p->m*60;Æ  p->rawS = 0;≤  p->validHMS = 1;°}†¢/*ª** Compute both YMD and HMS¢*/Ÿ(static void computeYMD_HMS(DateTime *p){∞  computeYMD(p);∞  computeHMS(p);°}†¢/*Ÿ#** Clear the YMD and HMS and the TZ¢*/Ÿ)static void clearYMD_HMS_TZ(DateTime *p){≤  p->validYMD = 0;≤  p->validHMS = 0;±  p->validTZ = 0;°}†Ω#ifndef SQLITE_OMIT_LOCALTIME¢/*ŸG** On recent Windows platforms, the localtime_s() function is availableŸ@** as part of the "Secure CRT". It is essentially equivalent to ŸG** localtime_r() available under most POSIX platforms, except that the Ÿ'** order of the parameters is reversed.¢**ŸD** See http://msdn.microsoft.com/en-us/library/a442x3ye(VS.80).aspx.¢**ŸF** If the user has not indicated to use localtime_r() or localtime_s()Ÿ>** already, check for an MSVC build environment that provides ±** localtime_s().¢*/Ÿ,#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S \Ÿ<    && defined(_MSC_VER) && defined(_CRT_INSECURE_DEPRECATE)∏#undef  HAVE_LOCALTIME_S∫#define HAVE_LOCALTIME_S 1¶#endif†¢/*ŸI** The following routine implements the rough equivalent of localtime_r()ŸC** using whatever operating-system specific localtime facility thatŸ7** is available.  This routine returns 0 on success andŸ!** non-zero on any kind of error.¢**ŸH** If the sqlite3GlobalConfig.bLocaltimeFault variable is true then thisº** routine will always fail.¢**ŸD** EVIDENCE-OF: R-62172-00036 In this implementation, the standard CŸI** library function localtime_r() is used to assist in the calculation ofÆ** local time.¢*/Ÿ2static int osLocaltime(time_t *t, struct tm *pTm){©  int rc;Ÿ*#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S∞  struct tm *pX;∑#if SQLITE_THREADSAFE>0ŸG  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);¶#endifΩ  sqlite3_mutex_enter(mutex);¥  pX = localtime(t);π#ifndef SQLITE_UNTESTABLEŸ3  if( sqlite3GlobalConfig.bLocaltimeFault ) pX = 0;¶#endif∂  if( pX ) *pTm = *pX;Ω  sqlite3_mutex_leave(mutex);≠  rc = pX==0;•#elseπ#ifndef SQLITE_UNTESTABLEŸ5  if( sqlite3GlobalConfig.bLocaltimeFault ) return 1;¶#endif¥#if HAVE_LOCALTIME_Ræ  rc = localtime_r(t, pTm)==0;•#elseª  rc = localtime_s(pTm, t);Ω#endif /* HAVE_LOCALTIME_R */Ÿ1#endif /* HAVE_LOCALTIME_R || HAVE_LOCALTIME_S */¨  return rc;°}Ÿ"#endif /* SQLITE_OMIT_LOCALTIME */††Ω#ifndef SQLITE_OMIT_LOCALTIME¢/*ŸE** Compute the difference (in milliseconds) between localtime and UTCŸK** (a.k.a. GMT) for the time value p where p is in UTC. If no error occurs,Ÿ0** return this value and set *pRc to SQLITE_OK. ¢**ŸK** Or, if an error does occur, set *pRc to SQLITE_ERROR. The returned valueΩ** is undefined in this case.¢*/Ÿ%static sqlite3_int64 localtimeOffset(ŸI  DateTime *p,                    /* Date at which to calculate offset */ŸF  sqlite3_context *pCtx,          /* Write error here if one occurs */ŸK  int *pRc                        /* OUT: Error code. SQLITE_OK or ERROR */¢){∞  DateTime x, y;´  time_t t;≥  struct tm sLocal;†ŸF  /* Initialize the contents of sLocal to avoid a compiler warning. */Ÿ%  memset(&sLocal, 0, sizeof(sLocal));†©  x = *p;µ  computeYMD_HMS(&x);æ  if( x.Y<1971 || x.Y>=2038 ){ŸL    /* EVIDENCE-OF: R-55269-29598 The localtime_r() C function normally onlyŸK    ** works for years between 1970 and 2037. For dates outside this range,ŸJ    ** SQLite attempts to map the year into an equivalent year within thisŸ9    ** range, do the calculation, then map the year back.¶    */Ø    x.Y = 2000;¨    x.M = 1;¨    x.D = 1;¨    x.h = 0;¨    x.m = 0;Æ    x.s = 0.0;™  } else {Ω    int s = (int)(x.s + 0.5);¨    x.s = s;£  }´  x.tz = 0;∞  x.validJD = 0;∞  computeJD(&x);Ÿ1  t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);Ÿ!  if( osLocaltime(&t, &sLocal) ){Ÿ=    sqlite3_result_error(pCtx, "local time unavailable", -1);∏    *pRc = SQLITE_ERROR;≠    return 0;£  }æ  y.Y = sLocal.tm_year + 1900;∫  y.M = sLocal.tm_mon + 1;∑  y.D = sLocal.tm_mday;∑  y.h = sLocal.tm_hour;∂  y.m = sLocal.tm_min;∂  y.s = sLocal.tm_sec;±  y.validYMD = 1;±  y.validHMS = 1;∞  y.validJD = 0;≠  y.rawS = 0;∞  y.validTZ = 0;∞  y.isError = 0;∞  computeJD(&y);≥  *pRc = SQLITE_OK;∑  return y.iJD - x.iJD;°}Ÿ"#endif /* SQLITE_OMIT_LOCALTIME */†¢/*ŸG** The following table defines various date transformations of the form¢**∏**            'NNN days'¢**ŸH** Where NNN is an arbitrary floating-point number and "days" can be oneº** of several units of time.¢*/µstatic const struct {Ÿ4  u8 eType;           /* Transformation type code */Ÿ-  u8 nName;           /* Length of th name */Ÿ6  char *zName;        /* Name of the transformation */Ÿ@  double rLimit;      /* Maximum NNN value for this transform */Ÿ<  double rXform;      /* Constant used for this transform */≤} aXformType[] = {ŸB  { 0, 6, "second", 464269060800.0, 86400000.0/(24.0*60.0*60.0) },ŸB  { 0, 6, "minute", 7737817680.0,   86400000.0/(24.0*60.0)      },ŸB  { 0, 4, "hour",   128963628.0,    86400000.0/24.0             },ŸB  { 0, 3, "day",    5373485.0,      86400000.0                  },ŸB  { 1, 5, "month",  176546.0,       30.0*86400000.0             },ŸB  { 2, 4, "year",   14713.0,        365.0*86400000.0            },¢};†¢/*Ÿ>** Process a modifier to a date-time stamp.  The modifiers areÆ** as follows:¢**Ø**     NNN days∞**     NNN hours≤**     NNN minutes∑**     NNN.NNNN seconds±**     NNN months∞**     NNN yearsµ**     start of month¥**     start of year¥**     start of week≥**     start of day∞**     weekday N∞**     unixepoch∞**     localtime™**     utc¢**ŸH** Return 0 on success and 1 if there is any kind of error. If the errorŸK** is in a system call (i.e. localtime()), then an error message is writtenŸI** to context pCtx. If the error is an unrecognized modifier, no error is≥** written to pCtx.¢*/πstatic int parseModifier(Ÿ4  sqlite3_context *pCtx,      /* Function context */Ÿ<  const char *z,              /* The text of the modifier */Ÿ;  int n,                      /* Length of zMod in bytes */ŸF  DateTime *p                 /* The date/time value to be modified */¢){≠  int rc = 1;´  double r;Ÿ)  switch(sqlite3UpperToLower[(u8)z[0]] ){Ω#ifndef SQLITE_OMIT_LOCALTIMEØ    case 'l': {µ      /*    localtime®      **ŸI      ** Assuming the current time value is UTC (a.k.a. GMT), shift it toπ      ** show local time.®      */ŸK      if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){µ        computeJD(p);Ÿ0        p->iJD += localtimeOffset(p, pCtx, &rc);ª        clearYMD_HMS_TZ(p);ß      }¨      break;•    }¶#endifØ    case 'u': {®      /*µ      **    unixepoch®      **Ÿ9      ** Treat the current value of p->s as the number ofŸB      ** seconds since 1970.  Convert to a real julian day number.®      */Ÿ:      if( sqlite3_stricmp(z, "unixepoch")==0 && p->rawS ){Ÿ,        r = p->s*1000.0 + 210866760000000.0;Ÿ,        if( r>=0.0 && r<464269060800000.0 ){Ω          clearYMD_HMS_TZ(p);Ÿ$          p->iJD = (sqlite3_int64)r;π          p->validJD = 1;∂          p->rawS = 0;±          rc = 0;©        }ß      }Ω#ifndef SQLITE_OMIT_LOCALTIMEŸJ      else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){∫        if( p->tzSet==0 ){ª          sqlite3_int64 c1;∑          computeJD(p);Ÿ-          c1 = localtimeOffset(p, pCtx, &rc);æ          if( rc==SQLITE_OK ){π            p->iJD -= c1;ø            clearYMD_HMS_TZ(p);Ÿ9            p->iJD += c1 - localtimeOffset(p, pCtx, &rc);´          }∑          p->tzSet = 1;Æ        }else{π          rc = SQLITE_OK;©        }ß      }¶#endif¨      break;•    }Ø    case 'w': {®      /*µ      **    weekday N®      **ŸA      ** Move the date to the same time on the next occurrence ofŸD      ** weekday N where 0==Sunday, 1==Monday, and so forth.  If theŸE      ** date is already on the appropriate weekday, this is a no-op.®      */Ÿ/      if( sqlite3_strnicmp(z, "weekday ", 8)==0ŸM               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)Ÿ1               && (n=(int)r)==r && n>=0 && r<7 ){∏        sqlite3_int64 Z;∫        computeYMD_HMS(p);∑        p->validTZ = 0;∑        p->validJD = 0;µ        computeJD(p);Ÿ0        Z = ((p->iJD + 129600000)/86400000) % 7;π        if( Z>n ) Z -= 7;Ÿ#        p->iJD += (n - Z)*86400000;ª        clearYMD_HMS_TZ(p);Ø        rc = 0;ß      }¨      break;•    }Ø    case 's': {®      /*∫      **    start of TTTTT®      **ŸE      ** Move the date backwards to the beginning of the current day,∫      ** or month or year.®      */Ÿ9      if( sqlite3_strnicmp(z, "start of ", 9)!=0 ) break;Ÿ>      if( !p->validJD && !p->validYMD && !p->validHMS ) break;≠      z += 9;¥      computeYMD(p);∂      p->validHMS = 1;∂      p->h = p->m = 0;±      p->s = 0.0;≤      p->rawS = 0;µ      p->validTZ = 0;µ      p->validJD = 0;Ÿ*      if( sqlite3_stricmp(z,"month")==0 ){±        p->D = 1;Ø        rc = 0;Ÿ/      }else if( sqlite3_stricmp(z,"year")==0 ){±        p->M = 1;±        p->D = 1;Ø        rc = 0;Ÿ.      }else if( sqlite3_stricmp(z,"day")==0 ){Ø        rc = 0;ß      }¨      break;•    }≠    case '+':≠    case '-':≠    case '0':≠    case '1':≠    case '2':≠    case '3':≠    case '4':≠    case '5':≠    case '6':≠    case '7':≠    case '8':Ø    case '9': {∂      double rRounder;¨      int i;ŸA      for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}Ÿ0      if( !sqlite3AtoF(z, &r, n, SQLITE_UTF8) ){Ø        rc = 1;Æ        break;ß      }∂      if( z[n]==':' ){ŸK        /* A modifier of the form (+|-)HH:MM:SS.FFF adds (or subtracts) theŸN        ** specified number of hours, minutes, seconds, and fractional secondsŸI        ** to the time.  The ".FFF" may be omitted.  The ":SS.FFF" may be≥        ** omitted.™        */ª        const char *z2 = z;¥        DateTime tx;∫        sqlite3_int64 day;Ÿ(        if( !sqlite3Isdigit(*z2) ) z2++;Ÿ#        memset(&tx, 0, sizeof(tx));Ÿ)        if( parseHhMmSs(z2, &tx) ) break;∑        computeJD(&tx);ª        tx.iJD -= 43200000;æ        day = tx.iJD/86400000;ø        tx.iJD -= day*86400000;Ÿ)        if( z[0]=='-' ) tx.iJD = -tx.iJD;µ        computeJD(p);ª        clearYMD_HMS_TZ(p);π        p->iJD += tx.iJD;Ø        rc = 0;Æ        break;ß      }†ŸF      /* If control reaches this point, it means the transformation isŸ/      ** one of the forms like "+NNN days".  */≠      z += n;Ÿ&      while( sqlite3Isspace(*z) ) z++;Ω      n = sqlite3Strlen30(z);æ      if( n>10 || n<3 ) break;Ÿ5      if( sqlite3UpperToLower[(u8)z[n-1]]=='s' ) n--;≥      computeJD(p);≠      rc = 1;Ÿ#      rRounder = r<0 ? -0.5 : +0.5;Ÿ-      for(i=0; i<ArraySize(aXformType); i++){Ÿ"        if( aXformType[i].nName==nŸ:         && sqlite3_strnicmp(aXformType[i].zName, z, n)==0Ÿ=         && r>-aXformType[i].rLimit && r<aXformType[i].rLimit™        ){Ÿ(          switch( aXformType[i].eType ){Ÿ<            case 1: { /* Special processing to add months */¥              int x;Ÿ               computeYMD_HMS(p);Ω              p->M += (int)r;Ÿ6              x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;∏              p->Y += x;ª              p->M -= x*12;Ω              p->validJD = 0;∫              r -= (int)r;¥              break;≠            }Ÿ;            case 2: { /* Special processing to add years */Ω              int y = (int)r;Ÿ               computeYMD_HMS(p);∏              p->Y += y;Ω              p->validJD = 0;∫              r -= (int)r;¥              break;≠            }´          }∑          computeJD(p);ŸG          p->iJD += (sqlite3_int64)(r*aXformType[i].rXform + rRounder);±          rc = 0;∞          break;©        }ß      }π      clearYMD_HMS_TZ(p);¨      break;•    }Æ    default: {¨      break;•    }£  }¨  return rc;°}†¢/*ŸB** Process time function arguments.  argv[0] is a date-time stamp.ŸA** argv[1] and following are modifiers.  Parse them all and writeŸ>** the resulting time into the DateTime structure p.  Return 0Ÿ,** on success and 1 if there are any errors.¢**Ÿ>** If there are zero parameters (if even argv[0] is undefined)Ÿ4** then assume a default value of "now" for argv[0].¢*/≤static int isDate(º  sqlite3_context *context, ¨  int argc, ∏  sqlite3_value **argv, ≠  DateTime *p¢){´  int i, n;π  const unsigned char *z;¨  int eType;ª  memset(p, 0, sizeof(*p));∞  if( argc==0 ){Ÿ,    return setDateTimeToCurrent(context, p);£  }Ÿ9  if( (eType = sqlite3_value_type(argv[0]))==SQLITE_FLOATŸ.                   || eType==SQLITE_INTEGER ){Ÿ7    setRawDateNumber(p, sqlite3_value_double(argv[0]));®  }else{Ÿ$    z = sqlite3_value_text(argv[0]);Ÿ6    if( !z || parseDateOrTime(context, (char*)z, p) ){Ø      return 1;•    }£  }∏  for(i=1; i<argc; i++){Ÿ$    z = sqlite3_value_text(argv[i]);Ÿ%    n = sqlite3_value_bytes(argv[i]);ŸB    if( z==0 || parseModifier(context, (char*)z, n, p) ) return 1;£  }Ø  computeJD(p);Ÿ7  if( p->isError || !validJulianDay(p->iJD) ) return 1;´  return 0;°}††¢/*ŸG** The following routines implement the various date and time functions≠** of SQLite.¢*/†¢/*Ÿ+**    julianday( TIMESTRING, MOD, MOD, ...)¢**ŸF** Return the julian day number of the date specified in the arguments¢*/∫static void juliandayFunc(ª  sqlite3_context *context,´  int argc,∂  sqlite3_value **argv¢){≠  DateTime x;Ÿ+  if( isDate(context, argc, argv, &x)==0 ){≤    computeJD(&x);Ÿ5    sqlite3_result_double(context, x.iJD/86400000.0);£  }°}†¢/*Ÿ***    datetime( TIMESTRING, MOD, MOD, ...)¢**Ω** Return YYYY-MM-DD HH:MM:SS¢*/πstatic void datetimeFunc(ª  sqlite3_context *context,´  int argc,∂  sqlite3_value **argv¢){≠  DateTime x;Ÿ+  if( isDate(context, argc, argv, &x)==0 ){≥    char zBuf[100];∑    computeYMD_HMS(&x);ŸI    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",Ÿ:                     x.Y, x.M, x.D, x.h, x.m, (int)(x.s));Ÿ=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }°}†¢/*Ÿ&**    time( TIMESTRING, MOD, MOD, ...)¢**≤** Return HH:MM:SS¢*/µstatic void timeFunc(ª  sqlite3_context *context,´  int argc,∂  sqlite3_value **argv¢){≠  DateTime x;Ÿ+  if( isDate(context, argc, argv, &x)==0 ){≥    char zBuf[100];≥    computeHMS(&x);ŸO    sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);Ÿ=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }°}†¢/*Ÿ&**    date( TIMESTRING, MOD, MOD, ...)¢**¥** Return YYYY-MM-DD¢*/µstatic void dateFunc(ª  sqlite3_context *context,´  int argc,∂  sqlite3_value **argv¢){≠  DateTime x;Ÿ+  if( isDate(context, argc, argv, &x)==0 ){≥    char zBuf[100];≥    computeYMD(&x);ŸJ    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);Ÿ=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }°}†¢/*Ÿ2**    strftime( FORMAT, TIMESTRING, MOD, MOD, ...)¢**Ÿ@** Return a string described by FORMAT.  Conversions as follows:¢**µ**   %d  day of monthŸ&**   %f  ** fractional seconds  SS.SSS≥**   %H  hour 00-24º**   %j  day of year 000-366Ω**   %J  ** julian day number¥**   %m  month 01-12µ**   %M  minute 00-59Ÿ!**   %s  seconds since 1970-01-01∂**   %S  seconds 00-59Ÿ#**   %w  day of week 0-6  sunday==0ª**   %W  week of year 00-53∑**   %Y  year 0000-9999™**   %%  %¢*/πstatic void strftimeFunc(ª  sqlite3_context *context,´  int argc,∂  sqlite3_value **argv¢){≠  DateTime x;®  u64 n;≠  size_t i,j;™  char *z;Æ  sqlite3 *db;≥  const char *zFmt;±  char zBuf[100];∑  if( argc==0 ) return;Ÿ2  zFmt = (const char*)sqlite3_value_text(argv[0]);Ÿ>  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;Ÿ*  db = sqlite3_context_db_handle(context);Ÿ#  for(i=0, n=1; zFmt[i]; i++, n++){∑    if( zFmt[i]=='%' ){∫      switch( zFmt[i+1] ){±        case 'd':±        case 'H':±        case 'm':±        case 'M':±        case 'S':±        case 'W':Æ          n++;π          /* fall thru */±        case 'w':±        case '%':∞          break;±        case 'f':±          n += 8;∞          break;±        case 'j':±          n += 3;∞          break;±        case 'Y':±          n += 8;∞          break;±        case 's':±        case 'J':≤          n += 50;∞          break;∞        default:Ÿ.          return;  /* ERROR.  return a NULL */ß      }™      i++;•    }£  }Ÿ   testcase( n==sizeof(zBuf)-1 );æ  testcase( n==sizeof(zBuf) );Ÿ8  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );Ÿ6  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH] );∑  if( n<sizeof(zBuf) ){≠    z = zBuf;Ÿ5  }else if( n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH] ){Ÿ)    sqlite3_result_error_toobig(context);´    return;®  }else{Ÿ)    z = sqlite3DbMallocRawNN(db, (int)n);Ø    if( z==0 ){Ÿ*      sqlite3_result_error_nomem(context);≠      return;•    }£  }∞  computeJD(&x);µ  computeYMD_HMS(&x);ª  for(i=j=0; zFmt[i]; i++){∑    if( zFmt[i]!='%' ){∑      z[j++] = zFmt[i];™    }else{™      i++;∏      switch( zFmt[i] ){ŸF        case 'd':  sqlite3_snprintf(3, &z[j],"%02d",x.D); j+=2; break;≥        case 'f': {π          double s = x.s;Ÿ$          if( s>59.999 ) s = 59.999;Ÿ1          sqlite3_snprintf(7, &z[j],"%06.3f", s);Ÿ&          j += sqlite3Strlen30(&z[j]);∞          break;©        }ŸF        case 'H':  sqlite3_snprintf(3, &z[j],"%02d",x.h); j+=2; break;Ÿ!        case 'W': /* Fall thru */≥        case 'j': {ŸJ          int nDay;             /* Number of days since 1st day of year */π          DateTime y = x;∏          y.validJD = 0;≤          y.M = 1;≤          y.D = 1;∏          computeJD(&y);Ÿ8          nDay = (int)((x.iJD-y.iJD+43200000)/86400000);Ω          if( zFmt[i]=='W' ){Ÿ=            int wd;   /* 0=Monday, 1=Tuesday, ... 6=Sunday */Ÿ6            wd = (int)(((x.iJD+43200000)/86400000)%7);Ÿ<            sqlite3_snprintf(3, &z[j],"%02d",(nDay+7-wd)/7);≥            j += 2;∞          }else{Ÿ5            sqlite3_snprintf(4, &z[j],"%03d",nDay+1);≥            j += 3;´          }∞          break;©        }≥        case 'J': {Ÿ?          sqlite3_snprintf(20, &z[j],"%.16g",x.iJD/86400000.0);Ÿ$          j+=sqlite3Strlen30(&z[j]);∞          break;©        }ŸF        case 'm':  sqlite3_snprintf(3, &z[j],"%02d",x.M); j+=2; break;ŸF        case 'M':  sqlite3_snprintf(3, &z[j],"%02d",x.m); j+=2; break;≥        case 's': {Ÿ+          sqlite3_snprintf(30,&z[j],"%lld",ŸD                           (i64)(x.iJD/1000 - 21086676*(i64)10000));Ÿ&          j += sqlite3Strlen30(&z[j]);∞          break;©        }ŸJ        case 'S':  sqlite3_snprintf(3,&z[j],"%02d",(int)x.s); j+=2; break;≥        case 'w': {ŸB          z[j++] = (char)(((x.iJD+129600000)/86400000) % 7) + '0';∞          break;©        }≥        case 'Y': {ŸJ          sqlite3_snprintf(5,&z[j],"%04d",x.Y); j+=sqlite3Strlen30(&z[j]);∞          break;©        }Ÿ'        default:   z[j++] = '%'; break;ß      }•    }£  }´  z[j] = 0;Ÿ%  sqlite3_result_text(context, z, -1,ŸC                      z==zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC);°}†¢/*±** current_time()¢**Ÿ7** This function returns the same value as time('now').¢*/∂static void ctimeFunc(ª  sqlite3_context *context,Æ  int NotUsed,∫  sqlite3_value **NotUsed2¢){Ÿ'  UNUSED_PARAMETER2(NotUsed, NotUsed2);∫  timeFunc(context, 0, 0);°}†¢/*±** current_date()¢**Ÿ7** This function returns the same value as date('now').¢*/∂static void cdateFunc(ª  sqlite3_context *context,Æ  int NotUsed,∫  sqlite3_value **NotUsed2¢){Ÿ'  UNUSED_PARAMETER2(NotUsed, NotUsed2);∫  dateFunc(context, 0, 0);°}†¢/*∂** current_timestamp()¢**Ÿ;** This function returns the same value as datetime('now').¢*/ªstatic void ctimestampFunc(ª  sqlite3_context *context,Æ  int NotUsed,∫  sqlite3_value **NotUsed2¢){Ÿ'  UNUSED_PARAMETER2(NotUsed, NotUsed2);æ  datetimeFunc(context, 0, 0);°}Ÿ1#endif /* !defined(SQLITE_OMIT_DATETIME_FUNCS) */†Ÿ!#ifdef SQLITE_OMIT_DATETIME_FUNCS¢/*ŸB** If the library is compiled to omit the full-scale date and timeŸD** handling (to get a smaller binary), the following minimal versionŸJ** of the functions current_time(), current_date() and current_timestamp()ŸD** are included instead. This is to support column declarations thatŸ&** include "DEFAULT CURRENT_TIME" etc.¢**Ÿ>** This function uses the C-library functions time(), gmtime()ŸF** and strftime(). The format string to pass to strftime() is suppliedŸ%** as the user-data for the function.¢*/ºstatic void currentTimeFunc(ª  sqlite3_context *context,´  int argc,∂  sqlite3_value **argv¢){´  time_t t;Ÿ5  char *zFormat = (char *)sqlite3_user_data(context);≥  sqlite3_int64 iT;±  struct tm *pTm;±  struct tm sNow;∞  char zBuf[20];†π  UNUSED_PARAMETER(argc);π  UNUSED_PARAMETER(argv);†Ÿ'  iT = sqlite3StmtCurrentTime(context);µ  if( iT<=0 ) return;Ÿ.  t = iT/1000 - 10000*(sqlite3_int64)21086676;±#if HAVE_GMTIME_Rº  pTm = gmtime_r(&t, &sNow);•#elseŸE  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));≥  pTm = gmtime(&t);Ÿ-  if( pTm ) memcpy(&sNow, pTm, sizeof(sNow));ŸE  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));¶#endif¨  if( pTm ){Ÿ'    strftime(zBuf, 20, zFormat, &sNow);Ÿ=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }°}¶#endif†¢/*Ÿ?** This function registered all of the above C functions as SQLŸ@** functions.  This should be the only routine in this file with¥** external linkage.¢*/Ÿ;SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){Ÿ%  static FuncDef aDateTimeFuncs[] = {Ÿ"#ifndef SQLITE_OMIT_DATETIME_FUNCSŸ:    PURE_DATE(julianday,        -1, 0, 0, juliandayFunc ),Ÿ:    PURE_DATE(date,             -1, 0, 0, dateFunc      ),Ÿ:    PURE_DATE(time,             -1, 0, 0, timeFunc      ),Ÿ:    PURE_DATE(datetime,         -1, 0, 0, datetimeFunc  ),Ÿ:    PURE_DATE(strftime,         -1, 0, 0, strftimeFunc  ),Ÿ:    DFUNCTION(current_time,      0, 0, 0, ctimeFunc     ),Ÿ:    DFUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),Ÿ:    DFUNCTION(current_date,      0, 0, 0, cdateFunc     ),•#elseŸP    STR_FUNCTION(current_time,      0, "%H:%M:%S",          0, currentTimeFunc),ŸP    STR_FUNCTION(current_date,      0, "%Y-%m-%d",          0, currentTimeFunc),ŸP    STR_FUNCTION(current_timestamp, 0, "%Y-%m-%d %H:%M:%S", 0, currentTimeFunc),¶#endif§  };ŸG  sqlite3InsertBuiltinFuncs(aDateTimeFuncs, ArraySize(aDateTimeFuncs));°}†ŸO/************** End of date.c ************************************************/ŸO/************** Begin file os.c **********************************************/¢/*≥** 2005 November 29¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**Ÿ=** This file contains OS interface code that is common to all±** architectures.¢*/º/* #include "sqliteInt.h" */†¢/*ŸI** If we compile with the SQLITE_TEST macro set, then the following blockŸG** of code will give us the ability to simulate a disk I/O error.  ThisŸ.** is used for testing the I/O recovery logic.¢*/∏#if defined(SQLITE_TEST)ŸTSQLITE_API int sqlite3_io_error_hit = 0;            /* Total number of I/O Errors */ŸUSQLITE_API int sqlite3_io_error_hardhit = 0;        /* Number of non-benign errors */ŸWSQLITE_API int sqlite3_io_error_pending = 0;        /* Count down to first I/O error */ŸTSQLITE_API int sqlite3_io_error_persist = 0;        /* True if I/O errors persist */ŸSSQLITE_API int sqlite3_io_error_benign = 0;         /* True if errors are benign */Ÿ,SQLITE_API int sqlite3_diskfull_pending = 0;Ÿ$SQLITE_API int sqlite3_diskfull = 0;Ÿ!#endif /* defined(SQLITE_TEST) */†¢/*Ÿ?** When testing, also keep a count of the number of open files.¢*/∏#if defined(SQLITE_TEST)Ÿ+SQLITE_API int sqlite3_open_file_count = 0;Ÿ!#endif /* defined(SQLITE_TEST) */†¢/*ŸA** The default SQLite sqlite3_vfs implementations do not allocateŸA** memory (actually, os_unix.c allocates a small amount of memoryŸC** from within OsOpen()), but some third-party implementations may.ŸF** So we test the effects of a malloc() failing and the sqlite3OsXXX()ŸK** function returning SQLITE_IOERR_NOMEM using the DO_OS_MALLOC_TEST macro.¢**Ÿ@** The following functions are instrumented for malloc() failure´** testing:¢**∂**     sqlite3OsRead()∑**     sqlite3OsWrite()∂**     sqlite3OsSync()∫**     sqlite3OsFileSize()∂**     sqlite3OsLock()Ÿ#**     sqlite3OsCheckReservedLock()Ω**     sqlite3OsFileControl()∏**     sqlite3OsShmMap()∂**     sqlite3OsOpen()∏**     sqlite3OsDelete()∏**     sqlite3OsAccess()æ**     sqlite3OsFullPathname()¢**¢*/∏#if defined(SQLITE_TEST)Ÿ1SQLITE_API int sqlite3_memdebug_vfs_oom_test = 1;ŸF  #define DO_OS_MALLOC_TEST(x)                                       \ŸP  if (sqlite3_memdebug_vfs_oom_test && (!x || !sqlite3JournalIsInMemory(x))) { \ŸF    void *pTstAlloc = sqlite3Malloc(10);                             \ŸF    if (!pTstAlloc) return SQLITE_IOERR_NOMEM_BKPT;                  \ŸF    sqlite3_free(pTstAlloc);                                         \£  }•#elseæ  #define DO_OS_MALLOC_TEST(x)¶#endif†¢/*ŸA** The following routines are convenience wrappers around methodsŸH** of the sqlite3_file object.  This is mostly just syntactic sugar. AllŸC** of this would be completely automatic if SQLite were coded usingæ** C++ instead of plain old C.¢*/Ÿ6SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file *pId){∂  if( pId->pMethods ){ø    pId->pMethods->xClose(pId);∂    pId->pMethods = 0;£  }°}ŸTSQLITE_PRIVATE int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){∏  DO_OS_MALLOC_TEST(id);Ÿ4  return id->pMethods->xRead(id, pBuf, amt, offset);°}Ÿ[SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){∏  DO_OS_MALLOC_TEST(id);Ÿ5  return id->pMethods->xWrite(id, pBuf, amt, offset);°}ŸASQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file *id, i64 size){Ÿ+  return id->pMethods->xTruncate(id, size);°}Ÿ>SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file *id, int flags){∏  DO_OS_MALLOC_TEST(id);Ÿ<  return flags ? id->pMethods->xSync(id, flags) : SQLITE_OK;°}ŸCSQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){∏  DO_OS_MALLOC_TEST(id);Ÿ,  return id->pMethods->xFileSize(id, pSize);°}ŸASQLITE_PRIVATE int sqlite3OsLock(sqlite3_file *id, int lockType){∏  DO_OS_MALLOC_TEST(id);Ÿ+  return id->pMethods->xLock(id, lockType);°}ŸCSQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file *id, int lockType){Ÿ-  return id->pMethods->xUnlock(id, lockType);°}ŸNSQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){∏  DO_OS_MALLOC_TEST(id);Ÿ7  return id->pMethods->xCheckReservedLock(id, pResOut);°}†¢/*ŸI** Use sqlite3OsFileControl() when we are doing something that might failŸJ** and we need to know about the failures.  Use sqlite3OsFileControlHint()ŸI** when simply tossing information over the wall to the VFS and we do notŸK** really care if the VFS receives and understands the information since itŸL** is only a hint and can be safely ignored.  The sqlite3OsFileControlHint()ŸK** routine has no return value since the return value would be meaningless.¢*/ŸNSQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){Ÿ/  if( id->pMethods==0 ) return SQLITE_NOTFOUND;≤#ifdef SQLITE_TESTŸ&  if( op!=SQLITE_FCNTL_COMMIT_PHASETWOŸ#   && op!=SQLITE_FCNTL_LOCK_TIMEOUT§  ){ŸL    /* Faults are not injected into COMMIT_PHASETWO because, assuming SQLiteŸC    ** is using a regular VFS, it is called after the correspondingŸF    ** transaction has been committed. Injecting a fault at this pointŸI    ** confuses the test scripts - the COMMIT comand returns SQLITE_NOMEMŸ/    ** but the transaction is committed anyway.¶    **ŸJ    ** The core must call OsFileControl() though, not OsFileControlHint(),ŸJ    ** as if a custom VFS (e.g. zipvfs) returns an error here, it probablyŸI    ** means the commit really has failed and an error should be returned∑    ** to the user.  */∫    DO_OS_MALLOC_TEST(id);£  }¶#endifŸ2  return id->pMethods->xFileControl(id, op, pArg);°}ŸSSQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){ŸD  if( id->pMethods ) (void)id->pMethods->xFileControl(id, op, pArg);°}†Ÿ9SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id){Ÿ@  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;ŸF  return (xSectorSize ? xSectorSize(id) : SQLITE_DEFAULT_SECTOR_SIZE);°}ŸDSQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id){Ÿ2  return id->pMethods->xDeviceCharacteristics(id);°}∑#ifndef SQLITE_OMIT_WALŸTSQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){Ÿ6  return id->pMethods->xShmLock(id, offset, n, flags);°}Ÿ:SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id){Ÿ   id->pMethods->xShmBarrier(id);°}ŸGSQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){Ÿ1  return id->pMethods->xShmUnmap(id, deleteFlag);°}Ÿ#SQLITE_PRIVATE int sqlite3OsShmMap(Ÿ<  sqlite3_file *id,               /* Database file handle */¨  int iPage,´  int pgsz,ŸH  int bExtend,                    /* True to extend file if necessary */Ÿ?  void volatile **pp              /* OUT: Pointer to mapping */¢){∏  DO_OS_MALLOC_TEST(id);Ÿ=  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);°}º#endif /* SQLITE_OMIT_WAL */†∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ4/* The real implementation of xFetch and xUnfetch */ŸSSQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){∏  DO_OS_MALLOC_TEST(id);Ÿ2  return id->pMethods->xFetch(id, iOff, iAmt, pp);°}ŸISQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){Ÿ-  return id->pMethods->xUnfetch(id, iOff, p);°}•#elseŸ;/* No-op stubs to use when memory-mapped I/O is disabled */ŸSSQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){™  *pp = 0;≥  return SQLITE_OK;°}ŸISQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){≥  return SQLITE_OK;°}¶#endif†¢/*ŸA** The next group of routines are convenience wrappers around theØ** VFS methods.¢*/Ÿ!SQLITE_PRIVATE int sqlite3OsOpen(¥  sqlite3_vfs *pVfs,¥  const char *zPath,∂  sqlite3_file *pFile,¨  int flags,∞  int *pFlagsOut¢){©  int rc;∑  DO_OS_MALLOC_TEST(0);ŸH  /* 0x87f7f is a mask of SQLITE_OPEN_ flags that are valid to be passedŸD  ** down into the VFS layer.  Some SQLITE_OPEN_ flags (for example,ŸI  ** SQLITE_OPEN_FULLMUTEX or SQLITE_OPEN_SHAREDCACHE) are blocked beforeπ  ** reaching the VFS. */ŸC  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x87f7f, pFlagsOut);Ÿ0  assert( rc==SQLITE_OK || pFile->pMethods==0 );¨  return rc;°}ŸVSQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){∑  DO_OS_MALLOC_TEST(0);Ÿ%  assert( dirSync==0 || dirSync==1 );Ÿ-  return pVfs->xDelete(pVfs, zPath, dirSync);°}Ÿ#SQLITE_PRIVATE int sqlite3OsAccess(¥  sqlite3_vfs *pVfs,¥  const char *zPath,¨  int flags,Æ  int *pResOut¢){∑  DO_OS_MALLOC_TEST(0);Ÿ4  return pVfs->xAccess(pVfs, zPath, flags, pResOut);°}Ÿ)SQLITE_PRIVATE int sqlite3OsFullPathname(¥  sqlite3_vfs *pVfs,¥  const char *zPath,Ø  int nPathOut,∞  char *zPathOut¢){∑  DO_OS_MALLOC_TEST(0);≤  zPathOut[0] = 0;Ÿ>  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);°}Ÿ"#ifndef SQLITE_OMIT_LOAD_EXTENSIONŸKSQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){Ÿ$  return pVfs->xDlOpen(pVfs, zPath);°}ŸRSQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){Ÿ'  pVfs->xDlError(pVfs, nByte, zBufOut);°}Ÿ^SQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){Ÿ)  return pVfs->xDlSym(pVfs, pHdle, zSym);°}ŸGSQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){Ÿ   pVfs->xDlClose(pVfs, pHandle);°}Ÿ'#endif /* SQLITE_OMIT_LOAD_EXTENSION */ŸTSQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){Ÿ1  return pVfs->xRandomness(pVfs, nByte, zBufOut);°}ŸASQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){Ÿ$  return pVfs->xSleep(pVfs, nMicro);°}Ÿ<SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs *pVfs){ŸC  return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0;°}ŸYSQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){©  int rc;ŸM  /* IMPLEMENTATION-OF: R-49045-42493 SQLite will use the xCurrentTimeInt64()ŸH  ** method to get the current date and time if that method is availableŸK  ** (if iVersion is 2 or greater and the function pointer is not NULL) andŸ?  ** will fall back to xCurrentTime() if xCurrentTimeInt64() is±  ** unavailable.§  */Ÿ5  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){Ÿ1    rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);®  }else{≠    double r;Ÿ&    rc = pVfs->xCurrentTime(pVfs, &r);Ÿ.    *pTimeOut = (sqlite3_int64)(r*86400000.0);£  }¨  return rc;°}†Ÿ'SQLITE_PRIVATE int sqlite3OsOpenMalloc(¥  sqlite3_vfs *pVfs,¥  const char *zFile,∏  sqlite3_file **ppFile,¨  int flags,∞  int *pOutFlags¢){©  int rc;∂  sqlite3_file *pFile;Ÿ<  pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);Æ  if( pFile ){Ÿ=    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);∏    if( rc!=SQLITE_OK ){∫      sqlite3_free(pFile);™    }else{∂      *ppFile = pFile;•    }®  }else{ª    rc = SQLITE_NOMEM_BKPT;£  }¨  return rc;°}Ÿ<SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *pFile){≤  assert( pFile );∏  sqlite3OsClose(pFile);∂  sqlite3_free(pFile);°}†¢/*ŸF** This function is a wrapper around the OS specific implementation ofŸB** sqlite3_os_init(). The purpose of the wrapper is to provide theŸC** ability to simulate a malloc failure, so that the handling of anŸ@** error in sqlite3_os_init() by the upper layers can be tested.¢*/Ÿ'SQLITE_PRIVATE int sqlite3OsInit(void){ø  void *p = sqlite3_malloc(10);Ÿ&  if( p==0 ) return SQLITE_NOMEM_BKPT;≤  sqlite3_free(p);ª  return sqlite3_os_init();°}†¢/*Ÿ2** The list of all registered VFS implementations.¢*/Ÿ,static sqlite3_vfs * SQLITE_WSD vfsList = 0;Ÿ.#define vfsList GLOBAL(sqlite3_vfs *, vfsList)†¢/*Ÿ@** Locate a VFS by name.  If no name is given, simply return theπ** first VFS on the list.¢*/Ÿ;SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){∏  sqlite3_vfs *pVfs = 0;µ#if SQLITE_THREADSAFE∑  sqlite3_mutex *mutex;¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ   int rc = sqlite3_initialize();¥  if( rc ) return 0;¶#endifµ#if SQLITE_THREADSAFEŸ8  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);¶#endifΩ  sqlite3_mutex_enter(mutex);Ÿ.  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){∏    if( zVfs==0 ) break;Ÿ-    if( strcmp(zVfs, pVfs->zName)==0 ) break;£  }Ω  sqlite3_mutex_leave(mutex);Æ  return pVfs;°}†¢/*Ÿ$** Unlink a VFS from the linked list¢*/Ÿ)static void vfsUnlink(sqlite3_vfs *pVfs){ŸN  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) );∞  if( pVfs==0 ){Ø    /* No-op */º  }else if( vfsList==pVfs ){∫    vfsList = pVfs->pNext;∂  }else if( vfsList ){Ω    sqlite3_vfs *p = vfsList;Ÿ(    while( p->pNext && p->pNext!=pVfs ){≥      p = p->pNext;•    }π    if( p->pNext==pVfs ){Ω      p->pNext = pVfs->pNext;•    }£  }°}†¢/*ŸG** Register a VFS with the system.  It is harmless to register the sameŸF** VFS multiple times.  The new VFS becomes the default if makeDflt is®** true.¢*/ŸESQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){Ÿ$  MUTEX_LOGIC(sqlite3_mutex *mutex;)º#ifndef SQLITE_OMIT_AUTOINITŸ   int rc = sqlite3_initialize();µ  if( rc ) return rc;¶#endifæ#ifdef SQLITE_ENABLE_API_ARMORŸ*  if( pVfs==0 ) return SQLITE_MISUSE_BKPT;¶#endif†ŸG  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )Ω  sqlite3_mutex_enter(mutex);≤  vfsUnlink(pVfs);ø  if( makeDflt || vfsList==0 ){∫    pVfs->pNext = vfsList;≥    vfsList = pVfs;®  }else{Ÿ!    pVfs->pNext = vfsList->pNext;∫    vfsList->pNext = pVfs;£  }≤  assert(vfsList);Ω  sqlite3_mutex_leave(mutex);≥  return SQLITE_OK;°}†¢/*Ÿ7** Unregister a VFS so that it is no longer accessible.¢*/Ÿ9SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){µ#if SQLITE_THREADSAFEŸG  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);¶#endifΩ  sqlite3_mutex_enter(mutex);≤  vfsUnlink(pVfs);Ω  sqlite3_mutex_leave(mutex);≥  return SQLITE_OK;°}†ŸO/************** End of os.c **************************************************/ŸO/************** Begin file fault.c *******************************************/¢/*Æ** 2008 Jan 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**Ÿ>** This file contains code to support the concept of "benign" ŸB** malloc failures (when the xMalloc() or xRealloc() method of theŸD** sqlite3_mem_methods structure fails to allocate a block of memory≥** and returns 0). ¢**Ÿ@** Most malloc failures are non-benign. After they occur, SQLiteŸD** abandons the current operation and returns an error code (usuallyŸK** SQLITE_NOMEM) to the user. However, sometimes a fault is not necessarilyŸK** fatal. For example, if a malloc fails while resizing a hash table, this ŸH** is completely recoverable simply by not carrying out the resize. The ŸG** hash table will continue to function normally.  So a malloc failure Ÿ0** during a hash table resize is a benign fault.¢*/†º/* #include "sqliteInt.h" */†π#ifndef SQLITE_UNTESTABLE†¢/*¥** Global variables.¢*/Ÿ3typedef struct BenignMallocHooks BenignMallocHooks;Ÿ,static SQLITE_WSD struct BenignMallocHooks {Ω  void (*xBenignBegin)(void);ª  void (*xBenignEnd)(void);∫} sqlite3Hooks = { 0, 0 };†ŸI/* The "wsdHooks" macro will resolve to the appropriate BenignMallocHooksŸD** structure.  If writable static data is unsupported on the target,ŸF** we have to locate the state vector at run-time.  In the more commonŸL** case where writable static data is supported, wsdHooks can refer directlyŸ5** to the "sqlite3Hooks" state vector declared above.¢*/∂#ifdef SQLITE_OMIT_WSD∑# define wsdHooksInit \Ÿ@  BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)∂# define wsdHooks x[0]•#elseµ# define wsdHooksInitæ# define wsdHooks sqlite3Hooks¶#endif††¢/*Ÿ=** Register hooks to call when sqlite3BeginBenignMalloc() andŸ5** sqlite3EndBenignMalloc() are called, respectively.¢*/Ÿ-SQLITE_PRIVATE void sqlite3BenignMallocHooks(Ω  void (*xBenignBegin)(void),∫  void (*xBenignEnd)(void)¢){Ø  wsdHooksInit;Ÿ'  wsdHooks.xBenignBegin = xBenignBegin;Ÿ#  wsdHooks.xBenignEnd = xBenignEnd;°}†¢/*ŸL** This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate thatŸL** subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()Ÿ<** indicates that subsequent malloc failures are non-benign.¢*/Ÿ3SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void){Ø  wsdHooksInit;æ  if( wsdHooks.xBenignBegin ){º    wsdHooks.xBenignBegin();£  }°}Ÿ1SQLITE_PRIVATE void sqlite3EndBenignMalloc(void){Ø  wsdHooksInit;º  if( wsdHooks.xBenignEnd ){∫    wsdHooks.xBenignEnd();£  }°}†Ÿ(#endif   /* #ifndef SQLITE_UNTESTABLE */†ŸO/************** End of fault.c ***********************************************/ŸO/************** Begin file mem0.c ********************************************/¢/*≤** 2008 October 28¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸD** This file contains a no-op memory allocation drivers for use whenŸE** SQLITE_ZERO_MALLOC is defined.  The allocation drivers implementedŸH** here always fail.  SQLite will not operate with these drivers.  TheseŸC** are merely placeholders.  Real drivers must be substituted usingŸ/** sqlite3_config() before SQLite will operate.¢*/º/* #include "sqliteInt.h" */†¢/*Ÿ>** This version of the memory allocator is the default.  It isŸF** used when no other memory allocator is specified using compile-time™** macros.¢*/π#ifdef SQLITE_ZERO_MALLOC†¢/*Ÿ3** No-op versions of all memory allocation routines¢*/Ÿ5static void *sqlite3MemMalloc(int nByte){ return 0; }Ÿ3static void sqlite3MemFree(void *pPrior){ return; }ŸDstatic void *sqlite3MemRealloc(void *pPrior, int nByte){ return 0; }Ÿ4static int sqlite3MemSize(void *pPrior){ return 0; }Ÿ0static int sqlite3MemRoundup(int n){ return n; }Ÿ=static int sqlite3MemInit(void *NotUsed){ return SQLITE_OK; }Ÿ8static void sqlite3MemShutdown(void *NotUsed){ return; }†¢/*ŸG** This routine is the only routine in this file with external linkage.¢**Ÿ@** Populate the low-level memory allocation function pointers inŸD** sqlite3GlobalConfig.m with pointers to the routines in this file.¢*/Ÿ/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ÿ5  static const sqlite3_mem_methods defaultMethods = {∂     sqlite3MemMalloc,¥     sqlite3MemFree,∑     sqlite3MemRealloc,¥     sqlite3MemSize,∑     sqlite3MemRoundup,¥     sqlite3MemInit,∏     sqlite3MemShutdown,¶     0§  };Ÿ8  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);°}†ø#endif /* SQLITE_ZERO_MALLOC */†ŸO/************** End of mem0.c ************************************************/ŸO/************** Begin file mem1.c ********************************************/¢/*±** 2007 August 14¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸB** This file contains low-level memory allocation drivers for whenŸG** SQLite will use the standard C-library malloc/realloc/free interfaceŸ!** to obtain the memory it needs.¢**ŸH** This file contains implementations of the low-level memory allocationŸH** routines specified in the sqlite3_mem_methods object.  The content ofŸB** this file is only used if SQLITE_SYSTEM_MALLOC is defined.  TheŸE** SQLITE_SYSTEM_MALLOC macro is defined automatically if neither theŸG** SQLITE_MEMDEBUG nor the SQLITE_WIN32_MALLOC macros are defined.  TheŸE** default configuration is to use memory allocation routines in this®** file.¢**Ÿ ** C-preprocessor macro summary:¢**ŸJ**    HAVE_MALLOC_USABLE_SIZE     The configure script sets this symbol ifŸK**                                the malloc_usable_size() interface existsŸJ**                                on the target platform.  Or, this symbolŸB**                                can be set manually, if desired.ŸF**                                If an equivalent interface exists byŸG**                                a different name, using a separate -DŸ6**                                option to rename it.¢**ŸK**    SQLITE_WITHOUT_ZONEMALLOC   Some older macs lack support for the zoneŸN**                                memory allocator.  Set this symbol to enableŸ9**                                building on older macs.¢**ŸG**    SQLITE_WITHOUT_MSIZE        Set this symbol to disable the use ofŸJ**                                _msize() on windows systems.  This mightŸI**                                be necessary when compiling for Delphi,Ÿ.**                                for example.¢*/º/* #include "sqliteInt.h" */†¢/*Ÿ>** This version of the memory allocator is the default.  It isŸF** used when no other memory allocator is specified using compile-time™** macros.¢*/ª#ifdef SQLITE_SYSTEM_MALLOCŸ=#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)†¢/*Ÿ@** Use the zone allocator available on apple products unless theŸ/** SQLITE_WITHOUT_ZONEMALLOC symbol is defined.¢*/∑#include <sys/sysctl.h>∫#include <malloc/malloc.h>Ÿ"#ifdef SQLITE_MIGHT_BE_SINGLE_COREΩ#include <libkern/OSAtomic.h>Ÿ(#endif /* SQLITE_MIGHT_BE_SINGLE_CORE */Ÿ#static malloc_zone_t* _sqliteZone_;Ÿ>#define SQLITE_MALLOC(x) malloc_zone_malloc(_sqliteZone_, (x))Ÿ;#define SQLITE_FREE(x) malloc_zone_free(_sqliteZone_, (x));ŸG#define SQLITE_REALLOC(x,y) malloc_zone_realloc(_sqliteZone_, (x), (y))æ#define SQLITE_MALLOCSIZE(x) \ŸL        (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,x) : malloc_size(x))†º#else /* if not __APPLE__ */†¢/*ŸA** Use standard C library malloc and free on non-Apple systems.  ŸF** Also used by Apple systems if SQLITE_WITHOUT_ZONEMALLOC is defined.¢*/Ÿ.#define SQLITE_MALLOC(x)             malloc(x)Ÿ,#define SQLITE_FREE(x)               free(x)Ÿ5#define SQLITE_REALLOC(x,y)          realloc((x),(y))†¢/*ŸG** The malloc.h header file is needed for malloc_usable_size() functionŸ ** on some systems (e.g. Linux).¢*/Ÿ,#if HAVE_MALLOC_H && HAVE_MALLOC_USABLE_SIZEø#  define SQLITE_USE_MALLOC_H 1Ÿ)#  define SQLITE_USE_MALLOC_USABLE_SIZE 1¢/*ŸG** The MSVCRT has malloc_usable_size(), but it is called _msize().  TheŸF** use of _msize() is automatic, but can be disabled by compiling withŸE** -DSQLITE_WITHOUT_MSIZE.  Using the _msize() function also requiresº** the malloc.h header file.¢*/Ÿ9#elif defined(_MSC_VER) && !defined(SQLITE_WITHOUT_MSIZE)Ω#  define SQLITE_USE_MALLOC_H∫#  define SQLITE_USE_MSIZE¶#endif†¢/*ŸI** Include the malloc.h header file, if necessary.  Also set define macroŸH** SQLITE_MALLOCSIZE to the appropriate function name, which is _msize()ŸI** for MSVC and malloc_usable_size() for most other systems (e.g. Linux).ŸI** The memory size function can always be overridden manually by definingŸ<** the macro SQLITE_MALLOCSIZE to the desired function name.¢*/Ÿ #if defined(SQLITE_USE_MALLOC_H)µ#  include <malloc.h>Ÿ,#  if defined(SQLITE_USE_MALLOC_USABLE_SIZE)Ÿ##    if !defined(SQLITE_MALLOCSIZE)Ÿ:#      define SQLITE_MALLOCSIZE(x)   malloc_usable_size(x)™#    endifŸ!#  elif defined(SQLITE_USE_MSIZE)Ÿ##    if !defined(SQLITE_MALLOCSIZE)Ÿ+#      define SQLITE_MALLOCSIZE      _msize™#    endif®#  endifŸ)#endif /* defined(SQLITE_USE_MALLOC_H) */†Ÿ'#endif /* __APPLE__ or not __APPLE__ */†¢/*Ÿ9** Like malloc(), but remember the size of the allocationŸ7** so that we can find it later using sqlite3MemSize().¢**ŸE** For this low-level routine, we are guaranteed that nByte>0 becauseŸG** cases of nByte<=0 will be intercepted and dealt with by higher level¨** routines.¢*/Ÿ)static void *sqlite3MemMalloc(int nByte){∏#ifdef SQLITE_MALLOCSIZE™  void *p;Ÿ#  testcase( ROUND8(nByte)==nByte );Ω  p = SQLITE_MALLOC( nByte );≠  if( p==0 ){Ÿ,    testcase( sqlite3GlobalConfig.xLog!=0 );ŸN    sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);£  }´  return p;•#else≥  sqlite3_int64 *p;¥  assert( nByte>0 );Ÿ#  testcase( ROUND8(nByte)!=nByte );ø  p = SQLITE_MALLOC( nByte+8 );™  if( p ){±    p[0] = nByte;®    p++;®  }else{Ÿ,    testcase( sqlite3GlobalConfig.xLog!=0 );ŸN    sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);£  }≥  return (void *)p;¶#endif°}†¢/*ŸI** Like free() but works for allocations obtained from sqlite3MemMalloc()∫** or sqlite3MemRealloc().¢**ŸC** For this low-level routine, we already know that pPrior!=0 sinceŸA** cases where pPrior==0 will have been intecepted and dealt withº** by higher-level routines.¢*/Ÿ)static void sqlite3MemFree(void *pPrior){∏#ifdef SQLITE_MALLOCSIZE∂  SQLITE_FREE(pPrior);•#elseŸ,  sqlite3_int64 *p = (sqlite3_int64*)pPrior;∂  assert( pPrior!=0 );¶  p--;±  SQLITE_FREE(p);¶#endif°}†¢/*Ÿ=** Report the allocated size of a prior return from xMalloc()±** or xRealloc().¢*/Ÿ(static int sqlite3MemSize(void *pPrior){∏#ifdef SQLITE_MALLOCSIZE∂  assert( pPrior!=0 );Ÿ(  return (int)SQLITE_MALLOCSIZE(pPrior);•#else≥  sqlite3_int64 *p;∂  assert( pPrior!=0 );Ω  p = (sqlite3_int64*)pPrior;¶  p--;≥  return (int)p[0];¶#endif°}†¢/*ŸA** Like realloc().  Resize an allocation previously obtained from∂** sqlite3MemMalloc().¢**ŸE** For this low-level interface, we know that pPrior!=0.  Cases whereŸD** pPrior==0 while have been intercepted by higher-level routine andŸB** redirected to xMalloc.  Similarly, we know that nByte>0 becauseŸB** cases where nByte<=0 will have been intercepted by higher-levelŸ$** routines and redirected to xFree.¢*/Ÿ8static void *sqlite3MemRealloc(void *pPrior, int nByte){∏#ifdef SQLITE_MALLOCSIZEŸ*  void *p = SQLITE_REALLOC(pPrior, nByte);≠  if( p==0 ){Ÿ,    testcase( sqlite3GlobalConfig.xLog!=0 );Ω    sqlite3_log(SQLITE_NOMEM,Ÿ,      "failed memory resize %u to %u bytes",Ÿ(      SQLITE_MALLOCSIZE(pPrior), nByte);£  }´  return p;•#elseŸ,  sqlite3_int64 *p = (sqlite3_int64*)pPrior;Ÿ!  assert( pPrior!=0 && nByte>0 );Ÿ9  assert( nByte==ROUND8(nByte) ); /* EV: R-46199-30249 */¶  p--;Ÿ"  p = SQLITE_REALLOC(p, nByte+8 );™  if( p ){±    p[0] = nByte;®    p++;®  }else{Ÿ,    testcase( sqlite3GlobalConfig.xLog!=0 );Ω    sqlite3_log(SQLITE_NOMEM,Ÿ,      "failed memory resize %u to %u bytes",Ÿ%      sqlite3MemSize(pPrior), nByte);£  }≤  return (void*)p;¶#endif°}†¢/*Ÿ=** Round up a request size to the next valid allocation size.¢*/Ÿ$static int sqlite3MemRoundup(int n){≥  return ROUND8(n);°}†¢/*∫** Initialize this module.¢*/Ÿ)static int sqlite3MemInit(void *NotUsed){Ÿ=#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)Ø  int cpuCount;≠  size_t len;µ  if( _sqliteZone_ ){µ    return SQLITE_OK;£  }π  len = sizeof(cpuCount);ŸM  /* One usually wants to use hw.acctivecpu for MT decisions, but not here */Ÿ4  sysctlbyname("hw.ncpu", &cpuCount, &len, NULL, 0);≥  if( cpuCount>1 ){Ÿ-    /* defer MT decisions to system malloc */Ÿ)    _sqliteZone_ = malloc_default_zone();®  }else{ŸF    /* only 1 core, use our own zone to contention over global locks, Ÿ.    ** e.g. we have our own dedicated locks */Ÿ/    _sqliteZone_ = malloc_create_zone(4096, 0);Ÿ6    malloc_set_zone_name(_sqliteZone_, "Sqlite_Heap");£  }ŸG#endif /*  defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC) */º  UNUSED_PARAMETER(NotUsed);≥  return SQLITE_OK;°}†¢/*º** Deinitialize this module.¢*/Ÿ.static void sqlite3MemShutdown(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);©  return;°}†¢/*ŸG** This routine is the only routine in this file with external linkage.¢**Ÿ@** Populate the low-level memory allocation function pointers inŸD** sqlite3GlobalConfig.m with pointers to the routines in this file.¢*/Ÿ/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ÿ5  static const sqlite3_mem_methods defaultMethods = {∂     sqlite3MemMalloc,¥     sqlite3MemFree,∑     sqlite3MemRealloc,¥     sqlite3MemSize,∑     sqlite3MemRoundup,¥     sqlite3MemInit,∏     sqlite3MemShutdown,¶     0§  };Ÿ8  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);°}†Ÿ!#endif /* SQLITE_SYSTEM_MALLOC */†ŸO/************** End of mem1.c ************************************************/ŸO/************** Begin file mem2.c ********************************************/¢/*±** 2007 August 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸB** This file contains low-level memory allocation drivers for whenŸG** SQLite will use the standard C-library malloc/realloc/free interfaceŸJ** to obtain the memory it needs while adding lots of additional debuggingŸH** information to each allocation in order to help detect and fix memoryŸ!** leaks and memory usage errors.¢**ŸH** This file contains implementations of the low-level memory allocationŸ8** routines specified in the sqlite3_mem_methods object.¢*/º/* #include "sqliteInt.h" */†¢/*Ÿ;** This version of the memory allocator is used only if theŸ#** SQLITE_MEMDEBUG macro is defined¢*/∂#ifdef SQLITE_MEMDEBUG†¢/*Ÿ;** The backtrace functionality is only available with GLIBC¢*/∞#ifdef __GLIBC__Ÿ#  extern int backtrace(void**,int);Ÿ8  extern void backtrace_symbols_fd(void*const*,int,int);•#elseπ# define backtrace(A,B) 1Ÿ$# define backtrace_symbols_fd(A,B,C)¶#endif∏/* #include <stdio.h> */†¢/*Ÿ*** Each memory allocation looks like this:¢**ŸL**  ------------------------------------------------------------------------ŸL**  | Title |  backtrace pointers |  MemBlockHdr |  allocation |  EndGuard |ŸL**  ------------------------------------------------------------------------¢**ŸG** The application code sees only a pointer to the allocation.  We haveŸG** to back up from the allocation pointer to find the MemBlockHdr.  TheŸD** MemBlockHdr tells us the size of the allocation and the number ofŸD** backtrace pointers.  There is also a guard word at the end of theØ** MemBlockHdr.¢*/¥struct MemBlockHdr {ŸC  i64 iSize;                          /* Size of this allocation */ŸM  struct MemBlockHdr *pNext, *pPrev;  /* Linked list of all unfreed memory */ŸN  char nBacktrace;                    /* Number of backtraces on this alloc */ŸE  char nBacktraceSlots;               /* Available backtrace slots */ŸI  u8 nTitle;                          /* Bytes of title; includes '\0' */Ÿ@  u8 eType;                           /* Allocation type code */ŸA  int iForeGuard;                     /* Guard word for sanity */¢};†¢/*Æ** Guard words¢*/º#define FOREGUARD 0x80F5E153º#define REARGUARD 0xE4676B53†¢/*Ÿ-** Number of malloc size increments to track.¢*/¥#define NCSIZE  1000†¢/*Ÿ@** All of the static variables used by this module are collectedŸ<** into a single structure named "mem".  This is to keep theŸ?** static variables organized and to reduce namespace pollutionŸ?** when this module is combined with other in the amalgamation.¢*/Østatic struct {¢  §  /*Ÿ@  ** Mutex to control access to the memory allocation subsystem.§  */∑  sqlite3_mutex *mutex;†§  /*ŸB  ** Head and tail of a linked list of all outstanding allocations§  */Ω  struct MemBlockHdr *pFirst;º  struct MemBlockHdr *pLast;¢  §  /*ŸB  ** The number of levels of backtrace to save in new allocations.§  */±  int nBacktrace;Ÿ(  void (*xBacktrace)(int, int, void **);†§  /*Ÿ0  ** Title text to insert in front of each block§  */ŸN  int nTitle;        /* Bytes of zTitle to save.  Includes '\0' and padding */Ÿ)  char zTitle[100];  /* The title text */†•  /* Ÿ>  ** sqlite3MallocDisallow() increments the following counter.Ÿ(  ** sqlite3MallocAllow() decrements it.§  */Ÿ4  int disallow; /* Do not allow memory allocation */†§  /*Ÿ:  ** Gather statistics on the sizes of memory allocations.Ÿ:  ** nAlloc[i] is the number of allocation attempts of i*8Ÿ?  ** bytes.  i==NCSIZE is the number of allocation attempts forŸ$  ** sizes more than NCSIZE*8 bytes.§  */Ÿ<  int nAlloc[NCSIZE];      /* Total number of allocations */Ÿ>  int nCurrent[NCSIZE];    /* Current number of allocations */Ÿ<  int mxCurrent[NCSIZE];   /* Highwater mark for nCurrent */†¶} mem;††¢/*Ÿ!** Adjust memory usage statistics¢*/Ÿ2static void adjustStats(int iSize, int increment){∫  int i = ROUND8(iSize)/8;≥  if( i>NCSIZE-1 ){≥    i = NCSIZE - 1;£  }¥  if( increment>0 ){¥    mem.nAlloc[i]++;∂    mem.nCurrent[i]++;Ÿ+    if( mem.nCurrent[i]>mem.mxCurrent[i] ){Ÿ)      mem.mxCurrent[i] = mem.nCurrent[i];•    }®  }else{∂    mem.nCurrent[i]--;Ÿ!    assert( mem.nCurrent[i]>=0 );£  }°}†¢/*ŸA** Given an allocation, find the MemBlockHdr for that allocation.¢**ŸE** This routine checks the guards at either end of the allocation andŸ$** if they are incorrect it asserts.¢*/ŸEstatic struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){∏  struct MemBlockHdr *p;¨  int *pInt;™  u8 *pU8;Ø  int nReserve;†Ÿ'  p = (struct MemBlockHdr*)pAllocation;¶  p--;Ÿ*  assert( p->iForeGuard==(int)FOREGUARD );æ  nReserve = ROUND8(p->iSize);ª  pInt = (int*)pAllocation;π  pU8 = (u8*)pAllocation;Ÿ7  assert( pInt[nReserve/sizeof(int)]==(int)REARGUARD );Ÿ7  /* This checks any of the "extra" bytes allocated dueŸ4  ** to rounding up to an 8 byte boundary to ensure Ÿ#  ** they haven't been overwritten.§  */Ÿ?  while( nReserve-- > p->iSize ) assert( pU8[nReserve]==0x65 );´  return p;°}†¢/*Ÿ?** Return the number of bytes currently allocated at address p.¢*/Ÿ#static int sqlite3MemSize(void *p){ª  struct MemBlockHdr *pHdr;´  if( !p ){≠    return 0;£  }Ÿ#  pHdr = sqlite3MemsysGetHeader(p);∫  return (int)pHdr->iSize;°}†¢/*Ÿ.** Initialize the memory allocation subsystem.¢*/Ÿ)static int sqlite3MemInit(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);Ÿ0  assert( (sizeof(struct MemBlockHdr)&7) == 0 );Ÿ&  if( !sqlite3GlobalConfig.bMemstat ){ŸJ    /* If memory status is enabled, then the malloc.c wrapper will alreadyŸG    ** hold the STATIC_MEM mutex when the routines here are invoked. */Ÿ;    mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);£  }≥  return SQLITE_OK;°}†¢/*Ÿ0** Deinitialize the memory allocation subsystem.¢*/Ÿ.static void sqlite3MemShutdown(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);∞  mem.mutex = 0;°}†¢/*Ÿ=** Round up a request size to the next valid allocation size.¢*/Ÿ$static int sqlite3MemRoundup(int n){≥  return ROUND8(n);°}†¢/*ŸB** Fill a buffer with pseudo-random bytes.  This is used to presetŸE** the content of a new memory allocation to unpredictable values andŸF** to clear the content of a freed allocation to unpredictable values.¢*/Ÿ.static void randomFill(char *pBuf, int nByte){∑  unsigned int x, y, r;æ  x = SQLITE_PTR_TO_INT(pBuf);∞  y = nByte | 1;∂  while( nByte >= 4 ){Ÿ,    x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);Ω    y = y*1103515245 + 12345;Æ    r = x ^ y;¥    *(int*)pBuf = r;Æ    pBuf += 4;Ø    nByte -= 4;£  }∑  while( nByte-- > 0 ){Ÿ,    x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);Ω    y = y*1103515245 + 12345;Æ    r = x ^ y;π    *(pBuf++) = r & 0xff;£  }°}†¢/*Ÿ"** Allocate nByte bytes of memory.¢*/Ÿ)static void *sqlite3MemMalloc(int nByte){ª  struct MemBlockHdr *pHdr;≠  void **pBt;™  char *z;¨  int *pInt;Æ  void *p = 0;∞  int totalSize;Ø  int nReserve;Ÿ!  sqlite3_mutex_enter(mem.mutex);º  assert( mem.disallow==0 );ª  nReserve = ROUND8(nByte);Ÿ6  totalSize = nReserve + sizeof(*pHdr) + sizeof(int) +Ÿ9               mem.nBacktrace*sizeof(void*) + mem.nTitle;∏  p = malloc(totalSize);™  if( p ){™    z = p;Ÿ!    pBt = (void**)&z[mem.nTitle];Ÿ5    pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace];¥    pHdr->pNext = 0;º    pHdr->pPrev = mem.pLast;¥    if( mem.pLast ){æ      mem.pLast->pNext = pHdr;™    }else{∏      mem.pFirst = pHdr;•    }µ    mem.pLast = pHdr;Ÿ!    pHdr->iForeGuard = FOREGUARD;ø    pHdr->eType = MEMTYPE_HEAP;Ÿ+    pHdr->nBacktraceSlots = mem.nBacktrace;æ    pHdr->nTitle = mem.nTitle;π    if( mem.nBacktrace ){∂      void *aAddr[40];Ÿ>      pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1;Ÿ=      memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));µ      assert(pBt[0]);ª      if( mem.xBacktrace ){Ÿ=        mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]);ß      }™    }else{ª      pHdr->nBacktrace = 0;•    }µ    if( mem.nTitle ){Ÿ(      memcpy(z, mem.zTitle, mem.nTitle);•    }∏    pHdr->iSize = nByte;ª    adjustStats(nByte, +1);∫    pInt = (int*)&pHdr[1];Ÿ+    pInt[nReserve/sizeof(int)] = REARGUARD;Ÿ#    randomFill((char*)pInt, nByte);Ÿ6    memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);¥    p = (void*)pInt;£  }Ÿ!  sqlite3_mutex_leave(mem.mutex);¨  return p; °}†¢/*Ø** Free memory.¢*/Ÿ)static void sqlite3MemFree(void *pPrior){ª  struct MemBlockHdr *pHdr;≠  void **pBt;™  char *z;ŸL  assert( sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0 π       || mem.mutex!=0 );Ÿ(  pHdr = sqlite3MemsysGetHeader(pPrior);µ  pBt = (void**)pHdr;ø  pBt -= pHdr->nBacktraceSlots;Ÿ!  sqlite3_mutex_enter(mem.mutex);¥  if( pHdr->pPrev ){Ÿ'    assert( pHdr->pPrev->pNext==pHdr );Ÿ%    pHdr->pPrev->pNext = pHdr->pNext;®  }else{ø    assert( mem.pFirst==pHdr );Ω    mem.pFirst = pHdr->pNext;£  }¥  if( pHdr->pNext ){Ÿ'    assert( pHdr->pNext->pPrev==pHdr );Ÿ%    pHdr->pNext->pPrev = pHdr->pPrev;®  }else{æ    assert( mem.pLast==pHdr );º    mem.pLast = pHdr->pPrev;£  }±  z = (char*)pBt;¥  z -= pHdr->nTitle;Ÿ$  adjustStats((int)pHdr->iSize, -1);ŸE  randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +Ÿ?                (int)pHdr->iSize + sizeof(int) + pHdr->nTitle);™  free(z);Ÿ#  sqlite3_mutex_leave(mem.mutex);  °}†¢/*Ÿ4** Change the size of an existing memory allocation.¢**ŸD** For this debugging implementation, we *always* make a copy of theŸ?** allocation into a new place in memory.  In this way, if the ŸC** higher level code is using pointer to the old allocation, it is Ÿ@** much more likely to break and we are much more liking to find≠** the error.¢*/Ÿ8static void *sqlite3MemRealloc(void *pPrior, int nByte){æ  struct MemBlockHdr *pOldHdr;≠  void *pNew;º  assert( mem.disallow==0 );Ÿ7  assert( (nByte & 7)==0 );     /* EV: R-46199-30249 */Ÿ+  pOldHdr = sqlite3MemsysGetHeader(pPrior);Ÿ!  pNew = sqlite3MemMalloc(nByte);≠  if( pNew ){ŸO    memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));ø    if( nByte>pOldHdr->iSize ){ŸN      randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - (int)pOldHdr->iSize);•    }ª    sqlite3MemFree(pPrior);£  }Æ  return pNew;°}†¢/*Ÿ@** Populate the low-level memory allocation function pointers inŸD** sqlite3GlobalConfig.m with pointers to the routines in this file.¢*/Ÿ/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ÿ5  static const sqlite3_mem_methods defaultMethods = {∂     sqlite3MemMalloc,¥     sqlite3MemFree,∑     sqlite3MemRealloc,¥     sqlite3MemSize,∑     sqlite3MemRoundup,¥     sqlite3MemInit,∏     sqlite3MemShutdown,¶     0§  };Ÿ8  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);°}†¢/*Ÿ#** Set the "type" of an allocation.¢*/Ÿ>SQLITE_PRIVATE void sqlite3MemdebugSetType(void *p, u8 eType){Ÿ=  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){Ω    struct MemBlockHdr *pHdr;Ÿ%    pHdr = sqlite3MemsysGetHeader(p);Ÿ*    assert( pHdr->iForeGuard==FOREGUARD );∏    pHdr->eType = eType;£  }°}†¢/*ŸC** Return TRUE if the mask of type in eType matches the type of theŸ.** allocation p.  Also return true if p==NULL.¢**ŸD** This routine is designed for use within an assert() statement, toŸ2** verify the type of an allocation.  For example:¢**Ÿ9**     assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );¢*/Ÿ=SQLITE_PRIVATE int sqlite3MemdebugHasType(void *p, u8 eType){≠  int rc = 1;Ÿ=  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){Ω    struct MemBlockHdr *pHdr;Ÿ%    pHdr = sqlite3MemsysGetHeader(p);ŸL    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */Ÿ!    if( (pHdr->eType&eType)==0 ){≠      rc = 0;•    }£  }¨  return rc;°}†¢/*ŸN** Return TRUE if the mask of type in eType matches no bits of the type of theŸ.** allocation p.  Also return true if p==NULL.¢**ŸD** This routine is designed for use within an assert() statement, toŸ2** verify the type of an allocation.  For example:¢**Ÿ=**     assert( sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );¢*/Ÿ<SQLITE_PRIVATE int sqlite3MemdebugNoType(void *p, u8 eType){≠  int rc = 1;Ÿ=  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){Ω    struct MemBlockHdr *pHdr;Ÿ%    pHdr = sqlite3MemsysGetHeader(p);ŸL    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */Ÿ!    if( (pHdr->eType&eType)!=0 ){≠      rc = 0;•    }£  }¨  return rc;°}†¢/*Ÿ?** Set the number of backtrace levels kept for each allocation.ŸG** A value of zero turns off backtracing.  The number is always roundedπ** up to a multiple of 2.¢*/Ÿ8SQLITE_PRIVATE void sqlite3MemdebugBacktrace(int depth){Ω  if( depth<0 ){ depth = 0; }ø  if( depth>20 ){ depth = 20; }π  depth = (depth+1)&0xfe;π  mem.nBacktrace = depth;°}†Ÿ\SQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){æ  mem.xBacktrace = xBacktrace;°}†¢/*Ÿ3** Set the title string for subsequent allocations.¢*/Ÿ@SQLITE_PRIVATE void sqlite3MemdebugSettitle(const char *zTitle){Ÿ/  unsigned int n = sqlite3Strlen30(zTitle) + 1;Ÿ!  sqlite3_mutex_enter(mem.mutex);Ÿ7  if( n>=sizeof(mem.zTitle) ) n = sizeof(mem.zTitle)-1;Ÿ   memcpy(mem.zTitle, zTitle, n);¥  mem.zTitle[n] = 0;π  mem.nTitle = ROUND8(n);Ÿ!  sqlite3_mutex_leave(mem.mutex);°}†Ÿ*SQLITE_PRIVATE void sqlite3MemdebugSync(){ª  struct MemBlockHdr *pHdr;Ÿ/  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){æ    void **pBt = (void**)pHdr;Ÿ!    pBt -= pHdr->nBacktraceSlots;ŸB    mem.xBacktrace((int)pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]);£  }°}†¢/*ŸA** Open the file indicated and write a log of all unfreed memory Ω** allocations into that log.¢*/Ÿ?SQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename){¨  FILE *out;ª  struct MemBlockHdr *pHdr;≠  void **pBt;®  int i;æ  out = fopen(zFilename, "w");Ø  if( out==0 ){ŸK    fprintf(stderr, "** Unable to output memory debug output log: %s **\n",ø                    zFilename);´    return;£  }Ÿ/  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){∫    char *z = (char*)pHdr;Ÿ<    z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;Ÿ9    fprintf(out, "**** %lld bytes at %p from %s ****\n", Ÿ=            pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : "???");ª    if( pHdr->nBacktrace ){≤      fflush(out);π      pBt = (void**)pHdr;Ÿ#      pBt -= pHdr->nBacktraceSlots;Ÿ?      backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));π      fprintf(out, "\n");•    }£  }º  fprintf(out, "COUNTS:\n");º  for(i=0; i<NCSIZE-1; i++){∏    if( mem.nAlloc[i] ){Ÿ/      fprintf(out, "   %5d: %10d %10d %10d\n", ŸC            i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);•    }£  }Ω  if( mem.nAlloc[NCSIZE-1] ){Ÿ,    fprintf(out, "   %5d: %10d %10d %10d\n",Ÿ.             NCSIZE*8-8, mem.nAlloc[NCSIZE-1],Ÿ>             mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]);£  }Æ  fclose(out);°}†¢/*ŸA** Return the number of times sqlite3MemMalloc() has been called.¢*/Ÿ0SQLITE_PRIVATE int sqlite3MemdebugMallocCount(){®  int i;±  int nTotal = 0;∫  for(i=0; i<NCSIZE; i++){º    nTotal += mem.nAlloc[i];£  }∞  return nTotal;°}††º#endif /* SQLITE_MEMDEBUG */†ŸO/************** End of mem2.c ************************************************/ŸO/************** Begin file mem3.c ********************************************/¢/*≤** 2007 October 14¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ=** This file contains the C functions that implement a memoryŸ+** allocation subsystem for use by SQLite. ¢**Ÿ<** This version of the memory allocation subsystem omits allŸ>** use of malloc(). The SQLite user supplies a block of memoryŸ=** before calling sqlite3_initialize() from which allocationsŸ9** are made and returned by the xMalloc() and xRealloc() Ÿ>** implementations. Once sqlite3_initialize() has been called,Ÿ?** the amount of memory available to SQLite is fixed and cannotÆ** be changed.¢**Ÿ>** This version of the memory allocation subsystem is includedŸ9** in the build only if SQLITE_ENABLE_MEMSYS3 is defined.¢*/º/* #include "sqliteInt.h" */†¢/*ŸF** This version of the memory allocator is only built into the libraryŸB** SQLITE_ENABLE_MEMSYS3 is defined. Defining this symbol does notŸE** mean that the library will use a memory-pool by default, just thatŸA** it is available. The mempool allocator is activated by calling¥** sqlite3_config().¢*/º#ifdef SQLITE_ENABLE_MEMSYS3†¢/*Ÿ3** Maximum size (in Mem3Blocks) of a "small" chunk.¢*/≥#define MX_SMALL 10††¢/*Ÿ ** Number of freelist hash slots¢*/≤#define N_HASH  61†¢/*ŸB** A memory allocation (also called a "chunk") consists of two or ŸC** more blocks where each block is 8 bytes.  The first 8 bytes are Ÿ-** a header that is not returned to the user.¢**Ÿ>** A chunk is two or more blocks that is either checked out orŸH** free.  The first block has format u.hdr.  u.hdr.size4x is 4 times theŸ>** size of the allocation in blocks if the allocation is free.ŸA** The u.hdr.size4x&1 bit is true if the chunk is checked out andŸA** false if the chunk is on the freelist.  The u.hdr.size4x&2 bitŸ@** is true if the previous chunk is checked out and false if theŸC** previous chunk is free.  The u.hdr.prevSize field is the size ofŸ?** the previous chunk in blocks if the previous chunk is on theŸ7** freelist. If the previous chunk is checked out, thenŸC** u.hdr.prevSize can be part of the data for that chunk and should∫** not be read or written.¢**Ÿ@** We often identify a chunk by its index in mem3.aPool[].  WhenŸ>** this is done, the chunk index refers to the second block ofŸ>** the chunk.  In this way, the first chunk has an index of 1.ŸA** A chunk index of 0 means "no such chunk" and is the equivalentµ** of a NULL pointer.¢**Ÿ>** The second block of free chunks is of the form u.list.  TheŸC** two fields form a double-linked list of chunks of related sizes.ŸA** Pointers to the head of the list are stored in mem3.aiSmall[] Ÿ:** for smaller chunks and mem3.aiHash[] for larger chunks.¢**ŸD** The second block of a chunk is user data if the chunk is checked ŸA** out.  If a chunk is checked out, the user data may extend intoŸ3** the u.hdr.prevSize value of the following chunk.¢*/Ÿ#typedef struct Mem3Block Mem3Block;≤struct Mem3Block {©  union {¨    struct {ŸH      u32 prevSize;   /* Size of previous chunk in Mem3Block elements */ŸN      u32 size4x;     /* 4x the size of current chunk in Mem3Block elements */™    } hdr;¨    struct {ŸD      u32 next;       /* Index in mem3.aPool[] of next free chunk */ŸH      u32 prev;       /* Index in mem3.aPool[] of previous free chunk */´    } list;¶  } u;¢};†¢/*Ÿ@** All of the static variables used by this module are collectedŸ=** into a single structure named "mem3".  This is to keep theŸ?** static variables organized and to reduce namespace pollutionŸ?** when this module is combined with other in the amalgamation.¢*/Ÿ%static SQLITE_WSD struct Mem3Global {§  /*ŸD  ** Memory available for allocation. nPool is the size of the arrayŸ0  ** (in Mem3Blocks) pointed to by aPool less 2.§  */¨  u32 nPool;≥  Mem3Block *aPool;†§  /*Ÿ9  ** True if we are evaluating an out-of-memory callback.§  */∞  int alarmBusy;¢  §  /*Ÿ@  ** Mutex to control access to the memory allocation subsystem.§  */∑  sqlite3_mutex *mutex;¢  §  /*Ÿ8  ** The minimum amount of free space that we have seen.§  */Ø  u32 mnMaster;†§  /*ŸD  ** iMaster is the index of the master chunk.  Most new allocationsŸC  ** occur off of this chunk.  szMaster is the size (in Mem3Blocks)ŸG  ** of the current master.  iMaster is 0 if there is not master chunk.ŸA  ** The master chunk is not in either the aiHash[] or aiSmall[].§  */Æ  u32 iMaster;Ø  u32 szMaster;†§  /*Ÿ?  ** Array of lists of free blocks according to the block size Ÿ?  ** for smaller chunks, or a hash on the block size for larger¨  ** chunks.§  */ŸJ  u32 aiSmall[MX_SMALL-1];   /* For sizes 2 through MX_SMALL, inclusive */ŸB  u32 aiHash[N_HASH];        /* For sizes MX_SMALL+1 and larger */∂} mem3 = { 97535575 };†Ÿ,#define mem3 GLOBAL(struct Mem3Global, mem3)†¢/*Ÿ>** Unlink the chunk at mem3.aPool[i] from list it is currentlyŸ1** on.  *pRoot is the list that i is a member of.¢*/Ÿ5static void memsys3UnlinkFromList(u32 i, u32 *pRoot){Ÿ'  u32 next = mem3.aPool[i].u.list.next;Ÿ'  u32 prev = mem3.aPool[i].u.list.prev;Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );∞  if( prev==0 ){≤    *pRoot = next;®  }else{Ÿ(    mem3.aPool[prev].u.list.next = next;£  }≠  if( next ){Ÿ(    mem3.aPool[next].u.list.prev = prev;£  }Ÿ   mem3.aPool[i].u.list.next = 0;Ÿ   mem3.aPool[i].u.list.prev = 0;°}†¢/*Ÿ$** Unlink the chunk at index i from Ÿ*** whatever list is currently a member of.¢*/Ÿ!static void memsys3Unlink(u32 i){±  u32 size, hash;Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );Ÿ2  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );±  assert( i>=1 );Ÿ(  size = mem3.aPool[i-1].u.hdr.size4x/4;Ÿ6  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );¥  assert( size>=2 );π  if( size <= MX_SMALL ){Ÿ4    memsys3UnlinkFromList(i, &mem3.aiSmall[size-2]);®  }else{π    hash = size % N_HASH;Ÿ1    memsys3UnlinkFromList(i, &mem3.aiHash[hash]);£  }°}†¢/*Ÿ@** Link the chunk at mem3.aPool[i] so that is on the list rooted≠** at *pRoot.¢*/Ÿ3static void memsys3LinkIntoList(u32 i, u32 *pRoot){Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );Ÿ%  mem3.aPool[i].u.list.next = *pRoot;Ÿ   mem3.aPool[i].u.list.prev = 0;Ø  if( *pRoot ){Ÿ'    mem3.aPool[*pRoot].u.list.prev = i;£  }≠  *pRoot = i;°}†¢/*Ÿ8** Link the chunk at index i into either the appropriateŸ8** small chunk list, or into the large chunk hash table.¢*/østatic void memsys3Link(u32 i){±  u32 size, hash;Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );±  assert( i>=1 );Ÿ2  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );Ÿ(  size = mem3.aPool[i-1].u.hdr.size4x/4;Ÿ6  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );¥  assert( size>=2 );π  if( size <= MX_SMALL ){Ÿ2    memsys3LinkIntoList(i, &mem3.aiSmall[size-2]);®  }else{π    hash = size % N_HASH;Ÿ/    memsys3LinkIntoList(i, &mem3.aiHash[hash]);£  }°}†¢/*ŸH** If the STATIC_MEM mutex is not already held, obtain it now. The mutexŸ9** will already be held (obtained by code in malloc.c) ifŸ(** sqlite3GlobalConfig.bMemStat is true.¢*/østatic void memsys3Enter(void){Ÿ9  if( sqlite3GlobalConfig.bMemstat==0 && mem3.mutex==0 ){Ÿ<    mem3.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);£  }Ÿ"  sqlite3_mutex_enter(mem3.mutex);°}østatic void memsys3Leave(void){Ÿ"  sqlite3_mutex_leave(mem3.mutex);°}†¢/*Ÿ@** Called when we are unable to satisfy an allocation of nBytes.¢*/Ÿ*static void memsys3OutOfMemory(int nByte){∏  if( !mem3.alarmBusy ){∑    mem3.alarmBusy = 1;Ÿ-    assert( sqlite3_mutex_held(mem3.mutex) );Ÿ$    sqlite3_mutex_leave(mem3.mutex);Ÿ"    sqlite3_release_memory(nByte);Ÿ$    sqlite3_mutex_enter(mem3.mutex);∑    mem3.alarmBusy = 0;£  }°}††¢/*Ÿ?** Chunk i is a free chunk that has been unlinked.  Adjust its Ÿ=** size parameters for check-out and return a pointer to the Ω** user portion of the chunk.¢*/Ÿ0static void *memsys3Checkout(u32 i, u32 nBlock){®  u32 x;Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );±  assert( i>=1 );Ÿ3  assert( mem3.aPool[i-1].u.hdr.size4x/4==nBlock );Ÿ:  assert( mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock );Ÿ#  x = mem3.aPool[i-1].u.hdr.size4x;Ÿ6  mem3.aPool[i-1].u.hdr.size4x = nBlock*4 | 1 | (x&2);Ÿ1  mem3.aPool[i+nBlock-1].u.hdr.prevSize = nBlock;Ÿ+  mem3.aPool[i+nBlock-1].u.hdr.size4x |= 2;∏  return &mem3.aPool[i];°}†¢/*Ÿ?** Carve a piece off of the end of the mem3.iMaster free chunk.ŸC** Return a pointer to the new allocation.  Or, if the master chunkŸ!** is not large enough, return 0.¢*/Ÿ+static void *memsys3FromMaster(u32 nBlock){Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );Ÿ"  assert( mem3.szMaster>=nBlock );Ÿ   if( nBlock>=mem3.szMaster-1 ){ø    /* Use the entire master */Ÿ;    void *p = memsys3Checkout(mem3.iMaster, mem3.szMaster);µ    mem3.iMaster = 0;∂    mem3.szMaster = 0;∂    mem3.mnMaster = 0;≠    return p;®  }else{Ÿ3    /* Split the master block.  Return the tail. */∞    u32 newi, x;Ÿ1    newi = mem3.iMaster + mem3.szMaster - nBlock;Ÿ$    assert( newi > mem3.iMaster+1 );ŸE    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = nBlock;Ÿ?    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x |= 2;Ÿ3    mem3.aPool[newi-1].u.hdr.size4x = nBlock*4 + 1;º    mem3.szMaster -= nBlock;Ÿ6    mem3.aPool[newi-1].u.hdr.prevSize = mem3.szMaster;Ÿ4    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;ŸB    mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;Ÿ(    if( mem3.szMaster < mem3.mnMaster ){Ÿ$      mem3.mnMaster = mem3.szMaster;•    }Ÿ$    return (void*)&mem3.aPool[newi];£  }°}†¢/*Ÿ?** *pRoot is the head of a list of free chunks of the same sizeŸC** or same size hash.  In other words, *pRoot is an entry in eitherŸ%** mem3.aiSmall[] or mem3.aiHash[].  ¢**Ÿ@** This routine examines all entries on the given list and triesŸ8** to coalesce each entries with adjacent free chunks.  ¢**ŸD** If it sees a chunk that is larger than mem3.iMaster, it replaces ŸD** the current mem3.iMaster with the new larger chunk.  In order forŸB** this mem3.iMaster replacement to work, the master chunk must beŸ@** linked into the hash tables.  That is not the normal state ofŸ@** affairs, of course.  The calling routine must link the masterŸE** chunk before invoking this routine, then must unlink the (possiblyŸ8** changed) master chunk once this routine has finished.¢*/Ÿ%static void memsys3Merge(u32 *pRoot){æ  u32 iNext, prev, size, i, x;†Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );æ  for(i=*pRoot; i>0; i=iNext){Ÿ&    iNext = mem3.aPool[i].u.list.next;Ÿ(    size = mem3.aPool[i-1].u.hdr.size4x;∫    assert( (size&1)==0 );∂    if( (size&2)==0 ){Ÿ&      memsys3UnlinkFromList(i, pRoot);Ÿ3      assert( i > mem3.aPool[i-1].u.hdr.prevSize );Ÿ0      prev = i - mem3.aPool[i-1].u.hdr.prevSize;∏      if( prev==iNext ){Ÿ-        iNext = mem3.aPool[prev].u.list.next;ß      }∫      memsys3Unlink(prev);ø      size = i + size/4 - prev;Ÿ.      x = mem3.aPool[prev-1].u.hdr.size4x & 2;Ÿ3      mem3.aPool[prev-1].u.hdr.size4x = size*4 | x;Ÿ4      mem3.aPool[prev+size-1].u.hdr.prevSize = size;∏      memsys3Link(prev);Ø      i = prev;™    }else{∞      size /= 4;•    }Ω    if( size>mem3.szMaster ){∑      mem3.iMaster = i;ª      mem3.szMaster = size;•    }£  }°}†¢/*Ÿ7** Return a block of memory of at least nBytes in size.π** Return NULL if unable.¢**Ÿ@** This function assumes that the necessary mutexes, if any, areŸ.** already held by the caller. Hence "Unsafe".¢*/Ÿ,static void *memsys3MallocUnsafe(int nByte){®  u32 i;≠  u32 nBlock;≠  u32 toFree;†Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );Ÿ!  assert( sizeof(Mem3Block)==8 );≤  if( nByte<=12 ){Ø    nBlock = 2;®  }else{º    nBlock = (nByte + 11)/8;£  }∂  assert( nBlock>=2 );†¨  /* STEP 1:Ÿ>  ** Look for an entry of the correct size in either the smallŸ;  ** chunk table or in the large chunk hash table.  This isŸ;  ** successful most of the time (about 9 times out of 10).§  */ª  if( nBlock <= MX_SMALL ){ø    i = mem3.aiSmall[nBlock-2];Æ    if( i>0 ){Ÿ8      memsys3UnlinkFromList(i, &mem3.aiSmall[nBlock-2]);Ÿ(      return memsys3Checkout(i, nBlock);•    }®  }else{ø    int hash = nBlock % N_HASH;Ÿ?    for(i=mem3.aiHash[hash]; i>0; i=mem3.aPool[i].u.list.next){Ÿ3      if( mem3.aPool[i-1].u.hdr.size4x/4==nBlock ){Ÿ5        memsys3UnlinkFromList(i, &mem3.aiHash[hash]);Ÿ*        return memsys3Checkout(i, nBlock);ß      }•    }£  }†¨  /* STEP 2:ŸD  ** Try to satisfy the allocation by carving a piece off of the endŸC  ** of the master chunk.  This step usually works if step 1 fails.§  */æ  if( mem3.szMaster>=nBlock ){Ÿ%    return memsys3FromMaster(nBlock);£  }††Æ  /* STEP 3:  ŸA  ** Loop through the entire memory pool.  Coalesce adjacent freeŸC  ** chunks.  Recompute the master chunk as the largest free chunk.ŸD  ** Then try again to satisfy the allocation by carving a piece offŸ<  ** of the end of the master chunk.  This step happens very∂  ** rarely (we hope!)§  */Ÿ=  for(toFree=nBlock*16; toFree<(mem3.nPool*16); toFree *= 2){ø    memsys3OutOfMemory(toFree);∑    if( mem3.iMaster ){Ÿ       memsys3Link(mem3.iMaster);∑      mem3.iMaster = 0;∏      mem3.szMaster = 0;•    }º    for(i=0; i<N_HASH; i++){Ÿ$      memsys3Merge(&mem3.aiHash[i]);•    }Ÿ     for(i=0; i<MX_SMALL-1; i++){Ÿ%      memsys3Merge(&mem3.aiSmall[i]);•    }∏    if( mem3.szMaster ){Ÿ"      memsys3Unlink(mem3.iMaster);Ÿ"      if( mem3.szMaster>=nBlock ){Ÿ)        return memsys3FromMaster(nBlock);ß      }•    }£  }†Ÿ2  /* If none of the above worked, then we fail. */´  return 0;°}†¢/*Ÿ)** Free an outstanding memory allocation.¢**Ÿ@** This function assumes that the necessary mutexes, if any, areŸ.** already held by the caller. Hence "Unsafe".¢*/Ÿ*static void memsys3FreeUnsafe(void *pOld){Ÿ"  Mem3Block *p = (Mem3Block*)pOld;®  int i;Æ  u32 size, x;Ÿ+  assert( sqlite3_mutex_held(mem3.mutex) );Ÿ6  assert( p>mem3.aPool && p<&mem3.aPool[mem3.nPool] );µ  i = p - mem3.aPool;Ÿ0  assert( (mem3.aPool[i-1].u.hdr.size4x&1)==1 );Ÿ(  size = mem3.aPool[i-1].u.hdr.size4x/4;Ÿ!  assert( i+size<=mem3.nPool+1 );Ÿ%  mem3.aPool[i-1].u.hdr.size4x &= ~1;Ÿ-  mem3.aPool[i+size-1].u.hdr.prevSize = size;Ÿ*  mem3.aPool[i+size-1].u.hdr.size4x &= ~2;±  memsys3Link(i);†Ÿ<  /* Try to expand the master using the newly freed chunk */µ  if( mem3.iMaster ){Ÿ<    while( (mem3.aPool[mem3.iMaster-1].u.hdr.size4x&2)==0 ){Ÿ7      size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize;ª      mem3.iMaster -= size;º      mem3.szMaster += size;Ÿ"      memsys3Unlink(mem3.iMaster);Ÿ6      x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;ŸD      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;ŸN      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;•    }Ÿ4    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;ŸJ    while( (mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x&1)==0 ){Ÿ0      memsys3Unlink(mem3.iMaster+mem3.szMaster);ŸO      mem3.szMaster += mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x/4;ŸD      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;ŸN      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;•    }£  }°}†¢/*Ÿ?** Return the size of an outstanding allocation, in bytes.  TheŸ=** size returned omits the 8-byte header overhead.  This onlyŸ3** works for chunks that are currently checked out.¢*/Ÿ static int memsys3Size(void *p){¥  Mem3Block *pBlock;±  assert( p!=0 );π  pBlock = (Mem3Block*)p;Ÿ+  assert( (pBlock[-1].u.hdr.size4x&1)!=0 );Ÿ,  return (pBlock[-1].u.hdr.size4x&~3)*2 - 4;°}†¢/*Ÿ=** Round up a request size to the next valid allocation size.¢*/Ÿ!static int memsys3Roundup(int n){Æ  if( n<=12 ){Æ    return 12;®  }else{ª    return ((n+11)&~7) - 4;£  }°}†¢/*Ω** Allocate nBytes of memory.¢*/Ÿ'static void *memsys3Malloc(int nBytes){≥  sqlite3_int64 *p;ŸI  assert( nBytes>0 );          /* malloc.c filters out 0 byte requests */±  memsys3Enter();Ÿ"  p = memsys3MallocUnsafe(nBytes);±  memsys3Leave();≥  return (void*)p; °}†¢/*Ø** Free memory.¢*/Ÿ&static void memsys3Free(void *pPrior){≥  assert( pPrior );±  memsys3Enter();º  memsys3FreeUnsafe(pPrior);±  memsys3Leave();°}†¢/*Ÿ3** Change the size of an existing memory allocation¢*/Ÿ6static void *memsys3Realloc(void *pPrior, int nBytes){´  int nOld;™  void *p;≤  if( pPrior==0 ){Ÿ"    return sqlite3_malloc(nBytes);£  }≤  if( nBytes<=0 ){π    sqlite3_free(pPrior);≠    return 0;£  }Ω  nOld = memsys3Size(pPrior);Ÿ)  if( nBytes<=nOld && nBytes>=nOld-128 ){≤    return pPrior;£  }±  memsys3Enter();Ÿ"  p = memsys3MallocUnsafe(nBytes);™  if( p ){∂    if( nOld<nBytes ){æ      memcpy(p, pPrior, nOld);™    }else{Ÿ       memcpy(p, pPrior, nBytes);•    }æ    memsys3FreeUnsafe(pPrior);£  }±  memsys3Leave();´  return p;°}†¢/*∫** Initialize this module.¢*/Ÿ&static int memsys3Init(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);Ÿ#  if( !sqlite3GlobalConfig.pHeap ){∏    return SQLITE_ERROR;£  }†ŸE  /* Store a pointer to the memory block in global structure mem3. */Ÿ!  assert( sizeof(Mem3Block)==8 );Ÿ6  mem3.aPool = (Mem3Block *)sqlite3GlobalConfig.pHeap;ŸC  mem3.nPool = (sqlite3GlobalConfig.nHeap / sizeof(Mem3Block)) - 2;†Ÿ$  /* Initialize the master block. */Ω  mem3.szMaster = mem3.nPool;Ÿ   mem3.mnMaster = mem3.szMaster;≥  mem3.iMaster = 1;Ÿ6  mem3.aPool[0].u.hdr.size4x = (mem3.szMaster<<2) + 2;Ÿ5  mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool;Ÿ*  mem3.aPool[mem3.nPool].u.hdr.size4x = 1;†≥  return SQLITE_OK;°}†¢/*º** Deinitialize this module.¢*/Ÿ+static void memsys3Shutdown(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);±  mem3.mutex = 0;©  return;°}†††¢/*ŸA** Open the file indicated and write a log of all unfreed memory Ω** allocations into that log.¢*/Ÿ>SQLITE_PRIVATE void sqlite3Memsys3Dump(const char *zFilename){≥#ifdef SQLITE_DEBUG¨  FILE *out;´  u32 i, j;´  u32 size;Ÿ(  if( zFilename==0 || zFilename[0]==0 ){±    out = stdout;®  }else{Ÿ     out = fopen(zFilename, "w");±    if( out==0 ){ŸM      fprintf(stderr, "** Unable to output memory debug output log: %s **\n",Ÿ!                      zFilename);≠      return;•    }£  }±  memsys3Enter();º  fprintf(out, "CHUNKS:\n");Ÿ%  for(i=1; i<=mem3.nPool; i+=size/4){Ÿ(    size = mem3.aPool[i-1].u.hdr.size4x;¥    if( size/4<=1 ){Ÿ6      fprintf(out, "%p size error\n", &mem3.aPool[i]);≤      assert( 0 );¨      break;•    }ŸG    if( (size&1)==0 && mem3.aPool[i+size/4-1].u.hdr.prevSize!=size/4 ){ŸD      fprintf(out, "%p tail size does not match\n", &mem3.aPool[i]);≤      assert( 0 );¨      break;•    }ŸA    if( ((mem3.aPool[i+size/4-1].u.hdr.size4x&2)>>1)!=(size&1) ){ŸJ      fprintf(out, "%p tail checkout bit is incorrect\n", &mem3.aPool[i]);≤      assert( 0 );¨      break;•    }±    if( size&1 ){ŸO      fprintf(out, "%p %6d bytes checked out\n", &mem3.aPool[i], (size/4)*8-8);™    }else{ŸI      fprintf(out, "%p %6d bytes free%s\n", &mem3.aPool[i], (size/4)*8-8,Ÿ8                  i==mem3.iMaster ? " **master**" : "");•    }£  }æ  for(i=0; i<MX_SMALL-1; i++){Ÿ&    if( mem3.aiSmall[i]==0 ) continue;Ÿ#    fprintf(out, "small(%2d):", i);Ÿ?    for(j = mem3.aiSmall[i]; j>0; j=mem3.aPool[j].u.list.next){Ÿ-      fprintf(out, " %p(%d)", &mem3.aPool[j],Ÿ4              (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);•    }∏    fprintf(out, "\n"); £  }∫  for(i=0; i<N_HASH; i++){Ÿ%    if( mem3.aiHash[i]==0 ) continue;Ÿ"    fprintf(out, "hash(%2d):", i);Ÿ>    for(j = mem3.aiHash[i]; j>0; j=mem3.aPool[j].u.list.next){Ÿ-      fprintf(out, " %p(%d)", &mem3.aPool[j],Ÿ4              (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);•    }∏    fprintf(out, "\n"); £  }Ÿ,  fprintf(out, "master=%d\n", mem3.iMaster);Ÿ?  fprintf(out, "nowUsed=%d\n", mem3.nPool*8 - mem3.szMaster*8);Ÿ>  fprintf(out, "mxUsed=%d\n", mem3.nPool*8 - mem3.mnMaster*8);Ÿ"  sqlite3_mutex_leave(mem3.mutex);¥  if( out==stdout ){≥    fflush(stdout);®  }else{∞    fclose(out);£  }•#elseæ  UNUSED_PARAMETER(zFilename);¶#endif°}†¢/*Ÿ?** This routine is the only routine in this file with external ´** linkage.¢**Ÿ@** Populate the low-level memory allocation function pointers inŸH** sqlite3GlobalConfig.m with pointers to the routines in this file. TheŸ3** arguments specify the block of memory to manage.¢**ŸA** This routine is only called by sqlite3_config(), and thereforeŸ0** is not required to be threadsafe (it is not).¢*/ŸESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void){Ÿ5  static const sqlite3_mem_methods mempoolMethods = {≥     memsys3Malloc,±     memsys3Free,¥     memsys3Realloc,±     memsys3Size,¥     memsys3Roundup,±     memsys3Init,µ     memsys3Shutdown,¶     0§  };π  return &mempoolMethods;°}†Ÿ"#endif /* SQLITE_ENABLE_MEMSYS3 */†ŸO/************** End of mem3.c ************************************************/ŸO/************** Begin file mem5.c ********************************************/¢/*≤** 2007 October 14¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ=** This file contains the C functions that implement a memoryŸ+** allocation subsystem for use by SQLite. ¢**Ÿ<** This version of the memory allocation subsystem omits allŸB** use of malloc(). The application gives SQLite a block of memoryŸ=** before calling sqlite3_initialize() from which allocationsŸ9** are made and returned by the xMalloc() and xRealloc() Ÿ>** implementations. Once sqlite3_initialize() has been called,Ÿ?** the amount of memory available to SQLite is fixed and cannotÆ** be changed.¢**Ÿ>** This version of the memory allocation subsystem is includedŸ9** in the build only if SQLITE_ENABLE_MEMSYS5 is defined.¢**Ÿ6** This memory allocator uses the following algorithm:¢**ŸD**   1.  All memory allocation sizes are rounded up to a power of 2.¢**ŸF**   2.  If two adjacent free blocks are the halves of a larger block,ŸH**       then the two blocks are coalesced into the single larger block.¢**ŸE**   3.  New memory is allocated from the first available free block.¢**ŸK** This algorithm is described in: J. M. Robson. "Bounds for Some FunctionsŸI** Concerning Dynamic Storage Allocation". Journal of the Association forŸF** Computing Machinery, Volume 21, Number 8, July 1974, pages 491-499.£** ŸE** Let n be the size of the largest allocation divided by the minimumŸH** allocation size (after rounding all sizes up to a power of 2.)  Let MŸE** be the maximum amount of memory ever outstanding at one time.  LetŸD** N be the total amount of memory available for allocation.  RobsonŸA** proved that this memory allocator will never breakdown due to Ÿ;** fragmentation as long as the following constraint holds:¢**Ÿ'**      N >=  M*(1 + log2(n)/2) - n + 1¢**ŸE** The sqlite3_status() logic tracks the maximum values of n and M soŸ@** that an application can, at any time, verify this constraint.¢*/º/* #include "sqliteInt.h" */†¢/*Ÿ:** This version of the memory allocator is used only when Ÿ$** SQLITE_ENABLE_MEMSYS5 is defined.¢*/º#ifdef SQLITE_ENABLE_MEMSYS5†¢/*ŸB** A minimum allocation is an instance of the following structure.Ÿ@** Larger allocations are an array of these structures where theŸ%** size of the array is a power of 2.¢**Ÿ@** The size of this object must be a power of two.  That fact isΩ** verified in memsys5Init().¢*/Ÿ!typedef struct Mem5Link Mem5Link;±struct Mem5Link {Ÿ0  int next;       /* Index of next free chunk */Ÿ4  int prev;       /* Index of previous free chunk */¢};†¢/*ŸE** Maximum size of any allocation is ((1<<LOGMAX)*mem5.szAtom). SinceŸA** mem5.szAtom is always at least 8 and 32-bit integers are used,Ÿ3** it is not actually possible to reach this limit.¢*/±#define LOGMAX 30†¢/*Ÿ(** Masks used for mem5.aCtrl[] elements.¢*/Ÿ;#define CTRL_LOGSIZE  0x1f    /* Log2 Size of this block */Ÿ;#define CTRL_FREE     0x20    /* True if not checked out */†¢/*Ÿ@** All of the static variables used by this module are collectedŸ=** into a single structure named "mem5".  This is to keep theŸ?** static variables organized and to reduce namespace pollutionŸ?** when this module is combined with other in the amalgamation.¢*/Ÿ%static SQLITE_WSD struct Mem5Global {§  /*Ÿ$  ** Memory available for allocation§  */Ÿ>  int szAtom;      /* Smallest possible allocation in bytes */Ÿ?  int nBlock;      /* Number of szAtom sized blocks in zPool */Ÿ9  u8 *zPool;       /* Memory available to be allocated */¢  §  /*Ÿ@  ** Mutex to control access to the memory allocation subsystem.§  */∑  sqlite3_mutex *mutex;†Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)§  /*ª  ** Performance statistics§  */Ÿ;  u64 nAlloc;         /* Total number of calls to malloc */ŸN  u64 totalAlloc;     /* Total of all malloc calls - includes internal frag */Ÿ8  u64 totalExcess;    /* Total internal fragmentation */ŸN  u32 currentOut;     /* Current checkout, including internal fragmentation */Ÿ@  u32 currentCount;   /* Current number of distinct checkouts */Ÿ<  u32 maxOut;         /* Maximum instantaneous currentOut */Ÿ>  u32 maxCount;       /* Maximum instantaneous currentCount */ŸK  u32 maxRequest;     /* Largest allocation (exclusive of internal frag) */¶#endif¢  §  /*ŸE  ** Lists of free blocks.  aiFreelist[0] is a list of free blocks ofŸD  ** size mem5.szAtom.  aiFreelist[1] holds blocks of size szAtom*2.ŸE  ** aiFreelist[2] holds free blocks of size szAtom*4.  And so forth.§  */ª  int aiFreelist[LOGMAX+1];†§  /*ŸA  ** Space for tracking which blocks are checked out and the sizeŸ(  ** of each block.  One byte per block.§  */¨  u8 *aCtrl;†ß} mem5;†¢/*ŸB** Access the static variable through a macro for SQLITE_OMIT_WSD.¢*/Ÿ,#define mem5 GLOBAL(struct Mem5Global, mem5)†¢/*Ÿ>** Assuming mem5.zPool is divided up into an array of Mem5LinkŸ8** structures, return a pointer to the idx-th such link.¢*/ŸD#define MEM5LINK(idx) ((Mem5Link *)(&mem5.zPool[(idx)*mem5.szAtom]))†¢/*Ÿ>** Unlink the chunk at mem5.aPool[i] from list it is currentlyŸ8** on.  It should be found on mem5.aiFreelist[iLogsize].¢*/Ÿ/static void memsys5Unlink(int i, int iLogsize){±  int next, prev;Ÿ"  assert( i>=0 && i<mem5.nBlock );Ÿ,  assert( iLogsize>=0 && iLogsize<=LOGMAX );Ÿ5  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );†ª  next = MEM5LINK(i)->next;ª  prev = MEM5LINK(i)->prev;Ø  if( prev<0 ){Ÿ%    mem5.aiFreelist[iLogsize] = next;®  }else{Ÿ     MEM5LINK(prev)->next = next;£  }∞  if( next>=0 ){Ÿ     MEM5LINK(next)->prev = prev;£  }°}†¢/*Ÿ=** Link the chunk at mem5.aPool[i] so that is on the iLogsize≠** free list.¢*/Ÿ-static void memsys5Link(int i, int iLogsize){®  int x;Ÿ+  assert( sqlite3_mutex_held(mem5.mutex) );Ÿ"  assert( i>=0 && i<mem5.nBlock );Ÿ,  assert( iLogsize>=0 && iLogsize<=LOGMAX );Ÿ5  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );†Ÿ4  x = MEM5LINK(i)->next = mem5.aiFreelist[iLogsize];π  MEM5LINK(i)->prev = -1;≠  if( x>=0 ){º    assert( x<mem5.nBlock );∫    MEM5LINK(x)->prev = i;£  }Ÿ   mem5.aiFreelist[iLogsize] = i;°}†¢/*ŸG** Obtain or release the mutex needed to access global data structures.¢*/østatic void memsys5Enter(void){Ÿ"  sqlite3_mutex_enter(mem5.mutex);°}østatic void memsys5Leave(void){Ÿ"  sqlite3_mutex_leave(mem5.mutex);°}†¢/*Ÿ:** Return the size of an outstanding allocation, in bytes.Ÿ=** This only works for chunks that are currently checked out.¢*/Ÿ static int memsys5Size(void *p){Ø  int iSize, i;±  assert( p!=0 );Ÿ.  i = (int)(((u8 *)p-mem5.zPool)/mem5.szAtom);Ÿ"  assert( i>=0 && i<mem5.nBlock );Ÿ<  iSize = mem5.szAtom * (1 << (mem5.aCtrl[i]&CTRL_LOGSIZE));Ø  return iSize;°}†¢/*Ÿ7** Return a block of memory of at least nBytes in size.Ÿ4** Return NULL if unable.  Return NULL if nBytes==0.¢**Ÿ0** The caller guarantees that nByte is positive.¢**Ÿ9** The caller has obtained a mutex prior to invoking thisŸ8** routine so there is never any chance that two or moreŸ3** threads can be in this routine at the same time.¢*/Ÿ,static void *memsys5MallocUnsafe(int nByte){Ÿ5  int i;           /* Index of a mem5.aPool[] slot */Ÿ5  int iBin;        /* Index into mem5.aiFreelist[] */ŸD  int iFullSz;     /* Size of allocation rounded up to power of 2 */Ÿ1  int iLogsize;    /* Log2 of iFullSz/POW2_MIN */†Ÿ   /* nByte must be a positive */¥  assert( nByte>0 );†Ÿ(  /* No more than 1GiB per allocation */Ÿ$  if( nByte > 0x40000000 ) return 0;†Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)ŸD  /* Keep track of the maximum allocation request.  Even unfulfilledº  ** requests are counted */Ÿ#  if( (u32)nByte>mem5.maxRequest ){º    mem5.maxRequest = nByte;£  }¶#endif††Ÿ5  /* Round nByte up to the next valid power of two */ŸM  for(iFullSz=mem5.szAtom,iLogsize=0; iFullSz<nByte; iFullSz*=2,iLogsize++){}†ŸC  /* Make sure mem5.aiFreelist[iLogsize] contains at least one freeŸC  ** block.  If not, then split a block of the next larger power ofŸ>  ** two in order to create a new free block of size iLogsize.§  */ŸG  for(iBin=iLogsize; iBin<=LOGMAX && mem5.aiFreelist[iBin]<0; iBin++){}¥  if( iBin>LOGMAX ){Ÿ,    testcase( sqlite3GlobalConfig.xLog!=0 );ŸD    sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes", nByte);≠    return 0;£  }º  i = mem5.aiFreelist[iBin];π  memsys5Unlink(i, iBin);π  while( iBin>iLogsize ){∞    int newSize;†´    iBin--;∏    newSize = 1 << iBin;Ÿ-    mem5.aCtrl[i+newSize] = CTRL_FREE | iBin;Ÿ!    memsys5Link(i+newSize, iBin);£  }ª  mem5.aCtrl[i] = iLogsize;†Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ÿ0  /* Update allocator performance statistics. */∞  mem5.nAlloc++;Ω  mem5.totalAlloc += iFullSz;Ÿ&  mem5.totalExcess += iFullSz - nByte;∂  mem5.currentCount++;Ω  mem5.currentOut += iFullSz;ŸJ  if( mem5.maxCount<mem5.currentCount ) mem5.maxCount = mem5.currentCount;ŸB  if( mem5.maxOut<mem5.currentOut ) mem5.maxOut = mem5.currentOut;¶#endif†≥#ifdef SQLITE_DEBUGŸJ  /* Make sure the allocated memory does not assume that it is set to zeroŸ5  ** or retains a value from a previous allocation */Ÿ4  memset(&mem5.zPool[i*mem5.szAtom], 0xAA, iFullSz);¶#endif†Ÿ1  /* Return a pointer to the allocated memory. */Ÿ+  return (void*)&mem5.zPool[i*mem5.szAtom];°}†¢/*Ÿ)** Free an outstanding memory allocation.¢*/Ÿ*static void memsys5FreeUnsafe(void *pOld){µ  u32 size, iLogsize;≠  int iBlock;†Ÿ@  /* Set iBlock to the index of the block pointed to by pOld in ŸC  ** the array of mem5.szAtom byte blocks pointed to by mem5.zPool.§  */Ÿ6  iBlock = (int)(((u8 *)pOld-mem5.zPool)/mem5.szAtom);†ŸF  /* Check that the pointer pOld points to a valid, non-free block. */Ÿ,  assert( iBlock>=0 && iBlock<mem5.nBlock );Ÿ3  assert( ((u8 *)pOld-mem5.zPool)%mem5.szAtom==0 );Ÿ0  assert( (mem5.aCtrl[iBlock] & CTRL_FREE)==0 );†Ÿ/  iLogsize = mem5.aCtrl[iBlock] & CTRL_LOGSIZE;µ  size = 1<<iLogsize;Ÿ+  assert( iBlock+size-1<(u32)mem5.nBlock );†Ÿ"  mem5.aCtrl[iBlock] |= CTRL_FREE;Ÿ)  mem5.aCtrl[iBlock+size-1] |= CTRL_FREE;†Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ÿ   assert( mem5.currentCount>0 );Ÿ0  assert( mem5.currentOut>=(size*mem5.szAtom) );∂  mem5.currentCount--;Ÿ&  mem5.currentOut -= size*mem5.szAtom;Ÿ6  assert( mem5.currentOut>0 || mem5.currentCount==0 );Ÿ6  assert( mem5.currentCount>0 || mem5.currentOut==0 );¶#endif†Ÿ,  mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;Ÿ#  while( ALWAYS(iLogsize<LOGMAX) ){Ø    int iBuddy;Ÿ!    if( (iBlock>>iLogsize) & 1 ){Ω      iBuddy = iBlock - size;∫      assert( iBuddy>=0 );™    }else{Ω      iBuddy = iBlock + size;Ÿ&      if( iBuddy>=mem5.nBlock ) break;•    }Ÿ;    if( mem5.aCtrl[iBuddy]!=(CTRL_FREE | iLogsize) ) break;Ÿ$    memsys5Unlink(iBuddy, iLogsize);Ø    iLogsize++;∏    if( iBuddy<iBlock ){Ÿ0      mem5.aCtrl[iBuddy] = CTRL_FREE | iLogsize;Ω      mem5.aCtrl[iBlock] = 0;∂      iBlock = iBuddy;™    }else{Ÿ0      mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;Ω      mem5.aCtrl[iBuddy] = 0;•    }Æ    size *= 2;£  }†≥#ifdef SQLITE_DEBUGŸJ  /* Overwrite freed memory with the 0x55 bit pattern to verify that it isŸ"  ** not used after being freed */Ÿ6  memset(&mem5.zPool[iBlock*mem5.szAtom], 0x55, size);¶#endif†Ÿ   memsys5Link(iBlock, iLogsize);°}†¢/*Ω** Allocate nBytes of memory.¢*/Ÿ'static void *memsys5Malloc(int nBytes){∑  sqlite3_int64 *p = 0;±  if( nBytes>0 ){≥    memsys5Enter();Ÿ$    p = memsys5MallocUnsafe(nBytes);≥    memsys5Leave();£  }≥  return (void*)p; °}†¢/*Ø** Free memory.¢**Ÿ>** The outer layer memory allocator prevents this routine fromø** being called with pPrior==0.¢*/Ÿ&static void memsys5Free(void *pPrior){∂  assert( pPrior!=0 );±  memsys5Enter();º  memsys5FreeUnsafe(pPrior);≥  memsys5Leave();  °}†¢/*Ÿ4** Change the size of an existing memory allocation.¢**Ÿ>** The outer layer memory allocator prevents this routine fromŸ!** being called with pPrior==0.  ¢**Ÿ9** nBytes is always a value obtained from a prior call toŸ?** memsys5Round().  Hence nBytes is always a non-negative powerŸ?** of two.  If nBytes==0 that means that an oversize allocationŸ@** (an allocation larger than 0x40000000) was requested and thisŸ2** routine should return 0 without freeing pPrior.¢*/Ÿ6static void *memsys5Realloc(void *pPrior, int nBytes){´  int nOld;™  void *p;∂  assert( pPrior!=0 );Ÿ<  assert( (nBytes&(nBytes-1))==0 );  /* EV: R-46199-30249 */∂  assert( nBytes>=0 );≤  if( nBytes==0 ){≠    return 0;£  }Ω  nOld = memsys5Size(pPrior);µ  if( nBytes<=nOld ){≤    return pPrior;£  }º  p = memsys5Malloc(nBytes);™  if( p ){º    memcpy(p, pPrior, nOld);∏    memsys5Free(pPrior);£  }´  return p;°}†¢/*ŸA** Round up a request size to the next valid allocation size.  IfŸG** the allocation is too large to be handled by this allocation system,¨** return 0.¢**ŸD** All allocations must be a power of two and must be expressed by aŸE** 32-bit signed integer.  Hence the largest allocation is 0x40000000∑** or 1073741824 bytes.¢*/Ÿ!static int memsys5Roundup(int n){Æ  int iFullSz;Ÿ   if( n > 0x40000000 ) return 0;Ÿ4  for(iFullSz=mem5.szAtom; iFullSz<n; iFullSz *= 2);±  return iFullSz;°}†¢/*Ÿ8** Return the ceiling of the logarithm base 2 of iValue.¢**Ÿ!** Examples:   memsys5Log(1) -> 0Ÿ!**             memsys5Log(2) -> 1Ÿ!**             memsys5Log(4) -> 2Ÿ!**             memsys5Log(5) -> 3Ÿ!**             memsys5Log(8) -> 3Ÿ!**             memsys5Log(9) -> 4¢*/Ÿ"static int memsys5Log(int iValue){´  int iLog;ŸK  for(iLog=0; (iLog<(int)((sizeof(int)*8)-1)) && (1<<iLog)<iValue; iLog++);Æ  return iLog;°}†¢/*Ÿ#** Initialize the memory allocator.¢**ŸF** This routine is not threadsafe.  The caller must be holding a mutexŸ>** to prevent multiple threads from entering at the same time.¢*/Ÿ&static int memsys5Init(void *NotUsed){Ÿ'  int ii;            /* Loop counter */ŸP  int nByte;         /* Number of bytes of memory available to this allocator */Ÿ:  u8 *zByte;         /* Memory usable by this allocator */ŸI  int nMinLog;       /* Log base 2 of minimum allocation size in bytes */Ÿ6  int iOffset;       /* An offset into mem5.aCtrl[] */†º  UNUSED_PARAMETER(NotUsed);†Ÿ;  /* For the purposes of this routine, disable the mutex */±  mem5.mutex = 0;†ŸG  /* The size of a Mem5Link object must be a power of two.  Verify that≤  ** this is case.§  */Ÿ7  assert( (sizeof(Mem5Link)&(sizeof(Mem5Link)-1))==0 );†Ÿ$  nByte = sqlite3GlobalConfig.nHeap;Ÿ)  zByte = (u8*)sqlite3GlobalConfig.pHeap;ŸF  assert( zByte!=0 );  /* sqlite3_config() does not allow otherwise */†ŸP  /* boundaries on sqlite3GlobalConfig.mnReq are enforced in sqlite3_config() */Ÿ2  nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq);Ω  mem5.szAtom = (1<<nMinLog);Ÿ-  while( (int)sizeof(Mem5Link)>mem5.szAtom ){Ÿ#    mem5.szAtom = mem5.szAtom << 1;£  }†Ÿ3  mem5.nBlock = (nByte / (mem5.szAtom+sizeof(u8)));µ  mem5.zPool = zByte;Ÿ:  mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.szAtom];†æ  for(ii=0; ii<=LOGMAX; ii++){Ω    mem5.aiFreelist[ii] = -1;£  }†Æ  iOffset = 0;æ  for(ii=LOGMAX; ii>=0; ii--){π    int nAlloc = (1<<ii);Ÿ(    if( (iOffset+nAlloc)<=mem5.nBlock ){Ÿ+      mem5.aCtrl[iOffset] = ii | CTRL_FREE;ø      memsys5Link(iOffset, ii);∏      iOffset += nAlloc;•    }Ÿ)    assert((iOffset+nAlloc)>mem5.nBlock);£  }†ŸA  /* If a mutex is required for normal operation, allocate one */Ÿ(  if( sqlite3GlobalConfig.bMemstat==0 ){Ÿ<    mem5.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);£  }†≥  return SQLITE_OK;°}†¢/*º** Deinitialize this module.¢*/Ÿ+static void memsys5Shutdown(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);±  mem5.mutex = 0;©  return;°}†≤#ifdef SQLITE_TEST¢/*ŸA** Open the file indicated and write a log of all unfreed memory Ω** allocations into that log.¢*/Ÿ>SQLITE_PRIVATE void sqlite3Memsys5Dump(const char *zFilename){¨  FILE *out;Æ  int i, j, n;Æ  int nMinLog;†Ÿ(  if( zFilename==0 || zFilename[0]==0 ){±    out = stdout;®  }else{Ÿ     out = fopen(zFilename, "w");±    if( out==0 ){ŸM      fprintf(stderr, "** Unable to output memory debug output log: %s **\n",Ÿ!                      zFilename);≠      return;•    }£  }±  memsys5Enter();Ÿ$  nMinLog = memsys5Log(mem5.szAtom);Ÿ+  for(i=0; i<=LOGMAX && i+nMinLog<32; i++){ŸF    for(n=0, j=mem5.aiFreelist[i]; j>=0; j = MEM5LINK(j)->next, n++){}ŸI    fprintf(out, "freelist items of size %d: %d\n", mem5.szAtom << i, n);£  }Ÿ:  fprintf(out, "mem5.nAlloc       = %llu\n", mem5.nAlloc);Ÿ>  fprintf(out, "mem5.totalAlloc   = %llu\n", mem5.totalAlloc);Ÿ?  fprintf(out, "mem5.totalExcess  = %llu\n", mem5.totalExcess);Ÿ<  fprintf(out, "mem5.currentOut   = %u\n", mem5.currentOut);Ÿ>  fprintf(out, "mem5.currentCount = %u\n", mem5.currentCount);Ÿ8  fprintf(out, "mem5.maxOut       = %u\n", mem5.maxOut);Ÿ:  fprintf(out, "mem5.maxCount     = %u\n", mem5.maxCount);Ÿ<  fprintf(out, "mem5.maxRequest   = %u\n", mem5.maxRequest);±  memsys5Leave();¥  if( out==stdout ){≥    fflush(stdout);®  }else{∞    fclose(out);£  }°}¶#endif†¢/*Ÿ?** This routine is the only routine in this file with external Ÿ@** linkage. It returns a pointer to a static sqlite3_mem_methodsŸ-** struct populated with the memsys5 methods.¢*/ŸESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){Ÿ5  static const sqlite3_mem_methods memsys5Methods = {≥     memsys5Malloc,±     memsys5Free,¥     memsys5Realloc,±     memsys5Size,¥     memsys5Roundup,±     memsys5Init,µ     memsys5Shutdown,¶     0§  };π  return &memsys5Methods;°}†Ÿ"#endif /* SQLITE_ENABLE_MEMSYS5 */†ŸO/************** End of mem5.c ************************************************/ŸO/************** Begin file mutex.c *******************************************/¢/*±** 2007 August 14¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ=** This file contains the C functions that implement mutexes.¢**ŸK** This file contains code that is common across all mutex implementations.¢*/º/* #include "sqliteInt.h" */†Ÿ8#if defined(SQLITE_DEBUG) && !defined(SQLITE_MUTEX_OMIT)¢/*ŸI** For debugging purposes, record when the mutex subsystem is initializedŸF** and uninitialized so that we can assert() if there is an attempt toŸ6** allocate a mutex while the system is uninitialized.¢*/Ÿ&static SQLITE_WSD int mutexIsInit = 0;Ÿ8#endif /* SQLITE_DEBUG && !defined(SQLITE_MUTEX_OMIT) */††π#ifndef SQLITE_MUTEX_OMIT†Ÿ)#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS¢/*ŸG** This block (enclosed by SQLITE_ENABLE_MULTITHREADED_CHECKS) containsŸB** the implementation of a wrapper around the system default mutexŸ+** implementation (sqlite3DefaultMutex()). ¢**ŸC** Most calls are passed directly through to the underlying defaultŸD** mutex implementation. Except, if a mutex is configured by callingŸC** sqlite3MutexWarnOnContention() on it, then if contention is everŸK** encountered within xMutexEnter() a warning is emitted via sqlite3_log().¢**ŸG** This type of mutex is used as the database handle mutex when testingŸ8** apps that usually use SQLITE_CONFIG_MULTITHREAD mode.¢*/†£/* ŸD** Type for all mutexes used when SQLITE_ENABLE_MULTITHREADED_CHECKSŸG** is defined. Variable CheckMutex.mutex is a pointer to the real mutexŸN** allocated by the system mutex implementation. Variable iType is usually setŸM** to the type of mutex requested - SQLITE_MUTEX_RECURSIVE, SQLITE_MUTEX_FASTŸK** or one of the static mutex identifiers. Or, if this is a recursive mutexŸG** that has been configured using sqlite3MutexWarnOnContention(), it isŸ(** set to SQLITE_MUTEX_WARNONCONTENTION.¢*/Ÿ%typedef struct CheckMutex CheckMutex;≥struct CheckMutex {¨  int iType;∑  sqlite3_mutex *mutex;¢};†Ÿ+#define SQLITE_MUTEX_WARNONCONTENTION  (-1)†£/* Ÿ>** Pointer to real mutex methods object used by the CheckMutexŸ,** implementation. Set by checkMutexInit(). ¢*/ŸCstatic SQLITE_WSD const sqlite3_mutex_methods *pGlobalMutexMethods;†≥#ifdef SQLITE_DEBUGŸ,static int checkMutexHeld(sqlite3_mutex *p){ŸB  return pGlobalMutexMethods->xMutexHeld(((CheckMutex*)p)->mutex);°}Ÿ/static int checkMutexNotheld(sqlite3_mutex *p){ŸE  return pGlobalMutexMethods->xMutexNotheld(((CheckMutex*)p)->mutex);°}¶#endif†¢/*Ÿ3** Initialize and deinitialize the mutex subsystem.¢*/Ÿ!static int checkMutexInit(void){ Ÿ.  pGlobalMutexMethods = sqlite3DefaultMutex();¥  return SQLITE_OK; °}Ÿ static int checkMutexEnd(void){ ∫  pGlobalMutexMethods = 0;¥  return SQLITE_OK; °}†¢/*¥** Allocate a mutex.¢*/Ÿ1static sqlite3_mutex *checkMutexAlloc(int iType){Ÿ'  static CheckMutex staticMutexes[] = {Ÿ#    {2, 0}, {3, 0}, {4, 0}, {5, 0},Ÿ#    {6, 0}, {7, 0}, {8, 0}, {9, 0},Ÿ&    {10, 0}, {11, 0}, {12, 0}, {13, 0}§  };¥  CheckMutex *p = 0;†Ÿ>  assert( SQLITE_MUTEX_RECURSIVE==1 && SQLITE_MUTEX_FAST==0 );∞  if( iType<2 ){Ÿ.    p = sqlite3MallocZero(sizeof(CheckMutex));∏    if( p==0 ) return 0;µ    p->iType = iType;®  }else{æ#ifdef SQLITE_ENABLE_API_ARMORŸ,    if( iType-2>=ArraySize(staticMutexes) ){ø      (void)SQLITE_MISUSE_BKPT;Ø      return 0;•    }¶#endifŸ     p = &staticMutexes[iType-2];£  }†¥  if( p->mutex==0 ){Ÿ7    p->mutex = pGlobalMutexMethods->xMutexAlloc(iType);∂    if( p->mutex==0 ){¥      if( iType<2 ){∏        sqlite3_free(p);ß      }¨      p = 0;•    }£  }†ª  return (sqlite3_mutex*)p;°}†¢/*∞** Free a mutex.¢*/Ÿ-static void checkMutexFree(sqlite3_mutex *p){Ÿ%  assert( SQLITE_MUTEX_RECURSIVE<2 );Ÿ   assert( SQLITE_MUTEX_FAST<2 );Ÿ,  assert( SQLITE_MUTEX_WARNONCONTENTION<2 );†ª#if SQLITE_ENABLE_API_ARMORŸ!  if( ((CheckMutex*)p)->iType<2 )¶#endif£  {Ÿ(    CheckMutex *pCheck = (CheckMutex*)p;Ÿ3    pGlobalMutexMethods->xMutexFree(pCheck->mutex);π    sqlite3_free(pCheck);£  }æ#ifdef SQLITE_ENABLE_API_ARMORß  else{Ω    (void)SQLITE_MISUSE_BKPT;£  }¶#endif°}†¢/*≥** Enter the mutex.¢*/Ÿ.static void checkMutexEnter(sqlite3_mutex *p){Ÿ&  CheckMutex *pCheck = (CheckMutex*)p;Ÿ5  if( pCheck->iType==SQLITE_MUTEX_WARNONCONTENTION ){ŸC    if( SQLITE_OK==pGlobalMutexMethods->xMutexTry(pCheck->mutex) ){≠      return;•    }ø    sqlite3_log(SQLITE_MISUSE, Ÿ>        "illegal multi-threaded access to database connection"¶    );£  }Ÿ2  pGlobalMutexMethods->xMutexEnter(pCheck->mutex);°}†¢/*Ÿ"** Enter the mutex (do not block).¢*/Ÿ+static int checkMutexTry(sqlite3_mutex *p){Ÿ&  CheckMutex *pCheck = (CheckMutex*)p;Ÿ7  return pGlobalMutexMethods->xMutexTry(pCheck->mutex);°}†¢/*≥** Leave the mutex.¢*/Ÿ.static void checkMutexLeave(sqlite3_mutex *p){Ÿ&  CheckMutex *pCheck = (CheckMutex*)p;Ÿ2  pGlobalMutexMethods->xMutexLeave(pCheck->mutex);°}†Ÿ;sqlite3_mutex_methods const *multiThreadedCheckMutex(void){Ÿ/  static const sqlite3_mutex_methods sMutex = {≥    checkMutexInit,≤    checkMutexEnd,¥    checkMutexAlloc,≥    checkMutexFree,¥    checkMutexEnter,≤    checkMutexTry,¥    checkMutexLeave,≥#ifdef SQLITE_DEBUG≥    checkMutexHeld,µ    checkMutexNotheld•#else¶    0,•    0¶#endif§  };±  return &sMutex;°}†¢/*ŸG** Mark the SQLITE_MUTEX_RECURSIVE mutex passed as the only argument asŸ.** one on which there should be no contention.¢*/ŸCSQLITE_PRIVATE void sqlite3MutexWarnOnContention(sqlite3_mutex *p){Ÿ?  if( sqlite3GlobalConfig.mutex.xMutexAlloc==checkMutexAlloc ){Ÿ(    CheckMutex *pCheck = (CheckMutex*)p;Ÿ4    assert( pCheck->iType==SQLITE_MUTEX_RECURSIVE );Ÿ2    pCheck->iType = SQLITE_MUTEX_WARNONCONTENTION;£  }°}Ÿ7#endif   /* ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS */†¢/*ø** Initialize the mutex system.¢*/Ÿ+SQLITE_PRIVATE int sqlite3MutexInit(void){ µ  int rc = SQLITE_OK;Ÿ/  if( !sqlite3GlobalConfig.mutex.xMutexAlloc ){ŸH    /* If the xMutexAlloc method has not been set, then the user did notŸD    ** install a mutex implementation via sqlite3_config() prior to ŸG    ** sqlite3_initialize() being called. This block copies pointers toŸI    ** the default implementation into the sqlite3GlobalConfig structure.¶    */Ÿ'    sqlite3_mutex_methods const *pFrom;Ÿ<    sqlite3_mutex_methods *pTo = &sqlite3GlobalConfig.mutex;†Ÿ)    if( sqlite3GlobalConfig.bCoreMutex ){Ÿ)#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKSŸ(      pFrom = multiThreadedCheckMutex();•#elseŸ$      pFrom = sqlite3DefaultMutex();¶#endif™    }else{Ÿ!      pFrom = sqlite3NoopMutex();•    }Ÿ(    pTo->xMutexInit = pFrom->xMutexInit;Ÿ&    pTo->xMutexEnd = pFrom->xMutexEnd;Ÿ(    pTo->xMutexFree = pFrom->xMutexFree;Ÿ*    pTo->xMutexEnter = pFrom->xMutexEnter;Ÿ&    pTo->xMutexTry = pFrom->xMutexTry;Ÿ*    pTo->xMutexLeave = pFrom->xMutexLeave;Ÿ(    pTo->xMutexHeld = pFrom->xMutexHeld;Ÿ.    pTo->xMutexNotheld = pFrom->xMutexNotheld;ª    sqlite3MemoryBarrier();Ÿ*    pTo->xMutexAlloc = pFrom->xMutexAlloc;£  }Ÿ1  assert( sqlite3GlobalConfig.mutex.xMutexInit );Ÿ.  rc = sqlite3GlobalConfig.mutex.xMutexInit();†≥#ifdef SQLITE_DEBUGø  GLOBAL(int, mutexIsInit) = 1;¶#endif†¨  return rc;°}†¢/*ŸD** Shutdown the mutex system. This call frees resources allocated by∂** sqlite3MutexInit().¢*/Ÿ)SQLITE_PRIVATE int sqlite3MutexEnd(void){µ  int rc = SQLITE_OK;Ÿ,  if( sqlite3GlobalConfig.mutex.xMutexEnd ){Ÿ/    rc = sqlite3GlobalConfig.mutex.xMutexEnd();£  }†≥#ifdef SQLITE_DEBUGø  GLOBAL(int, mutexIsInit) = 0;¶#endif†¨  return rc;°}†¢/*ŸF** Retrieve a pointer to a static mutex or allocate a new dynamic one.¢*/Ÿ6SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){º#ifndef SQLITE_OMIT_AUTOINITŸD  if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;ŸA  if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;¶#endifŸ2  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );Ÿ3  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);°}†Ÿ8SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){Ÿ(  if( !sqlite3GlobalConfig.bCoreMutex ){≠    return 0;£  }Ÿ%  assert( GLOBAL(int, mutexIsInit) );Ÿ2  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );Ÿ3  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);°}†¢/*∏** Free a dynamic mutex.¢*/Ÿ5SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){™  if( p ){Ÿ3    assert( sqlite3GlobalConfig.mutex.xMutexFree );Ÿ,    sqlite3GlobalConfig.mutex.xMutexFree(p);£  }°}†¢/*ŸH** Obtain the mutex p. If some other thread already has the mutex, blockº** until it can be obtained.¢*/Ÿ6SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){™  if( p ){Ÿ4    assert( sqlite3GlobalConfig.mutex.xMutexEnter );Ÿ-    sqlite3GlobalConfig.mutex.xMutexEnter(p);£  }°}†¢/*ŸM** Obtain the mutex p. If successful, return SQLITE_OK. Otherwise, if anotherŸH** thread holds the mutex and it cannot be obtained, return SQLITE_BUSY.¢*/Ÿ3SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){µ  int rc = SQLITE_OK;™  if( p ){Ÿ2    assert( sqlite3GlobalConfig.mutex.xMutexTry );Ÿ2    return sqlite3GlobalConfig.mutex.xMutexTry(p);£  }¨  return rc;°}†¢/*ŸF** The sqlite3_mutex_leave() routine exits a mutex that was previouslyŸG** entered by the same thread.  The behavior is undefined if the mutex ŸG** is not currently entered. If a NULL pointer is passed as an argumentº** this function is a no-op.¢*/Ÿ6SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){™  if( p ){Ÿ4    assert( sqlite3GlobalConfig.mutex.xMutexLeave );Ÿ-    sqlite3GlobalConfig.mutex.xMutexLeave(p);£  }°}†Æ#ifndef NDEBUG¢/*ŸC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areŸ/** intended for use inside assert() statements.¢*/Ÿ4SQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p){Ÿ9  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexHeld );Ÿ9  return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p);°}Ÿ7SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p){Ÿ<  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld );Ÿ<  return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p);°}¶#endif†Ÿ(#endif /* !defined(SQLITE_MUTEX_OMIT) */††ŸO/************** End of mutex.c ***********************************************/ŸO/************** Begin file mutex_noop.c **************************************/¢/*≤** 2008 October 07¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ=** This file contains the C functions that implement mutexes.¢**Ÿ?** This implementation in this file does not provide any mutualŸ>** exclusion and is thus suitable for use only in applicationsŸ<** that use SQLite in a single thread.  The routines definedŸ?** here are place-holders.  Applications can substitute workingŸ)** mutex routines at start-time using the¢**Ÿ.**     sqlite3_config(SQLITE_CONFIG_MUTEX,...)¢**≠** interface.¢**ŸC** If compiled with SQLITE_DEBUG, then additional logic is insertedŸB** that does error checking on mutexes to make sure they are being¥** called correctly.¢*/º/* #include "sqliteInt.h" */†π#ifndef SQLITE_MUTEX_OMIT†¥#ifndef SQLITE_DEBUG¢/*Ÿ'** Stub routines for all mutex methods.¢**Ÿ?** This routines provide no mutual exclusion or error checking.¢*/Ÿ3static int noopMutexInit(void){ return SQLITE_OK; }Ÿ2static int noopMutexEnd(void){ return SQLITE_OK; }Ÿ.static sqlite3_mutex *noopMutexAlloc(int id){ ∑  UNUSED_PARAMETER(id);º  return (sqlite3_mutex*)8; °}ŸKstatic void noopMutexFree(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }ŸLstatic void noopMutexEnter(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }Ÿ*static int noopMutexTry(sqlite3_mutex *p){∂  UNUSED_PARAMETER(p);≥  return SQLITE_OK;°}ŸLstatic void noopMutexLeave(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }†ŸCSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){Ÿ/  static const sqlite3_mutex_methods sMutex = {≤    noopMutexInit,±    noopMutexEnd,≥    noopMutexAlloc,≤    noopMutexFree,≥    noopMutexEnter,±    noopMutexTry,≥    noopMutexLeave,†¶    0,¶    0,§  };†±  return &sMutex;°}∫#endif /* !SQLITE_DEBUG */†≥#ifdef SQLITE_DEBUG¢/*ŸA** In this implementation, error checking is provided for testingŸ@** and debugging purposes.  The mutexes still do not provide any¥** mutual exclusion.¢*/†¢/*≥** The mutex object¢*/Ÿ$typedef struct sqlite3_debug_mutex {Ÿ"  int id;     /* The mutex type */Ÿ>  int cnt;    /* Number of entries without a matching leave */∂} sqlite3_debug_mutex;†¢/*ŸC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areŸ/** intended for use inside assert() statements.¢*/Ÿ-static int debugMutexHeld(sqlite3_mutex *pX){Ÿ4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;∫  return p==0 || p->cnt>0;°}Ÿ0static int debugMutexNotheld(sqlite3_mutex *pX){Ÿ4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;ª  return p==0 || p->cnt==0;°}†¢/*Ÿ3** Initialize and deinitialize the mutex subsystem.¢*/Ÿ4static int debugMutexInit(void){ return SQLITE_OK; }Ÿ3static int debugMutexEnd(void){ return SQLITE_OK; }†¢/*Ÿ4** The sqlite3_mutex_alloc() routine allocates a newŸ9** mutex and returns a pointer to it.  If it returns NULLŸ3** that means that a mutex could not be allocated. ¢*/Ÿ.static sqlite3_mutex *debugMutexAlloc(int id){ŸC  static sqlite3_debug_mutex aStatic[SQLITE_MUTEX_STATIC_VFS3 - 1];Ÿ   sqlite3_debug_mutex *pNew = 0;Ø  switch( id ){ª    case SQLITE_MUTEX_FAST:Ÿ"    case SQLITE_MUTEX_RECURSIVE: {Ÿ*      pNew = sqlite3Malloc(sizeof(*pNew));±      if( pNew ){∂        pNew->id = id;∂        pNew->cnt = 0;ß      }¨      break;•    }Æ    default: {æ#ifdef SQLITE_ENABLE_API_ARMORŸ/      if( id-2<0 || id-2>=ArraySize(aStatic) ){Ÿ!        (void)SQLITE_MISUSE_BKPT;±        return 0;ß      }¶#endifº      pNew = &aStatic[id-2];¥      pNew->id = id;¨      break;•    }£  }æ  return (sqlite3_mutex*)pNew;°}†¢/*Ÿ9** This routine deallocates a previously allocated mutex.¢*/Ÿ.static void debugMutexFree(sqlite3_mutex *pX){Ÿ4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;∂  assert( p->cnt==0 );ŸB  if( p->id==SQLITE_MUTEX_RECURSIVE || p->id==SQLITE_MUTEX_FAST ){¥    sqlite3_free(p);®  }else{æ#ifdef SQLITE_ENABLE_API_ARMORΩ    (void)SQLITE_MISUSE_BKPT;¶#endif£  }°}†¢/*ŸE** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptŸD** to enter a mutex.  If another thread is already within the mutex,ŸG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnŸD** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OKŸK** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE canŸD** be entered multiple times by the same thread.  In such cases the,ŸF** mutex must be exited an equal number of times before another threadŸH** can enter.  If the same thread tries to enter any other kind of mutexŸ-** more than once, the behavior is undefined.¢*/Ÿ/static void debugMutexEnter(sqlite3_mutex *pX){Ÿ4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;ŸC  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );´  p->cnt++;°}Ÿ,static int debugMutexTry(sqlite3_mutex *pX){Ÿ4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;ŸC  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );´  p->cnt++;≥  return SQLITE_OK;°}†¢/*Ÿ;** The sqlite3_mutex_leave() routine exits a mutex that wasŸ7** previously entered by the same thread.  The behaviorŸ8** is undefined if the mutex is not currently entered orŸ<** is not currently allocated.  SQLite will never do either.¢*/Ÿ/static void debugMutexLeave(sqlite3_mutex *pX){Ÿ4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;ø  assert( debugMutexHeld(pX) );´  p->cnt--;ŸC  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );°}†ŸCSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){Ÿ/  static const sqlite3_mutex_methods sMutex = {≥    debugMutexInit,≤    debugMutexEnd,¥    debugMutexAlloc,≥    debugMutexFree,¥    debugMutexEnter,≤    debugMutexTry,¥    debugMutexLeave,†≥    debugMutexHeld,µ    debugMutexNotheld§  };†±  return &sMutex;°}π#endif /* SQLITE_DEBUG */†¢/*ŸJ** If compiled with SQLITE_MUTEX_NOOP, then the no-op mutex implementationŸ;** is used regardless of the run-time threadsafety setting.¢*/∏#ifdef SQLITE_MUTEX_NOOPŸFSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){º  return sqlite3NoopMutex();°}Ÿ'#endif /* defined(SQLITE_MUTEX_NOOP) */Ÿ(#endif /* !defined(SQLITE_MUTEX_OMIT) */†ŸO/************** End of mutex_noop.c ******************************************/ŸO/************** Begin file mutex_unix.c **************************************/¢/*±** 2007 August 28¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸI** This file contains the C functions that implement mutexes for pthreads¢*/º/* #include "sqliteInt.h" */†¢/*ŸD** The code in this file is only used if we are compiling threadsafeº** under unix with pthreads.¢**ŸD** Note that this implementation requires a version of pthreads thatæ** supports recursive mutexes.¢*/º#ifdef SQLITE_MUTEX_PTHREADS†¥#include <pthread.h>†¢/*ŸK** The sqlite3_mutex.id, sqlite3_mutex.nRef, and sqlite3_mutex.owner fieldsŸG** are necessary under two condidtions:  (1) Debug builds and (2) usingŸK** home-grown mutexes.  Encapsulate these conditions into a single #define.¢*/ŸF#if defined(SQLITE_DEBUG) || defined(SQLITE_HOMEGROWN_RECURSIVE_MUTEX)º# define SQLITE_MUTEX_NREF 1•#elseº# define SQLITE_MUTEX_NREF 0¶#endif†¢/*ŸB** Each recursive mutex is an instance of the following structure.¢*/∂struct sqlite3_mutex {Ÿ=  pthread_mutex_t mutex;     /* Mutex controlling the lock */Ÿ9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ÿ-  int id;                    /* Mutex type */¶#endifµ#if SQLITE_MUTEX_NREFŸ6  volatile int nRef;         /* Number of entrances */ŸC  volatile pthread_t owner;  /* Thread that is within this mutex */Ÿ8  int trace;                 /* True to trace changes */¶#endif¢};µ#if SQLITE_MUTEX_NREFŸ(# define SQLITE3_MUTEX_INITIALIZER(id) \Ÿ4     {PTHREAD_MUTEX_INITIALIZER,id,0,(pthread_t)0,0}Ÿ&#elif defined(SQLITE_ENABLE_API_ARMOR)ŸH# define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER, id }•#elseŸC#define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER }¶#endif†¢/*ŸC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areŸH** intended for use only inside assert() statements.  On some platforms,ŸB** there might be race conditions that can cause these routines toŸC** deliver incorrect results.  In particular, if pthread_equal() isŸ>** not an atomic operation, then these routines might deliveryŸ?** incorrect results.  On most platforms, pthread_equal() is a ŸB** comparison of two integers and is therefore atomic.  But we areŸE** told that HPUX is not such a platform.  If so, then these routinesŸ*** will not always work correctly on HPUX.¢**ŸA** On those platforms where pthread_equal() is not atomic, SQLiteŸA** should be compiled without -DSQLITE_DEBUG and with -DNDEBUG toŸA** make sure no assert() statements are evaluated and hence theseΩ** routines are never called.¢*/Ÿ-#if !defined(NDEBUG) || defined(SQLITE_DEBUG)Ÿ.static int pthreadMutexHeld(sqlite3_mutex *p){ŸA  return (p->nRef!=0 && pthread_equal(p->owner, pthread_self()));°}Ÿ1static int pthreadMutexNotheld(sqlite3_mutex *p){ŸB  return p->nRef==0 || pthread_equal(p->owner, pthread_self())==0;°}¶#endif†¢/*ŸG** Try to provide a memory barrier operation, needed for initializationŸE** and also for the implementation of xShmBarrier in the VFS in casesŸ,** where SQLite is compiled without mutexes.¢*/Ÿ/SQLITE_PRIVATE void sqlite3MemoryBarrier(void){Ÿ"#if defined(SQLITE_MEMORY_BARRIER)∏  SQLITE_MEMORY_BARRIER;Ÿ/#elif defined(__GNUC__) && GCC_VERSION>=4001000∑  __sync_synchronize();¶#endif°}†¢/*Ÿ3** Initialize and deinitialize the mutex subsystem.¢*/Ÿ6static int pthreadMutexInit(void){ return SQLITE_OK; }Ÿ5static int pthreadMutexEnd(void){ return SQLITE_OK; }†¢/*Ÿ4** The sqlite3_mutex_alloc() routine allocates a newŸ9** mutex and returns a pointer to it.  If it returns NULLŸ:** that means that a mutex could not be allocated.  SQLiteŸ;** will unwind its stack and return an error.  The argumentŸ>** to sqlite3_mutex_alloc() is one of these integer constants:¢**ß** <ul>∫** <li>  SQLITE_MUTEX_FASTø** <li>  SQLITE_MUTEX_RECURSIVEŸ#** <li>  SQLITE_MUTEX_STATIC_MASTERŸ ** <li>  SQLITE_MUTEX_STATIC_MEMŸ!** <li>  SQLITE_MUTEX_STATIC_OPENŸ!** <li>  SQLITE_MUTEX_STATIC_PRNGŸ ** <li>  SQLITE_MUTEX_STATIC_LRUŸ!** <li>  SQLITE_MUTEX_STATIC_PMEMŸ!** <li>  SQLITE_MUTEX_STATIC_APP1Ÿ!** <li>  SQLITE_MUTEX_STATIC_APP2Ÿ!** <li>  SQLITE_MUTEX_STATIC_APP3Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS1Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS2Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS3®** </ul>¢**Ÿ@** The first two constants cause sqlite3_mutex_alloc() to createŸG** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVEŸA** is used but not necessarily so when SQLITE_MUTEX_FAST is used.Ÿ?** The mutex implementation does not need to make a distinctionŸB** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it doesŸB** not want to.  But SQLite will only request a recursive mutex inŸD** cases where it really needs one.  If a faster non-recursive mutexŸH** implementation is available on the host platform, the mutex subsystemŸ>** might return such a mutex in response to SQLITE_MUTEX_FAST.¢**ŸD** The other allowed parameters to sqlite3_mutex_alloc() each returnŸC** a pointer to a static preexisting mutex.  Six static mutexes areŸD** used by the current version of SQLite.  Future versions of SQLiteŸF** may add additional static mutexes.  Static mutexes are for internalŸC** use by SQLite only.  Applications that use SQLite mutexes shouldŸ@** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or∫** SQLITE_MUTEX_RECURSIVE.¢**ŸF** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FASTŸ@** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()Ÿ@** returns a different mutex on every call.  But for the static ŸA** mutex types, the same mutex is returned on every call that has∏** the same type number.¢*/Ÿ3static sqlite3_mutex *pthreadMutexAlloc(int iType){Ÿ*  static sqlite3_mutex staticMutexes[] = {Ÿ!    SQLITE3_MUTEX_INITIALIZER(2),Ÿ!    SQLITE3_MUTEX_INITIALIZER(3),Ÿ!    SQLITE3_MUTEX_INITIALIZER(4),Ÿ!    SQLITE3_MUTEX_INITIALIZER(5),Ÿ!    SQLITE3_MUTEX_INITIALIZER(6),Ÿ!    SQLITE3_MUTEX_INITIALIZER(7),Ÿ!    SQLITE3_MUTEX_INITIALIZER(8),Ÿ!    SQLITE3_MUTEX_INITIALIZER(9),Ÿ"    SQLITE3_MUTEX_INITIALIZER(10),Ÿ"    SQLITE3_MUTEX_INITIALIZER(11),Ÿ"    SQLITE3_MUTEX_INITIALIZER(12),Ÿ!    SQLITE3_MUTEX_INITIALIZER(13)§  };≥  sqlite3_mutex *p;≤  switch( iType ){Ÿ"    case SQLITE_MUTEX_RECURSIVE: {Ÿ*      p = sqlite3MallocZero( sizeof(*p) );Æ      if( p ){Ÿ'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEXŸB        /* If recursive mutexes are not available, we will have toŸ(        ** build our own.  See below. */Ÿ)        pthread_mutex_init(&p->mutex, 0);•#elseŸ6        /* Use a recursive mutex if it is available */Ÿ*        pthread_mutexattr_t recursiveAttr;Ÿ/        pthread_mutexattr_init(&recursiveAttr);ŸK        pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);Ÿ6        pthread_mutex_init(&p->mutex, &recursiveAttr);Ÿ2        pthread_mutexattr_destroy(&recursiveAttr);¶#endifŸ9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ÿ'        p->id = SQLITE_MUTEX_RECURSIVE;¶#endifß      }¨      break;•    }Ω    case SQLITE_MUTEX_FAST: {Ÿ*      p = sqlite3MallocZero( sizeof(*p) );Æ      if( p ){Ÿ)        pthread_mutex_init(&p->mutex, 0);Ÿ9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ÿ"        p->id = SQLITE_MUTEX_FAST;¶#endifß      }¨      break;•    }Æ    default: {æ#ifdef SQLITE_ENABLE_API_ARMORŸ;      if( iType-2<0 || iType-2>=ArraySize(staticMutexes) ){Ÿ!        (void)SQLITE_MISUSE_BKPT;±        return 0;ß      }¶#endifŸ"      p = &staticMutexes[iType-2];¨      break;•    }£  }Ÿ9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ÿ!  assert( p==0 || p->id==iType );¶#endif´  return p;°}††¢/*Ÿ(** This routine deallocates a previouslyŸ:** allocated mutex.  SQLite is careful to deallocate everyª** mutex that it allocates.¢*/Ÿ/static void pthreadMutexFree(sqlite3_mutex *p){∑  assert( p->nRef==0 );ª#if SQLITE_ENABLE_API_ARMORŸA  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE )¶#endif£  {Ÿ%    pthread_mutex_destroy(&p->mutex);¥    sqlite3_free(p);£  }æ#ifdef SQLITE_ENABLE_API_ARMORß  else{Ω    (void)SQLITE_MISUSE_BKPT;£  }¶#endif°}†¢/*ŸE** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptŸD** to enter a mutex.  If another thread is already within the mutex,ŸG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnŸD** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OKŸK** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE canŸD** be entered multiple times by the same thread.  In such cases the,ŸF** mutex must be exited an equal number of times before another threadŸH** can enter.  If the same thread tries to enter any other kind of mutexŸ-** more than once, the behavior is undefined.¢*/Ÿ0static void pthreadMutexEnter(sqlite3_mutex *p){ŸD  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );†Ÿ'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEXŸA  /* If recursive mutexes are not available, then we have to growŸ?  ** our own.  This implementation assumes that pthread_equal()Ÿ>  ** is atomic - that it cannot be deceived into thinking selfŸB  ** and p->owner are equal if p->owner changes between two valuesŸE  ** that are not equal to self while the comparison is taking place.Ÿ>  ** This implementation also assumes a coherent cache - that ŸB  ** separate processes cannot read different values from the sameŸA  ** address at the same time.  If either of these two conditionsŸF  ** are not met, then the mutexes will fail and problems will result.§  */£  {Ÿ$    pthread_t self = pthread_self();Ÿ5    if( p->nRef>0 && pthread_equal(p->owner, self) ){∞      p->nRef++;™    }else{Ÿ$      pthread_mutex_lock(&p->mutex);ª      assert( p->nRef==0 );∂      p->owner = self;≤      p->nRef = 1;•    }£  }•#elseŸ>  /* Use the built-in recursive mutexes if they are available.§  */Ÿ   pthread_mutex_lock(&p->mutex);µ#if SQLITE_MUTEX_NREFŸ%  assert( p->nRef>0 || p->owner==0 );º  p->owner = pthread_self();¨  p->nRef++;¶#endif¶#endif†≥#ifdef SQLITE_DEBUG±  if( p->trace ){ŸG    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);£  }¶#endif°}Ÿ-static int pthreadMutexTry(sqlite3_mutex *p){©  int rc;ŸD  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );†Ÿ'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEXŸA  /* If recursive mutexes are not available, then we have to growŸ?  ** our own.  This implementation assumes that pthread_equal()Ÿ>  ** is atomic - that it cannot be deceived into thinking selfŸB  ** and p->owner are equal if p->owner changes between two valuesŸE  ** that are not equal to self while the comparison is taking place.Ÿ>  ** This implementation also assumes a coherent cache - that ŸB  ** separate processes cannot read different values from the sameŸA  ** address at the same time.  If either of these two conditionsŸF  ** are not met, then the mutexes will fail and problems will result.§  */£  {Ÿ$    pthread_t self = pthread_self();Ÿ5    if( p->nRef>0 && pthread_equal(p->owner, self) ){∞      p->nRef++;µ      rc = SQLITE_OK;Ÿ4    }else if( pthread_mutex_trylock(&p->mutex)==0 ){ª      assert( p->nRef==0 );∂      p->owner = self;≤      p->nRef = 1;µ      rc = SQLITE_OK;™    }else{∑      rc = SQLITE_BUSY;•    }£  }•#elseŸ>  /* Use the built-in recursive mutexes if they are available.§  */Ÿ,  if( pthread_mutex_trylock(&p->mutex)==0 ){µ#if SQLITE_MUTEX_NREFæ    p->owner = pthread_self();Æ    p->nRef++;¶#endif≥    rc = SQLITE_OK;®  }else{µ    rc = SQLITE_BUSY;£  }¶#endif†≥#ifdef SQLITE_DEBUGŸ"  if( rc==SQLITE_OK && p->trace ){ŸG    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);£  }¶#endif¨  return rc;°}†¢/*Ÿ;** The sqlite3_mutex_leave() routine exits a mutex that wasŸ7** previously entered by the same thread.  The behaviorŸ8** is undefined if the mutex is not currently entered orŸ<** is not currently allocated.  SQLite will never do either.¢*/Ÿ0static void pthreadMutexLeave(sqlite3_mutex *p){Ÿ   assert( pthreadMutexHeld(p) );µ#if SQLITE_MUTEX_NREF¨  p->nRef--;Ÿ   if( p->nRef==0 ) p->owner = 0;¶#endifŸ8  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );†Ÿ'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX≥  if( p->nRef==0 ){Ÿ$    pthread_mutex_unlock(&p->mutex);£  }•#elseŸ"  pthread_mutex_unlock(&p->mutex);¶#endif†≥#ifdef SQLITE_DEBUG±  if( p->trace ){ŸG    printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);£  }¶#endif°}†ŸFSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){Ÿ/  static const sqlite3_mutex_methods sMutex = {µ    pthreadMutexInit,¥    pthreadMutexEnd,∂    pthreadMutexAlloc,µ    pthreadMutexFree,∂    pthreadMutexEnter,¥    pthreadMutexTry,∂    pthreadMutexLeave,≥#ifdef SQLITE_DEBUGµ    pthreadMutexHeld,∑    pthreadMutexNotheld•#else¶    0,•    0¶#endif§  };†±  return &sMutex;°}†Ÿ"#endif /* SQLITE_MUTEX_PTHREADS */†ŸO/************** End of mutex_unix.c ******************************************/ŸO/************** Begin file mutex_w32.c ***************************************/¢/*±** 2007 August 14¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸG** This file contains the C functions that implement mutexes for Win32.¢*/º/* #include "sqliteInt.h" */†±#if SQLITE_OS_WIN¢/*Ÿ2** Include code that is common to all os_*.c files¢*/ŸO/************** Include os_common.h in the middle of mutex_w32.c *************/ŸO/************** Begin file os_common.h ***************************************/¢/*Æ** 2004 May 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸG** This file contains macros and a little bit of code that is common toŸJ** all of the platform-specific files (os_*.c) and is #included into those©** files.¢**ŸG** This file should be #included by the os_*.c files only.  It is not aø** general purpose header file.¢*/µ#ifndef _OS_COMMON_H_µ#define _OS_COMMON_H_†¢/*ŸH** At least two bugs have slipped in because we changed the MEMORY_DEBUGŸG** macro to SQLITE_DEBUG and some older makefiles have not yet made theŸI** switch.  The following code should catch this problem at compile-time.¢*/≥#ifdef MEMORY_DEBUGŸH# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."¶#endif†¢/*ŸD** Macros for performance tracing.  Normally turned off.  Only works¥** on i486 hardware.¢*/ø#ifdef SQLITE_PERFORMANCE_TRACE†¢/*Ÿ;** hwtime.h contains inline assembler code for implementingŸ$** high-performance timing routines.¢*/ŸO/************** Include hwtime.h in the middle of os_common.h ****************/ŸO/************** Begin file hwtime.h ******************************************/¢/*Æ** 2008 May 27¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸG** This file contains inline asm code for retrieving "high-performance"ø** counters for x86 class CPUs.¢*/∑#ifndef SQLITE_HWTIME_H∑#define SQLITE_HWTIME_H†¢/*ŸK** The following routine only works on pentium-class (or newer) processors.ŸD** It uses the RDTSC opcode to read the cycle count value out of theŸC** processor and returns that value.  This can be used for high-res≠** profiling.¢*/Ÿ1#if (defined(__GNUC__) || defined(_MSC_VER)) && \Ÿ>      (defined(i386) || defined(__i386__) || defined(_M_IX86))†∑  #if defined(__GNUC__)†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){π     unsigned int lo, hi;Ÿ;     __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));Ÿ)     return (sqlite_uint64)hi << 32 | lo;£  }†π  #elif defined(_MSC_VER)†ŸG  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){¨     __asm {≠        rdtscŸ+        ret       ; return value at EDX:EAX¶     }£  }†®  #endif†Ÿ0#elif (defined(__GNUC__) && defined(__x86_64__))†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){∏      unsigned long val;Ÿ2      __asm__ __volatile__ ("rdtsc" : "=A" (val));±      return val;£  }° Ÿ-#elif (defined(__GNUC__) && defined(__ppc__))†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){Ÿ       unsigned long long retval;π      unsigned long junk;Ÿ       __asm__ __volatile__ ("\n\ø          1:      mftbu   %1\n\Ÿ                   mftb    %L0\n\ø                  mftbu   %0\n\Ÿ"                  cmpw    %0,%1\n\Ω                  bne     1b"Ÿ0                  : "=r" (retval), "=r" (junk));¥      return retval;£  }†•#else†ŸB  #error Need implementation of sqlite3Hwtime() for your platform.†§  /*ŸG  ** To compile without implementing sqlite3Hwtime() for your platform,Ÿ:  ** you can remove the above #error and use the followingŸ:  ** stub function.  You will lose timing support for manyŸ=  ** of the debugging and testing utilities, but it should atª  ** least compile and run.§  */ŸPSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }†¶#endif†Ÿ&#endif /* !defined(SQLITE_HWTIME_H) */†ŸO/************** End of hwtime.h **********************************************/ŸO/************** Continuing where we left off in os_common.h ******************/†Ωstatic sqlite_uint64 g_start;østatic sqlite_uint64 g_elapsed;Ÿ1#define TIMER_START       g_start=sqlite3Hwtime()Ÿ;#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_startŸ##define TIMER_ELAPSED     g_elapsed•#else≥#define TIMER_START±#define TIMER_ENDŸ,#define TIMER_ELAPSED     ((sqlite_uint64)0)¶#endif†¢/*ŸI** If we compile with the SQLITE_TEST macro set, then the following blockŸG** of code will give us the ability to simulate a disk I/O error.  ThisŸ.** is used for testing the I/O recovery logic.¢*/∏#if defined(SQLITE_TEST)Ÿ+SQLITE_API extern int sqlite3_io_error_hit;Ÿ/SQLITE_API extern int sqlite3_io_error_hardhit;Ÿ/SQLITE_API extern int sqlite3_io_error_pending;Ÿ/SQLITE_API extern int sqlite3_io_error_persist;Ÿ.SQLITE_API extern int sqlite3_io_error_benign;Ÿ/SQLITE_API extern int sqlite3_diskfull_pending;Ÿ'SQLITE_API extern int sqlite3_diskfull;Ÿ<#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)Ÿ #define SimulateIOError(CODE)  \Ÿ:  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \Ÿ.       || sqlite3_io_error_pending-- == 1 )  \Ÿ&              { local_ioerr(); CODE; }∫static void local_ioerr(){∑  IOTRACE(("IOERR\n"));π  sqlite3_io_error_hit++;Ÿ<  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;°}Ÿ%#define SimulateDiskfullError(CODE) \Ÿ$   if( sqlite3_diskfull_pending ){ \Ÿ+     if( sqlite3_diskfull_pending == 1 ){ \∑       local_ioerr(); \æ       sqlite3_diskfull = 1; \Ÿ"       sqlite3_io_error_hit = 1; \Æ       CODE; \≠     }else{ \Ÿ$       sqlite3_diskfull_pending--; \®     } \§   }•#elseŸ #define SimulateIOErrorBenign(X)∫#define SimulateIOError(A)Ÿ #define SimulateDiskfullError(A)Ÿ!#endif /* defined(SQLITE_TEST) */†¢/*Ÿ:** When testing, keep a count of the number of open files.¢*/∏#if defined(SQLITE_TEST)Ÿ.SQLITE_API extern int sqlite3_open_file_count;Ÿ4#define OpenCounter(X)  sqlite3_open_file_count+=(X)•#else∂#define OpenCounter(X)Ÿ!#endif /* defined(SQLITE_TEST) */†Ÿ$#endif /* !defined(_OS_COMMON_H_) */†ŸO/************** End of os_common.h *******************************************/ŸO/************** Continuing where we left off in mutex_w32.c ******************/†¢/*Ÿ/** Include the header file for the Windows VFS.¢*/ŸO/************** Include os_win.h in the middle of mutex_w32.c ****************/ŸO/************** Begin file os_win.h ******************************************/¢/*≥** 2013 November 25¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**Ÿ7** This file contains code that is specific to Windows.¢*/∑#ifndef SQLITE_OS_WIN_H∑#define SQLITE_OS_WIN_H†¢/*Ÿ/** Include the primary Windows SDK header file.¢*/¥#include "windows.h"†±#ifdef __CYGWIN__∏# include <sys/cygwin.h>Ÿ0# include <errno.h> /* amalgamator: dontcache */¶#endif†¢/*Ÿ/** Determine if we are dealing with Windows NT.¢**ŸI** We ought to be able to determine if we are compiling for Windows 9x orŸ6** Windows NT using the _WIN32_WINNT macro as follows:¢**º** #if defined(_WIN32_WINNT)Ω** # define SQLITE_OS_WINNT 1®** #elseΩ** # define SQLITE_OS_WINNT 0©** #endif¢**ŸG** However, Visual Studio 2005 does not set _WIN32_WINNT by default, asŸH** it ought to, so the above test does not work.  We'll just assume thatŸK** everything is Windows NT unless the programmer explicitly says otherwiseŸ#** by setting SQLITE_OS_WINNT to 0.¢*/Ÿ.#if SQLITE_OS_WIN && !defined(SQLITE_OS_WINNT)∫# define SQLITE_OS_WINNT 1¶#endif†¢/*ŸI** Determine if we are dealing with Windows CE - which has a much reducedß** API.¢*/∑#if defined(_WIN32_WCE)∫# define SQLITE_OS_WINCE 1•#else∫# define SQLITE_OS_WINCE 0¶#endif†¢/*ŸJ** Determine if we are dealing with WinRT, which provides only a subset of∂** the full Win32 API.¢*/Ω#if !defined(SQLITE_OS_WINRT)∫# define SQLITE_OS_WINRT 0¶#endif†¢/*ŸJ** For WinCE, some API function parameters do not appear to be declared as¨** volatile.¢*/≥#if SQLITE_OS_WINCEæ# define SQLITE_WIN32_VOLATILE•#elseŸ'# define SQLITE_WIN32_VOLATILE volatile¶#endif†¢/*ŸH** For some Windows sub-platforms, the _beginthreadex() / _endthreadex()ŸH** functions are not available (e.g. those not using MSVC, Cygwin, etc).¢*/Ÿ>#if SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \Ÿ/    SQLITE_THREADSAFE>0 && !defined(__CYGWIN__)Ÿ # define SQLITE_OS_WIN_THREADS 1•#elseŸ # define SQLITE_OS_WIN_THREADS 0¶#endif†º#endif /* SQLITE_OS_WIN_H */†ŸO/************** End of os_win.h **********************************************/ŸO/************** Continuing where we left off in mutex_w32.c ******************/¶#endif†¢/*ŸG** The code in this file is only used if we are compiling multithreadedµ** on a Win32 system.¢*/∑#ifdef SQLITE_MUTEX_W32†¢/*ŸB** Each recursive mutex is an instance of the following structure.¢*/∂struct sqlite3_mutex {Ÿ=  CRITICAL_SECTION mutex;    /* Mutex controlling the lock */Ÿ-  int id;                    /* Mutex type */≥#ifdef SQLITE_DEBUGŸ7  volatile int nRef;         /* Number of enterances */Ÿ<  volatile DWORD owner;      /* Thread holding this mutex */Ÿ8  volatile LONG trace;       /* True to trace changes */¶#endif¢};†¢/*ŸH** These are the initializer values used when declaring a "static" mutexŸH** on Win32.  It should be noted that all mutexes require initializationπ** on the Win32 platform.¢*/Ÿ*#define SQLITE_W32_MUTEX_INITIALIZER { 0 }†≥#ifdef SQLITE_DEBUGŸK#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id, \Ÿ5                                    0L, (DWORD)0, 0 }•#elseŸJ#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id }¶#endif†≥#ifdef SQLITE_DEBUG¢/*ŸC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areŸ4** intended for use only inside assert() statements.¢*/Ÿ*static int winMutexHeld(sqlite3_mutex *p){Ÿ6  return p->nRef!=0 && p->owner==GetCurrentThreadId();°}†Ÿ9static int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){Ÿ%  return p->nRef==0 || p->owner!=tid;°}†Ÿ-static int winMutexNotheld(sqlite3_mutex *p){Ÿ#  DWORD tid = GetCurrentThreadId();Ÿ"  return winMutexNotheld2(p, tid);°}¶#endif†¢/*ŸG** Try to provide a memory barrier operation, needed for initializationŸI** and also for the xShmBarrier method of the VFS in cases when SQLite isŸ2** compiled without mutexes (SQLITE_THREADSAFE=0).¢*/Ÿ/SQLITE_PRIVATE void sqlite3MemoryBarrier(void){Ÿ"#if defined(SQLITE_MEMORY_BARRIER)∏  SQLITE_MEMORY_BARRIER;∑#elif defined(__GNUC__)∑  __sync_synchronize();∏#elif MSVC_VERSION>=1300∂  _ReadWriteBarrier();º#elif defined(MemoryBarrier)≤  MemoryBarrier();¶#endif°}†¢/*Ÿ3** Initialize and deinitialize the mutex subsystem.¢*/Ÿ1static sqlite3_mutex winMutex_staticMutexes[] = {ø  SQLITE3_MUTEX_INITIALIZER(2),ø  SQLITE3_MUTEX_INITIALIZER(3),ø  SQLITE3_MUTEX_INITIALIZER(4),ø  SQLITE3_MUTEX_INITIALIZER(5),ø  SQLITE3_MUTEX_INITIALIZER(6),ø  SQLITE3_MUTEX_INITIALIZER(7),ø  SQLITE3_MUTEX_INITIALIZER(8),ø  SQLITE3_MUTEX_INITIALIZER(9),Ÿ   SQLITE3_MUTEX_INITIALIZER(10),Ÿ   SQLITE3_MUTEX_INITIALIZER(11),Ÿ   SQLITE3_MUTEX_INITIALIZER(12),ø  SQLITE3_MUTEX_INITIALIZER(13)¢};†østatic int winMutex_isInit = 0;Ÿ=static int winMutex_isNt = -1; /* <0 means "need to query" */†ŸG/* As the winMutexInit() and winMutexEnd() functions are called as partŸE** of the sqlite3_initialize() and sqlite3_shutdown() processing, theŸD** "interlocked" magic used here is probably not strictly necessary.¢*/Ÿ4static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;†Ÿ8SQLITE_API int sqlite3_win32_is_nt(void); /* os_win.c */ŸGSQLITE_API void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */†æstatic int winMutexInit(void){Ÿ>  /* The first to increment to 1 does actual initialization */Ÿ<  if( InterlockedCompareExchange(&winMutex_lock, 1, 0)==0 ){™    int i;Ÿ7    for(i=0; i<ArraySize(winMutex_staticMutexes); i++){≥#if SQLITE_OS_WINRTŸJ      InitializeCriticalSectionEx(&winMutex_staticMutexes[i].mutex, 0, 0);•#elseŸB      InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);¶#endif•    }∏    winMutex_isInit = 1;®  }else{ŸD    /* Another thread is (in the process of) initializing the static±    ** mutexes */æ    while( !winMutex_isInit ){Ω      sqlite3_win32_sleep(1);•    }£  }≥  return SQLITE_OK;°}†Ωstatic int winMutexEnd(void){Ÿ5  /* The first to decrement to 0 does actual shutdownŸ/  ** (which should be the last to shutdown.) */Ÿ<  if( InterlockedCompareExchange(&winMutex_lock, 0, 1)==1 ){Ω    if( winMutex_isInit==1 ){¨      int i;Ÿ9      for(i=0; i<ArraySize(winMutex_staticMutexes); i++){Ÿ@        DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);ß      }∫      winMutex_isInit = 0;•    }£  }≥  return SQLITE_OK;°}†¢/*Ÿ4** The sqlite3_mutex_alloc() routine allocates a newŸ9** mutex and returns a pointer to it.  If it returns NULLŸ:** that means that a mutex could not be allocated.  SQLiteŸ;** will unwind its stack and return an error.  The argumentŸ>** to sqlite3_mutex_alloc() is one of these integer constants:¢**ß** <ul>∫** <li>  SQLITE_MUTEX_FASTø** <li>  SQLITE_MUTEX_RECURSIVEŸ#** <li>  SQLITE_MUTEX_STATIC_MASTERŸ ** <li>  SQLITE_MUTEX_STATIC_MEMŸ!** <li>  SQLITE_MUTEX_STATIC_OPENŸ!** <li>  SQLITE_MUTEX_STATIC_PRNGŸ ** <li>  SQLITE_MUTEX_STATIC_LRUŸ!** <li>  SQLITE_MUTEX_STATIC_PMEMŸ!** <li>  SQLITE_MUTEX_STATIC_APP1Ÿ!** <li>  SQLITE_MUTEX_STATIC_APP2Ÿ!** <li>  SQLITE_MUTEX_STATIC_APP3Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS1Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS2Ÿ!** <li>  SQLITE_MUTEX_STATIC_VFS3®** </ul>¢**Ÿ@** The first two constants cause sqlite3_mutex_alloc() to createŸG** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVEŸA** is used but not necessarily so when SQLITE_MUTEX_FAST is used.Ÿ?** The mutex implementation does not need to make a distinctionŸB** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it doesŸB** not want to.  But SQLite will only request a recursive mutex inŸD** cases where it really needs one.  If a faster non-recursive mutexŸH** implementation is available on the host platform, the mutex subsystemŸ>** might return such a mutex in response to SQLITE_MUTEX_FAST.¢**ŸD** The other allowed parameters to sqlite3_mutex_alloc() each returnŸC** a pointer to a static preexisting mutex.  Six static mutexes areŸD** used by the current version of SQLite.  Future versions of SQLiteŸF** may add additional static mutexes.  Static mutexes are for internalŸC** use by SQLite only.  Applications that use SQLite mutexes shouldŸ@** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or∫** SQLITE_MUTEX_RECURSIVE.¢**ŸF** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FASTŸ@** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()Ÿ?** returns a different mutex on every call.  But for the staticŸA** mutex types, the same mutex is returned on every call that has∏** the same type number.¢*/Ÿ/static sqlite3_mutex *winMutexAlloc(int iType){≥  sqlite3_mutex *p;†≤  switch( iType ){ª    case SQLITE_MUTEX_FAST:Ÿ"    case SQLITE_MUTEX_RECURSIVE: {Ÿ*      p = sqlite3MallocZero( sizeof(*p) );Æ      if( p ){∂        p->id = iType;≥#ifdef SQLITE_DEBUGŸ'#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMICµ        p->trace = 1;¶#endif¶#endif≥#if SQLITE_OS_WINRTŸ5        InitializeCriticalSectionEx(&p->mutex, 0, 0);•#elseŸ-        InitializeCriticalSection(&p->mutex);¶#endifß      }¨      break;•    }Æ    default: {æ#ifdef SQLITE_ENABLE_API_ARMORŸD      if( iType-2<0 || iType-2>=ArraySize(winMutex_staticMutexes) ){Ÿ!        (void)SQLITE_MISUSE_BKPT;±        return 0;ß      }¶#endifŸ+      p = &winMutex_staticMutexes[iType-2];≥#ifdef SQLITE_DEBUGŸ&#ifdef SQLITE_WIN32_MUTEX_TRACE_STATICŸ2      InterlockedCompareExchange(&p->trace, 1, 0);¶#endif¶#endif¨      break;•    }£  }Ÿ!  assert( p==0 || p->id==iType );´  return p;°}††¢/*Ÿ(** This routine deallocates a previouslyŸ:** allocated mutex.  SQLite is careful to deallocate everyª** mutex that it allocates.¢*/Ÿ+static void winMutexFree(sqlite3_mutex *p){Æ  assert( p );Ÿ&  assert( p->nRef==0 && p->owner==0 );ŸB  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){Ÿ%    DeleteCriticalSection(&p->mutex);¥    sqlite3_free(p);®  }else{æ#ifdef SQLITE_ENABLE_API_ARMORΩ    (void)SQLITE_MISUSE_BKPT;¶#endif£  }°}†¢/*ŸE** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptŸD** to enter a mutex.  If another thread is already within the mutex,ŸG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnŸD** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OKŸK** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE canŸD** be entered multiple times by the same thread.  In such cases the,ŸF** mutex must be exited an equal number of times before another threadŸH** can enter.  If the same thread tries to enter any other kind of mutexŸ-** more than once, the behavior is undefined.¢*/Ÿ,static void winMutexEnter(sqlite3_mutex *p){Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ÿ#  DWORD tid = GetCurrentThreadId();¶#endif≥#ifdef SQLITE_DEBUGÆ  assert( p );ŸF  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );•#elseÆ  assert( p );¶#endifø  assert( winMutex_isInit==1 );Ÿ"  EnterCriticalSection(&p->mutex);≥#ifdef SQLITE_DEBUGŸ%  assert( p->nRef>0 || p->owner==0 );±  p->owner = tid;¨  p->nRef++;±  if( p->trace ){ŸA    OSTRACE(("ENTER-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",Ÿ0             tid, p->id, p, p->trace, p->nRef));£  }¶#endif°}†Ÿ)static int winMutexTry(sqlite3_mutex *p){Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ÿ#  DWORD tid = GetCurrentThreadId();¶#endif∑  int rc = SQLITE_BUSY;Æ  assert( p );ŸF  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );§  /*ŸE  ** The sqlite3_mutex_try() routine is very rarely used, and when itŸH  ** is used it is merely an optimization.  So it is OK for it to always™  ** fail.§  **ŸH  ** The TryEnterCriticalSection() interface is only available on WinNT.ŸE  ** And some windows compilers complain if you try to use it withoutŸJ  ** first doing some #defines that prevent SQLite from building on Win98.ŸB  ** For that reason, we will omit this optimization for now.  See≤  ** ticket #2685.§  */Ÿ3#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400ø  assert( winMutex_isInit==1 );Ÿ2  assert( winMutex_isNt>=-1 && winMutex_isNt<=1 );∏  if( winMutex_isNt<0 ){Ÿ*    winMutex_isNt = sqlite3_win32_is_nt();£  }Ÿ1  assert( winMutex_isNt==0 || winMutex_isNt==1 );Ÿ<  if( winMutex_isNt && TryEnterCriticalSection(&p->mutex) ){≥#ifdef SQLITE_DEBUG≥    p->owner = tid;Æ    p->nRef++;¶#endif≥    rc = SQLITE_OK;£  }•#else∂  UNUSED_PARAMETER(p);¶#endif≥#ifdef SQLITE_DEBUG±  if( p->trace ){ŸQ    OSTRACE(("TRY-MUTEX tid=%lu, mutex(%d)=%p (%d), owner=%lu, nRef=%d, rc=%s\n",ŸN             tid, p->id, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));£  }¶#endif¨  return rc;°}†¢/*Ÿ;** The sqlite3_mutex_leave() routine exits a mutex that wasŸ7** previously entered by the same thread.  The behaviorŸ8** is undefined if the mutex is not currently entered orŸ<** is not currently allocated.  SQLite will never do either.¢*/Ÿ,static void winMutexLeave(sqlite3_mutex *p){Ÿ1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ÿ#  DWORD tid = GetCurrentThreadId();¶#endifÆ  assert( p );≥#ifdef SQLITE_DEBUG∂  assert( p->nRef>0 );∫  assert( p->owner==tid );¨  p->nRef--;Ÿ   if( p->nRef==0 ) p->owner = 0;Ÿ8  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );¶#endifø  assert( winMutex_isInit==1 );Ÿ"  LeaveCriticalSection(&p->mutex);≥#ifdef SQLITE_DEBUG±  if( p->trace ){ŸA    OSTRACE(("LEAVE-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",Ÿ0             tid, p->id, p, p->trace, p->nRef));£  }¶#endif°}†ŸFSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){Ÿ/  static const sqlite3_mutex_methods sMutex = {±    winMutexInit,∞    winMutexEnd,≤    winMutexAlloc,±    winMutexFree,≤    winMutexEnter,∞    winMutexTry,≤    winMutexLeave,≥#ifdef SQLITE_DEBUG±    winMutexHeld,≥    winMutexNotheld•#else¶    0,•    0¶#endif§  };±  return &sMutex;°}†Ω#endif /* SQLITE_MUTEX_W32 */†ŸO/************** End of mutex_w32.c *******************************************/ŸO/************** Begin file malloc.c ******************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**Ÿ6** Memory allocation functions used throughout sqlite.¢*/º/* #include "sqliteInt.h" */π/* #include <stdarg.h> */†¢/*ŸE** Attempt to release up to n bytes of non-essential memory currentlyŸG** held by SQLite. An example of non-essential memory is memory used toŸ6** cache database pages that are not currently in use.¢*/Ÿ-SQLITE_API int sqlite3_release_memory(int n){Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTŸ'  return sqlite3PcacheReleaseMemory(n);•#elseŸJ  /* IMPLEMENTATION-OF: R-34391-24921 The sqlite3_release_memory() routineŸ=  ** is a no-op returning zero if SQLite is not compiled withŸ(  ** SQLITE_ENABLE_MEMORY_MANAGEMENT. */∂  UNUSED_PARAMETER(n);´  return 0;¶#endif°}†¢/*Ÿ>** State information local to the memory allocation subsystem.¢*/Ÿ%static SQLITE_WSD struct Mem0Global {Ÿ?  sqlite3_mutex *mutex;         /* Mutex to serialize access */Ÿ9  sqlite3_int64 alarmThreshold; /* The soft heap limit */†§  /*ŸA  ** True if heap is nearly "full" where "full" is defined by theŸ'  ** sqlite3_soft_heap_limit() setting.§  */±  int nearlyFull;µ} mem0 = { 0, 0, 0 };†Ÿ,#define mem0 GLOBAL(struct Mem0Global, mem0)†¢/*Ÿ@** Return the memory allocator mutex. sqlite3_status() needs it.¢*/Ÿ7SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void){¥  return mem0.mutex;°}†æ#ifndef SQLITE_OMIT_DEPRECATED¢/*ŸC** Deprecated external interface.  It used to set an alarm callbackŸB** that was invoked when memory usage grew too large.  Now it is a©** no-op.¢*/Ÿ$SQLITE_API int sqlite3_memory_alarm(Ÿ9  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),≠  void *pArg,∫  sqlite3_int64 iThreshold¢){≤  (void)xCallback;≠  (void)pArg;≥  (void)iThreshold;≥  return SQLITE_OK;°}¶#endif†¢/*ŸC** Set the soft heap-size limit for the library. Passing a zero or Ÿ%** negative value indicates no limit.¢*/ŸDSQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){ª  sqlite3_int64 priorLimit;∑  sqlite3_int64 excess;∂  sqlite3_int64 nUsed;º#ifndef SQLITE_OMIT_AUTOINITŸ   int rc = sqlite3_initialize();µ  if( rc ) return -1;¶#endifŸ"  sqlite3_mutex_enter(mem0.mutex);Ÿ#  priorLimit = mem0.alarmThreshold;¨  if( n<0 ){Ÿ$    sqlite3_mutex_leave(mem0.mutex);∂    return priorLimit;£  }∫  mem0.alarmThreshold = n;Ÿ8  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);Ÿ&  mem0.nearlyFull = (n>0 && n<=nUsed);Ÿ"  sqlite3_mutex_leave(mem0.mutex);Ÿ%  excess = sqlite3_memory_used() - n;ŸD  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));¥  return priorLimit;°}Ÿ/SQLITE_API void sqlite3_soft_heap_limit(int n){≤  if( n<0 ) n = 0;ø  sqlite3_soft_heap_limit64(n);°}†¢/*Ÿ.** Initialize the memory allocation subsystem.¢*/Ÿ+SQLITE_PRIVATE int sqlite3MallocInit(void){©  int rc;Ÿ)  if( sqlite3GlobalConfig.m.xMalloc==0 ){ª    sqlite3MemSetDefault();£  }Ÿ!  memset(&mem0, 0, sizeof(mem0));Ÿ:  mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);ŸD  if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512Ÿ(      || sqlite3GlobalConfig.nPage<=0 ){Ÿ"    sqlite3GlobalConfig.pPage = 0;Ÿ#    sqlite3GlobalConfig.szPage = 0;£  }ŸC  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);Ÿ5  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));¨  return rc;°}†¢/*ŸH** Return true if the heap is currently under memory pressure - in otherŸ@** words if the amount of heap used is close to the limit set byΩ** sqlite3_soft_heap_limit().¢*/Ÿ/SQLITE_PRIVATE int sqlite3HeapNearlyFull(void){π  return mem0.nearlyFull;°}†¢/*Ÿ0** Deinitialize the memory allocation subsystem.¢*/Ÿ+SQLITE_PRIVATE void sqlite3MallocEnd(void){Ÿ(  if( sqlite3GlobalConfig.m.xShutdown ){ŸD    sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData);£  }Ÿ!  memset(&mem0, 0, sizeof(mem0));°}†¢/*Ÿ5** Return the amount of memory currently checked out.¢*/Ÿ3SQLITE_API sqlite3_int64 sqlite3_memory_used(void){∏  sqlite3_int64 res, mx;Ÿ<  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);≠  return res;°}†¢/*Ÿ9** Return the maximum amount of memory that has ever beenŸ9** checked out since either the beginning of this processŸ"** or since the most recent reset.¢*/ŸASQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){∏  sqlite3_int64 res, mx;ŸD  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);¨  return mx;°}†¢/*µ** Trigger the alarm ¢*/Ÿ*static void sqlite3MallocAlarm(int nByte){Ÿ&  if( mem0.alarmThreshold<=0 ) return;Ÿ"  sqlite3_mutex_leave(mem0.mutex);Ÿ   sqlite3_release_memory(nByte);Ÿ"  sqlite3_mutex_enter(mem0.mutex);°}†¢/*ŸA** Do a memory allocation with statistics and alarms.  Assume the∏** lock is already held.¢*/Ÿ.static void mallocWithAlarm(int n, void **pp){™  void *p;¨  int nFull;Ÿ+  assert( sqlite3_mutex_held(mem0.mutex) );∞  assert( n>0 );†ŸI  /* In Firefox (circa 2017-02-08), xRoundup() is remapped to an internalŸH  ** implementation of malloc_good_size(), which must be called in debugŸI  ** mode and specifically when the DMD "Dark Matter Detector" is enabledŸH  ** or else a crash results.  Hence, do not attempt to optimize out theŸ"  ** following xRoundup() call. */Ÿ,  nFull = sqlite3GlobalConfig.m.xRoundup(n);†∏#ifdef SQLITE_MAX_MEMORYŸN  if( sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)+nFull>SQLITE_MAX_MEMORY ){¨    *pp = 0;´    return;£  }¶#endif†Ÿ7  sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);æ  if( mem0.alarmThreshold>0 ){ŸH    sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);Ÿ/    if( nUsed >= mem0.alarmThreshold - nFull ){∫      mem0.nearlyFull = 1;Ÿ       sqlite3MallocAlarm(nFull);™    }else{∫      mem0.nearlyFull = 0;•    }£  }Ÿ+  p = sqlite3GlobalConfig.m.xMalloc(nFull);Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTŸ&  if( p==0 && mem0.alarmThreshold>0 ){æ    sqlite3MallocAlarm(nFull);Ÿ-    p = sqlite3GlobalConfig.m.xMalloc(nFull);£  }¶#endif™  if( p ){Ÿ!    nFull = sqlite3MallocSize(p);Ÿ6    sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);Ÿ3    sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);£  }™  *pp = p;°}†¢/*ŸI** Allocate memory.  This routine is like sqlite3_malloc() except that itŸ=** assumes the memory subsystem has already been initialized.¢*/Ÿ*SQLITE_PRIVATE void *sqlite3Malloc(u64 n){™  void *p;æ  if( n==0 || n>=0x7fffff00 ){ŸI    /* A memory allocation of a number of bytes which is near the maximumŸI    ** signed integer value might cause an integer overflow inside of theŸH    ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, givingŸI    ** 255 bytes of overhead.  SQLite itself will never use anything nearŸP    ** this amount.  The only way to reach the limit is with sqlite3_malloc() */™    p = 0;Ÿ+  }else if( sqlite3GlobalConfig.bMemstat ){Ÿ$    sqlite3_mutex_enter(mem0.mutex);Ÿ     mallocWithAlarm((int)n, &p);Ÿ$    sqlite3_mutex_leave(mem0.mutex);®  }else{Ÿ.    p = sqlite3GlobalConfig.m.xMalloc((int)n);£  }Ÿ>  assert( EIGHT_BYTE_ALIGNMENT(p) );  /* IMP: R-11148-40995 */´  return p;°}†¢/*ŸG** This version of the memory allocation is for use by the application.ŸC** First make sure the memory subsystem is initialized, then do theÆ** allocation.¢*/Ÿ'SQLITE_API void *sqlite3_malloc(int n){º#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ%  return n<=0 ? 0 : sqlite3Malloc(n);°}Ÿ4SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n){º#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endif∫  return sqlite3Malloc(n);°}†¢/*Ÿ5** TRUE if p is a lookaside memory allocation from db¢*/Ω#ifndef SQLITE_OMIT_LOOKASIDEŸ-static int isLookaside(sqlite3 *db, void *p){ŸD  return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pEnd);°}•#else∫#define isLookaside(A,B) 0¶#endif†¢/*ŸB** Return the size of a memory allocation previously obtained fromŸ'** sqlite3Malloc() or sqlite3_malloc().¢*/Ÿ.SQLITE_PRIVATE int sqlite3MallocSize(void *p){Ÿ4  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );Ÿ(  return sqlite3GlobalConfig.m.xSize(p);°}Ÿ=SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){±  assert( p!=0 );Ÿ$  if( db==0 || !isLookaside(db,p) ){≥#ifdef SQLITE_DEBUG∞    if( db==0 ){Ÿ<      assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );Ÿ8      assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );™    }else{ŸL      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ŸP      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );•    }¶#endifŸ*    return sqlite3GlobalConfig.m.xSize(p);®  }else{Ÿ,    assert( sqlite3_mutex_held(db->mutex) );º    return db->lookaside.sz;£  }°}Ÿ1SQLITE_API sqlite3_uint64 sqlite3_msize(void *p){Ÿ8  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );Ÿ4  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );Ÿ0  return p ? sqlite3GlobalConfig.m.xSize(p) : 0;°}†¢/*Ÿ8** Free memory previously obtained from sqlite3Malloc().¢*/Ÿ&SQLITE_API void sqlite3_free(void *p){Ÿ.  if( p==0 ) return;  /* IMP: R-49053-54554 */Ÿ4  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );Ÿ8  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );Ÿ%  if( sqlite3GlobalConfig.bMemstat ){Ÿ$    sqlite3_mutex_enter(mem0.mutex);ŸG    sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));Ÿ5    sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);Ÿ#    sqlite3GlobalConfig.m.xFree(p);Ÿ$    sqlite3_mutex_leave(mem0.mutex);®  }else{Ÿ#    sqlite3GlobalConfig.m.xFree(p);£  }°}†¢/*Ÿ8** Add the size of memory allocation "p" to the count inµ** *db->pnBytesFreed.¢*/ŸHstatic SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){Ÿ1  *db->pnBytesFreed += sqlite3DbMallocSize(db,p);°}†¢/*ŸB** Free memory that might be associated with a particular databaseŸH** connection.  Calling sqlite3DbFree(D,X) for X==0 is a harmless no-op.Ÿ@** The sqlite3DbFreeNN(D,X) version requires that X be non-NULL.¢*/Ÿ:SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3 *db, void *p){Ÿ3  assert( db==0 || sqlite3_mutex_held(db->mutex) );±  assert( p!=0 );´  if( db ){ª    if( db->pnBytesFreed ){Ÿ#      measureAllocationSize(db, p);≠      return;•    }Ω    if( isLookaside(db, p) ){Ÿ.      LookasideSlot *pBuf = (LookasideSlot*)p;≥#ifdef SQLITE_DEBUGŸ7      /* Trash all content in the buffer being freed */Ÿ(      memset(p, 0xaa, db->lookaside.sz);¶#endifŸ(      pBuf->pNext = db->lookaside.pFree;Ÿ!      db->lookaside.pFree = pBuf;≠      return;•    }£  }ŸH  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ŸL  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ŸA  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );Ÿ*  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);≤  sqlite3_free(p);°}Ÿ8SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){Ÿ3  assert( db==0 || sqlite3_mutex_held(db->mutex) );Ÿ!  if( p ) sqlite3DbFreeNN(db, p);°}†¢/*Ÿ3** Change the size of an existing memory allocation¢*/Ÿ<SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){∏  int nOld, nNew, nDiff;≠  void *pNew;Ÿ7  assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );Ÿ;  assert( sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP) );∞  if( pOld==0 ){Ÿ:    return sqlite3Malloc(nBytes); /* IMP: R-04300-56712 */£  }≤  if( nBytes==0 ){Ÿ0    sqlite3_free(pOld); /* IMP: R-26507-47431 */≠    return 0;£  }ª  if( nBytes>=0x7fffff00 ){ŸN    /* The 0x7ffff00 limit term is explained in comments on sqlite3Malloc() */≠    return 0;£  }Ÿ!  nOld = sqlite3MallocSize(pOld);ŸG  /* IMPLEMENTATION-OF: R-46199-30249 SQLite guarantees that the secondŸG  ** argument to xRealloc is always a value returned by a prior call to±  ** xRoundup. */Ÿ5  nNew = sqlite3GlobalConfig.m.xRoundup((int)nBytes);≥  if( nOld==nNew ){∞    pNew = pOld;Ÿ+  }else if( sqlite3GlobalConfig.bMemstat ){Ÿ$    sqlite3_mutex_enter(mem0.mutex);ŸC    sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, (int)nBytes);∏    nDiff = nNew - nOld;ŸD    if( nDiff>0 && sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED) >= Ÿ&          mem0.alarmThreshold-nDiff ){Ÿ       sqlite3MallocAlarm(nDiff);•    }Ÿ6    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);Ÿ+    if( pNew==0 && mem0.alarmThreshold>0 ){Ÿ&      sqlite3MallocAlarm((int)nBytes);Ÿ8      pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);•    }Ø    if( pNew ){Ÿ%      nNew = sqlite3MallocSize(pNew);Ÿ<      sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew-nOld);•    }Ÿ$    sqlite3_mutex_leave(mem0.mutex);®  }else{Ÿ6    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);£  }Ÿ@  assert( EIGHT_BYTE_ALIGNMENT(pNew) ); /* IMP: R-11148-40995 */Æ  return pNew;°}†¢/*ŸE** The public interface to sqlite3Realloc.  Make sure that the memoryŸ<** subsystem is initialized prior to invoking sqliteRealloc.¢*/Ÿ4SQLITE_API void *sqlite3_realloc(void *pOld, int n){º#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ,  if( n<0 ) n = 0;  /* IMP: R-26507-47431 */Ÿ!  return sqlite3Realloc(pOld, n);°}ŸASQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){º#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ!  return sqlite3Realloc(pOld, n);°}††¢/*º** Allocate and zero memory.£*/ Ÿ.SQLITE_PRIVATE void *sqlite3MallocZero(u64 n){Ω  void *p = sqlite3Malloc(n);™  if( p ){º    memset(p, 0, (size_t)n);£  }´  return p;°}†¢/*Ÿ;** Allocate and zero memory.  If the allocation fails, makeŸ3** the mallocFailed flag in the connection pointer.¢*/Ÿ=SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n){™  void *p;¥  testcase( db==0 );Ÿ   p = sqlite3DbMallocRaw(db, n);Ÿ"  if( p ) memset(p, 0, (size_t)n);´  return p;°}††Ÿ>/* Finish the work of sqlite3DbMallocRawNN for the unusual andŸG** slower case when the allocation cannot be fulfilled using lookaside.¢*/ŸCstatic SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){™  void *p;≤  assert( db!=0 );∑  p = sqlite3Malloc(n);ø  if( !p ) sqlite3OomFault(db);º  sqlite3MemdebugSetType(p, ŸI         (db->lookaside.bDisable==0) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP);´  return p;°}†¢/*Ÿ=** Allocate memory, either lookaside (if possible) or heap.  Ÿ8** If the allocation fails, set the mallocFailed flag in∫** the connection pointer.¢**ŸC** If db!=0 and db->mallocFailed is true (indicating a prior mallocŸA** failure on the same database connection) then always return 0.ŸA** Hence for a particular database connection, once malloc startsŸ>** failing, it fails consistently until mallocFailed is reset.ŸA** This is an important assumption.  There are many places in theŸ!** code that do things like this:¢**Ÿ6**         int *a = (int*)sqlite3DbMallocRaw(db, 100);Ÿ6**         int *b = (int*)sqlite3DbMallocRaw(db, 200);Ω**         if( b ) a[10] = 9;¢**ŸI** In other words, if a subsequent malloc (ex: "b") worked, it is assumedŸ/** that all prior mallocs (ex: "a") worked too.¢**ŸI** The sqlite3MallocRawNN() variant guarantees that the "db" parameter is∂** not a NULL pointer.¢*/Ÿ<SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){™  void *p;Ÿ.  if( db ) return sqlite3DbMallocRawNN(db, n);∑  p = sqlite3Malloc(n);Ÿ*  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);´  return p;°}Ÿ>SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){Ω#ifndef SQLITE_OMIT_LOOKASIDE∂  LookasideSlot *pBuf;≤  assert( db!=0 );Ÿ*  assert( sqlite3_mutex_held(db->mutex) );Ÿ   assert( db->pnBytesFreed==0 );Ÿ"  if( db->lookaside.bDisable==0 ){Ÿ"    assert( db->mallocFailed==0 );Ω    if( n>db->lookaside.sz ){Ÿ       db->lookaside.anStat[1]++;Ÿ0    }else if( (pBuf = db->lookaside.pFree)!=0 ){Ÿ(      db->lookaside.pFree = pBuf->pNext;Ÿ       db->lookaside.anStat[0]++;π      return (void*)pBuf;Ÿ0    }else if( (pBuf = db->lookaside.pInit)!=0 ){Ÿ(      db->lookaside.pInit = pBuf->pNext;Ÿ       db->lookaside.anStat[0]++;π      return (void*)pBuf;™    }else{Ÿ       db->lookaside.anStat[2]++;•    }ø  }else if( db->mallocFailed ){≠    return 0;£  }•#else≤  assert( db!=0 );Ÿ*  assert( sqlite3_mutex_held(db->mutex) );Ÿ   assert( db->pnBytesFreed==0 );π  if( db->mallocFailed ){≠    return 0;£  }¶#endifŸ"  return dbMallocRawFinish(db, n);°}†π/* Forward declaration */ŸJstatic SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n);†¢/*Ÿ@** Resize the block of memory pointed to by p to n bytes. If theŸD** resize fails, set the mallocFailed flag in the connection object.¢*/ŸCSQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){≤  assert( db!=0 );Ÿ0  if( p==0 ) return sqlite3DbMallocRawNN(db, n);Ÿ*  assert( sqlite3_mutex_held(db->mutex) );Ÿ:  if( isLookaside(db,p) && n<=db->lookaside.sz ) return p;Ÿ#  return dbReallocFinish(db, p, n);°}ŸJstatic SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){±  void *pNew = 0;≤  assert( db!=0 );±  assert( p!=0 );º  if( db->mallocFailed==0 ){Ω    if( isLookaside(db, p) ){Ÿ)      pNew = sqlite3DbMallocRawNN(db, n);±      if( pNew ){Ÿ*        memcpy(pNew, p, db->lookaside.sz);Ω        sqlite3DbFree(db, p);ß      }™    }else{ŸL      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ŸP      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );Ÿ.      sqlite3MemdebugSetType(p, MEMTYPE_HEAP);Ÿ%      pNew = sqlite3_realloc64(p, n);≤      if( !pNew ){º        sqlite3OomFault(db);ß      }Ÿ"      sqlite3MemdebugSetType(pNew,ŸL            (db->lookaside.bDisable==0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));•    }£  }Æ  return pNew;°}†¢/*ŸC** Attempt to reallocate p.  If the reallocation fails, then free pŸ<** and set the mallocFailed flag in the database connection.¢*/ŸISQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){≠  void *pNew;Ÿ$  pNew = sqlite3DbRealloc(db, p, n);Æ  if( !pNew ){π    sqlite3DbFree(db, p);£  }Æ  return pNew;°}†¢/*ŸI** Make a copy of a string in memory obtained from sqliteMalloc(). These ŸM** functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). ThisŸJ** is because when memory debugging is turned on, these two functions are ŸH** called via macros that record the current file and line number in the∏** ThreadData structure.¢*/ŸASQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){≠  char *zNew;´  size_t n;≠  if( z==0 ){≠    return 0;£  }¥  n = strlen(z) + 1;Ÿ#  zNew = sqlite3DbMallocRaw(db, n);≠  if( zNew ){∑    memcpy(zNew, z, n);£  }Æ  return zNew;°}ŸISQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){≠  char *zNew;≤  assert( db!=0 );≠  if( z==0 ){≠    return 0;£  }æ  assert( (n&0x7fffffff)==n );Ÿ'  zNew = sqlite3DbMallocRawNN(db, n+1);≠  if( zNew ){ø    memcpy(zNew, z, (size_t)n);∞    zNew[n] = 0;£  }Æ  return zNew;°}†¢/*ŸG** The text between zStart and zEnd represents a phrase within a largerŸD** SQL statement.  Make a copy of this phrase in space obtained formŸ<** sqlite3DbMalloc().  Omit leading and trailing whitespace.¢*/ŸYSQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){®  int n;Ÿ.  while( sqlite3Isspace(zStart[0]) ) zStart++;ª  n = (int)(zEnd - zStart);Ÿ:  while( ALWAYS(n>0) && sqlite3Isspace(zStart[n-1]) ) n--;Ÿ)  return sqlite3DbStrNDup(db, zStart, n);°}†¢/*ŸD** Free any prior content in *pz and replace it with a copy of zNew.¢*/ŸOSQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){π  sqlite3DbFree(db, *pz);Ÿ"  *pz = sqlite3DbStrDup(db, zNew);°}†¢/*ŸI** Call this routine to record the fact that an OOM (out-of-memory) errorŸB** has happened.  This routine will set db->mallocFailed, and alsoŸC** temporarily disable the lookaside memory allocator and interruptµ** any running VDBEs.¢*/Ÿ1SQLITE_PRIVATE void sqlite3OomFault(sqlite3 *db){Ÿ4  if( db->mallocFailed==0 && db->bBenignMalloc==0 ){π    db->mallocFailed = 1;∫    if( db->nVdbeExec>0 ){ø      db->u1.isInterrupted = 1;•    }Ω    db->lookaside.bDisable++;£  }°}†¢/*Ÿ?** This routine reactivates the memory allocator and clears theŸ&** db->mallocFailed flag as necessary.¢**Ÿ=** The memory allocator is not restarted if there are running©** VDBEs.¢*/Ÿ1SQLITE_PRIVATE void sqlite3OomClear(sqlite3 *db){Ÿ-  if( db->mallocFailed && db->nVdbeExec==0 ){π    db->mallocFailed = 0;Ω    db->u1.isInterrupted = 0;Ÿ'    assert( db->lookaside.bDisable>0 );Ω    db->lookaside.bDisable--;£  }°}†¢/*ŸB** Take actions at the end of an API call to indicate an OOM error¢*/Ÿ4static SQLITE_NOINLINE int apiOomError(sqlite3 *db){∂  sqlite3OomClear(db);Ÿ!  sqlite3Error(db, SQLITE_NOMEM);ª  return SQLITE_NOMEM_BKPT;°}†¢/*ŸF** This function must be called before exiting any API function (i.e. ŸC** returning control to the user) that has called sqlite3_malloc or≥** sqlite3_realloc.¢**ŸG** The returned value is normally a copy of the second argument to thisŸK** function. However, if a malloc() failure has occurred since the previousŸ0** invocation SQLITE_NOMEM is returned instead. ¢**ŸC** If an OOM as occurred, then the connection error-code (the valueŸ9** returned by sqlite3_errcode()) is set to SQLITE_NOMEM.¢*/Ÿ7SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){ŸA  /* If the db handle must hold the connection handle mutex here.ŸA  ** Otherwise the read (and possible write) of db->mallocFailed Ÿ1  ** is unsafe, as is the call to sqlite3Error().§  */≤  assert( db!=0 );Ÿ*  assert( sqlite3_mutex_held(db->mutex) );Ÿ3  if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){ª    return apiOomError(db);£  }∫  return rc & db->errMask;°}†ŸO/************** End of malloc.c **********************************************/ŸO/************** Begin file printf.c ******************************************/¢/*ŸB** The "printf" code that follows dates from the 1980's.  It is in∂** the public domain. ¢**ŸJ**************************************************************************¢**ŸF** This file contains code for a set of "printf"-like routines.  TheseŸE** routines format strings much like the printf() from the standard CŸF** library, though the implementation here has enhancements to support™** SQLite.¢*/º/* #include "sqliteInt.h" */†¢/*ŸB** Conversion types fall into various categories as defined by theπ** following enumeration.¢*/Ÿ?#define etRADIX       0 /* non-decimal integer types.  %x %o */Ÿ1#define etFLOAT       1 /* Floating point.  %f */Ÿ?#define etEXP         2 /* Exponentional notation. %e and %E */ŸP#define etGENERIC     3 /* Floating or exponential, depending on exponent. %g */ŸN#define etSIZE        4 /* Return number of characters processed so far. %n */Ÿ)#define etSTRING      5 /* Strings. %s */Ÿ?#define etDYNSTRING   6 /* Dynamically allocated strings. %z */Ÿ0#define etPERCENT     7 /* Percent symbol. %% */Ÿ,#define etCHARX       8 /* Characters. %c */Ÿ=/* The rest are extensions, not normally found in printf() */Ÿ<#define etSQLESCAPE   9 /* Strings with '\'' doubled.  %q */ŸH#define etSQLESCAPE2 10 /* Strings with '\'' doubled and enclosed in '',ŸD                          NULL pointers replaced by SQL NULL.  %Q */Ÿ<#define etTOKEN      11 /* a pointer to a Token structure */Ÿ4#define etSRCLIST    12 /* a pointer to a SrcList */Ÿ/#define etPOINTER    13 /* The %p conversion */Ÿ=#define etSQLESCAPE3 14 /* %w -> Strings with '\"' doubled */ŸJ#define etORDINAL    15 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */Ÿ6#define etDECIMAL    16 /* %d or %u, but not %x, %o */†Ÿ>#define etINVALID    17 /* Any unrecognized conversion type */††¢/*Ÿ*** An "etByte" is an 8-bit unsigned value.¢*/Ωtypedef unsigned char etByte;†¢/*ŸG** Each builtin conversion character (ex: the 'd' in "%d") is describedŸ,** by an instance of the following structure¢*/ŸDtypedef struct et_info {   /* Information about each format field */Ÿ=  char fmttype;            /* The format field code letter */Ÿ>  etByte base;             /* The base for radix conversion */ŸE  etByte flags;            /* One or more of FLAG_ constants below */Ÿ4  etByte type;             /* Conversion paradigm */ŸK  etByte charset;          /* Offset into aDigits[] of the digits string */ŸK  etByte prefix;           /* Offset into aPrefix[] of the prefix string */™} et_info;†¢/*Ÿ#** Allowed values for et_info.flags¢*/ŸI#define FLAG_SIGNED    1     /* True if the value to convert is signed */Ÿ;#define FLAG_STRING    4     /* Allow infinite precision */††¢/*ŸE** The following table is searched linearly, so it is good to put theŸ/** most frequently used conversion types first.¢*/ŸAstatic const char aDigits[] = "0123456789ABCDEF0123456789abcdef";Ÿ*static const char aPrefix[] = "-x0\000X0";Ÿ"static const et_info fmtinfo[] = {Ÿ'  {  'd', 10, 1, etDECIMAL,    0,  0 },Ÿ'  {  's',  0, 4, etSTRING,     0,  0 },Ÿ'  {  'g',  0, 1, etGENERIC,    30, 0 },Ÿ'  {  'z',  0, 4, etDYNSTRING,  0,  0 },Ÿ'  {  'q',  0, 4, etSQLESCAPE,  0,  0 },Ÿ'  {  'Q',  0, 4, etSQLESCAPE2, 0,  0 },Ÿ'  {  'w',  0, 4, etSQLESCAPE3, 0,  0 },Ÿ'  {  'c',  0, 0, etCHARX,      0,  0 },Ÿ'  {  'o',  8, 0, etRADIX,      0,  2 },Ÿ'  {  'u', 10, 0, etDECIMAL,    0,  0 },Ÿ'  {  'x', 16, 0, etRADIX,      16, 1 },Ÿ'  {  'X', 16, 0, etRADIX,      0,  4 },Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINTŸ'  {  'f',  0, 1, etFLOAT,      0,  0 },Ÿ'  {  'e',  0, 1, etEXP,        30, 0 },Ÿ'  {  'E',  0, 1, etEXP,        14, 0 },Ÿ'  {  'G',  0, 1, etGENERIC,    14, 0 },¶#endifŸ'  {  'i', 10, 1, etDECIMAL,    0,  0 },Ÿ'  {  'n',  0, 0, etSIZE,       0,  0 },Ÿ'  {  '%',  0, 0, etPERCENT,    0,  0 },Ÿ'  {  'p', 16, 0, etPOINTER,    0,  1 },†ŸC  /* All the rest are undocumented and are for internal use only */Ÿ'  {  'T',  0, 0, etTOKEN,      0,  0 },Ÿ'  {  'S',  0, 0, etSRCLIST,    0,  0 },Ÿ'  {  'r', 10, 1, etORDINAL,    0,  0 },¢};†¢/*ŸL** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating pointπ** conversions will work.¢*/Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINT¢/*Ÿ2** "*val" is a double such that 0.1 <= *val < 10.0Ÿ<** Return the ascii code for the leading digit of *val, thenŸ*** multiply "*val" by 10.0 to renormalize.¢**´** Example:Ÿ **     input:     *val = 3.14159Ÿ8**     output:    *val = 1.4159    function return = '3'¢**ŸD** The counter *cnt is incremented each time.  After counter exceedsŸA** 16 (the number of significant digits in a 64-bit float) '0' is≥** always returned.¢*/Ÿ8static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){¨  int digit;¥  LONGDOUBLE_TYPE d;Ω  if( (*cnt)<=0 ) return '0';´  (*cnt)--;¥  digit = (int)*val;¨  d = digit;Ø  digit += '0';π  *val = (*val - d)*10.0;µ  return (char)digit;°}Ÿ'#endif /* SQLITE_OMIT_FLOATING_POINT */†¢/*Ÿ,** Set the StrAccum object to an error mode.¢*/Ÿ5static void setStrAccumError(StrAccum *p, u8 eError){Ÿ>  assert( eError==STRACCUM_NOMEM || eError==STRACCUM_TOOBIG );∑  p->accError = eError;∞  p->nAlloc = 0;°}†¢/*Ÿ6** Extra argument values from a PrintfArguments object¢*/Ÿ3static sqlite3_int64 getIntArg(PrintfArguments *p){Ÿ#  if( p->nArg<=p->nUsed ) return 0;Ÿ3  return sqlite3_value_int64(p->apArg[p->nUsed++]);°}Ÿ/static double getDoubleArg(PrintfArguments *p){Ÿ%  if( p->nArg<=p->nUsed ) return 0.0;Ÿ4  return sqlite3_value_double(p->apArg[p->nUsed++]);°}Ÿ,static char *getTextArg(PrintfArguments *p){Ÿ#  if( p->nArg<=p->nUsed ) return 0;Ÿ9  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);°}††¢/*Ÿ<** On machines with a small stack size, you can redefine theŸ=** SQLITE_PRINT_BUF_SIZE to be something smaller, if desired.¢*/Ω#ifndef SQLITE_PRINT_BUF_SIZEŸ!# define SQLITE_PRINT_BUF_SIZE 70¶#endifŸH#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */†¢/*Ÿ;** Render a string given by "fmt" into the StrAccum object.¢*/Ÿ$SQLITE_PRIVATE void sqlite3VXPrintf(Ÿ:  StrAccum *pAccum,          /* Accumulate results here */Ÿ0  const char *fmt,           /* Format string */Ÿ,  va_list ap                 /* arguments */¢){ŸF  int c;                     /* Next character in the format string */ŸC  char *bufpt;               /* Pointer to the conversion buffer */ŸA  int precision;             /* Precision of the current field */Ÿ6  int length;                /* Length of the field */ŸA  int idx;                   /* A general purpose loop counter */Ÿ=  int width;                 /* Width of the current field */Ÿ>  etByte flag_leftjustify;   /* True if "-" flag is present */Ÿ=  etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */Ÿ>  etByte flag_alternateform; /* True if "#" flag is present */Ÿ>  etByte flag_altform2;      /* True if "!" flag is present */ŸP  etByte flag_zeropad;       /* True if field width constant starts with zero */ŸO  etByte flag_long;          /* 1 for the "l" flag, 2 for "ll", 0 by default */Ÿ8  etByte done;               /* Loop termination flag */ŸD  etByte cThousand;          /* Thousands separator for %d and %u */Ÿ6  etByte xtype = etINVALID;  /* Conversion paradigm */ŸA  u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */ŸP  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */Ÿ:  sqlite_uint64 longvalue;   /* Value for integer types */Ÿ7  LONGDOUBLE_TYPE realvalue; /* Value for real types */ŸL  const et_info *infop;      /* Pointer to the appropriate info structure */Ÿ3  char *zOut;                /* Rendering buffer */Ÿ?  int nOut;                  /* Size of the rendering buffer */ŸJ  char *zExtra = 0;          /* Malloced memory used by some conversion */Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINTŸ;  int  exp, e2;              /* exponent of real numbers */ŸH  int nsd;                   /* Number of significant digits returned */ŸJ  double rounder;            /* Used for rounding floating point values */ŸH  etByte flag_dp;            /* True if decimal point should be shown */ŸK  etByte flag_rtz;           /* True if trailing zeros should be removed */¶#endifŸJ  PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */Ÿ4  char buf[etBUFSIZE];       /* Conversion buffer */†ŸI  /* pAccum never starts out with an empty buffer that was obtained from ŸE  ** malloc().  This precondition is required by the mprintf("%z...")µ  ** optimization. */ŸO  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );†¨  bufpt = 0;Ÿ9  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){Ÿ,    pArgList = va_arg(ap, PrintfArguments*);±    bArgList = 1;®  }else{±    bArgList = 0;£  }æ  for(; (c=(*fmt))!=0; ++fmt){±    if( c!='%' ){∫      bufpt = (char *)fmt;≤#if HAVE_STRCHRNULŸ       fmt = strchrnul(fmt, '%');•#elseŸ/      do{ fmt++; }while( *fmt && *fmt != '%' );¶#endifŸ?      sqlite3StrAccumAppend(pAccum, bufpt, (int)(fmt - bufpt));∫      if( *fmt==0 ) break;•    }∫    if( (c=(*++fmt))==0 ){Ÿ,      sqlite3StrAccumAppend(pAccum, "%", 1);¨      break;•    }Ÿ)    /* Find out what flags are present */Ÿ0    flag_leftjustify = flag_prefix = cThousand =Ÿ;     flag_alternateform = flag_altform2 = flag_zeropad = 0;≠    done = 0;ß    do{≤      switch( c ){Ÿ4        case '-':   flag_leftjustify = 1;     break;Ÿ4        case '+':   flag_prefix = '+';        break;Ÿ4        case ' ':   flag_prefix = ' ';        break;Ÿ4        case '#':   flag_alternateform = 1;   break;Ÿ4        case '!':   flag_altform2 = 1;        break;Ÿ4        case '0':   flag_zeropad = 1;         break;Ÿ4        case ',':   cThousand = ',';          break;Ÿ4        default:    done = 1;                 break;ß      }Ÿ'    }while( !done && (c=(*++fmt))!=0 );Ω    /* Get the field width */±    if( c=='*' ){µ      if( bArgList ){Ÿ)        width = (int)getIntArg(pArgList);¨      }else{ø        width = va_arg(ap,int);ß      }¥      if( width<0 ){Ω        flag_leftjustify = 1;Ÿ2        width = width >= -2147483647 ? -width : 0;ß      }±      c = *++fmt;™    }else{∂      unsigned wx = 0;Ÿ       while( c>='0' && c<='9' ){Ω        wx = wx*10 + c - '0';≥        c = *++fmt;ß      }Ÿ       testcase( wx>0x7fffffff );æ      width = wx & 0x7fffffff;•    }∑    assert( width>=0 );Ÿ$#ifdef SQLITE_PRINTF_PRECISION_LIMITŸ.    if( width>SQLITE_PRINTF_PRECISION_LIMIT ){Ÿ,      width = SQLITE_PRINTF_PRECISION_LIMIT;•    }¶#endif†ª    /* Get the precision */±    if( c=='.' ){±      c = *++fmt;≥      if( c=='*' ){∑        if( bArgList ){Ÿ/          precision = (int)getIntArg(pArgList);Æ        }else{Ÿ%          precision = va_arg(ap,int);©        }≥        c = *++fmt;∫        if( precision<0 ){ŸA          precision = precision >= -2147483647 ? -precision : -1;©        }¨      }else{∏        unsigned px = 0;Ÿ"        while( c>='0' && c<='9' ){ø          px = px*10 + c - '0';µ          c = *++fmt;©        }Ÿ"        testcase( px>0x7fffffff );Ÿ$        precision = px & 0x7fffffff;ß      }™    }else{µ      precision = -1;•    }æ    assert( precision>=(-1) );Ÿ$#ifdef SQLITE_PRINTF_PRECISION_LIMITŸ2    if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){Ÿ0      precision = SQLITE_PRINTF_PRECISION_LIMIT;•    }¶#endif††Ÿ*    /* Get the conversion type modifier */±    if( c=='l' ){¥      flag_long = 1;±      c = *++fmt;≥      if( c=='l' ){∂        flag_long = 2;≥        c = *++fmt;ß      }™    }else{¥      flag_long = 0;•    }Ÿ,    /* Fetch the info entry for the field */∏    infop = &fmtinfo[0];∂    xtype = etINVALID;Ÿ.    for(idx=0; idx<ArraySize(fmtinfo); idx++){Ÿ$      if( c==fmtinfo[idx].fmttype ){æ        infop = &fmtinfo[idx];º        xtype = infop->type;Æ        break;ß      }•    }†¶    /*Ÿ;    ** At this point, variables are initialized as follows:¶    **Ÿ>    **   flag_alternateform          TRUE if a '#' is present.Ÿ>    **   flag_altform2               TRUE if a '!' is present.Ÿ7    **   flag_prefix                 '+' or ' ' or zeroŸG    **   flag_leftjustify            TRUE if a '-' is present or if theŸ>    **                               field width was negative.ŸD    **   flag_zeropad                TRUE if the width began with 0.Ÿ:    **   flag_long                   1 for "l", 2 for "ll"ŸH    **   width                       The specified field width.  This isŸO    **                               always non-negative.  Zero is the default.ŸJ    **   precision                   The specified precision.  The defaultŸ+    **                               is -1.ŸA    **   xtype                       The class of the conversion.ŸL    **   infop                       Pointer to the appropriate info struct.¶    */¥    switch( xtype ){µ      case etPOINTER:Ÿ4        flag_long = sizeof(char*)==sizeof(i64) ? 2 :Ÿ=                     sizeof(char*)==sizeof(long int) ? 1 : 0;Ÿ-        /* Fall through into the next case */µ      case etORDINAL:π      case etRADIX:      ∂        cThousand = 0;Ÿ-        /* Fall through into the next case */µ      case etDECIMAL:Ÿ)        if( infop->flags & FLAG_SIGNED ){∞          i64 v;π          if( bArgList ){Ÿ$            v = getIntArg(pArgList);Ÿ           }else if( flag_long ){ø            if( flag_long==2 ){Ÿ"              v = va_arg(ap,i64) ;≤            }else{Ÿ&              v = va_arg(ap,long int);≠            }∞          }else{ø            v = va_arg(ap,int);´          }¥          if( v<0 ){Ÿ$            if( v==SMALLEST_INT64 ){Ÿ'              longvalue = ((u64)1)<<63;≤            }else{Ω              longvalue = -v;≠            }π            prefix = '-';∞          }else{∫            longvalue = v;Ÿ!            prefix = flag_prefix;´          }Æ        }else{π          if( bArgList ){Ÿ1            longvalue = (u64)getIntArg(pArgList);Ÿ           }else if( flag_long ){ø            if( flag_long==2 ){Ÿ)              longvalue = va_arg(ap,u64);≤            }else{Ÿ7              longvalue = va_arg(ap,unsigned long int);≠            }∞          }else{Ÿ0            longvalue = va_arg(ap,unsigned int);´          }µ          prefix = 0;©        }Ÿ2        if( longvalue==0 ) flag_alternateform = 0;Ÿ:        if( flag_zeropad && precision<width-(prefix!=0) ){Ÿ(          precision = width-(prefix!=0);©        }Ÿ1        if( precision<etBUFSIZE-10-etBUFSIZE/3 ){ª          nOut = etBUFSIZE;µ          zOut = buf;Æ        }else{Ÿ4          u64 n = (u64)precision + 10 + precision/3;Ÿ-          zOut = zExtra = sqlite3Malloc( n );∏          if( zOut==0 ){Ÿ5            setStrAccumError(pAccum, STRACCUM_NOMEM);≥            return;´          }∏          nOut = (int)n;©        }æ        bufpt = &zOut[nOut-1];ø        if( xtype==etORDINAL ){Ÿ0          static const char zOrd[] = "thstndrd";Ÿ(          int x = (int)(longvalue % 10);Ÿ-          if( x>=4 || (longvalue/10)%10==1 ){≤            x = 0;´          }Ÿ#          *(--bufpt) = zOrd[x*2+1];Ÿ!          *(--bufpt) = zOrd[x*2];©        }©        {Ÿ6          const char *cset = &aDigits[infop->charset];Ÿ           u8 base = infop->base;ŸN          do{                                           /* Convert to ascii */Ÿ.            *(--bufpt) = cset[longvalue%base];Ÿ'            longvalue = longvalue/base;Ÿ           }while( longvalue>0 );©        }Ÿ,        length = (int)(&zOut[nOut-1]-bufpt);Ÿ"        while( precision>length ){ŸF          *(--bufpt) = '0';                             /* Zero pad */≥          length++;©        }∏        if( cThousand ){ŸA          int nn = (length - 1)/3;  /* Number of "," to insert */Ÿ&          int ix = (length - 1)%3 + 1;∂          bufpt -= nn;Ÿ"          for(idx=0; nn>0; idx++){Ÿ'            bufpt[idx] = bufpt[idx+nn];±            ix--;∏            if( ix==0 ){Ÿ'              bufpt[++idx] = cThousand;≥              nn--;µ              ix = 3;≠            }´          }©        }ŸF        if( prefix ) *(--bufpt) = prefix;               /* Add sign */ŸM        if( flag_alternateform && infop->prefix ){      /* Add "0" or "0x" */∫          const char *pre;±          char x;Ÿ(          pre = &aPrefix[infop->prefix];Ÿ5          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;©        }Ÿ,        length = (int)(&zOut[nOut-1]-bufpt);Æ        break;≥      case etFLOAT:±      case etEXP:µ      case etGENERIC:∑        if( bArgList ){Ÿ-          realvalue = getDoubleArg(pArgList);Æ        }else{Ÿ(          realvalue = va_arg(ap,double);©        }Ÿ!#ifdef SQLITE_OMIT_FLOATING_POINT≥        length = 0;•#elseŸL        if( precision<0 ) precision = 6;         /* Set default precision */º        if( realvalue<0.0 ){Ÿ!          realvalue = -realvalue;∑          prefix = '-';Æ        }else{ø          prefix = flag_prefix;©        }Ÿ:        if( xtype==etGENERIC && precision>0 ) precision--;Ÿ$        testcase( precision>0xfff );ŸK        for(idx=precision&0xfff, rounder=0.5; idx>0; idx--, rounder*=0.1){}Ÿ2        if( xtype==etFLOAT ) realvalue += rounder;ŸC        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */∞        exp = 0;Ÿ.        if( sqlite3IsNaN((double)realvalue) ){∏          bufpt = "NaN";µ          length = 3;∞          break;©        }º        if( realvalue>0.0 ){Ÿ&          LONGDOUBLE_TYPE scale = 1.0;ŸP          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}ŸO          while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }ŸM          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }Ω          realvalue /= scale;Ÿ>          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }Ÿ=          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }∏          if( exp>350 ){∏            bufpt = buf;º            buf[0] = prefix;Ÿ,            memcpy(buf+(prefix!=0),"Inf",4);Ÿ#            length = 3+(prefix!=0);≤            break;´          }©        }¥        bufpt = buf;™        /*ŸG        ** If the field type is etGENERIC, then convert to either etEXPŸ&        ** or etFLOAT, as appropriate.™        */Ω        if( xtype!=etFLOAT ){ø          realvalue += rounder;Ÿ;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }©        }ø        if( xtype==etGENERIC ){Ÿ)          flag_rtz = !flag_alternateform;Ÿ(          if( exp<-4 || exp>precision ){∫            xtype = etEXP;∞          }else{Ÿ(            precision = precision - exp;º            xtype = etFLOAT;´          }Æ        }else{Ÿ#          flag_rtz = flag_altform2;©        }ª        if( xtype==etEXP ){±          e2 = 0;Æ        }else{≥          e2 = exp;©        }ŸC        if( MAX(e2,0)+(i64)precision+(i64)width > etBUFSIZE - 15 ){π          bufpt = zExtra ŸH              = sqlite3Malloc( MAX(e2,0)+(i64)precision+(i64)width+15 );π          if( bufpt==0 ){Ÿ5            setStrAccumError(pAccum, STRACCUM_NOMEM);≥            return;´          }©        }µ        zOut = bufpt;Ÿ$        nsd = 16 + flag_altform2*10;ŸJ        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;Ÿ-        /* The sign in front of the number */µ        if( prefix ){æ          *(bufpt++) = prefix;©        }Ÿ/        /* Digits prior to the decimal point */≥        if( e2<0 ){ª          *(bufpt++) = '0';Æ        }else{Ω          for(; e2>=0; e2--){Ÿ6            *(bufpt++) = et_getdigit(&realvalue,&nsd);´          }©        }ø        /* The decimal point */∂        if( flag_dp ){ª          *(bufpt++) = '.';©        }ŸB        /* "0" digits after the decimal point but before the firstŸ-        ** significant digit of the number */Ÿ+        for(e2++; e2<0; precision--, e2++){Ÿ           assert( precision>0 );ª          *(bufpt++) = '0';©        }Ÿ8        /* Significant digits after the decimal point */Ÿ!        while( (precision--)>0 ){Ÿ4          *(bufpt++) = et_getdigit(&realvalue,&nsd);©        }ŸK        /* Remove trailing zeros and the "." if no digits follow the "." */Ÿ"        if( flag_rtz && flag_dp ){Ÿ1          while( bufpt[-1]=='0' ) *(--bufpt) = 0;ø          assert( bufpt>zOut );ø          if( bufpt[-1]=='.' ){Ÿ             if( flag_altform2 ){ø              *(bufpt++) = '0';≤            }else{Ω              *(--bufpt) = 0;≠            }´          }©        }Ÿ#        /* Add the "eNNN" suffix */ª        if( xtype==etEXP ){Ÿ/          *(bufpt++) = aDigits[infop->charset];∂          if( exp<0 ){Ÿ)            *(bufpt++) = '-'; exp = -exp;∞          }else{Ω            *(bufpt++) = '+';´          }π          if( exp>=100 ){ŸH            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */∑            exp %= 100;´          }ŸG          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */ŸF          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */©        }≥        *bufpt = 0;†ŸK        /* The converted number is in buf[] and zero terminated. Output it.ŸK        ** Note that the number is in the usual order, not reversed as withŸ"        ** integer conversions. */Ÿ#        length = (int)(bufpt-zOut);µ        bufpt = zOut;†ŸG        /* Special case:  Add leading zeros if the flag_zeropad flag isŸ/        ** set and we are not left justified */ŸA        if( flag_zeropad && !flag_leftjustify && length < width){∞          int i;Ÿ$          int nPad = width - length;Ÿ%          for(i=width; i>=nPad; i--){Ÿ%            bufpt[i] = bufpt[i-nPad];´          }∏          i = prefix!=0;Ÿ+          while( nPad-- ) bufpt[i++] = '0';π          length = width;©        }Ÿ1#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */Æ        break;≤      case etSIZE:∏        if( !bArgList ){Ÿ-          *(va_arg(ap,int*)) = pAccum->nChar;©        }ª        length = width = 0;Æ        break;µ      case etPERCENT:µ        buf[0] = '%';¥        bufpt = buf;≥        length = 1;Æ        break;≥      case etCHARX:∑        if( bArgList ){Ÿ'          bufpt = getTextArg(pArgList);µ          length = 1;∂          if( bufpt ){Ÿ$            buf[0] = c = *(bufpt++);Ÿ!            if( (c&0xc0)==0xc0 ){Ÿ9              while( length<4 && (bufpt[0]&0xc0)==0x80 ){Ÿ+                buf[length++] = *(bufpt++);Ø              }≠            }∞          }else{∑            buf[0] = 0;´          }Æ        }else{Ÿ4          unsigned int ch = va_arg(ap,unsigned int);ª          if( ch<0x00080 ){ø            buf[0] = ch & 0xff;∑            length = 1;Ÿ!          }else if( ch<0x00800 ){Ÿ/            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);Ÿ,            buf[1] = 0x80 + (u8)(ch & 0x3f);∑            length = 2;Ÿ!          }else if( ch<0x10000 ){Ÿ0            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);Ÿ1            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);Ÿ,            buf[2] = 0x80 + (u8)(ch & 0x3f);∑            length = 3;∞          }else{Ÿ2            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);Ÿ2            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);Ÿ1            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);Ÿ,            buf[3] = 0x80 + (u8)(ch & 0x3f);∑            length = 4;´          }©        }∫        if( precision>1 ){ø          width -= precision-1;Ÿ-          if( width>1 && !flag_leftjustify ){Ÿ4            sqlite3AppendChar(pAccum, width-1, ' ');∂            width = 0;´          }Ÿ#          while( precision-- > 1 ){Ÿ7            sqlite3StrAccumAppend(pAccum, buf, length);´          }©        }¥        bufpt = buf;∫        flag_altform2 = 1;Ÿ#        goto adjust_width_for_utf8;¥      case etSTRING:∑      case etDYNSTRING:∑        if( bArgList ){Ÿ'          bufpt = getTextArg(pArgList);ª          xtype = etSTRING;Æ        }else{Ÿ#          bufpt = va_arg(ap,char*);©        }∑        if( bufpt==0 ){µ          bufpt = "";Ÿ'        }else if( xtype==etDYNSTRING ){ŸO          if( pAccum->nChar==0 && pAccum->mxAlloc && width==0 && precision<0 ){ŸA            /* Special optimization for sqlite3_mprintf("%z..."):ŸH            ** Extend an existing memory allocation rather than creatingº            ** a new one. */ŸF            assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );Ÿ"            pAccum->zText = bufpt;ŸD            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);Ÿ<            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);Ÿ:            pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;∑            length = 0;≤            break;´          }π          zExtra = bufpt;©        }ª        if( precision>=0 ){æ          if( flag_altform2 ){ŸK            /* Set length to the number of bytes needed in order to displayŸ&            ** precision characters */Ÿ5            unsigned char *z = (unsigned char*)bufpt;Ÿ-            while( precision-- > 0 && z[0] ){Ÿ"              SQLITE_SKIP_UTF8(z);≠            }Ÿ6            length = (int)(z - (unsigned char*)bufpt);∞          }else{ŸH            for(length=0; length<precision && bufpt[length]; length++){}´          }Æ        }else{Ÿ3          length = 0x7fffffff & (int)strlen(bufpt);©        }º      adjust_width_for_utf8:Ÿ'        if( flag_altform2 && width>0 ){ŸK          /* Adjust width to account for extra bytes in UTF-8 characters */æ          int ii = length - 1;ŸB          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;©        }Æ        break;Ÿ?      case etSQLESCAPE:           /* %q: Escape ' characters */ŸI      case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */Ÿ?      case etSQLESCAPE3: {        /* %w: Escape " characters */ø        int i, j, k, n, isnull;∂        int needQuote;∞        char ch;ŸJ        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */µ        char *escarg;†∑        if( bArgList ){Ÿ(          escarg = getTextArg(pArgList);Æ        }else{Ÿ$          escarg = va_arg(ap,char*);©        }ª        isnull = escarg==0;ŸH        if( isnull ) escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");ŸF        /* For %q, %Q, and %w, the precision is the number of byte (orŸG        ** characters if the ! flags is present) to use from the input.ŸG        ** Because of the extra quoting characters inserted, the numberŸA        ** of output characters may be larger than the precision.™        */∂        k = precision;Ÿ8        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){ª          if( ch==q )  n++;Ÿ1          if( flag_altform2 && (ch&0xc0)==0xc0 ){Ÿ5            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }´          }©        }Ÿ3        needQuote = !isnull && xtype==etSQLESCAPE2;≥        n += i + 3;∫        if( n>etBUFSIZE ){Ÿ.          bufpt = zExtra = sqlite3Malloc( n );π          if( bufpt==0 ){Ÿ5            setStrAccumError(pAccum, STRACCUM_NOMEM);≥            return;´          }Æ        }else{∂          bufpt = buf;©        }Æ        j = 0;Ÿ'        if( needQuote ) bufpt[j++] = q;Æ        k = i;ª        for(i=0; i<k; i++){Ÿ&          bufpt[j++] = ch = escarg[i];Ÿ&          if( ch==q ) bufpt[j++] = ch;©        }Ÿ'        if( needQuote ) bufpt[j++] = q;µ        bufpt[j] = 0;≥        length = j;Ÿ#        goto adjust_width_for_utf8;ß      }µ      case etTOKEN: {∂        Token *pToken;ŸG        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;Ÿ$        pToken = va_arg(ap, Token*);æ        assert( bArgList==0 );Ÿ"        if( pToken && pToken->n ){ŸK          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);©        }ª        length = width = 0;Æ        break;ß      }∑      case etSRCLIST: {∂        SrcList *pSrc;Æ        int k;Ÿ#        struct SrcList_item *pItem;ŸG        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;Ÿ$        pSrc = va_arg(ap, SrcList*);º        k = va_arg(ap, int);º        pItem = &pSrc->a[k];æ        assert( bArgList==0 );Ÿ'        assert( k>=0 && k<pSrc->nSrc );ø        if( pItem->zDatabase ){Ÿ=          sqlite3StrAccumAppendAll(pAccum, pItem->zDatabase);Ÿ0          sqlite3StrAccumAppend(pAccum, ".", 1);©        }Ÿ7        sqlite3StrAccumAppendAll(pAccum, pItem->zName);ª        length = width = 0;Æ        break;ß      }∞      default: {Ÿ#        assert( xtype==etINVALID );Ø        return;ß      }Ÿ*    }/* End switch over the format type */¶    /*ŸA    ** The text of the conversion is pointed to by "bufpt" and isŸA    ** "length" characters long.  The field width is "width".  DoŸG    ** the output.  Both length and width are in bytes, not characters,ŸH    ** at this point.  If the "!" flag was present on string conversionsŸM    ** indicating that width and precision should be expressed in characters,ŸI    ** then the values have been translated prior to reaching this point.¶    */¥    width -= length;≤    if( width>0 ){ŸD      if( !flag_leftjustify ) sqlite3AppendChar(pAccum, width, ' ');Ÿ3      sqlite3StrAccumAppend(pAccum, bufpt, length);ŸC      if( flag_leftjustify ) sqlite3AppendChar(pAccum, width, ' ');™    }else{Ÿ3      sqlite3StrAccumAppend(pAccum, bufpt, length);•    }†±    if( zExtra ){Ÿ(      sqlite3DbFree(pAccum->db, zExtra);±      zExtra = 0;•    }Ÿ,  }/* End for loop over the format string */∑} /* End of function */†¢/*ŸC** Enlarge the memory allocation on a StrAccum object so that it isŸ0** able to accept at least N more bytes of text.¢**ŸE** Return the number of bytes of text that StrAccum is able to acceptŸF** after the attempted enlargement.  The value returned might be zero.¢*/Ÿ6static int sqlite3StrAccumEnlarge(StrAccum *p, int N){≠  char *zNew;ŸL  assert( p->nChar+(i64)N >= p->nAlloc ); /* Only called if really needed */¥  if( p->accError ){Ÿ+    testcase(p->accError==STRACCUM_TOOBIG);Ÿ*    testcase(p->accError==STRACCUM_NOMEM);≠    return 0;£  }∂  if( p->mxAlloc==0 ){Ÿ!    N = p->nAlloc - p->nChar - 1;Ÿ)    setStrAccumError(p, STRACCUM_TOOBIG);≠    return N;®  }else{Ÿ.    char *zOld = isMalloced(p) ? p->zText : 0;π    i64 szNew = p->nChar;≥    szNew += N + 1;Ÿ%    if( szNew+p->nChar<=p->mxAlloc ){ŸN      /* Force exponential buffer size growth as long as it does not overflow,Ÿ:      ** to avoid having to call this routine too often */∏      szNew += p->nChar;•    }Ω    if( szNew > p->mxAlloc ){æ      sqlite3StrAccumReset(p);Ÿ+      setStrAccumError(p, STRACCUM_TOOBIG);Ø      return 0;™    }else{Ω      p->nAlloc = (int)szNew;•    }∞    if( p->db ){Ÿ6      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);™    }else{Ÿ0      zNew = sqlite3_realloc64(zOld, p->nAlloc);•    }Ø    if( zNew ){Ÿ+      assert( p->zText!=0 || p->nChar==0 );ŸJ      if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);∂      p->zText = zNew;Ÿ3      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);Ÿ/      p->printfFlags |= SQLITE_PRINTF_MALLOCED;™    }else{æ      sqlite3StrAccumReset(p);Ÿ*      setStrAccumError(p, STRACCUM_NOMEM);Ø      return 0;•    }£  }´  return N;°}†¢/*Ÿ=** Append N copies of character c to the given string buffer.¢*/ŸBSQLITE_PRIVATE void sqlite3AppendChar(StrAccum *p, int N, char c){Ÿ-  testcase( p->nChar + (i64)N > 0x7fffffff );ŸN  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){´    return;£  }Ÿ,  while( (N--)>0 ) p->zText[p->nChar++] = c;°}†¢/*ŸE** The StrAccum "p" is not large enough to accept N new bytes of z[].Ÿ+** So enlarge if first, then do the append.¢**ŸM** This is a helper routine to sqlite3StrAccumAppend() that does special-caseŸ@** work (enlarging the buffer) using tail recursion, so that theŸB** sqlite3StrAccumAppend() routine can use fast calling semantics.¢*/ŸPstatic void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){Ÿ#  N = sqlite3StrAccumEnlarge(p, N);¨  if( N>0 ){Ÿ&    memcpy(&p->zText[p->nChar], z, N);≤    p->nChar += N;£  }°}†¢/*ŸF** Append N bytes of text from z to the StrAccum object.  Increase theŸ;** size of the memory allocation for StrAccum if necessary.¢*/ŸMSQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){π  assert( z!=0 || N==0 );Ÿ6  assert( p->zText!=0 || p->nChar==0 || p->accError );±  assert( N>=0 );Ÿ+  assert( p->accError==0 || p->nAlloc==0 );Ÿ   if( p->nChar+N >= p->nAlloc ){º    enlargeAndAppend(p,z,N);∞  }else if( N ){∑    assert( p->zText );≤    p->nChar += N;Ÿ(    memcpy(&p->zText[p->nChar-N], z, N);£  }°}†¢/*ŸJ** Append the complete text of zero-terminated string z[] to the p string.¢*/ŸISQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum *p, const char *z){Ÿ2  sqlite3StrAccumAppend(p, z, sqlite3Strlen30(z));°}††¢/*Ÿ<** Finish off a string by making sure it is zero-terminated.Ÿ;** Return a pointer to the resulting string.  Return a NULLŸ0** pointer if any kind of error was encountered.¢*/Ÿ@static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){Æ  char *zText;Ÿ+  assert( p->mxAlloc>0 && !isMalloced(p) );Ÿ1  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );Æ  if( zText ){Ÿ(    memcpy(zText, p->zText, p->nChar+1);Ÿ-    p->printfFlags |= SQLITE_PRINTF_MALLOCED;®  }else{Ÿ(    setStrAccumError(p, STRACCUM_NOMEM);£  }≥  p->zText = zText;Ø  return zText;°}Ÿ8SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){±  if( p->zText ){ª    p->zText[p->nChar] = 0;Ÿ)    if( p->mxAlloc>0 && !isMalloced(p) ){Ÿ&      return strAccumFinishRealloc(p);•    }£  }≤  return p->zText;°}†¢/*Ÿ:** Reset an StrAccum string.  Reclaim all malloced memory.¢*/Ÿ6SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum *p){∂  if( isMalloced(p) ){Ÿ#    sqlite3DbFree(p->db, p->zText);Ÿ.    p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;£  }Ø  p->zText = 0;°}†¢/*Ÿ#** Initialize a string accumulator.¢**Ÿ,** p:     The accumulator to be initialized.ŸD** db:    Pointer to a database connection.  May be NULL.  LookasideŸK**        memory is used if not NULL. db->mallocFailed is set appropriately∏**        when not NULL.ŸJ** zBase: An initial buffer.  May be NULL in which case the initial buffer∂**        is malloced.ŸK** n:     Size of zBase in bytes.  If total space requirements never exceedŸ2**        n then no memory allocations ever occur.ŸI** mx:    Maximum number of bytes to accumulate.  If mx==0 then no memoryŸ&**        allocations will ever occur.¢*/Ÿ^SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){≥  p->zText = zBase;≠  p->db = db;∞  p->nAlloc = n;≤  p->mxAlloc = mx;Ø  p->nChar = 0;≤  p->accError = 0;µ  p->printfFlags = 0;°}†¢/*ŸD** Print into memory obtained from sqliteMalloc().  Use the internalª** %-conversion extensions.¢*/ŸSSQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){™  char *z;Ÿ$  char zBase[SQLITE_PRINT_BUF_SIZE];Ø  StrAccum acc;≤  assert( db!=0 );Ÿ5  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),Ÿ7                      db->aLimit[SQLITE_LIMIT_LENGTH]);Ÿ+  acc.printfFlags = SQLITE_PRINTF_INTERNAL;Ÿ%  sqlite3VXPrintf(&acc, zFormat, ap);Ÿ"  z = sqlite3StrAccumFinish(&acc);Ÿ%  if( acc.accError==STRACCUM_NOMEM ){∏    sqlite3OomFault(db);£  }´  return z;°}†¢/*ŸD** Print into memory obtained from sqliteMalloc().  Use the internalª** %-conversion extensions.¢*/ŸKSQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){≠  va_list ap;™  char *z;∏  va_start(ap, zFormat);Ÿ'  z = sqlite3VMPrintf(db, zFormat, ap);≠  va_end(ap);´  return z;°}†¢/*ŸG** Print into memory obtained from sqlite3_malloc().  Omit the internalª** %-conversion extensions.¢*/ŸCSQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){™  char *z;Ÿ$  char zBase[SQLITE_PRINT_BUF_SIZE];Ø  StrAccum acc;†Ÿ #ifdef SQLITE_ENABLE_API_ARMOR  ≥  if( zFormat==0 ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸH  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);Ÿ%  sqlite3VXPrintf(&acc, zFormat, ap);Ÿ"  z = sqlite3StrAccumFinish(&acc);´  return z;°}†¢/*ŸI** Print into memory obtained from sqlite3_malloc()().  Omit the internalª** %-conversion extensions.¢*/Ÿ;SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){≠  va_list ap;™  char *z;º#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endif∏  va_start(ap, zFormat);Ÿ$  z = sqlite3_vmprintf(zFormat, ap);≠  va_end(ap);´  return z;°}†¢/*ŸF** sqlite3_snprintf() works like snprintf() except that it ignores theŸD** current locale settings.  This is important for SQLite because weŸD** are not able to use a "," as the decimal point in place of "." asΩ** specified by some locales.¢**ŸE** Oops:  The first two arguments of sqlite3_snprintf() are backwardsŸI** from the snprintf() standard.  Unfortunately, it is too late to changeŸH** this without breaking compatibility, so we just have to live with the´** mistake.¢**Ÿ.** sqlite3_vsnprintf() is the varargs version.¢*/ŸWSQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){Ø  StrAccum acc;π  if( n<=0 ) return zBuf;æ#ifdef SQLITE_ENABLE_API_ARMORø  if( zBuf==0 || zFormat==0 ) {Ω    (void)SQLITE_MISUSE_BKPT;ª    if( zBuf ) zBuf[0] = 0;∞    return zBuf;£  }¶#endifŸ+  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);Ÿ%  sqlite3VXPrintf(&acc, zFormat, ap);∂  zBuf[acc.nChar] = 0;Æ  return zBuf;°}ŸOSQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){™  char *z;≠  va_list ap;∑  va_start(ap,zFormat);Ÿ.  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);≠  va_end(ap);´  return z;°}†¢/*ŸG** This is the routine that actually formats the sqlite3_log() message.ŸF** We house it in a separate routine from sqlite3_log() to avoid usingŸ?** stack space on small-stack systems when logging is disabled.¢**ŸI** sqlite3_log() must render into a static buffer.  It cannot dynamicallyŸH** allocate memory because it might be called while the memory allocator±** mutex is held.¢**ŸE** sqlite3VXPrintf() might ask for *temporary* memory allocations forŸI** certain format characters (%q) or for very large precisions or widths.ŸG** Care must be taken that any sqlite3_log() calls that occur while theŸ4** memory mutex is held do not use these mechanisms.¢*/ŸHstatic void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){ŸA  StrAccum acc;                          /* String accumulator */ŸC  char zMsg[SQLITE_PRINT_BUF_SIZE*3];    /* Complete log message */†Ÿ6  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);Ÿ%  sqlite3VXPrintf(&acc, zFormat, ap);ŸA  sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,Ÿ8                           sqlite3StrAccumFinish(&acc));°}†¢/*Ÿ?** Format and write a message to the log if logging is enabled.¢*/ŸDSQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){Ÿ;  va_list ap;                             /* Vararg list */Ÿ!  if( sqlite3GlobalConfig.xLog ){∫    va_start(ap, zFormat);Ÿ(    renderLogMsg(iErrCode, zFormat, ap);Ø    va_end(ap);£  }°}†Ÿ:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)¢/*ŸD** A version of printf() that understands %lld.  Used for debugging.ŸL** The printf() built into some versions of windows does not understand %lldŸ0** and segfaults if you give it a long long int.¢*/ŸASQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){≠  va_list ap;Ø  StrAccum acc;±  char zBuf[500];Ÿ6  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);∑  va_start(ap,zFormat);Ÿ%  sqlite3VXPrintf(&acc, zFormat, ap);≠  va_end(ap);æ  sqlite3StrAccumFinish(&acc);ª#ifdef SQLITE_OS_TRACE_PROC£  {ŸA    extern void SQLITE_OS_TRACE_PROC(const char *zBuf, int nBuf);Ÿ-    SQLITE_OS_TRACE_PROC(zBuf, sizeof(zBuf));£  }•#elseΩ  fprintf(stdout,"%s", zBuf);±  fflush(stdout);¶#endif°}¶#endif††¢/*ŸK** variable-argument wrapper around sqlite3VXPrintf().  The bFlags argumentŸF** can contain the bit SQLITE_PRINTF_INTERNAL enable internal formats.¢*/ŸJSQLITE_PRIVATE void sqlite3XPrintf(StrAccum *p, const char *zFormat, ...){≠  va_list ap;∑  va_start(ap,zFormat);Ÿ"  sqlite3VXPrintf(p, zFormat, ap);≠  va_end(ap);°}†ŸO/************** End of printf.c **********************************************/ŸO/************** Begin file treeview.c ****************************************/¢/*≠** 2015-06-08¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸJ** This file contains C code to implement the TreeView debugging routines.ŸI** These routines print a parse tree to standard output for debugging and≠** analysis. ¢**Ÿ?** The interfaces in this file is only available when compilingµ** with SQLITE_DEBUG.¢*/º/* #include "sqliteInt.h" */≥#ifdef SQLITE_DEBUG†¢/*ŸL** Add a new subitem to the tree.  The moreToFollow flag indicates that thisŸ$** is not the last item in the tree.¢*/ŸCstatic TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow){≠  if( p==0 ){Ÿ'    p = sqlite3_malloc64( sizeof(*p) );∏    if( p==0 ) return 0;Ω    memset(p, 0, sizeof(*p));®  }else{∞    p->iLevel++;£  }Ÿ/  assert( moreToFollow==0 || moreToFollow==1 );ŸF  if( p->iLevel<sizeof(p->bLine) ) p->bLine[p->iLevel] = moreToFollow;´  return p;°}†¢/*Ÿ&** Finished with one layer of the tree¢*/Ÿ,static void sqlite3TreeViewPop(TreeView *p){¥  if( p==0 ) return;Æ  p->iLevel--;Ÿ$  if( p->iLevel<0 ) sqlite3_free(p);°}†¢/*ŸM** Generate a single line of output for the tree, with a prefix that containsŸ!** all the appropriate tree lines¢*/ŸGstatic void sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...){≠  va_list ap;®  int i;Ø  StrAccum acc;±  char zBuf[500];Ÿ6  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);™  if( p ){Ÿ7    for(i=0; i<p->iLevel && i<sizeof(p->bLine)-1; i++){ŸD      sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|   " : "    ", 4);•    }ŸB    sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|-- " : "'-- ", 4);£  }∏  va_start(ap, zFormat);Ÿ%  sqlite3VXPrintf(&acc, zFormat, ap);≠  va_end(ap);∏  assert( acc.nChar>0 );ŸE  if( zBuf[acc.nChar-1]!='\n' ) sqlite3StrAccumAppend(&acc, "\n", 1);æ  sqlite3StrAccumFinish(&acc);Ω  fprintf(stdout,"%s", zBuf);±  fflush(stdout);°}†¢/*ŸI** Shorthand for starting a new tree item that consists of a single label¢*/ŸPstatic void sqlite3TreeViewItem(TreeView *p, const char *zLabel,u8 moreFollows){Ÿ*  p = sqlite3TreeViewPush(p, moreFollows);Ÿ'  sqlite3TreeViewLine(p, "%s", zLabel);°}†¢/*Ÿ:** Generate a human-readable description of a WITH clause.¢*/Ÿ]SQLITE_PRIVATE void sqlite3TreeViewWith(TreeView *pView, const With *pWith, u8 moreToFollow){®  int i;∏  if( pWith==0 ) return;æ  if( pWith->nCte==0 ) return;∂  if( pWith->pOuter ){ŸO    sqlite3TreeViewLine(pView, "WITH (0x%p, pOuter=0x%p)",pWith,pWith->pOuter);®  }else{Ÿ5    sqlite3TreeViewLine(pView, "WITH (0x%p)", pWith);£  }∂  if( pWith->nCte>0 ){Ÿ*    pView = sqlite3TreeViewPush(pView, 1);Ÿ!    for(i=0; i<pWith->nCte; i++){±      StrAccum x;∑      char zLine[1000];Ÿ,      const struct Cte *pCte = &pWith->a[i];Ÿ:      sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);Ÿ,      sqlite3XPrintf(&x, "%s", pCte->zName);Ÿ0      if( pCte->pCols && pCte->pCols->nExpr>0 ){∏        char cSep = '(';Æ        int j;Ÿ,        for(j=0; j<pCte->pCols->nExpr; j++){ŸD          sqlite3XPrintf(&x, "%c%s", cSep, pCte->pCols->a[j].zName);µ          cSep = ',';©        }Ÿ         sqlite3XPrintf(&x, ")");ß      }Ÿ       sqlite3XPrintf(&x, " AS");Ÿ       sqlite3StrAccumFinish(&x);Ÿ9      sqlite3TreeViewItem(pView, zLine, i<pWith->nCte-1);Ÿ5      sqlite3TreeViewSelect(pView, pCte->pSelect, 0);Ÿ       sqlite3TreeViewPop(pView);•    }æ    sqlite3TreeViewPop(pView);£  }°}††¢/*Ÿ<** Generate a human-readable description of a Select object.¢*/Ÿ]SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){¨  int n = 0;Æ  int cnt = 0;≠  if( p==0 ){Ÿ-    sqlite3TreeViewLine(pView, "nil-SELECT");´    return;§  } Ÿ3  pView = sqlite3TreeViewPush(pView, moreToFollow);±  if( p->pWith ){Ÿ,    sqlite3TreeViewWith(pView, p->pWith, 1);¨    cnt = 1;Ÿ"    sqlite3TreeViewPush(pView, 1);£  }•  do{∑#if SELECTTRACE_ENABLEDæ    sqlite3TreeViewLine(pView,Ÿ7      "SELECT%s%s (%s/%p) selFlags=0x%x nSelectRow=%d",Ÿ7      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),Ÿ8      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""),Ÿ"      p->zSelName, p, p->selFlags,∏      (int)p->nSelectRow¶    );•#elseŸO    sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p) selFlags=0x%x nSelectRow=%d",Ÿ7      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),ŸH      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p, p->selFlags,∏      (int)p->nSelectRow¶    );¶#endifŸ*    if( cnt++ ) sqlite3TreeViewPop(pView);¥    if( p->pPrior ){Ø      n = 1000;™    }else{¨      n = 0;Ÿ)      if( p->pSrc && p->pSrc->nSrc ) n++;∫      if( p->pWhere ) n++;º      if( p->pGroupBy ) n++;ª      if( p->pHaving ) n++;º      if( p->pOrderBy ) n++;∫      if( p->pLimit ) n++;•    }ŸE    sqlite3TreeViewExprList(pView, p->pEList, (n--)>0, "result-set");Ÿ#    if( p->pSrc && p->pSrc->nSrc ){¨      int i;Ÿ2      pView = sqlite3TreeViewPush(pView, (n--)>0);Ÿ)      sqlite3TreeViewLine(pView, "FROM");Ÿ%      for(i=0; i<p->pSrc->nSrc; i++){Ÿ4        struct SrcList_item *pItem = &p->pSrc->a[i];≥        StrAccum x;∏        char zLine[100];Ÿ<        sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);Ÿ5        sqlite3XPrintf(&x, "{%d,*}", pItem->iCursor);ø        if( pItem->zDatabase ){ŸG          sqlite3XPrintf(&x, " %s.%s", pItem->zDatabase, pItem->zName);Ÿ!        }else if( pItem->zName ){Ÿ2          sqlite3XPrintf(&x, " %s", pItem->zName);©        }∫        if( pItem->pTab ){Ÿ@          sqlite3XPrintf(&x, " tabname=%Q", pItem->pTab->zName);©        }º        if( pItem->zAlias ){Ÿ8          sqlite3XPrintf(&x, " (AS %s)", pItem->zAlias);©        }Ÿ+        if( pItem->fg.jointype & JT_LEFT ){Ÿ+          sqlite3XPrintf(&x, " LEFT-JOIN");©        }Ÿ"        sqlite3StrAccumFinish(&x);Ÿ>        sqlite3TreeViewItem(pView, zLine, i<p->pSrc->nSrc-1); Ω        if( pItem->pSelect ){Ÿ:          sqlite3TreeViewSelect(pView, pItem->pSelect, 0);©        }Ÿ"        if( pItem->fg.isTabFunc ){ŸN          sqlite3TreeViewExprList(pView, pItem->u1.pFuncArg, 0, "func-args:");©        }Ÿ"        sqlite3TreeViewPop(pView);ß      }Ÿ       sqlite3TreeViewPop(pView);•    }¥    if( p->pWhere ){Ÿ3      sqlite3TreeViewItem(pView, "WHERE", (n--)>0);Ÿ/      sqlite3TreeViewExpr(pView, p->pWhere, 0);Ÿ       sqlite3TreeViewPop(pView);•    }∂    if( p->pGroupBy ){ŸF      sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, "GROUPBY");•    }µ    if( p->pHaving ){Ÿ4      sqlite3TreeViewItem(pView, "HAVING", (n--)>0);Ÿ0      sqlite3TreeViewExpr(pView, p->pHaving, 0);Ÿ       sqlite3TreeViewPop(pView);•    }∂    if( p->pOrderBy ){ŸF      sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, "ORDERBY");•    }¥    if( p->pLimit ){Ÿ3      sqlite3TreeViewItem(pView, "LIMIT", (n--)>0);ŸI      sqlite3TreeViewExpr(pView, p->pLimit->pLeft, p->pLimit->pRight!=0);æ      if( p->pLimit->pRight ){Ÿ6        sqlite3TreeViewItem(pView, "OFFSET", (n--)>0);Ÿ9        sqlite3TreeViewExpr(pView, p->pLimit->pRight, 0);Ÿ"        sqlite3TreeViewPop(pView);ß      }Ÿ       sqlite3TreeViewPop(pView);•    }¥    if( p->pPrior ){Ÿ       const char *zOp = "UNION";∂      switch( p->op ){Ÿ7        case TK_ALL:         zOp = "UNION ALL";  break;Ÿ7        case TK_INTERSECT:   zOp = "INTERSECT";  break;Ÿ7        case TK_EXCEPT:      zOp = "EXCEPT";     break;ß      }Ÿ)      sqlite3TreeViewItem(pView, zOp, 1);•    }≤    p = p->pPrior;±  }while( p!=0 );º  sqlite3TreeViewPop(pView);°}†¢/*Ÿ?** Generate a human-readable explanation of an expression tree.¢*/Ÿ]SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){Ÿ1  const char *zBinOp = 0;   /* Binary operator */Ÿ0  const char *zUniOp = 0;   /* Unary operator */±  char zFlgs[60];Ÿ3  pView = sqlite3TreeViewPush(pView, moreToFollow);±  if( pExpr==0 ){Ÿ&    sqlite3TreeViewLine(pView, "nil");æ    sqlite3TreeViewPop(pView);´    return;£  }µ  if( pExpr->flags ){Ÿ.    if( ExprHasProperty(pExpr, EP_FromJoin) ){ŸB      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x iRJT=%d",Ÿ=                       pExpr->flags, pExpr->iRightJoinTable);™    }else{ŸH      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x",pExpr->flags);•    }®  }else{±    zFlgs[0] = 0;£  }∂  switch( pExpr->op ){π    case TK_AGG_COLUMN: {Ÿ0      sqlite3TreeViewLine(pView, "AGG{%d:%d}%s",Ÿ2            pExpr->iTable, pExpr->iColumn, zFlgs);¨      break;•    }µ    case TK_COLUMN: {º      if( pExpr->iTable<0 ){Ÿ=        /* This only happens when coding check constraints */ŸJ        sqlite3TreeViewLine(pView, "COLUMN(%d)%s", pExpr->iColumn, zFlgs);¨      }else{Ÿ/        sqlite3TreeViewLine(pView, "{%d:%d}%s",ŸC                             pExpr->iTable, pExpr->iColumn, zFlgs);ß      }¨      break;•    }∂    case TK_INTEGER: {Ÿ'      if( pExpr->flags & EP_IntValue ){Ÿ:        sqlite3TreeViewLine(pView, "%d", pExpr->u.iValue);¨      }else{Ÿ:        sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);ß      }¨      break;•    }Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINT¥    case TK_FLOAT: {Ÿ7      sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);¨      break;•    }¶#endifµ    case TK_STRING: {Ÿ7      sqlite3TreeViewLine(pView,"%Q", pExpr->u.zToken);¨      break;•    }≥    case TK_NULL: {Ÿ(      sqlite3TreeViewLine(pView,"NULL");¨      break;•    }∏    case TK_TRUEFALSE: {Ÿ       sqlite3TreeViewLine(pView,Ÿ:         sqlite3ExprTruthValue(pExpr) ? "TRUE" : "FALSE");¨      break;•    }Ÿ #ifndef SQLITE_OMIT_BLOB_LITERAL≥    case TK_BLOB: {Ÿ7      sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);¨      break;•    }¶#endif∑    case TK_VARIABLE: {Ÿ2      sqlite3TreeViewLine(pView,"VARIABLE(%s,%d)",Ÿ;                          pExpr->u.zToken, pExpr->iColumn);¨      break;•    }∑    case TK_REGISTER: {Ÿ?      sqlite3TreeViewLine(pView,"REGISTER(%d)", pExpr->iTable);¨      break;•    }±    case TK_ID: {Ÿ>      sqlite3TreeViewLine(pView,"ID \"%w\"", pExpr->u.zToken);¨      break;•    }∏#ifndef SQLITE_OMIT_CAST≥    case TK_CAST: {Ÿ;      /* Expressions of the form:   CAST(pLeft AS token) */Ÿ<      sqlite3TreeViewLine(pView,"CAST %Q", pExpr->u.zToken);Ÿ2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¨      break;•    }Ω#endif /* SQLITE_OMIT_CAST */Ÿ.    case TK_LT:      zBinOp = "LT";     break;Ÿ.    case TK_LE:      zBinOp = "LE";     break;Ÿ.    case TK_GT:      zBinOp = "GT";     break;Ÿ.    case TK_GE:      zBinOp = "GE";     break;Ÿ.    case TK_NE:      zBinOp = "NE";     break;Ÿ.    case TK_EQ:      zBinOp = "EQ";     break;Ÿ.    case TK_IS:      zBinOp = "IS";     break;Ÿ.    case TK_ISNOT:   zBinOp = "ISNOT";  break;Ÿ.    case TK_AND:     zBinOp = "AND";    break;Ÿ.    case TK_OR:      zBinOp = "OR";     break;Ÿ.    case TK_PLUS:    zBinOp = "ADD";    break;Ÿ.    case TK_STAR:    zBinOp = "MUL";    break;Ÿ.    case TK_MINUS:   zBinOp = "SUB";    break;Ÿ.    case TK_REM:     zBinOp = "REM";    break;Ÿ.    case TK_BITAND:  zBinOp = "BITAND"; break;Ÿ.    case TK_BITOR:   zBinOp = "BITOR";  break;Ÿ.    case TK_SLASH:   zBinOp = "DIV";    break;Ÿ.    case TK_LSHIFT:  zBinOp = "LSHIFT"; break;Ÿ.    case TK_RSHIFT:  zBinOp = "RSHIFT"; break;Ÿ.    case TK_CONCAT:  zBinOp = "CONCAT"; break;Ÿ.    case TK_DOT:     zBinOp = "DOT";    break;†Ÿ.    case TK_UMINUS:  zUniOp = "UMINUS"; break;Ÿ.    case TK_UPLUS:   zUniOp = "UPLUS";  break;Ÿ.    case TK_BITNOT:  zUniOp = "BITNOT"; break;Ÿ.    case TK_NOT:     zUniOp = "NOT";    break;Ÿ.    case TK_ISNULL:  zUniOp = "ISNULL"; break;Ÿ/    case TK_NOTNULL: zUniOp = "NOTNULL"; break;†¥    case TK_TRUTH: {¨      int x;º      const char *azOp[] = {Ÿ=         "IS-FALSE", "IS-TRUE", "IS-NOT-FALSE", "IS-NOT-TRUE"®      };Ÿ:      assert( pExpr->op2==TK_IS || pExpr->op2==TK_ISNOT );æ      assert( pExpr->pRight );Ÿ0      assert( pExpr->pRight->op==TK_TRUEFALSE );ŸJ      x = (pExpr->op2==TK_ISNOT)*2 + sqlite3ExprTruthValue(pExpr->pRight);∑      zUniOp = azOp[x];¨      break;•    }†≥    case TK_SPAN: {Ÿ=      sqlite3TreeViewLine(pView, "SPAN %Q", pExpr->u.zToken);Ÿ2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¨      break;•    }†∂    case TK_COLLATE: {Ÿ@      sqlite3TreeViewLine(pView, "COLLATE %Q", pExpr->u.zToken);Ÿ2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¨      break;•    }†π    case TK_AGG_FUNCTION:∑    case TK_FUNCTION: {Ÿ=      ExprList *pFarg;       /* List of function arguments */Ÿ1      if( ExprHasProperty(pExpr, EP_TokenOnly) ){≤        pFarg = 0;¨      }else{ø        pFarg = pExpr->x.pList;ß      }Ÿ'      if( pExpr->op==TK_AGG_FUNCTION ){Ÿ7        sqlite3TreeViewLine(pView, "AGG_FUNCTION%d %Q",Ÿ:                             pExpr->op2, pExpr->u.zToken);¨      }else{ŸC        sqlite3TreeViewLine(pView, "FUNCTION %Q", pExpr->u.zToken);ß      }≤      if( pFarg ){Ÿ4        sqlite3TreeViewExprList(pView, pFarg, 0, 0);ß      }¨      break;•    }º#ifndef SQLITE_OMIT_SUBQUERYµ    case TK_EXISTS: {ŸI      sqlite3TreeViewLine(pView, "EXISTS-expr flags=0x%x", pExpr->flags);Ÿ8      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);¨      break;•    }µ    case TK_SELECT: {ŸI      sqlite3TreeViewLine(pView, "SELECT-expr flags=0x%x", pExpr->flags);Ÿ8      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);¨      break;•    }±    case TK_IN: {Ÿ@      sqlite3TreeViewLine(pView, "IN flags=0x%x", pExpr->flags);Ÿ2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);Ÿ1      if( ExprHasProperty(pExpr, EP_xIsSelect) ){Ÿ:        sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);¨      }else{Ÿ=        sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);ß      }¨      break;•    }Ÿ!#endif /* SQLITE_OMIT_SUBQUERY */†¶    /*ª    **    x BETWEEN y AND z¶    **º    ** This is equivalent to¶    **∑    **    x>=y AND x<=z¶    **Ÿ#    ** X is stored in pExpr->pLeft.Ÿ/    ** Y is stored in pExpr->pList->a[0].pExpr.Ÿ/    ** Z is stored in pExpr->pList->a[1].pExpr.¶    */∂    case TK_BETWEEN: {æ      Expr *pX = pExpr->pLeft;Ÿ,      Expr *pY = pExpr->x.pList->a[0].pExpr;Ÿ,      Expr *pZ = pExpr->x.pList->a[1].pExpr;Ÿ,      sqlite3TreeViewLine(pView, "BETWEEN");Ÿ(      sqlite3TreeViewExpr(pView, pX, 1);Ÿ(      sqlite3TreeViewExpr(pView, pY, 1);Ÿ(      sqlite3TreeViewExpr(pView, pZ, 0);¨      break;•    }∂    case TK_TRIGGER: {ŸH      /* If the opcode is TK_TRIGGER, then the expression is a referenceŸE      ** to a column in the new.* or old.* pseudo-tables available toŸG      ** trigger programs. In this case Expr.iTable is set to 1 for theŸJ      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumnŸF      ** is set to the column of the pseudo-table to read, or to -1 toæ      ** read the rowid field.®      */Ÿ+      sqlite3TreeViewLine(pView, "%s(%d)", Ÿ9          pExpr->iTable ? "NEW" : "OLD", pExpr->iColumn);¨      break;•    }≥    case TK_CASE: {Ÿ)      sqlite3TreeViewLine(pView, "CASE");Ÿ2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);Ÿ;      sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);¨      break;•    }ª#ifndef SQLITE_OMIT_TRIGGER¥    case TK_RAISE: {Ÿ       const char *zType = "unk";Ÿ       switch( pExpr->affinity ){Ÿ7        case OE_Rollback:   zType = "rollback";  break;Ÿ7        case OE_Abort:      zType = "abort";     break;Ÿ7        case OE_Fail:       zType = "fail";      break;Ÿ7        case OE_Ignore:     zType = "ignore";    break;ß      }ŸI      sqlite3TreeViewLine(pView, "RAISE %s(%Q)", zType, pExpr->u.zToken);¨      break;•    }¶#endif¥    case TK_MATCH: {Ÿ3      sqlite3TreeViewLine(pView, "MATCH {%d:%d}%s",Ÿ@                          pExpr->iTable, pExpr->iColumn, zFlgs);Ÿ3      sqlite3TreeViewExpr(pView, pExpr->pRight, 0);¨      break;•    }µ    case TK_VECTOR: {ŸC      sqlite3TreeViewBareExprList(pView, pExpr->x.pList, "VECTOR");¨      break;•    }º    case TK_SELECT_COLUMN: {ŸE      sqlite3TreeViewLine(pView, "SELECT-COLUMN %d", pExpr->iColumn);Ÿ?      sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);¨      break;•    }∫    case TK_IF_NULL_ROW: {ŸB      sqlite3TreeViewLine(pView, "IF-NULL-ROW %d", pExpr->iTable);Ÿ2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¨      break;•    }Æ    default: {Ÿ5      sqlite3TreeViewLine(pView, "op=%d", pExpr->op);¨      break;•    }£  }Ø  if( zBinOp ){Ÿ6    sqlite3TreeViewLine(pView, "%s%s", zBinOp, zFlgs);Ÿ0    sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);Ÿ1    sqlite3TreeViewExpr(pView, pExpr->pRight, 0);µ  }else if( zUniOp ){Ÿ6    sqlite3TreeViewLine(pView, "%s%s", zUniOp, zFlgs);Ÿ0    sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);£  }º  sqlite3TreeViewPop(pView);°}††¢/*Ÿ?** Generate a human-readable explanation of an expression list.¢*/Ÿ0SQLITE_PRIVATE void sqlite3TreeViewBareExprList(≤  TreeView *pView,∏  const ExprList *pList,¥  const char *zLabel¢){Ÿ2  if( zLabel==0 || zLabel[0]==0 ) zLabel = "LIST";±  if( pList==0 ){Ÿ5    sqlite3TreeViewLine(pView, "%s (empty)", zLabel);®  }else{™    int i;Ÿ-    sqlite3TreeViewLine(pView, "%s", zLabel);Ÿ"    for(i=0; i<pList->nExpr; i++){Ÿ*      int j = pList->a[i].u.x.iOrderByCol;Ÿ&      char *zName = pList->a[i].zName;∑      if( j || zName ){Ÿ&        sqlite3TreeViewPush(pView, 0);ß      }≤      if( zName ){Ÿ3        sqlite3TreeViewLine(pView, "AS %s", zName);ß      }Æ      if( j ){Ÿ8        sqlite3TreeViewLine(pView, "iOrderByCol=%d", j);ß      }ŸF      sqlite3TreeViewExpr(pView, pList->a[i].pExpr, i<pList->nExpr-1);∑      if( j || zName ){Ÿ"        sqlite3TreeViewPop(pView);ß      }•    }£  }°}Ÿ,SQLITE_PRIVATE void sqlite3TreeViewExprList(≤  TreeView *pView,∏  const ExprList *pList,≤  u8 moreToFollow,¥  const char *zLabel¢){Ÿ3  pView = sqlite3TreeViewPush(pView, moreToFollow);Ÿ4  sqlite3TreeViewBareExprList(pView, pList, zLabel);º  sqlite3TreeViewPop(pView);°}†π#endif /* SQLITE_DEBUG */†ŸO/************** End of treeview.c ********************************************/ŸO/************** Begin file random.c ******************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ>** This file contains code to implement a pseudo-random numberø** generator (PRNG) for SQLite.¢**ŸD** Random numbers are used by some of the database backends in orderŸB** to generate random integer keys for tables or random filenames.¢*/º/* #include "sqliteInt.h" */††Ÿ6/* All threads share a single random number generator.Ÿ8** This structure is the current state of the generator.¢*/Ÿ*static SQLITE_WSD struct sqlite3PrngType {Ÿ:  unsigned char isInit;          /* True if initialized */Ÿ6  unsigned char i, j;            /* State variables */Ÿ6  unsigned char s[256];          /* State variables */Æ} sqlite3Prng;†¢/*π** Return N random bytes.¢*/Ÿ6SQLITE_API void sqlite3_randomness(int N, void *pBuf){≤  unsigned char t;Ω  unsigned char *zBuf = pBuf;†ŸK  /* The "wsdPrng" macro will resolve to the pseudo-random number generatorŸI  ** state vector.  If writable static data is unsupported on the target,ŸH  ** we have to locate the state vector at run-time.  In the more commonŸM  ** case where writable static data is supported, wsdPrng can refer directlyŸ6  ** to the "sqlite3Prng" state vector declared above.§  */∂#ifdef SQLITE_OMIT_WSDŸK  struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);µ# define wsdPrng p[0]•#elseº# define wsdPrng sqlite3Prng¶#endif†µ#if SQLITE_THREADSAFE∑  sqlite3_mutex *mutex;¶#endif†º#ifndef SQLITE_OMIT_AUTOINITŸ$  if( sqlite3_initialize() ) return;¶#endif†µ#if SQLITE_THREADSAFEŸ6  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);¶#endif†Ω  sqlite3_mutex_enter(mutex);∏  if( N<=0 || pBuf==0 ){∑    wsdPrng.isInit = 0;ø    sqlite3_mutex_leave(mutex);´    return;£  }†Ÿ>  /* Initialize the state of the random number generator once,Ÿ@  ** the first time this routine is called.  The seed value doesŸ=  ** not need to contain a lot of randomness since we are notŸ<  ** trying to do secure encryption or anything like that...§  **ŸE  ** Nothing in this file or anywhere else in SQLite does any kind ofŸJ  ** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-randomŸ3  ** number generator) not as an encryption device.§  */∏  if( !wsdPrng.isInit ){™    int i;∞    char k[256];≤    wsdPrng.j = 0;≤    wsdPrng.i = 0;Ÿ5    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);π    for(i=0; i<256; i++){ª      wsdPrng.s[i] = (u8)i;•    }π    for(i=0; i<256; i++){Ÿ'      wsdPrng.j += wsdPrng.s[i] + k[i];ø      t = wsdPrng.s[wsdPrng.j];Ÿ*      wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];∑      wsdPrng.s[i] = t;•    }∑    wsdPrng.isInit = 1;£  }†∞  assert( N>0 );•  do{∞    wsdPrng.i++;Ω    t = wsdPrng.s[wsdPrng.i];≥    wsdPrng.j += t;Ÿ0    wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];Ω    wsdPrng.s[wsdPrng.j] = t;æ    t += wsdPrng.s[wsdPrng.i];Ω    *(zBuf++) = wsdPrng.s[t];∞  }while( --N );Ω  sqlite3_mutex_leave(mutex);°}†π#ifndef SQLITE_UNTESTABLE¢/*ŸC** For testing purposes, we sometimes want to preserve the state ofŸC** PRNG and restore the PRNG to its saved state at a later time, orŸE** to reset the PRNG to its initial state.  These routines accomplishØ** those tasks.¢**Ÿ?** The sqlite3_test_control() interface calls these routines to¥** control the PRNG.¢*/Ÿ:static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;Ÿ/SQLITE_PRIVATE void sqlite3PrngSaveState(void){©  memcpy(Ÿ6    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),Ÿ1    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),∑    sizeof(sqlite3Prng)§  );°}Ÿ2SQLITE_PRIVATE void sqlite3PrngRestoreState(void){©  memcpy(Ÿ1    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),Ÿ6    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),∑    sizeof(sqlite3Prng)§  );°}æ#endif /* SQLITE_UNTESTABLE */†ŸO/************** End of random.c **********************************************/ŸO/************** Begin file threads.c *****************************************/¢/*Ø** 2012 July 21¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸE** This file presents a simple cross-platform threading interface forº** use internally by SQLite.¢**ŸF** A "thread" can be created using sqlite3ThreadCreate().  This threadŸ=** runs independently of its creator until it is joined usingŸ5** sqlite3ThreadJoin(), at which point it terminates.¢**ŸD** Threads do not have to be real.  It could be that the work of theŸJ** "thread" is done by the main thread at either the sqlite3ThreadCreate()ŸB** or sqlite3ThreadJoin() call.  This is, in fact, what happens inŸI** single threaded systems.  Nothing in SQLite requires multiple threads.ŸI** This interface exists so that applications that want to take advantageŸH** of multiple cores can do so, while also allowing applications to stayæ** single-threaded if desired.¢*/º/* #include "sqliteInt.h" */±#if SQLITE_OS_WINª/* #  include "os_win.h" */¶#endif†ø#if SQLITE_MAX_WORKER_THREADS>0†ŸN/********************************* Unix Pthreads ****************************/ŸK#if SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) && SQLITE_THREADSAFE>0†ŸP#define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */∫/* #include <pthread.h> */†∂/* A running thread */µstruct SQLiteThread {Ÿ0  pthread_t tid;                 /* Thread ID */ŸG  int done;                      /* Set to true when thread finishes */ŸD  void *pOut;                    /* Result returned by the thread */Ÿ9  void *(*xTask)(void*);         /* The thread routine */Ÿ=  void *pIn;                     /* Argument to the thread */¢};†π/* Create a new thread */Ÿ'SQLITE_PRIVATE int sqlite3ThreadCreate(ŸC  SQLiteThread **ppThread,  /* OUT: Write the thread object here */ŸE  void *(*xTask)(void*),    /* Routine to run in a separate thread */Ÿ>  void *pIn                 /* Argument passed into xTask() */¢){≤  SQLiteThread *p;©  int rc;†∏  assert( ppThread!=0 );µ  assert( xTask!=0 );Ÿ:  /* This routine is never used in single-threaded mode */Ÿ.  assert( sqlite3GlobalConfig.bCoreMutex!=0 );†∞  *ppThread = 0;Ÿ   p = sqlite3Malloc(sizeof(*p));Ÿ&  if( p==0 ) return SQLITE_NOMEM_BKPT;ª  memset(p, 0, sizeof(*p));≥  p->xTask = xTask;Ø  p->pIn = pIn;ŸF  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a ŸJ  ** function that returns SQLITE_ERROR when passed the argument 200, thatŸE  ** forces worker threads to run sequentially and deterministically Ω  ** for testing purposes. */Ω  if( sqlite3FaultSim(200) ){´    rc = 1;¨  }else{    Ÿ0    rc = pthread_create(&p->tid, 0, xTask, pIn);£  }´  if( rc ){∞    p->done = 1;π    p->pOut = xTask(pIn);£  }∞  *ppThread = p;≥  return SQLITE_OK;°}†Ÿ#/* Get the results of the thread */ŸDSQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){©  int rc;†µ  assert( ppOut!=0 );Ÿ-  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;∞  if( p->done ){µ    *ppOut = p->pOut;≥    rc = SQLITE_OK;®  }else{Ÿ@    rc = pthread_join(p->tid, ppOut) ? SQLITE_ERROR : SQLITE_OK;£  }≤  sqlite3_free(p);¨  return rc;°}†Ÿ=#endif /* SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) */ŸN/******************************** End Unix Pthreads *************************/††ŸN/********************************* Win32 Threads ****************************/π#if SQLITE_OS_WIN_THREADS†ŸP#define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */¥#include <process.h>†∂/* A running thread */µstruct SQLiteThread {Ÿ2  void *tid;               /* The thread handle */Ÿ6  unsigned id;             /* The thread identifier */Ÿ?  void *(*xTask)(void*);   /* The routine to run as a thread */Ÿ2  void *pIn;               /* Argument to xTask */Ÿ0  void *pResult;           /* Result of xTask */¢};†Ÿ//* Thread procedure Win32 compatibility shim */Ÿ,static unsigned __stdcall sqlite3ThreadProc(Ÿ=  void *pArg  /* IN: Pointer to the SQLiteThread structure */¢){Ÿ)  SQLiteThread *p = (SQLiteThread *)pArg;†±  assert( p!=0 );•#if 0§  /*Ÿ9  ** This assert appears to trigger spuriously on certainŸ:  ** versions of Windows, possibly due to _beginthreadex()Ÿ9  ** and/or CreateThread() not fully setting their threadŸ-  ** ID parameter before starting the thread.§  */Ÿ(  assert( p->id==GetCurrentThreadId() );¶#endif∏  assert( p->xTask!=0 );Ÿ   p->pResult = p->xTask(p->pIn);†≤  _endthreadex(0);Ω  return 0; /* NOT REACHED */°}†π/* Create a new thread */Ÿ'SQLITE_PRIVATE int sqlite3ThreadCreate(ŸC  SQLiteThread **ppThread,  /* OUT: Write the thread object here */ŸE  void *(*xTask)(void*),    /* Routine to run in a separate thread */Ÿ>  void *pIn                 /* Argument passed into xTask() */¢){≤  SQLiteThread *p;†∏  assert( ppThread!=0 );µ  assert( xTask!=0 );∞  *ppThread = 0;Ÿ   p = sqlite3Malloc(sizeof(*p));Ÿ&  if( p==0 ) return SQLITE_NOMEM_BKPT;ŸF  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a ŸJ  ** function that returns SQLITE_ERROR when passed the argument 200, thatŸE  ** forces worker threads to run sequentially and deterministically ŸD  ** (via the sqlite3FaultSim() term of the conditional) for testing±  ** purposes. */ŸB  if( sqlite3GlobalConfig.bCoreMutex==0 || sqlite3FaultSim(200) ){Ω    memset(p, 0, sizeof(*p));®  }else{µ    p->xTask = xTask;±    p->pIn = pIn;ŸJ    p->tid = (void*)_beginthreadex(0, 0, sqlite3ThreadProc, p, 0, &p->id);¥    if( p->tid==0 ){ø      memset(p, 0, sizeof(*p));•    }£  }¥  if( p->xTask==0 ){Ÿ!    p->id = GetCurrentThreadId();º    p->pResult = xTask(pIn);£  }∞  *ppThread = p;≥  return SQLITE_OK;°}†ŸESQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject); /* os_win.c */†Ÿ#/* Get the results of the thread */ŸDSQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){´  DWORD rc;´  BOOL bRc;†µ  assert( ppOut!=0 );Ÿ-  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;¥  if( p->xTask==0 ){Ÿ0    /* assert( p->id==GetCurrentThreadId() ); */∑    rc = WAIT_OBJECT_0;∏    assert( p->tid==0 );®  }else{Ÿ6    assert( p->id!=0 && p->id!=GetCurrentThreadId() );Ÿ*    rc = sqlite3Win32Wait((HANDLE)p->tid);Ÿ%    assert( rc!=WAIT_IO_COMPLETION );Ÿ&    bRc = CloseHandle((HANDLE)p->tid);≤    assert( bRc );£  }Ÿ.  if( rc==WAIT_OBJECT_0 ) *ppOut = p->pResult;≤  sqlite3_free(p);Ÿ8  return (rc==WAIT_OBJECT_0) ? SQLITE_OK : SQLITE_ERROR;°}†Ÿ"#endif /* SQLITE_OS_WIN_THREADS */ŸN/******************************** End Win32 Threads *************************/††ŸN/********************************* Single-Threaded **************************/Ÿ"#ifndef SQLITE_THREADS_IMPLEMENTED¢/*ŸJ** This implementation does not actually create a new thread.  It does theŸK** work of the thread in the main thread, when either the thread is created∑** or when it is joined¢*/†∂/* A running thread */µstruct SQLiteThread {Ÿ?  void *(*xTask)(void*);   /* The routine to run as a thread */Ÿ2  void *pIn;               /* Argument to xTask */Ÿ0  void *pResult;           /* Result of xTask */¢};†π/* Create a new thread */Ÿ'SQLITE_PRIVATE int sqlite3ThreadCreate(ŸC  SQLiteThread **ppThread,  /* OUT: Write the thread object here */ŸE  void *(*xTask)(void*),    /* Routine to run in a separate thread */Ÿ>  void *pIn                 /* Argument passed into xTask() */¢){≤  SQLiteThread *p;†∏  assert( ppThread!=0 );µ  assert( xTask!=0 );∞  *ppThread = 0;Ÿ   p = sqlite3Malloc(sizeof(*p));Ÿ&  if( p==0 ) return SQLITE_NOMEM_BKPT;Ÿ$  if( (SQLITE_PTR_TO_INT(p)/17)&1 ){µ    p->xTask = xTask;±    p->pIn = pIn;®  }else{±    p->xTask = 0;º    p->pResult = xTask(pIn);£  }∞  *ppThread = p;≥  return SQLITE_OK;°}†Ÿ#/* Get the results of the thread */ŸDSQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){†µ  assert( ppOut!=0 );Ÿ-  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;±  if( p->xTask ){æ    *ppOut = p->xTask(p->pIn);®  }else{∏    *ppOut = p->pResult;£  }≤  sqlite3_free(p);†∏#if defined(SQLITE_TEST)£  {Ÿ(    void *pTstAlloc = sqlite3Malloc(10);Ÿ-    if (!pTstAlloc) return SQLITE_NOMEM_BKPT;º    sqlite3_free(pTstAlloc);£  }¶#endif†≥  return SQLITE_OK;°}†Ÿ1#endif /* !defined(SQLITE_THREADS_IMPLEMENTED) */ŸN/****************************** End Single-Threaded *************************/Ÿ(#endif /* SQLITE_MAX_WORKER_THREADS>0 */†ŸO/************** End of threads.c *********************************************/ŸO/************** Begin file utf.c *********************************************/¢/*∞** 2004 April 13¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ@** This file contains routines used to translate between UTF-8, Ÿ"** UTF-16, UTF-16BE, and UTF-16LE.¢**≤** Notes on UTF-8:¢**Ÿ2**   Byte-0    Byte-1    Byte-2    Byte-3    ValueŸG**  0xxxxxxx                                 00000000 00000000 0xxxxxxxŸG**  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxxŸG**  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxxŸG**  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx¢**¢**Ÿ)** Notes on UTF-16:  (with wwww+1==uuuuu)¢**Ÿ2**      Word-0               Word-1          ValueŸG**  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxxŸG**  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx¢**¢**∫** BOM or Byte Order Mark:Ÿ/**     0xff 0xfe   little-endian utf-16 followsŸ,**     0xfe 0xff   big-endian utf-16 follows¢**¢*/º/* #include "sqliteInt.h" */π/* #include <assert.h> */∫/* #include "vdbeInt.h" */†Ÿ8#if !defined(SQLITE_AMALGAMATION) && SQLITE_BYTEORDER==0¢/*ŸC** The following constant value is used by the SQLITE_BIGENDIAN andæ** SQLITE_LITTLEENDIAN macros.¢*/Ÿ(SQLITE_PRIVATE const int sqlite3one = 1;Ÿ7#endif /* SQLITE_AMALGAMATION && SQLITE_BYTEORDER==0 */†¢/*Ÿ=** This lookup table is used to help decode the first byte ofø** a multi-byte UTF8 character.¢*/Ÿ2static const unsigned char sqlite3Utf8Trans1[] = {Ÿ1  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,Ÿ1  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,Ÿ1  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,Ÿ1  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,Ÿ1  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,Ÿ1  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,Ÿ1  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,Ÿ1  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,¢};††Ÿ8#define WRITE_UTF8(zOut, c) {                          \Ÿ8  if( c<0x00080 ){                                     \Ÿ8    *zOut++ = (u8)(c&0xFF);                            \Ÿ8  }                                                    \Ÿ8  else if( c<0x00800 ){                                \Ÿ8    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \Ÿ8    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \Ÿ8  }                                                    \Ÿ8  else if( c<0x10000 ){                                \Ÿ8    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \Ÿ8    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \Ÿ8    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \Ÿ8  }else{                                               \Ÿ8    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \Ÿ8    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \Ÿ8    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \Ÿ8    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \Ÿ8  }                                                    \°}†ŸE#define WRITE_UTF16LE(zOut, c) {                                    \ŸE  if( c<=0xFFFF ){                                                  \ŸE    *zOut++ = (u8)(c&0x00FF);                                       \ŸE    *zOut++ = (u8)((c>>8)&0x00FF);                                  \ŸE  }else{                                                            \ŸE    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \ŸE    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \ŸE    *zOut++ = (u8)(c&0x00FF);                                       \ŸE    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \ŸE  }                                                                 \°}†ŸE#define WRITE_UTF16BE(zOut, c) {                                    \ŸE  if( c<=0xFFFF ){                                                  \ŸE    *zOut++ = (u8)((c>>8)&0x00FF);                                  \ŸE    *zOut++ = (u8)(c&0x00FF);                                       \ŸE  }else{                                                            \ŸE    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \ŸE    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \ŸE    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \ŸE    *zOut++ = (u8)(c&0x00FF);                                       \ŸE  }                                                                 \°}†ŸG#define READ_UTF16LE(zIn, TERM, c){                                   \ŸG  c = (*zIn++);                                                       \ŸG  c += ((*zIn++)<<8);                                                 \ŸG  if( c>=0xD800 && c<0xE000 && TERM ){                                \ŸG    int c2 = (*zIn++);                                                \ŸG    c2 += ((*zIn++)<<8);                                              \ŸG    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \ŸG  }                                                                   \°}†ŸG#define READ_UTF16BE(zIn, TERM, c){                                   \ŸG  c = ((*zIn++)<<8);                                                  \ŸG  c += (*zIn++);                                                      \ŸG  if( c>=0xD800 && c<0xE000 && TERM ){                                \ŸG    int c2 = ((*zIn++)<<8);                                           \ŸG    c2 += (*zIn++);                                                   \ŸG    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \ŸG  }                                                                   \°}†¢/*ŸA** Translate a single UTF-8 character.  Return the unicode value.¢**Ÿ=** During translation, assume that the byte that zTerm points≠** is a 0x00.¢**Ÿ=** Write a pointer to the next unread byte back into *pzNext.¢**∫** Notes On Invalid UTF-8:¢**ŸI**  *  This routine never allows a 7-bit character (0x00 through 0x7f) toŸK**     be encoded as a multi-byte character.  Any multi-byte character thatŸN**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.¢**ŸG**  *  This routine never allows a UTF16 surrogate value to be encoded.ŸC**     If a multi-byte character attempts to encode a value betweenŸ7**     0xd800 and 0xe000 then it is rendered as 0xfffd.¢**ŸG**  *  Bytes in the range of 0x80 through 0xbf which occur as the firstŸD**     byte of a character are interpreted as single-byte charactersŸB**     and rendered as themselves even though they are technically∫**     invalid characters.¢**Ÿ6**  *  This routine accepts over-length UTF8 encodingsŸK**     for unicode values 0x80 and greater.  It does not change over-lengthŸ5**     encodings to 0xfffd as some systems recommend.¢*/Ÿ<#define READ_UTF8(zIn, zTerm, c)                           \Ÿ<  c = *(zIn++);                                            \Ÿ<  if( c>=0xc0 ){                                           \Ÿ<    c = sqlite3Utf8Trans1[c-0xc0];                         \Ÿ<    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \Ÿ<      c = (c<<6) + (0x3f & *(zIn++));                      \Ÿ<    }                                                      \Ÿ<    if( c<0x80                                             \Ÿ<        || (c&0xFFFFF800)==0xD800                          \Ÿ<        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \£  }Ÿ#SQLITE_PRIVATE u32 sqlite3Utf8Read(ŸM  const unsigned char **pz    /* Pointer to string from which to read char */¢){±  unsigned int c;†Ÿ?  /* Same as READ_UTF8() above but without the zTerm parameter.ŸK  ** For this routine, we assume the UTF8 string is always zero-terminated.§  */±  c = *((*pz)++);∞  if( c>=0xc0 ){Ÿ"    c = sqlite3Utf8Trans1[c-0xc0];Ÿ#    while( (*(*pz) & 0xc0)==0x80 ){Ÿ'      c = (c<<6) + (0x3f & *((*pz)++));•    }Æ    if( c<0x80Ÿ!        || (c&0xFFFFF800)==0xD800Ÿ3        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }£  }´  return c;°}††††¢/*ŸD** If the TRANSLATE_TRACE macro is defined, the value of each Mem isŸJ** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().£*/ ø/* #define TRANSLATE_TRACE 1 */†π#ifndef SQLITE_OMIT_UTF16¢/*ŸE** This routine transforms the internal text encoding used by pMem toŸE** desiredEnc. It is an error if the string is already of the desiredŸ9** encoding, or if *pMem does not contain a string value.¢*/ŸUSQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){ŸL  int len;                    /* Maximum length of output string in bytes */Ÿ;  unsigned char *zOut;                  /* Output buffer */Ÿ<  unsigned char *zIn;                   /* Input iterator */Ÿ:  unsigned char *zTerm;                 /* End of input */Ÿ=  unsigned char *z;                     /* Output iterator */±  unsigned int c;†Ÿ?  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );Ÿ   assert( pMem->flags&MEM_Str );Ÿ"  assert( pMem->enc!=desiredEnc );π  assert( pMem->enc!=0 );∑  assert( pMem->n>=0 );†Ÿ5#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)£  {≥    char zBuf[100];Ÿ*    sqlite3VdbeMemPrettyPrint(pMem, zBuf);Ÿ*    fprintf(stderr, "INPUT:  %s\n", zBuf);£  }¶#endif†ŸF  /* If the translation is between UTF-16 little and big endian, then ŸI  ** all that is required is to swap the byte order. This case is handledŸ!  ** differently from the others.§  */Ÿ:  if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){¨    u8 temp;´    int rc;Ÿ+    rc = sqlite3VdbeMemMakeWriteable(pMem);∏    if( rc!=SQLITE_OK ){Ÿ!      assert( rc==SQLITE_NOMEM );ø      return SQLITE_NOMEM_BKPT;•    }∑    zIn = (u8*)pMem->z;Ω    zTerm = &zIn[pMem->n&~1];∑    while( zIn<zTerm ){≤      temp = *zIn;∂      *zIn = *(zIn+1);¨      zIn++;¥      *zIn++ = temp;•    }ª    pMem->enc = desiredEnc;∑    goto translate_out;£  }†ŸM  /* Set len to the maximum number of bytes required in the output buffer. */Ÿ   if( desiredEnc==SQLITE_UTF8 ){ŸC    /* When converting from UTF-16, the maximum growth results fromŸB    ** translating a 2-byte character to a 4-byte UTF-8 character.Ÿ6    ** A single byte is required for the output string∂    ** nul-terminator.¶    */≤    pMem->n &= ~1;∫    len = pMem->n * 2 + 1;®  }else{ŸH    /* When converting from UTF-8 to UTF-16 the maximum growth is causedŸG    ** when a 1-byte UTF-8 character is translated into a 2-byte UTF-16ŸE    ** character. Two bytes are required in the output buffer for the∂    ** nul-terminator.¶    */∫    len = pMem->n * 2 + 2;£  }†ŸK  /* Set zIn to point at the start of the input buffer and zTerm to point 1∑  ** byte past the end.§  **ŸG  ** Variable zOut is set to point at the output buffer, space obtainedª  ** from sqlite3_malloc().§  */µ  zIn = (u8*)pMem->z;∏  zTerm = &zIn[pMem->n];Ÿ+  zOut = sqlite3DbMallocRaw(pMem->db, len);Æ  if( !zOut ){Ω    return SQLITE_NOMEM_BKPT;£  }´  z = zOut;†ø  if( pMem->enc==SQLITE_UTF8 ){Ÿ%    if( desiredEnc==SQLITE_UTF16LE ){Ÿ)      /* UTF-8 -> UTF-16 Little-endian */π      while( zIn<zTerm ){Ÿ!        READ_UTF8(zIn, zTerm, c);º        WRITE_UTF16LE(z, c);ß      }™    }else{Ÿ+      assert( desiredEnc==SQLITE_UTF16BE );Ÿ&      /* UTF-8 -> UTF-16 Big-endian */π      while( zIn<zTerm ){Ÿ!        READ_UTF8(zIn, zTerm, c);º        WRITE_UTF16BE(z, c);ß      }•    }æ    pMem->n = (int)(z - zOut);≠    *z++ = 0;®  }else{Ÿ&    assert( desiredEnc==SQLITE_UTF8 );Ÿ$    if( pMem->enc==SQLITE_UTF16LE ){Ÿ)      /* UTF-16 Little-endian -> UTF-8 */π      while( zIn<zTerm ){Ÿ)        READ_UTF16LE(zIn, zIn<zTerm, c); π        WRITE_UTF8(z, c);ß      }™    }else{Ÿ&      /* UTF-16 Big-endian -> UTF-8 */π      while( zIn<zTerm ){Ÿ)        READ_UTF16BE(zIn, zIn<zTerm, c); π        WRITE_UTF8(z, c);ß      }•    }æ    pMem->n = (int)(z - zOut);£  }©  *z = 0;Ÿ9  assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len );†≤  c = pMem->flags;æ  sqlite3VdbeMemRelease(pMem);Ÿ?  pMem->flags = MEM_Str|MEM_Term|(c&(MEM_AffMask|MEM_Subtype));π  pMem->enc = desiredEnc;∏  pMem->z = (char*)zOut;∫  pMem->zMalloc = pMem->z;Ÿ:  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);†Ætranslate_out:Ÿ5#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)£  {≥    char zBuf[100];Ÿ*    sqlite3VdbeMemPrettyPrint(pMem, zBuf);Ÿ*    fprintf(stderr, "OUTPUT: %s\n", zBuf);£  }¶#endif≥  return SQLITE_OK;°}æ#endif /* SQLITE_OMIT_UTF16 */†π#ifndef SQLITE_OMIT_UTF16¢/*ŸE** This routine checks for a byte-order mark at the beginning of the ŸF** UTF-16 string stored in *pMem. If one is present, it is removed andŸA** the encoding of the Mem adjusted. This routine does not do anyŸ5** byte-swapping, it just sets Mem.enc appropriately.¢**ŸG** The allocation (static, dynamic etc.) and encoding of the Mem may beº** changed by this function.¢*/Ÿ6SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem){µ  int rc = SQLITE_OK;≠  u8 bom = 0;†∑  assert( pMem->n>=0 );≤  if( pMem->n>1 ){ª    u8 b1 = *(u8 *)pMem->z;Ÿ#    u8 b2 = *(((u8 *)pMem->z) + 1);ø    if( b1==0xFE && b2==0xFF ){ª      bom = SQLITE_UTF16BE;•    }ø    if( b1==0xFF && b2==0xFE ){ª      bom = SQLITE_UTF16LE;•    }£  }¢  ¨  if( bom ){Ÿ+    rc = sqlite3VdbeMemMakeWriteable(pMem);∏    if( rc==SQLITE_OK ){≥      pMem->n -= 2;Ÿ-      memmove(pMem->z, &pMem->z[2], pMem->n);æ      pMem->z[pMem->n] = '\0';Ÿ       pMem->z[pMem->n+1] = '\0';æ      pMem->flags |= MEM_Term;∂      pMem->enc = bom;•    }£  }¨  return rc;°}æ#endif /* SQLITE_OMIT_UTF16 */†¢/*ŸD** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,ŸJ** return the number of unicode characters in pZ up to (but not including)ŸB** the first 0x00 byte. If nByte is not less than zero, return theŸC** number of unicode characters in the first nByte of pZ (or up to Ÿ*** the first 0x00, whichever comes first).¢*/ŸBSQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){¨  int r = 0;ø  const u8 *z = (const u8*)zIn;≤  const u8 *zTerm;±  if( nByte>=0 ){∂    zTerm = &z[nByte];®  }else{º    zTerm = (const u8*)(-1);£  }µ  assert( z<=zTerm );º  while( *z!=0 && z<zTerm ){∏    SQLITE_SKIP_UTF8(z);®    r++;£  }´  return r;°}†ŸI/* This test function is not currently used by the automated test-suite. Ÿ.** Hence it is only available in debug builds.¢*/Ÿ1#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)¢/*º** Translate UTF-8 to UTF-8.¢**ŸD** This has the effect of making sure that the string is well-formedŸ+** UTF-8.  Miscoded characters are removed.¢**Ÿ=** The translation is done in-place and aborted if the output∂** overruns the input.¢*/Ÿ6SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn){º  unsigned char *zOut = zIn;æ  unsigned char *zStart = zIn;®  u32 c;†ø  while( zIn[0] && zOut<=zIn ){Ÿ*    c = sqlite3Utf8Read((const u8**)&zIn);¥    if( c!=0xfffd ){∫      WRITE_UTF8(zOut, c);•    }£  }¨  *zOut = 0;æ  return (int)(zOut - zStart);°}¶#endif†π#ifndef SQLITE_OMIT_UTF16¢/*ŸF** Convert a UTF-16 string in the native encoding into a UTF-8 string.ŸK** Memory to hold the UTF-8 string is obtained from sqlite3_malloc and mustŸ$** be freed by the calling function.¢**Ÿ4** NULL is returned if there is an allocation error.¢*/ŸTSQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){®  Mem m;ª  memset(&m, 0, sizeof(m));¨  m.db = db;Ÿ9  sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);Ÿ-  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);π  if( db->mallocFailed ){æ    sqlite3VdbeMemRelease(&m);¨    m.z = 0;£  }Ÿ8  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );Ÿ7  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );Ÿ$  assert( m.z || db->mallocFailed );≠  return m.z;°}†¢/*ŸI** zIn is a UTF-16 encoded unicode string at least nChar characters long.ŸC** Return the number of bytes in the first nChar unicode charactersŸ&** in pZ.  nChar must be non-negative.¢*/ŸCSQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){®  int c;ø  unsigned char const *z = zIn;¨  int n = 0;¢  Ÿ+  if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){µ    while( n<nChar ){º      READ_UTF16BE(z, 1, c);™      n++;•    }®  }else{µ    while( n<nChar ){º      READ_UTF16LE(z, 1, c);™      n++;•    }£  }Ÿ-  return (int)(z-(unsigned char const *)zIn);°}†∏#if defined(SQLITE_TEST)¢/*ŸJ** This routine is called from the TCL test function "translate_selftest".ŸB** It checks that the primitives for serializing and deserializingŸ:** characters in each encoding are inverses of each other.¢*/Ÿ-SQLITE_PRIVATE void sqlite3UtfSelfTest(void){¥  unsigned int i, t;π  unsigned char zBuf[20];≥  unsigned char *z;®  int n;±  unsigned int c;†æ  for(i=0; i<0x00110000; i++){≠    z = zBuf;µ    WRITE_UTF8(z, i);∂    n = (int)(z-zBuf);∫    assert( n>0 && n<=4 );≠    z[0] = 0;≠    z = zBuf;Ÿ(    c = sqlite3Utf8Read((const u8**)&z);™    t = i;Ÿ,    if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;Ÿ,    if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;≥    assert( c==t );∫    assert( (z-zBuf)==n );£  }æ  for(i=0; i<0x00110000; i++){Ÿ)    if( i>=0xD800 && i<0xE000 ) continue;≠    z = zBuf;∏    WRITE_UTF16LE(z, i);∂    n = (int)(z-zBuf);∫    assert( n>0 && n<=4 );≠    z[0] = 0;≠    z = zBuf;∫    READ_UTF16LE(z, 1, c);≥    assert( c==i );∫    assert( (z-zBuf)==n );£  }æ  for(i=0; i<0x00110000; i++){Ÿ)    if( i>=0xD800 && i<0xE000 ) continue;≠    z = zBuf;∏    WRITE_UTF16BE(z, i);∂    n = (int)(z-zBuf);∫    assert( n>0 && n<=4 );≠    z[0] = 0;≠    z = zBuf;∫    READ_UTF16BE(z, 1, c);≥    assert( c==i );∫    assert( (z-zBuf)==n );£  }°}∏#endif /* SQLITE_TEST */æ#endif /* SQLITE_OMIT_UTF16 */†ŸO/************** End of utf.c *************************************************/ŸO/************** Begin file util.c ********************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ,** Utility functions used throughout sqlite.¢**Ÿ@** This file contains functions for allocating memory, comparingŸ ** strings, and stuff like that.¢**¢*/º/* #include "sqliteInt.h" */π/* #include <stdarg.h> */Ÿ##if HAVE_ISNAN || SQLITE_HAVE_ISNAN≤# include <math.h>¶#endif†¢/*Ÿ2** Routine needed to support the testcase() macro.¢*/ª#ifdef SQLITE_COVERAGE_TESTŸ+SQLITE_PRIVATE void sqlite3Coverage(int x){º  static unsigned dummy = 0;∑  dummy += (unsigned)x;°}¶#endif†¢/*ŸJ** Give a callback to the test harness that can be used to simulate faultsŸH** in places where it is difficult or expensive to do so purely by means≠** of inputs.¢**ŸH** The intent of the integer argument is to let the fault simulator knowŸ:** which of multiple sqlite3FaultSim() calls has been hit.¢**ŸE** Return whatever integer value the test callback returns, or returnŸ.** SQLITE_OK if no test callback is installed.¢*/π#ifndef SQLITE_UNTESTABLEŸ.SQLITE_PRIVATE int sqlite3FaultSim(int iTest){Ÿ<  int (*xCallback)(int) = sqlite3GlobalConfig.xTestCallback;Ÿ2  return xCallback ? xCallback(iTest) : SQLITE_OK;°}¶#endif†Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINT¢/*ŸA** Return true if the floating point value is Not a Number (NaN).¢**ŸL** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.ŸH** Otherwise, we have our own implementation that works on most systems.¢*/Ÿ*SQLITE_PRIVATE int sqlite3IsNaN(double x){Ÿ"  int rc;   /* The value return */Ÿ%#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN§  /*ŸF  ** Systems that support the isnan() library function should probablyŸG  ** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we haveŸF  ** found that many systems do not have a working isnan() function soŸ7  ** this implementation is provided as an alternative.§  **ŸG  ** This NaN test sometimes fails if compiled on GCC with -ffast-math.ŸG  ** On the other hand, the use of -ffast-math comes with the following≠  ** warning:§  **ŸD  **      This option [-ffast-math] should never be turned on by anyŸH  **      -O option since it can result in incorrect output for programsŸA  **      which depend on an exact implementation of IEEE or ISO Ÿ2  **      rules/specifications for math functions.§  **ŸD  ** Under MSVC, this NaN test may fail if compiled with a floating-ŸA  ** point precision mode other than /fp:precise.  From the MSDN ≥  ** documentation:§  **ŸK  **      The compiler [with /fp:precise] will properly handle comparisons ŸK  **      involving NaN. For example, x != x evaluates to true if x is NaN ≠  **      ...§  */¥#ifdef __FAST_MATH__ŸJ# error SQLite will not work correctly with the -ffast-math option of GCC.¶#endif∏  volatile double y = x;∏  volatile double z = y;Æ  rc = (y!=z);∫#else  /* if HAVE_ISNAN */∞  rc = isnan(x);∑#endif /* HAVE_ISNAN */±  testcase( rc );¨  return rc;°}Ÿ'#endif /* SQLITE_OMIT_FLOATING_POINT */†¢/*ŸC** Compute a string length that is limited to what can be stored inŸ,** lower 30 bits of a 32-bit signed integer.¢**ŸJ** The value returned will never be negative.  Nor will it ever be greaterŸH** than the actual length of the string.  For very long strings (greaterŸK** than 1GiB) the value returned might be less than the true string length.¢*/Ÿ2SQLITE_PRIVATE int sqlite3Strlen30(const char *z){∂  if( z==0 ) return 0;Ÿ%  return 0x3fffffff & (int)strlen(z);°}†¢/*ŸH** Return the declared type of a column.  Or return zDflt if the column ∏** has no declared type.¢**ŸI** The column type is an extra string stored after the zero-terminator onŸB** the column name if and only if the COLFLAG_HASTYPE flag is set.¢*/ŸBSQLITE_PRIVATE char *sqlite3ColumnType(Column *pCol, char *zDflt){Ÿ;  if( (pCol->colFlags & COLFLAG_HASTYPE)==0 ) return zDflt;Ÿ/  return pCol->zName + strlen(pCol->zName) + 1;°}†¢/*ŸG** Helper function for sqlite3Error() - called rarely.  Broken out intoŸE** a separate routine to avoid unnecessary register saves on entry to≤** sqlite3Error().¢*/ŸKstatic SQLITE_NOINLINE void  sqlite3ErrorFinish(sqlite3 *db, int err_code){Ÿ/  if( db->pErr ) sqlite3ValueSetNull(db->pErr);Ÿ#  sqlite3SystemError(db, err_code);°}†¢/*ŸL** Set the current error code to err_code and clear any prior error message.ŸJ** Also set iSysErrno (by calling sqlite3System) if the err_code indicatesΩ** that would be appropriate.¢*/Ÿ<SQLITE_PRIVATE void sqlite3Error(sqlite3 *db, int err_code){≤  assert( db!=0 );π  db->errCode = err_code;Ÿ>  if( err_code || db->pErr ) sqlite3ErrorFinish(db, err_code);°}†¢/*ŸC** Load the sqlite3.iSysErrno field if that is an appropriate thingŸ.** to do based on the SQLite error code in rc.¢*/Ÿ<SQLITE_PRIVATE void sqlite3SystemError(sqlite3 *db, int rc){Ÿ&  if( rc==SQLITE_IOERR_NOMEM ) return;≠  rc &= 0xff;Ÿ0  if( rc==SQLITE_CANTOPEN || rc==SQLITE_IOERR ){Ÿ4    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);£  }°}†¢/*ŸA** Set the most recent error code and error string for the sqliteŸ4** handle "db". The error code is set to "err_code".¢**Ÿ@** If it is not NULL, string zFormat specifies the format of theŸC** error string in the style of the printf functions: The followingŸ!** format characters are allowed:¢**ø**      %s      Insert a stringŸ7**      %z      A string that should be freed after useŸ!**      %d      Insert an integeræ**      %T      Insert a tokenŸ5**      %S      Insert the first element of a SrcList¢**ŸA** zFormat and any string tokens that follow it are assumed to be¥** encoded in UTF-8.¢**ŸF** To clear the most recent error for sqlite handle "db", sqlite3ErrorŸB** should be called with err_code set to SQLITE_OK and zFormat set´** to NULL.¢*/Ÿ]SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){≤  assert( db!=0 );π  db->errCode = err_code;Ÿ#  sqlite3SystemError(db, err_code);≥  if( zFormat==0 ){ø    sqlite3Error(db, err_code);Ÿ>  }else if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){¨    char *z;Ø    va_list ap;∫    va_start(ap, zFormat);Ÿ)    z = sqlite3VMPrintf(db, zFormat, ap);Ø    va_end(ap);ŸE    sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC);£  }°}†¢/*ŸF** Add an error message to pParse->zErrMsg and increment pParse->nErr.Ÿ3** The following formatting characters are allowed:¢**ø**      %s      Insert a stringŸ7**      %z      A string that should be freed after useŸ!**      %d      Insert an integeræ**      %T      Insert a tokenŸ5**      %S      Insert the first element of a SrcList¢**ŸE** This function should be used to report any error that occurs whileŸB** compiling an SQL statement (i.e. within sqlite3_prepare()). TheŸC** last thing the sqlite3_prepare() function does is copy the errorŸI** stored by this function into the database handle using sqlite3Error().ŸC** Functions sqlite3Error() or sqlite3ErrorWithMsg() should be usedŸ4** during statement execution (sqlite3_step() etc.).¢*/ŸMSQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){≠  char *zMsg;≠  va_list ap;ª  sqlite3 *db = pParse->db;∏  va_start(ap, zFormat);Ÿ*  zMsg = sqlite3VMPrintf(db, zFormat, ap);≠  va_end(ap);∏  if( db->suppressErr ){º    sqlite3DbFree(db, zMsg);®  }else{≥    pParse->nErr++;Ÿ'    sqlite3DbFree(db, pParse->zErrMsg);ª    pParse->zErrMsg = zMsg;æ    pParse->rc = SQLITE_ERROR;£  }°}†¢/*ŸF** Convert an SQL-style quoted string into a normal string by removingŸB** the quote characters.  The conversion is done in-place.  If theŸA** input does not begin with a quote character, then this routineÆ** is a no-op.¢**ŸC** The input string must be zero-terminated.  A new zero-terminatorŸ#** is added to the dequoted string.¢**ŸE** The return value is -1 if no dequoting occurs or the length of theŸG** dequoted string, exclusive of the zero terminator, if dequoting does©** occur.¢**ŸB** 2002-Feb-14: This routine is extended to remove MS-Access styleŸE** brackets from around identifiers.  For example:  "[a-b-c]" becomes´** "a-b-c".¢*/Ÿ,SQLITE_PRIVATE void sqlite3Dequote(char *z){≠  char quote;´  int i, j;¥  if( z==0 ) return;Ø  quote = z[0];Ÿ&  if( !sqlite3Isquote(quote) ) return;ø  if( quote=='[' ) quote = ']';∂  for(i=1, j=0;; i++){≥    assert( z[i] );∂    if( z[i]==quote ){∫      if( z[i+1]==quote ){∑        z[j++] = quote;¨        i++;¨      }else{Æ        break;ß      }™    }else{¥      z[j++] = z[i];•    }£  }´  z[j] = 0;°}†¢/*Ÿ(** Generate a Token object from a string¢*/Ÿ8SQLITE_PRIVATE void sqlite3TokenInit(Token *p, char *z){´  p->z = z;º  p->n = sqlite3Strlen30(z);°}†ª/* Convenient short-hand */Ÿ(#define UpperToLower sqlite3UpperToLower†¢/*ŸC** Some systems have stricmp().  Others have strcasecmp().  BecauseŸ3** there is no consistency, we will define our own.¢**Ÿ=** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() andŸG** sqlite3_strnicmp() APIs allow applications and extensions to compareŸ<** the contents of two buffers containing UTF-8 strings in aŸ?** case-independent fashion, using the same definition of "caseŸH** independence" that SQLite uses internally when comparing identifiers.¢*/ŸFSQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){±  if( zLeft==0 ){ª    return zRight ? -1 : 0;∏  }else if( zRight==0 ){≠    return 1;£  }Ÿ'  return sqlite3StrICmp(zLeft, zRight);°}ŸISQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){∑  unsigned char *a, *b;®  int c;Ω  a = (unsigned char *)zLeft;æ  b = (unsigned char *)zRight;™  for(;;){Ÿ6    c = (int)UpperToLower[*a] - (int)UpperToLower[*b];ª    if( c || *a==0 ) break;®    a++;®    b++;£  }´  return c;°}ŸNSQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){Ÿ   register unsigned char *a, *b;±  if( zLeft==0 ){ª    return zRight ? -1 : 0;∏  }else if( zRight==0 ){≠    return 1;£  }Ω  a = (unsigned char *)zLeft;æ  b = (unsigned char *)zRight;ŸM  while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }Ÿ7  return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];°}†¢/*Ÿ@** Compute 10 to the E-th power.  Examples:  E==1 results in 10.Ÿ1** E==2 results in 100.  E==50 results in 1.0e50.¢**Ÿ=** This routine only works for values of E between 1 and 341.¢*/Ÿ+static LONGDOUBLE_TYPE sqlite3Pow10(int E){µ#if defined(_MSC_VER)Ÿ&  static const LONGDOUBLE_TYPE x[] = {≠    1.0e+001,≠    1.0e+002,≠    1.0e+004,≠    1.0e+008,≠    1.0e+016,≠    1.0e+032,≠    1.0e+064,≠    1.0e+128,¨    1.0e+256§  };∫  LONGDOUBLE_TYPE r = 1.0;®  int i;ª  assert( E>=0 && E<=307 );æ  for(i=0; E!=0; i++, E >>=1){∫    if( E & 1 ) r *= x[i];£  }´  return r;•#elseª  LONGDOUBLE_TYPE x = 10.0;∫  LONGDOUBLE_TYPE r = 1.0;´  while(1){∑    if( E & 1 ) r *= x;¨    E >>= 1;µ    if( E==0 ) break;´    x *= x;£  }¨  return r; ¶#endif°}†¢/*Ÿ=** The string z[] is an text representation of a real number.Ÿ>** Convert this string to a double and write it into *pResult.¢**ŸG** The string z[] is length bytes in length (bytes, not characters) andŸI** uses the encoding enc.  The string is not necessarily zero-terminated.¢**ŸJ** Return TRUE if the result is a valid real number (or integer) and FALSEŸE** if the string is empty or contains extraneous text.  Valid numbersø** are in one of these formats:¢**Ω**    [+-]digits[E[+-]digits]Ÿ&**    [+-]digits.[digits][E[+-]digits]æ**    [+-].digits[E[+-]digits]¢**ŸL** Leading and trailing whitespace is ignored for the purpose of determining¨** validity.¢**ŸE** If some prefix of the input string is a valid number, this routineŸG** returns FALSE but it still converts the prefix and writes the result±** into *pResult.¢*/ŸSSQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){Ÿ"#ifndef SQLITE_OMIT_FLOATING_POINT´  int incr;Ÿ   const char *zEnd = z + length;Ÿ6  /* sign * significand * (10 ^ (esign * exponent)) */Ÿ,  int sign = 1;    /* sign of significand */Ÿ$  i64 s = 0;       /* significand */ŸC  int d = 0;       /* adjust exponent for shifting decimal point */Ÿ)  int esign = 1;   /* sign of exponent */Ÿ!  int e = 0;       /* exponent */ŸK  int eValid = 1;  /* True exponent is either not used or is well-formed */∞  double result;≤  int nDigits = 0;ŸM  int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */†ŸK  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );ŸC  *pResult = 0.0;   /* Default return value, in case of an error */†π  if( enc==SQLITE_UTF8 ){≠    incr = 1;®  }else{™    int i;≠    incr = 2;Ÿ5    assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );Ÿ-    for(i=3-enc; i<length && z[i]==0; i+=2){}∂    nonNum = i<length;≥    zEnd = &z[i^1];±    z += (enc&1);£  }†ª  /* skip leading spaces */Ÿ0  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;π  if( z>=zEnd ) return 0;†ø  /* get sign of significand */∞  if( *z=='-' ){Æ    sign = -1;¨    z+=incr;∂  }else if( *z=='+' ){¨    z+=incr;£  }†Ÿ2  /* copy max significant digits to significand */ŸD  while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){∫    s = s*10 + (*z - '0');∑    z+=incr; nDigits++;£  }†Ÿ,  /* skip non-significant significand digitsŸ6  ** (increase exponent by d to shift decimal left) */ŸC  while( z<zEnd && sqlite3Isdigit(*z) ){ z+=incr; nDigits++; d++; }Ÿ"  if( z>=zEnd ) goto do_atof_calc;†Ÿ#  /* if decimal point is present */∞  if( *z=='.' ){¨    z+=incr;Ÿ4    /* copy digits from after decimal to significandŸ9    ** (decrease exponent by d to shift decimal right) */Ÿ*    while( z<zEnd && sqlite3Isdigit(*z) ){Ÿ%      if( s<((LARGEST_INT64-9)/10) ){æ        s = s*10 + (*z - '0');¨        d--;ß      }π      z+=incr; nDigits++;•    }£  }Ÿ"  if( z>=zEnd ) goto do_atof_calc;†æ  /* if exponent is present */ª  if( *z=='e' || *z=='E' ){¨    z+=incr;Ø    eValid = 0;†ŸI    /* This branch is needed to avoid a (harmless) buffer overread.  The ŸI    ** special comment alerts the mutation tester that the correct answerŸ3    ** is obtained even if the branch is omitted */ŸP    if( z>=zEnd ) goto do_atof_calc;              /*PREVENTS-HARMLESS-OVERREAD*/†æ    /* get sign of exponent */≤    if( *z=='-' ){±      esign = -1;Æ      z+=incr;∏    }else if( *z=='+' ){Æ      z+=incr;•    }Ÿ!    /* copy digits to exponent */Ÿ*    while( z<zEnd && sqlite3Isdigit(*z) ){Ÿ0      e = e<10000 ? (e*10 + (*z - '0')) : 10000;Æ      z+=incr;±      eValid = 1;•    }£  }†º  /* skip trailing spaces */Ÿ0  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;†≠do_atof_calc:Ÿ-  /* adjust exponent by d, and update sign */¥  e = (e*esign) + d;≠  if( e<0 ) {Ø    esign = -1;¨    e *= -1;™  } else {Æ    esign = 1;£  }†Æ  if( s==0 ) {Ÿ3    /* In the IEEE 754 standard, zero is signed. */Ÿ-    result = sign<0 ? -(double)0 : (double)0;™  } else {Ÿ"    /* Attempt to reduce exponent.¶    **ŸK    ** Branches that are not required for the correct answer but which onlyŸG    ** help to obtain the correct answer faster are marked with specialŸ2    ** comments, as a hint to the mutation tester.¶    */ŸP    while( e>0 ){                                       /*OPTIMIZATION-IF-TRUE*/¥      if( esign>0 ){ŸP        if( s>=(LARGEST_INT64/10) ) break;             /*OPTIMIZATION-IF-FALSE*/∞        s *= 10;¨      }else{ŸP        if( s%10!=0 ) break;                           /*OPTIMIZATION-IF-FALSE*/∞        s /= 10;ß      }™      e--;•    }†Ÿ(    /* adjust the sign of significand */∏    s = sign<0 ? -s : s;†ŸP    if( e==0 ){                                         /*OPTIMIZATION-IF-TRUE*/π      result = (double)s;™    }else{ŸB      /* attempt to handle extremely small/large numbers better */ŸP      if( e>307 ){                                      /*OPTIMIZATION-IF-TRUE*/ŸP        if( e<342 ){                                    /*OPTIMIZATION-IF-TRUE*/Ÿ6          LONGDOUBLE_TYPE scale = sqlite3Pow10(e-308);∏          if( esign<0 ){ø            result = s / scale;ø            result /= 1.0e+308;∞          }else{ø            result = s * scale;ø            result *= 1.0e+308;´          }Ÿ         }else{ assert( e>=342 );∏          if( esign<0 ){ª            result = 0.0*s;∞          }else{Ø#ifdef INFINITYŸ             result = INFINITY*s;•#elseŸ3            result = 1e308*1e308*s;  /* Infinity */¶#endif´          }©        }¨      }else{Ÿ0        LONGDOUBLE_TYPE scale = sqlite3Pow10(e);∂        if( esign<0 ){Ω          result = s / scale;Æ        }else{Ω          result = s * scale;©        }ß      }•    }£  }†∏  /* store the result */¥  *pResult = result;†ŸI  /* return true if number and no extra non-whitespace chracters after */Ÿ5  return z==zEnd && nDigits>0 && eValid && nonNum==0;•#elseŸ1  return !sqlite3Atoi64(z, pResult, length, enc);Ÿ'#endif /* SQLITE_OMIT_FLOATING_POINT */°}†¢/*ŸG** Compare the 19-character string zNum against the text representationŸH** value 2^63:  9223372036854775808.  Return negative, zero, or positiveŸ>** if zNum is less than, equal to, or greater than the string.Ÿ5** Note that zNum must contain exactly 19 characters.¢**ŸF** Unlike memcmp() this routine is guaranteed to return the differenceŸC** in the values of the last digit if the only difference is in theŸ ** last digit.  So, for example,¢**Ÿ/**      compare2pow63("9223372036854775800", 1)¢**≤** will return -8.¢*/Ÿ5static int compare2pow63(const char *zNum, int incr){¨  int c = 0;®  int i;Ÿ,                    /* 012345678901234567 */Ÿ+  const char *pow63 = "922337203685477580";æ  for(i=0; c==0 && i<18; i++){Ÿ#    c = (zNum[i*incr]-pow63[i])*10;£  }≠  if( c==0 ){º    c = zNum[18*incr] - '8';∏    testcase( c==(-1) );µ    testcase( c==0 );∏    testcase( c==(+1) );£  }´  return c;°}†¢/*ŸG** Convert zNum to a 64-bit signed integer.  zNum must be decimal. ThisŸ2** routine does *not* accept hexadecimal notation.¢**´** Returns:¢**ŸH**     0    Successful transformation.  Fits in a 64-bit signed integer.Ÿ9**     1    Excess non-space text after the integer valueŸI**     2    Integer too large for a 64-bit signed integer or is malformedŸ/**     3    Special case of 9223372036854775808¢**ŸG** length is the number of bytes in the string (bytes, not characters).ŸB** The string is not necessarily zero-terminated.  The encoding is∞** given by enc.¢*/ŸRSQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){´  int incr;¨  u64 u = 0;Ÿ$  int neg = 0; /* assume positive */®  int i;¨  int c = 0;ŸM  int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */Ÿ-  int rc;          /* Baseline return code */µ  const char *zStart;Ÿ#  const char *zEnd = zNum + length;ŸK  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );π  if( enc==SQLITE_UTF8 ){≠    incr = 1;®  }else{≠    incr = 2;Ÿ5    assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );Ÿ0    for(i=3-enc; i<length && zNum[i]==0; i+=2){}∂    nonNum = i<length;∂    zEnd = &zNum[i^1];¥    zNum += (enc&1);£  }Ÿ9  while( zNum<zEnd && sqlite3Isspace(*zNum) ) zNum+=incr;≤  if( zNum<zEnd ){µ    if( *zNum=='-' ){Æ      neg = 1;±      zNum+=incr;ª    }else if( *zNum=='+' ){±      zNum+=incr;•    }£  }∞  zStart = zNum;ŸM  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; } /* Skip leading zeros. */ŸA  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){∑    u = u*10 + c - '0';£  }π  testcase( i==18*incr );π  testcase( i==19*incr );π  testcase( i==20*incr );∏  if( u>LARGEST_INT64 ){ŸF    /* This test and assignment is needed only to suppress UB warningsŸJ    ** from clang and -fsanitize=undefined.  This test and assignment makeŸK    ** the code a little larger and slower, and no harm comes from omittingŸE    ** them, but we must appaise the undefined-behavior pharisees. */Ÿ1    *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;≤  }else if( neg ){¥    *pNum = -(i64)u;®  }else{≥    *pNum = (i64)u;£  }©  rc = 0;Ÿ0  if( (i==0 && zStart==zNum)     /* No digits */ŸK   || nonNum                     /* UTF16 with high-order bytes non-zero */§  ){´    rc = 1;Ÿ=  }else if( &zNum[i]<zEnd ){     /* Extra bytes at the end */Ø    int jj = i;ß    do{Ÿ&      if( !sqlite3Isspace(zNum[jj]) ){ŸE        rc = 1;          /* Extra non-space text after the integer */Æ        break;ß      }±      jj += incr;Ω    }while( &zNum[jj]<zEnd );£  }≤  if( i<19*incr ){ŸA    /* Less than 19 digits, so we know that it fits in 64 bits */ø    assert( u<=LARGEST_INT64 );Æ    return rc;®  }else{ŸN    /* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */Ÿ2    c = i>19*incr ? 1 : compare2pow63(zNum, incr);Æ    if( c<0 ){Ÿ<      /* zNum is less than 9223372036854775808 so it fits */Ÿ!      assert( u<=LARGEST_INT64 );∞      return rc;™    }else{Ÿ3      *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;∞      if( c>0 ){ŸF        /* zNum is greater than 9223372036854775808 so it overflows */±        return 2;¨      }else{ŸG        /* zNum is exactly 9223372036854775808.  Fits if negative.  TheŸ1        ** special case 2 overflow if positive */Ÿ%        assert( u-1==LARGEST_INT64 );º        return neg ? rc : 3;ß      }•    }£  }°}†¢/*ŸG** Transform a UTF-8 integer literal, in either decimal or hexadecimal,ŸL** into a 64-bit signed integer.  This routine accepts hexadecimal literals,Ÿ$** whereas sqlite3Atoi64() does not.¢**´** Returns:¢**ŸH**     0    Successful transformation.  Fits in a 64-bit signed integer.Ÿ/**     1    Excess text after the integer valueŸI**     2    Integer too large for a 64-bit signed integer or is malformedŸ/**     3    Special case of 9223372036854775808¢*/ŸBSQLITE_PRIVATE int sqlite3DecOrHexToI64(const char *z, i64 *pOut){ø#ifndef SQLITE_OMIT_HEX_INTEGERØ  if( z[0]=='0'æ   && (z[1]=='x' || z[1]=='X')§  ){Æ    u64 u = 0;≠    int i, k;æ    for(i=2; z[i]=='0'; i++){}Ÿ)    for(k=i; sqlite3Isxdigit(z[k]); k++){Ÿ'      u = u*16 + sqlite3HexToInt(z[k]);•    }∏    memcpy(pOut, &u, 8);Ÿ(    return (z[k]==0 && k-i<=16) ? 0 : 2;ß  }elseŸ$#endif /* SQLITE_OMIT_HEX_INTEGER */£  {ŸC    return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), SQLITE_UTF8);£  }°}†¢/*ŸC** If zNum represents an integer that will fit in 32-bits, then setŸD** *pValue to that integer and return true.  Otherwise return false.¢**ŸK** This routine accepts both decimal and hexadecimal notation for integers.¢**Ÿ>** Any non-numeric characters that following zNum are ignored.Ÿ<** This is different from sqlite3Atoi64() which requires theŸ&** input number to be zero-terminated.¢*/ŸBSQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){µ  sqlite_int64 v = 0;´  int i, c;Æ  int neg = 0;µ  if( zNum[0]=='-' ){¨    neg = 1;´    zNum++;ª  }else if( zNum[0]=='+' ){´    zNum++;£  }ø#ifndef SQLITE_OMIT_HEX_INTEGER∑  else if( zNum[0]=='0'Ÿ)        && (zNum[1]=='x' || zNum[1]=='X')Ÿ#        && sqlite3Isxdigit(zNum[2])§  ){Æ    u32 u = 0;Æ    zNum += 2;Ÿ!    while( zNum[0]=='0' ) zNum++;Ÿ3    for(i=0; sqlite3Isxdigit(zNum[i]) && i<8; i++){Ÿ*      u = u*16 + sqlite3HexToInt(zNum[i]);•    }Ÿ;    if( (u&0x80000000)==0 && sqlite3Isxdigit(zNum[i])==0 ){º      memcpy(pValue, &u, 4);Ø      return 1;™    }else{Ø      return 0;•    }£  }¶#endifŸ*  if( !sqlite3Isdigit(zNum[0]) ) return 0;ø  while( zNum[0]=='0' ) zNum++;Ÿ8  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){±    v = v*10 + c;£  }†ŸI  /* The longest decimal representation of a 32 bit integer is 10 digits:§  **ª  **             1234567890ª  **     2^31 -> 2147483648§  */¥  testcase( i==10 );≠  if( i>10 ){≠    return 0;£  }Ÿ   testcase( v-neg==2147483647 );π  if( v-neg>2147483647 ){≠    return 0;£  }¨  if( neg ){´    v = -v;£  }≥  *pValue = (int)v;´  return 1;°}†¢/*ŸA** Return a 32-bit integer value extracted from a string.  If theŸ+** string is not an integer, just return 0.¢*/Ÿ.SQLITE_PRIVATE int sqlite3Atoi(const char *z){¨  int x = 0;Ÿ!  if( z ) sqlite3GetInt32(z, &x);´  return x;°}†¢/*Ÿ6** The variable-length integer encoding is as follows:¢**ß** KEY:Ÿ:**         A = 0xxxxxxx    7 bits of data and one flag bitŸ:**         B = 1xxxxxxx    7 bits of data and one flag bitŸ)**         C = xxxxxxxx    8 bits of data¢**Æ**  7 bits - AØ** 14 bits - BA∞** 21 bits - BBA±** 28 bits - BBBA≤** 35 bits - BBBBA≥** 42 bits - BBBBBA¥** 49 bits - BBBBBBAµ** 56 bits - BBBBBBBA∂** 64 bits - BBBBBBBBC¢*/†¢/*ŸE** Write a 64-bit variable-length integer to memory starting at p[0].ŸF** The length of data write will be between 1 and 9 bytes.  The numberŸ ** of bytes written is returned.¢**ŸF** A variable-length integer consists of the lower 7 bits of each byteŸD** for all bytes that have the 8th bit set and one byte with the 8thŸD** bit clear.  Except, if we get to the 9th byte, it stores the fullø** 8 bits and is the last byte.¢*/Ÿ@static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){Æ  int i, j, n;≠  u8 buf[10];Ÿ$  if( v & (((u64)0xff000000)<<32) ){±    p[8] = (u8)v;¨    v >>= 8;∏    for(i=7; i>=0; i--){Ÿ%      p[i] = (u8)((v & 0x7f) | 0x80);Æ      v >>= 7;•    }≠    return 9;ß  }    ®  n = 0;•  do{Ÿ'    buf[n++] = (u8)((v & 0x7f) | 0x80);¨    v >>= 7;±  }while( v!=0 );±  buf[0] &= 0x7f;±  assert( n<=9 );Ÿ"  for(i=0, j=n-1; j>=0; j--, i++){≤    p[i] = buf[j];£  }´  return n;°}Ÿ=SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){∞  if( v<=0x7f ){≤    p[0] = v&0x7f;≠    return 1;£  }≤  if( v<=0x3fff ){æ    p[0] = ((v>>7)&0x7f)|0x80;≤    p[1] = v&0x7f;≠    return 2;£  }∫  return putVarint64(p,v);°}†¢/*ŸD** Bitmasks used by sqlite3GetVarint().  These precomputed constantsŸG** are defined here rather than simply putting the constant expressionsŸ;** inline in order to work around bugs in the RVT compiler.¢**Ÿ-** SLOT_2_0     A mask for  (0x7f<<14) | 0x7f¢**Ÿ1** SLOT_4_2_0   A mask for  (0x7f<<28) | SLOT_2_0¢*/ø#define SLOT_2_0     0x001fc07fø#define SLOT_4_2_0   0xf01fc07f††¢/*ŸF** Read a 64-bit variable-length integer from memory starting at p[0].Ÿ?** Return the number of bytes read.  The value is stored in *v.¢*/ŸCSQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){¨  u32 a,b,s;†©  a = *p;∏  /* a: p0 (unmasked) */∞  if (!(a&0x80))£  {´    *v = a;≠    return 1;£  }†¶  p++;©  b = *p;∏  /* b: p1 (unmasked) */∞  if (!(b&0x80))£  {Æ    a &= 0x7f;≠    a = a<<7;´    a |= b;´    *v = a;≠    return 2;£  }†Ÿ7  /* Verify that constants are precomputed correctly */Ÿ.  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );Ÿ=  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );†¶  p++;¨  a = a<<14;™  a |= *p;Ÿ!  /* a: p0<<14 | p2 (unmasked) */∞  if (!(a&0x80))£  {≤    a &= SLOT_2_0;Æ    b &= 0x7f;≠    b = b<<7;´    a |= b;´    *v = a;≠    return 3;£  }†∑  /* CSE1 from below */∞  a &= SLOT_2_0;¶  p++;¨  b = b<<14;™  b |= *p;Ÿ!  /* b: p1<<14 | p3 (unmasked) */∞  if (!(b&0x80))£  {≤    b &= SLOT_2_0;∑    /* moved CSE1 up */Ÿ!    /* a &= (0x7f<<14)|(0x7f); */≠    a = a<<7;´    a |= b;´    *v = a;≠    return 4;£  }†ø  /* a: p0<<14 | p2 (masked) */Ÿ!  /* b: p1<<14 | p3 (unmasked) */Ÿ8  /* 1:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */µ  /* moved CSE1 up */ø  /* a &= (0x7f<<14)|(0x7f); */∞  b &= SLOT_2_0;®  s = a;ø  /* s: p0<<14 | p2 (masked) */†¶  p++;¨  a = a<<14;™  a |= *p;Ÿ*  /* a: p0<<28 | p2<<14 | p4 (unmasked) */∞  if (!(a&0x80))£  {ŸA    /* we can skip these cause they were (effectively) done aboveΩ    ** while calculating s */Ÿ,    /* a &= (0x7f<<28)|(0x7f<<14)|(0x7f); */Ÿ!    /* b &= (0x7f<<14)|(0x7f); */≠    b = b<<7;´    a |= b;Æ    s = s>>18;∫    *v = ((u64)s)<<32 | a;≠    return 5;£  }†Ÿ8  /* 2:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */´  s = s<<7;©  s |= b;Ÿ0  /* s: p0<<21 | p1<<14 | p2<<7 | p3 (masked) */†¶  p++;¨  b = b<<14;™  b |= *p;Ÿ*  /* b: p1<<28 | p3<<14 | p5 (unmasked) */∞  if (!(b&0x80))£  {ŸN    /* we can skip this cause it was (effectively) done above in calc'ing s */Ÿ,    /* b &= (0x7f<<28)|(0x7f<<14)|(0x7f); */≤    a &= SLOT_2_0;≠    a = a<<7;´    a |= b;Æ    s = s>>18;∫    *v = ((u64)s)<<32 | a;≠    return 6;£  }†¶  p++;¨  a = a<<14;™  a |= *p;Ÿ*  /* a: p2<<28 | p4<<14 | p6 (unmasked) */∞  if (!(a&0x80))£  {¥    a &= SLOT_4_2_0;≤    b &= SLOT_2_0;≠    b = b<<7;´    a |= b;Æ    s = s>>11;∫    *v = ((u64)s)<<32 | a;≠    return 7;£  }†∑  /* CSE2 from below */∞  a &= SLOT_2_0;¶  p++;¨  b = b<<14;™  b |= *p;Ÿ*  /* b: p3<<28 | p5<<14 | p7 (unmasked) */∞  if (!(b&0x80))£  {¥    b &= SLOT_4_2_0;∑    /* moved CSE2 up */Ÿ!    /* a &= (0x7f<<14)|(0x7f); */≠    a = a<<7;´    a |= b;≠    s = s>>4;∫    *v = ((u64)s)<<32 | a;≠    return 8;£  }†¶  p++;¨  a = a<<15;™  a |= *p;Ÿ*  /* a: p4<<29 | p6<<15 | p8 (unmasked) */†µ  /* moved CSE2 up */Ÿ*  /* a &= (0x7f<<29)|(0x7f<<15)|(0xff); */∞  b &= SLOT_2_0;´  b = b<<8;©  a |= b;†´  s = s<<4;¨  b = p[-4];¨  b &= 0x7f;´  b = b>>3;©  s |= b;†∏  *v = ((u64)s)<<32 | a;†´  return 9;°}†¢/*ŸF** Read a 32-bit variable-length integer from memory starting at p[0].Ÿ?** Return the number of bytes read.  The value is stored in *v.¢**ŸK** If the varint stored in p[0] is larger than can fit in a 32-bit unsignedŸ&** integer, then set *v to 0xffffffff.¢**Ÿ?** A MACRO version, getVarint32, is provided which inlines the Ÿ?** single-byte case.  All code should use the MACRO version as ŸG** this function assumes the single-byte case has already been handled.¢*/ŸESQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){™  u32 a,b;†ŸF  /* The 1-byte case.  Overwhelmingly the most common.  Handled inlineŸ!  ** by the getVarin32() macro */©  a = *p;∏  /* a: p0 (unmasked) */≥#ifndef getVarint32∞  if (!(a&0x80))£  {Ÿ"    /* Values between 0 and 127 */´    *v = a;≠    return 1;£  }¶#endif†∑  /* The 2-byte case */¶  p++;©  b = *p;∏  /* b: p1 (unmasked) */∞  if (!(b&0x80))£  {Ÿ&    /* Values between 128 and 16383 */Æ    a &= 0x7f;≠    a = a<<7;Ø    *v = a | b;≠    return 2;£  }†∑  /* The 3-byte case */¶  p++;¨  a = a<<14;™  a |= *p;Ÿ!  /* a: p0<<14 | p2 (unmasked) */∞  if (!(a&0x80))£  {Ÿ*    /* Values between 16384 and 2097151 */ª    a &= (0x7f<<14)|(0x7f);Æ    b &= 0x7f;≠    b = b<<7;Ø    *v = a | b;≠    return 3;£  }†ŸA  /* A 32-bit varint is used to store size information in btrees.ŸB  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.ŸC  ** A 3-byte varint is sufficient, for example, to record the sizeŸ&  ** of a 1048569-byte BLOB or string.§  **ŸB  ** We only unroll the first 1-, 2-, and 3- byte cases.  The veryŸA  ** rare larger cases can be handled by the slower 64-bit varint≠  ** routine.§  */•#if 1£  {¨    u64 v64;©    u8 n;†´    p -= 2;Ÿ"    n = sqlite3GetVarint(p, &v64);∫    assert( n>3 && n<=9 );Ÿ&    if( (v64 & SQLITE_MAX_U32)!=v64 ){∂      *v = 0xffffffff;™    }else{¥      *v = (u32)v64;•    }≠    return n;£  }†•#elseŸB  /* For following code (kept for historical record only) shows anŸ@  ** unrolling for the 3- and 4-byte varint cases.  This code isŸD  ** slightly faster, but it is also larger and much harder to test.§  */¶  p++;¨  b = b<<14;™  b |= *p;Ÿ!  /* b: p1<<14 | p3 (unmasked) */∞  if (!(b&0x80))£  {Ÿ.    /* Values between 2097152 and 268435455 */ª    b &= (0x7f<<14)|(0x7f);ª    a &= (0x7f<<14)|(0x7f);≠    a = a<<7;Ø    *v = a | b;≠    return 4;£  }†¶  p++;¨  a = a<<14;™  a |= *p;Ÿ*  /* a: p0<<28 | p2<<14 | p4 (unmasked) */∞  if (!(a&0x80))£  {Ÿ3    /* Values  between 268435456 and 34359738367 */¥    a &= SLOT_4_2_0;¥    b &= SLOT_4_2_0;≠    b = b<<7;Ø    *v = a | b;≠    return 5;£  }†ŸA  /* We can only reach this point when reading a corrupt databaseŸF  ** file.  In that case we are not in any hurry.  Use the (relativelyŸD  ** slow) general-purpose sqlite3GetVarint() routine to extract theÆ  ** value. */£  {¨    u64 v64;©    u8 n;†´    p -= 4;Ÿ"    n = sqlite3GetVarint(p, &v64);∫    assert( n>5 && n<=9 );≤    *v = (u32)v64;≠    return n;£  }¶#endif°}†¢/*ŸD** Return the number of bytes that will be needed to store the given≤** 64-bit integer.¢*/Ÿ+SQLITE_PRIVATE int sqlite3VarintLen(u64 v){®  int i;Ÿ0  for(i=1; (v >>= 7)!=0; i++){ assert( i<10 ); }´  return i;°}††¢/*Ÿ6** Read or write a four-byte big-endian integer value.¢*/Ÿ0SQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p){∫#if SQLITE_BYTEORDER==4321®  u32 x;±  memcpy(&x,p,4);´  return x;Ÿ4#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000®  u32 x;±  memcpy(&x,p,4);æ  return __builtin_bswap32(x);Ÿ2#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300®  u32 x;±  memcpy(&x,p,4);º  return _byteswap_ulong(x);•#else∏  testcase( p[0]&0x80 );Ÿ>  return ((unsigned)p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];¶#endif°}Ÿ=SQLITE_PRIVATE void sqlite3Put4byte(unsigned char *p, u32 v){∫#if SQLITE_BYTEORDER==4321±  memcpy(p,&v,4);Ÿ4#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000ø  u32 x = __builtin_bswap32(v);±  memcpy(p,&x,4);Ÿ2#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300Ω  u32 x = _byteswap_ulong(v);±  memcpy(p,&x,4);•#elseµ  p[0] = (u8)(v>>24);µ  p[1] = (u8)(v>>16);¥  p[2] = (u8)(v>>8);Ø  p[3] = (u8)v;¶#endif°}†††¢/*Ÿ2** Translate a single byte of Hex into an integer.Ÿ=** This routine only works if h really is a valid hexadecimalª** character:  0..9a..fA..F¢*/Ÿ)SQLITE_PRIVATE u8 sqlite3HexToInt(int h){ŸM  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );≥#ifdef SQLITE_ASCII¥  h += 9*(1&(h>>6));¶#endif¥#ifdef SQLITE_EBCDICµ  h += 9*(1&~(h>>4));¶#endif∑  return (u8)(h & 0xf);°}†ŸC#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC)¢/*ŸA** Convert a BLOB literal of the form "x'hhhhhh'" into its binaryŸC** value.  Return a pointer to its binary value.  Space to hold theŸB** binary value has been obtained from malloc and must be freed by∑** the calling routine.¢*/ŸISQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){Æ  char *zBlob;®  int i;†Ÿ4  zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);¶  n--;Æ  if( zBlob ){∏    for(i=0; i<n; i+=2){ŸH      zBlob[i/2] = (sqlite3HexToInt(z[i])<<4) | sqlite3HexToInt(z[i+1]);•    }≥    zBlob[i/2] = 0;£  }Ø  return zBlob;°}Ÿ:#endif /* !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */†¢/*ŸG** Log an error that is an API call on a connection pointer that shouldŸH** not have been used.  The "type" of connection pointer is given as theŸG** argument.  The zType is a word like "NULL" or "closed" or "invalid".¢*/Ÿ0static void logBadConnection(const char *zType){Ω  sqlite3_log(SQLITE_MISUSE, Ÿ4     "API call with %s database connection pointer",™     zType§  );°}†¢/*ŸC** Check to make sure we have a valid db pointer.  This test is notŸC** foolproof but it does provide some measure of protection againstŸB** misuse of the interface such as passing in db pointers that areŸF** NULL or which have been previously closed.  If this routine returnsŸD** 1 it means that the db pointer is valid and 0 if it should not beŸC** dereferenced for any reason.  The calling function should invokeΩ** SQLITE_MISUSE immediately.¢**ŸC** sqlite3SafetyCheckOk() requires that the db pointer be valid forŸH** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed toŸ@** open properly and is not fit for general use but which can beŸ>** used as an argument to sqlite3_errmsg() or sqlite3_close().¢*/Ÿ5SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db){¨  u32 magic;Æ  if( db==0 ){Ω    logBadConnection("NULL");≠    return 0;£  }¥  magic = db->magic;Ÿ!  if( magic!=SQLITE_MAGIC_OPEN ){Ÿ)    if( sqlite3SafetyCheckSickOrOk(db) ){Ÿ.      testcase( sqlite3GlobalConfig.xLog!=0 );Ÿ#      logBadConnection("unopened");•    }≠    return 0;®  }else{≠    return 1;£  }°}Ÿ;SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db){¨  u32 magic;¥  magic = db->magic;Ÿ!  if( magic!=SQLITE_MAGIC_SICK &&Ÿ!      magic!=SQLITE_MAGIC_OPEN &&Ÿ!      magic!=SQLITE_MAGIC_BUSY ){Ÿ,    testcase( sqlite3GlobalConfig.xLog!=0 );Ÿ     logBadConnection("invalid");≠    return 0;®  }else{≠    return 1;£  }°}†¢/*ŸL** Attempt to add, substract, or multiply the 64-bit signed value iB againstŸF** the other 64-bit signed integer at *pA and store the result in *pA.ŸF** Return 0 on success.  Or if the operation would have resulted in anŸ.** overflow, leave *pA unchanged and return 1.¢*/Ÿ4SQLITE_PRIVATE int sqlite3AddInt64(i64 *pA, i64 iB){Ÿ6#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)Ÿ-  return __builtin_add_overflow(*pA, iB, pA);•#elseØ  i64 iA = *pA;Ÿ'  testcase( iA==0 ); testcase( iA==1 );Ÿ(  testcase( iB==-1 ); testcase( iB==0 );Æ  if( iB>=0 ){Ÿ1    testcase( iA>0 && LARGEST_INT64 - iA == iB );Ÿ5    testcase( iA>0 && LARGEST_INT64 - iA == iB - 1 );Ÿ3    if( iA>0 && LARGEST_INT64 - iA < iB ) return 1;®  }else{Ÿ8    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 1 );Ÿ8    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 2 );Ÿ:    if( iA<0 && -(iA + LARGEST_INT64) > iB + 1 ) return 1;£  }¨  *pA += iB;¨  return 0; ¶#endif°}Ÿ4SQLITE_PRIVATE int sqlite3SubInt64(i64 *pA, i64 iB){Ÿ6#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)Ÿ-  return __builtin_sub_overflow(*pA, iB, pA);•#elseŸ#  testcase( iB==SMALLEST_INT64+1 );ª  if( iB==SMALLEST_INT64 ){Ÿ2    testcase( (*pA)==(-1) ); testcase( (*pA)==0 );º    if( (*pA)>=0 ) return 1;Æ    *pA -= iB;≠    return 0;®  }else{Ÿ$    return sqlite3AddInt64(pA, -iB);£  }¶#endif°}Ÿ4SQLITE_PRIVATE int sqlite3MulInt64(i64 *pA, i64 iB){Ÿ6#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)Ÿ-  return __builtin_mul_overflow(*pA, iB, pA);•#elseØ  i64 iA = *pA;≠  if( iB>0 ){Ÿ'    if( iA>LARGEST_INT64/iB ) return 1;Ÿ(    if( iA<SMALLEST_INT64/iB ) return 1;≥  }else if( iB<0 ){Ø    if( iA>0 ){Ÿ*      if( iB<SMALLEST_INT64/iA ) return 1;µ    }else if( iA<0 ){Ÿ(      if( iB==SMALLEST_INT64 ) return 1;Ÿ(      if( iA==SMALLEST_INT64 ) return 1;Ÿ+      if( -iA>LARGEST_INT64/-iB ) return 1;•    }£  }Æ  *pA = iA*iB;´  return 0;¶#endif°}†¢/*ŸK** Compute the absolute value of a 32-bit signed integer, of possible.  Or Ÿ@** if the integer has a value of -2147483648, return +2147483647¢*/Ÿ*SQLITE_PRIVATE int sqlite3AbsInt32(int x){∂  if( x>=0 ) return x;Ÿ-  if( x==(int)0x80000000 ) return 0x7fffffff;¨  return -x;°}†æ#ifdef SQLITE_ENABLE_8_3_NAMES¢/*ŸH** If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the databaseŸJ** filename in zBaseFilename is a URI with the "8_3_names=1" parameter andŸK** if filename in z[] has a suffix (a.k.a. "extension") that is longer thanŸH** three characters, then shorten the suffix on z[] to be the last threeŸ%** characters of the original suffix.¢**ŸF** If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then alwaysŸ8** do the suffix shortening regardless of URI parameter.¢**¨** Examples:¢**Ÿ'**     test.db-journal    =>   test.nalŸ'**     test.db-wal        =>   test.walŸ'**     test.db-shm        =>   test.shmŸ'**     test.db-mj7f3319fa =>   test.9fa¢*/ŸKSQLITE_PRIVATE void sqlite3FileSuffix3(const char *zBaseFilename, char *z){Ω#if SQLITE_ENABLE_8_3_NAMES<2Ÿ:  if( sqlite3_uri_boolean(zBaseFilename, "8_3_names", 0) )¶#endif£  {Æ    int i, sz;º    sz = sqlite3Strlen30(z);Ÿ5    for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}ŸD    if( z[i]=='.' && ALWAYS(sz>i+4) ) memmove(&z[i+1], &z[sz-3], 4);£  }°}¶#endif†£/* ŸG** Find (an approximate) sum of two LogEst values.  This computation isŸF** not a simple "+" operator because LogEst is stored as a logarithmic©** value.£** ¢*/Ÿ;SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst a, LogEst b){Ÿ$  static const unsigned char x[] = {Ÿ.     10, 10,                         /* 0,1 */Ÿ.      9, 9,                          /* 2,3 */Ÿ.      8, 8,                          /* 4,5 */Ÿ0      7, 7, 7,                       /* 6,7,8 */Ÿ2      6, 6, 6,                       /* 9,10,11 */Ÿ0      5, 5, 5,                       /* 12-14 */Ÿ0      4, 4, 4, 4,                    /* 15-18 */Ÿ0      3, 3, 3, 3, 3, 3,              /* 19-24 */Ÿ0      2, 2, 2, 2, 2, 2, 2,           /* 25-31 */§  };≠  if( a>=b ){∫    if( a>b+49 ) return a;º    if( a>b+31 ) return a+1;¥    return a+x[a-b];®  }else{∫    if( b>a+49 ) return b;º    if( b>a+31 ) return b+1;¥    return b+x[b-a];£  }°}†¢/*Ÿ@** Convert an integer into a LogEst.  In other words, compute anŸ ** approximation for 10*log2(x).¢*/Ÿ+SQLITE_PRIVATE LogEst sqlite3LogEst(u64 x){Ÿ1  static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };∞  LogEst y = 40;¨  if( x<8 ){∑    if( x<2 ) return 0;Ÿ&    while( x<8 ){  y -= 10; x <<= 1; }®  }else{∏#if GCC_VERSION>=5004000Ÿ$    int i = 60 - __builtin_clzll(x);Æ    y += i*10;¨    x >>= i;•#elseŸA    while( x>255 ){ y += 40; x >>= 4; }  /*OPTIMIZATION-IF-TRUE*/Ÿ'    while( x>15 ){  y += 10; x >>= 1; }¶#endif£  }π  return a[x&7] + y - 10;°}†Ÿ #ifndef SQLITE_OMIT_VIRTUALTABLE¢/*Ÿ!** Convert a double into a LogEstŸ;** In other words, compute an approximation for 10*log2(x).¢*/Ÿ8SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x){®  u64 a;´  LogEst e;Ÿ)  assert( sizeof(x)==8 && sizeof(a)==8 );∂  if( x<=1 ) return 0;Ÿ3  if( x<=2000000000 ) return sqlite3LogEst((u64)x);¥  memcpy(&a, &x, 8);µ  e = (a>>52) - 1022;Æ  return e*10;°}Ÿ%#endif /* SQLITE_OMIT_VIRTUALTABLE */†Ÿ/#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \Ÿ.    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \Ÿ*    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)¢/*Ÿ$** Convert a LogEst into an integer.¢**ŸB** Note that this routine is only used when one or more of variousŸ0** non-standard compile-time options is enabled.¢*/Ÿ0SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst x){®  u64 n;´  n = x%10;™  x /= 10;¥  if( n>=5 ) n -= 2;π  else if( n>=1 ) n -= 1;Ÿ/#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \Ÿ*    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)Ÿ'  if( x>60 ) return (u64)LARGEST_INT64;•#elseŸG  /* If only SQLITE_ENABLE_STAT3_OR_STAT4 is on, then the largest inputŸG  ** possible to this routine is 310, resulting in a maximum x of 31 */≤  assert( x<=60 );¶#endifŸ,  return x>=3 ? (n+8)<<(x-3) : (n+8)>>(3-x);°}Ÿ8#endif /* defined SCANSTAT or STAT4 or ESTIMATED_ROWS */†¢/*ŸF** Add a new name/number pair to a VList.  This might require that theŸC** VList object be reallocated, so return the new VList.  If an OOMŸ4** error occurs, the original VList returned and theŸ ** db->mallocFailed flag is set.¢**ŸD** A VList is really just an array of integers.  To destroy a VList,Ÿ%** simply pass it to sqlite3DbFree().¢**ŸF** The first integer is the number of integers allocated for the wholeŸF** VList.  The second integer is the number of integers actually used.ŸE** Each name/number pair is encoded by subsequent groups of 3 or more¨** integers.¢**ŸG** Each name/number pair starts with two integers which are the numericŸI** value for the pair and the size of the name/number pair, respectively.ŸH** The text name overlays one or more following integers.  The text nameΩ** is always zero-terminated.¢**∞** Conceptually:¢**¥**    struct VList {Ÿ3**      int nAlloc;   // Number of allocated slots Ÿ.**      int nUsed;    // Number of used slots ª**      struct VListEntry {Ÿ0**        int iValue;    // Value for this entryŸ4**        int nSlot;     // Slots used by this entryŸ(**        // ... variable name goes hereØ**      } a[0];ß**    }¢**ŸD** During code generation, pointers to the variable names within theŸD** VList are taken.  When that happens, nAlloc is set to zero as an ŸC** indication that the VList may never again be enlarged, since theŸ8** accompanying realloc() would invalidate the pointers.¢*/Ÿ&SQLITE_PRIVATE VList *sqlite3VListAdd(ŸH  sqlite3 *db,           /* The database connection used for malloc() */Ÿ>  VList *pIn,            /* The input VList.  Might be NULL */Ÿ4  const char *zName,     /* Name of symbol to add */Ÿ5  int nName,             /* Bytes of text in zName */Ÿ<  int iVal               /* Value to associate with zName */¢){ŸM  int nInt;              /* number of sizeof(int) objects needed for zName */ŸD  char *z;               /* Pointer to where zName will be stored */ŸC  int i;                 /* Index in pIn[] where zName is stored */†µ  nInt = nName/4 + 3;ŸE  assert( pIn==0 || pIn[0]>=3 );  /* Verify ok to add new elements */Ÿ'  if( pIn==0 || pIn[1]+nInt > pIn[0] ){Ÿ     /* Enlarge the allocation */Ÿ.    int nAlloc = (pIn ? pIn[0]*2 : 10) + nInt;Ÿ@    VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));Ω    if( pOut==0 ) return pIn;Ω    if( pIn==0 ) pOut[1] = 2;Ø    pIn = pOut;¥    pIn[0] = nAlloc;£  }≠  i = pIn[1];∞  pIn[i] = iVal;≤  pIn[i+1] = nInt;∑  z = (char*)&pIn[i+2];≤  pIn[1] = i+nInt;ª  assert( pIn[1]<=pIn[0] );∫  memcpy(z, zName, nName);Ø  z[nName] = 0;≠  return pIn;°}†¢/*ŸE** Return a pointer to the name of a variable in the given VList thatŸH** has the value iVal.  Or return a NULL if there is no such variable in´** the list¢*/ŸGSQLITE_PRIVATE const char *sqlite3VListNumToName(VList *pIn, int iVal){¨  int i, mx;∏  if( pIn==0 ) return 0;Æ  mx = pIn[1];®  i = 2;•  do{Ÿ/    if( pIn[i]==iVal ) return (char*)&pIn[i+2];≤    i += pIn[i+1];±  }while( i<mx );´  return 0;°}†¢/*ŸD** Return the number of the variable named zName, if it is in VList.Ÿ,** or return 0 if there is no such variable.¢*/ŸSSQLITE_PRIVATE int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){¨  int i, mx;∏  if( pIn==0 ) return 0;Æ  mx = pIn[1];®  i = 2;•  do{Ÿ+    const char *z = (const char*)&pIn[i+2];ŸA    if( strncmp(z,zName,nName)==0 && z[nName]==0 ) return pIn[i];≤    i += pIn[i+1];±  }while( i<mx );´  return 0;°}†ŸO/************** End of util.c ************************************************/ŸO/************** Begin file hash.c ********************************************/¢/*¥** 2001 September 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ4** This is the implementation of generic hash-tables≤** used in SQLite.¢*/º/* #include "sqliteInt.h" */π/* #include <assert.h> */†Ÿ@/* Turn bulk memory into a hash table object by initializing theŸ ** fields of the Hash structure.¢**ŸC** "pNew" is a pointer to the hash table that is to be initialized.¢*/Ÿ0SQLITE_PRIVATE void sqlite3HashInit(Hash *pNew){¥  assert( pNew!=0 );≤  pNew->first = 0;≤  pNew->count = 0;≥  pNew->htsize = 0;Ø  pNew->ht = 0;°}†Ÿ=/* Remove all entries from a hash table.  Reclaim all memory.ŸD** Call this routine to delete a hash table or to reset a hash table∂** to the empty state.¢*/Ÿ/SQLITE_PRIVATE void sqlite3HashClear(Hash *pH){ŸJ  HashElem *elem;         /* For looping over all elements of the table */†≤  assert( pH!=0 );≥  elem = pH->first;∞  pH->first = 0;∑  sqlite3_free(pH->ht);≠  pH->ht = 0;±  pH->htsize = 0;∞  while( elem ){Ÿ%    HashElem *next_elem = elem->next;∑    sqlite3_free(elem);µ    elem = next_elem;£  }∞  pH->count = 0;°}†¢/*∏** The hashing function.¢*/Ÿ+static unsigned int strHash(const char *z){µ  unsigned int h = 0;≤  unsigned char c;ŸE  while( (c = (unsigned char)*z++)!=0 ){     /*OPTIMIZATION-IF-TRUE*/ŸD    /* Knuth multiplicative hashing.  (Sorting & Searching, p. 510).ŸD    ** 0x9e3779b1 is 2654435761 which is the closest prime number toŸE    ** (2**32)*golden_ratio, where golden_ratio = (sqrt(5) - 1)/2. */Ÿ     h += sqlite3UpperToLower[c];¥    h *= 0x9e3779b1;£  }´  return h;°}††ŸD/* Link pNew element into the hash table pH.  If pEntry!=0 then alsoŸ+** insert pNew into the pEntry hash bucket.¢*/∫static void insertElement(Ÿ6  Hash *pH,              /* The complete hash table */ŸD  struct _ht *pEntry,    /* The entry into which pNew is inserted */Ÿ9  HashElem *pNew         /* The element to be inserted */¢){Ÿ>  HashElem *pHead;       /* First element already in pEntry */Ø  if( pEntry ){Ÿ.    pHead = pEntry->count ? pEntry->chain : 0;¥    pEntry->count++;π    pEntry->chain = pNew;®  }else{Æ    pHead = 0;£  }Æ  if( pHead ){∑    pNew->next = pHead;Ω    pNew->prev = pHead->prev;Ÿ2    if( pHead->prev ){ pHead->prev->next = pNew; }Ÿ*    else             { pH->first = pNew; }∑    pHead->prev = pNew;®  }else{ª    pNew->next = pH->first;Ÿ.    if( pH->first ){ pH->first->prev = pNew; }≥    pNew->prev = 0;µ    pH->first = pNew;£  }°}††Ÿ@/* Resize the hash table so that it cantains "new_size" buckets.¢**ŸC** The hash table might fail to resize if sqlite3_malloc() fails orŸ1** if the new size is the same as the prior size.Ÿ5** Return TRUE if the resize occurs and false if not.¢*/Ÿ3static int rehash(Hash *pH, unsigned int new_size){Ÿ9  struct _ht *new_ht;            /* The new hash table */ŸI  HashElem *elem, *next_elem;    /* For looping over existing elements */†æ#if SQLITE_MALLOC_SOFT_LIMIT>0Ÿ=  if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){Ÿ;    new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht);£  }Ÿ&  if( new_size==pH->htsize ) return 0;¶#endif†Ÿ@  /* The inability to allocates space for a larger hash table isŸ@  ** a performance hit but it is not a fatal error.  So mark theŸF  ** allocation as a benign. Use sqlite3Malloc()/memset(0) instead of ŸG  ** sqlite3MallocZero() to make the allocation, as sqlite3MallocZero()ŸG  ** only zeroes the requested number of bytes whereas this module willŸG  ** use the actual amount of space allocated for the hash table (whichŸ.  ** may be larger than the requested amount).§  */Ω  sqlite3BeginBenignMalloc();ŸF  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );ª  sqlite3EndBenignMalloc();†ª  if( new_ht==0 ) return 0;∑  sqlite3_free(pH->ht);≤  pH->ht = new_ht;ŸG  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);Ÿ1  memset(new_ht, 0, new_size*sizeof(struct _ht));Ÿ;  for(elem=pH->first, pH->first=0; elem; elem = next_elem){Ÿ4    unsigned int h = strHash(elem->pKey) % new_size;ª    next_elem = elem->next;Ÿ(    insertElement(pH, &new_ht[h], elem);£  }´  return 1;°}†ŸA/* This function (for internal use only) locates an element in anŸB** hash table that matches the given key.  If no element is found,ŸH** a pointer to a static null element with HashElem.data==0 is returned.ŸC** If pH is not NULL, then the hash for this key is written to *pH.¢*/Ÿ%static HashElem *findElementWithHash(Ÿ1  const Hash *pH,     /* The pH to be searched */Ÿ8  const char *pKey,   /* The key we are searching for */Ÿ5  unsigned int *pHash /* Write the hash value here */¢){ŸI  HashElem *elem;                /* Used to loop thru the element list */ŸF  int count;                     /* Number of elements left to test */Ÿ8  unsigned int h;                /* The computed hash */Ÿ/  static HashElem nullElement = { 0, 0, 0, 0 };†Ÿ*  if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/∑    struct _ht *pEntry;Ÿ#    h = strHash(pKey) % pH->htsize;∏    pEntry = &pH->ht[h];π    elem = pEntry->chain;∫    count = pEntry->count;®  }else{™    h = 0;µ    elem = pH->first;∂    count = pH->count;£  }π  if( pHash ) *pHash = h;≥  while( count-- ){∂    assert( elem!=0 );Ÿ.    if( sqlite3StrICmp(elem->pKey,pKey)==0 ){ ≤      return elem;•    }∂    elem = elem->next;£  }∂  return &nullElement;°}†ŸD/* Remove a single entry from the hash table given a pointer to thatŸ+** element and a hash on the element's key.¢*/Ÿ#static void removeElementGivenHash(Ÿ2  Hash *pH,         /* The pH containing "elem" */Ÿ?  HashElem* elem,   /* The element to be removed from the pH */Ÿ4  unsigned int h    /* Hash value for the element */¢){µ  struct _ht *pEntry;≥  if( elem->prev ){Ÿ#    elem->prev->next = elem->next; ®  }else{ª    pH->first = elem->next;£  }≥  if( elem->next ){Ÿ"    elem->next->prev = elem->prev;£  }Ø  if( pH->ht ){∏    pEntry = &pH->ht[h];æ    if( pEntry->chain==elem ){Ÿ!      pEntry->chain = elem->next;•    }¥    pEntry->count--;ø    assert( pEntry->count>=0 );£  }∑  sqlite3_free( elem );Æ  pH->count--;µ  if( pH->count==0 ){ª    assert( pH->first==0 );ª    assert( pH->count==0 );π    sqlite3HashClear(pH);£  }°}†Ÿ?/* Attempt to locate an element of the hash table pH with a keyŸ@** that matches pKey.  Return the data for this element if it isŸ'** found, or NULL if there is no match.¢*/ŸGSQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey){≤  assert( pH!=0 );¥  assert( pKey!=0 );Ÿ0  return findElementWithHash(pH, pKey, 0)->data;°}†Ÿ=/* Insert an element into the hash table pH.  The key is pKey∫** and the data is "data".¢**Ÿ7** If no element exists with a matching key, then a newŸ+** element is created and NULL is returned.¢**Ÿ@** If another element already exists with the same key, then theŸ?** new data replaces the old data and the old data is returned.ŸC** The key is not copied in this instance.  If a malloc fails, thenŸ<** the new data is returned and the hash table is unchanged.¢**Ÿ=** If the "data" parameter to this function is NULL, then theŸA** element corresponding to "key" is removed from the hash table.¢*/ŸOSQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){ŸH  unsigned int h;       /* the hash of the key modulo hash table size */Ÿ@  HashElem *elem;       /* Used to loop thru the element list */Ÿ9  HashElem *new_elem;   /* New element added to the pH */†≤  assert( pH!=0 );¥  assert( pKey!=0 );Ÿ)  elem = findElementWithHash(pH,pKey,&h);≥  if( elem->data ){Ÿ     void *old_data = elem->data;≤    if( data==0 ){Ÿ(      removeElementGivenHash(pH,elem,h);™    }else{∏      elem->data = data;∏      elem->pKey = pKey;•    }¥    return old_data;£  }π  if( data==0 ) return 0;Ÿ:  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );Ÿ   if( new_elem==0 ) return data;∏  new_elem->pKey = pKey;∏  new_elem->data = data;Æ  pH->count++;Ÿ2  if( pH->count>=10 && pH->count > 2*pH->htsize ){Ÿ"    if( rehash(pH, pH->count*2) ){Ω      assert( pH->htsize>0 );Ÿ%      h = strHash(pKey) % pH->htsize;•    }£  }Ÿ7  insertElement(pH, pH->ht ? &pH->ht[h] : 0, new_elem);´  return 0;°}†ŸO/************** End of hash.c ************************************************/ŸO/************** Begin file opcodes.c *****************************************/Ÿ+/* Automatically generated.  Do not edit */Ÿ4/* See the tool/mkopcodec.tcl script for details. */Ÿ##if !defined(SQLITE_OMIT_EXPLAIN) \ª || defined(VDBE_PROFILE) \π || defined(SQLITE_DEBUG)ŸD#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) || defined(SQLITE_DEBUG)π# define OpHelp(X) "\0" X•#else≤# define OpHelp(X)¶#endifŸ4SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){Ÿ& static const char *const azName[] = {Ÿ,    /*   0 */ "Savepoint"        OpHelp(""),Ÿ,    /*   1 */ "AutoCommit"       OpHelp(""),Ÿ,    /*   2 */ "Transaction"      OpHelp(""),Ÿ,    /*   3 */ "SorterNext"       OpHelp(""),Ÿ,    /*   4 */ "PrevIfOpen"       OpHelp(""),Ÿ,    /*   5 */ "NextIfOpen"       OpHelp(""),Ÿ,    /*   6 */ "Prev"             OpHelp(""),Ÿ,    /*   7 */ "Next"             OpHelp(""),Ÿ,    /*   8 */ "Checkpoint"       OpHelp(""),Ÿ,    /*   9 */ "JournalMode"      OpHelp(""),Ÿ,    /*  10 */ "Vacuum"           OpHelp(""),ŸB    /*  11 */ "VFilter"          OpHelp("iplan=r[P3] zplan='P4'"),Ÿ9    /*  12 */ "VUpdate"          OpHelp("data=r[P3@P2]"),Ÿ,    /*  13 */ "Goto"             OpHelp(""),Ÿ,    /*  14 */ "Gosub"            OpHelp(""),Ÿ,    /*  15 */ "InitCoroutine"    OpHelp(""),Ÿ,    /*  16 */ "Yield"            OpHelp(""),Ÿ,    /*  17 */ "MustBeInt"        OpHelp(""),Ÿ,    /*  18 */ "Jump"             OpHelp(""),Ÿ9    /*  19 */ "Not"              OpHelp("r[P2]= !r[P1]"),Ÿ,    /*  20 */ "Once"             OpHelp(""),Ÿ,    /*  21 */ "If"               OpHelp(""),Ÿ,    /*  22 */ "IfNot"            OpHelp(""),ŸR    /*  23 */ "IfNullRow"        OpHelp("if P1.nullRow then r[P3]=NULL, goto P2"),Ÿ8    /*  24 */ "SeekLT"           OpHelp("key=r[P3@P4]"),Ÿ8    /*  25 */ "SeekLE"           OpHelp("key=r[P3@P4]"),Ÿ8    /*  26 */ "SeekGE"           OpHelp("key=r[P3@P4]"),Ÿ8    /*  27 */ "SeekGT"           OpHelp("key=r[P3@P4]"),Ÿ8    /*  28 */ "NoConflict"       OpHelp("key=r[P3@P4]"),Ÿ8    /*  29 */ "NotFound"         OpHelp("key=r[P3@P4]"),Ÿ8    /*  30 */ "Found"            OpHelp("key=r[P3@P4]"),Ÿ8    /*  31 */ "SeekRowid"        OpHelp("intkey=r[P3]"),Ÿ8    /*  32 */ "NotExists"        OpHelp("intkey=r[P3]"),Ÿ,    /*  33 */ "Last"             OpHelp(""),Ÿ,    /*  34 */ "IfSmaller"        OpHelp(""),Ÿ,    /*  35 */ "SorterSort"       OpHelp(""),Ÿ,    /*  36 */ "Sort"             OpHelp(""),Ÿ,    /*  37 */ "Rewind"           OpHelp(""),Ÿ8    /*  38 */ "IdxLE"            OpHelp("key=r[P3@P4]"),Ÿ8    /*  39 */ "IdxGT"            OpHelp("key=r[P3@P4]"),Ÿ8    /*  40 */ "IdxLT"            OpHelp("key=r[P3@P4]"),Ÿ8    /*  41 */ "IdxGE"            OpHelp("key=r[P3@P4]"),Ÿ<    /*  42 */ "RowSetRead"       OpHelp("r[P3]=rowset(P1)"),ŸB    /*  43 */ "Or"               OpHelp("r[P3]=(r[P1] || r[P2])"),ŸB    /*  44 */ "And"              OpHelp("r[P3]=(r[P1] && r[P2])"),ŸJ    /*  45 */ "RowSetTest"       OpHelp("if r[P3] in rowset(P1) goto P2"),Ÿ,    /*  46 */ "Program"          OpHelp(""),ŸC    /*  47 */ "FkIfZero"         OpHelp("if fkctr[P1]==0 goto P2"),ŸN    /*  48 */ "IfPos"            OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),ŸM    /*  49 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]--, goto P2"),ŸB    /*  50 */ "IsNull"           OpHelp("if r[P1]==NULL goto P2"),ŸB    /*  51 */ "NotNull"          OpHelp("if r[P1]!=NULL goto P2"),Ÿ;    /*  52 */ "Ne"               OpHelp("IF r[P3]!=r[P1]"),Ÿ;    /*  53 */ "Eq"               OpHelp("IF r[P3]==r[P1]"),Ÿ:    /*  54 */ "Gt"               OpHelp("IF r[P3]>r[P1]"),Ÿ;    /*  55 */ "Le"               OpHelp("IF r[P3]<=r[P1]"),Ÿ:    /*  56 */ "Lt"               OpHelp("IF r[P3]<r[P1]"),Ÿ;    /*  57 */ "Ge"               OpHelp("IF r[P3]>=r[P1]"),Ÿ,    /*  58 */ "ElseNotEq"        OpHelp(""),ŸC    /*  59 */ "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),Ÿ,    /*  60 */ "IncrVacuum"       OpHelp(""),Ÿ,    /*  61 */ "VNext"            OpHelp(""),Ÿ7    /*  62 */ "Init"             OpHelp("Start at P2"),Ÿ,    /*  63 */ "Return"           OpHelp(""),Ÿ,    /*  64 */ "EndCoroutine"     OpHelp(""),Ÿ>    /*  65 */ "HaltIfNull"       OpHelp("if r[P3]=null halt"),Ÿ,    /*  66 */ "Halt"             OpHelp(""),Ÿ4    /*  67 */ "Integer"          OpHelp("r[P2]=P1"),Ÿ4    /*  68 */ "Int64"            OpHelp("r[P2]=P4"),Ÿ?    /*  69 */ "String"           OpHelp("r[P2]='P4' (len=P1)"),Ÿ:    /*  70 */ "Null"             OpHelp("r[P2..P3]=NULL"),Ÿ6    /*  71 */ "SoftNull"         OpHelp("r[P1]=NULL"),Ÿ=    /*  72 */ "Blob"             OpHelp("r[P2]=P4 (len=P1)"),ŸB    /*  73 */ "Variable"         OpHelp("r[P2]=parameter(P1,P4)"),Ÿ=    /*  74 */ "Move"             OpHelp("r[P2@P3]=r[P1@P3]"),ŸA    /*  75 */ "Copy"             OpHelp("r[P2@P3+1]=r[P1@P3+1]"),Ÿ7    /*  76 */ "SCopy"            OpHelp("r[P2]=r[P1]"),Ÿ7    /*  77 */ "IntCopy"          OpHelp("r[P2]=r[P1]"),Ÿ;    /*  78 */ "ResultRow"        OpHelp("output=r[P1@P2]"),Ÿ,    /*  79 */ "CollSeq"          OpHelp(""),Ÿ:    /*  80 */ "AddImm"           OpHelp("r[P1]=r[P1]+P2"),Ÿ,    /*  81 */ "RealAffinity"     OpHelp(""),Ÿ;    /*  82 */ "Cast"             OpHelp("affinity(r[P1])"),Ÿ,    /*  83 */ "Permutation"      OpHelp(""),Ÿ=    /*  84 */ "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),Ÿ=    /*  85 */ "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),Ÿ>    /*  86 */ "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),Ÿ>    /*  87 */ "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),Ÿ=    /*  88 */ "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),Ÿ=    /*  89 */ "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),Ÿ=    /*  90 */ "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),Ÿ=    /*  91 */ "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),Ÿ=    /*  92 */ "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),Ÿ=    /*  93 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),ŸA    /*  94 */ "Compare"          OpHelp("r[P1@P3] <-> r[P2@P3]"),Ÿ9    /*  95 */ "BitNot"           OpHelp("r[P1]= ~r[P1]"),ŸQ    /*  96 */ "IsTrue"           OpHelp("r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4"),Ÿ6    /*  97 */ "String8"          OpHelp("r[P2]='P4'"),ŸE    /*  98 */ "Offset"           OpHelp("r[P3] = sqlite_offset(P1)"),Ÿ4    /*  99 */ "Column"           OpHelp("r[P3]=PX"),Ÿ>    /* 100 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),ŸA    /* 101 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),Ÿ9    /* 102 */ "Count"            OpHelp("r[P2]=count()"),Ÿ,    /* 103 */ "ReadCookie"       OpHelp(""),Ÿ,    /* 104 */ "SetCookie"        OpHelp(""),Ÿ:    /* 105 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),Ÿ:    /* 106 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),Ÿ:    /* 107 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),Ÿ,    /* 108 */ "OpenDup"          OpHelp(""),Ÿ6    /* 109 */ "OpenAutoindex"    OpHelp("nColumn=P2"),Ÿ6    /* 110 */ "OpenEphemeral"    OpHelp("nColumn=P2"),Ÿ,    /* 111 */ "SorterOpen"       OpHelp(""),ŸJ    /* 112 */ "SequenceTest"     OpHelp("if( cursor[P1].ctr++ ) pc = P2"),Ÿ?    /* 113 */ "OpenPseudo"       OpHelp("P3 columns in r[P2]"),Ÿ,    /* 114 */ "Close"            OpHelp(""),Ÿ,    /* 115 */ "ColumnsUsed"      OpHelp(""),ŸB    /* 116 */ "Sequence"         OpHelp("r[P2]=cursor[P1].ctr++"),Ÿ7    /* 117 */ "NewRowid"         OpHelp("r[P2]=rowid"),ŸC    /* 118 */ "Insert"           OpHelp("intkey=r[P3] data=r[P2]"),Ÿ@    /* 119 */ "InsertInt"        OpHelp("intkey=P3 data=r[P2]"),Ÿ,    /* 120 */ "Delete"           OpHelp(""),Ÿ,    /* 121 */ "ResetCount"       OpHelp(""),ŸN    /* 122 */ "SorterCompare"    OpHelp("if key(P1)!=trim(r[P3],P4) goto P2"),Ÿ6    /* 123 */ "SorterData"       OpHelp("r[P2]=data"),Ÿ6    /* 124 */ "RowData"          OpHelp("r[P2]=data"),Ÿ7    /* 125 */ "Rowid"            OpHelp("r[P2]=rowid"),Ÿ,    /* 126 */ "NullRow"          OpHelp(""),Ÿ,    /* 127 */ "SeekEnd"          OpHelp(""),Ÿ5    /* 128 */ "SorterInsert"     OpHelp("key=r[P2]"),Ÿ5    /* 129 */ "IdxInsert"        OpHelp("key=r[P2]"),Ÿ8    /* 130 */ "IdxDelete"        OpHelp("key=r[P2@P3]"),ŸI    /* 131 */ "DeferredSeek"     OpHelp("Move P3 to P1.rowid if needed"),Ÿ4    /* 132 */ "Real"             OpHelp("r[P2]=P4"),Ÿ7    /* 133 */ "IdxRowid"         OpHelp("r[P2]=rowid"),Ÿ,    /* 134 */ "Destroy"          OpHelp(""),Ÿ,    /* 135 */ "Clear"            OpHelp(""),Ÿ,    /* 136 */ "ResetSorter"      OpHelp(""),ŸF    /* 137 */ "CreateBtree"      OpHelp("r[P2]=root iDb=P1 flags=P3"),Ÿ,    /* 138 */ "SqlExec"          OpHelp(""),Ÿ,    /* 139 */ "ParseSchema"      OpHelp(""),Ÿ,    /* 140 */ "LoadAnalysis"     OpHelp(""),Ÿ,    /* 141 */ "DropTable"        OpHelp(""),Ÿ,    /* 142 */ "DropIndex"        OpHelp(""),Ÿ,    /* 143 */ "DropTrigger"      OpHelp(""),Ÿ,    /* 144 */ "IntegrityCk"      OpHelp(""),Ÿ<    /* 145 */ "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),Ÿ,    /* 146 */ "Param"            OpHelp(""),Ÿ9    /* 147 */ "FkCounter"        OpHelp("fkctr[P1]+=P2"),ŸB    /* 148 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),Ÿd    /* 149 */ "OffsetLimit"      OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),ŸF    /* 150 */ "AggStep0"         OpHelp("accum=r[P3] step(r[P2@P5])"),ŸF    /* 151 */ "AggStep"          OpHelp("accum=r[P3] step(r[P2@P5])"),Ÿ<    /* 152 */ "AggFinal"         OpHelp("accum=r[P1] N=P2"),Ÿ,    /* 153 */ "Expire"           OpHelp(""),ŸC    /* 154 */ "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),Ÿ,    /* 155 */ "VBegin"           OpHelp(""),Ÿ,    /* 156 */ "VCreate"          OpHelp(""),Ÿ,    /* 157 */ "VDestroy"         OpHelp(""),Ÿ,    /* 158 */ "VOpen"            OpHelp(""),Ÿ=    /* 159 */ "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),Ÿ,    /* 160 */ "VRename"          OpHelp(""),Ÿ,    /* 161 */ "Pagecount"        OpHelp(""),Ÿ,    /* 162 */ "MaxPgcnt"         OpHelp(""),Ÿ,    /* 163 */ "PureFunc0"        OpHelp(""),Ÿ@    /* 164 */ "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),Ÿ,    /* 165 */ "PureFunc"         OpHelp(""),Ÿ@    /* 166 */ "Function"         OpHelp("r[P3]=func(r[P2@P5])"),Ÿ,    /* 167 */ "Trace"            OpHelp(""),Ÿ,    /* 168 */ "CursorHint"       OpHelp(""),Ÿ,    /* 169 */ "Noop"             OpHelp(""),Ÿ,    /* 170 */ "Explain"          OpHelp(""),§  };≥  return azName[i];°}¶#endif†ŸO/************** End of opcodes.c *********************************************/ŸO/************** Begin file os_unix.c *****************************************/¢/*Æ** 2004 May 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸL** This file contains the VFS implementation for unix-like operating systemsŸD** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.¢**ŸI** There are actually several different VFS implementations in this file.ŸI** The differences are in the way that file locking is done.  The defaultŸI** implementation uses Posix Advisory Locks.  Alternative implementationsŸI** use flock(), dot-files, various proprietary locking schemas, or simplyΩ** skip locking all together.¢**ŸK** This source file is organized into divisions where the logic for variousŸE** subfunctions is contained within the appropriate division.  PLEASEŸE** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placedŸ9** in the correct division and should be clearly labeled.¢**Ÿ)** The layout of divisions is as follows:¢**Ÿ;**   *  General-purpose declarations and utility functions.Ÿ-**   *  Unique file ID logic used by VxWorks.ŸM**   *  Various locking primitive implementations (all except proxy locking):Ÿ"**      + for Posix Advisory Locksπ**      + for no-op locksº**      + for dot-file locksΩ**      + for flock() lockingŸ2**      + for named semaphore locks (VxWorks only)Ÿ0**      + for AFP filesystem locks (MacOSX only)Ÿ9**   *  sqlite3_file methods not associated with locking.ŸA**   *  Definitions of sqlite3_io_methods objects for all lockingŸ@**      methods plus "finder" functions for each locking method.Ÿ+**   *  sqlite3_vfs method implementations.ŸK**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)ŸB**   *  Definitions of sqlite3_vfs objects for all locking methodsŸG**      plus implementations of sqlite3_os_init() and sqlite3_os_end().¢*/º/* #include "sqliteInt.h" */ŸD#if SQLITE_OS_UNIX              /* This file is used on unix only */†¢/*ŸB** There are various methods for file locking used for concurrency´** control:¢**Ÿ$**   1. POSIX locking (the default),≥**   2. No locking,π**   3. Dot-file locking,∏**   4. flock() locking,ø**   5. AFP locking (OSX only),Ÿ.**   6. Named POSIX semaphores (VXWorks only),Ÿ!**   7. proxy locking. (OSX only)¢**ŸG** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLEŸK** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automaticŸE** selection of the appropriate locking style based on the filesystemŸ#** where the database is located.  ¢*/Ÿ)#if !defined(SQLITE_ENABLE_LOCKING_STYLE)∏#  if defined(__APPLE__)Ÿ)#    define SQLITE_ENABLE_LOCKING_STYLE 1ß#  elseŸ)#    define SQLITE_ENABLE_LOCKING_STYLE 0®#  endif¶#endif†Ÿ4/* Use pread() and pwrite() if they are available */∂#if defined(__APPLE__)µ# define HAVE_PREAD 1∂# define HAVE_PWRITE 1¶#endifŸ3#if defined(HAVE_PREAD64) && defined(HAVE_PWRITE64)±# undef USE_PREAD∂# define USE_PREAD64 1Ÿ1#elif defined(HAVE_PREAD) && defined(HAVE_PWRITE)≥# undef USE_PREAD64¥# define USE_PREAD 1¶#endif†¢/*∫** standard include files.¢*/∂#include <sys/types.h>µ#include <sys/stat.h>≤#include <fcntl.h>∂#include <sys/ioctl.h>≥#include <unistd.h>∑/* #include <time.h> */µ#include <sys/time.h>≤#include <errno.h>Ÿ7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0∂# include <sys/mman.h>¶#endif†ø#if SQLITE_ENABLE_LOCKING_STYLEΩ/* # include <sys/ioctl.h> */∂# include <sys/file.h>∑# include <sys/param.h>Ÿ(#endif /* SQLITE_ENABLE_LOCKING_STYLE */†ŸH#if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \ŸE                           (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))ŸA#  if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \ŸM       && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))æ#    define HAVE_GETHOSTUUID 1ß#  elseŸ)#    warning "gethostuuid() is disabled."®#  endif¶#endif††Æ#if OS_VXWORKSΩ/* # include <sys/ioctl.h> */∑# include <semaphore.h>¥# include <limits.h>∑#endif /* OS_VXWORKS */†Ÿ5#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE∑# include <sys/mount.h>¶#endif†±#ifdef HAVE_UTIME≥# include <utime.h>¶#endif†¢/*Ÿ%** Allowed values of unixFile.fsFlags¢*/Ÿ'#define SQLITE_FSFLAGS_IS_MSDOS     0x1†¢/*ŸF** If we are to be thread-safe, include the pthreads header and defineŸ!** the SQLITE_UNIX_THREADS macro.¢*/µ#if SQLITE_THREADSAFEª/* # include <pthread.h> */æ# define SQLITE_UNIX_THREADS 1¶#endif†¢/*Ÿ/** Default permissions when creating a new file¢*/Ÿ'#ifndef SQLITE_DEFAULT_FILE_PERMISSIONSŸ-# define SQLITE_DEFAULT_FILE_PERMISSIONS 0644¶#endif†¢/*Ÿ3** Default permissions when creating auto proxy dir¢*/Ÿ+#ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONSŸ1# define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755¶#endif†¢/*Ÿ!** Maximum supported path-length.¢*/∏#define MAX_PATHNAME 512†¢/*Ÿ#** Maximum supported symbolic links¢*/ø#define SQLITE_MAX_SYMLINKS 100†Ÿ>/* Always cast the getpid() return type for compatibility withŸ ** kernel modules in VxWorks. */Ÿ##define osGetpid(X) (pid_t)getpid()†¢/*ŸD** Only set the lastErrno if the error code is a real error and not Ÿ<** a normal expected return code of SQLITE_BUSY or SQLITE_OK¢*/ŸB#define IS_LOCK_ERROR(x)  ((x != SQLITE_OK) && (x != SQLITE_BUSY))†∏/* Forward references */ŸLtypedef struct unixShm unixShm;               /* Connection shared memory */ŸJtypedef struct unixShmNode unixShmNode;       /* Shared memory instance */Ÿ=typedef struct unixInodeInfo unixInodeInfo;   /* An i-node */ŸMtypedef struct UnixUnusedFd UnixUnusedFd;     /* An unused file descriptor */†¢/*ŸJ** Sometimes, after a file handle is closed by SQLite, the file descriptorŸK** cannot be closed immediately. In these cases, instances of the followingŸG** structure are used to store the file descriptor while waiting for anŸ+** opportunity to either close or reuse it.¢*/µstruct UnixUnusedFd {Ÿ:  int fd;                   /* File descriptor to close */ŸL  int flags;                /* Flags this file descriptor was opened with */ŸJ  UnixUnusedFd *pNext;      /* Next unused file descriptor on same file */¢};†¢/*ŸJ** The unixFile structure is subclass of sqlite3_file specific to the unix∑** VFS implementations.¢*/Ÿ!typedef struct unixFile unixFile;±struct unixFile {ŸB  sqlite3_io_methods const *pMethod;  /* Always the first entry */ŸN  sqlite3_vfs *pVfs;                  /* The VFS that created this unixFile */ŸJ  unixInodeInfo *pInode;              /* Info about locks on this inode */Ÿ?  int h;                              /* The file descriptor */ŸL  unsigned char eFileLock;            /* The type of lock held on this fd */ŸN  unsigned short int ctrlFlags;       /* Behavioral bits.  UNIXFILE_* flags */ŸN  int lastErrno;                      /* The unix errno from last I/O error */ŸH  void *lockingContext;               /* Locking style specific state */ŸF  UnixUnusedFd *pPreallocatedUnused;  /* Pre-allocated UnixUnusedFd */Ÿ<  const char *zPath;                  /* Name of the file */ŸM  unixShm *pShm;                      /* Shared memory segment information */ŸJ  int szChunk;                        /* Configured by FCNTL_CHUNK_SIZE */∫#if SQLITE_MAX_MMAP_SIZE>0ŸM  int nFetchOut;                      /* Number of outstanding xFetch refs */ŸP  sqlite3_int64 mmapSize;             /* Usable size of mapping at pMapRegion */ŸP  sqlite3_int64 mmapSizeActual;       /* Actual size of mapping at pMapRegion */ŸL  sqlite3_int64 mmapSizeMax;          /* Configured FCNTL_MMAP_SIZE value */Ÿ@  void *pMapRegion;                   /* Memory mapped region */¶#endifŸ>  int sectorSize;                     /* Device sector size */ŸN  int deviceCharacteristics;          /* Precomputed device characteristics */ø#if SQLITE_ENABLE_LOCKING_STYLEŸI  int openFlags;                      /* The flags specified at open() */¶#endifŸ5#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)ŸH  unsigned fsFlags;                   /* cached details from statfs() */¶#endifŸ"#ifdef SQLITE_ENABLE_SETLK_TIMEOUTŸL  unsigned iBusyTimeout;              /* Wait this many millisec on locks */¶#endifÆ#if OS_VXWORKSŸ:  struct vxworksFileId *pId;          /* Unique file ID */¶#endif≥#ifdef SQLITE_DEBUGŸE  /* The next group of variables are used to track whether or not theŸE  ** transaction counter in bytes 24-27 of database files are updatedŸH  ** whenever any part of the database changes.  An assertion fault willŸE  ** occur if a file is updated without also updating the transactionŸE  ** counter.  This test is made to avoid new problems similar to theŸ$  ** one described by ticket #3584. §  */ŸN  unsigned char transCntrChng;   /* True if the transaction counter changed */ŸP  unsigned char dbUpdate;        /* True if any part of database file changed */ŸJ  unsigned char inNormalWrite;   /* True if in a normal write operation */†¶#endif†≤#ifdef SQLITE_TESTŸE  /* In test mode, increase the size of this structure a bit so that Ÿ?  ** it is larger than the struct CrashFile defined in test6.c.§  */¥  char aPadding[32];¶#endif¢};†ŸG/* This variable holds the process id (pid) from when the xRandomness()ŸH** method was called.  If xOpen() is called from a different process id,ŸA** indicating that a fork() has occurred, the PRNG will be reset.¢*/østatic pid_t randomnessPid = 0;†¢/*Ÿ5** Allowed values for the unixFile.ctrlFlags bitmask:¢*/ŸM#define UNIXFILE_EXCL        0x01     /* Connections from one process only */ŸC#define UNIXFILE_RDONLY      0x02     /* Connection is read only */Ÿ?#define UNIXFILE_PERSIST_WAL 0x04     /* Persistent WAL mode */æ#ifndef SQLITE_DISABLE_DIRSYNCŸA# define UNIXFILE_DIRSYNC    0x08     /* Directory sync needed */•#elseŸ!# define UNIXFILE_DIRSYNC    0x00¶#endifŸL#define UNIXFILE_PSOW        0x10     /* SQLITE_IOCAP_POWERSAFE_OVERWRITE */Ÿ;#define UNIXFILE_DELETE      0x20     /* Delete on close */ŸP#define UNIXFILE_URI         0x40     /* Filename might have query parameters */Ÿ>#define UNIXFILE_NOLOCK      0x80     /* Do no file locking */†¢/*Ÿ2** Include code that is common to all os_*.c files¢*/ŸO/************** Include os_common.h in the middle of os_unix.c ***************/ŸO/************** Begin file os_common.h ***************************************/¢/*Æ** 2004 May 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸG** This file contains macros and a little bit of code that is common toŸJ** all of the platform-specific files (os_*.c) and is #included into those©** files.¢**ŸG** This file should be #included by the os_*.c files only.  It is not aø** general purpose header file.¢*/µ#ifndef _OS_COMMON_H_µ#define _OS_COMMON_H_†¢/*ŸH** At least two bugs have slipped in because we changed the MEMORY_DEBUGŸG** macro to SQLITE_DEBUG and some older makefiles have not yet made theŸI** switch.  The following code should catch this problem at compile-time.¢*/≥#ifdef MEMORY_DEBUGŸH# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."¶#endif†¢/*ŸD** Macros for performance tracing.  Normally turned off.  Only works¥** on i486 hardware.¢*/ø#ifdef SQLITE_PERFORMANCE_TRACE†¢/*Ÿ;** hwtime.h contains inline assembler code for implementingŸ$** high-performance timing routines.¢*/ŸO/************** Include hwtime.h in the middle of os_common.h ****************/ŸO/************** Begin file hwtime.h ******************************************/¢/*Æ** 2008 May 27¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸG** This file contains inline asm code for retrieving "high-performance"ø** counters for x86 class CPUs.¢*/∑#ifndef SQLITE_HWTIME_H∑#define SQLITE_HWTIME_H†¢/*ŸK** The following routine only works on pentium-class (or newer) processors.ŸD** It uses the RDTSC opcode to read the cycle count value out of theŸC** processor and returns that value.  This can be used for high-res≠** profiling.¢*/Ÿ1#if (defined(__GNUC__) || defined(_MSC_VER)) && \Ÿ>      (defined(i386) || defined(__i386__) || defined(_M_IX86))†∑  #if defined(__GNUC__)†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){π     unsigned int lo, hi;Ÿ;     __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));Ÿ)     return (sqlite_uint64)hi << 32 | lo;£  }†π  #elif defined(_MSC_VER)†ŸG  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){¨     __asm {≠        rdtscŸ+        ret       ; return value at EDX:EAX¶     }£  }†®  #endif†Ÿ0#elif (defined(__GNUC__) && defined(__x86_64__))†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){∏      unsigned long val;Ÿ2      __asm__ __volatile__ ("rdtsc" : "=A" (val));±      return val;£  }° Ÿ-#elif (defined(__GNUC__) && defined(__ppc__))†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){Ÿ       unsigned long long retval;π      unsigned long junk;Ÿ       __asm__ __volatile__ ("\n\ø          1:      mftbu   %1\n\Ÿ                   mftb    %L0\n\ø                  mftbu   %0\n\Ÿ"                  cmpw    %0,%1\n\Ω                  bne     1b"Ÿ0                  : "=r" (retval), "=r" (junk));¥      return retval;£  }†•#else†ŸB  #error Need implementation of sqlite3Hwtime() for your platform.†§  /*ŸG  ** To compile without implementing sqlite3Hwtime() for your platform,Ÿ:  ** you can remove the above #error and use the followingŸ:  ** stub function.  You will lose timing support for manyŸ=  ** of the debugging and testing utilities, but it should atª  ** least compile and run.§  */ŸPSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }†¶#endif†Ÿ&#endif /* !defined(SQLITE_HWTIME_H) */†ŸO/************** End of hwtime.h **********************************************/ŸO/************** Continuing where we left off in os_common.h ******************/†Ωstatic sqlite_uint64 g_start;østatic sqlite_uint64 g_elapsed;Ÿ1#define TIMER_START       g_start=sqlite3Hwtime()Ÿ;#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_startŸ##define TIMER_ELAPSED     g_elapsed•#else≥#define TIMER_START±#define TIMER_ENDŸ,#define TIMER_ELAPSED     ((sqlite_uint64)0)¶#endif†¢/*ŸI** If we compile with the SQLITE_TEST macro set, then the following blockŸG** of code will give us the ability to simulate a disk I/O error.  ThisŸ.** is used for testing the I/O recovery logic.¢*/∏#if defined(SQLITE_TEST)Ÿ+SQLITE_API extern int sqlite3_io_error_hit;Ÿ/SQLITE_API extern int sqlite3_io_error_hardhit;Ÿ/SQLITE_API extern int sqlite3_io_error_pending;Ÿ/SQLITE_API extern int sqlite3_io_error_persist;Ÿ.SQLITE_API extern int sqlite3_io_error_benign;Ÿ/SQLITE_API extern int sqlite3_diskfull_pending;Ÿ'SQLITE_API extern int sqlite3_diskfull;Ÿ<#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)Ÿ #define SimulateIOError(CODE)  \Ÿ:  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \Ÿ.       || sqlite3_io_error_pending-- == 1 )  \Ÿ&              { local_ioerr(); CODE; }∫static void local_ioerr(){∑  IOTRACE(("IOERR\n"));π  sqlite3_io_error_hit++;Ÿ<  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;°}Ÿ%#define SimulateDiskfullError(CODE) \Ÿ$   if( sqlite3_diskfull_pending ){ \Ÿ+     if( sqlite3_diskfull_pending == 1 ){ \∑       local_ioerr(); \æ       sqlite3_diskfull = 1; \Ÿ"       sqlite3_io_error_hit = 1; \Æ       CODE; \≠     }else{ \Ÿ$       sqlite3_diskfull_pending--; \®     } \§   }•#elseŸ #define SimulateIOErrorBenign(X)∫#define SimulateIOError(A)Ÿ #define SimulateDiskfullError(A)Ÿ!#endif /* defined(SQLITE_TEST) */†¢/*Ÿ:** When testing, keep a count of the number of open files.¢*/∏#if defined(SQLITE_TEST)Ÿ.SQLITE_API extern int sqlite3_open_file_count;Ÿ4#define OpenCounter(X)  sqlite3_open_file_count+=(X)•#else∂#define OpenCounter(X)Ÿ!#endif /* defined(SQLITE_TEST) */†Ÿ$#endif /* !defined(_OS_COMMON_H_) */†ŸO/************** End of os_common.h *******************************************/ŸO/************** Continuing where we left off in os_unix.c ********************/†¢/*Ÿ<** Define various macros that are missing from some systems.¢*/≥#ifndef O_LARGEFILE∂# define O_LARGEFILE 0¶#endifπ#ifdef SQLITE_DISABLE_LFS≥# undef O_LARGEFILE∂# define O_LARGEFILE 0¶#endif≤#ifndef O_NOFOLLOWµ# define O_NOFOLLOW 0¶#endif∞#ifndef O_BINARY≥# define O_BINARY 0¶#endif†¢/*ŸB** The threadid macro resolves to the thread-id or to 0.  Used foræ** testing and debugging only.¢*/µ#if SQLITE_THREADSAFEø#define threadid pthread_self()•#else≤#define threadid 0¶#endif†¢/*ŸC** HAVE_MREMAP defaults to true on Linux and false everywhere else.¢*/π#if !defined(HAVE_MREMAP)Ÿ/# if defined(__linux__) && defined(_GNU_SOURCE)∑#  define HAVE_MREMAP 1¶# else∑#  define HAVE_MREMAP 0ß# endif¶#endif†¢/*ŸO** Explicitly call the 64-bit version of lseek() on Android. Otherwise, lseek()ŸB** is the 32-bit version, even if _FILE_OFFSET_BITS=64 is defined.¢*/≤#ifdef __ANDROID__∂# define lseek lseek64¶#endif†∞#ifdef __linux__¢/*Ÿ?** Linux-specific IOCTL magic numbers used for controlling F2FS¢*/Ÿ$#define F2FS_IOCTL_MAGIC        0xf5Ÿ@#define F2FS_IOC_START_ATOMIC_WRITE     _IO(F2FS_IOCTL_MAGIC, 1)Ÿ@#define F2FS_IOC_COMMIT_ATOMIC_WRITE    _IO(F2FS_IOCTL_MAGIC, 2)Ÿ@#define F2FS_IOC_START_VOLATILE_WRITE   _IO(F2FS_IOCTL_MAGIC, 3)Ÿ@#define F2FS_IOC_ABORT_VOLATILE_WRITE   _IO(F2FS_IOCTL_MAGIC, 5)ŸG#define F2FS_IOC_GET_FEATURES           _IOR(F2FS_IOCTL_MAGIC, 12, u32)Ÿ(#define F2FS_FEATURE_ATOMIC_WRITE 0x0004∂#endif /* __linux__ */††¢/*ŸE** Different Unix systems declare open() in different ways.  Same useŸG** open(const char*,int,mode_t).  Others use open(const char*,int,...).ŸD** The difference is important when using a pointer to the function.¢**ŸH** The safest way to deal with the problem is to always use this wrapperŸ4** which always has the same well-defined interface.¢*/Ÿ=static int posixOpen(const char *zFile, int flags, int mode){Ÿ"  return open(zFile, flags, mode);°}†∑/* Forward reference */Ÿ,static int openDirectory(const char*, int*);Ÿ!static int unixGetpagesize(void);†¢/*ŸF** Many system calls are accessed through pointer-to-functions so thatŸI** they may be overridden at runtime to facilitate fault injection duringŸL** testing and sandboxing.  The following array holds the names and pointersŸ$** to all overrideable system calls.¢*/ºstatic struct unix_syscall {Ÿ=  const char *zName;            /* Name of the system call */ŸF  sqlite3_syscall_ptr pCurrent; /* Current value of the system call */Ÿ3  sqlite3_syscall_ptr pDefault; /* Default value */∞} aSyscall[] = {Ÿ:  { "open",         (sqlite3_syscall_ptr)posixOpen,  0  },ŸG#define osOpen      ((int(*)(const char*,int,int))aSyscall[0].pCurrent)†Ÿ:  { "close",        (sqlite3_syscall_ptr)close,      0  },Ÿ7#define osClose     ((int(*)(int))aSyscall[1].pCurrent)†Ÿ:  { "access",       (sqlite3_syscall_ptr)access,     0  },ŸC#define osAccess    ((int(*)(const char*,int))aSyscall[2].pCurrent)†Ÿ:  { "getcwd",       (sqlite3_syscall_ptr)getcwd,     0  },ŸB#define osGetcwd    ((char*(*)(char*,size_t))aSyscall[3].pCurrent)†Ÿ:  { "stat",         (sqlite3_syscall_ptr)stat,       0  },ŸL#define osStat      ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)†¢/*Ÿ@** The DJGPP compiler environment looks mostly like Unix, but itŸF** lacks the fcntl() system call.  So redefine fcntl() to be somethingŸF** that always succeeds.  This means that locking does not occur underŸ/** DJGPP.  But it is DOS - what did you expect?¢*/∞#ifdef __DJGPP__Ÿ,  { "fstat",        0,                 0  },ª#define osFstat(a,b,c)    0™#else     Ÿ:  { "fstat",        (sqlite3_syscall_ptr)fstat,      0  },ŸD#define osFstat     ((int(*)(int,struct stat*))aSyscall[5].pCurrent)¶#endif†Ÿ:  { "ftruncate",    (sqlite3_syscall_ptr)ftruncate,  0  },Ÿ=#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent)†Ÿ:  { "fcntl",        (sqlite3_syscall_ptr)fcntl,      0  },Ÿ?#define osFcntl     ((int(*)(int,int,...))aSyscall[7].pCurrent)†Ÿ:  { "read",         (sqlite3_syscall_ptr)read,       0  },ŸH#define osRead      ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)†Ÿ5#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLEŸ:  { "pread",        (sqlite3_syscall_ptr)pread,      0  },•#elseŸ:  { "pread",        (sqlite3_syscall_ptr)0,          0  },¶#endifŸN#define osPread     ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)†∏#if defined(USE_PREAD64)Ÿ:  { "pread64",      (sqlite3_syscall_ptr)pread64,    0  },•#elseŸ:  { "pread64",      (sqlite3_syscall_ptr)0,          0  },¶#endifŸO#define osPread64 ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent)†Ÿ:  { "write",        (sqlite3_syscall_ptr)write,      0  },ŸO#define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)†Ÿ5#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLEŸ:  { "pwrite",       (sqlite3_syscall_ptr)pwrite,     0  },•#elseŸ:  { "pwrite",       (sqlite3_syscall_ptr)0,          0  },¶#endifŸ@#define osPwrite    ((ssize_t(*)(int,const void*,size_t,off_t))\Ÿ*                    aSyscall[12].pCurrent)†∏#if defined(USE_PREAD64)Ÿ:  { "pwrite64",     (sqlite3_syscall_ptr)pwrite64,   0  },•#elseŸ:  { "pwrite64",     (sqlite3_syscall_ptr)0,          0  },¶#endifŸB#define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off64_t))\Ÿ*                    aSyscall[13].pCurrent)†Ÿ?  { "fchmod",       (sqlite3_syscall_ptr)fchmod,          0  },Ÿ?#define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent)†Ÿ9#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATEŸ?  { "fallocate",    (sqlite3_syscall_ptr)posix_fallocate,  0 },•#elseŸ?  { "fallocate",    (sqlite3_syscall_ptr)0,                0 },¶#endifŸD#define osFallocate ((int(*)(int,off_t,off_t))aSyscall[15].pCurrent)†Ÿ?  { "unlink",       (sqlite3_syscall_ptr)unlink,           0 },Ÿ@#define osUnlink    ((int(*)(const char*))aSyscall[16].pCurrent)†ŸE  { "openDirectory",    (sqlite3_syscall_ptr)openDirectory,      0 },ŸI#define osOpenDirectory ((int(*)(const char*,int*))aSyscall[17].pCurrent)†Ÿ>  { "mkdir",        (sqlite3_syscall_ptr)mkdir,           0 },ŸG#define osMkdir     ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)†Ÿ>  { "rmdir",        (sqlite3_syscall_ptr)rmdir,           0 },Ÿ@#define osRmdir     ((int(*)(const char*))aSyscall[19].pCurrent)†∏#if defined(HAVE_FCHOWN)Ÿ>  { "fchown",       (sqlite3_syscall_ptr)fchown,          0 },•#elseŸ>  { "fchown",       (sqlite3_syscall_ptr)0,               0 },¶#endifŸD#define osFchown    ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)†∏#if defined(HAVE_FCHOWN)Ÿ>  { "geteuid",      (sqlite3_syscall_ptr)geteuid,         0 },•#elseŸ>  { "geteuid",      (sqlite3_syscall_ptr)0,               0 },¶#endifŸ;#define osGeteuid   ((uid_t(*)(void))aSyscall[21].pCurrent)†Ÿ7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0Ÿ>  { "mmap",         (sqlite3_syscall_ptr)mmap,            0 },•#elseŸ>  { "mmap",         (sqlite3_syscall_ptr)0,               0 },¶#endifŸP#define osMmap ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)†Ÿ7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0Ÿ>  { "munmap",       (sqlite3_syscall_ptr)munmap,          0 },•#elseŸ>  { "munmap",       (sqlite3_syscall_ptr)0,               0 },¶#endifŸ>#define osMunmap ((int(*)(void*,size_t))aSyscall[23].pCurrent)†ŸH#if HAVE_MREMAP && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)Ÿ>  { "mremap",       (sqlite3_syscall_ptr)mremap,          0 },•#elseŸ>  { "mremap",       (sqlite3_syscall_ptr)0,               0 },¶#endifŸO#define osMremap ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)†Ÿ7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0Ÿ>  { "getpagesize",  (sqlite3_syscall_ptr)unixGetpagesize, 0 },•#elseŸ>  { "getpagesize",  (sqlite3_syscall_ptr)0,               0 },¶#endifŸ;#define osGetpagesize ((int(*)(void))aSyscall[25].pCurrent)†∫#if defined(HAVE_READLINK)Ÿ>  { "readlink",     (sqlite3_syscall_ptr)readlink,        0 },•#elseŸ>  { "readlink",     (sqlite3_syscall_ptr)0,               0 },¶#endifŸP#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)†∑#if defined(HAVE_LSTAT)Ÿ>  { "lstat",         (sqlite3_syscall_ptr)lstat,          0 },•#elseŸ>  { "lstat",         (sqlite3_syscall_ptr)0,              0 },¶#endifŸN#define osLstat      ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)†ŸC#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ÿ>  { "ioctl",         (sqlite3_syscall_ptr)ioctl,          0 },•#elseŸ>  { "ioctl",         (sqlite3_syscall_ptr)0,              0 },¶#endifŸ<#define osIoctl ((int(*)(int,int,...))aSyscall[28].pCurrent)†Ÿ-}; /* End of the overrideable system calls */††¢/*ŸJ** On some systems, calls to fchown() will trigger a message in a securityŸJ** log if they come from non-root processes.  So avoid calling fchown() ifæ** we are not running as root.¢*/Ÿ6static int robustFchown(int fd, uid_t uid, gid_t gid){∏#if defined(HAVE_FCHOWN)Ÿ0  return osGeteuid() ? 0 : osFchown(fd,uid,gid);•#else´  return 0;¶#endif°}†¢/*ŸD** This is the xSetSystemCall() method of sqlite3_vfs for all of theŸA** "unix" VFSes.  Return SQLITE_OK opon successfully updating theŸF** system call pointer, or SQLITE_NOTFOUND if there is no configurableª** system call named zName.¢*/Ωstatic int unixSetSystemCall(Ÿ@  sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */ŸE  const char *zName,            /* Name of system call to override */ŸF  sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */¢){±  unsigned int i;ª  int rc = SQLITE_NOTFOUND;†Ω  UNUSED_PARAMETER(pNotUsed);±  if( zName==0 ){ŸF    /* If no zName is given, restore all system calls to their defaultø    ** settings and return NULL¶    */≥    rc = SQLITE_OK;Ÿ:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ÿ!      if( aSyscall[i].pDefault ){Ÿ4        aSyscall[i].pCurrent = aSyscall[i].pDefault;ß      }•    }®  }else{ŸA    /* If zName is specified, operate on only the one system call±    ** specified.¶    */Ÿ:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ÿ0      if( strcmp(zName, aSyscall[i].zName)==0 ){Ÿ&        if( aSyscall[i].pDefault==0 ){Ÿ6          aSyscall[i].pDefault = aSyscall[i].pCurrent;©        }∑        rc = SQLITE_OK;Ÿ:        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;Ÿ(        aSyscall[i].pCurrent = pNewFunc;Æ        break;ß      }•    }£  }¨  return rc;°}†¢/*ŸD** Return the value of a system call.  Return NULL if zName is not aŸI** recognized system call name.  NULL is also returned if the system call∫** is currently undefined.¢*/Ÿ-static sqlite3_syscall_ptr unixGetSystemCall(∏  sqlite3_vfs *pNotUsed,≥  const char *zName¢){±  unsigned int i;†Ω  UNUSED_PARAMETER(pNotUsed);Ÿ8  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){ŸJ    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;£  }´  return 0;°}†¢/*ŸH** Return the name of the first system call after zName.  If zName==NULLŸG** then return the name of the first system call.  Return NULL if zNameŸA** is the last system call or if zName is not the name of a validØ** system call.¢*/ŸIstatic const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){≠  int i = -1;†∂  UNUSED_PARAMETER(p);Æ  if( zName ){Ÿ+    for(i=0; i<ArraySize(aSyscall)-1; i++){Ÿ6      if( strcmp(zName, aSyscall[i].zName)==0 ) break;•    }£  }Ÿ'  for(i++; i<ArraySize(aSyscall); i++){Ÿ;    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;£  }´  return 0;°}†¢/*ŸL** Do not accept any file descriptor less than this value, in order to avoidŸK** opening database file using file descriptors that are commonly used for Ÿ%** standard input, output, and error.¢*/Ÿ&#ifndef SQLITE_MINIMUM_FILE_DESCRIPTORŸ)# define SQLITE_MINIMUM_FILE_DESCRIPTOR 3¶#endif†¢/*ŸD** Invoke open().  Do so multiple times, until it either succeeds orŸ*** fails for some reason other than EINTR.¢**ŸD** If the file creation mode "m" is 0 then set it to the default forŸD** SQLite.  The default is SQLITE_DEFAULT_FILE_PERMISSIONS (normallyŸ>** 0644) as modified by the system umask.  If m is not 0, thenŸ?** make the file creation mode be exactly m ignoring the umask.¢**ŸF** The m parameter will be non-zero only when creating -wal, -journal,ŸB** and -shm files.  We want those files to have *exactly* the sameŸF** permissions as their original database, unadulterated by the umask.ŸC** In that way, if a database file is -rw-rw-rw or -rw-rw-r-, and aŸ?** transaction crashes and leaves behind hot journals, then anyŸE** process that is able to write to the database will also be able toº** recover the hot journals.¢*/Ÿ7static int robust_open(const char *z, int f, mode_t m){©  int fd;Ÿ6  mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;´  while(1){∂#if defined(O_CLOEXEC)Ÿ"    fd = osOpen(z,f|O_CLOEXEC,m2);•#else∏    fd = osOpen(z,f,m2);¶#endifØ    if( fd<0 ){Ÿ"      if( errno==EINTR ) continue;¨      break;•    }Ÿ3    if( fd>=SQLITE_MINIMUM_FILE_DESCRIPTOR ) break;∞    osClose(fd);Ÿ     sqlite3_log(SQLITE_WARNING, ŸG                "attempt to open \"%s\" as file descriptor %d", z, fd);¨    fd = -1;Ÿ,    if( osOpen("/dev/null", f, m)<0 ) break;£  }Æ  if( fd>=0 ){Ø    if( m!=0 ){∫      struct stat statbuf;Ÿ#      if( osFstat(fd, &statbuf)==0 º       && statbuf.st_size==0Ÿ$       && (statbuf.st_mode&0777)!=m ®      ){∏        osFchmod(fd, m);ß      }•    }Ÿ@#if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)Ÿ?    osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);¶#endif£  }¨  return fd;°}†¢/*ŸB** Helper functions to obtain and relinquish the global mutex. TheŸ8** global mutex is used to protect the unixInodeInfo andŸ@** vxworksFileId objects used by this file, all of which may be æ** shared by multiple threads.¢**ŸF** Function unixMutexHeld() is used to assert() that the global mutex ŸI** is held when required. This function is only used as part of assert() ≥** statements. e.g.¢**µ**   unixEnterMutex()Ÿ!**     assert( unixMutexHeld() );µ**   unixEnterLeave()¢*/Ÿ&static sqlite3_mutex *unixBigLock = 0;Ÿ!static void unixEnterMutex(void){Ÿ#  sqlite3_mutex_enter(unixBigLock);°}Ÿ!static void unixLeaveMutex(void){Ÿ#  sqlite3_mutex_leave(unixBigLock);°}≥#ifdef SQLITE_DEBUGŸ static int unixMutexHeld(void) {Ÿ)  return sqlite3_mutex_held(unixBigLock);°}¶#endif††ª#ifdef SQLITE_HAVE_OS_TRACE¢/*ŸD** Helper function for printing out trace information from debuggingŸC** binaries. This returns the string representation of the suppliedµ** integer lock-type.¢*/Ÿ-static const char *azFileLock(int eFileLock){∂  switch( eFileLock ){Ÿ     case NO_LOCK: return "NONE";Ÿ&    case SHARED_LOCK: return "SHARED";Ÿ*    case RESERVED_LOCK: return "RESERVED";Ÿ(    case PENDING_LOCK: return "PENDING";Ÿ,    case EXCLUSIVE_LOCK: return "EXCLUSIVE";£  }±  return "ERROR";°}¶#endif†∏#ifdef SQLITE_LOCK_TRACE¢/*Ÿ6** Print out information about all locking operations.¢**ŸB** This routine is used for troubleshooting locks on multithreadedŸ?** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACEŸ>** command-line option on the compiler.  This code is normallyÆ** turned off.¢*/Ÿ6static int lockTrace(int fd, int op, struct flock *p){∏  char *zOpName, *zType;®  int s;±  int savedErrno;¥  if( op==F_GETLK ){∂    zOpName = "GETLK";∫  }else if( op==F_SETLK ){∂    zOpName = "SETLK";®  }else{ª    s = osFcntl(fd, op, p);Ÿ>    sqlite3DebugPrintf("fcntl unknown %d %d %d\n", fd, op, s);≠    return s;£  }ª  if( p->l_type==F_RDLCK ){¥    zType = "RDLCK";Ÿ!  }else if( p->l_type==F_WRLCK ){¥    zType = "WRLCK";Ÿ!  }else if( p->l_type==F_UNLCK ){¥    zType = "UNLCK";®  }else{∞    assert( 0 );£  }Ÿ"  assert( p->l_whence==SEEK_SET );π  s = osFcntl(fd, op, p);µ  savedErrno = errno;Ÿ7  sqlite3DebugPrintf("fcntl %d %d %s %s %d %d %d %d\n",ŸB     threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,∑     (int)p->l_pid, s);ŸM  if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){¥    struct flock l2;¨    l2 = *p;æ    osFcntl(fd, F_GETLK, &l2);Ω    if( l2.l_type==F_RDLCK ){∂      zType = "RDLCK";Ÿ#    }else if( l2.l_type==F_WRLCK ){∂      zType = "WRLCK";Ÿ#    }else if( l2.l_type==F_UNLCK ){∂      zType = "UNLCK";™    }else{≤      assert( 0 );•    }Ÿ=    sqlite3DebugPrintf("fcntl-failure-reason: %s %d %d %d\n",Ÿ=       zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);£  }µ  errno = savedErrno;´  return s;°}Æ#undef osFcntlπ#define osFcntl lockTraceæ#endif /* SQLITE_LOCK_TRACE */†¢/*Ÿ1** Retry ftruncate() calls that fail due to EINTR¢**ŸC** All calls to ftruncate() within this file should be made throughŸD** this wrapper.  On the Android platform, bypassing the logic belowŸ$** could lead to a corrupt database.¢*/Ÿ5static int robust_ftruncate(int h, sqlite3_int64 sz){©  int rc;≤#ifdef __ANDROID__ŸA  /* On Android, ftruncate() always uses 32-bit offsets, even if ŸK  ** _FILE_OFFSET_BITS=64 is defined. This means it is unsafe to attempt toŸF  ** truncate a file to any size larger than 2GiB. Silently ignore any∑  ** such attempts.  */Ÿ%  if( sz>(sqlite3_int64)0x7FFFFFFF ){≥    rc = SQLITE_OK;ß  }else¶#endifŸ=  do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );¨  return rc;°}†¢/*ŸE** This routine translates a standard POSIX errno code into somethingŸG** useful to the clients of the sqlite3 functions.  Specifically, it isŸI** intended to translate a variety of "try again" errors into SQLITE_BUSYŸG** and a variety of "please close the file descriptor NOW" errors into Ø** SQLITE_IOERR£** ŸK** Errors during initialization of locks, or file system support for locks,Ÿ8** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.¢*/ŸGstatic int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {Ÿ0  assert( (sqliteIOErr == SQLITE_IOERR_LOCK) || Ÿ2          (sqliteIOErr == SQLITE_IOERR_UNLOCK) || Ÿ1          (sqliteIOErr == SQLITE_IOERR_RDLOCK) ||Ÿ<          (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) );∑  switch (posixError) {Ø  case EACCES: Æ  case EAGAIN:±  case ETIMEDOUT:≠  case EBUSY:≠  case EINTR:∞  case ENOLCK:  ŸA    /* random NFS retry error, unless during file system support Ÿ@     * introspection, in which it actually means what it says */∑    return SQLITE_BUSY;§    Æ  case EPERM: ∑    return SQLITE_PERM;§    ´  default: ∑    return sqliteIOErr;£  }°}††ŸO/******************************************************************************ŸO****************** Begin Unique File ID Utility Used By VxWorks ***************¢**ŸO** On most versions of unix, we can get a unique ID for a file by concatenatingŸN** the device number and the inode number.  But this does not work on VxWorks.ŸH** On VxWorks, a unique file id must be based on the canonical filename.¢**ŸG** A pointer to an instance of the following structure can be used as aŸG** unique file ID in VxWorks.  Each instance of this structure containsŸH** a copy of the canonical filename.  There is also a reference count.  ŸH** The structure is reclaimed when the number of pointers to it drops to®** zero.¢**ŸG** There are never very many files open at one time and lookups are notŸ@** a performance-critical path, so it is sufficient to put theseø** structures on a linked list.¢*/∂struct vxworksFileId {Ÿ@  struct vxworksFileId *pNext;  /* Next in a list of them all */ŸF  int nRef;                     /* Number of references to this one */ŸK  int nName;                    /* Length of the zCanonicalName[] string */Ÿ8  char *zCanonicalName;         /* Canonical filename */¢};†Æ#if OS_VXWORKS£/* Ÿ@** All unique filenames are held on a linked list headed by this¨** variable:¢*/Ÿ1static struct vxworksFileId *vxworksFileList = 0;†¢/*Ÿ.** Simplify a filename into its canonical formŸ#** by making the following changes:¢**Ÿ+**  * removing any trailing and duplicate /Ω**  * convert /./ into just /Ÿ;**  * convert /A/../ where A is any simple name into just /¢**Ÿ:** Changes are made in-place.  Return the new name length.¢**Ÿ?** The original filename is in z[0..n-1].  Return the number ofŸ%** characters in the simplified name.¢*/Ÿ/static int vxworksSimplifyName(char *z, int n){´  int i, j;Ÿ%  while( n>1 && z[n-1]=='/' ){ n--; }∑  for(i=j=0; i<n; i++){¥    if( z[i]=='/' ){Ÿ!      if( z[i+1]=='/' ) continue;Ÿ0      if( z[i+1]=='.' && i+2<n && z[i+2]=='/' ){Ø        i += 1;±        continue;ß      }Ÿ?      if( z[i+1]=='.' && i+3<n && z[i+2]=='.' && z[i+3]=='/' ){Ÿ+        while( j>0 && z[j-1]!='/' ){ j--; }π        if( j>0 ){ j--; }Ø        i += 2;±        continue;ß      }•    }≤    z[j++] = z[i];£  }´  z[j] = 0;´  return j;°}†¢/*ŸA** Find a unique file ID for the given absolute pathname.  ReturnŸE** a pointer to the vxworksFileId object.  This pointer is the unique´** file ID.¢**ŸC** The nRef field of the vxworksFileId object is incremented beforeŸA** the object is returned.  A new vxworksFileId object is createdŸ-** and added to the global list if necessary.¢**Ÿ4** If a memory allocation error occurs, return NULL.¢*/ŸJstatic struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){ŸF  struct vxworksFileId *pNew;         /* search key and new file ID */ŸN  struct vxworksFileId *pCandidate;   /* For looping over existing file IDs */ŸJ  int n;                              /* Length of zAbsoluteName string */†Ÿ"  assert( zAbsoluteName[0]=='/' );Ÿ!  n = (int)strlen(zAbsoluteName);Ÿ3  pNew = sqlite3_malloc64( sizeof(*pNew) + (n+1) );π  if( pNew==0 ) return 0;Ÿ)  pNew->zCanonicalName = (char*)&pNew[1];Ÿ3  memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);Ÿ3  n = vxworksSimplifyName(pNew->zCanonicalName, n);†ŸC  /* Search for an existing entry that matching the canonical name.ŸD  ** If found, increment the reference count and return a pointer to∫  ** the existing file ID.§  */≥  unixEnterMutex();ŸL  for(pCandidate=vxworksFileList; pCandidate; pCandidate=pCandidate->pNext){Ω    if( pCandidate->nName==n ŸF     && memcmp(pCandidate->zCanonicalName, pNew->zCanonicalName, n)==0¶    ){∫       sqlite3_free(pNew);∫       pCandidate->nRef++;∏       unixLeaveMutex();π       return pCandidate;•    }£  }†Ÿ7  /* No match was found.  We will make a new file ID */±  pNew->nRef = 1;≤  pNew->nName = n;Ÿ   pNew->pNext = vxworksFileList;π  vxworksFileList = pNew;≥  unixLeaveMutex();Æ  return pNew;°}†¢/*ŸA** Decrement the reference count on a vxworksFileId object.  FreeŸ4** the object when the reference count reaches zero.¢*/Ÿ<static void vxworksReleaseFileId(struct vxworksFileId *pId){≥  unixEnterMutex();∏  assert( pId->nRef>0 );Æ  pId->nRef--;µ  if( pId->nRef==0 ){æ    struct vxworksFileId **pp;ŸE    for(pp=&vxworksFileList; *pp && *pp!=pId; pp = &((*pp)->pNext)){}∑    assert( *pp==pId );µ    *pp = pId->pNext;∂    sqlite3_free(pId);£  }≥  unixLeaveMutex();°}∑#endif /* OS_VXWORKS */ŸO/*************** End of Unique File ID Utility Used By VxWorks ****************ŸO******************************************************************************/††ŸO/******************************************************************************ŸO*************************** Posix Advisory Locking ****************************¢**ŸE** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)ŸD** section 6.5.2.2 lines 483 through 490 specify that when a processŸF** sets or clears a lock, that operation overrides any prior locks setŸH** by the same process.  It does not explicitly say so, but this impliesŸD** that it overrides locks set by the same process using a differentŸ-** file descriptor.  Consider this test case:¢**Ÿ9**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);Ÿ9**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);¢**Ÿ@** Suppose ./file1 and ./file2 are really the same file (becauseŸ?** one is a hard or symbolic link to the other) then if you setŸ>** an exclusive lock on fd1, then try to get an exclusive lockŸ>** on fd2, it works.  I would have expected the second lock toŸ>** fail since there was already a lock on the file due to fd1.Ÿ@** But not so.  Since both locks came from the same process, theŸA** second overrides the first, even though they were on differentŸ3** file descriptors opened on different file names.¢**ŸG** This means that we cannot use POSIX locks to synchronize file accessŸK** among competing threads of the same process.  POSIX locks will work fineŸC** to synchronize access for threads in separate processes, but notŸ#** threads within the same process.¢**ŸI** To work around the problem, SQLite has to manage file locks internallyŸF** on its own.  Whenever a new database is opened, we have to find theŸF** specific inode of the database file (the inode is determined by theŸH** st_dev and st_ino fields of the stat structure that fstat() fills in)ŸF** and check for locks already existing on that inode.  When locks areŸH** created or removed, we have to look at our own internal record of theŸH** locks to see if another thread has previously set a lock on that same©** inode.¢**ŸK** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.ŸH** For VxWorks, we have to use the alternative unique ID system based onŸ@** canonical filename and implemented in the previous division.)¢**ŸI** The sqlite3_file structure for POSIX is no longer just an integer fileŸA** descriptor.  It is now a structure that holds the integer fileŸF** descriptor and a pointer to a structure that describes the internalŸD** locks on the corresponding inode.  There is one locking structureŸL** per inode, so if the same inode is opened twice, both unixFile structuresŸD** point to the same locking structure.  The locking structure keepsŸD** a reference count (so we will know when to delete it) and a "cnt"ŸB** field that tells us its internal lock status.  cnt==0 means theŸC** file is unlocked.  cnt==-1 means the file has an exclusive lock.Ÿ6** cnt>0 means there are cnt shared locks on the file.¢**Ÿ@** Any attempt to lock or unlock a file first checks the lockingŸ@** structure.  The fcntl() system call is only invoked to set a Ÿ@** POSIX lock if the internal lock structure transitions betweenŸ"** a locked and an unlocked state.¢**ŸD** But wait:  there are yet more problems with POSIX advisory locks.¢**ŸG** If you close a file descriptor that points to a file that has locks,ŸC** all locks on that file that are owned by the current process areŸD** released.  To work around this problem, each unixInodeInfo objectŸA** maintains a count of the number of pending locks on tha inode.Ÿ=** When an attempt is made to close an unixFile, if there areŸI** other unixFile open on the same inode that are holding locks, the callŸK** to close() the file descriptor is deferred until all of the locks clear.ŸL** The unixInodeInfo structure keeps a list of file descriptors that need toŸE** be closed and that list is walked (and cleared) when the last lock™** clears.¢**ŸH** Yet another problem:  LinuxThreads do not play well with posix locks.¢**ŸE** Many older versions of linux use the LinuxThreads library which isŸE** not posix compliant.  Under LinuxThreads, a lock created by threadŸ>** A cannot be modified or overridden by a different thread B.ŸB** Only thread A can modify the lock.  Locking behavior is correctŸF** if the appliation uses the newer Native Posix Thread Library (NPTL)ŸE** on linux - with NPTL a lock created by thread A can override locksŸB** in thread B.  But there is no way to know at compile-time whichŸB** threading library is being used.  So there is no way to know atŸG** compile-time whether or not thread A can override locks on thread B.ŸA** One has to do a run-time check to discover the behavior of the≥** current process.¢**ŸE** SQLite used to support LinuxThreads.  But support for LinuxThreadsŸI** was dropped beginning with version 3.7.0.  SQLite will still work withŸG** LinuxThreads provided that (1) there is no more than one connection ŸE** per database file in the same process and (2) database connectionsæ** do not move across threads.¢*/†¢/*Ÿ@** An instance of the following structure serves as the key usedŸ/** to locate a particular unixInodeInfo object.¢*/≥struct unixFileId {Ÿ1  dev_t dev;                  /* Device number */Æ#if OS_VXWORKSŸ?  struct vxworksFileId *pId;  /* Unique file ID for vxworks. */•#elseŸA  /* We are told that some versions of Android contain a bug thatŸ9  ** sizes ino_t at only 32-bits instead of 64-bits. (SeeŸI  ** https://android-review.googlesource.com/#/c/115351/3/dist/sqlite3.c)ŸI  ** To work around this, always allocate 64-bits for the inode number.  ŸI  ** On small machines that only have 32-bit inodes, this wastes 4 bytes,Ÿ*  ** but that should not be a big deal. */∫  /* WAS:  ino_t ino;   */Ÿ/  u64 ino;                   /* Inode number */¶#endif¢};†¢/*ŸD** An instance of the following structure is allocated for each openŸD** inode.  Or, on LinuxThreads, there is one of these structures forŸ$** each inode opened by each thread.¢**ŸF** A single inode can have multiple file descriptors, so each unixFileŸF** structure contains a pointer to an instance of this object and thisŸA** object keeps a count of the number of unixFile pointing to it.¢*/∂struct unixInodeInfo {Ÿ6  struct unixFileId fileId;       /* The lookup key */ŸC  int nShared;                    /* Number of SHARED locks held */ŸN  unsigned char eFileLock;        /* One of SHARED_LOCK, RESERVED_LOCK etc. */ŸI  unsigned char bProcessLock;     /* An exclusive process lock is held */ŸL  int nRef;                       /* Number of pointers to this structure */ŸP  unixShmNode *pShmNode;          /* Shared memory associated with this inode */ŸH  int nLock;                      /* Number of outstanding file locks */ŸH  UnixUnusedFd *pUnused;          /* Unused file descriptors to close */ŸI  unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */Ÿ=  unixInodeInfo *pPrev;           /*    .... doubly linked */ø#if SQLITE_ENABLE_LOCKING_STYLEŸE  unsigned long long sharedByte;  /* for AFP simulated shared lock */¶#endifÆ#if OS_VXWORKSŸ=  sem_t *pSem;                    /* Named POSIX semaphore */Ÿ>  char aSemName[MAX_PATHNAME+2];  /* Name of that semaphore */¶#endif¢};†¢/*Ÿ(** A lists of all unixInodeInfo objects.¢*/ŸEstatic unixInodeInfo *inodeList = 0;  /* All unixInodeInfo objects */ŸIstatic unsigned int nUnusedFd = 0;    /* Total unused file descriptors */†¢/*¢**ŸJ** This function - unixLogErrorAtLine(), is only ever called via the macro≤** unixLogError().¢**ŸK** It is invoked after an error occurs in an OS function and errno has beenŸM** set. It logs a message using sqlite3_log() containing the current value ofŸK** errno and, if possible, the human-readable equivalent from strerror() or∞** strerror_r().¢**ŸG** The first argument passed to the macro should be the error code thatŸK** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN). ŸJ** The two subsequent arguments should be the name of the OS function thatŸF** failed (e.g. "unlink", "open") and the associated file-system path,™** if any.¢*/ŸB#define unixLogError(a,b,c)     unixLogErrorAtLine(a,b,c,__LINE__)æstatic int unixLogErrorAtLine(Ÿ9  int errcode,                    /* SQLite error code */ŸG  const char *zFunc,              /* Name of OS function that failed */ŸG  const char *zPath,              /* File path associated with error */ŸO  int iLine                       /* Source line number where error occurred */¢){ŸM  char *zErr;                     /* Message from strerror() or equivalent */ŸB  int iErrno = errno;             /* Saved syscall error number */†ŸG  /* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then useŸG  ** the strerror() function to obtain the human-readable error messageŸ6  ** equivalent to errno. Otherwise, use strerror_r().•  */ Ÿ1#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)∞  char aErr[80];Ÿ   memset(aErr, 0, sizeof(aErr));Æ  zErr = aErr;†ŸL  /* If STRERROR_R_CHAR_P (set by autoconf scripts) or __USE_GNU is defined,ŸI  ** assume that the system provides the GNU version of strerror_r() thatŸN  ** returns a pointer to a buffer containing the error message. That pointer ŸL  ** may point to aErr[], or it may point to some static storage somewhere. ŸE  ** Otherwise, assume that the system provides the POSIX version of ŸD  ** strerror_r(), which always writes an error message into aErr[].§  **ŸI  ** If the code incorrectly assumes that it is the POSIX version that isŸF  ** available, the error message will often be an empty string. Not aŸL  ** huge problem. Incorrectly concluding that the GNU version is available Ÿ%  ** could lead to a segfault though.§  */Ÿ4#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)©  zErr = ß# endifŸ+  strerror_r(iErrno, aErr, sizeof(aErr)-1);†∑#elif SQLITE_THREADSAFEŸF  /* This is a threadsafe build, but strerror_r() is not available. */¨  zErr = "";•#elseŸ-  /* Non-threadsafe build, use strerror(). */∫  zErr = strerror(iErrno);¶#endif†º  if( zPath==0 ) zPath = "";∂  sqlite3_log(errcode,Ÿ'      "os_unix.c:%d: (%d) %s(%s) - %s",Ÿ'      iLine, iErrno, zFunc, zPath, zErr§  );†±  return errcode;°}†¢/*ª** Close a file descriptor.¢**ŸD** We assume that close() almost always works, since it is only in aŸG** very sick application or on a very sick platform that it might fail.ŸC** If it does fail, simply leak the file descriptor, but do log the©** error.¢**ŸB** Note that it is not safe to retry close() after EINTR since theŸD** file descriptor might have already been reused by another thread.ŸE** So we don't even try to recover from an EINTR.  Just log the errorØ** and move on.¢*/Ÿ=static void robust_close(unixFile *pFile, int h, int lineno){≥  if( osClose(h) ){Ÿ3    unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",Ÿ9                       pFile ? pFile->zPath : 0, lineno);£  }°}†¢/*ŸF** Set the pFile->lastErrno.  Do this in a subroutine as that providesŸ*** a convenient place to set a breakpoint.¢*/Ÿ7static void storeLastErrno(unixFile *pFile, int error){ª  pFile->lastErrno = error;°}†¢/*ŸL** Close all file descriptors accumuated in the unixInodeInfo->pUnused list.£*/ Ÿ-static void closePendingFds(unixFile *pFile){Ÿ(  unixInodeInfo *pInode = pFile->pInode;≤  UnixUnusedFd *p;∂  UnixUnusedFd *pNext;Ÿ%  for(p=pInode->pUnused; p; p=pNext){µ    pNext = p->pNext;Ÿ)    robust_close(pFile, p->fd, __LINE__);¥    sqlite3_free(p);∞    nUnusedFd--;£  }∂  pInode->pUnused = 0;°}†¢/*ŸM** Release a unixInodeInfo structure previously allocated by findInodeInfo().¢**ŸE** The mutex entered using the unixEnterMutex() function must be heldŸ ** when this function is called.¢*/Ÿ.static void releaseInodeInfo(unixFile *pFile){Ÿ(  unixInodeInfo *pInode = pFile->pInode;º  assert( unixMutexHeld() );∑  if( ALWAYS(pInode) ){≥    pInode->nRef--;∫    if( pInode->nRef==0 ){Ÿ$      assert( pInode->pShmNode==0 );Ω      closePendingFds(pFile);∫      if( pInode->pPrev ){Ÿ/        assert( pInode->pPrev->pNext==pInode );Ÿ-        pInode->pPrev->pNext = pInode->pNext;¨      }else{Ÿ$        assert( inodeList==pInode );Ÿ"        inodeList = pInode->pNext;ß      }∫      if( pInode->pNext ){Ÿ/        assert( pInode->pNext->pPrev==pInode );Ÿ-        pInode->pNext->pPrev = pInode->pPrev;ß      }ª      sqlite3_free(pInode);•    }£  }Ÿ)  assert( inodeList!=0 || nUnusedFd==0 );°}†¢/*Ÿ@** Given a file descriptor, locate the unixInodeInfo object thatŸG** describes that file descriptor.  Create a new one if necessary.  TheŸ:** return value might be uninitialized if an error occurs.¢**ŸE** The mutex entered using the unixEnterMutex() function must be heldŸ ** when this function is called.¢**Ÿ$** Return an appropriate error code.¢*/πstatic int findInodeInfo(ŸO  unixFile *pFile,               /* Unix file with file desc used in the key */ŸK  unixInodeInfo **ppInode        /* Return the unixInodeInfo object here */¢){Ÿ>  int rc;                        /* System call return code */ŸD  int fd;                        /* The file descriptor for pFile */ŸG  struct unixFileId fileId;      /* Lookup key for the unixInodeInfo */ŸA  struct stat statbuf;           /* Low-level file information */ŸE  unixInodeInfo *pInode = 0;     /* Candidate unixInodeInfo object */†º  assert( unixMutexHeld() );†ŸA  /* Get low-level information about the file that we can used toŸ'  ** create a unique name for the file.§  */∞  fd = pFile->h;Ω  rc = osFstat(fd, &statbuf);Æ  if( rc!=0 ){Ÿ!    storeLastErrno(pFile, errno);Ÿ5#if defined(EOVERFLOW) && defined(SQLITE_DISABLE_LFS)Ÿ:    if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;¶#endif∏    return SQLITE_IOERR;£  }†∞#ifdef __APPLE__ŸA  /* On OS X on an msdos filesystem, the inode number is reportedŸA  ** incorrectly for zero-size files.  See ticket #3260.  To workŸC  ** around this problem (we consider it a bug in OS X, not SQLite)ŸC  ** we always increase the file size to 1 by writing a single byteŸB  ** prior to accessing the inode number.  The one byte written isŸC  ** an ASCII 'S' character which also happens to be the first byteŸC  ** in the header of every SQLite database.  In this way, if thereŸG  ** is a race condition such that another thread has already populatedŸ7  ** the first page of the database, no damage is done.§  */ŸL  if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){ŸA    do{ rc = osWrite(fd, "S", 1); }while( rc<0 && errno==EINTR );∞    if( rc!=1 ){Ÿ#      storeLastErrno(pFile, errno);∫      return SQLITE_IOERR;•    }ø    rc = osFstat(fd, &statbuf);∞    if( rc!=0 ){Ÿ#      storeLastErrno(pFile, errno);∫      return SQLITE_IOERR;•    }£  }¶#endif†Ÿ%  memset(&fileId, 0, sizeof(fileId));æ  fileId.dev = statbuf.st_dev;Æ#if OS_VXWORKS∫  fileId.pId = pFile->pId;•#elseŸ#  fileId.ino = (u64)statbuf.st_ino;¶#endifŸ)  assert( inodeList!=0 || nUnusedFd==0 );µ  pInode = inodeList;ŸF  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){ª    pInode = pInode->pNext;£  }≤  if( pInode==0 ){Ÿ1    pInode = sqlite3_malloc64( sizeof(*pInode) );¥    if( pInode==0 ){ø      return SQLITE_NOMEM_BKPT;•    }Ÿ'    memset(pInode, 0, sizeof(*pInode));Ÿ5    memcpy(&pInode->fileId, &fileId, sizeof(fileId));µ    pInode->nRef = 1;æ    pInode->pNext = inodeList;∂    pInode->pPrev = 0;Ÿ.    if( inodeList ) inodeList->pPrev = pInode;∑    inodeList = pInode;®  }else{≥    pInode->nRef++;£  }¥  *ppInode = pInode;≥  return SQLITE_OK;°}†¢/*ŸO** Return TRUE if pFile has been renamed or unlinked since it was first opened.¢*/Ÿ)static int fileHasMoved(unixFile *pFile){Æ#if OS_VXWORKSŸC  return pFile->pInode!=0 && pFile->pId!=pFile->pInode->fileId.pId;•#else≤  struct stat buf;º  return pFile->pInode!=0 &&Ÿ%      (osStat(pFile->zPath, &buf)!=0 Ÿ8         || (u64)buf.st_ino!=pFile->pInode->fileId.ino);¶#endif°}††¢/*Ÿ>** Check a unixFile that is a database.  Verify the following:¢**Ÿ1** (1) There is exactly one hard link on the fileŸ&** (2) The file is not a symbolic linkŸ0** (3) The file has not been renamed or unlinked¢**ŸK** Issue sqlite3_log(SQLITE_WARNING,...) messages if anything is not right.¢*/Ÿ*static void verifyDbFile(unixFile *pFile){≤  struct stat buf;©  int rc;†Ÿ=  /* These verifications occurs for the main database only */Ÿ2  if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) return;†ø  rc = osFstat(pFile->h, &buf);Æ  if( rc!=0 ){ŸI    sqlite3_log(SQLITE_WARNING, "cannot fstat db file %s", pFile->zPath);´    return;£  }∏  if( buf.st_nlink==0 ){ŸN    sqlite3_log(SQLITE_WARNING, "file unlinked while open: %s", pFile->zPath);´    return;£  }∑  if( buf.st_nlink>1 ){ŸL    sqlite3_log(SQLITE_WARNING, "multiple links to file: %s", pFile->zPath);´    return;£  }º  if( fileHasMoved(pFile) ){ŸM    sqlite3_log(SQLITE_WARNING, "file renamed while open: %s", pFile->zPath);´    return;£  }°}††¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸJ** file by this or any other process. If such a lock is held, set *pResOutŸK** to a non-zero value otherwise *pResOut is set to zero.  The return valueŸG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ŸAstatic int unixCheckReservedLock(sqlite3_file *id, int *pResOut){µ  int rc = SQLITE_OK;≥  int reserved = 0;Ÿ"  unixFile *pFile = (unixFile*)id;†Ÿ<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );†≤  assert( pFile );Ÿ*  assert( pFile->eFileLock<=SHARED_LOCK );ŸH  unixEnterMutex(); /* Because pFile->pInode is shared across threads */†Ÿ;  /* Check if a thread in this process holds such a lock */Ÿ-  if( pFile->pInode->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }†Ÿ2  /* Otherwise see if some other process holds it.§  */±#ifndef __DJGPP__Ÿ2  if( !reserved && !pFile->pInode->bProcessLock ){∂    struct flock lock;Ω    lock.l_whence = SEEK_SET;Ÿ!    lock.l_start = RESERVED_BYTE;≥    lock.l_len = 1;∫    lock.l_type = F_WRLCK;Ÿ,    if( osFcntl(pFile->h, F_GETLK, &lock) ){Ÿ*      rc = SQLITE_IOERR_CHECKRESERVEDLOCK;Ÿ#      storeLastErrno(pFile, errno);Ÿ&    } else if( lock.l_type!=F_UNLCK ){≥      reserved = 1;•    }£  }¶#endif¢  ≥  unixLeaveMutex();ŸF  OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved));†∂  *pResOut = reserved;¨  return rc;°}†¢/*Ω** Set a posix-advisory-lock.¢**Ÿ<** There are two versions of this routine.  If compiled withŸF** SQLITE_ENABLE_SETLK_TIMEOUT then the routine has an extra parameterŸC** which is a pointer to a unixFile.  If the unixFile->iBusyTimeoutŸE** value is set, then it is the number of milliseconds to wait beforeŸD** failing the lock.  The iBusyTimeout value is always reset back toµ** zero on each call.¢**ŸH** If SQLITE_ENABLE_SETLK_TIMEOUT is not defined, then do a non-blockingª** attempt to set the lock.¢*/Ÿ##ifndef SQLITE_ENABLE_SETLK_TIMEOUTŸ;# define osSetPosixAdvisoryLock(h,x,t) osFcntl(h,F_SETLK,x)•#elseŸ"static int osSetPosixAdvisoryLock(ŸK  int h,                /* The file descriptor on which to take the lock */Ÿ9  struct flock *pLock,  /* The description of the lock */Ÿ=  unixFile *pFile       /* Structure holding timeout value */¢){Ÿ$  int rc = osFcntl(h,F_SETLK,pLock);Ÿ)  while( rc<0 && pFile->iBusyTimeout>0 ){ŸN    /* On systems that support some kind of blocking file lock with a timeout,ŸK    ** make appropriate changes here to invoke that blocking file lock.  OnŸJ    ** generic posix, however, there is no such API.  So we simply try theŸM    ** lock once every millisecond until either the timeout expires, or untilø    ** the lock is obtained. */±    usleep(1000);Ÿ"    rc = osFcntl(h,F_SETLK,pLock);∫    pFile->iBusyTimeout--;£  }¨  return rc;°}Ÿ(#endif /* SQLITE_ENABLE_SETLK_TIMEOUT */††¢/*Ÿ@** Attempt to set a system-lock on the file pFile.  The lock is ∂** described by pLock.¢**ŸH** If the pFile was opened read/write from unix-excl, then the only lockŸF** ever obtained is an exclusive lock, and it is obtained exactly onceŸG** the first time any lock is attempted.  All subsequent system lockingŸI** operations become no-ops.  Locking operations still happen internally,ŸF** in order to coordinate access between separate database connectionsŸD** within this process, but all of that is handled in memory and theŸ)** operating system does not participate.¢**ŸF** This function is a pass-through to fcntl(F_SETLK) if pFile is usingŸF** any VFS other than "unix-excl" or if pFile is opened on "unix-excl"¥** and is read-only.¢**ŸG** Zero is returned if the call completes successfully, or -1 if a callŸK** to fcntl() fails. In this case, errno is set appropriately (by fcntl()).¢*/Ÿ>static int unixFileLock(unixFile *pFile, struct flock *pLock){©  int rc;Ÿ(  unixInodeInfo *pInode = pFile->pInode;º  assert( unixMutexHeld() );∂  assert( pInode!=0 );ŸL  if( (pFile->ctrlFlags & (UNIXFILE_EXCL|UNIXFILE_RDONLY))==UNIXFILE_EXCL ){Ÿ"    if( pInode->bProcessLock==0 ){∏      struct flock lock;Ÿ!      assert( pInode->nLock==0 );ø      lock.l_whence = SEEK_SET;Ÿ"      lock.l_start = SHARED_FIRST;ø      lock.l_len = SHARED_SIZE;º      lock.l_type = F_WRLCK;Ÿ:      rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);ª      if( rc<0 ) return rc;ø      pInode->bProcessLock = 1;∂      pInode->nLock++;™    }else{≠      rc = 0;•    }®  }else{Ÿ8    rc = osSetPosixAdvisoryLock(pFile->h, pLock, pFile);£  }¨  return rc;°}†¢/*ŸE** Lock the file with the lock specified by parameter eFileLock - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ÿ$** routine to lower a locking level.¢*/Ÿ5static int unixLock(sqlite3_file *id, int eFileLock){ŸH  /* The following describes the implementation of the various locks andŸI  ** lock transitions in terms of the POSIX advisory shared and exclusiveŸG  ** lock primitives (called read-locks and write-locks below, to avoidŸF  ** confusion with SQLite lock names). The algorithms are complicatedŸM  ** slightly in order to be compatible with Windows95 systems simultaneouslyŸE  ** accessing the same database file, in case that is ever required.§  **ŸK  ** Symbols defined in os.h indentify the 'pending byte' and the 'reservedŸI  ** byte', each single bytes at well known offsets, and the 'shared byteŸ9  ** range', a range of 510 bytes at a well known offset.§  **ŸE  ** To obtain a SHARED lock, a read-lock is obtained on the 'pendingŸF  ** byte'.  If this is successful, 'shared byte range' is read-lockedŸF  ** and the lock on the 'pending byte' released.  (Legacy note:  WhenŸJ  ** SQLite was first developed, Windows95 systems were still very common,ŸF  ** and Widnows95 lacks a shared-lock capability.  So on Windows95, aŸH  ** single randomly selected by from the 'shared byte range' is locked.ŸG  ** Windows95 is now pretty much extinct, but this work-around for theŸ>  ** lack of shared-locks on Windows95 lives on, for backwards¥  ** compatibility.)§  **ŸJ  ** A process may only obtain a RESERVED lock after it has a SHARED lock.ŸC  ** A RESERVED lock is implemented by grabbing a write-lock on the∂  ** 'reserved byte'. §  **ŸE  ** A process may only obtain a PENDING lock after it has obtained aŸI  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lockŸH  ** on the 'pending byte'. This ensures that no new SHARED locks can beŸJ  ** obtained, but existing SHARED locks are allowed to persist. A processŸJ  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.ŸK  ** This property is used by the algorithm for rolling back a journal file≥  ** after a crash.§  **ŸA  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, isŸE  ** implemented by obtaining a write-lock on the entire 'shared byteŸJ  ** range'. Since all other locks require a read-lock on one of the bytesŸH  ** within this range, this ensures that no other locks are held on theØ  ** database. §  */µ  int rc = SQLITE_OK;Ÿ"  unixFile *pFile = (unixFile*)id;∏  unixInodeInfo *pInode;¥  struct flock lock;±  int tErrno = 0;†≤  assert( pFile );ŸC  OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,Ÿ:      azFileLock(eFileLock), azFileLock(pFile->eFileLock),ŸC      azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,¥      osGetpid(0)));†ŸG  /* If there is already a lock of this type or more restrictive on theŸ@  ** unixFile, do nothing. Don't use the end_lock: exit path, asŸ-  ** unixEnterMutex() hasn't been called yet.§  */Ÿ$  if( pFile->eFileLock>=eFileLock ){ŸB    OSTRACE(("LOCK    %d %s ok (already held) (unix)\n", pFile->h,Ÿ$            azFileLock(eFileLock)));µ    return SQLITE_OK;£  }†Ÿ/  /* Make sure the locking sequence is correct.ŸJ  **  (1) We never move from unlocked to anything higher than shared lock.Ÿ9  **  (2) SQLite never explicitly requests a pendig lock.ŸH  **  (3) A shared lock is always held when a reserve lock is requested.§  */Ÿ@  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );Ÿ$  assert( eFileLock!=PENDING_LOCK );ŸF  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );†ŸH  /* This mutex is needed because pFile->pInode is shared across threads§  */≥  unixEnterMutex();π  pInode = pFile->pInode;†ŸG  /* If some thread using this PID has a lock via a different unixFile*Ÿ;  ** handle that precludes the requested lock, return BUSY.§  */Ÿ.  if( (pFile->eFileLock!=pInode->eFileLock && ŸE          (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))§  ){µ    rc = SQLITE_BUSY;≤    goto end_lock;£  }†ŸJ  /* If a SHARED lock is requested, and some thread using this PID alreadyŸG  ** has a SHARED or RESERVED lock, then increment reference counts and∂  ** return SQLITE_OK.§  */Ÿ   if( eFileLock==SHARED_LOCK && ŸM      (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){Ÿ%    assert( eFileLock==SHARED_LOCK );Ÿ"    assert( pFile->eFileLock==0 );Ÿ     assert( pInode->nShared>0 );Ÿ#    pFile->eFileLock = SHARED_LOCK;∂    pInode->nShared++;¥    pInode->nLock++;≤    goto end_lock;£  }††ŸG  /* A PENDING lock is needed before acquiring a SHARED lock and beforeŸH  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will±  ** be released.§  */≤  lock.l_len = 1L;ª  lock.l_whence = SEEK_SET;Ω  if( eFileLock==SHARED_LOCK ŸE      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)§  ){Ÿ;    lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);Ÿ     lock.l_start = PENDING_BYTE;Ÿ%    if( unixFileLock(pFile, &lock) ){µ      tErrno = errno;Ÿ@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);º      if( rc!=SQLITE_BUSY ){Ÿ&        storeLastErrno(pFile, tErrno);ß      }¥      goto end_lock;•    }£  }††ŸC  /* If control gets to this point, then actually go ahead and makeŸ3  ** operating system calls for the specified lock.§  */ø  if( eFileLock==SHARED_LOCK ){Ÿ!    assert( pInode->nShared==0 );Ÿ#    assert( pInode->eFileLock==0 );º    assert( rc==SQLITE_OK );†ø    /* Now get the read-lock */Ÿ     lock.l_start = SHARED_FIRST;Ω    lock.l_len = SHARED_SIZE;Ÿ%    if( unixFileLock(pFile, &lock) ){µ      tErrno = errno;Ÿ@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);•    }†Ÿ)    /* Drop the temporary PENDING lock */Ÿ     lock.l_start = PENDING_BYTE;¥    lock.l_len = 1L;∫    lock.l_type = F_UNLCK;Ÿ6    if( unixFileLock(pFile, &lock) && rc==SQLITE_OK ){Ÿ2      /* This could happen with a network mount */µ      tErrno = errno;Ÿ       rc = SQLITE_IOERR_UNLOCK; •    }†≠    if( rc ){º      if( rc!=SQLITE_BUSY ){Ÿ&        storeLastErrno(pFile, tErrno);ß      }¥      goto end_lock;™    }else{Ÿ%      pFile->eFileLock = SHARED_LOCK;∂      pInode->nLock++;∫      pInode->nShared = 1;•    }Ÿ=  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){ŸE    /* We are trying for an exclusive lock but another thread in thisŸ6    ** same process is still holding a shared lock. */µ    rc = SQLITE_BUSY;®  }else{Ÿ?    /* The request was for a RESERVED or EXCLUSIVE lock.  It isŸA    ** assumed that there is a SHARED or greater lock on the fileØ    ** already.¶    */Ÿ"    assert( 0!=pFile->eFileLock );∫    lock.l_type = F_WRLCK;†ŸD    assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );Ÿ#    if( eFileLock==RESERVED_LOCK ){Ÿ#      lock.l_start = RESERVED_BYTE;∂      lock.l_len = 1L;™    }else{Ÿ"      lock.l_start = SHARED_FIRST;ø      lock.l_len = SHARED_SIZE;•    }†Ÿ%    if( unixFileLock(pFile, &lock) ){µ      tErrno = errno;Ÿ@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);º      if( rc!=SQLITE_BUSY ){Ÿ&        storeLastErrno(pFile, tErrno);ß      }•    }£  }¢  †≥#ifdef SQLITE_DEBUGŸ>  /* Set up the transaction-counter change checking flags whenŸ@  ** transitioning from a SHARED to a RESERVED lock.  The changeŸ<  ** from SHARED to RESERVED marks the beginning of a normalŸ2  ** write operation (not a hot journal rollback).§  */≥  if( rc==SQLITE_OKŸ#   && pFile->eFileLock<=SHARED_LOCKæ   && eFileLock==RESERVED_LOCK§  ){Ω    pFile->transCntrChng = 0;∏    pFile->dbUpdate = 0;Ω    pFile->inNormalWrite = 1;£  }¶#endif††∂  if( rc==SQLITE_OK ){Ÿ!    pFile->eFileLock = eFileLock;Ÿ"    pInode->eFileLock = eFileLock;Ÿ(  }else if( eFileLock==EXCLUSIVE_LOCK ){Ÿ$    pFile->eFileLock = PENDING_LOCK;Ÿ%    pInode->eFileLock = PENDING_LOCK;£  }†©end_lock:≥  unixLeaveMutex();ŸI  OSTRACE(("LOCK    %d %s %s (unix)\n", pFile->h, azFileLock(eFileLock), Ÿ(      rc==SQLITE_OK ? "ok" : "failed"));¨  return rc;°}†¢/*ŸI** Add the file descriptor used by file handle pFile to the corresponding∞** pUnused list.¢*/Ÿ*static void setPendingFd(unixFile *pFile){Ÿ(  unixInodeInfo *pInode = pFile->pInode;Ÿ/  UnixUnusedFd *p = pFile->pPreallocatedUnused;Ω  p->pNext = pInode->pUnused;∂  pInode->pUnused = p;∞  pFile->h = -1;Ÿ!  pFile->pPreallocatedUnused = 0;Æ  nUnusedFd++;°}†¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.£** ŸN** If handleNFSUnlock is true, then on downgrading an EXCLUSIVE_LOCK to SHAREDŸM** the byte range is divided into 2 parts and the first part is unlocked thenŸK** set to a read lock, then the other part is simply unlocked.  This works ŸK** around a bug in BSD NFS lockd (also seen on MacOSX 10.3+) that fails to Ÿ=** remove the write lock on a region when a read lock is set.¢*/ŸMstatic int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){Ÿ"  unixFile *pFile = (unixFile*)id;∏  unixInodeInfo *pInode;¥  struct flock lock;µ  int rc = SQLITE_OK;†≤  assert( pFile );ŸN  OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,ŸI      pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,¥      osGetpid(0)));†Ÿ#  assert( eFileLock<=SHARED_LOCK );Ÿ$  if( pFile->eFileLock<=eFileLock ){µ    return SQLITE_OK;£  }≥  unixEnterMutex();π  pInode = pFile->pInode;ø  assert( pInode->nShared!=0 );Ÿ%  if( pFile->eFileLock>SHARED_LOCK ){Ÿ2    assert( pInode->eFileLock==pFile->eFileLock );†≥#ifdef SQLITE_DEBUGŸ?    /* When reducing a lock such that other processes can startŸ:    ** reading the database file again, make sure that theŸB    ** transaction counter was updated if any part of the databaseŸ@    ** file changed.  If the transaction counter is not updated,Ÿ@    ** other connections to the same file might not realize thatŸC    ** the file has changed and hence might not know to flush theirŸH    ** cache.  The use of a stale cache can lead to database corruption.¶    */Ω    pFile->inNormalWrite = 0;¶#endif†ŸK    /* downgrading to a shared lock on NFS involves clearing the write lockŸP    ** before establishing the readlock - to avoid a race condition we downgradeŸL    ** the lock in 2 blocks, so that part of the range will be covered by a Ÿ;    ** write lock until the rest is covered by a read lock:¥    **  1:   [WWWWW]¥    **  2:   [....W]¥    **  3:   [RRRRW]¥    **  4:   [RRRR.]¶    */Ÿ!    if( eFileLock==SHARED_LOCK ){Ÿ7#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLEº      (void)handleNFSUnlock;Ÿ#      assert( handleNFSUnlock==0 );¶#endifŸ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEº      if( handleNFSUnlock ){ŸJ        int tErrno;               /* Error code from system call errors */Ÿ(        off_t divSize = SHARED_SIZE - 1;®        æ        lock.l_type = F_UNLCK;Ÿ!        lock.l_whence = SEEK_SET;Ÿ$        lock.l_start = SHARED_FIRST;Ω        lock.l_len = divSize;Ÿ/        if( unixFileLock(pFile, &lock)==(-1) ){π          tErrno = errno;Ÿ#          rc = SQLITE_IOERR_UNLOCK;Ÿ(          storeLastErrno(pFile, tErrno);∫          goto end_unlock;©        }æ        lock.l_type = F_RDLCK;Ÿ!        lock.l_whence = SEEK_SET;Ÿ$        lock.l_start = SHARED_FIRST;Ω        lock.l_len = divSize;Ÿ/        if( unixFileLock(pFile, &lock)==(-1) ){π          tErrno = errno;ŸF          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);Ÿ"          if( IS_LOCK_ERROR(rc) ){Ÿ*            storeLastErrno(pFile, tErrno);´          }∫          goto end_unlock;©        }æ        lock.l_type = F_UNLCK;Ÿ!        lock.l_whence = SEEK_SET;Ÿ,        lock.l_start = SHARED_FIRST+divSize;Ÿ)        lock.l_len = SHARED_SIZE-divSize;Ÿ/        if( unixFileLock(pFile, &lock)==(-1) ){π          tErrno = errno;Ÿ#          rc = SQLITE_IOERR_UNLOCK;Ÿ(          storeLastErrno(pFile, tErrno);∫          goto end_unlock;©        }´      }elseŸ>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */ß      {æ        lock.l_type = F_RDLCK;Ÿ!        lock.l_whence = SEEK_SET;Ÿ$        lock.l_start = SHARED_FIRST;Ÿ!        lock.l_len = SHARED_SIZE;Ÿ)        if( unixFileLock(pFile, &lock) ){ŸN          /* In theory, the call to unixFileLock() cannot fail because anotherŸG          ** process is holding an incompatible lock. If it does, this ŸJ          ** indicates that the other process is not following the lockingŸM          ** protocol. If this happens, return SQLITE_IOERR_RDLOCK. ReturningŸN          ** SQLITE_BUSY would confuse the upper layer (in practice it causes Ÿ$          ** an assert to fail). */ Ÿ#          rc = SQLITE_IOERR_RDLOCK;Ÿ'          storeLastErrno(pFile, errno);∫          goto end_unlock;©        }ß      }•    }∫    lock.l_type = F_UNLCK;Ω    lock.l_whence = SEEK_SET;Ÿ     lock.l_start = PENDING_BYTE;Ÿ>    lock.l_len = 2L;  assert( PENDING_BYTE+1==RESERVED_BYTE );Ÿ(    if( unixFileLock(pFile, &lock)==0 ){Ÿ&      pInode->eFileLock = SHARED_LOCK;™    }else{ø      rc = SQLITE_IOERR_UNLOCK;Ÿ#      storeLastErrno(pFile, errno);∂      goto end_unlock;•    }£  }ª  if( eFileLock==NO_LOCK ){ŸD    /* Decrement the shared lock counter.  Release the lock using anŸG    ** OS call only when all threads in this same process have released∞    ** the lock.¶    */∂    pInode->nShared--;Ω    if( pInode->nShared==0 ){º      lock.l_type = F_UNLCK;ø      lock.l_whence = SEEK_SET;Ÿ%      lock.l_start = lock.l_len = 0L;Ÿ*      if( unixFileLock(pFile, &lock)==0 ){Ÿ$        pInode->eFileLock = NO_LOCK;¨      }else{Ÿ!        rc = SQLITE_IOERR_UNLOCK;Ÿ%        storeLastErrno(pFile, errno);Ÿ$        pInode->eFileLock = NO_LOCK;Ÿ#        pFile->eFileLock = NO_LOCK;ß      }•    }†ŸE    /* Decrement the count of locks against this same file.  When theŸG    ** count reaches zero, close any other file descriptors whose closeŸ1    ** was deferred because of outstanding locks.¶    */¥    pInode->nLock--;ø    assert( pInode->nLock>=0 );ª    if( pInode->nLock==0 ){Ω      closePendingFds(pFile);•    }£  }†´end_unlock:≥  unixLeaveMutex();Ÿ3  if( rc==SQLITE_OK ) pFile->eFileLock = eFileLock;¨  return rc;°}†¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢*/Ÿ7static int unixUnlock(sqlite3_file *id, int eFileLock){∫#if SQLITE_MAX_MMAP_SIZE>0ŸE  assert( eFileLock==SHARED_LOCK || ((unixFile *)id)->nFetchOut==0 );¶#endifŸ'  return posixUnlock(id, eFileLock, 0);°}†∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ1static int unixMapfile(unixFile *pFd, i64 nByte);Ÿ)static void unixUnmapfile(unixFile *pFd);¶#endif†¢/*ŸB** This function performs the parts of the "close file" operation ŸB** common to all locking schemes. It closes the directory and fileŸB** handles, if they are valid, and sets all fields of the unixFile≤** structure to 0.¢**ŸG** It is *not* necessary to hold the mutex when this routine is called,Ÿ?** even on VxWorks.  A mutex will be acquired on VxWorks by theŸ"** vxworksReleaseFileId() routine.¢*/Ÿ+static int closeUnixFile(sqlite3_file *id){Ÿ"  unixFile *pFile = (unixFile*)id;∫#if SQLITE_MAX_MMAP_SIZE>0∑  unixUnmapfile(pFile);¶#endif¥  if( pFile->h>=0 ){Ÿ,    robust_close(pFile, pFile->h, __LINE__);≤    pFile->h = -1;£  }Æ#if OS_VXWORKS≥  if( pFile->pId ){Ÿ-    if( pFile->ctrlFlags & UNIXFILE_DELETE ){Ÿ+      osUnlink(pFile->pId->zCanonicalName);•    }Ÿ%    vxworksReleaseFileId(pFile->pId);≥    pFile->pId = 0;£  }¶#endifŸ #ifdef SQLITE_UNLINK_AFTER_CLOSEŸ+  if( pFile->ctrlFlags & UNIXFILE_DELETE ){ª    osUnlink(pFile->zPath);Ÿ)    sqlite3_free(*(char**)&pFile->zPath);µ    pFile->zPath = 0;£  }¶#endifŸ(  OSTRACE(("CLOSE   %-3d\n", pFile->h));≤  OpenCounter(-1);Ÿ+  sqlite3_free(pFile->pPreallocatedUnused);Ÿ%  memset(pFile, 0, sizeof(unixFile));≥  return SQLITE_OK;°}†¢/*∞** Close a file.¢*/Ÿ'static int unixClose(sqlite3_file *id){µ  int rc = SQLITE_OK;Ÿ#  unixFile *pFile = (unixFile *)id;∂  verifyDbFile(pFile);∫  unixUnlock(id, NO_LOCK);≥  unixEnterMutex();†ŸG  /* unixFile.pInode is always valid here. Otherwise, a different closeŸ:  ** routine (e.g. nolockClose()) would be called instead.§  */ŸE  assert( pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 );Ÿ6  if( ALWAYS(pFile->pInode) && pFile->pInode->nLock ){ŸJ    /* If there are outstanding locks, do not actually close the file justŸG    ** yet because that would clear those locks.  Instead, add the fileŸL    ** descriptor to pInode->pUnused list.  It will be automatically closed Ÿ%    ** when the last lock is cleared.¶    */∏    setPendingFd(pFile);£  }∫  releaseInodeInfo(pFile);π  rc = closeUnixFile(id);≥  unixLeaveMutex();¨  return rc;°}†ŸO/************** End of the posix advisory lock implementation *****************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO****************************** No-op Locking **********************************¢**ŸG** Of the various locking implementations available, this is by far theŸJ** simplest:  locking is ignored.  No attempt is made to lock the databaseø** file for reading or writing.¢**ŸB** This locking mode is appropriate for use on read-only databasesŸD** (ex: databases that are burned into CD-ROM, for example.)  It canŸE** also be used if the application employs some external mechanism toŸB** prevent simultaneous access of the same database by two or moreŸA** database connections.  But there is a serious risk of databaseŸG** corruption if this locking mode is used in situations where multipleŸH** database connections are accessing the same database file at the sameŸ9** time and one or more of those connections are writing.¢*/†ŸHstatic int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){º  UNUSED_PARAMETER(NotUsed);Ø  *pResOut = 0;≥  return SQLITE_OK;°}Ÿ;static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){Ÿ'  UNUSED_PARAMETER2(NotUsed, NotUsed2);≥  return SQLITE_OK;°}Ÿ=static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){Ÿ'  UNUSED_PARAMETER2(NotUsed, NotUsed2);≥  return SQLITE_OK;°}†¢/*≤** Close the file.¢*/Ÿ*static int nolockClose(sqlite3_file *id) {ª  return closeUnixFile(id);°}†ŸO/******************* End of the no-op lock implementation *********************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO************************* Begin dot-file Locking ******************************¢**ŸI** The dotfile locking implementation uses the existence of separate lockŸL** files (really a directory) to control access to the database.  This worksŸO** on just about every filesystem imaginable.  But there are serious downsides:¢**ŸG**    (1)  There is zero concurrency.  A single reader blocks all otherŸ<**         connections from reading or writing the database.¢**ŸH**    (2)  An application crash or power loss can leave stale lock filesŸ;**         sitting around that need to be cleared manually.¢**ŸG** Nevertheless, a dotlock is an appropriate locking mode for use if noŸ'** other locking strategy is available.¢**ŸL** Dotfile locking works by creating a subdirectory in the same directory asŸJ** the database and with the same name but with a ".lock" extension added.ŸJ** The existence of a lock directory implies an EXCLUSIVE lock.  All otherŸD** lock types (SHARED, RESERVED, PENDING) are mapped into EXCLUSIVE.¢*/†¢/*ŸI** The file suffix added to the data base filename in order to create the≤** lock directory.¢*/æ#define DOTLOCK_SUFFIX ".lock"†¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸJ** file by this or any other process. If such a lock is held, set *pResOutŸK** to a non-zero value otherwise *pResOut is set to zero.  The return valueŸG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢**ŸG** In dotfile locking, either a lock exists or it does not.  So in thisŸH** variation of CheckReservedLock(), *pResOut is set to true if any lockŸ9** is held on the file and false if the file is unlocked.¢*/ŸEstatic int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {µ  int rc = SQLITE_OK;≥  int reserved = 0;Ÿ"  unixFile *pFile = (unixFile*)id;†Ÿ<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ≤  assert( pFile );Ÿ@  reserved = osAccess((const char*)pFile->lockingContext, 0)==0;ŸI  OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, rc, reserved));∂  *pResOut = reserved;¨  return rc;°}†¢/*ŸE** Lock the file with the lock specified by parameter eFileLock - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ÿ$** routine to lower a locking level.¢**ŸE** With dotfile locking, we really only support state (4): EXCLUSIVE.Ÿ4** But we track the other locking levels internally.¢*/Ÿ9static int dotlockLock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ2  char *zLockFile = (char *)pFile->lockingContext;µ  int rc = SQLITE_OK;††ŸI  /* If we have any lock, then the lock file already exists.  All we haveŸ;  ** to do is adjust our internal record of the lock level.§  */Ÿ#  if( pFile->eFileLock > NO_LOCK ){Ÿ!    pFile->eFileLock = eFileLock;Ÿ5    /* Always update the timestamp on the old file */±#ifdef HAVE_UTIMEª    utime(zLockFile, NULL);•#elseº    utimes(zLockFile, NULL);¶#endifµ    return SQLITE_OK;£  }¢  æ  /* grab an exclusive lock */Ÿ   rc = osMkdir(zLockFile, 0777);≠  if( rc<0 ){Ÿ2    /* failed to open/create the lock directory */∑    int tErrno = errno;ª    if( EEXIST == tErrno ){∑      rc = SQLITE_BUSY;¨    } else {Ÿ@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);º      if( rc!=SQLITE_BUSY ){Ÿ&        storeLastErrno(pFile, tErrno);ß      }•    }Æ    return rc;§  } ¢  Ÿ*  /* got it, set the type and return ok */ø  pFile->eFileLock = eFileLock;¨  return rc;°}†¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢**Ÿ@** When the locking level reaches NO_LOCK, delete the lock file.¢*/Ÿ;static int dotlockUnlock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ2  char *zLockFile = (char *)pFile->lockingContext;©  int rc;†≤  assert( pFile );ŸJ  OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,Ÿ+           pFile->eFileLock, osGetpid(0)));Ÿ#  assert( eFileLock<=SHARED_LOCK );¢  π  /* no-op if possible */Ÿ$  if( pFile->eFileLock==eFileLock ){µ    return SQLITE_OK;£  }†ŸE  /* To downgrade to shared, simply update our internal notion of theŸ8  ** lock state.  No need to mess with the file on disk.§  */ø  if( eFileLock==SHARED_LOCK ){Ÿ#    pFile->eFileLock = SHARED_LOCK;µ    return SQLITE_OK;£  }¢  Ÿ:  /* To fully unlock the database, delete the lock file */ø  assert( eFileLock==NO_LOCK );∫  rc = osRmdir(zLockFile);≠  if( rc<0 ){∑    int tErrno = errno;π    if( tErrno==ENOENT ){µ      rc = SQLITE_OK;™    }else{ø      rc = SQLITE_IOERR_UNLOCK;Ÿ$      storeLastErrno(pFile, tErrno);•    }Ø    return rc; £  }Ω  pFile->eFileLock = NO_LOCK;≥  return SQLITE_OK;°}†¢/*ŸF** Close a file.  Make sure the lock has been released before closing.¢*/Ÿ+static int dotlockClose(sqlite3_file *id) {Ÿ"  unixFile *pFile = (unixFile*)id;≤  assert( id!=0 );Ω  dotlockUnlock(id, NO_LOCK);Ÿ&  sqlite3_free(pFile->lockingContext);ª  return closeUnixFile(id);°}ŸO/****************** End of the dot-file lock implementation *******************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO************************** Begin flock Locking ********************************¢**Ÿ2** Use the flock() system call to do file locking.¢**Ÿ?** flock() locking is like dot-file locking in that the variousŸC** fine-grain locking levels supported by SQLite are collapsed intoŸB** a single exclusive lock.  In other words, SHARED, RESERVED, andŸA** PENDING locks are the same thing as an EXCLUSIVE lock.  SQLiteŸA** still works when you do this, but concurrency is reduced sinceŸ?** only a single process can be reading the database at a time.¢**ŸA** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off¢*/ø#if SQLITE_ENABLE_LOCKING_STYLE†¢/*Ÿ+** Retry flock() calls that fail with EINTR¢*/¨#ifdef EINTRŸ(static int robust_flock(int fd, int op){©  int rc;Ÿ8  do{ rc = flock(fd,op); }while( rc<0 && errno==EINTR );¨  return rc;°}•#elseŸ%# define robust_flock(a,b) flock(a,b)¶#endif•     †¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸJ** file by this or any other process. If such a lock is held, set *pResOutŸK** to a non-zero value otherwise *pResOut is set to zero.  The return valueŸG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ŸBstatic int flockCheckReservedLock(sqlite3_file *id, int *pResOut){µ  int rc = SQLITE_OK;≥  int reserved = 0;Ÿ"  unixFile *pFile = (unixFile*)id;¢  Ÿ<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ≤  assert( pFile );¢  Ÿ;  /* Check if a thread in this process holds such a lock */Ÿ%  if( pFile->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }¢  Ÿ5  /* Otherwise see if some other process holds it. */≤  if( !reserved ){Ÿ!    /* attempt to get the lock */Ÿ8    int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);Ø    if( !lrc ){Ÿ#      /* got the lock, unlock it */Ÿ,      lrc = robust_flock(pFile->h, LOCK_UN);≤      if ( lrc ) {ª        int tErrno = errno;Ÿ)        /* unlock failed with an error */Ÿ#        lrc = SQLITE_IOERR_UNLOCK; Ÿ&        storeLastErrno(pFile, tErrno);±        rc = lrc;ß      }¨    } else {π      int tErrno = errno;≥      reserved = 1;Ÿ/      /* someone else might have it reserved */ŸB      lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); ø      if( IS_LOCK_ERROR(lrc) ){Ÿ&        storeLastErrno(pFile, tErrno);±        rc = lrc;ß      }•    }£  }ŸG  OSTRACE(("TEST WR-LOCK %d %d %d (flock)\n", pFile->h, rc, reserved));†Ÿ&#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORSŸ$  if( (rc & 0xff) == SQLITE_IOERR ){≥    rc = SQLITE_OK;Ø    reserved=1;£  }Ÿ,#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */∂  *pResOut = reserved;¨  return rc;°}†¢/*ŸE** Lock the file with the lock specified by parameter eFileLock - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸF** flock() only really support EXCLUSIVE locks.  We track intermediateŸE** lock states in the sqlite3_file structure, but all locks SHARED orŸH** above are really EXCLUSIVE locks and exclude all other processes from≥** access the file.¢**ŸE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ÿ$** routine to lower a locking level.¢*/Ÿ7static int flockLock(sqlite3_file *id, int eFileLock) {µ  int rc = SQLITE_OK;Ÿ"  unixFile *pFile = (unixFile*)id;†≤  assert( pFile );†Ÿ2  /* if we already have a lock, it is exclusive.  Ÿ1  ** Just adjust level and punt on outta here. */Ÿ#  if (pFile->eFileLock > NO_LOCK) {Ÿ!    pFile->eFileLock = eFileLock;µ    return SQLITE_OK;£  }¢  æ  /* grab an exclusive lock */¢  Ÿ2  if (robust_flock(pFile->h, LOCK_EX | LOCK_NB)) {∑    int tErrno = errno;Ÿ"    /* didn't get, must be busy */Ÿ>    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);º    if( IS_LOCK_ERROR(rc) ){Ÿ$      storeLastErrno(pFile, tErrno);•    }™  } else {Ÿ,    /* got it, set the type and return ok */Ÿ!    pFile->eFileLock = eFileLock;£  }ŸJ  OSTRACE(("LOCK    %d %s %s (flock)\n", pFile->h, azFileLock(eFileLock), Ÿ-           rc==SQLITE_OK ? "ok" : "failed"));Ÿ&#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORSŸ$  if( (rc & 0xff) == SQLITE_IOERR ){µ    rc = SQLITE_BUSY;£  }Ÿ,#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */¨  return rc;°}††¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢*/Ÿ9static int flockUnlock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;¢  ≤  assert( pFile );ŸH  OSTRACE(("UNLOCK  %d %d was %d pid=%d (flock)\n", pFile->h, eFileLock,Ÿ+           pFile->eFileLock, osGetpid(0)));Ÿ#  assert( eFileLock<=SHARED_LOCK );¢  π  /* no-op if possible */Ÿ$  if( pFile->eFileLock==eFileLock ){µ    return SQLITE_OK;£  }¢  ŸB  /* shared can just be set because we always have an exclusive */ø  if (eFileLock==SHARED_LOCK) {Ÿ!    pFile->eFileLock = eFileLock;µ    return SQLITE_OK;£  }¢  ª  /* no, really, unlock. */Ÿ(  if( robust_flock(pFile->h, LOCK_UN) ){Ÿ&#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORSµ    return SQLITE_OK;Ÿ,#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */ø    return SQLITE_IOERR_UNLOCK;®  }else{ø    pFile->eFileLock = NO_LOCK;µ    return SQLITE_OK;£  }°}†¢/*∞** Close a file.¢*/Ÿ)static int flockClose(sqlite3_file *id) {≤  assert( id!=0 );ª  flockUnlock(id, NO_LOCK);ª  return closeUnixFile(id);°}†Ÿ6#endif /* SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORK */†ŸO/******************* End of the flock lock implementation *********************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO************************ Begin Named Semaphore Locking ************************¢**Ÿ8** Named semaphore locking is only supported on VxWorks.¢**ŸF** Semaphore locking is like dot-lock and flock in that it really onlyŸG** supports EXCLUSIVE locking.  Only a single process can read or writeŸH** the database file at a time.  This reduces potential concurrency, butŸ-** makes the lock implementation much easier.¢*/Æ#if OS_VXWORKS†¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸJ** file by this or any other process. If such a lock is held, set *pResOutŸK** to a non-zero value otherwise *pResOut is set to zero.  The return valueŸG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ŸBstatic int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {µ  int rc = SQLITE_OK;≥  int reserved = 0;Ÿ"  unixFile *pFile = (unixFile*)id;†Ÿ<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ≤  assert( pFile );†Ÿ;  /* Check if a thread in this process holds such a lock */Ÿ%  if( pFile->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }¢  Ÿ5  /* Otherwise see if some other process holds it. */≤  if( !reserved ){Ÿ&    sem_t *pSem = pFile->pInode->pSem;†Ÿ     if( sem_trywait(pSem)==-1 ){π      int tErrno = errno;Ω      if( EAGAIN != tErrno ){ŸO        rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);Ÿ&        storeLastErrno(pFile, tErrno);Æ      } else {Ÿ>        /* someone else has the lock when we are in NO_LOCK */Ÿ4        reserved = (pFile->eFileLock < SHARED_LOCK);ß      }™    }else{Ÿ*      /* we could have it if we want it */µ      sem_post(pSem);•    }£  }ŸE  OSTRACE(("TEST WR-LOCK %d %d %d (sem)\n", pFile->h, rc, reserved));†∂  *pResOut = reserved;¨  return rc;°}†¢/*ŸE** Lock the file with the lock specified by parameter eFileLock - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸN** Semaphore locks only really support EXCLUSIVE locks.  We track intermediateŸE** lock states in the sqlite3_file structure, but all locks SHARED orŸH** above are really EXCLUSIVE locks and exclude all other processes from≥** access the file.¢**ŸE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ÿ$** routine to lower a locking level.¢*/Ÿ6static int semXLock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ$  sem_t *pSem = pFile->pInode->pSem;µ  int rc = SQLITE_OK;†Ÿ2  /* if we already have a lock, it is exclusive.  Ÿ1  ** Just adjust level and punt on outta here. */Ÿ#  if (pFile->eFileLock > NO_LOCK) {Ÿ!    pFile->eFileLock = eFileLock;≥    rc = SQLITE_OK;∂    goto sem_end_lock;£  }¢  Ÿ<  /* lock semaphore now but bail out when already locked. */æ  if( sem_trywait(pSem)==-1 ){µ    rc = SQLITE_BUSY;∂    goto sem_end_lock;£  }†Ÿ*  /* got it, set the type and return ok */ø  pFile->eFileLock = eFileLock;†Æ sem_end_lock:¨  return rc;°}†¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢*/Ÿ8static int semXUnlock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ$  sem_t *pSem = pFile->pInode->pSem;†≤  assert( pFile );±  assert( pSem );ŸF  OSTRACE(("UNLOCK  %d %d was %d pid=%d (sem)\n", pFile->h, eFileLock,Ÿ+           pFile->eFileLock, osGetpid(0)));Ÿ#  assert( eFileLock<=SHARED_LOCK );¢  π  /* no-op if possible */Ÿ$  if( pFile->eFileLock==eFileLock ){µ    return SQLITE_OK;£  }¢  ŸB  /* shared can just be set because we always have an exclusive */ø  if (eFileLock==SHARED_LOCK) {Ÿ!    pFile->eFileLock = eFileLock;µ    return SQLITE_OK;£  }¢  ∫  /* no, really unlock. */Ω  if ( sem_post(pSem)==-1 ) {ª    int rc, tErrno = errno;Ÿ@    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);º    if( IS_LOCK_ERROR(rc) ){Ÿ$      storeLastErrno(pFile, tErrno);•    }Ø    return rc; £  }Ω  pFile->eFileLock = NO_LOCK;≥  return SQLITE_OK;°}†¢/*± ** Close a file.£ */Ÿ(static int semXClose(sqlite3_file *id) {´  if( id ){Ÿ$    unixFile *pFile = (unixFile*)id;º    semXUnlock(id, NO_LOCK);¥    assert( pFile );µ    unixEnterMutex();º    releaseInodeInfo(pFile);µ    unixLeaveMutex();∂    closeUnixFile(id);£  }≥  return SQLITE_OK;°}†∑#endif /* OS_VXWORKS */¢/*Ÿ8** Named semaphore locking is only available on VxWorks.¢**ŸO*************** End of the named semaphore lock implementation ****************ŸO******************************************************************************/††ŸO/******************************************************************************ŸO*************************** Begin AFP Locking *********************************¢**ŸG** AFP is the Apple Filing Protocol.  AFP is a network filesystem foundŸ3** on Apple Macintosh computers - both OS9 and OSX.¢**ŸH** Third-party implementations of AFP are available.  But this code hereµ** only works on OSX.¢*/†Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE¢/*ŸG** The afpLockingContext structure contains all afp lock specific state¢*/Ÿ3typedef struct afpLockingContext afpLockingContext;∫struct afpLockingContext {Ø  int reserved;Ÿ=  const char *dbPath;             /* Name of the open file */¢};†∑struct ByteRangeLockPB2°{ŸF  unsigned long long offset;        /* offset to first byte to lock */Ÿ>  unsigned long long length;        /* nbr of bytes to lock */ŸN  unsigned long long retRangeStart; /* nbr of 1st byte locked if successful */Ÿ>  unsigned char unLockFlag;         /* 1 = unlock, 0 = lock */ŸN  unsigned char startEndFlag;       /* 1=rel to end of fork, 0=rel to start */ŸK  int fd;                           /* file desc to assoc this lock with */¢};†ŸO#define afpfsByteRangeLock2FSCTL        _IOWR('z', 23, struct ByteRangeLockPB2)†¢/*ŸC** This is a utility for setting or clearing a bit-range lock on an≤** AFP filesystem.£** Ÿ7** Return SQLITE_OK on success, SQLITE_BUSY on failure.¢*/∂static int afpSetLock(ŸP  const char *path,              /* Name of the file to be locked or unlocked */ŸC  unixFile *pFile,               /* Open file descriptor on path */Ÿ>  unsigned long long offset,     /* First byte to be locked */Ÿ>  unsigned long long length,     /* Number of bytes to lock */ŸM  int setLockFlag                /* True to set lock.  False to clear lock */¢){Ω  struct ByteRangeLockPB2 pb;™  int err;¢  Ÿ&  pb.unLockFlag = setLockFlag ? 0 : 1;∂  pb.startEndFlag = 0;µ  pb.offset = offset;∂  pb.length = length; ≥  pb.fd = pFile->h;¢  Ÿ<  OSTRACE(("AFPSETLOCK [%s] for %d%s in range %llx:%llx\n", ŸE    (setLockFlag?"ON":"OFF"), pFile->h, (pb.fd==-1?"[testval-1]":""),µ    offset, length));Ÿ6  err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0);≤  if ( err==-1 ) {´    int rc;∑    int tErrno = errno;Ÿ9    OSTRACE(("AFPSETLOCK failed to fsctl() '%s' %d %s\n",Ÿ.             path, tErrno, strerror(tErrno)));Ÿ$#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORSµ    rc = SQLITE_BUSY;•#elseŸ*    rc = sqliteErrorFromPosixError(tErrno,ŸK                    setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);Ÿ*#endif /* SQLITE_IGNORE_AFP_LOCK_ERRORS */º    if( IS_LOCK_ERROR(rc) ){Ÿ$      storeLastErrno(pFile, tErrno);•    }Æ    return rc;™  } else {µ    return SQLITE_OK;£  }°}†¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸJ** file by this or any other process. If such a lock is held, set *pResOutŸK** to a non-zero value otherwise *pResOut is set to zero.  The return valueŸG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/Ÿ@static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){µ  int rc = SQLITE_OK;≥  int reserved = 0;Ÿ"  unixFile *pFile = (unixFile*)id;Ω  afpLockingContext *context;¢  Ÿ<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ≤  assert( pFile );Ÿ8  context = (afpLockingContext *) pFile->lockingContext;∫  if( context->reserved ){±    *pResOut = 1;µ    return SQLITE_OK;£  }ŸH  unixEnterMutex(); /* Because pFile->pInode is shared across threads */¢  Ÿ;  /* Check if a thread in this process holds such a lock */Ÿ-  if( pFile->pInode->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }¢  Ÿ2  /* Otherwise see if some other process holds it.•   */≤  if( !reserved ){Ÿ     /* lock the RESERVED byte */ŸG    int lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);  π    if( SQLITE_OK==lrc ){ŸJ      /* if we succeeded in taking the reserved lock, unlock it to restoreæ      ** the original state */ŸD      lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);¨    } else {ŸG      /* if we failed to get the lock then someone else must have it */≥      reserved = 1;•    }Ω    if( IS_LOCK_ERROR(lrc) ){≠      rc=lrc;•    }£  }¢  ≥  unixLeaveMutex();ŸE  OSTRACE(("TEST WR-LOCK %d %d %d (afp)\n", pFile->h, rc, reserved));¢  ∂  *pResOut = reserved;¨  return rc;°}†¢/*ŸE** Lock the file with the lock specified by parameter eFileLock - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ÿ$** routine to lower a locking level.¢*/Ÿ4static int afpLock(sqlite3_file *id, int eFileLock){µ  int rc = SQLITE_OK;Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ(  unixInodeInfo *pInode = pFile->pInode;ŸK  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;¢  ≤  assert( pFile );ŸB  OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (afp)\n", pFile->h,Ÿ?           azFileLock(eFileLock), azFileLock(pFile->eFileLock),ŸJ           azFileLock(pInode->eFileLock), pInode->nShared , osGetpid(0)));†ŸG  /* If there is already a lock of this type or more restrictive on theŸD  ** unixFile, do nothing. Don't use the afp_end_lock: exit path, asŸ-  ** unixEnterMutex() hasn't been called yet.§  */Ÿ$  if( pFile->eFileLock>=eFileLock ){ŸA    OSTRACE(("LOCK    %d %s ok (already held) (afp)\n", pFile->h,Ÿ#           azFileLock(eFileLock)));µ    return SQLITE_OK;£  }†Ÿ.  /* Make sure the locking sequence is correctŸJ  **  (1) We never move from unlocked to anything higher than shared lock.Ÿ9  **  (2) SQLite never explicitly requests a pendig lock.ŸH  **  (3) A shared lock is always held when a reserve lock is requested.§  */Ÿ@  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );Ÿ$  assert( eFileLock!=PENDING_LOCK );ŸF  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );¢  ŸH  /* This mutex is needed because pFile->pInode is shared across threads§  */≥  unixEnterMutex();π  pInode = pFile->pInode;†ŸG  /* If some thread using this PID has a lock via a different unixFile*Ÿ;  ** handle that precludes the requested lock, return BUSY.§  */Ÿ.  if( (pFile->eFileLock!=pInode->eFileLock && ŸB       (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))ß     ){µ    rc = SQLITE_BUSY;∂    goto afp_end_lock;£  }¢  ŸJ  /* If a SHARED lock is requested, and some thread using this PID alreadyŸG  ** has a SHARED or RESERVED lock, then increment reference counts and∂  ** return SQLITE_OK.§  */Ÿ   if( eFileLock==SHARED_LOCK && ŸL     (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){Ÿ%    assert( eFileLock==SHARED_LOCK );Ÿ"    assert( pFile->eFileLock==0 );Ÿ     assert( pInode->nShared>0 );Ÿ#    pFile->eFileLock = SHARED_LOCK;∂    pInode->nShared++;¥    pInode->nLock++;∂    goto afp_end_lock;£  }§    ŸG  /* A PENDING lock is needed before acquiring a SHARED lock and beforeŸH  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will±  ** be released.§  */Ω  if( eFileLock==SHARED_LOCK ŸE      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)§  ){Ø    int failed;ŸD    failed = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 1);±    if (failed) {≤      rc = failed;∏      goto afp_end_lock;•    }£  }¢  ŸC  /* If control gets to this point, then actually go ahead and makeŸ3  ** operating system calls for the specified lock.§  */ø  if( eFileLock==SHARED_LOCK ){Ÿ"    int lrc1, lrc2, lrc1Errno = 0;≤    long lk, mask;§    Ÿ!    assert( pInode->nShared==0 );Ÿ#    assert( pInode->eFileLock==0 );®        Ÿ:    mask = (sizeof(long)==8) ? LARGEST_INT64 : 0x7fffffff;Ÿ+    /* Now get the read-lock SHARED_LOCK */ŸJ    /* note that the quality of the randomness doesn't matter that much */≥    lk = random(); Ÿ7    pInode->sharedByte = (lk & mask)%(SHARED_SIZE - 1);Ÿ.    lrc1 = afpSetLock(context->dbPath, pFile, Ÿ1          SHARED_FIRST+pInode->sharedByte, 1, 1);æ    if( IS_LOCK_ERROR(lrc1) ){Ÿ#      lrc1Errno = pFile->lastErrno;•    }Ÿ)    /* Drop the temporary PENDING lock */ŸB    lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);§    ø    if( IS_LOCK_ERROR(lrc1) ) {Ÿ'      storeLastErrno(pFile, lrc1Errno);∞      rc = lrc1;∏      goto afp_end_lock;Ÿ%    } else if( IS_LOCK_ERROR(lrc2) ){∞      rc = lrc2;∏      goto afp_end_lock;Ÿ$    } else if( lrc1 != SQLITE_OK ) {∞      rc = lrc1;¨    } else {Ÿ%      pFile->eFileLock = SHARED_LOCK;∂      pInode->nLock++;∫      pInode->nShared = 1;•    }Ÿ=  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){ŸE    /* We are trying for an exclusive lock but another thread in thisŸ7     ** same process is still holding a shared lock. */µ    rc = SQLITE_BUSY;®  }else{Ÿ?    /* The request was for a RESERVED or EXCLUSIVE lock.  It isŸA    ** assumed that there is a SHARED or greater lock on the fileØ    ** already.¶    */≥    int failed = 0;Ÿ"    assert( 0!=pFile->eFileLock );ŸI    if (eFileLock >= RESERVED_LOCK && pFile->eFileLock < RESERVED_LOCK) {Ÿ%        /* Acquire a RESERVED lock */ŸH        failed = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);¥      if( !failed ){æ        context->reserved = 1;ß      }•    }Ÿ1    if (!failed && eFileLock == EXCLUSIVE_LOCK) {Ÿ%      /* Acquire an EXCLUSIVE lock */®        ŸH      /* Remove the shared lock before trying the range.  we'll need to ŸC      ** reestablish the shared lock if we can't get the  afpUnlock®      */ŸF      if( !(failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST +Ÿ6                         pInode->sharedByte, 1, 0)) ){Ÿ         int failed2 = SQLITE_OK;Ÿ:        /* now attemmpt to get the exclusive lock range */ŸB        failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST, Ÿ/                               SHARED_SIZE, 1);ŸD        if( failed && (failed2 = afpSetLock(context->dbPath, pFile, ŸC                       SHARED_FIRST + pInode->sharedByte, 1, 1)) ){ŸK          /* Can't reestablish the shared lock.  Sqlite can't deal, this isŸ!          ** a critical I/O error¨          */Ÿ=          rc = ((failed & 0xff) == SQLITE_IOERR) ? failed2 : Ÿ!               SQLITE_IOERR_LOCK;º          goto afp_end_lock;™        } ¨      }else{µ        rc = failed; ß      }•    }±    if( failed ){≤      rc = failed;•    }£  }¢  ∂  if( rc==SQLITE_OK ){Ÿ!    pFile->eFileLock = eFileLock;Ÿ"    pInode->eFileLock = eFileLock;Ÿ(  }else if( eFileLock==EXCLUSIVE_LOCK ){Ÿ$    pFile->eFileLock = PENDING_LOCK;Ÿ%    pInode->eFileLock = PENDING_LOCK;£  }¢  ≠afp_end_lock:≥  unixLeaveMutex();ŸH  OSTRACE(("LOCK    %d %s %s (afp)\n", pFile->h, azFileLock(eFileLock), Ÿ+         rc==SQLITE_OK ? "ok" : "failed"));¨  return rc;°}†¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢*/Ÿ7static int afpUnlock(sqlite3_file *id, int eFileLock) {µ  int rc = SQLITE_OK;Ÿ"  unixFile *pFile = (unixFile*)id;∏  unixInodeInfo *pInode;ŸK  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;µ  int skipShared = 0;≤#ifdef SQLITE_TEST≥  int h = pFile->h;¶#endif†≤  assert( pFile );ŸM  OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\n", pFile->h, eFileLock,ŸN           pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,π           osGetpid(0)));†Ÿ#  assert( eFileLock<=SHARED_LOCK );Ÿ$  if( pFile->eFileLock<=eFileLock ){µ    return SQLITE_OK;£  }≥  unixEnterMutex();π  pInode = pFile->pInode;ø  assert( pInode->nShared!=0 );Ÿ%  if( pFile->eFileLock>SHARED_LOCK ){Ÿ2    assert( pInode->eFileLock==pFile->eFileLock );Ω    SimulateIOErrorBenign(1);Ω    SimulateIOError( h=(-1) )Ω    SimulateIOErrorBenign(0);§    ≥#ifdef SQLITE_DEBUGŸ?    /* When reducing a lock such that other processes can startŸ:    ** reading the database file again, make sure that theŸB    ** transaction counter was updated if any part of the databaseŸ@    ** file changed.  If the transaction counter is not updated,Ÿ@    ** other connections to the same file might not realize thatŸC    ** the file has changed and hence might not know to flush theirŸH    ** cache.  The use of a stale cache can lead to database corruption.¶    */Ÿ#    assert( pFile->inNormalWrite==0Ÿ            || pFile->dbUpdate==0Ÿ(           || pFile->transCntrChng==1 );Ω    pFile->inNormalWrite = 0;¶#endif§    Ÿ+    if( pFile->eFileLock==EXCLUSIVE_LOCK ){ŸL      rc = afpSetLock(context->dbPath, pFile, SHARED_FIRST, SHARED_SIZE, 0);ŸK      if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1) ){Ÿ<        /* only re-establish the shared lock if necessary */Ÿ=        int sharedLockByte = SHARED_FIRST+pInode->sharedByte;ŸF        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);Æ      } else {∑        skipShared = 1;ß      }•    }Ÿ:    if( rc==SQLITE_OK && pFile->eFileLock>=PENDING_LOCK ){ŸB      rc = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);¶    } ŸP    if( rc==SQLITE_OK && pFile->eFileLock>=RESERVED_LOCK && context->reserved ){ŸC      rc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);±      if( !rc ){ ø        context->reserved = 0; ß      }•    }ŸH    if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1)){Ÿ&      pInode->eFileLock = SHARED_LOCK;•    }£  }Ÿ,  if( rc==SQLITE_OK && eFileLock==NO_LOCK ){†ŸD    /* Decrement the shared lock counter.  Release the lock using anŸG    ** OS call only when all threads in this same process have released∞    ** the lock.¶    */ŸH    unsigned long long sharedLockByte = SHARED_FIRST+pInode->sharedByte;∂    pInode->nShared--;Ω    if( pInode->nShared==0 ){ø      SimulateIOErrorBenign(1);ø      SimulateIOError( h=(-1) )ø      SimulateIOErrorBenign(0);∏      if( !skipShared ){ŸF        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);ß      }∞      if( !rc ){Ÿ$        pInode->eFileLock = NO_LOCK;Ÿ#        pFile->eFileLock = NO_LOCK;ß      }•    }∏    if( rc==SQLITE_OK ){∂      pInode->nLock--;Ÿ!      assert( pInode->nLock>=0 );Ω      if( pInode->nLock==0 ){ø        closePendingFds(pFile);ß      }•    }£  }¢  ≥  unixLeaveMutex();Ÿ3  if( rc==SQLITE_OK ) pFile->eFileLock = eFileLock;¨  return rc;°}†¢/*Ÿ7** Close a file & cleanup AFP specific locking context ¢*/Ÿ'static int afpClose(sqlite3_file *id) {µ  int rc = SQLITE_OK;Ÿ"  unixFile *pFile = (unixFile*)id;≤  assert( id!=0 );π  afpUnlock(id, NO_LOCK);≥  unixEnterMutex();Ÿ.  if( pFile->pInode && pFile->pInode->nLock ){ŸJ    /* If there are outstanding locks, do not actually close the file justŸG    ** yet because that would clear those locks.  Instead, add the fileŸL    ** descriptor to pInode->aPending.  It will be automatically closed whenŸ     ** the last lock is cleared.¶    */∏    setPendingFd(pFile);£  }∫  releaseInodeInfo(pFile);Ÿ&  sqlite3_free(pFile->lockingContext);π  rc = closeUnixFile(id);≥  unixLeaveMutex();¨  return rc;°}†Ÿ>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */¢/*ŸG** The code above is the AFP lock implementation.  The code is specificŸG** to MacOSX and does not work on other unix platforms.  No alternativeŸE** is available.  If you don't compile for a mac, then the "unix-afp"∏** VFS is not available.¢**ŸO********************* End of the AFP lock implementation **********************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO*************************** Begin NFS Locking ********************************/†Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE¢/*ŸM ** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ* ** must be either NO_LOCK or SHARED_LOCK.£ **ŸF ** If the locking level of the file descriptor is already at or belowŸ9 ** the requested locking level, this routine is a no-op.£ */Ÿ6static int nfsUnlock(sqlite3_file *id, int eFileLock){Ÿ'  return posixUnlock(id, eFileLock, 1);°}†Ÿ>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */¢/*ŸG** The code above is the NFS lock implementation.  The code is specificŸG** to MacOSX and does not work on other unix platforms.  No alternative≤** is available.  ¢**ŸO********************* End of the NFS lock implementation **********************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO**************** Non-locking sqlite3_file methods *****************************¢**ŸE** The next division contains implementations for all methods of the ŸC** sqlite3_file object other than the locking methods.  The lockingŸB** methods were defined in divisions above (one locking method perŸA** division).  Those methods that are common to all locking modesŸ*** are gather together into this division.¢*/†¢/*ŸC** Seek to the offset passed as the second argument, then read cnt Ÿ=** bytes into pBuf. Return the number of bytes actually read.¢**ŸB** NB:  If you define USE_PREAD or USE_PREAD64, then it might alsoŸD** be necessary to define _XOPEN_SOURCE to be 500.  This varies fromŸA** one system to another.  Since SQLite does not define USE_PREADŸG** in any form by default, we will not attempt to define _XOPEN_SOURCE.ø** See tickets #2741 and #2681.¢**ŸI** To avoid stomping the errno value on a failed read the lastErrno valueª** is set before returning.¢*/ŸPstatic int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){™  int got;∞  int prior = 0;Ÿ2#if (!defined(USE_PREAD) && !defined(USE_PREAD64))∞  i64 newOffset;¶#endifÆ  TIMER_START;ø  assert( cnt==(cnt&0x1ffff) );¥  assert( id->h>2 );•  do{∂#if defined(USE_PREAD)Ÿ,    got = osPread(id->h, pBuf, cnt, offset);Ÿ     SimulateIOError( got = -1 );∫#elif defined(USE_PREAD64)Ÿ.    got = osPread64(id->h, pBuf, cnt, offset);Ÿ     SimulateIOError( got = -1 );•#elseŸ/    newOffset = lseek(id->h, offset, SEEK_SET);Ÿ&    SimulateIOError( newOffset = -1 );∂    if( newOffset<0 ){Ÿ+      storeLastErrno((unixFile*)id, errno);∞      return -1;•    }Ÿ#    got = osRead(id->h, pBuf, cnt);¶#endifπ    if( got==cnt ) break;∞    if( got<0 ){Ÿ.      if( errno==EINTR ){ got = 1; continue; }∞      prior = 0;Ÿ,      storeLastErrno((unixFile*)id,  errno);¨      break;∂    }else if( got>0 ){±      cnt -= got;¥      offset += got;≥      prior += got;Ÿ(      pBuf = (void*)(got + (char*)pBuf);•    }≤  }while( got>0 );¨  TIMER_END;Ÿ+  OSTRACE(("READ    %-3d %5d %7lld %llu\n",Ÿ<            id->h, got+prior, offset-prior, TIMER_ELAPSED));≥  return got+prior;°}†¢/*Ÿ@** Read data from a file into a buffer.  Return SQLITE_OK if allŸA** bytes were read successfully and SQLITE_IOERR if anything goes©** wrong.¢*/¥static int unixRead(¥  sqlite3_file *id, Æ  void *pBuf, ™  int amt,∂  sqlite3_int64 offset¢){Ÿ#  unixFile *pFile = (unixFile *)id;™  int got;Ø  assert( id );∂  assert( offset>=0 );≤  assert( amt>0 );†ŸF  /* If this is a database file (not a journal, master-journal or tempŸN  ** file), the bytes in the locking range should never be read or written. */•#if 0Ÿ'  assert( pFile->pPreallocatedUnused==0Ÿ"       || offset>=PENDING_BYTE+512Ÿ#       || offset+amt<=PENDING_BYTE §  );¶#endif†∫#if SQLITE_MAX_MMAP_SIZE>0ŸF  /* Deal with as much of this read request as possible by transferingŸ5  ** data from the memory mapping using memcpy().  */ø  if( offset<pFile->mmapSize ){Ÿ(    if( offset+amt <= pFile->mmapSize ){Ÿ>      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);∑      return SQLITE_OK;™    }else{Ÿ+      int nCopy = pFile->mmapSize - offset;Ÿ@      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);Ÿ"      pBuf = &((u8 *)pBuf)[nCopy];≥      amt -= nCopy;∂      offset += nCopy;•    }£  }¶#endif†Ÿ.  got = seekAndRead(pFile, offset, pBuf, amt);±  if( got==amt ){µ    return SQLITE_OK;¥  }else if( got<0 ){Ÿ&    /* lastErrno set by seekAndRead */Ω    return SQLITE_IOERR_READ;®  }else{Ÿ8    storeLastErrno(pFile, 0);   /* not a system error */Ÿ8    /* Unread parts of the buffer must be zero-filled */Ÿ,    memset(&((char*)pBuf)[got], 0, amt-got);Ÿ#    return SQLITE_IOERR_SHORT_READ;£  }°}†¢/*ŸF** Attempt to seek the file-descriptor passed as the first argument toŸF** absolute offset iOff, then attempt to write nBuf bytes of data fromŸJ** pBuf to it. If an error occurs, return -1 and set *piErrno. Otherwise, ŸD** return the actual number of bytes written (which may be less than©** nBuf).¢*/∫static int seekAndWriteFd(ŸC  int fd,                         /* File descriptor to write to */ŸG  i64 iOff,                       /* File offset to begin writing at */ŸN  const void *pBuf,               /* Copy data from this buffer to the file */ŸD  int nBuf,                       /* Size of buffer pBuf in bytes */ŸI  int *piErrno                    /* OUT: Error number if error occurs */¢){ŸE  int rc = 0;                     /* Value returned by system call */†Ÿ!  assert( nBuf==(nBuf&0x1ffff) );±  assert( fd>2 );∑  assert( piErrno!=0 );≤  nBuf &= 0x1ffff;Æ  TIMER_START;†∂#if defined(USE_PREAD)ŸO  do{ rc = (int)osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );∫#elif defined(USE_PREAD64)ŸO  do{ rc = (int)osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);•#else•  do{Ÿ*    i64 iSeek = lseek(fd, iOff, SEEK_SET);Ÿ"    SimulateIOError( iSeek = -1 );≤    if( iSeek<0 ){Æ      rc = -1;¨      break;•    }Ÿ!    rc = osWrite(fd, pBuf, nBuf);Ÿ!  }while( rc<0 && errno==EINTR );¶#endif†¨  TIMER_END;ŸJ  OSTRACE(("WRITE   %-3d %5d %7lld %llu\n", fd, rc, iOff, TIMER_ELAPSED));†æ  if( rc<0 ) *piErrno = errno;¨  return rc;°}††¢/*ŸB** Seek to the offset in id->offset then read cnt bytes into pBuf.Ÿ@** Return the number of bytes actually read.  Update the offset.¢**ŸJ** To avoid stomping the errno value on a failed write the lastErrno valueª** is set before returning.¢*/ŸMstatic int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){ŸB  return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);°}††¢/*ŸE** Write data from a buffer into a file.  Return SQLITE_OK on successŸ'** or some other error code on failure.¢*/µstatic int unixWrite(¥  sqlite3_file *id, ¥  const void *pBuf, ™  int amt,∑  sqlite3_int64 offset ¢){Ÿ"  unixFile *pFile = (unixFile*)id;∞  int wrote = 0;Ø  assert( id );≤  assert( amt>0 );†ŸF  /* If this is a database file (not a journal, master-journal or tempŸN  ** file), the bytes in the locking range should never be read or written. */•#if 0Ÿ'  assert( pFile->pPreallocatedUnused==0Ÿ"       || offset>=PENDING_BYTE+512Ÿ#       || offset+amt<=PENDING_BYTE §  );¶#endif†≥#ifdef SQLITE_DEBUGŸE  /* If we are doing a normal write to a database file (as opposed toŸF  ** doing a hot-journal rollback or a write to some file other than aŸA  ** normal database file) then record the fact that the databaseŸF  ** has changed.  If the transaction counter is modified, record thatÆ  ** fact too.§  */Ω  if( pFile->inNormalWrite ){Ÿ>    pFile->dbUpdate = 1;  /* The database has been modified */Ÿ'    if( offset<=24 && offset+amt>=27 ){≠      int rc;∂      char oldCntr[4];ø      SimulateIOErrorBenign(1);Ÿ.      rc = seekAndRead(pFile, 24, oldCntr, 4);ø      SimulateIOErrorBenign(0);ŸF      if( rc!=4 || memcmp(oldCntr, &((char*)pBuf)[24-offset], 4)!=0 ){ŸL        pFile->transCntrChng = 1;  /* The transaction counter has changed */ß      }•    }£  }¶#endif†Ÿ<#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0ŸG  /* Deal with as much of this write request as possible by transferingŸ5  ** data from the memory mapping using memcpy().  */ø  if( offset<pFile->mmapSize ){Ÿ(    if( offset+amt <= pFile->mmapSize ){Ÿ>      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);∑      return SQLITE_OK;™    }else{Ÿ+      int nCopy = pFile->mmapSize - offset;Ÿ@      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);Ÿ"      pBuf = &((u8 *)pBuf)[nCopy];≥      amt -= nCopy;∂      offset += nCopy;•    }£  }¶#endif° ŸK  while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){±    amt -= wrote;¥    offset += wrote;Ÿ!    pBuf = &((char*)pBuf)[wrote];£  }Ÿ)  SimulateIOError(( wrote=(-1), amt=1 ));Ÿ,  SimulateDiskfullError(( wrote=0, amt=1 ));†≤  if( amt>wrote ){Ÿ.    if( wrote<0 && pFile->lastErrno!=ENOSPC ){Ÿ)      /* lastErrno set by seekAndWrite */Ÿ       return SQLITE_IOERR_WRITE;™    }else{Ÿ8      storeLastErrno(pFile, 0); /* not a system error */π      return SQLITE_FULL;•    }£  }†≥  return SQLITE_OK;°}†≤#ifdef SQLITE_TEST¢/*ŸH** Count the number of fullsyncs and normal syncs.  This is used to testŸ=** that syncs and fullsyncs are occurring at the right times.¢*/Ÿ&SQLITE_API int sqlite3_sync_count = 0;Ÿ*SQLITE_API int sqlite3_fullsync_count = 0;¶#endif†¢/*ŸF** We do not trust systems to provide a working fdatasync().  Some do.ŸF** Others do no.  To be safe, we will stick with the (slightly slower)ŸL** fsync(). If you know that your system does support fdatasync() correctly,ŸE** then simply compile with -Dfdatasync=fdatasync or -DHAVE_FDATASYNC¢*/Ÿ*#if !defined(fdatasync) && !HAVE_FDATASYNC∏# define fdatasync fsync¶#endif†¢/*Ÿ>** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or notŸ>** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currentlyŸ6** only available on Mac OS X.  But that could change.¢*/≤#ifdef F_FULLFSYNCπ# define HAVE_FULLFSYNC 1•#elseπ# define HAVE_FULLFSYNC 0¶#endif††¢/*Ÿ>** The fsync() system call does not work as advertised on manyŸ?** unix systems.  The following procedure is an attempt to make≤** it work better.¢**ŸB** The SQLITE_NO_SYNC macro disables all fsync()s.  This is usefulŸB** for testing when we want to run through the test suite quickly.Ÿ?** You are strongly advised *not* to deploy with SQLITE_NO_SYNCŸC** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crashŸ:** or power failure will likely corrupt the database file.¢**ŸF** SQLite sets the dataOnly flag if the size of the file is unchanged.ŸI** The idea behind dataOnly is that it should only write the file contentŸE** to disk, not the inode.  We only set dataOnly if the file size is ŸA** unchanged since the file size is part of the inode.  However, ŸF** Ted Ts'o tells us that fdatasync() will also write the inode if theŸG** file size has changed.  The only real difference between fdatasync()ŸD** and fsync(), Ted tells us, is that fdatasync() will not flush theŸF** inode if the mtime or owner or other inode attributes have changed.ŸF** We only care about the file size, not the other file attributes, soŸD** as far as SQLite is concerned, an fdatasync() is always adequate.ŸB** So, we always use fdatasync() if it is available, regardless ofŸ"** the value of the dataOnly flag.¢*/Ÿ:static int full_fsync(int fd, int fullSync, int dataOnly){©  int rc;†ŸE  /* The following "ifdef/elif/else/" block has the same structure asŸE  ** the one below. It is replicated here solely to avoid cluttering Ÿ9  ** up the real code with the UNUSED_PARAMETER() macros.§  */µ#ifdef SQLITE_NO_SYNC∑  UNUSED_PARAMETER(fd);Ω  UNUSED_PARAMETER(fullSync);Ω  UNUSED_PARAMETER(dataOnly);¥#elif HAVE_FULLFSYNCΩ  UNUSED_PARAMETER(dataOnly);•#elseΩ  UNUSED_PARAMETER(fullSync);Ω  UNUSED_PARAMETER(dataOnly);¶#endif†Ÿ@  /* Record the number of times that we do a normal fsync() and ŸI  ** FULLSYNC.  This is used during testing to verify that this procedureŸ,  ** gets called with the correct arguments.§  */≤#ifdef SQLITE_TESTŸ*  if( fullSync ) sqlite3_fullsync_count++;∑  sqlite3_sync_count++;¶#endif†ŸC  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is aŸ?  ** no-op.  But go ahead and call fstat() to validate the fileŸ?  ** descriptor as we need a method to provoke a failure during∂  ** coverate testing.§  */µ#ifdef SQLITE_NO_SYNC£  {¥    struct stat buf;ª    rc = osFstat(fd, &buf);£  }¥#elif HAVE_FULLFSYNC±  if( fullSync ){Ÿ%    rc = osFcntl(fd, F_FULLFSYNC, 0);®  }else{´    rc = 1;£  }ŸA  /* If the FULLFSYNC failed, fall back to attempting an fsync().ŸA  ** It shouldn't be possible for fullfsync to fail on the local Ÿ>  ** file system (on OSX), so failure indicates that FULLFSYNCŸ@  ** isn't supported for this file system. So, attempt an fsync ŸE  ** and (for now) ignore the overhead of a superfluous fcntl call.  Ÿ?  ** It'd be better to detect fullfsync support once and avoid Ÿ.  ** the fcntl call every time sync is called.§  */∫  if( rc ) rc = fsync(fd);†∏#elif defined(__APPLE__)ŸP  /* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctlyŸK  ** so currently we default to the macro that redefines fdatasync to fsync§  */±  rc = fsync(fd);¶#else µ  rc = fdatasync(fd);Æ#if OS_VXWORKSŸ!  if( rc==-1 && errno==ENOTSUP ){≥    rc = fsync(fd);£  }∑#endif /* OS_VXWORKS */Ÿ5#endif /* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */†æ  if( OS_VXWORKS && rc!= -1 ){´    rc = 0;£  }¨  return rc;°}†¢/*ŸE** Open a file descriptor to the directory containing file zFilename.Ÿ?** If successful, *pFd is set to the opened file descriptor andŸA** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEMŸA** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined©** value.¢**Ÿ@** The directory file descriptor is used for only one thing - toŸE** fsync() a directory to make sure file creation and deletion eventsŸ<** are flushed to disk.  Such fsyncs are not needed on newerŸA** journaling filesystems, but are required on older filesystems.¢**ŸB** This routine can be overridden using the xSetSysCall interface.ŸC** The ability to override this routine was added in support of theŸD** chromium sandbox.  Opening a directory is a security risk (we areŸA** told) so making it overrideable allows the chromium sandbox toŸD** replace this routine with a harmless no-op.  To make this routineŸD** a no-op, replace it with a stub that returns SQLITE_OK but leavesŸ!** *pFd set to a negative number.¢**ŸB** If SQLITE_OK is returned, the caller is responsible for closingŸ*** the file descriptor *pFd using close().¢*/Ÿ:static int openDirectory(const char *zFilename, int *pFd){©  int ii;Æ  int fd = -1;Ÿ   char zDirname[MAX_PATHNAME+1];†Ÿ<  sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename);ŸA  for(ii=(int)strlen(zDirname); ii>0 && zDirname[ii]!='/'; ii--);≠  if( ii>0 ){∏    zDirname[ii] = '\0';®  }else{Ÿ-    if( zDirname[0]!='/' ) zDirname[0] = '.';¥    zDirname[1] = 0;£  }Ÿ3  fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);Æ  if( fd>=0 ){Ÿ1    OSTRACE(("OPENDIR %-3d %s\n", fd, zDirname));£  }¨  *pFd = fd;ø  if( fd>=0 ) return SQLITE_OK;ŸG  return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname);°}†¢/*ŸC** Make sure all writes to a particular file are committed to disk.¢**ŸB** If dataOnly==0 then both the file itself and its metadata (fileŸD** size, access time, etc) are synced.  If dataOnly!=0 then only the∑** file data is synced.¢**ŸC** Under Unix, also make sure that the directory entry for the fileŸF** has been created by fsync-ing the directory that contains the file.ŸG** If we do not do this and we encounter a power failure, the directoryŸC** entry for the journal might not exist after we reboot.  The nextŸK** SQLite to access the file will not know that the journal exists (becauseŸM** the directory entry for the journal was never created) and the transactionŸ@** will not roll back - possibly leading to database corruption.¢*/Ÿ1static int unixSync(sqlite3_file *id, int flags){©  int rc;Ÿ"  unixFile *pFile = (unixFile*)id;†Ÿ0  int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);Ÿ2  int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL;†Ÿ?  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */Ÿ)  assert((flags&0x0F)==SQLITE_SYNC_NORMALŸ'      || (flags&0x0F)==SQLITE_SYNC_FULL§  );†ŸI  /* Unix cannot, but some systems may return SQLITE_FULL from here. ThisŸ?  ** line is to test that doing so does not cause any problems.§  */Ÿ.  SimulateDiskfullError( return SQLITE_FULL );†≤  assert( pFile );Ÿ(  OSTRACE(("SYNC    %-3d\n", pFile->h));Ÿ4  rc = full_fsync(pFile->h, isFullsync, isDataOnly);∫  SimulateIOError( rc=1 );´  if( rc ){Ÿ!    storeLastErrno(pFile, errno);ŸH    return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);£  }†ŸE  /* Also fsync the directory containing the file if the DIRSYNC flagŸJ  ** is set.  This is a one-time occurrence.  Many systems (examples: AIX)ŸD  ** are unable to fsync a directory, so ignore errors on the fsync.§  */Ÿ,  if( pFile->ctrlFlags & UNIXFILE_DIRSYNC ){Æ    int dirfd;ŸJ    OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,Ÿ)            HAVE_FULLFSYNC, isFullsync));Ÿ/    rc = osOpenDirectory(pFile->zPath, &dirfd);∏    if( rc==SQLITE_OK ){æ      full_fsync(dirfd, 0, 0);Ÿ+      robust_close(pFile, dirfd, __LINE__);™    }else{Ÿ$      assert( rc==SQLITE_CANTOPEN );µ      rc = SQLITE_OK;•    }Ÿ*    pFile->ctrlFlags &= ~UNIXFILE_DIRSYNC;£  }¨  return rc;°}†¢/*Ÿ,** Truncate an open file to a specified size¢*/Ÿ5static int unixTruncate(sqlite3_file *id, i64 nByte){Ÿ#  unixFile *pFile = (unixFile *)id;©  int rc;≤  assert( pFile );Ÿ2  SimulateIOError( return SQLITE_IOERR_TRUNCATE );†ŸH  /* If the user has configured a chunk-size for this file, truncate theŸF  ** file so that it consists of an integer number of chunks (i.e. theŸJ  ** actual file size after the operation may be larger than the requested´  ** size).§  */π  if( pFile->szChunk>0 ){ŸK    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;£  }†Ÿ)  rc = robust_ftruncate(pFile->h, nByte);´  if( rc ){Ÿ!    storeLastErrno(pFile, errno);ŸJ    return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);®  }else{≥#ifdef SQLITE_DEBUGŸG    /* If we are doing a normal write to a database file (as opposed toŸH    ** doing a hot-journal rollback or a write to some file other than aŸE    ** normal database file) and we truncate the file to zero length,ŸF    ** that effectively updates the change counter.  This might happenŸH    ** when restoring a database using the backup API from a zero-lengthÆ    ** source.¶    */Ÿ+    if( pFile->inNormalWrite && nByte==0 ){ø      pFile->transCntrChng = 1;•    }¶#endif†∫#if SQLITE_MAX_MMAP_SIZE>0ŸJ    /* If the file was just truncated to a size smaller than the currentlyŸL    ** mapped region, reduce the effective mapping size as well. SQLite willŸM    ** use read() and write() to access data beyond this point from now on.  ¶    */Ÿ     if( nByte<pFile->mmapSize ){æ      pFile->mmapSize = nByte;•    }¶#endif†µ    return SQLITE_OK;£  }°}†¢/*Ÿ0** Determine the current size of a file in bytes¢*/Ÿ6static int unixFileSize(sqlite3_file *id, i64 *pSize){©  int rc;≤  struct stat buf;Ø  assert( id );Ÿ)  rc = osFstat(((unixFile*)id)->h, &buf);∫  SimulateIOError( rc=1 );Æ  if( rc!=0 ){Ÿ)    storeLastErrno((unixFile*)id, errno);æ    return SQLITE_IOERR_FSTAT;£  }∑  *pSize = buf.st_size;†ŸE  /* When opening a zero-size database, the findInodeInfo() procedureŸF  ** writes a single byte into that file in order to work around a bugŸI  ** in the OS-X msdos filesystem.  In order to avoid problems with upperŸG  ** layers, we need to report this file size as zero even though it isæ  ** really 1.   Ticket #3260.§  */Ω  if( *pSize==1 ) *pSize = 0;††≥  return SQLITE_OK;°}†Ÿ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)¢/*ŸF** Handler for proxy-locking file-control verbs.  Defined below in theΩ** proxying locking division.¢*/Ÿ5static int proxyFileControl(sqlite3_file*,int,void*);¶#endif†£/* Ÿ@** This function is called to handle the SQLITE_FCNTL_SIZE_HINT ŸB** file-control operation.  Enlarge the database to nBytes in sizeŸC** (rounded up to the next chunk-size).  If the database is alreadyŸ-** nBytes or larger, this routine is a no-op.¢*/Ÿ5static int fcntlSizeHint(unixFile *pFile, i64 nByte){π  if( pFile->szChunk>0 ){Ÿ:    i64 nSize;                    /* Required file size */ŸM    struct stat buf;              /* Used to hold return values of fstat() */£   Ÿ"    if( osFstat(pFile->h, &buf) ){Ÿ       return SQLITE_IOERR_FSTAT;•    }†ŸI    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;Ÿ!    if( nSize>(i64)buf.st_size ){†Ÿ9#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATEŸF      /* The code below is handling the return value of osFallocate() ŸN      ** correctly. posix_fallocate() is defined to "returns zero on success, ŸI      ** or an error number on  failure". See the manpage for details. */Æ      int err;©      do{ŸD        err = osFallocate(pFile->h, buf.st_size, nSize-buf.st_size);ª      }while( err==EINTR );Ÿ*      if( err ) return SQLITE_IOERR_WRITE;•#elseŸE      /* If the OS does not have posix_fallocate(), fake it. Write a ŸG      ** single byte to the last byte in each block that falls entirelyŸE      ** within the extended region. Then, if required, a single byteŸD      ** at offset (nSize-1), to set the size of the file correctly.ŸE      ** This is a similar technique to that used by glibc on systemsŸ2      ** that do not have a real fallocate() call.®      */Ÿ>      int nBlk = buf.st_blksize;  /* File-system block size */ŸO      int nWrite = 0;             /* Number of bytes written by seekAndWrite */Ÿ?      i64 iWrite;                 /* Next offset to write to */†Ÿ2      iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;Ÿ$      assert( iWrite>=buf.st_size );Ÿ%      assert( ((iWrite+1)%nBlk)==0 );Ÿ9      for(/*no-op*/; iWrite<nSize+nBlk-1; iWrite+=nBlk ){Ÿ/        if( iWrite>=nSize ) iWrite = nSize - 1;Ÿ4        nWrite = seekAndWrite(pFile, iWrite, "", 1);Ÿ2        if( nWrite!=1 ) return SQLITE_IOERR_WRITE;ß      }¶#endif•    }£  }†∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ6  if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){´    int rc;º    if( pFile->szChunk<=0 ){Ÿ.      if( robust_ftruncate(pFile->h, nByte) ){Ÿ%        storeLastErrno(pFile, errno);ŸN        return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);ß      }•    }†Ÿ#    rc = unixMapfile(pFile, nByte);Æ    return rc;£  }¶#endif†≥  return SQLITE_OK;°}†¢/*ŸE** If *pArg is initially negative then this is a query.  Set *pArg toŸJ** 1 or 0 depending on whether or not bit mask of pFile->ctrlFlags is set.¢**ŸJ** If *pArg is 0 or 1, then clear or set the mask bit of pFile->ctrlFlags.¢*/ŸHstatic void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){∞  if( *pArg<0 ){Ÿ)    *pArg = (pFile->ctrlFlags & mask)!=0;π  }else if( (*pArg)==0 ){æ    pFile->ctrlFlags &= ~mask;®  }else{Ω    pFile->ctrlFlags |= mask;£  }°}†π/* Forward declaration */Ÿ1static int unixGetTempname(int nBuf, char *zBuf);†¢/*Ÿ2** Information and control of an open file handle.¢*/ŸAstatic int unixFileControl(sqlite3_file *id, int op, void *pArg){Ÿ"  unixFile *pFile = (unixFile*)id;Ø  switch( op ){ŸC#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ÿ+    case SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: {Ÿ>      int rc = osIoctl(pFile->h, F2FS_IOC_START_ATOMIC_WRITE);Ÿ8      return rc ? SQLITE_IOERR_BEGIN_ATOMIC : SQLITE_OK;•    }Ÿ,    case SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: {Ÿ?      int rc = osIoctl(pFile->h, F2FS_IOC_COMMIT_ATOMIC_WRITE);Ÿ9      return rc ? SQLITE_IOERR_COMMIT_ATOMIC : SQLITE_OK;•    }Ÿ.    case SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: {Ÿ@      int rc = osIoctl(pFile->h, F2FS_IOC_ABORT_VOLATILE_WRITE);Ÿ;      return rc ? SQLITE_IOERR_ROLLBACK_ATOMIC : SQLITE_OK;•    }Ÿ:#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */†Ÿ"    case SQLITE_FCNTL_LOCKSTATE: {Ÿ%      *(int*)pArg = pFile->eFileLock;∑      return SQLITE_OK;•    }Ÿ#    case SQLITE_FCNTL_LAST_ERRNO: {Ÿ%      *(int*)pArg = pFile->lastErrno;∑      return SQLITE_OK;•    }Ÿ#    case SQLITE_FCNTL_CHUNK_SIZE: {Ÿ$      pFile->szChunk = *(int *)pArg;∑      return SQLITE_OK;•    }Ÿ"    case SQLITE_FCNTL_SIZE_HINT: {≠      int rc;ø      SimulateIOErrorBenign(1);Ÿ.      rc = fcntlSizeHint(pFile, *(i64 *)pArg);ø      SimulateIOErrorBenign(0);∞      return rc;•    }Ÿ$    case SQLITE_FCNTL_PERSIST_WAL: {Ÿ;      unixModeBit(pFile, UNIXFILE_PERSIST_WAL, (int*)pArg);∑      return SQLITE_OK;•    }Ÿ,    case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {Ÿ4      unixModeBit(pFile, UNIXFILE_PSOW, (int*)pArg);∑      return SQLITE_OK;•    }Ÿ     case SQLITE_FCNTL_VFSNAME: {Ÿ@      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);∑      return SQLITE_OK;•    }Ÿ%    case SQLITE_FCNTL_TEMPFILENAME: {ŸA      char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );≥      if( zTFile ){Ÿ9        unixGetTempname(pFile->pVfs->mxPathname, zTFile);ø        *(char**)pArg = zTFile;ß      }∑      return SQLITE_OK;•    }Ÿ"    case SQLITE_FCNTL_HAS_MOVED: {Ÿ(      *(int*)pArg = fileHasMoved(pFile);∑      return SQLITE_OK;•    }Ÿ"#ifdef SQLITE_ENABLE_SETLK_TIMEOUTŸ%    case SQLITE_FCNTL_LOCK_TIMEOUT: {Ÿ(      pFile->iBusyTimeout = *(int*)pArg;∑      return SQLITE_OK;•    }¶#endif∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ"    case SQLITE_FCNTL_MMAP_SIZE: {Ÿ!      i64 newLimit = *(i64*)pArg;π      int rc = SQLITE_OK;Ÿ0      if( newLimit>sqlite3GlobalConfig.mxMmap ){Ÿ.        newLimit = sqlite3GlobalConfig.mxMmap;ß      }†ŸL      /* The value of newLimit may be eventually cast to (size_t) and passedŸK      ** to mmap(). Restrict its value to 2GB if (size_t) is not at least a∏      ** 64-bit type. */Ÿ+      if( newLimit>0 && sizeof(size_t)<8 ){Ÿ+        newLimit = (newLimit & 0x7FFFFFFF);ß      }†Ÿ'      *(i64*)pArg = pFile->mmapSizeMax;ŸO      if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){Ÿ&        pFile->mmapSizeMax = newLimit;Ÿ         if( pFile->mmapSize>0 ){ø          unixUnmapfile(pFile);Ÿ&          rc = unixMapfile(pFile, -1);©        }ß      }∞      return rc;•    }¶#endif≥#ifdef SQLITE_DEBUGŸ=    /* The pager calls this method to signal that it has doneŸB    ** a rollback and that the database is therefore unchanged andŸA    ** it hence it is OK for the transaction change counter to be±    ** unchanged.¶    */Ÿ%    case SQLITE_FCNTL_DB_UNCHANGED: {Ÿ$      ((unixFile*)id)->dbUpdate = 0;∑      return SQLITE_OK;•    }¶#endifŸ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ÿ(    case SQLITE_FCNTL_SET_LOCKPROXYFILE:Ÿ*    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {Ÿ*      return proxyFileControl(id,op,pArg);•    }Ÿ>#endif /* SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__) */£  }π  return SQLITE_NOTFOUND;°}†¢/*ŸG** If pFd->sectorSize is non-zero when this function is called, it is aŸ7** no-op. Otherwise, the values of pFd->sectorSize and ŸC** pFd->deviceCharacteristics are set according to the file-system ¥** characteristics. ¢**ŸG** There are two versions of this function. One for QNX and one for all±** other systems.¢*/≤#ifndef __QNXNTO__Ÿ4static void setDeviceCharacteristics(unixFile *pFd){Ÿ@  assert( pFd->deviceCharacteristics==0 || pFd->sectorSize!=0 );ª  if( pFd->sectorSize==0 ){ŸC#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)¨    int res;Æ    u32 f = 0;†Ÿ9    /* Check for support for F2FS atomic batch writes. */Ÿ5    res = osIoctl(pFd->h, F2FS_IOC_GET_FEATURES, &f);Ÿ4    if( res==0 && (f & F2FS_FEATURE_ATOMIC_WRITE) ){Ÿ=      pFd->deviceCharacteristics = SQLITE_IOCAP_BATCH_ATOMIC;•    }Ÿ:#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */†Ÿ8    /* Set the POWERSAFE_OVERWRITE flag if requested. */Ÿ)    if( pFd->ctrlFlags & UNIXFILE_PSOW ){ŸE      pFd->deviceCharacteristics |= SQLITE_IOCAP_POWERSAFE_OVERWRITE;•    }†Ÿ1    pFd->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;£  }°}•#elseπ#include <sys/dcmd_blk.h>∏#include <sys/statvfs.h>Ÿ6static void setDeviceCharacteristics(unixFile *pFile){ø  if( pFile->sectorSize == 0 ){∫    struct statvfs fsInfo;ß       Ÿ4    /* Set defaults for non-supported filesystems */Ÿ3    pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;Ÿ%    pFile->deviceCharacteristics = 0;Ÿ-    if( fstatvfs(pFile->h, &fsInfo) == -1 ) {≠      return;•    }†Ÿ-    if( !strcmp(fsInfo.f_basetype, "tmp") ) {Ÿ)      pFile->sectorSize = fsInfo.f_bsize;Ÿ$      pFile->deviceCharacteristics =ŸP        SQLITE_IOCAP_ATOMIC4K |       /* All ram filesystem writes are atomic */ŸN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilŸ>                                      ** the write succeeds */ŸO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindŸ<                                      ** so it is ordered */™        0;Ÿ2    }else if( strstr(fsInfo.f_basetype, "etfs") ){Ÿ)      pFile->sectorSize = fsInfo.f_bsize;Ÿ$      pFile->deviceCharacteristics =Ÿ1        /* etfs cluster size writes are atomic */Ÿ<        (pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) |ŸN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilŸ>                                      ** the write succeeds */ŸO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindŸ<                                      ** so it is ordered */™        0;Ÿ3    }else if( !strcmp(fsInfo.f_basetype, "qnx6") ){Ÿ)      pFile->sectorSize = fsInfo.f_bsize;Ÿ$      pFile->deviceCharacteristics =ŸL        SQLITE_IOCAP_ATOMIC |         /* All filesystem writes are atomic */ŸN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilŸ>                                      ** the write succeeds */ŸO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindŸ<                                      ** so it is ordered */™        0;Ÿ3    }else if( !strcmp(fsInfo.f_basetype, "qnx4") ){Ÿ)      pFile->sectorSize = fsInfo.f_bsize;Ÿ$      pFile->deviceCharacteristics =ŸE        /* full bitset of atomics from max sector size and smaller */ŸG        ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |ŸO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindŸ<                                      ** so it is ordered */™        0;Ÿ1    }else if( strstr(fsInfo.f_basetype, "dos") ){Ÿ)      pFile->sectorSize = fsInfo.f_bsize;Ÿ$      pFile->deviceCharacteristics =ŸE        /* full bitset of atomics from max sector size and smaller */ŸG        ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |ŸO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindŸ<                                      ** so it is ordered */™        0;™    }else{Ÿ$      pFile->deviceCharacteristics =Ÿ=        SQLITE_IOCAP_ATOMIC512 |      /* blocks are atomic */ŸN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilŸ>                                      ** the write succeeds */™        0;•    }£  }ŸJ  /* Last chance verification.  If the sector size isn't a multiple of 512ª  ** then it isn't valid.*/Ÿ%  if( pFile->sectorSize % 512 != 0 ){Ÿ%    pFile->deviceCharacteristics = 0;Ÿ3    pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;£  }°}¶#endif†¢/*ŸE** Return the sector size in bytes of the underlying block device forŸB** the specified file. This is almost always 512 bytes, but may beª** larger for some devices.¢**ŸF** SQLite code assumes this function cannot fail. It also assumes thatŸC** if two files are created in the same file-system directory (i.e.ŸD** a database and its journal file) that the sector size will be the±** same for both.¢*/Ÿ,static int unixSectorSize(sqlite3_file *id){Ÿ   unixFile *pFd = (unixFile*)id;Ÿ   setDeviceCharacteristics(pFd);π  return pFd->sectorSize;°}†¢/*Ÿ2** Return the device characteristics for the file.¢**ŸL** This VFS is set up to return SQLITE_IOCAP_POWERSAFE_OVERWRITE by default.ŸI** However, that choice is controversial since technically the underlyingŸG** file system does not always provide powersafe overwrites.  (In otherŸE** words, after a power-loss event, parts of the file that were neverŸL** written might end up being altered.)  However, non-PSOW behavior is very,ŸG** very rare.  And asserting PSOW makes a large reduction in the amountŸH** of required I/O for journaling, since a lot of padding is eliminated.ŸN**  Hence, while POWERSAFE_OVERWRITE is on by default, there is a file-controlŸM** available to turn it off and URI query parameter available to turn it off.¢*/Ÿ7static int unixDeviceCharacteristics(sqlite3_file *id){Ÿ   unixFile *pFd = (unixFile*)id;Ÿ   setDeviceCharacteristics(pFd);Ÿ$  return pFd->deviceCharacteristics;°}†Ÿ7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0†¢/*ø** Return the system page size.¢**ŸK** This function should not be called directly by other code in this file. Ÿ:** Instead, it should be called via macro osGetpagesize().¢*/Ÿ!static int unixGetpagesize(void){Æ#if OS_VXWORKSÆ  return 1024;∫#elif defined(_BSD_SOURCE)∑  return getpagesize();•#elseŸ$  return (int)sysconf(_SC_PAGESIZE);¶#endif°}†Ÿ@#endif /* !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0 */†∑#ifndef SQLITE_OMIT_WAL†¢/*Ÿ6** Object used to represent an shared memory buffer.  ¢**ŸF** When multiple threads all reference the same wal-index, each threadŸF** has its own unixShm object, but they all point to a single instanceŸH** of this unixShmNode object.  In other words, each wal-index is openedπ** only once per process.¢**ŸI** Each unixShmNode object is connected to a single unixInodeInfo object.ŸH** We could coalesce this object into unixInodeInfo, but that would meanŸH** every open file that does not use shared memory (in other words, mostŸE** open files) would have to carry around this extra information.  SoŸI** the unixInodeInfo object contains a pointer to this unixShmNode objectŸ:** and the unixShmNode object is created only when needed.¢**Ÿ;** unixMutexHeld() must be true when creating or destroyingŸ@** this object or while reading or writing the following fields:¢**¨**      nRef¢**ŸB** The following fields are read-only after the object is created:£** ´**      fid±**      zFilename¢**ŸC** Either unixShmNode.mutex must be held or unixShmNode.nRef==0 andŸB** unixMutexHeld() is true when reading or writing any other fieldµ** in this structure.¢*/¥struct unixShmNode {ŸH  unixInodeInfo *pInode;     /* unixInodeInfo that owns this SHM node */Ÿ>  sqlite3_mutex *mutex;      /* Mutex to access this object */Ÿ;  char *zFilename;           /* Name of the mmapped file */Ÿ7  int h;                     /* Open file descriptor */Ÿ@  int szRegion;              /* Size of shared-memory regions */Ÿ9  u16 nRegion;               /* Size of array apRegion */Ÿ4  u8 isReadonly;             /* True if read-only */Ÿ;  u8 isUnlocked;             /* True if no DMS lock held */ŸH  char **apRegion;           /* Array of mapped shared-memory regions */ŸM  int nRef;                  /* Number of unixShm objects pointing to this */ŸG  unixShm *pFirst;           /* All unixShm objects pointing to this */≥#ifdef SQLITE_DEBUGŸ?  u8 exclMask;               /* Mask of exclusive locks held */Ÿ<  u8 sharedMask;             /* Mask of shared locks held */ŸB  u8 nextShmId;              /* Next available unixShm.id value */¶#endif¢};†¢/*ŸB** Structure used internally by this VFS to record the state of anŸ!** open shared memory connection.¢**ŸG** The following fields are initialized when this object is created andº** are read-only thereafter:¢**≥**    unixShm.pFile∞**    unixShm.id¢**ŸJ** All other fields are read/write.  The unixShm.pFile->mutex must be heldŸ)** while accessing any read/write fields.¢*/∞struct unixShm {ŸD  unixShmNode *pShmNode;     /* The underlying unixShmNode object */ŸI  unixShm *pNext;            /* Next unixShm with the same unixShmNode */ŸH  u8 hasMutex;               /* True if holding the unixShmNode mutex */ŸO  u8 id;                     /* Id of this connection within its unixShmNode */Ÿ<  u16 sharedMask;            /* Mask of shared locks held */Ÿ?  u16 exclMask;              /* Mask of exclusive locks held */¢};†¢/*Ω** Constants used for locking¢*/ŸO#define UNIX_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)         /* first lock byte */ŸN#define UNIX_SHM_DMS    (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */†¢/*ŸG** Apply posix advisory locks for all bytes from ofst through ofst+n-1.¢**ŸE** Locks block if the mask is exactly UNIX_SHM_C and are non-blocking≠** otherwise.¢*/Ωstatic int unixShmSystemLock(Ÿ>  unixFile *pFile,       /* Open connection to the WAL file */Ÿ;  int lockType,          /* F_UNLCK, F_RDLCK, or F_WRLCK */Ÿ>  int ofst,              /* First byte of the locking range */Ÿ6  int n                  /* Number of bytes to lock */¢){ŸM  unixShmNode *pShmNode; /* Apply locks to this open shared-memory segment */ŸC  struct flock f;        /* The posix advisory locking structure */Ÿ7  int rc = SQLITE_OK;    /* Result code form fcntl() */†ŸD  /* Access to the unixShmNode object is serialized by the caller */Ÿ%  pShmNode = pFile->pInode->pShmNode;ŸE  assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->mutex) );†Ÿ2  /* Shared locks never span more than one byte */Ÿ&  assert( n==1 || lockType!=F_RDLCK );†æ  /* Locks are within range */Ÿ(  assert( n>=1 && n<=SQLITE_SHM_NLOCK );†∑  if( pShmNode->h>=0 ){Ÿ+    /* Initialize the locking parameters */∏    f.l_type = lockType;∫    f.l_whence = SEEK_SET;µ    f.l_start = ofst;∞    f.l_len = n;Ÿ8    rc = osSetPosixAdvisoryLock(pShmNode->h, &f, pFile);Ÿ.    rc = (rc!=(-1)) ? SQLITE_OK : SQLITE_BUSY;£  }†Ÿ9  /* Update the global lock state and do debug tracing */≥#ifdef SQLITE_DEBUG≠  { u16 mask;π  OSTRACE(("SHM-LOCK "));Ÿ6  mask = ofst>31 ? 0xffff : (1<<(ofst+n)) - (1<<ofst);∂  if( rc==SQLITE_OK ){º    if( lockType==F_UNLCK ){Ÿ&      OSTRACE(("unlock %d ok", ofst));Ÿ"      pShmNode->exclMask &= ~mask;Ÿ$      pShmNode->sharedMask &= ~mask;Ÿ"    }else if( lockType==F_RDLCK ){Ÿ)      OSTRACE(("read-lock %d ok", ofst));Ÿ"      pShmNode->exclMask &= ~mask;Ÿ#      pShmNode->sharedMask |= mask;™    }else{Ÿ"      assert( lockType==F_WRLCK );Ÿ*      OSTRACE(("write-lock %d ok", ofst));Ÿ!      pShmNode->exclMask |= mask;Ÿ$      pShmNode->sharedMask &= ~mask;•    }®  }else{º    if( lockType==F_UNLCK ){Ÿ*      OSTRACE(("unlock %d failed", ofst));Ÿ"    }else if( lockType==F_RDLCK ){Ÿ$      OSTRACE(("read-lock failed"));™    }else{Ÿ"      assert( lockType==F_WRLCK );Ÿ.      OSTRACE(("write-lock %d failed", ofst));•    }£  }Ÿ'  OSTRACE((" - afterwards %03x,%03x\n",Ÿ6           pShmNode->sharedMask, pShmNode->exclMask));£  }¶#endif†¥  return rc;        °}†¢/*ŸI** Return the minimum number of 32KB shm regions that should be mapped atŸH** a time, assuming that each mapping must be an integer multiple of theº** current system page-size.¢**ŸL** Usually, this is 1. The exception seems to be systems that are configuredŸH** to use 64KB pages - in this case each mapping must cover at least twoØ** shm regions.¢*/Ÿ%static int unixShmRegionPerMap(void){Ÿ7  int shmsz = 32*1024;            /* SHM region size */Ÿ6  int pgsz = osGetpagesize();   /* System page size */ŸF  assert( ((pgsz-1)&pgsz)==0 );   /* Page size must be a power of 2 */º  if( pgsz<shmsz ) return 1;¥  return pgsz/shmsz;°}†¢/*ŸJ** Purge the unixShmNodeList list of all entries with unixShmNode.nRef==0.¢**ŸJ** This is not a VFS shared-memory method; it is a utility function calledŸ ** by VFS shared-memory methods.¢*/Ÿ(static void unixShmPurge(unixFile *pFd){Ÿ)  unixShmNode *p = pFd->pInode->pShmNode;º  assert( unixMutexHeld() );Ÿ   if( p && ALWAYS(p->nRef==0) ){Ÿ+    int nShmPerMap = unixShmRegionPerMap();™    int i;Ÿ%    assert( p->pInode==pFd->pInode );Ÿ!    sqlite3_mutex_free(p->mutex);Ÿ*    for(i=0; i<p->nRegion; i+=nShmPerMap){¥      if( p->h>=0 ){Ÿ.        osMunmap(p->apRegion[i], p->szRegion);¨      }else{Ÿ%        sqlite3_free(p->apRegion[i]);ß      }•    }æ    sqlite3_free(p->apRegion);≤    if( p->h>=0 ){Ÿ(      robust_close(pFd, p->h, __LINE__);∞      p->h = -1;•    }º    p->pInode->pShmNode = 0;¥    sqlite3_free(p);£  }°}†¢/*ŸG** The DMS lock has not yet been taken on shm file pShmNode. Attempt toŸB** take it now. Return SQLITE_OK if successful, or an SQLite error≤** code otherwise.¢**Ÿ@** If the DMS cannot be locked because this is a readonly_shm=1 Ÿ?** connection and no other process already holds a lock, returnŸ;** SQLITE_READONLY_CANTINIT and set pShmNode->isUnlocked=1.¢*/ŸHstatic int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){¥  struct flock lock;µ  int rc = SQLITE_OK;†ŸC  /* Use F_GETLK to determine the locks other processes are holdingŸE  ** on the DMS byte. If it indicates that another process is holdingŸA  ** a SHARED lock, then this process may also take a SHARED lockŸ.  ** and proceed with opening the *-shm file. §  **ŸC  ** Or, if no other process is holding any lock, then this processŸH  ** is the first to open it. In this case take an EXCLUSIVE lock on theŸE  ** DMS byte and truncate the *-shm file to zero bytes in size. ThenŸ0  ** downgrade to a SHARED lock on the DMS byte.§  **ŸE  ** If another process is holding an EXCLUSIVE lock on the DMS byte,ŸE  ** return SQLITE_BUSY to the caller (it will try again). An earlierŸF  ** version of this code attempted the SHARED lock at this point. ButŸD  ** this introduced a subtle race condition: if the process holdingŸF  ** EXCLUSIVE failed just before truncating the *-shm file, then thisŸE  ** process might open and use the *-shm file without truncating it.ŸC  ** And if the *-shm file has been corrupted by a power failure orŸC  ** system crash, the database itself may also become corrupt.  */ª  lock.l_whence = SEEK_SET;æ  lock.l_start = UNIX_SHM_DMS;±  lock.l_len = 1;∏  lock.l_type = F_WRLCK;Ÿ1  if( osFcntl(pShmNode->h, F_GETLK, &lock)!=0 ) {ª    rc = SQLITE_IOERR_LOCK;Ÿ#  }else if( lock.l_type==F_UNLCK ){ø    if( pShmNode->isReadonly ){ø      pShmNode->isUnlocked = 1;Ÿ$      rc = SQLITE_READONLY_CANTINIT;™    }else{Ÿ>      rc = unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1);Ÿ>      if( rc==SQLITE_OK && robust_ftruncate(pShmNode->h, 0) ){ŸP        rc = unixLogError(SQLITE_IOERR_SHMOPEN,"ftruncate",pShmNode->zFilename);ß      }•    }Ÿ#  }else if( lock.l_type==F_WRLCK ){µ    rc = SQLITE_BUSY;£  }†∂  if( rc==SQLITE_OK ){Ÿ;    assert( lock.l_type==F_UNLCK || lock.l_type==F_RDLCK );Ÿ<    rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);£  }¨  return rc;°}†¢/*ŸH** Open a shared-memory area associated with open database file pDbFd.  Ÿ5** This particular implementation uses mmapped files.¢**ŸD** The file used to implement shared-memory is in the same directoryŸG** as the open database file and has the same name as the open databaseŸH** file with the "-shm" suffix added.  For example, if the database fileŸG** is "/home/user1/config.db" then the file that is created and mmappedŸB** for shared memory will be called "/home/user1/config.db-shm".  ¢**ŸD** Another approach to is to use files in /dev/shm or /dev/tmp or anŸA** some other tmpfs mount. But if a file in a different directoryŸD** from the database file is used, then differing access permissionsŸ@** or a chroot() might cause two different processes on the sameŸ@** database to end up using different files for shared memory - ŸC** meaning that their memory would not really be shared - resultingŸ?** in database corruption.  Nevertheless, this tmpfs file usageŸI** can be enabled at compile-time using -DSQLITE_SHM_DIRECTORY="/dev/shm"ŸG** or the equivalent.  The use of the SQLITE_SHM_DIRECTORY compile-timeŸG** option results in an incompatible build of SQLite;  builds of SQLiteŸG** that with differing SQLITE_SHM_DIRECTORY settings attempt to use theŸG** same database file at the same time, database corruption will likelyŸE** result. The SQLITE_SHM_DIRECTORY compile-time option is consideredŸ<** "unsupported" and may go away in a future SQLite release.¢**ŸG** When opening a new shared-memory file, if no other instances of thatŸG** file are currently open, in this process or in other processes, thenŸH** the file must be truncated to zero length or have its header cleared.¢**ŸE** If the original database file (pDbFd) is using the "unix-excl" VFSŸE** that means that an exclusive lock is held on the database file andŸF** that no other processes are able to read or write the database.  InŸD** that case, we do not really need shared memory.  No shared memoryŸJ** file is created.  The shared memory will be simulated with heap memory.¢*/Ÿ1static int unixOpenSharedMemory(unixFile *pDbFd){ŸC  struct unixShm *p = 0;          /* The connection to be opened */ŸC  struct unixShmNode *pShmNode;   /* The underlying mmapped file */Ÿ3  int rc = SQLITE_OK;             /* Result code */Ÿ7  unixInodeInfo *pInode;          /* The inode of fd */Ÿ=  char *zShm;             /* Name of the file used for SHM */ŸI  int nShmFilename;               /* Size of the SHM filename in bytes */†Ÿ2  /* Allocate space for the new unixShm object. */Ÿ%  p = sqlite3_malloc64( sizeof(*p) );Ÿ&  if( p==0 ) return SQLITE_NOMEM_BKPT;ª  memset(p, 0, sizeof(*p));ª  assert( pDbFd->pShm==0 );†ŸK  /* Check to see if a unixShmNode object already exists. Reuse an existingŸ3  ** one if present. Create a new one if necessary.§  */≥  unixEnterMutex();π  pInode = pDbFd->pInode;æ  pShmNode = pInode->pShmNode;¥  if( pShmNode==0 ){ŸK    struct stat sStat;                 /* fstat() info for database file */º#ifndef SQLITE_SHM_DIRECTORYŸ)    const char *zBasePath = pDbFd->zPath;¶#endif†ŸJ    /* Call fstat() to figure out the permissions on the database file. IfŸH    ** a new *-shm file is created, an attempt will be made to create itŸ!    ** with the same permissions.¶    */Ÿ$    if( osFstat(pDbFd->h, &sStat) ){æ      rc = SQLITE_IOERR_FSTAT;∏      goto shm_open_err;•    }†ª#ifdef SQLITE_SHM_DIRECTORYŸ5    nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;•#elseŸ.    nShmFilename = 6 + (int)strlen(zBasePath);¶#endifŸD    pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );∂    if( pShmNode==0 ){Ω      rc = SQLITE_NOMEM_BKPT;∏      goto shm_open_err;•    }Ÿ8    memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);Ÿ5    zShm = pShmNode->zFilename = (char*)&pShmNode[1];ª#ifdef SQLITE_SHM_DIRECTORYŸ)    sqlite3_snprintf(nShmFilename, zShm, Ÿ>                     SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",Ÿ;                     (u32)sStat.st_ino, (u32)sStat.st_dev);•#elseŸ>    sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);Ÿ+    sqlite3FileSuffix3(pDbFd->zPath, zShm);¶#endifµ    pShmNode->h = -1;Ÿ'    pDbFd->pInode->pShmNode = pShmNode;Ÿ%    pShmNode->pInode = pDbFd->pInode;Ÿ)    if( sqlite3GlobalConfig.bCoreMutex ){Ÿ?      pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);ø      if( pShmNode->mutex==0 ){ø        rc = SQLITE_NOMEM_BKPT;∫        goto shm_open_err;ß      }•    }†Ÿ"    if( pInode->bProcessLock==0 ){ŸD      if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){ŸN        pShmNode->h = robust_open(zShm, O_RDWR|O_CREAT, (sStat.st_mode&0777));ß      }∫      if( pShmNode->h<0 ){ŸH        pShmNode->h = robust_open(zShm, O_RDONLY, (sStat.st_mode&0777));º        if( pShmNode->h<0 ){Ÿ@          rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zShm);º          goto shm_open_err;©        }Ÿ!        pShmNode->isReadonly = 1;ß      }†ŸH      /* If this process is running as root, make sure that the SHM fileŸO      ** is owned by the same user that owns the original database.  Otherwise,Ÿ8      ** the original owner will not be able to connect.®      */Ÿ<      robustFchown(pShmNode->h, sStat.st_uid, sStat.st_gid);†Ÿ1      rc = unixLockSharedMemory(pDbFd, pShmNode);ŸL      if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;•    }£  }†Ÿ:  /* Make the new connection a child of the unixShmNode */π  p->pShmNode = pShmNode;≥#ifdef SQLITE_DEBUGŸ   p->id = pShmNode->nextShmId++;¶#endif≥  pShmNode->nRef++;≤  pDbFd->pShm = p;≥  unixLeaveMutex();†ŸG  /* The reference count on pShmNode has already been incremented underŸE  ** the cover of the unixEnterMutex() mutex and the pointer from theŸJ  ** new (struct unixShm) object to the pShmNode has been set. All that isŸG  ** left to do is to link the new object into the linked list startingŸN  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex ´  ** mutex.§  */Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);æ  p->pNext = pShmNode->pFirst;∑  pShmNode->pFirst = p;Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);¨  return rc;†æ  /* Jump here on any error */≠shm_open_err:ŸG  unixShmPurge(pDbFd);       /* This call frees pShmNode if required */≤  sqlite3_free(p);≥  unixLeaveMutex();¨  return rc;°}†¢/*ŸH** This function is called to obtain a pointer to region iRegion of the ŸM** shared-memory associated with the database file fd. Shared-memory regions ŸJ** are numbered starting from zero. Each shared-memory region is szRegion ±** bytes in size.¢**ŸH** If an error occurs, an error code is returned and *pp is set to NULL.¢**ŸK** Otherwise, if the bExtend parameter is 0 and the requested shared-memoryŸK** region has not been allocated (by any client, including one running in aŸI** separate process), then *pp is set to NULL and SQLITE_OK returned. If ŸJ** bExtend is non-zero and the requested shared-memory region has not yet Ÿ4** been allocated, it is allocated by this function.¢**ŸL** If the shared-memory region has already been allocated or is allocated byŸG** this call as described above, then it is mapped into this processes ŸK** address space (if it is not already), *pp is set to point to the mapped Ÿ!** memory and SQLITE_OK returned.¢*/∂static int unixShmMap(ŸD  sqlite3_file *fd,               /* Handle open on database file */Ÿ:  int iRegion,                    /* Region to retrieve */Ÿ7  int szRegion,                   /* Size of regions */ŸH  int bExtend,                    /* True to extend file if necessary */Ÿ:  void volatile **pp              /* OUT: Mapped memory */¢){Ÿ"  unixFile *pDbFd = (unixFile*)fd;≠  unixShm *p;∏  unixShmNode *pShmNode;µ  int rc = SQLITE_OK;Ÿ)  int nShmPerMap = unixShmRegionPerMap();±  int nReqRegion;†ŸG  /* If the shared-memory file has not yet been opened, open it now. */∑  if( pDbFd->pShm==0 ){Ÿ%    rc = unixOpenSharedMemory(pDbFd);Ÿ"    if( rc!=SQLITE_OK ) return rc;£  }†≤  p = pDbFd->pShm;π  pShmNode = p->pShmNode;Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);Ω  if( pShmNode->isUnlocked ){Ÿ/    rc = unixLockSharedMemory(pDbFd, pShmNode);Ÿ)    if( rc!=SQLITE_OK ) goto shmpage_out;Ω    pShmNode->isUnlocked = 0;£  }ŸA  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );Ÿ,  assert( pShmNode->pInode==pDbFd->pInode );Ÿ=  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );Ÿ<  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 );†Ÿ8  /* Minimum number of regions required to be mapped. */Ÿ@  nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;†Ÿ%  if( pShmNode->nRegion<nReqRegion ){ŸA    char **apNew;                      /* New apRegion[] array */ŸG    int nByte = nReqRegion*szRegion;   /* Minimum required file size */Ÿ<    struct stat sStat;                 /* Used by fstat() */†Ÿ"    pShmNode->szRegion = szRegion;†π    if( pShmNode->h>=0 ){ŸN      /* The requested region is not mapped into this processes address space.ŸM      ** Check to see if it has been allocated (i.e. if the wal-index file isŸ7      ** large enough to contain the requested region).®      */Ÿ)      if( osFstat(pShmNode->h, &sStat) ){Ÿ"        rc = SQLITE_IOERR_SHMSIZE;π        goto shmpage_out;ß      }¢  Ÿ       if( sStat.st_size<nByte ){ŸK        /* The requested memory region does not exist. If bExtend is set toŸM        ** false, exit early. *pp will be set to NULL and SQLITE_OK returned.™        */∑        if( !bExtend ){ª          goto shmpage_out;©        }†ŸI        /* Alternatively, if bExtend is true, extend the file. Do this byŸC        ** writing a single byte to the end of each (OS) page beingŸH        ** allocated or extended. Technically, we need only write to theŸH        ** last page in order to extend the file. But writing to all newŸJ        ** pages forces the OS to allocate them immediately, which reducesŸL        ** the chances of SIGBUS while accessing the mapped region later on.™        */≠        else{Ÿ'          static const int pgsz = 4096;≤          int iPg;†ŸO          /* Write to the last byte of each newly allocated or extended page */Ÿ&          assert( (nByte % pgsz)==0 );ŸA          for(iPg=(sStat.st_size/pgsz); iPg<(nByte/pgsz); iPg++){∂            int x = 0;ŸO            if( seekAndWriteFd(pShmNode->h, iPg*pgsz + pgsz-1, "", 1, &x)!=1 ){Ÿ6              const char *zFile = pShmNode->zFilename;ŸF              rc = unixLogError(SQLITE_IOERR_SHMSIZE, "write", zFile);ø              goto shmpage_out;≠            }´          }©        }ß      }•    }†ŸL    /* Map the requested memory region into this processes address space. */Ÿ%    apNew = (char **)sqlite3_realloc(Ÿ5        pShmNode->apRegion, nReqRegion*sizeof(char *)¶    );±    if( !apNew ){Ÿ#      rc = SQLITE_IOERR_NOMEM_BKPT;∑      goto shmpage_out;•    }ø    pShmNode->apRegion = apNew;Ÿ*    while( pShmNode->nRegion<nReqRegion ){Ÿ%      int nMap = szRegion*nShmPerMap;¨      int i;±      void *pMem;ª      if( pShmNode->h>=0 ){æ        pMem = osMmap(0, nMap,ŸE            pShmNode->isReadonly ? PROT_READ : PROT_READ|PROT_WRITE, ŸD            MAP_SHARED, pShmNode->h, szRegion*(i64)pShmNode->nRegion™        );ø        if( pMem==MAP_FAILED ){ŸN          rc = unixLogError(SQLITE_IOERR_SHMMAP, "mmap", pShmNode->zFilename);ª          goto shmpage_out;©        }¨      }else{Ÿ*        pMem = sqlite3_malloc64(szRegion);∂        if( pMem==0 ){Ÿ!          rc = SQLITE_NOMEM_BKPT;ª          goto shmpage_out;©        }Ÿ"        memset(pMem, 0, szRegion);ß      }†Ÿ"      for(i=0; i<nShmPerMap; i++){ŸM        pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];ß      }Ÿ&      pShmNode->nRegion += nShmPerMap;•    }£  }†¨shmpage_out:Ÿ"  if( pShmNode->nRegion>iRegion ){Ÿ&    *pp = pShmNode->apRegion[iRegion];®  }else{¨    *pp = 0;£  }ŸC  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);¨  return rc;°}†¢/*Ÿ5** Change the lock state for a shared-memory segment.¢**ŸL** Note that the relationship between SHAREd and EXCLUSIVE locks is a littleŸI** different here than in posix.  In xShmLock(), one can go from unlockedŸJ** to shared and back or from unlocked to exclusive and back.  But one mayŸ?** not go from shared to exclusive or from exclusive to shared.¢*/∑static int unixShmLock(ŸJ  sqlite3_file *fd,          /* Database file holding the shared memory */ŸC  int ofst,                  /* First lock to acquire or release */ŸH  int n,                     /* Number of locks to acquire or release */Ÿ;  int flags                  /* What to do with the lock */¢){ŸN  unixFile *pDbFd = (unixFile*)fd;      /* Connection holding shared memory */ŸL  unixShm *p = pDbFd->pShm;             /* The shared memory being locked */ŸK  unixShm *pX;                          /* For looping over all siblings */ŸG  unixShmNode *pShmNode = p->pShmNode;  /* The underlying file iNode */Ÿ9  int rc = SQLITE_OK;                   /* Result code */ŸN  u16 mask;                             /* Mask of locks to take or release */†Ÿ.  assert( pShmNode==pDbFd->pInode->pShmNode );Ÿ,  assert( pShmNode->pInode==pDbFd->pInode );Ÿ0  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );±  assert( n>=1 );Ÿ6  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)Ÿ9       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)Ÿ8       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)Ÿ>       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );Ÿ6  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );Ÿ=  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );Ÿ<  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 );†Ÿ#  mask = (1<<(ofst+n)) - (1<<ofst);Ÿ#  assert( n>1 || mask==(1<<ofst) );Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);Ÿ"  if( flags & SQLITE_SHM_UNLOCK ){Ÿ9    u16 allMask = 0; /* Mask of locks held by siblings */†Ÿ1    /* See if any siblings hold this same lock */Ÿ/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){ª      if( pX==p ) continue;Ÿ@      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );Ÿ       allMask |= pX->sharedMask;•    }†Ÿ'    /* Unlock the system-level locks */æ    if( (mask & allMask)==0 ){ŸD      rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);™    }else{µ      rc = SQLITE_OK;•    }†æ    /* Undo the local locks */∏    if( rc==SQLITE_OK ){ª      p->exclMask &= ~mask;Ω      p->sharedMask &= ~mask;¶    } Ÿ(  }else if( flags & SQLITE_SHM_SHARED ){ŸO    u16 allShared = 0;  /* Union of locks held by connections other than "p" */†ŸK    /* Find out which shared locks are already held by sibling connections.ŸJ    ** If any sibling already holds an exclusive lock, go ahead and return≥    ** SQLITE_BUSY.¶    */Ÿ/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){Ÿ%      if( (pX->exclMask & mask)!=0 ){π        rc = SQLITE_BUSY;Æ        break;ß      }Ÿ"      allShared |= pX->sharedMask;•    }†Ÿ<    /* Get shared locks at the system level, if necessary */∏    if( rc==SQLITE_OK ){Ÿ"      if( (allShared & mask)==0 ){ŸF        rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);¨      }else{∑        rc = SQLITE_OK;ß      }•    }†Ÿ$    /* Get the local shared locks */∏    if( rc==SQLITE_OK ){º      p->sharedMask |= mask;•    }®  }else{ŸG    /* Make sure no sibling connections hold locks that will block thisŸ7    ** lock.  If any do, return SQLITE_BUSY right away.¶    */Ÿ/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){ŸC      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){π        rc = SQLITE_BUSY;Æ        break;ß      }•    }¢  ŸG    /* Get the exclusive locks at the system level.  Then if successfulŸ6    ** also mark the local connection as being locked.¶    */∏    if( rc==SQLITE_OK ){ŸD      rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);∫      if( rc==SQLITE_OK ){Ÿ,        assert( (p->sharedMask & mask)==0 );º        p->exclMask |= mask;ß      }•    }£  }Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);Ÿ7  OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",Ÿ<           p->id, osGetpid(0), p->sharedMask, p->exclMask));¨  return rc;°}†¢/*ŸA** Implement a memory barrier or memory fence on shared memory.  ¢**ŸE** All loads and stores begun before the barrier must complete beforeŸ-** any load or store begun after the barrier.¢*/ªstatic void unixShmBarrier(ŸO  sqlite3_file *fd                /* Database file holding the shared memory */¢){∑  UNUSED_PARAMETER(fd);ŸG  sqlite3MemoryBarrier();         /* compiler-defined memory barrier */ŸB  unixEnterMutex();               /* Also mutex, for redundancy */≥  unixLeaveMutex();°}†¢/*Ÿ?** Close a connection to shared-memory.  Delete the underlying Ÿ!** storage if deleteFlag is true.¢**ŸH** If there is no shared memory associated with the connection then thisø** routine is a harmless no-op.¢*/∏static int unixShmUnmap(ŸD  sqlite3_file *fd,               /* The underlying database file */ŸD  int deleteFlag                  /* Delete shared-memory if true */¢){ŸC  unixShm *p;                     /* The connection to be closed */ŸI  unixShmNode *pShmNode;          /* The underlying shared-memory file */ŸL  unixShm **pp;                   /* For looping over sibling connections */ŸD  unixFile *pDbFd;                /* The underlying database file */†∏  pDbFd = (unixFile*)fd;≤  p = pDbFd->pShm;æ  if( p==0 ) return SQLITE_OK;π  pShmNode = p->pShmNode;†Ÿ.  assert( pShmNode==pDbFd->pInode->pShmNode );Ÿ,  assert( pShmNode->pInode==pDbFd->pInode );†Ÿ?  /* Remove connection p from the set of connections associatedµ  ** with pShmNode */Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);Ÿ;  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}±  *pp = p->pNext;†Ω  /* Free the connection p */≤  sqlite3_free(p);≤  pDbFd->pShm = 0;Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);†Ÿ?  /* If pShmNode->nRef has reached 0, then close the underlyingø  ** shared-memory file, too */≥  unixEnterMutex();Ω  assert( pShmNode->nRef>0 );≥  pShmNode->nRef--;∫  if( pShmNode->nRef==0 ){Ÿ'    if( deleteFlag && pShmNode->h>=0 ){Ÿ$      osUnlink(pShmNode->zFilename);•    }∏    unixShmPurge(pDbFd);£  }≥  unixLeaveMutex();†≥  return SQLITE_OK;°}††•#elseπ# define unixShmMap     0π# define unixShmLock    0π# define unixShmBarrier 0π# define unixShmUnmap   0Ÿ$#endif /* #ifndef SQLITE_OMIT_WAL */†∫#if SQLITE_MAX_MMAP_SIZE>0¢/*Ÿ4** If it is currently memory mapped, unmap file pFd.¢*/Ÿ)static void unixUnmapfile(unixFile *pFd){æ  assert( pFd->nFetchOut==0 );∏  if( pFd->pMapRegion ){Ÿ3    osMunmap(pFd->pMapRegion, pFd->mmapSizeActual);∏    pFd->pMapRegion = 0;∂    pFd->mmapSize = 0;º    pFd->mmapSizeActual = 0;£  }°}†¢/*ŸD** Attempt to set the size of the memory mapping maintained by file ŸC** descriptor pFd to nNew bytes. Any existing mapping is discarded.¢**Ÿ=** If successful, this function sets the following variables:¢**º**       unixFile.pMapRegion∫**       unixFile.mmapSizeŸ **       unixFile.mmapSizeActual¢**ŸD** If unsuccessful, an error message is logged via sqlite3_log() andŸC** the three variables above are zeroed. In this case SQLite shouldŸA** continue accessing the database using the xRead() and xWrite()´** methods.¢*/∫static void unixRemapfile(Ÿ>  unixFile *pFd,                  /* File descriptor object */Ÿ=  i64 nNew                        /* Required mapping size */¢){º  const char *zErr = "mmap";ŸL  int h = pFd->h;                      /* File descriptor open on db file */ŸL  u8 *pOrig = (u8 *)pFd->pMapRegion;   /* Pointer to current file mapping */ŸJ  i64 nOrig = pFd->mmapSizeActual;     /* Size of pOrig region in bytes */ŸD  u8 *pNew = 0;                        /* Location of new mapping */ŸD  int flags = PROT_READ;               /* Flags to pass to mmap() */†æ  assert( pFd->nFetchOut==0 );ø  assert( nNew>pFd->mmapSize );Ÿ#  assert( nNew<=pFd->mmapSizeMax );≥  assert( nNew>0 );Ÿ/  assert( pFd->mmapSizeActual>=pFd->mmapSize );∫  assert( MAP_FAILED!=0 );†º#ifdef SQLITE_MMAP_READWRITEŸB  if( (pFd->ctrlFlags & UNIXFILE_RDONLY)==0 ) flags |= PROT_WRITE;¶#endif†Æ  if( pOrig ){Ø#if HAVE_MREMAPø    i64 nReuse = pFd->mmapSize;•#elseŸ*    const int szSyspage = osGetpagesize();Ÿ2    i64 nReuse = (pFd->mmapSize & ~(szSyspage-1));¶#endifæ    u8 *pReq = &pOrig[nReuse];†ŸH    /* Unmap any pages of the existing mapping that cannot be reused. */∏    if( nReuse!=nOrig ){Ÿ#      osMunmap(pReq, nOrig-nReuse);•    }†Ø#if HAVE_MREMAPŸ9    pNew = osMremap(pOrig, nReuse, nNew, MREMAP_MAYMOVE);¥    zErr = "mremap";•#elseŸC    pNew = osMmap(pReq, nNew-nReuse, flags, MAP_SHARED, h, nReuse);ª    if( pNew!=MAP_FAILED ){∑      if( pNew!=pReq ){Ÿ&        osMunmap(pNew, nNew - nReuse);±        pNew = 0;¨      }else{µ        pNew = pOrig;ß      }•    }¶#endif†ŸE    /* The attempt to extend the existing mapping failed. Free it. */Ÿ&    if( pNew==MAP_FAILED || pNew==0 ){æ      osMunmap(pOrig, nReuse);•    }£  }†ŸE  /* If pNew is still NULL, try to create an entirely new mapping. */∞  if( pNew==0 ){Ÿ4    pNew = osMmap(0, nNew, flags, MAP_SHARED, h, 0);£  }†π  if( pNew==MAP_FAILED ){≠    pNew = 0;≠    nNew = 0;Ÿ.    unixLogError(SQLITE_OK, zErr, pFd->zPath);†ŸJ    /* If the mmap() above failed, assume that all subsequent mmap() callsŸJ    ** will probably fail too. Fall back to using xRead/xWrite exclusively∏    ** in this case.  */π    pFd->mmapSizeMax = 0;£  }Ÿ!  pFd->pMapRegion = (void *)pNew;Ÿ-  pFd->mmapSize = pFd->mmapSizeActual = nNew;°}†¢/*ŸJ** Memory map or remap the file opened by file-descriptor pFd (if the fileŸK** is already mapped, the existing mapping is replaced by the new). Or, if ŸE** there already exists a mapping for this file, and there are still ŸC** outstanding xFetch() references to it, this function is a no-op.¢**ŸH** If parameter nByte is non-negative, then it is the requested size of ŸJ** the mapping to create. Otherwise, if nByte is less than zero, then the ŸI** requested size is the size of the file on disk. The actual size of theŸH** created mapping is either the requested size or the value configured Ÿ7** using SQLITE_FCNTL_MMAP_LIMIT, whichever is smaller.¢**ŸG** SQLITE_OK is returned if no error occurs (even if the mapping is notŸF** recreated as a result of outstanding references) or an SQLite error≤** code otherwise.¢*/Ÿ0static int unixMapfile(unixFile *pFd, i64 nMap){Ÿ)  assert( nMap>=0 || pFd->nFetchOut==0 );Ÿ?  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );Ÿ*  if( pFd->nFetchOut>0 ) return SQLITE_OK;†Ø  if( nMap<0 ){ŸB    struct stat statbuf;          /* Low-level file information */Ÿ$    if( osFstat(pFd->h, &statbuf) ){Ÿ       return SQLITE_IOERR_FSTAT;•    }ª    nMap = statbuf.st_size;£  }æ  if( nMap>pFd->mmapSizeMax ){º    nMap = pFd->mmapSizeMax;£  }†Ÿ?  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );º  if( nMap!=pFd->mmapSize ){Ω    unixRemapfile(pFd, nMap);£  }†≥  return SQLITE_OK;°}Ÿ##endif /* SQLITE_MAX_MMAP_SIZE>0 */†¢/*ŸK** If possible, return a pointer to a mapping of file fd starting at offsetŸ;** iOff. The mapping must be valid for at least nAmt bytes.¢**ŸK** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.ŸL** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.ŸJ** Finally, if an error does occur, return an SQLite error code. The finalŸ*** value of *pp is undefined in this case.¢**ŸF** If this function does return a pointer, the caller must eventually Ÿ2** release the reference by calling unixUnfetch().¢*/ŸFstatic int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){∫#if SQLITE_MAX_MMAP_SIZE>0ŸF  unixFile *pFd = (unixFile *)fd;   /* The underlying database file */¶#endif™  *pp = 0;†∫#if SQLITE_MAX_MMAP_SIZE>0ª  if( pFd->mmapSizeMax>0 ){Ω    if( pFd->pMapRegion==0 ){Ÿ$      int rc = unixMapfile(pFd, -1);Ÿ$      if( rc!=SQLITE_OK ) return rc;•    }Ÿ%    if( pFd->mmapSize >= iOff+nAmt ){Ÿ+      *pp = &((u8 *)pFd->pMapRegion)[iOff];∑      pFd->nFetchOut++;•    }£  }¶#endif≥  return SQLITE_OK;°}†¢/*ŸD** If the third argument is non-NULL, then this function releases a ŸC** reference obtained by an earlier call to unixFetch(). The secondŸI** argument passed to this function must be the same as the correspondingŸ;** argument that was passed to the unixFetch() invocation. ¢**ŸI** Or, if the third argument is NULL, then this function is being called ŸJ** to inform the VFS layer that, according to POSIX, any existing mapping Ÿ-** may now be invalid and should be unmapped.¢*/Ÿ<static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){∫#if SQLITE_MAX_MMAP_SIZE>0ŸF  unixFile *pFd = (unixFile *)fd;   /* The underlying database file */π  UNUSED_PARAMETER(iOff);†ŸG  /* If p==0 (unmap the entire file) then there must be no outstanding ŸH  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),Ÿ5  ** then there must be at least one outstanding.  */Ÿ(  assert( (p==0)==(pFd->nFetchOut==0) );†Ÿ.  /* If p!=0, it must match the iOff value. */Ÿ6  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] );†™  if( p ){µ    pFd->nFetchOut--;®  }else{∑    unixUnmapfile(pFd);£  }†æ  assert( pFd->nFetchOut>=0 );•#else∑  UNUSED_PARAMETER(fd);∂  UNUSED_PARAMETER(p);π  UNUSED_PARAMETER(iOff);¶#endif≥  return SQLITE_OK;°}†¢/*Ÿ<** Here ends the implementation of all sqlite3_file methods.¢**ŸO********************** End sqlite3_file Methods *******************************ŸO******************************************************************************/†¢/*ŸH** This division contains definitions of sqlite3_io_methods objects thatŸK** implement various file locking strategies.  It also contains definitionsŸN** of "finder" functions.  A finder-function is used to locate the appropriateŸJ** sqlite3_io_methods object for a particular database file.  The pAppDataŸI** field of the sqlite3_vfs VFS objects are initialized to be pointers toŸ,** the correct finder-function for that VFS.¢**ŸG** Most finder functions return a pointer to a fixed sqlite3_io_methodsŸK** object.  The only interesting finder-function is autolockIoFinder, whichŸC** looks at the filesystem type and tries to guess the best locking∂** strategy from that.¢**Ÿ2** For finder-function F, two objects are created:¢**Ÿ3**    (1) The real finder-function named "FImpt()".¢**Ÿ=**    (2) A constant pointer to this function named just "F".¢**¢**ŸC** A pointer to the F pointer is used as the pAppData value for VFSŸA** objects.  We have to do this instead of letting pAppData pointŸB** directly at the finder-function since C90 rules prevent a void*Ÿ(** from be cast into a function pointer.¢**¢**Ÿ5** Each instance of this macro generates two objects:¢**ŸI**   *  A constant sqlite3_io_methods object call METHOD that has lockingŸ/**      methods CLOSE, LOCK, UNLOCK, CKRESLOCK.¢**ŸJ**   *  An I/O method finder function called FINDER that returns a pointerŸ4**      to the METHOD object in the previous bullet.¢*/ŸN#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP)     \ŸNstatic const sqlite3_io_methods METHOD = {                                   \ŸN   VERSION,                    /* iVersion */                                \ŸN   CLOSE,                      /* xClose */                                  \ŸN   unixRead,                   /* xRead */                                   \ŸN   unixWrite,                  /* xWrite */                                  \ŸN   unixTruncate,               /* xTruncate */                               \ŸN   unixSync,                   /* xSync */                                   \ŸN   unixFileSize,               /* xFileSize */                               \ŸN   LOCK,                       /* xLock */                                   \ŸN   UNLOCK,                     /* xUnlock */                                 \ŸN   CKLOCK,                     /* xCheckReservedLock */                      \ŸN   unixFileControl,            /* xFileControl */                            \ŸN   unixSectorSize,             /* xSectorSize */                             \ŸN   unixDeviceCharacteristics,  /* xDeviceCapabilities */                     \ŸN   SHMMAP,                     /* xShmMap */                                 \ŸN   unixShmLock,                /* xShmLock */                                \ŸN   unixShmBarrier,             /* xShmBarrier */                             \ŸN   unixShmUnmap,               /* xShmUnmap */                               \ŸN   unixFetch,                  /* xFetch */                                  \ŸN   unixUnfetch,                /* xUnfetch */                                \ŸN};                                                                           \ŸNstatic const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   \ŸN  UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);                                  \ŸN  return &METHOD;                                                            \ŸN}                                                                            \ŸNstatic const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)    \≥    = FINDER##Impl;†¢/*ŸA** Here are all of the sqlite3_io_methods objects for each of theŸG** locking strategies.  Functions that return pointers to these methods¥** are also created.¢*/™IOMETHODS(Ÿ6  posixIoFinder,            /* Finder function name */Ÿ@  posixIoMethods,           /* sqlite3_io_methods object name */ŸD  3,                        /* shared memory and mmap are enabled */Ÿ/  unixClose,                /* xClose method */Ÿ.  unixLock,                 /* xLock method */Ÿ0  unixUnlock,               /* xUnlock method */Ÿ;  unixCheckReservedLock,    /* xCheckReservedLock method */Ÿ0  unixShmMap                /* xShmMap method */°)™IOMETHODS(Ÿ6  nolockIoFinder,           /* Finder function name */Ÿ@  nolockIoMethods,          /* sqlite3_io_methods object name */Ÿ;  3,                        /* shared memory is disabled */Ÿ/  nolockClose,              /* xClose method */Ÿ.  nolockLock,               /* xLock method */Ÿ0  nolockUnlock,             /* xUnlock method */Ÿ;  nolockCheckReservedLock,  /* xCheckReservedLock method */Ÿ0  0                         /* xShmMap method */°)™IOMETHODS(Ÿ6  dotlockIoFinder,          /* Finder function name */Ÿ@  dotlockIoMethods,         /* sqlite3_io_methods object name */Ÿ;  1,                        /* shared memory is disabled */Ÿ/  dotlockClose,             /* xClose method */Ÿ.  dotlockLock,              /* xLock method */Ÿ0  dotlockUnlock,            /* xUnlock method */Ÿ;  dotlockCheckReservedLock, /* xCheckReservedLock method */Ÿ0  0                         /* xShmMap method */°)†ø#if SQLITE_ENABLE_LOCKING_STYLE™IOMETHODS(Ÿ6  flockIoFinder,            /* Finder function name */Ÿ@  flockIoMethods,           /* sqlite3_io_methods object name */Ÿ;  1,                        /* shared memory is disabled */Ÿ/  flockClose,               /* xClose method */Ÿ.  flockLock,                /* xLock method */Ÿ0  flockUnlock,              /* xUnlock method */Ÿ;  flockCheckReservedLock,   /* xCheckReservedLock method */Ÿ0  0                         /* xShmMap method */°)¶#endif†Æ#if OS_VXWORKS™IOMETHODS(Ÿ6  semIoFinder,              /* Finder function name */Ÿ@  semIoMethods,             /* sqlite3_io_methods object name */Ÿ;  1,                        /* shared memory is disabled */Ÿ/  semXClose,                /* xClose method */Ÿ.  semXLock,                 /* xLock method */Ÿ0  semXUnlock,               /* xUnlock method */Ÿ;  semXCheckReservedLock,    /* xCheckReservedLock method */Ÿ0  0                         /* xShmMap method */°)¶#endif†Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE™IOMETHODS(Ÿ6  afpIoFinder,              /* Finder function name */Ÿ@  afpIoMethods,             /* sqlite3_io_methods object name */Ÿ;  1,                        /* shared memory is disabled */Ÿ/  afpClose,                 /* xClose method */Ÿ.  afpLock,                  /* xLock method */Ÿ0  afpUnlock,                /* xUnlock method */Ÿ;  afpCheckReservedLock,     /* xCheckReservedLock method */Ÿ0  0                         /* xShmMap method */°)¶#endif†¢/*ŸD** The proxy locking method is a "super-method" in the sense that itŸD** opens secondary file descriptors for the conch and lock files andŸE** it uses proxy, dot-file, AFP, and flock() locking methods on thoseŸB** secondary files.  For this reason, the division that implementsŸG** proxy locking is located much further down in the file.  But we needŸD** to go ahead and define the sqlite3_io_methods and finder functionŸB** for proxy locking here.  So we forward declare the I/O methods.¢*/Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEŸ%static int proxyClose(sqlite3_file*);Ÿ)static int proxyLock(sqlite3_file*, int);Ÿ+static int proxyUnlock(sqlite3_file*, int);Ÿ7static int proxyCheckReservedLock(sqlite3_file*, int*);™IOMETHODS(Ÿ6  proxyIoFinder,            /* Finder function name */Ÿ@  proxyIoMethods,           /* sqlite3_io_methods object name */Ÿ;  1,                        /* shared memory is disabled */Ÿ/  proxyClose,               /* xClose method */Ÿ.  proxyLock,                /* xLock method */Ÿ0  proxyUnlock,              /* xUnlock method */Ÿ;  proxyCheckReservedLock,   /* xCheckReservedLock method */Ÿ0  0                         /* xShmMap method */°)¶#endif†ŸN/* nfs lockd on OSX 10.3+ doesn't clear write locks when a read lock is set */Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE™IOMETHODS(Ÿ7  nfsIoFinder,               /* Finder function name */ŸA  nfsIoMethods,              /* sqlite3_io_methods object name */Ÿ<  1,                         /* shared memory is disabled */Ÿ0  unixClose,                 /* xClose method */Ÿ/  unixLock,                  /* xLock method */Ÿ1  nfsUnlock,                 /* xUnlock method */Ÿ<  unixCheckReservedLock,     /* xCheckReservedLock method */Ÿ1  0                          /* xShmMap method */°)¶#endif†Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE£/* ŸJ** This "finder" function attempts to determine the best locking strategy ŸL** for the database file "filePath".  It then returns the sqlite3_io_methodsŸ(** object that implements that strategy.¢**ª** This is for MacOSX only.¢*/Ÿ6static const sqlite3_io_methods *autolockIoFinderImpl(Ÿ:  const char *filePath,    /* name of the database file */ŸG  unixFile *pNew           /* open file object for the database file */¢){ø  static const struct Mapping {ŸD    const char *zFilesystem;              /* Filesystem type name */ŸJ    const sqlite3_io_methods *pMethods;   /* Appropriate locking method */Æ  } aMap[] = {Ÿ"    { "hfs",    &posixIoMethods },Ÿ"    { "ufs",    &posixIoMethods },Ÿ     { "afpfs",  &afpIoMethods },Ÿ     { "smbfs",  &afpIoMethods },Ÿ#    { "webdav", &nolockIoMethods },¨    { 0, 0 }§  };®  int i;∑  struct statfs fsInfo;∏  struct flock lockInfo;†≤  if( !filePath ){ŸH    /* If filePath==NULL that means we are dealing with a transient fileŸ*    ** that does not need to be locked. */º    return &nolockIoMethods;£  }Ÿ(  if( statfs(filePath, &fsInfo) != -1 ){Ÿ&    if( fsInfo.f_flags & MNT_RDONLY ){æ      return &nolockIoMethods;•    }Ÿ'    for(i=0; aMap[i].zFilesystem; i++){Ÿ@      if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){Ÿ         return aMap[i].pMethods;ß      }•    }£  }†Ÿ2  /* Default case. Handles, amongst others, "nfs".Ÿ?  ** Test byte-range lock using fcntl(). If the call succeeds, Ÿ=  ** assume that the file-system supports POSIX style locks. §  */µ  lockInfo.l_len = 1;∑  lockInfo.l_start = 0;ø  lockInfo.l_whence = SEEK_SET;º  lockInfo.l_type = F_RDLCK;Ÿ2  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {Ÿ0    if( strcmp(fsInfo.f_fstypename, "nfs")==0 ){ª      return &nfsIoMethods;¨    } else {Ω      return &posixIoMethods;•    }®  }else{Ω    return &dotlockIoMethods;£  }°}Ÿ static const sqlite3_io_methods ŸK  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;†Ÿ>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */†Æ#if OS_VXWORKS¢/*ŸE** This "finder" function for VxWorks checks to see if posix advisoryŸI** locking works.  If it does, then that is what is used.  If it does notŸ2** work, then fallback to named semaphore locking.¢*/Ÿ5static const sqlite3_io_methods *vxworksIoFinderImpl(Ÿ:  const char *filePath,    /* name of the database file */Ÿ5  unixFile *pNew           /* the open file object */¢){∏  struct flock lockInfo;†≤  if( !filePath ){ŸH    /* If filePath==NULL that means we are dealing with a transient fileŸ*    ** that does not need to be locked. */º    return &nolockIoMethods;£  }†Ÿ<  /* Test if fcntl() is supported and use POSIX style locks.Ÿ7  ** Otherwise fall back to the named semaphore method.§  */µ  lockInfo.l_len = 1;∑  lockInfo.l_start = 0;ø  lockInfo.l_whence = SEEK_SET;º  lockInfo.l_type = F_RDLCK;Ÿ2  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {ª    return &posixIoMethods;®  }else{π    return &semIoMethods;£  }°}Ÿ static const sqlite3_io_methods ŸI  *(*const vxworksIoFinder)(const char*,unixFile*) = vxworksIoFinderImpl;†∑#endif /* OS_VXWORKS */†¢/*ŸB** An abstract type for a pointer to an IO method finder function:¢*/ŸHtypedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);††ŸM/****************************************************************************ŸM**************************** sqlite3_vfs methods ****************************¢**Ÿ>** This division contains the implementation of methods on the∂** sqlite3_vfs object.¢*/†¢/*ŸG** Initialize the contents of the unixFile structure pointed to by pId.¢*/∫static int fillInUnixFile(Ÿ5  sqlite3_vfs *pVfs,      /* Pointer to vfs object */ŸI  int h,                  /* Open file descriptor of file being opened */ŸD  sqlite3_file *pId,      /* Write to the unixFile structure here */Ÿ=  const char *zFilename,  /* Name of the file being opened */Ÿ>  int ctrlFlags           /* Zero or more UNIXFILE_* values */¢){Ÿ*  const sqlite3_io_methods *pLockingStyle;Ÿ#  unixFile *pNew = (unixFile *)pId;µ  int rc = SQLITE_OK;†ø  assert( pNew->pInode==NULL );†Ÿ,  /* No locking occurs in temporary files */Ÿ=  assert( zFilename!=0 || (ctrlFlags & UNIXFILE_NOLOCK)!=0 );†Ÿ/  OSTRACE(("OPEN    %-3d %s\n", h, zFilename));Æ  pNew->h = h;¥  pNew->pVfs = pVfs;∫  pNew->zPath = zFilename;Ÿ"  pNew->ctrlFlags = (u8)ctrlFlags;∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ1  pNew->mmapSizeMax = sqlite3GlobalConfig.szMmap;¶#endifŸG  if( sqlite3_uri_boolean(((ctrlFlags & UNIXFILE_URI) ? zFilename : 0),ŸA                           "psow", SQLITE_POWERSAFE_OVERWRITE) ){Ÿ%    pNew->ctrlFlags |= UNIXFILE_PSOW;£  }Ÿ+  if( strcmp(pVfs->zName,"unix-excl")==0 ){Ÿ%    pNew->ctrlFlags |= UNIXFILE_EXCL;£  }†Æ#if OS_VXWORKSŸ+  pNew->pId = vxworksFindFileId(zFilename);µ  if( pNew->pId==0 ){Ÿ!    ctrlFlags |= UNIXFILE_NOLOCK;ª    rc = SQLITE_NOMEM_BKPT;£  }¶#endif†Ÿ$  if( ctrlFlags & UNIXFILE_NOLOCK ){Ÿ%    pLockingStyle = &nolockIoMethods;®  }else{ŸF    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);ø#if SQLITE_ENABLE_LOCKING_STYLEŸL    /* Cache zFilename in the locking context (AFP and dotlock override) forŸJ    ** proxyLock activation is possible (remote proxy is based on db name)ŸB    ** zFilename remains valid until file is closed, to support */Ÿ,    pNew->lockingContext = (void*)zFilename;¶#endif£  }†Ÿ&  if( pLockingStyle == &posixIoMethodsŸ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEŸ%    || pLockingStyle == &nfsIoMethods¶#endif§  ){µ    unixEnterMutex();Ÿ,    rc = findInodeInfo(pNew, &pNew->pInode);∏    if( rc!=SQLITE_OK ){ŸK      /* If an error occurred in findInodeInfo(), close the file descriptorŸJ      ** immediately, before releasing the mutex. findInodeInfo() may fail∫      ** in two scenarios:®      **Ÿ(      **   (a) A call to fstat() failed.ø      **   (b) A malloc failed.®      **ŸG      ** Scenario (b) may only occur if the process is holding no otherŸI      ** file descriptors open on the same file. If there were other fileŸF      ** descriptors on this file, then no malloc would be required byŸH      ** findInodeInfo(). If this is the case, it is quite safe to closeŸL      ** handle h - as it is guaranteed that no posix locks will be releasedµ      ** by doing so.®      **ŸJ      ** If scenario (a) caused the error then things are not so safe. TheŸI      ** implicit assumption here is that if fstat() fails, things are inŸH      ** such bad shape that dropping a lock or two doesn't matter much.®      */Ÿ&      robust_close(pNew, h, __LINE__);≠      h = -1;•    }µ    unixLeaveMutex();£  }†Ÿ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ÿ,  else if( pLockingStyle == &afpIoMethods ){ŸC    /* AFP locking uses the file path so it needs to be included inΩ    ** the afpLockingContext.¶    */º    afpLockingContext *pCtx;ŸD    pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );≤    if( pCtx==0 ){Ω      rc = SQLITE_NOMEM_BKPT;™    }else{ŸH      /* NB: zFilename exists and remains valid until the file is closedŸF      ** according to requirement F11141.  So we do not need to make aŸ!      ** copy of the filename. */ø      pCtx->dbPath = zFilename;π      pCtx->reserved = 0;≥      srandomdev();∑      unixEnterMutex();Ÿ.      rc = findInodeInfo(pNew, &pNew->pInode);∫      if( rc!=SQLITE_OK ){Ÿ+        sqlite3_free(pNew->lockingContext);Ÿ(        robust_close(pNew, h, __LINE__);Ø        h = -1;ß      }ø      unixLeaveMutex();        •    }£  }¶#endif†Ÿ0  else if( pLockingStyle == &dotlockIoMethods ){ŸG    /* Dotfile locking uses the file path so it needs to be included inŸ!    ** the dotlockLockingContext ¶    */¥    char *zLockFile;≤    int nFilename;ª    assert( zFilename!=0 );Ÿ+    nFilename = (int)strlen(zFilename) + 6;Ÿ4    zLockFile = (char *)sqlite3_malloc64(nFilename);∑    if( zLockFile==0 ){Ω      rc = SQLITE_NOMEM_BKPT;™    }else{ŸM      sqlite3_snprintf(nFilename, zLockFile, "%s" DOTLOCK_SUFFIX, zFilename);•    }Ÿ%    pNew->lockingContext = zLockFile;£  }†Æ#if OS_VXWORKSŸ,  else if( pLockingStyle == &semIoMethods ){ŸC    /* Named semaphore locking uses the file path so it needs to beŸ(    ** included in the semLockingContext¶    */µ    unixEnterMutex();Ÿ,    rc = findInodeInfo(pNew, &pNew->pInode);Ÿ8    if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){Ÿ.      char *zSemName = pNew->pInode->aSemName;¨      int n;Ÿ9      sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",Ÿ2                       pNew->pId->zCanonicalName);Ÿ"      for( n=1; zSemName[n]; n++ )Ÿ1        if( zSemName[n]=='/' ) zSemName[n] = '_';Ÿ@      pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);Ÿ-      if( pNew->pInode->pSem == SEM_FAILED ){ø        rc = SQLITE_NOMEM_BKPT;Ÿ)        pNew->pInode->aSemName[0] = '\0';ß      }•    }µ    unixLeaveMutex();£  }¶#endif¢  ∫  storeLastErrno(pNew, 0);Æ#if OS_VXWORKS∂  if( rc!=SQLITE_OK ){Ÿ/    if( h>=0 ) robust_close(pNew, h, __LINE__);´    h = -1;∏    osUnlink(zFilename);Ÿ'    pNew->ctrlFlags |= UNIXFILE_DELETE;£  }¶#endif∂  if( rc!=SQLITE_OK ){Ÿ/    if( h>=0 ) robust_close(pNew, h, __LINE__);®  }else{Ÿ"    pNew->pMethod = pLockingStyle;¥    OpenCounter(+1);∑    verifyDbFile(pNew);£  }¨  return rc;°}†¢/*ŸB** Return the name of a directory in which to put temporary files.ŸE** If no suitable temporary file directory can be found, return NULL.¢*/Ÿ)static const char *unixTempFileDir(void){Ÿ!  static const char *azDirs[] = {ß     0,ß     0,∞     "/var/tmp",∞     "/usr/tmp",¨     "/tmp",®     "."§  };µ  unsigned int i = 0;≤  struct stat buf;Ÿ,  const char *zDir = sqlite3_temp_directory;†Ÿ7  if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");Ÿ0  if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");´  while(1){Ø    if( zDir!=0Ω     && osStat(zDir, &buf)==0º     && S_ISDIR(buf.st_mode)Ω     && osAccess(zDir, 03)==0¶    ){≤      return zDir;•    }Ÿ4    if( i>=sizeof(azDirs)/sizeof(azDirs[0]) ) break;∑    zDir = azDirs[i++];£  }´  return 0;°}†¢/*Ÿ@** Create a temporary file name in zBuf.  zBuf must be allocatedŸA** by the calling process and must be big enough to hold at least∫** pVfs->mxPathname bytes.¢*/Ÿ1static int unixGetTempname(int nBuf, char *zBuf){≥  const char *zDir;±  int iLimit = 0;†ŸC  /* It's odd to simulate an io-error here, but really this is justŸG  ** using the io-error infrastructure to test that SQLite handles this∑  ** function failing. §  */Æ  zBuf[0] = 0;Ÿ)  SimulateIOError( return SQLITE_IOERR );†ª  zDir = unixTempFileDir();Ÿ0  if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;•  do{™    u64 r;Ÿ&    sqlite3_randomness(sizeof(r), &r);µ    assert( nBuf>2 );µ    zBuf[nBuf-2] = 0;ŸF    sqlite3_snprintf(nBuf, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX"%llx%c",Ÿ!                     zDir, r, 0);Ÿ?    if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ) return SQLITE_ERROR;Ÿ   }while( osAccess(zBuf,0)==0 );≥  return SQLITE_OK;°}†Ÿ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)¢/*ŸA** Routine to transform a unixFile into a proxy-locking unixFile.ŸD** Implementation in the proxy-lock division, but used by unixOpen()Ÿ-** if SQLITE_PREFER_PROXY_LOCKING is defined.¢*/Ÿ:static int proxyTransformUnixFile(unixFile*, const char*);¶#endif†¢/*ŸH** Search for an unused file descriptor that was opened on the database ŸE** file (not a journal or master-journal file) identified by pathnameŸG** zPath with SQLITE_OPEN_XXX flags matching those passed as the secondΩ** argument to this function.¢**ŸG** Such a file descriptor may exist if a database connection was closedŸF** but the associated file descriptor could not be closed because someŸF** other file descriptor open on the same file is holding a file-lock.ŸH** Refer to comments in the unixClose() function and the lengthy commentŸE** describing "Posix Advisory Locking" at the start of this file for Ÿ'** further details. Also, ticket #4018.¢**ŸE** If a suitable file descriptor is found, then it is returned. If noŸ3** such file descriptor is located, -1 is returned.¢*/ŸBstatic UnixUnusedFd *findReusableFd(const char *zPath, int flags){º  UnixUnusedFd *pUnused = 0;†ŸH  /* Do not search for an unused file descriptor on vxworks. Not becauseŸJ  ** vxworks would not benefit from the change (it might, we're not sure),ŸH  ** but because no way to test it is currently available. It is better ŸJ  ** not to risk breaking vxworks support for the sake of such an obscure ±  ** feature.  */Ø#if !OS_VXWORKSŸC  struct stat sStat;                   /* Results of stat() call */†≥  unixEnterMutex();†ŸG  /* A stat() call may fail for various reasons. If this happens, it isŸH  ** almost certain that an open() call on the same path will also fail.ŸG  ** For this reason, if an error occurs in the stat() call here, it isŸG  ** ignored and -1 is returned. The caller will try to open a new fileŸF  ** descriptor on the same path, fail, and return an error to SQLite.§  **ŸG  ** Even if a subsequent open() call does succeed, the consequences ofŸC  ** not searching for a reusable file descriptor are not dire.  */Ÿ0  if( nUnusedFd>0 && 0==osStat(zPath, &sStat) ){∫    unixInodeInfo *pInode;†∑    pInode = inodeList;Ÿ6    while( pInode && (pInode->fileId.dev!=sStat.st_devŸA                     || pInode->fileId.ino!=(u64)sStat.st_ino) ){æ       pInode = pInode->pNext;•    }±    if( pInode ){∏      UnixUnusedFd **pp;ŸO      for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));¥      pUnused = *pp;¥      if( pUnused ){¥        nUnusedFd--;Ω        *pp = pUnused->pNext;ß      }•    }£  }≥  unixLeaveMutex();æ#endif    /* if !OS_VXWORKS */±  return pUnused;°}†¢/*Ÿ-** Find the mode, uid and gid of file zFile. ¢*/∑static int getFileMode(Ÿ1  const char *zFile,              /* File name */ŸA  mode_t *pMode,                  /* OUT: Permissions of zFile */Ÿ:  uid_t *pUid,                    /* OUT: uid of zFile. */Ÿ:  gid_t *pGid                     /* OUT: gid of zFile. */¢){ŸI  struct stat sStat;              /* Output of stat() on database file */µ  int rc = SQLITE_OK;Ÿ!  if( 0==osStat(zFile, &sStat) ){Ÿ"    *pMode = sStat.st_mode & 0777;π    *pUid = sStat.st_uid;π    *pGid = sStat.st_gid;®  }else{º    rc = SQLITE_IOERR_FSTAT;£  }¨  return rc;°}†¢/*ŸJ** This function is called by unixOpen() to determine the unix permissionsŸK** to create new files with. If no error occurs, then SQLITE_OK is returnedŸG** and a value suitable for passing as the third argument to open(2) isŸE** written to *pMode. If an IO error occurs, an SQLite error code is Ÿ4** returned and the value of *pMode is not modified.¢**ŸB** In most cases, this routine sets *pMode to 0, which will becomeŸ:** an indication to robust_open() to create the file usingŸ9** SQLITE_DEFAULT_FILE_PERMISSIONS adjusted by the umask.ŸG** But if the file being opened is a WAL or regular journal file, then ŸD** this function queries the file-system for the permissions on the ŸG** corresponding database file and sets *pMode to this value. Whenever ŸJ** possible, WAL and journal files are created using the same permissions Ÿ#** as the associated database file.¢**Ÿ=** If the SQLITE_ENABLE_8_3_NAMES option is enabled, then theŸD** original filename is unavailable.  But 8_3_NAMES is only used forŸC** FAT filesystems and permissions do not matter there, so just useª** the default permissions.¢*/æstatic int findCreateFileMode(ŸM  const char *zPath,              /* Path of file (possibly) being created */ŸO  int flags,                      /* Flags passed as 4th argument to xOpen() */ŸJ  mode_t *pMode,                  /* OUT: Permissions to open file with */ŸC  uid_t *pUid,                    /* OUT: uid to set on the file */ŸC  gid_t *pGid                     /* OUT: gid to set on the file */¢){Ÿ3  int rc = SQLITE_OK;             /* Return Code */≠  *pMode = 0;¨  *pUid = 0;¨  *pGid = 0;Ÿ;  if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){Ÿ:    char zDb[MAX_PATHNAME+1];     /* Database file path */ŸD    int nDb;                      /* Number of valid bytes in zDb */†ŸL    /* zPath is a path to a WAL or journal file. The following block derivesŸN    ** the path to the associated database file from zPath. This block handlesŸ(    ** the following naming conventions:¶    **ø    **   "<path to db>-journal"ª    **   "<path to db>-wal"Ÿ!    **   "<path to db>-journalNN"Ω    **   "<path to db>-walNN"¶    **Ÿ?    ** where NN is a decimal number. The NN naming schemes are Ÿ+    ** used by the test_multiplex.c module.¶    */Ÿ&    nDb = sqlite3Strlen30(zPath) - 1; Ω    while( zPath[nDb]!='-' ){ŸG      /* In normal operation, the journal file name will always containŸH      ** a '-' character.  However in 8+3 filename mode, or if a corruptŸL      ** rollback journal specifies a master journal with a goofy name, thenŸ%      ** the '-' might be missing. */Ÿ7      if( nDb==0 || zPath[nDb]=='.' ) return SQLITE_OK;¨      nDb--;•    }º    memcpy(zDb, zPath, nDb);¥    zDb[nDb] = '\0';†Ÿ-    rc = getFileMode(zDb, pMode, pUid, pGid);Ÿ0  }else if( flags & SQLITE_OPEN_DELETEONCLOSE ){≤    *pMode = 0600;Ÿ&  }else if( flags & SQLITE_OPEN_URI ){ŸJ    /* If this is a main database file and the file was opened using a URIŸH    ** filename, check for the "modeof" parameter. If present, interpretŸI    ** its value as a filename and try to copy the mode, uid and gid fromµ    ** that file.  */Ÿ;    const char *z = sqlite3_uri_parameter(zPath, "modeof");¨    if( z ){Ÿ-      rc = getFileMode(z, pMode, pUid, pGid);•    }£  }¨  return rc;°}†¢/*∑** Open the file zPath.£** ŸH** Previously, the SQLite OS layer used three functions in place of thisß** one:¢**Ÿ **     sqlite3OsOpenReadWrite();ø**     sqlite3OsOpenReadOnly();Ÿ **     sqlite3OsOpenExclusive();¢**ŸA** These calls correspond to the following combinations of flags:¢**Ÿ.**     ReadWrite() ->     (READWRITE | CREATE)Ÿ%**     ReadOnly()  ->     (READONLY) Ÿ:**     OpenExclusive() -> (READWRITE | CREATE | EXCLUSIVE)¢**ŸF** The old OpenExclusive() accepted a boolean argument - "delFlag". IfŸE** true, the file was configured to be automatically deleted when theŸA** file handle closed. To achieve the same effect using this new ŸF** interface, add the DELETEONCLOSE flag to those specified above for ≥** OpenExclusive().¢*/¥static int unixOpen(ŸO  sqlite3_vfs *pVfs,           /* The VFS for which this is the xOpen method */ŸB  const char *zPath,           /* Pathname of file to be opened */ŸH  sqlite3_file *pFile,         /* The file descriptor to be filled in */ŸG  int flags,                   /* Input flags to control the opening */ŸI  int *pOutFlags               /* Output flags returned to SQLite core */¢){Ÿ"  unixFile *p = (unixFile *)pFile;ŸI  int fd = -1;                   /* File descriptor returned by open() */Ÿ>  int openFlags = 0;             /* Flags to pass to open() */Ÿ;  int eType = flags&0xFFFFFF00;  /* Type of file to open */ŸF  int noLock;                    /* True to omit locking primitives */Ÿ;  int rc = SQLITE_OK;            /* Function Return Code */Ÿ7  int ctrlFlags = 0;             /* UNIXFILE_* flags */†Ÿ5  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);Ÿ9  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);Ÿ2  int isCreate     = (flags & SQLITE_OPEN_CREATE);Ÿ4  int isReadonly   = (flags & SQLITE_OPEN_READONLY);Ÿ5  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);ø#if SQLITE_ENABLE_LOCKING_STYLEŸ5  int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);¶#endifŸ5#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE∑  struct statfs fsInfo;¶#endif†ŸG  /* If creating a master or main-file journal, this function will openŸF  ** a file-descriptor on the directory too. The first time unixSync()ŸL  ** is called the directory file descriptor will be fsync()ed and close()d.§  */Ÿ   int isNewJrnl = (isCreate && (Ÿ*        eType==SQLITE_OPEN_MASTER_JOURNAL Ÿ(     || eType==SQLITE_OPEN_MAIN_JOURNAL æ     || eType==SQLITE_OPEN_WAL•  ));†ŸK  /* If argument zPath is a NULL pointer, this function is required to openŸA  ** a temporary file. Use this buffer to store the file name in.§  */Ÿ   char zTmpname[MAX_PATHNAME+2];º  const char *zName = zPath;†Ÿ.  /* Check the following statements are true: §  **ŸL  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and ŸA  **   (b) if CREATE is set, then READWRITE must also be set, andŸ=  **   (c) if EXCLUSIVE is set, then CREATE must also be set.ŸA  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.§  */ŸK  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));Ÿ%  assert(isCreate==0 || isReadWrite);Ÿ%  assert(isExclusive==0 || isCreate);Ÿ"  assert(isDelete==0 || isCreate);†ŸF  /* The main DB, main journal, WAL file and master journal are never ŸB  ** automatically deleted. Nor are they ever temporary files.  */Ÿ?  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );ŸD  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );ŸF  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );Ÿ;  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );†ŸI  /* Assert that the upper layer has set one of the "file-type" flags. */ŸH  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB ŸM       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL ŸO       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL ŸC       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL§  );†ŸG  /* Detect a pid change and reset the PRNG.  There is a race conditionŸG  ** here such that two or more threads all trying to open databases atŸD  ** the same instant might all reset the PRNG.  But multiple resets≤  ** are harmless.§  */Ÿ#  if( randomnessPid!=osGetpid(0) ){Ÿ     randomnessPid = osGetpid(0);º    sqlite3_randomness(0,0);£  }Ÿ!  memset(p, 0, sizeof(unixFile));†Ÿ#  if( eType==SQLITE_OPEN_MAIN_DB ){∫    UnixUnusedFd *pUnused;Ÿ+    pUnused = findReusableFd(zName, flags);≤    if( pUnused ){∑      fd = pUnused->fd;™    }else{Ÿ3      pUnused = sqlite3_malloc64(sizeof(*pUnused));µ      if( !pUnused ){Ÿ!        return SQLITE_NOMEM_BKPT;ß      }•    }Ÿ%    p->pPreallocatedUnused = pUnused;†ŸD    /* Database filenames are double-zero terminated if they are notŸC    ** URIs with parameters.  Hence, they can always be passed intoŸ"    ** sqlite3_uri_parameter(). */ŸE    assert( (flags & SQLITE_OPEN_URI) || zName[strlen(zName)+1]==0 );†µ  }else if( !zName ){ŸF    /* If zName is NULL, the upper layer is requesting a temp file. */Ÿ#    assert(isDelete && !isNewJrnl);Ÿ5    rc = unixGetTempname(pVfs->mxPathname, zTmpname);∏    if( rc!=SQLITE_OK ){∞      return rc;•    }µ    zName = zTmpname;†ŸF    /* Generated temporary filenames are always double-zero terminatedŸ-    ** for use by sqlite3_uri_parameter(). */Ÿ(    assert( zName[strlen(zName)+1]==0 );£  }†ŸH  /* Determine the value of the flags parameter passed to POSIX functionŸF  ** open(). These must be calculated even if open() is not called, asŸC  ** they may be stored as part of the file handle and used by the Ÿ1  ** 'conch file' locking functions later on.  */Ÿ*  if( isReadonly )  openFlags |= O_RDONLY;Ÿ(  if( isReadWrite ) openFlags |= O_RDWR;Ÿ)  if( isCreate )    openFlags |= O_CREAT;Ÿ5  if( isExclusive ) openFlags |= (O_EXCL|O_NOFOLLOW);Ÿ&  openFlags |= (O_LARGEFILE|O_BINARY);†≠  if( fd<0 ){ŸG    mode_t openMode;              /* Permissions to create file with */Ÿ;    uid_t uid;                    /* Userid for the file */Ÿ<    gid_t gid;                    /* Groupid for the file */ŸA    rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);∏    if( rc!=SQLITE_OK ){Ÿ(      assert( !p->pPreallocatedUnused );ŸJ      assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );∞      return rc;•    }Ÿ1    fd = robust_open(zName, openFlags, openMode);Ÿ=    OSTRACE(("OPENX   %-3d %s 0%o\n", fd, zName, openFlags));Ÿ7    assert( !isExclusive || (openFlags & O_CREAT)!=0 );Ø    if( fd<0 ){Ÿ@      if( isNewJrnl && errno==EACCES && osAccess(zName, F_OK) ){ŸE        /* If unable to create a journal because the directory is notŸ?        ** writable, change the error code to indicate that. */Ÿ'        rc = SQLITE_READONLY_DIRECTORY;Ÿ/      }else if( errno!=EISDIR && isReadWrite ){ŸK        /* Failed to open the file for read/write access. Try read-only. */Ÿ=        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);Ÿ'        openFlags &= ~(O_RDWR|O_CREAT);Ÿ&        flags |= SQLITE_OPEN_READONLY;æ        openFlags |= O_RDONLY;∑        isReadonly = 1;Ÿ5        fd = robust_open(zName, openFlags, openMode);ß      }•    }Ø    if( fd<0 ){ŸB      int rc2 = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);Ÿ#      if( rc==SQLITE_OK ) rc = rc2;π      goto open_finished;•    }†ŸH    /* If this process is running as root and if creating a new rollbackŸI    ** journal or WAL file, set the ownership of the journal or WAL to beŸ)    ** the same as the original database.¶    */Ÿ=    if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){Ÿ!      robustFchown(fd, uid, gid);•    }£  }≤  assert( fd>=0 );≤  if( pOutFlags ){∑    *pOutFlags = flags;£  }†ø  if( p->pPreallocatedUnused ){Ÿ$    p->pPreallocatedUnused->fd = fd;Ÿ*    p->pPreallocatedUnused->flags = flags;£  }†±  if( isDelete ){Æ#if OS_VXWORKS≤    zPath = zName;Ÿ(#elif defined(SQLITE_UNLINK_AFTER_CLOSE)Ÿ)    zPath = sqlite3_mprintf("%s", zName);≥    if( zPath==0 ){Ÿ$      robust_close(p, fd, __LINE__);ø      return SQLITE_NOMEM_BKPT;•    }•#else¥    osUnlink(zName);¶#endif£  }ø#if SQLITE_ENABLE_LOCKING_STYLEß  else{Ω    p->openFlags = openFlags;£  }¶#endif¢  Ÿ5#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLEŸ#  if( fstatfs(fd, &fsInfo) == -1 ){Ω    storeLastErrno(p, errno);Ÿ"    robust_close(p, fd, __LINE__);ø    return SQLITE_IOERR_ACCESS;£  }Ÿ6  if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {Ÿ;    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;£  }Ÿ6  if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {Ÿ;    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;£  }¶#endif†Ÿ$  /* Set up appropriate ctrlFlags */Ÿ=  if( isDelete )                ctrlFlags |= UNIXFILE_DELETE;Ÿ=  if( isReadonly )              ctrlFlags |= UNIXFILE_RDONLY;Ÿ&  noLock = eType!=SQLITE_OPEN_MAIN_DB;Ÿ=  if( noLock )                  ctrlFlags |= UNIXFILE_NOLOCK;Ÿ>  if( isNewJrnl )               ctrlFlags |= UNIXFILE_DIRSYNC;Ÿ:  if( flags & SQLITE_OPEN_URI ) ctrlFlags |= UNIXFILE_URI;†ø#if SQLITE_ENABLE_LOCKING_STYLEø#if SQLITE_PREFER_PROXY_LOCKING≤  isAutoProxy = 1;¶#endifŸA  if( isAutoProxy && (zPath!=NULL) && (!noLock) && pVfs->xOpen ){Ÿ:    char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");µ    int useProxy = 0;†ŸK    /* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 0 means ŸJ    ** never use proxy, NULL means use proxy for non-local files only.  */π    if( envforce!=NULL ){Ÿ"      useProxy = atoi(envforce)>0;™    }else{Ÿ-      useProxy = !(fsInfo.f_flags&MNT_LOCAL);•    }≥    if( useProxy ){Ÿ=      rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);∫      if( rc==SQLITE_OK ){Ÿ@        rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");º        if( rc!=SQLITE_OK ){ŸM          /* Use unixClose to clean up the resources added in fillInUnixFile ŸF          ** and clear all the structure's references.  Specifically, ŸL          ** pFile->pMethods will be NULL so sqlite3OsClose will be a no-op ¨          */ª          unixClose(pFile);¥          return rc;©        }ß      }π      goto open_finished;•    }£  }¶#endif¢  Ÿ$  assert( zPath==0 || zPath[0]=='/' ŸN      || eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL §  );Ÿ9  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);†Æopen_finished:∂  if( rc!=SQLITE_OK ){Ÿ)    sqlite3_free(p->pPreallocatedUnused);£  }¨  return rc;°}††¢/*ŸE** Delete the file at zPath. If the dirSync argument is true, fsync()Ÿ)** the directory after deleting the file.¢*/∂static int unixDelete(ŸK  sqlite3_vfs *NotUsed,     /* VFS containing this as the xDelete method */Ÿ<  const char *zPath,        /* Name of file to be deleted */ŸP  int dirSync               /* If true, fsync() directory after deleting file */¢){µ  int rc = SQLITE_OK;º  UNUSED_PARAMETER(NotUsed);Ÿ.  SimulateIOError(return SQLITE_IOERR_DELETE);æ  if( osUnlink(zPath)==(-1) ){µ    if( errno==ENOENTÆ#if OS_VXWORKSø        || osAccess(zPath,0)!=0¶#endif¶    ){Ÿ%      rc = SQLITE_IOERR_DELETE_NOENT;™    }else{Ÿ>      rc = unixLogError(SQLITE_IOERR_DELETE, "unlink", zPath);•    }Æ    return rc;£  }æ#ifndef SQLITE_DISABLE_DIRSYNCπ  if( (dirSync & 1)!=0 ){´    int fd;Ÿ%    rc = osOpenDirectory(zPath, &fd);∏    if( rc==SQLITE_OK ){ø      if( full_fsync(fd,0,0) ){ŸB        rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, "fsync", zPath);ß      }Ÿ$      robust_close(0, fd, __LINE__);™    }else{Ÿ$      assert( rc==SQLITE_CANTOPEN );µ      rc = SQLITE_OK;•    }£  }¶#endif¨  return rc;°}†¢/*ŸA** Test the existence of or access permissions of file zPath. TheŸ0** test performed depends on the value of flags:¢**Ÿ8**     SQLITE_ACCESS_EXISTS: Return 1 if the file existsŸJ**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.Ÿ@**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.¢**∂** Otherwise return 0.¢*/∂static int unixAccess(ŸF  sqlite3_vfs *NotUsed,   /* The VFS containing this xAccess method */Ÿ;  const char *zPath,      /* Path of the file to examine */ŸN  int flags,              /* What do we want to learn about the zPath file? */Ÿ9  int *pResOut            /* Write result boolean here */¢){º  UNUSED_PARAMETER(NotUsed);Ÿ1  SimulateIOError( return SQLITE_IOERR_ACCESS; );∑  assert( pResOut!=0 );†ŸG  /* The spec says there are three possible values for flags.  But onlyŸ%  ** two of them are actually used */ŸJ  assert( flags==SQLITE_ACCESS_EXISTS || flags==SQLITE_ACCESS_READWRITE );†Ÿ$  if( flags==SQLITE_ACCESS_EXISTS ){¥    struct stat buf;Ÿ9    *pResOut = (0==osStat(zPath, &buf) && buf.st_size>0);®  }else{Ÿ-    *pResOut = osAccess(zPath, W_OK|R_OK)==0;£  }≥  return SQLITE_OK;°}†¢/*¢**¢*/∫static int mkFullPathname(Ÿ2  const char *zPath,              /* Input path */Ÿ5  char *zOut,                     /* Output buffer */ŸE  int nOut                        /* Allocated size of buffer zOut */¢){Ÿ%  int nPath = sqlite3Strlen30(zPath);Ø  int iOff = 0;∂  if( zPath[0]!='/' ){Ÿ$    if( osGetcwd(zOut, nOut-2)==0 ){ŸA      return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);•    }Ÿ!    iOff = sqlite3Strlen30(zOut);∑    zOut[iOff++] = '/';£  }º  if( (iOff+nPath+1)>nOut ){ŸK    /* SQLite assumes that xFullPathname() nul-terminates the output bufferŸ'    ** even if it returns an error.  */∂    zOut[iOff] = '\0';Ÿ     return SQLITE_CANTOPEN_BKPT;£  }Ÿ8  sqlite3_snprintf(nOut-iOff, &zOut[iOff], "%s", zPath);≥  return SQLITE_OK;°}†¢/*ŸC** Turn a relative pathname into a full pathname. The relative pathŸC** is stored as a nul-terminated string in the buffer pointed to by™** zPath. ¢**ŸD** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes ŸB** (in this case, MAX_PATHNAME bytes). The full-path is written toŸ ** this buffer before returning.¢*/ºstatic int unixFullPathname(Ÿ;  sqlite3_vfs *pVfs,            /* Pointer to vfs object */ŸB  const char *zPath,            /* Possibly relative input path */ŸD  int nOut,                     /* Size of output buffer in bytes */Ÿ3  char *zOut                    /* Output buffer */¢){Ÿ3#if !defined(HAVE_READLINK) || !defined(HAVE_LSTAT)Ÿ+  return mkFullPathname(zPath, zOut, nOut);•#elseµ  int rc = SQLITE_OK;¨  int nByte;ŸN  int nLink = 1;                /* Number of symbolic links followed so far */ŸK  const char *zIn = zPath;      /* Input path for each iteration of loop */±  char *zDel = 0;†Ÿ+  assert( pVfs->mxPathname==MAX_PATHNAME );π  UNUSED_PARAMETER(pVfs);†ŸC  /* It's odd to simulate an io-error here, but really this is justŸG  ** using the io-error infrastructure to test that SQLite handles thisŸD  ** function failing. This function could fail if, for example, theŸ1  ** current working directory has been unlinked.§  */Ÿ)  SimulateIOError( return SQLITE_ERROR );†¶  do {†ŸK    /* Call stat() on path zIn. Set bLink to true if the path is a symbolicŸ$    ** link, or false otherwise.  */≤    int bLink = 0;¥    struct stat buf;Ÿ     if( osLstat(zIn, &buf)!=0 ){∫      if( errno!=ENOENT ){Ÿ>        rc = unixLogError(SQLITE_CANTOPEN_BKPT, "lstat", zIn);ß      }™    }else{Ÿ#      bLink = S_ISLNK(buf.st_mode);•    }†∞    if( bLink ){¥      if( zDel==0 ){Ÿ$        zDel = sqlite3_malloc(nOut);Ÿ-        if( zDel==0 ) rc = SQLITE_NOMEM_BKPT;Ÿ.      }else if( ++nLink>SQLITE_MAX_SYMLINKS ){Ÿ"        rc = SQLITE_CANTOPEN_BKPT;ß      }†∫      if( rc==SQLITE_OK ){Ÿ.        nByte = osReadlink(zIn, zDel, nOut-1);∂        if( nByte<0 ){ŸC          rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);Æ        }else{Ω          if( zDel[0]!='/' ){≤            int n;ŸE            for(n = sqlite3Strlen30(zIn); n>0 && zIn[n-1]!='/'; n--);Ÿ!            if( nByte+n+1>nOut ){Ÿ(              rc = SQLITE_CANTOPEN_BKPT;≤            }else{Ÿ/              memmove(&zDel[n], zDel, nByte+1);Ÿ#              memcpy(zDel, zIn, n);π              nByte += n;≠            }´          }Ω          zDel[nByte] = '\0';©        }ß      }†±      zIn = zDel;•    }†Ÿ8    assert( rc!=SQLITE_OK || zIn!=zOut || zIn[0]=='/' );Ÿ%    if( rc==SQLITE_OK && zIn!=zOut ){Ÿ+      rc = mkFullPathname(zIn, zOut, nOut);•    }π    if( bLink==0 ) break;Ø    zIn = zOut;∫  }while( rc==SQLITE_OK );†µ  sqlite3_free(zDel);¨  return rc;Ÿ*#endif   /* HAVE_READLINK && HAVE_LSTAT */°}††Ÿ"#ifndef SQLITE_OMIT_LOAD_EXTENSION¢/*Ÿ@** Interfaces for opening a shared library, finding entry pointsŸ=** within the shared library, and closing the shared library.¢*/≤#include <dlfcn.h>ŸEstatic void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){º  UNUSED_PARAMETER(NotUsed);Ÿ3  return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);°}†¢/*ŸH** SQLite calls this function immediately after a call to unixDlSym() orŸH** unixDlOpen() fails (returns a null pointer). If a more detailed errorŸF** message is available, it is written to zBufOut. If no error messageŸE** is available, zBufOut is left unmodified and SQLite uses a default±** error message.¢*/ŸGstatic void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){≥  const char *zErr;º  UNUSED_PARAMETER(NotUsed);≥  unixEnterMutex();≥  zErr = dlerror();≠  if( zErr ){Ÿ0    sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);£  }≥  unixLeaveMutex();°}ŸOstatic void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){•  /* ŸI  ** GCC with -pedantic-errors says that C90 does not allow a void* to beŸL  ** cast into a pointer to a function.  And yet the library dlsym() routineŸK  ** returns a void* which is really a pointer to a function.  So how do weŸ'  ** use dlsym() with -pedantic-errors?§  **ŸE  ** Variable x below is defined to be a pointer to a function takingŸL  ** parameters void* and const char* and returning a pointer to a function.ŸG  ** We initialize x by assigning it a pointer to the dlsym() function.ŸG  ** (That assignment requires a cast.)  Then we call the function that≥  ** x points to.  §  **ŸG  ** This work-around is unlikely to work correctly on any system whereŸL  ** you really cannot cast a function pointer into void*.  But then, on theŸJ  ** other hand, dlsym() will not work on such a system either, so we haveæ  ** not really lost anything.§  */Ÿ(  void (*(*x)(void*,const char*))(void);º  UNUSED_PARAMETER(NotUsed);Ÿ1  x = (void(*(*)(void*,const char*))(void))dlsym;∑  return (*x)(p, zSym);°}Ÿ=static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){º  UNUSED_PARAMETER(NotUsed);≥  dlclose(pHandle);°}Ÿ5#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */∑  #define unixDlOpen  0∑  #define unixDlError 0∑  #define unixDlSym   0∑  #define unixDlClose 0¶#endif†¢/*Ÿ?** Write nBuf bytes of random data to the supplied buffer zBuf.¢*/ŸFstatic int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){º  UNUSED_PARAMETER(NotUsed);Ÿ5  assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int)));†ŸB  /* We have to initialize zBuf to prevent valgrind from reportingŸE  ** errors.  The reports issued by valgrind are incorrect - we wouldŸA  ** prefer that the randomness be increased by making use of theŸD  ** uninitialized space in zBuf - but valgrind errors tend to worryŸG  ** some users.  Rather than argue, it seems easier just to initializeŸM  ** the whole array and silence valgrind, even if that means less randomness∏  ** in the random seed.§  **ŸH  ** When testing, initializing zBuf[] to zero is all we do.  That meansŸH  ** that we always use the same random number sequence.  This makes the∂  ** tests repeatable.§  */∏  memset(zBuf, 0, nBuf);Ÿ   randomnessPid = osGetpid(0);  Ÿ=#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)£  {∞    int fd, got;Ÿ2    fd = robust_open("/dev/urandom", O_RDONLY, 0);Ø    if( fd<0 ){Ø      time_t t;Ø      time(&t);Ÿ"      memcpy(zBuf, &t, sizeof(t));ŸF      memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));Ÿ>      assert( sizeof(t)+sizeof(randomnessPid)<=(size_t)nBuf );Ÿ/      nBuf = sizeof(t) + sizeof(randomnessPid);™    }else{ŸH      do{ got = osRead(fd, zBuf, nBuf); }while( got<0 && errno==EINTR );Ÿ$      robust_close(0, fd, __LINE__);•    }£  }¶#endifÆ  return nBuf;°}††¢/*Ÿ>** Sleep for a little while.  Return the amount of time slept.Ÿ?** The argument is the number of microseconds we want to sleep.ŸC** The return value is the number of microseconds of sleep actuallyŸA** requested from the underlying operating system, a number whichŸ?** might be greater than or equal to the argument, but not lessµ** than the argument.¢*/Ÿ=static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){Æ#if OS_VXWORKSµ  struct timespec sp;†Ÿ%  sp.tv_sec = microseconds / 1000000;Ÿ/  sp.tv_nsec = (microseconds % 1000000) * 1000;∑  nanosleep(&sp, NULL);º  UNUSED_PARAMETER(NotUsed);∂  return microseconds;Ÿ)#elif defined(HAVE_USLEEP) && HAVE_USLEEP∑  usleep(microseconds);º  UNUSED_PARAMETER(NotUsed);∂  return microseconds;•#elseŸ.  int seconds = (microseconds+999999)/1000000;±  sleep(seconds);º  UNUSED_PARAMETER(NotUsed);π  return seconds*1000000;¶#endif°}†¢/*ŸH** The following variable, if set to a non-zero value, is interpreted asŸD** the number of seconds since 1970 and is used to set the result ofŸ)** sqlite3OsCurrentTime() during testing.¢*/≤#ifdef SQLITE_TESTŸWSQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */¶#endif†¢/*ŸL** Find the current time (in Universal Coordinated Time).  Write into *piNowŸI** the current time and date as a Julian Day number times 86_400_000.  InŸM** other words, write into *piNow the number of milliseconds since the JulianŸG** epoch of noon in Greenwich on November 24, 4714 B.C according to theŸ ** proleptic Gregorian calendar.¢**ŸK** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date ≥** cannot be found.¢*/ŸLstatic int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){ŸI  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;µ  int rc = SQLITE_OK;∂#if defined(NO_GETTOD)´  time_t t;´  time(&t);Ÿ/  *piNow = ((sqlite3_int64)t)*1000 + unixEpoch;∞#elif OS_VXWORKS∑  struct timespec sNow;Ÿ'  clock_gettime(CLOCK_REALTIME, &sNow);ŸN  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_nsec/1000000;•#else∂  struct timeval sNow;ŸH  (void)gettimeofday(&sNow, 0);  /* Cannot fail given valid arguments */ŸK  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;¶#endif†≤#ifdef SQLITE_TESTΩ  if( sqlite3_current_time ){ŸB    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;£  }¶#endifº  UNUSED_PARAMETER(NotUsed);¨  return rc;°}†æ#ifndef SQLITE_OMIT_DEPRECATED¢/*ŸD** Find the current time (in Universal Coordinated Time).  Write theŸ?** current time and date as a Julian Day number into *prNow andŸ<** return 0.  Return 1 if the time and date cannot be found.¢*/Ÿ@static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){∂  sqlite3_int64 i = 0;©  int rc;º  UNUSED_PARAMETER(NotUsed);Ÿ#  rc = unixCurrentTimeInt64(0, &i);∏  *prNow = i/86400000.0;¨  return rc;°}•#else∫# define unixCurrentTime 0¶#endif†¢/*Ÿ<** The xGetLastError() method is designed to return a betterŸA** low-level error message when operating-system problems come upŸF** during SQLite operation.  Only the integer return code is currently®** used.¢*/ŸPstatic int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){º  UNUSED_PARAMETER(NotUsed);Ω  UNUSED_PARAMETER(NotUsed2);Ω  UNUSED_PARAMETER(NotUsed3);Ø  return errno;°}††¢/*ŸO************************ End of sqlite3_vfs methods ***************************ŸO******************************************************************************/†ŸO/******************************************************************************ŸO************************** Begin Proxy Locking ********************************¢**ŸG** Proxy locking is a "uber-locking-method" in this sense:  It uses theŸE** other locking methods on secondary lock files.  Proxy locking is aŸG** meta-layer over top of the primitive locking implemented above.  ForŸI** this reason, the division that implements of proxy locking is deferredŸH** until late in the file (here) after all of the other I/O methods haveŸE** been defined - so that the primitive locking methods are availableŸ@** as services to help with the implementation of proxy locking.¢**§****¢**ŸD** The default locking schemes in SQLite use byte-range locks on theŸJ** database file to coordinate safe, concurrent access by multiple readersŸI** and writers [http://sqlite.org/lockingv3.html].  The five file lockingŸJ** states (UNLOCKED, PENDING, SHARED, RESERVED, EXCLUSIVE) are implementedŸG** as POSIX read & write locks over fixed set of locations (via fsctl),ŸI** on AFP and SMB only exclusive byte-range locks are available via fsctlŸK** with _IOWR('z', 23, struct ByteRangeLockPB2) to track the same 5 states.ŸH** To simulate a F_RDLCK on the shared range, on AFP a randomly selectedŸE** address in the shared range is taken for a SHARED lock, the entireŸ0** shared range is taken for an EXCLUSIVE lock):¢**Ÿ&**      PENDING_BYTE        0x40000000Ÿ&**      RESERVED_BYTE       0x40000001Ÿ4**      SHARED_RANGE        0x40000002 -> 0x40000200¢**ŸD** This works well on the local file system, but shows a nearly 100xŸF** slowdown in read performance on AFP because the AFP client disablesŸG** the read cache when byte-range locks are present.  Enabling the readŸF** cache exposes a cache coherency problem that is present on all OS XŸ@** supported network file systems.  NFS and AFP both observe theŸ7** close-to-open semantics for ensuring cache coherencyŸC** [http://nfs.sourceforge.net/#faq_a8], which does not effectivelyŸF** address the requirements for concurrent database access by multiple∂** readers and writersŸI** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].¢**ŸL** To address the performance and cache coherency issues, proxy file lockingŸH** changes the way database access is controlled by limiting access to aŸG** single host at a time and moving file locks off of the database fileŸ4** and onto a proxy file on the local file system.  ¢**¢**¥** Using proxy locks¥** -----------------¢**©** C APIs¢**ŸD**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_SET_LOCKPROXYFILE,Ÿ2**                       <proxy_path> | ":auto:");ŸD**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_GET_LOCKPROXYFILE,Ÿ(**                       &<proxy_path>);¢**¢**Æ** SQL pragmas¢**Ÿ;**  PRAGMA [database.]lock_proxy_file=<proxy_path> | :auto:Ÿ%**  PRAGMA [database.]lock_proxy_file¢**ŸJ** Specifying ":auto:" means that if there is a conch file with a matchingŸJ** host ID in it, the proxy path in the conch file will be used, otherwiseŸ,** a proxy path based on the user's temp dirŸC** (via confstr(_CS_DARWIN_USER_TEMP_DIR,...)) will be used and theŸD** actual proxy file name is generated from the name and path of theø** database file.  For example:¢**Ÿ.**       For database path "/Users/me/foo.db" ŸN**       The lock path will be "<tmpdir>/sqliteplocks/_Users_me_foo.db:auto:")¢**ŸH** Once a lock proxy is configured for a database connection, it can notŸG** be removed, however it may be switched to a different proxy path viaŸG** the above APIs (assuming the conch file is not being held by anotherª** connection or process). ¢**¢**∫** How proxy locking works∫** -----------------------¢**ŸD** Proxy file locking relies primarily on two new supporting files: ¢**ŸH**   *  conch file to limit access to the database file to a single host±**      at a time¢**ŸD**   *  proxy file to act as a proxy for the advisory locks normallyΩ**      taken on the database¢**ŸK** The conch file - to use a proxy file, sqlite must first "hold the conch"ŸG** by taking an sqlite-style shared lock on the conch file, reading theŸH** contents and comparing the host's unique host ID (see below) and lockŸH** proxy path against the values stored in the conch.  The conch file isŸF** stored in the same directory as the database file and the file nameŸH** is patterned after the database file name as ".<databasename>-conch".ŸE** If the conch file does not exist, or its contents do not match theŸH** host ID and/or proxy path, then the lock is escalated to an exclusiveŸI** lock and the conch file contents is updated with the host ID and proxyŸH** path and the lock is downgraded to a shared lock again.  If the conchŸF** is held by another process (with a shared lock), the exclusive lockŸ)** will fail and SQLITE_BUSY is returned.¢**ŸG** The proxy file - a single-byte file used for all advisory file locksŸF** normally taken on the database file.   This allows for safe sharingŸD** of the database file for multiple readers and writers on the sameŸG** host (the conch ensures that they all use the same local lock file).¢**ŸG** Requesting the lock proxy does not immediately take the conch, it isŸE** only taken when the first request to lock database file is made.  ŸH** This matches the semantics of the traditional locking behavior, whereŸF** opening a connection to a database file does not take a lock on it.ŸD** The shared lock and an open file descriptor are maintained until Ÿ-** the connection to the database is closed. ¢**ŸG** The proxy file and the lock file are never deleted so they only needŸ.** to be created the first time they are used.¢**∏** Configuration options∏** ---------------------¢**ø**  SQLITE_PREFER_PROXY_LOCKING¢**Ÿ>**       Database files accessed on non-local file systems areŸC**       automatically configured for proxy locking, lock files areŸ4**       named automatically using the same logic asŸ(**       PRAGMA lock_proxy_file=":auto:"¶**    ∂**  SQLITE_PROXY_DEBUG¢**ŸB**       Enables the logging of error messages during host id fileø**       retrieval and creation¢**∞**  LOCKPROXYDIR¢**ŸG**       Overrides the default directory used for lock proxy files thatŸ9**       are named automatically via the ":auto:" setting¢**Ÿ'**  SQLITE_DEFAULT_PROXYDIR_PERMISSIONS¢**ŸE**       Permissions to use when creating a directory for storing theŸB**       lock proxy files, only used when LOCKPROXYDIR is not set.¶**    ¶**    ŸF** As mentioned above, when compiled with SQLITE_PREFER_PROXY_LOCKING,ŸH** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 willŸG** force proxy locking to be used for every database file opened, and 0ŸE** will force automatic proxy locking to be disabled for all databaseŸI** files (explicitly calling the SQLITE_FCNTL_SET_LOCKPROXYFILE pragma orŸJ** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).¢*/†¢/*Ÿ-** Proxy locking is only available on MacOSX ¢*/Ÿ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE†¢/*ŸK** The proxyLockingContext has the path and file structures for the remote æ** and local proxy files in it¢*/Ÿ7typedef struct proxyLockingContext proxyLockingContext;ºstruct proxyLockingContext {Ÿ4  unixFile *conchFile;         /* Open conch file */Ÿ;  char *conchFilePath;         /* Name of the conch file */Ÿ9  unixFile *lockProxy;         /* Open proxy lock file */Ÿ@  char *lockProxyPath;         /* Name of the proxy lock file */Ÿ:  char *dbPath;                /* Name of the open file */ŸK  int conchHeld;               /* 1 if the conch is held, -1 if lockless */ŸD  int nFails;                  /* Number of conch taking failures */ŸP  void *oldLockingContext;     /* Original lockingcontext to restore on close */ŸP  sqlite3_io_methods const *pOldMethod;     /* Original I/O methods for close */¢};†£/* ŸN** The proxy lock file path for the database at dbPath is written into lPath, ŸN** which must point to valid, writable memory large enough for a maxLen lengthÆ** file path. ¢*/ŸLstatic int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){™  int len;¨  int dbLen;®  int i;†≥#ifdef LOCKPROXYDIRŸ-  len = strlcpy(lPath, LOCKPROXYDIR, maxLen);•#elseŸ # ifdef _CS_DARWIN_USER_TEMP_DIR£  {Ÿ<    if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){Ÿ:      OSTRACE(("GETLOCKPATH  failed %s errno=%d pid=%d\n",Ÿ+               lPath, errno, osGetpid(0)));ø      return SQLITE_IOERR_LOCK;•    }Ÿ5    len = strlcat(lPath, "sqliteplocks", maxLen);    £  }¶# elseŸ(  len = strlcpy(lPath, "/tmp/", maxLen);ß# endif¶#endif†∫  if( lPath[len-1]!='/' ){Ÿ&    len = strlcat(lPath, "/", maxLen);£  }¢  Ÿ4  /* transform the db path to a unique cache name */æ  dbLen = (int)strlen(dbPath);Ÿ3  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){∑    char c = dbPath[i];Ÿ"    lPath[i+len] = (c=='/')?'_':c;£  }¥  lPath[i+len]='\0';Ÿ#  strlcat(lPath, ":auto:", maxLen);ŸL  OSTRACE(("GETLOCKPATH  proxy lock path=%s pid=%d\n", lPath, osGetpid(0)));≥  return SQLITE_OK;°}†£/* ŸA ** Creates the lock file and any missing directories in lockPath£ */Ÿ5static int proxyCreateLockPath(const char *lockPath){≠  int i, len;∑  char buf[MAXPATHLEN];∞  int start = 0;¢  π  assert(lockPath!=NULL);Ÿ6  /* try to create all the intermediate directories */æ  len = (int)strlen(lockPath);∑  buf[0] = lockPath[0];π  for( i=1; i<len; i++ ){Ÿ0    if( lockPath[i] == '/' && (i - start > 0) ){Ÿ8      /* only mkdir if leaf dir != "." or "/" or ".." */ŸN      if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/') ŸG         || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){¥        buf[i]='\0';Ÿ@        if( osMkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS) ){∏          int err=errno;Ω          if( err!=EEXIST ) {Ÿ;            OSTRACE(("CREATELOCKPATH  FAILED creating %s, "Ÿ8                     "'%s' proxy lock path=%s pid=%d\n",ŸA                     buf, strerror(err), lockPath, osGetpid(0)));∑            return err;´          }©        }ß      }∞      start=i+1;•    }π    buf[i] = lockPath[i];£  }ŸP  OSTRACE(("CREATELOCKPATH  proxy lock path=%s pid=%d\n",lockPath,osGetpid(0)));´  return 0;°}†¢/*ŸC** Create a new VFS file descriptor (stored in memory obtained fromŸI** sqlite3_malloc) and open the file named "path" in the file descriptor.¢**ŸE** The caller is responsible not only for closing the file descriptorŸG** but also for freeing the memory associated with the file descriptor.¢*/østatic int proxyCreateUnixFile(Ÿ<    const char *path,        /* path for the new unixFile */ŸG    unixFile **ppFile,       /* unixFile created and returned by ref */ŸK    int islockfile           /* if non zero missing dirs will be created */£) {Æ  int fd = -1;±  unixFile *pNew;µ  int rc = SQLITE_OK;Ÿ#  int openFlags = O_RDWR | O_CREAT;∑  sqlite3_vfs dummyVfs;±  int terrno = 0;ø  UnixUnusedFd *pUnused = NULL;†Ÿ)  /* 1. first try to open/create the fileŸH  ** 2. if that fails, and this is a lock file (not-conch), try creatingŸ/  ** the parent directories and then try again.Ÿ5  ** 3. if that fails, try to open the file read-onlyŸH  ** otherwise return BUSY (if lock file) or CANTOPEN for the conch file§  */Ÿ,  pUnused = findReusableFd(path, openFlags);∞  if( pUnused ){µ    fd = pUnused->fd;®  }else{Ÿ1    pUnused = sqlite3_malloc64(sizeof(*pUnused));≥    if( !pUnused ){ø      return SQLITE_NOMEM_BKPT;•    }£  }≠  if( fd<0 ){Ÿ)    fd = robust_open(path, openFlags, 0);≥    terrno = errno;Ÿ.    if( fd<0 && errno==ENOENT && islockfile ){Ÿ3      if( proxyCreateLockPath(path) == SQLITE_OK ){Ÿ-        fd = robust_open(path, openFlags, 0);ß      }•    }£  }≠  if( fd<0 ){π    openFlags = O_RDONLY;Ÿ)    fd = robust_open(path, openFlags, 0);≥    terrno = errno;£  }≠  if( fd<0 ){µ    if( islockfile ){π      return SQLITE_BUSY;•    }µ    switch (terrno) {≤      case EACCES:ª        return SQLITE_PERM;∞      case EIO: ŸC        return SQLITE_IOERR_LOCK; /* even though it is the conch */Æ      default:Ÿ$        return SQLITE_CANTOPEN_BKPT;•    }£  }¢  Ÿ5  pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));≥  if( pNew==NULL ){ª    rc = SQLITE_NOMEM_BKPT;∫    goto end_create_proxy;£  }Ÿ$  memset(pNew, 0, sizeof(unixFile));æ  pNew->openFlags = openFlags;Ÿ)  memset(&dummyVfs, 0, sizeof(dummyVfs));Ÿ/  dummyVfs.pAppData = (void*)&autolockIoFinder;ª  dummyVfs.zName = "dummy";≥  pUnused->fd = fd;Ω  pUnused->flags = openFlags;Ÿ&  pNew->pPreallocatedUnused = pUnused;¢  ŸC  rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file*)pNew, path, 0);∂  if( rc==SQLITE_OK ){≥    *ppFile = pNew;µ    return SQLITE_OK;£  }µend_create_proxy:    Ÿ#  robust_close(pNew, fd, __LINE__);µ  sqlite3_free(pNew);∏  sqlite3_free(pUnused);¨  return rc;°}†≤#ifdef SQLITE_TESTŸB/* simulate multiple hosts by creating unique hostid file paths */Ÿ&SQLITE_API int sqlite3_hostid_num = 0;¶#endif†Ÿ>#define PROXY_HOSTIDLEN    16  /* conch file host id length */†∑#ifdef HAVE_GETHOSTUUIDŸ9/* Not always defined in the headers as it ought to be */Ÿ?extern int gethostuuid(uuid_t id, const struct timespec *wait);¶#endif†ŸL/* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN º** bytes of writable memory.¢*/Ÿ?static int proxyGetHostID(unsigned char *pHostID, int *pError){Ÿ,  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));Ÿ&  memset(pHostID, 0, PROXY_HOSTIDLEN);∑#ifdef HAVE_GETHOSTUUID£  {Ÿ9    struct timespec timeout = {1, 0}; /* 1 sec timeout */Ÿ)    if( gethostuuid(pHostID, &timeout) ){∂      int err = errno;≥      if( pError ){∂        *pError = err;ß      }∫      return SQLITE_IOERR;•    }£  }•#elseª  UNUSED_PARAMETER(pError);¶#endif≤#ifdef SQLITE_TESTŸD  /* simulate multiple hosts by creating unique hostid file paths */ø  if( sqlite3_hostid_num != 0){ŸH    pHostID[0] = (char)(pHostID[0] + (char)(sqlite3_hostid_num & 0xFF));£  }¶#endif¢  ≥  return SQLITE_OK;°}†ŸA/* The conch file contains the header, host id and lock file path£ */ŸI#define PROXY_CONCHVERSION 2   /* 1-byte header, 16-byte host id, path */Ÿ=#define PROXY_HEADERLEN    1   /* conch file header length */Ÿ<#define PROXY_PATHINDEX    (PROXY_HEADERLEN+PROXY_HOSTIDLEN)ŸG#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)†£/* ŸN** Takes an open conch file, copies the contents to a new path and then moves ŸH** it back.  The newly created file's file descriptor is assigned to theŸJ** conch file structure and finally the original conch file descriptor is Ÿ'** closed.  Returns zero if successful.¢*/ŸAstatic int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){ŸL  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; Ÿ(  unixFile *conchFile = pCtx->conchFile;π  char tPath[MAXPATHLEN];æ  char buf[PROXY_MAXCONCHLEN];Ÿ$  char *cPath = pCtx->conchFilePath;µ  size_t readLen = 0;µ  size_t pathLen = 0;∑  char errmsg[64] = "";Æ  int fd = -1;Æ  int rc = -1;Ω  UNUSED_PARAMETER(myHostID);†ŸH  /* create a new path by replace the trailing '-conch' with '-break' */Ÿ.  pathLen = strlcpy(tPath, cPath, MAXPATHLEN);Ÿ)  if( pathLen>MAXPATHLEN || pathLen<6 || Ÿ5     (strlcpy(&tPath[pathLen-5], "break", 6) != 5) ){ŸO    sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);∑    goto end_breaklock;£  }æ  /* read the conch content */Ÿ=  readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);Ÿ   if( readLen<PROXY_PATHINDEX ){ŸO    sqlite3_snprintf(sizeof(errmsg),errmsg,"read error (len %d)",(int)readLen);∑    goto end_breaklock;£  }Ÿ0  /* write it out to the temporary break file */Ÿ6  fd = robust_open(tPath, (O_RDWR|O_CREAT|O_EXCL), 0);≠  if( fd<0 ){ŸJ    sqlite3_snprintf(sizeof(errmsg), errmsg, "create failed (%d)", errno);∑    goto end_breaklock;£  }Ÿ:  if( osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen ){ŸI    sqlite3_snprintf(sizeof(errmsg), errmsg, "write failed (%d)", errno);∑    goto end_breaklock;£  }Ω  if( rename(tPath, cPath) ){ŸJ    sqlite3_snprintf(sizeof(errmsg), errmsg, "rename failed (%d)", errno);∑    goto end_breaklock;£  }©  rc = 0;Ÿ5  fprintf(stderr, "broke stale lock on %s\n", cPath);Ÿ.  robust_close(pFile, conchFile->h, __LINE__);¥  conchFile->h = fd;Ÿ*  conchFile->openFlags = O_RDWR | O_CREAT;†Æend_breaklock:´  if( rc ){∞    if( fd>=0 ){∂      osUnlink(tPath);Ÿ(      robust_close(pFile, fd, __LINE__);•    }ŸM    fprintf(stderr, "failed to break stale lock on %s, %s\n", cPath, errmsg);£  }¨  return rc;°}†ŸK/* Take the requested lock on the conch file and break a stale lock if the ≥** host id matches.¢*/ŸJstatic int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){ŸL  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; Ÿ(  unixFile *conchFile = pCtx->conchFile;µ  int rc = SQLITE_OK;±  int nTries = 0;ø  struct timespec conchModTime;¢  Ÿ1  memset(&conchModTime, 0, sizeof(conchModTime));¶  do {ŸG    rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);Æ    nTries ++;∫    if( rc==SQLITE_BUSY ){Ÿ#      /* If the lock failed (busy):ŸJ       * 1st try: get the mod time of the conch, wait 0.5s and try again. ŸM       * 2nd try: fail if the mod time changed or host id is different, wait Ÿ'       *           10 sec and try againŸA       * 3rd try: break the lock unless the mod time has changed.©       */∂      struct stat buf;Ÿ(      if( osFstat(conchFile->h, &buf) ){Ÿ%        storeLastErrno(pFile, errno);Ÿ!        return SQLITE_IOERR_LOCK;ß      }¶      ∂      if( nTries==1 ){Ÿ(        conchModTime = buf.st_mtimespec;Ÿ@        usleep(500000); /* wait 0.5 sec and try the lock again*/≥        continue;  ß      }†π      assert( nTries>1 );Ÿ<      if( conchModTime.tv_sec != buf.st_mtimespec.tv_sec || Ÿ<         conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec ){ª        return SQLITE_BUSY;ß      }¶      ∏      if( nTries==2 ){  Ÿ%        char tBuf[PROXY_MAXCONCHLEN];ŸD        int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);¥        if( len<0 ){Ÿ'          storeLastErrno(pFile, errno);Ÿ#          return SQLITE_IOERR_LOCK;©        }ŸF        if( len>PROXY_PATHINDEX && tBuf[0]==(char)PROXY_CONCHVERSION){ŸA          /* don't break the lock if the host id doesn't match */ŸM          if( 0!=memcmp(&tBuf[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN) ){ø            return SQLITE_BUSY;´          }Æ        }else{ŸH          /* don't break the lock on short read or a version mismatch */Ω          return SQLITE_BUSY;©        }ŸB        usleep(10000000); /* wait 10 sec and try the lock again */≤        continue; ß      }¶      ∫      assert( nTries==3 );Ÿ4      if( 0==proxyBreakConchLock(pFile, myHostID) ){∑        rc = SQLITE_OK;Ÿ'        if( lockType==EXCLUSIVE_LOCK ){ŸP          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);©        }≤        if( !rc ){ŸM          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);©        }ß      }•    }Ÿ)  } while( rc==SQLITE_BUSY && nTries<3 );¢  ¨  return rc;°}†ŸK/* Takes the conch by taking a shared lock and read the contents conch, if ŸL** lockPath is non-NULL, the host ID and lock file path must match.  A NULL ŸJ** lockPath means that the lockPath in the conch file will be used if the ŸF** host IDs match, or a new lock path will be generated automatically Ÿ!** and written to the conch file.¢*/Ÿ+static int proxyTakeConch(unixFile *pFile){ŸL  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; ¢  ª  if( pCtx->conchHeld!=0 ){µ    return SQLITE_OK;®  }else{Ÿ*    unixFile *conchFile = pCtx->conchFile;¥    uuid_t myHostID;≥    int pError = 0;Ÿ$    char readBuf[PROXY_MAXCONCHLEN];æ    char lockPath[MAXPATHLEN];æ    char *tempLockPath = NULL;∑    int rc = SQLITE_OK;∏    int createConch = 0;∏    int hostIdMatch = 0;¥    int readLen = 0;ª    int tryOldLockPath = 0;Ω    int forceNewLockPath = 0;§    Ÿ;    OSTRACE(("TAKECONCH  %d for %s pid=%d\n", conchFile->h,ŸD             (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),ª             osGetpid(0)));†Ÿ+    rc = proxyGetHostID(myHostID, &pError);Ÿ"    if( (rc&0xff)==SQLITE_IOERR ){Ÿ$      storeLastErrno(pFile, pError);π      goto end_takeconch;•    }Ÿ6    rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);∏    if( rc!=SQLITE_OK ){π      goto end_takeconch;•    }Ÿ&    /* read the existing conch file */ŸO    readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);¥    if( readLen<0 ){Ÿ3      /* I/O error: lastErrno set by seekAndRead */Ÿ2      storeLastErrno(pFile, conchFile->lastErrno);Ω      rc = SQLITE_IOERR_READ;π      goto end_takeconch;Ÿ<    }else if( readLen<=(PROXY_HEADERLEN+PROXY_HOSTIDLEN) || Ÿ4             readBuf[0]!=(char)PROXY_CONCHVERSION ){ŸO      /* a short read or version format mismatch means we need to create a new µ      ** conch file. ®      */∂      createConch = 1;•    }ŸK    /* if the host id matches and the lock path already exists in the conchŸJ    ** we'll try to use the path there, if we can't open that path, we'll Ÿ,    ** retry with a new auto-generated path ¶    */ŸI    do { /* in case we need to try again for an :auto: named lock file */†Ÿ.      if( !createConch && !forceNewLockPath ){ŸC        hostIdMatch = !memcmp(&readBuf[PROXY_HEADERLEN], myHostID, Ÿ3                                  PROXY_HOSTIDLEN);Ÿ8        /* if the conch has data compare the contents */Ÿ#        if( !pCtx->lockProxyPath ){ŸM          /* for auto-named local lock file, just check the host ID and we'llŸB           ** use the local lock file path that's already in there≠           */º          if( hostIdMatch ){Ÿ9            size_t pathLen = (readLen - PROXY_PATHINDEX);¨            Ÿ&            if( pathLen>=MAXPATHLEN ){Ÿ#              pathLen=MAXPATHLEN-1;≠            }ŸA            memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);Ÿ"            lockPath[pathLen] = 0;Ÿ$            tempLockPath = lockPath;ø            tryOldLockPath = 1;ŸF            /* create a copy of the lock path if the conch is taken */ø            goto end_takeconch;´          }Ω        }else if( hostIdMatchŸJ               && !strncmp(pCtx->lockProxyPath, &readBuf[PROXY_PATHINDEX],Ÿ3                           readLen-PROXY_PATHINDEX)™        ){Ÿ.          /* conch host and lock path match */æ          goto end_takeconch; ©        }ß      }¶      ŸK      /* if the conch isn't writable and doesn't match, we can't take it */Ÿ/      if( (conchFile->openFlags&O_RDWR) == 0 ){π        rc = SQLITE_BUSY;ª        goto end_takeconch;ß      }¶      ŸH      /* either the conch didn't match or we need to create a new one */Ÿ!      if( !pCtx->lockProxyPath ){Ÿ=        proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);Ÿ         tempLockPath = lockPath;ŸI        /* create a copy of the lock path _only_ if the conch is taken */ß      }¶      ŸI      /* update conch with host and path (this will fail if other processŸH      ** has a shared lock already), if the host id matches, use the bigØ      ** stick.®      */Ÿ"      futimes(conchFile->h, NULL);Ÿ(      if( hostIdMatch && !createConch ){Ÿ@        if( conchFile->pInode && conchFile->pInode->nShared>1 ){ŸK          /* We are trying for an exclusive lock but another thread in thisŸ=           ** same process is still holding a shared lock. */ª          rc = SQLITE_BUSY;∫        } else {          Ÿ?          rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);©        }¨      }else{Ÿ=        rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);ß      }∫      if( rc==SQLITE_OK ){Ÿ,        char writeBuffer[PROXY_MAXCONCHLEN];∫        int writeSize = 0;®        Ÿ2        writeBuffer[0] = (char)PROXY_CONCHVERSION;ŸI        memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);Ÿ(        if( pCtx->lockProxyPath!=NULL ){ŸE          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath,æ                  MAXPATHLEN);Æ        }else{ŸK          strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);©        }ŸL        writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);Ÿ2        robust_ftruncate(conchFile->h, writeSize);ŸM        rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);Ÿ%        full_fsync(conchFile->h,0,0);ŸN        /* If we created a new conch file (not just updated the contents of a ŸL         ** valid conch file), try to match the permissions of the database ´         */Ÿ+        if( rc==SQLITE_OK && createConch ){∫          struct stat buf;Ÿ,          int err = osFstat(pFile->h, &buf);∑          if( err==0 ){ŸK            mode_t cmode = buf.st_mode&(S_IRUSR|S_IWUSR | S_IRGRP|S_IWGRP |Ÿ9                                        S_IROTH|S_IWOTH);ŸP            /* try to match the database file R/W permissions, ignore failure */∫#ifndef SQLITE_PROXY_DEBUGŸ*            osFchmod(conchFile->h, cmode);•#elseØ            do{Ÿ1              rc = osFchmod(conchFile->h, cmode);Ÿ/            }while( rc==(-1) && errno==EINTR );∏            if( rc!=0 ){ø              int code = errno;Ÿ>              fprintf(stderr, "fchmod %o FAILED with %d %s\n",Ÿ3                      cmode, code, strerror(code));¥            } else {Ÿ<              fprintf(stderr, "fchmod %o SUCCEDED\n",cmode);≠            }∞          }else{Ω            int code = errno;Ÿ<            fprintf(stderr, "STAT FAILED[%d] with %d %s\n", Ÿ/                    err, code, strerror(code));¶#endif´          }©        }ß      }ŸI      conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, SHARED_LOCK);¶      ≤    end_takeconch:Ÿ5      OSTRACE(("TRANSPROXY: CLOSE  %d\n", pFile->h));Ÿ.      if( rc==SQLITE_OK && pFile->openFlags ){Ø        int fd;∫        if( pFile->h>=0 ){Ÿ2          robust_close(pFile, pFile->h, __LINE__);©        }∂        pFile->h = -1;Ÿ<        fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);Ÿ0        OSTRACE(("TRANSPROXY: OPEN  %d\n", fd));¥        if( fd>=0 ){∏          pFile->h = fd;Æ        }else{ŸH          rc=SQLITE_CANTOPEN_BKPT; /* SQLITE_BUSY? proxyTakeConch calledº           during locking */©        }ß      }Ÿ.      if( rc==SQLITE_OK && !pCtx->lockProxy ){ŸG        char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;Ÿ<        rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);ŸB        if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM && tryOldLockPath ){ŸO          /* we couldn't create the proxy lock file with the old lock file pathŸ+           ** so try again via auto-naming ≠           */ø          forceNewLockPath = 1;Ω          tryOldLockPath = 0;ŸK          continue; /* go back to the do {} while start point, try again */©        }ß      }∫      if( rc==SQLITE_OK ){Ÿ@        /* Need to make a copy of path if we extracted the valueŸF         ** from the conch file or the path was allocated on the stack´         */ª        if( tempLockPath ){ŸA          pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);Ÿ%          if( !pCtx->lockProxyPath ){Ÿ#            rc = SQLITE_NOMEM_BKPT;´          }©        }ß      }∫      if( rc==SQLITE_OK ){º        pCtx->conchHeld = 1;®        Ÿ8        if( pCtx->lockProxy->pMethod == &afpIoMethods ){Ÿ$          afpLockingContext *afpCtx;ŸH          afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;Ÿ/          afpCtx->dbPath = pCtx->lockProxyPath;©        }Æ      } else {ŸG        conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);ß      }Ÿ2      OSTRACE(("TAKECONCH  %d %s\n", conchFile->h,Ÿ-               rc==SQLITE_OK?"ok":"failed"));∞      return rc;ŸD    } while (1); /* in case we need to retry the :auto: lock file - ŸO                 ** we should never get here except via the 'continue' call. */£  }°}†¢/*ŸA** If pFile holds a lock on a conch file, then release that lock.¢*/Ÿ.static int proxyReleaseConch(unixFile *pFile){Ÿ:  int rc = SQLITE_OK;         /* Subroutine return code */ŸJ  proxyLockingContext *pCtx;  /* The locking context for the proxy lock */Ÿ:  unixFile *conchFile;        /* Name of the conch file */†Ÿ6  pCtx = (proxyLockingContext *)pFile->lockingContext;æ  conchFile = pCtx->conchFile;Ÿ<  OSTRACE(("RELEASECONCH  %d for %s pid=%d\n", conchFile->h,ŸC           (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"), π           osGetpid(0)));∫  if( pCtx->conchHeld>0 ){ŸH    rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);£  }∂  pCtx->conchHeld = 0;Ÿ1  OSTRACE(("RELEASECONCH  %d %s\n", conchFile->h,Ÿ/           (rc==SQLITE_OK ? "ok" : "failed")));¨  return rc;°}†¢/*ŸI** Given the name of a database file, compute the name of its conch file.ŸG** Store the conch filename in memory obtained from sqlite3_malloc64().ŸG** Make *pConchPath point to the new name.  Return SQLITE_OK on successŸ.** or SQLITE_NOMEM if unable to obtain memory.¢**ŸC** The caller is responsible for ensuring that the allocated memoryΩ** space is eventually freed.¢**ŸB** *pConchPath is set to NULL if a memory allocation error occurs.¢*/ŸEstatic int proxyCreateConchPathname(char *dbPath, char **pConchPath){Ÿ2  int i;                        /* Loop counter */ŸK  int len = (int)strlen(dbPath); /* Length of database filename - dbPath */ŸM  char *conchPath;              /* buffer in which to construct conch name */†ŸE  /* Allocate space for the conch filename and initialize the name toŸ1  ** the name of the original database file. */  Ÿ>  *pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);µ  if( conchPath==0 ){Ω    return SQLITE_NOMEM_BKPT;£  }Ÿ#  memcpy(conchPath, dbPath, len+1);¢  Ÿ4  /* now insert a "." before the last / character */æ  for( i=(len-1); i>=0; i-- ){º    if( conchPath[i]=='/' ){™      i++;¨      break;•    }£  }≥  conchPath[i]='.';≤  while ( i<len ){Ω    conchPath[i+1]=dbPath[i];®    i++;£  }†Ÿ.  /* append the "-conch" suffix to the file */Ÿ'  memcpy(&conchPath[i+1], "-conch", 7);Ÿ,  assert( (int)strlen(conchPath) == len+7 );†≥  return SQLITE_OK;°}††ŸF/* Takes a fully configured proxy locking-style unix file and switchesº** the local lock file path ¢*/ŸCstatic int switchLockProxyPath(unixFile *pFile, const char *path) {ŸJ  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;Ÿ&  char *oldPath = pCtx->lockProxyPath;µ  int rc = SQLITE_OK;†Ÿ"  if( pFile->eFileLock!=NO_LOCK ){∑    return SQLITE_BUSY;•  }  †ŸN  /* nothing to do if the path is NULL, :auto: or matches the existing path */Ÿ:  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ||Ÿ7    (oldPath && !strncmp(oldPath, path, MAXPATHLEN)) ){µ    return SQLITE_OK;®  }else{Ÿ*    unixFile *lockProxy = pCtx->lockProxy;π    pCtx->lockProxy=NULL;∏    pCtx->conchHeld = 0;∫    if( lockProxy!=NULL ){Ÿ?      rc=lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);π      if( rc ) return rc;æ      sqlite3_free(lockProxy);•    }∫    sqlite3_free(oldPath);Ÿ3    pCtx->lockProxyPath = sqlite3DbStrDup(0, path);£  }¢  ¨  return rc;°}†¢/*ŸF** pFile is a file that has been opened by a prior xOpen call.  dbPathŸ?** is a string buffer at least MAXPATHLEN+1 characters in size.¢**ŸE** This routine find the filename associated with pFile and writes itÆ** int dbPath.¢*/ŸDstatic int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){∂#if defined(__APPLE__)Ÿ(  if( pFile->pMethod == &afpIoMethods ){ŸH    /* afp style keeps a reference to the db path in the filePath field ∑    ** of the struct */ŸD    assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );ŸI    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,∏            MAXPATHLEN);®  } else¶#endifŸ,  if( pFile->pMethod == &dotlockIoMethods ){ŸD    /* dot lock style uses the locking context to store the dot lock≥    ** file path */ŸM    int len = strlen((char *)pFile->lockingContext) - strlen(DOTLOCK_SUFFIX);Ÿ;    memcpy(dbPath, (char *)pFile->lockingContext, len + 1);®  }else{ŸL    /* all other styles use the locking context to store the db file path */Ÿ?    assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );Ÿ?    strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);£  }≥  return SQLITE_OK;°}†¢/*ŸJ** Takes an already filled in unix file and alters it so all file locking ŸH** will be performed on the local proxy lock file.  The following fieldsŸI** are preserved in the locking context so that they can be restored and Ÿ8** the unix structure properly cleaned up at close time:¥**  ->lockingContext≠**  ->pMethod¢*/ŸFstatic int proxyTransformUnixFile(unixFile *pFile, const char *path) {º  proxyLockingContext *pCtx;ŸB  char dbPath[MAXPATHLEN+1];       /* Name of the database file */∂  char *lockPath=NULL;µ  int rc = SQLITE_OK;¢  Ÿ"  if( pFile->eFileLock!=NO_LOCK ){∑    return SQLITE_BUSY;£  }Ÿ+  proxyGetDbPathForUnixFile(pFile, dbPath);Ÿ:  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ){≤    lockPath=NULL;®  }else{∫    lockPath=(char *)path;£  }¢  Ÿ6  OSTRACE(("TRANSPROXY  %d for %s pid=%d\n", pFile->h,Ÿ;           (lockPath ? lockPath : ":auto:"), osGetpid(0)));†Ÿ+  pCtx = sqlite3_malloc64( sizeof(*pCtx) );∞  if( pCtx==0 ){Ω    return SQLITE_NOMEM_BKPT;£  }Ÿ!  memset(pCtx, 0, sizeof(*pCtx));†Ÿ>  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);∂  if( rc==SQLITE_OK ){ŸG    rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);ŸB    if( rc==SQLITE_CANTOPEN && ((pFile->openFlags&O_RDWR) == 0) ){ŸM      /* if (a) the open flags are not O_RDWR, (b) the conch isn't there, andŸI      ** (c) the file system is read-only, then enable no-locking access.ŸO      ** Ugh, since O_RDONLY==0x0000 we test for !O_RDWR since unixOpen assertsŸA      ** that openFlags will have only one of O_RDONLY or O_RDWR.®      */ª      struct statfs fsInfo;º      struct stat conchInfo;π      int goLockless = 0;†Ÿ;      if( osStat(pCtx->conchFilePath, &conchInfo) == -1 ) {∏        int err = errno;Ÿ?        if( (err==ENOENT) && (statfs(dbPath, &fsInfo) != -1) ){ŸA          goLockless = (fsInfo.f_flags&MNT_RDONLY) == MNT_RDONLY;©        }ß      }∑      if( goLockless ){Ÿ:        pCtx->conchHeld = -1; /* read only FS/ lockless */∑        rc = SQLITE_OK;ß      }•    }•  }  Ÿ"  if( rc==SQLITE_OK && lockPath ){Ÿ7    pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);£  }†∂  if( rc==SQLITE_OK ){Ÿ.    pCtx->dbPath = sqlite3DbStrDup(0, dbPath);Ω    if( pCtx->dbPath==NULL ){Ω      rc = SQLITE_NOMEM_BKPT;•    }£  }∂  if( rc==SQLITE_OK ){ŸA    /* all memory is allocated, proxys are created and assigned, Ÿ:    ** switch the locking context and pMethod then return.¶    */Ÿ4    pCtx->oldLockingContext = pFile->lockingContext;Ÿ!    pFile->lockingContext = pCtx;Ÿ&    pCtx->pOldMethod = pFile->pMethod;Ÿ%    pFile->pMethod = &proxyIoMethods;®  }else{ª    if( pCtx->conchFile ){ ŸH      pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);Ÿ$      sqlite3_free(pCtx->conchFile);•    }Ÿ*    sqlite3DbFree(0, pCtx->lockProxyPath);Ÿ'    sqlite3_free(pCtx->conchFilePath); ∑    sqlite3_free(pCtx);£  }Ÿ+  OSTRACE(("TRANSPROXY  %d %s\n", pFile->h,Ÿ/           (rc==SQLITE_OK ? "ok" : "failed")));¨  return rc;°}††¢/*ŸF** This routine handles sqlite3_file_control() calls that are specific¥** to proxy locking.¢*/ŸBstatic int proxyFileControl(sqlite3_file *id, int op, void *pArg){Ø  switch( op ){Ÿ*    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {Ÿ&      unixFile *pFile = (unixFile*)id;Ÿ.      if( pFile->pMethod == &proxyIoMethods ){ŸP        proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;æ        proxyTakeConch(pFile);Ÿ"        if( pCtx->lockProxyPath ){Ÿ5          *(const char **)pArg = pCtx->lockProxyPath;Æ        }else{Ÿ5          *(const char **)pArg = ":auto: (not held)";©        }Æ      } else {Ÿ$        *(const char **)pArg = NULL;ß      }∑      return SQLITE_OK;•    }Ÿ*    case SQLITE_FCNTL_SET_LOCKPROXYFILE: {Ÿ&      unixFile *pFile = (unixFile*)id;π      int rc = SQLITE_OK;Ÿ=      int isProxyStyle = (pFile->pMethod == &proxyIoMethods);Ÿ0      if( pArg==NULL || (const char *)pArg==0 ){ª        if( isProxyStyle ){ŸM          /* turn off proxy locking - not supported.  If support is added forŸJ          ** switching proxy locking mode off then it will need to fail ifŸ+          ** the journal mode is WAL mode. ¨          */Ÿ@          rc = SQLITE_ERROR /*SQLITE_PROTOCOL? SQLITE_MISUSE?*/;Æ        }else{Ÿ;          /* turn off proxy locking - already off - NOOP */π          rc = SQLITE_OK;©        }¨      }else{Ÿ3        const char *proxyPath = (const char *)pArg;ª        if( isProxyStyle ){Ÿ&          proxyLockingContext *pCtx = Ÿ8            (proxyLockingContext*)pFile->lockingContext;Ÿ&          if( !strcmp(pArg, ":auto:") Ÿ%           || (pCtx->lockProxyPath &&ŸD               !strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))¨          ){ª            rc = SQLITE_OK;∞          }else{Ÿ7            rc = switchLockProxyPath(pFile, proxyPath);´          }Æ        }else{Ÿ*          /* turn on proxy file locking */Ÿ8          rc = proxyTransformUnixFile(pFile, proxyPath);©        }ß      }∞      return rc;•    }Æ    default: {ŸK      assert( 0 );  /* The call assures that only valid opcodes are sent */•    }£  }∞  /*NOTREACHED*/∂  return SQLITE_ERROR;°}†¢/*ŸL** Within this division (the proxying locking implementation) the proceduresŸG** above this point are all utilities.  The lock-related methods of theŸ1** proxy-locking sqlite3_io_method object follow.¢*/††¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸJ** file by this or any other process. If such a lock is held, set *pResOutŸK** to a non-zero value otherwise *pResOut is set to zero.  The return valueŸG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ŸCstatic int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ!  int rc = proxyTakeConch(pFile);∂  if( rc==SQLITE_OK ){ŸM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;º    if( pCtx->conchHeld>0 ){Ÿ(      unixFile *proxy = pCtx->lockProxy;ŸO      return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);Ÿ*    }else{ /* conchHeld < 0 is lockless */∞      pResOut=0;•    }£  }¨  return rc;°}†¢/*ŸE** Lock the file with the lock specified by parameter eFileLock - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ÿ$** routine to lower a locking level.¢*/Ÿ7static int proxyLock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ!  int rc = proxyTakeConch(pFile);∂  if( rc==SQLITE_OK ){ŸM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;º    if( pCtx->conchHeld>0 ){Ÿ(      unixFile *proxy = pCtx->lockProxy;ŸB      rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);Ÿ*      pFile->eFileLock = proxy->eFileLock;™    }else{Ÿ%      /* conchHeld < 0 is lockless */•    }£  }¨  return rc;°}††¢/*ŸL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢*/Ÿ9static int proxyUnlock(sqlite3_file *id, int eFileLock) {Ÿ"  unixFile *pFile = (unixFile*)id;Ÿ!  int rc = proxyTakeConch(pFile);∂  if( rc==SQLITE_OK ){ŸM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;º    if( pCtx->conchHeld>0 ){Ÿ(      unixFile *proxy = pCtx->lockProxy;ŸD      rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);Ÿ*      pFile->eFileLock = proxy->eFileLock;™    }else{Ÿ%      /* conchHeld < 0 is lockless */•    }£  }¨  return rc;°}†¢/*Ÿ&** Close a file that uses proxy locks.¢*/Ÿ)static int proxyClose(sqlite3_file *id) {≥  if( ALWAYS(id) ){Ÿ$    unixFile *pFile = (unixFile*)id;ŸM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;Ÿ*    unixFile *lockProxy = pCtx->lockProxy;Ÿ*    unixFile *conchFile = pCtx->conchFile;∑    int rc = SQLITE_OK;§    ¥    if( lockProxy ){ŸJ      rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, NO_LOCK);π      if( rc ) return rc;Ÿ@      rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);π      if( rc ) return rc;æ      sqlite3_free(lockProxy);∫      pCtx->lockProxy = 0;•    }¥    if( conchFile ){º      if( pCtx->conchHeld ){Ÿ&        rc = proxyReleaseConch(pFile);ª        if( rc ) return rc;ß      }Ÿ@      rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);π      if( rc ) return rc;æ      sqlite3_free(conchFile);•    }Ÿ*    sqlite3DbFree(0, pCtx->lockProxyPath);Ÿ&    sqlite3_free(pCtx->conchFilePath);Ÿ#    sqlite3DbFree(0, pCtx->dbPath);ŸH    /* restore the original locking context and pMethod then close it */Ÿ4    pFile->lockingContext = pCtx->oldLockingContext;Ÿ&    pFile->pMethod = pCtx->pOldMethod;∑    sqlite3_free(pCtx);Ÿ&    return pFile->pMethod->xClose(id);£  }≥  return SQLITE_OK;°}†††Ÿ>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */¢/*ŸD** The proxy locking style is intended for use with AFP filesystems.ŸG** And since AFP is only supported on MacOSX, the proxy locking is also∏** restricted to MacOSX.£** ¢**ŸO******************* End of the proxy lock implementation **********************ŸO******************************************************************************/†¢/*Ÿ-** Initialize the operating system interface.¢**ŸI** This routine registers all VFS implementations for unix-like operatingŸI** systems.  This routine, and the sqlite3_os_end() routine that follows,ŸG** should be the only routines in this file that are visible from other©** files.¢**ŸD** This routine is called once during SQLite initialization and by aŸF** single thread.  The memory allocation and mutex subsystems have notŸH** necessarily been initialized when this routine is called, and so they∂** should not be used.¢*/Ÿ&SQLITE_API int sqlite3_os_init(void){ •  /* ŸJ  ** The following macro defines an initializer for an sqlite3_vfs object.ŸI  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointerŸK  ** to the "finder" function.  (pAppData is a pointer to a pointer becauseŸK  ** silly C90 rules prohibit a void* from being cast to a function pointerŸL  ** and so we have to go through the intermediate pointer to avoid problemsŸ2  ** when compiling with -pedantic-errors on GCC.)§  **ŸI  ** The FINDER parameter to this macro is the name of the pointer to theŸC  ** finder-function.  The finder-function returns a pointer to theŸA  ** sqlite_io_methods object that implements the desired lockingŸC  ** behaviors.  See the division above that contains the IOMETHODSŸ8  ** macro for addition information on finder-functions.§  **ŸG  ** Most finders simply return a pointer to a fixed sqlite3_io_methodsŸJ  ** object.  But the "autolockIoFinder" available on MacOSX does a littleŸD  ** more than that; it looks at the filesystem type that hosts the ŸH  ** database file and tries to choose an locking method appropriate for∫  ** that filesystem time.§  */Ÿ=  #define UNIXVFS(VFSNAME, FINDER) {                        \Ÿ=    3,                    /* iVersion */                    \Ÿ=    sizeof(unixFile),     /* szOsFile */                    \Ÿ=    MAX_PATHNAME,         /* mxPathname */                  \Ÿ=    0,                    /* pNext */                       \Ÿ=    VFSNAME,              /* zName */                       \Ÿ=    (void*)&FINDER,       /* pAppData */                    \Ÿ=    unixOpen,             /* xOpen */                       \Ÿ=    unixDelete,           /* xDelete */                     \Ÿ=    unixAccess,           /* xAccess */                     \Ÿ=    unixFullPathname,     /* xFullPathname */               \Ÿ=    unixDlOpen,           /* xDlOpen */                     \Ÿ=    unixDlError,          /* xDlError */                    \Ÿ=    unixDlSym,            /* xDlSym */                      \Ÿ=    unixDlClose,          /* xDlClose */                    \Ÿ=    unixRandomness,       /* xRandomness */                 \Ÿ=    unixSleep,            /* xSleep */                      \Ÿ=    unixCurrentTime,      /* xCurrentTime */                \Ÿ=    unixGetLastError,     /* xGetLastError */               \Ÿ=    unixCurrentTimeInt64, /* xCurrentTimeInt64 */           \Ÿ=    unixSetSystemCall,    /* xSetSystemCall */              \Ÿ=    unixGetSystemCall,    /* xGetSystemCall */              \Ÿ=    unixNextSystemCall,   /* xNextSystemCall */             \£  }†§  /*ŸE  ** All default VFSes for unix are contained in the following array.§  **ŸH  ** Note that the sqlite3_vfs.pNext field of the VFS object is modifiedŸE  ** by the SQLite core when the VFS is registered.  So the followingª  ** array cannot be const.§  */ø  static sqlite3_vfs aVfs[] = {Ÿ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ÿ0    UNIXVFS("unix",          autolockIoFinder ),∞#elif OS_VXWORKSŸ/    UNIXVFS("unix",          vxworksIoFinder ),•#elseŸ-    UNIXVFS("unix",          posixIoFinder ),¶#endifŸ.    UNIXVFS("unix-none",     nolockIoFinder ),Ÿ/    UNIXVFS("unix-dotfile",  dotlockIoFinder ),Ÿ-    UNIXVFS("unix-excl",     posixIoFinder ),Æ#if OS_VXWORKSŸ+    UNIXVFS("unix-namedsem", semIoFinder ),¶#endifŸ-#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKSŸ-    UNIXVFS("unix-posix",    posixIoFinder ),¶#endifø#if SQLITE_ENABLE_LOCKING_STYLEŸ-    UNIXVFS("unix-flock",    flockIoFinder ),¶#endifŸ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ÿ+    UNIXVFS("unix-afp",      afpIoFinder ),Ÿ+    UNIXVFS("unix-nfs",      nfsIoFinder ),Ÿ-    UNIXVFS("unix-proxy",    proxyIoFinder ),¶#endif§  };Ÿ-  unsigned int i;          /* Loop counter */†Ÿ@  /* Double-check that the aSyscall[] array has been constructedŸ2  ** correctly.  See ticket [bb3a86e890c8e96ab] */Ÿ$  assert( ArraySize(aSyscall)==29 );†Ÿ6  /* Register all VFSes defined in the aVfs[] array */Ÿ6  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){Ÿ)    sqlite3_vfs_register(&aVfs[i], i==0);£  }Ÿ<  unixBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);¥  return SQLITE_OK; °}†¢/*Ÿ+** Shutdown the operating system interface.¢**ŸH** Some operating systems might need to do some cleanup in this routine,Ÿ>** to release dynamically allocated objects.  But not on unix.Ÿ$** This routine is a no-op for unix.¢*/Ÿ%SQLITE_API int sqlite3_os_end(void){ ≤  unixBigLock = 0;¥  return SQLITE_OK; °}° ª#endif /* SQLITE_OS_UNIX */†ŸO/************** End of os_unix.c *********************************************/ŸO/************** Begin file os_win.c ******************************************/¢/*Æ** 2004 May 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**Ÿ7** This file contains code that is specific to Windows.¢*/º/* #include "sqliteInt.h" */ŸH#if SQLITE_OS_WIN               /* This file is used for Windows only */†¢/*Ÿ2** Include code that is common to all os_*.c files¢*/ŸO/************** Include os_common.h in the middle of os_win.c ****************/ŸO/************** Begin file os_common.h ***************************************/¢/*Æ** 2004 May 22¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸG** This file contains macros and a little bit of code that is common toŸJ** all of the platform-specific files (os_*.c) and is #included into those©** files.¢**ŸG** This file should be #included by the os_*.c files only.  It is not aø** general purpose header file.¢*/µ#ifndef _OS_COMMON_H_µ#define _OS_COMMON_H_†¢/*ŸH** At least two bugs have slipped in because we changed the MEMORY_DEBUGŸG** macro to SQLITE_DEBUG and some older makefiles have not yet made theŸI** switch.  The following code should catch this problem at compile-time.¢*/≥#ifdef MEMORY_DEBUGŸH# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."¶#endif†¢/*ŸD** Macros for performance tracing.  Normally turned off.  Only works¥** on i486 hardware.¢*/ø#ifdef SQLITE_PERFORMANCE_TRACE†¢/*Ÿ;** hwtime.h contains inline assembler code for implementingŸ$** high-performance timing routines.¢*/ŸO/************** Include hwtime.h in the middle of os_common.h ****************/ŸO/************** Begin file hwtime.h ******************************************/¢/*Æ** 2008 May 27¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸG** This file contains inline asm code for retrieving "high-performance"ø** counters for x86 class CPUs.¢*/∑#ifndef SQLITE_HWTIME_H∑#define SQLITE_HWTIME_H†¢/*ŸK** The following routine only works on pentium-class (or newer) processors.ŸD** It uses the RDTSC opcode to read the cycle count value out of theŸC** processor and returns that value.  This can be used for high-res≠** profiling.¢*/Ÿ1#if (defined(__GNUC__) || defined(_MSC_VER)) && \Ÿ>      (defined(i386) || defined(__i386__) || defined(_M_IX86))†∑  #if defined(__GNUC__)†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){π     unsigned int lo, hi;Ÿ;     __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));Ÿ)     return (sqlite_uint64)hi << 32 | lo;£  }†π  #elif defined(_MSC_VER)†ŸG  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){¨     __asm {≠        rdtscŸ+        ret       ; return value at EDX:EAX¶     }£  }†®  #endif†Ÿ0#elif (defined(__GNUC__) && defined(__x86_64__))†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){∏      unsigned long val;Ÿ2      __asm__ __volatile__ ("rdtsc" : "=A" (val));±      return val;£  }° Ÿ-#elif (defined(__GNUC__) && defined(__ppc__))†Ÿ/  __inline__ sqlite_uint64 sqlite3Hwtime(void){Ÿ       unsigned long long retval;π      unsigned long junk;Ÿ       __asm__ __volatile__ ("\n\ø          1:      mftbu   %1\n\Ÿ                   mftb    %L0\n\ø                  mftbu   %0\n\Ÿ"                  cmpw    %0,%1\n\Ω                  bne     1b"Ÿ0                  : "=r" (retval), "=r" (junk));¥      return retval;£  }†•#else†ŸB  #error Need implementation of sqlite3Hwtime() for your platform.†§  /*ŸG  ** To compile without implementing sqlite3Hwtime() for your platform,Ÿ:  ** you can remove the above #error and use the followingŸ:  ** stub function.  You will lose timing support for manyŸ=  ** of the debugging and testing utilities, but it should atª  ** least compile and run.§  */ŸPSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }†¶#endif†Ÿ&#endif /* !defined(SQLITE_HWTIME_H) */†ŸO/************** End of hwtime.h **********************************************/ŸO/************** Continuing where we left off in os_common.h ******************/†Ωstatic sqlite_uint64 g_start;østatic sqlite_uint64 g_elapsed;Ÿ1#define TIMER_START       g_start=sqlite3Hwtime()Ÿ;#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_startŸ##define TIMER_ELAPSED     g_elapsed•#else≥#define TIMER_START±#define TIMER_ENDŸ,#define TIMER_ELAPSED     ((sqlite_uint64)0)¶#endif†¢/*ŸI** If we compile with the SQLITE_TEST macro set, then the following blockŸG** of code will give us the ability to simulate a disk I/O error.  ThisŸ.** is used for testing the I/O recovery logic.¢*/∏#if defined(SQLITE_TEST)Ÿ+SQLITE_API extern int sqlite3_io_error_hit;Ÿ/SQLITE_API extern int sqlite3_io_error_hardhit;Ÿ/SQLITE_API extern int sqlite3_io_error_pending;Ÿ/SQLITE_API extern int sqlite3_io_error_persist;Ÿ.SQLITE_API extern int sqlite3_io_error_benign;Ÿ/SQLITE_API extern int sqlite3_diskfull_pending;Ÿ'SQLITE_API extern int sqlite3_diskfull;Ÿ<#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)Ÿ #define SimulateIOError(CODE)  \Ÿ:  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \Ÿ.       || sqlite3_io_error_pending-- == 1 )  \Ÿ&              { local_ioerr(); CODE; }∫static void local_ioerr(){∑  IOTRACE(("IOERR\n"));π  sqlite3_io_error_hit++;Ÿ<  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;°}Ÿ%#define SimulateDiskfullError(CODE) \Ÿ$   if( sqlite3_diskfull_pending ){ \Ÿ+     if( sqlite3_diskfull_pending == 1 ){ \∑       local_ioerr(); \æ       sqlite3_diskfull = 1; \Ÿ"       sqlite3_io_error_hit = 1; \Æ       CODE; \≠     }else{ \Ÿ$       sqlite3_diskfull_pending--; \®     } \§   }•#elseŸ #define SimulateIOErrorBenign(X)∫#define SimulateIOError(A)Ÿ #define SimulateDiskfullError(A)Ÿ!#endif /* defined(SQLITE_TEST) */†¢/*Ÿ:** When testing, keep a count of the number of open files.¢*/∏#if defined(SQLITE_TEST)Ÿ.SQLITE_API extern int sqlite3_open_file_count;Ÿ4#define OpenCounter(X)  sqlite3_open_file_count+=(X)•#else∂#define OpenCounter(X)Ÿ!#endif /* defined(SQLITE_TEST) */†Ÿ$#endif /* !defined(_OS_COMMON_H_) */†ŸO/************** End of os_common.h *******************************************/ŸO/************** Continuing where we left off in os_win.c *********************/†¢/*Ÿ/** Include the header file for the Windows VFS.¢*/π/* #include "os_win.h" */†¢/*ŸC** Compiling and using WAL mode requires several APIs that are onlyŸ9** available in Windows platforms based on the NT kernel.¢*/Ÿ1#if !SQLITE_OS_WINNT && !defined(SQLITE_OMIT_WAL)ŸH#  error "WAL mode requires support from the Windows NT kernel, compile\∑ with SQLITE_OMIT_WAL."¶#endif†Ÿ.#if !SQLITE_OS_WINNT && SQLITE_MAX_MMAP_SIZE>0ŸJ#  error "Memory mapped files require support from the Windows NT kernel,\Ÿ& compile with SQLITE_MAX_MMAP_SIZE=0."¶#endif†¢/*ŸJ** Are most of the Win32 ANSI APIs available (i.e. with certain exceptionsæ** based on the sub-platform)?¢*/ŸJ#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(SQLITE_WIN32_NO_ANSI)ø#  define SQLITE_WIN32_HAS_ANSI¶#endif†¢/*ŸM** Are most of the Win32 Unicode APIs available (i.e. with certain exceptionsæ** based on the sub-platform)?¢*/Ÿ@#if (SQLITE_OS_WINCE || SQLITE_OS_WINNT || SQLITE_OS_WINRT) && \Ÿ"    !defined(SQLITE_WIN32_NO_WIDE)ø#  define SQLITE_WIN32_HAS_WIDE¶#endif†¢/*Ÿ9** Make sure at least one set of Win32 APIs is available.¢*/ŸF#if !defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_WIN32_HAS_WIDE)ŸJ#  error "At least one of SQLITE_WIN32_HAS_ANSI and SQLITE_WIN32_HAS_WIDE\≤ must be defined."¶#endif†¢/*ŸD** Define the required Windows SDK version constants if they are notµ** already available.¢*/≤#ifndef NTDDI_WIN8Ÿ6#  define NTDDI_WIN8                        0x06020000¶#endif†µ#ifndef NTDDI_WINBLUEŸ6#  define NTDDI_WINBLUE                     0x06030000¶#endif†∫#ifndef NTDDI_WINTHRESHOLDŸ6#  define NTDDI_WINTHRESHOLD                0x06040000¶#endif†¢/*ŸG** Check to see if the GetVersionEx[AW] functions are deprecated on theŸ?** target system.  GetVersionEx was first deprecated in Win8.1.¢*/Ÿ!#ifndef SQLITE_WIN32_GETVERSIONEXŸ>#  if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINBLUEŸN#    define SQLITE_WIN32_GETVERSIONEX   0   /* GetVersionEx() is deprecated */ß#  elseŸK#    define SQLITE_WIN32_GETVERSIONEX   1   /* GetVersionEx() is current */®#  endif¶#endif†¢/*ŸF** Check to see if the CreateFileMappingA function is supported on theŸG** target system.  It is unavailable when using "mincore.lib" on Win10.ŸH** When compiling for Windows 10, always assume "mincore.lib" is in use.¢*/Ÿ'#ifndef SQLITE_WIN32_CREATEFILEMAPPINGAŸC#  if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINTHRESHOLDŸ/#    define SQLITE_WIN32_CREATEFILEMAPPINGA   0ß#  elseŸ/#    define SQLITE_WIN32_CREATEFILEMAPPINGA   1®#  endif¶#endif†¢/*ŸH** This constant should already be defined (in the "WinDef.h" SDK file).¢*/∞#ifndef MAX_PATHŸ-#  define MAX_PATH                      (260)¶#endif†¢/*ŸI** Maximum pathname length (in chars) for Win32.  This should normally be¨** MAX_PATH.¢*/Ÿ##ifndef SQLITE_WIN32_MAX_PATH_CHARSŸ2#  define SQLITE_WIN32_MAX_PATH_CHARS   (MAX_PATH)¶#endif†¢/*ŸG** This constant should already be defined (in the "WinNT.h" SDK file).¢*/Ÿ #ifndef UNICODE_STRING_MAX_CHARSŸ/#  define UNICODE_STRING_MAX_CHARS      (32767)¶#endif†¢/*ŸI** Maximum pathname length (in chars) for WinNT.  This should normally beº** UNICODE_STRING_MAX_CHARS.¢*/Ÿ##ifndef SQLITE_WINNT_MAX_PATH_CHARSŸB#  define SQLITE_WINNT_MAX_PATH_CHARS   (UNICODE_STRING_MAX_CHARS)¶#endif†¢/*ŸJ** Maximum pathname length (in bytes) for Win32.  The MAX_PATH macro is inŸJ** characters, so we allocate 4 bytes per character assuming worst-case ofŸ"** 4-bytes-per-character for UTF8.¢*/Ÿ##ifndef SQLITE_WIN32_MAX_PATH_BYTESŸG#  define SQLITE_WIN32_MAX_PATH_BYTES   (SQLITE_WIN32_MAX_PATH_CHARS*4)¶#endif†¢/*ŸI** Maximum pathname length (in bytes) for WinNT.  This should normally beŸ,** UNICODE_STRING_MAX_CHARS * sizeof(WCHAR).¢*/Ÿ##ifndef SQLITE_WINNT_MAX_PATH_BYTESŸ)#  define SQLITE_WINNT_MAX_PATH_BYTES   \ŸI                            (sizeof(WCHAR) * SQLITE_WINNT_MAX_PATH_CHARS)¶#endif†¢/*Ÿ5** Maximum error message length (in chars) for WinRT.¢*/Ÿ%#ifndef SQLITE_WIN32_MAX_ERRMSG_CHARSŸ.#  define SQLITE_WIN32_MAX_ERRMSG_CHARS (1024)¶#endif†¢/*ŸE** Returns non-zero if the character should be treated as a directory≠** separator.¢*/≥#ifndef winIsDirSepŸG#  define winIsDirSep(a)                (((a) == '/') || ((a) == '\\'))¶#endif†¢/*ŸE** This macro is used when a local variable is set to a value that isŸG** [sometimes] not used by the code (e.g. via conditional compilation).¢*/Ω#ifndef UNUSED_VARIABLE_VALUEŸ1#  define UNUSED_VARIABLE_VALUE(x)      (void)(x)¶#endif†¢/*ŸH** Returns the character that should be used as the directory separator.¢*/¥#ifndef winGetDirSepŸ,#  define winGetDirSep()                '\\'¶#endif†¢/*ŸM** Do we need to manually define the Win32 file mapping APIs for use with WALŸL** mode or memory mapped files (e.g. these APIs are available in the WindowsŸ=** CE SDK; however, they are not present in the header file)?¢*/Ÿ%#if SQLITE_WIN32_FILEMAPPING_API && \Ÿ=        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)¢/*ŸL** Two of the file mapping APIs are different under WinRT.  Figure out whichØ** set we need.¢*/≥#if SQLITE_OS_WINRTŸ;WINBASEAPI HANDLE WINAPI CreateFileMappingFromApp(HANDLE, \Ÿ8        LPSECURITY_ATTRIBUTES, ULONG, ULONG64, LPCWSTR);†ŸNWINBASEAPI LPVOID WINAPI MapViewOfFileFromApp(HANDLE, ULONG, ULONG64, SIZE_T);•#elseŸ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸLWINBASEAPI HANDLE WINAPI CreateFileMappingA(HANDLE, LPSECURITY_ATTRIBUTES, \Ÿ%        DWORD, DWORD, DWORD, LPCSTR);Ÿ+#endif /* defined(SQLITE_WIN32_HAS_ANSI) */†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)ŸLWINBASEAPI HANDLE WINAPI CreateFileMappingW(HANDLE, LPSECURITY_ATTRIBUTES, \Ÿ&        DWORD, DWORD, DWORD, LPCWSTR);Ÿ+#endif /* defined(SQLITE_WIN32_HAS_WIDE) */†ŸLWINBASEAPI LPVOID WINAPI MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, SIZE_T);º#endif /* SQLITE_OS_WINRT */†¢/*Ÿ>** These file mapping APIs are common to both Win32 and WinRT.¢*/†Ÿ8WINBASEAPI BOOL WINAPI FlushViewOfFile(LPCVOID, SIZE_T);Ÿ0WINBASEAPI BOOL WINAPI UnmapViewOfFile(LPCVOID);Ÿ)#endif /* SQLITE_WIN32_FILEMAPPING_API */†¢/*Ÿ1** Some Microsoft compilers lack this definition.¢*/ø#ifndef INVALID_FILE_ATTRIBUTESŸ,# define INVALID_FILE_ATTRIBUTES ((DWORD)-1)¶#endif†∂#ifndef FILE_FLAG_MASKŸ-# define FILE_FLAG_MASK          (0xFF3C0000)¶#endif†ª#ifndef FILE_ATTRIBUTE_MASKŸ-# define FILE_ATTRIBUTE_MASK     (0x0003FFF7)¶#endif†∑#ifndef SQLITE_OMIT_WALŸ3/* Forward references to structures used for WAL */ŸKtypedef struct winShm winShm;           /* A connection to shared-memory */ŸGtypedef struct winShmNode winShmNode;   /* A region of shared-memory */¶#endif†¢/*ŸD** WinCE lacks native support for file locking so we have to fake itΩ** with some code of our own.¢*/≥#if SQLITE_OS_WINCE∫typedef struct winceLock {Ÿ;  int nReaders;       /* Number of reader locks obtained */ŸF  BOOL bPending;      /* Indicates a pending lock has been obtained */ŸG  BOOL bReserved;     /* Indicates a reserved lock has been obtained */ŸI  BOOL bExclusive;    /* Indicates an exclusive lock has been obtained */¨} winceLock;¶#endif†¢/*ŸM** The winFile structure is a subclass of sqlite3_file* specific to the win32µ** portability layer.¢*/øtypedef struct winFile winFile;∞struct winFile {Ÿ<  const sqlite3_io_methods *pMethod; /*** Must be first ***/Ÿ>  sqlite3_vfs *pVfs;      /* The VFS used to open this file */Ÿ=  HANDLE h;               /* Handle for accessing the file */ŸH  u8 locktype;            /* Type of lock currently held on this file */ŸJ  short sharedLockByte;   /* Randomly chosen byte used as a shared lock */Ÿ;  u8 ctrlFlags;           /* Flags.  See WINFILE_* below */ŸI  DWORD lastErrno;        /* The Windows errno from the last I/O error */∑#ifndef SQLITE_OMIT_WALŸF  winShm *pShm;           /* Instance of shared memory on this file */¶#endifŸ:  const char *zPath;      /* Full pathname of this file */ŸI  int szChunk;            /* Chunk size configured by FCNTL_CHUNK_SIZE */≥#if SQLITE_OS_WINCEŸC  LPWSTR zDeleteOnClose;  /* Name of file to delete when closing */ŸK  HANDLE hMutex;          /* Mutex used to control access to shared lock */ŸF  HANDLE hShared;         /* Shared memory segment used for locking */ŸJ  winceLock local;        /* Locks obtained by this instance of winFile */ŸG  winceLock *shared;      /* Global shared lock memory for the file  */¶#endif∫#if SQLITE_MAX_MMAP_SIZE>0ŸM  int nFetchOut;                /* Number of outstanding xFetch references */ŸI  HANDLE hMap;                  /* Handle for accessing memory mapping */Ÿ8  void *pMapRegion;             /* Area memory mapped */ŸB  sqlite3_int64 mmapSize;       /* Usable size of mapped region */ŸB  sqlite3_int64 mmapSizeActual; /* Actual size of mapped region */ŸF  sqlite3_int64 mmapSizeMax;    /* Configured FCNTL_MMAP_SIZE value */¶#endif¢};†¢/*ŸM** The winVfsAppData structure is used for the pAppData member for all of the∂** Win32 VFS variants.¢*/Ÿ+typedef struct winVfsAppData winVfsAppData;∂struct winVfsAppData {ŸG  const sqlite3_io_methods *pMethod; /* The file I/O methods to use. */ŸF  void *pAppData;                    /* The extra pAppData, if any. */ŸK  BOOL bNoLock;                      /* Non-zero if locking is disabled. */¢};†¢/*Ÿ'** Allowed values for winFile.ctrlFlags¢*/ŸD#define WINFILE_RDONLY          0x02   /* Connection is read only */Ÿ@#define WINFILE_PERSIST_WAL     0x04   /* Persistent WAL mode */ŸM#define WINFILE_PSOW            0x10   /* SQLITE_IOCAP_POWERSAFE_OVERWRITE */†¢/*Ÿ> * The size of the buffer used by sqlite3_win32_write_debug().£ */Ÿ!#ifndef SQLITE_WIN32_DBG_BUF_SIZEŸA#  define SQLITE_WIN32_DBG_BUF_SIZE   ((int)(4096-sizeof(DWORD)))¶#endif†¢/*ŸD * The value used with sqlite3_win32_set_directory() to specify thatŸ( * the data directory should be changed.£ */Ÿ(#ifndef SQLITE_WIN32_DATA_DIRECTORY_TYPEŸ.#  define SQLITE_WIN32_DATA_DIRECTORY_TYPE (1)¶#endif†¢/*ŸD * The value used with sqlite3_win32_set_directory() to specify thatŸ- * the temporary directory should be changed.£ */Ÿ(#ifndef SQLITE_WIN32_TEMP_DIRECTORY_TYPEŸ.#  define SQLITE_WIN32_TEMP_DIRECTORY_TYPE (2)¶#endif†¢/*ŸC * If compiled with SQLITE_WIN32_MALLOC on Windows, we will use theŸ7 * various Win32 API heap functions instead of our own.£ */∫#ifdef SQLITE_WIN32_MALLOC†¢/*ŸL * If this is non-zero, an isolated heap will be created by the native Win32ŸO * allocator subsystem; otherwise, the default process heap will be used.  ThisŸO * setting has no effect when compiling for WinRT.  By default, this is enabledŸD * and an isolated heap will be created to store all allocated data.¢ *ŸO ******************************************************************************ŸN * WARNING: It is important to note that when this setting is non-zero and theŸK *          winMemShutdown function is called (e.g. by the sqlite3_shutdownŸO *          function), all data that was allocated using the isolated heap willŸL *          be freed immediately and any attempt to access any of that freedŸO *          data will almost certainly result in an immediate access violation.ŸO ******************************************************************************£ */Ÿ #ifndef SQLITE_WIN32_HEAP_CREATEŸ0#  define SQLITE_WIN32_HEAP_CREATE        (TRUE)¶#endif†¢/*ŸK * This is the maximum possible initial size of the Win32-specific heap, in© * bytes.£ */Ÿ'#ifndef SQLITE_WIN32_HEAP_MAX_INIT_SIZEŸ7#  define SQLITE_WIN32_HEAP_MAX_INIT_SIZE (4294967295U)¶#endif†¢/*ŸK * This is the extra space for the initial size of the Win32-specific heap,Ÿ% * in bytes.  This value may be zero.£ */Ÿ$#ifndef SQLITE_WIN32_HEAP_INIT_EXTRAŸ1#  define SQLITE_WIN32_HEAP_INIT_EXTRA  (4194304)¶#endif†¢/*ŸI * Calculate the maximum legal cache size, in pages, based on the maximumŸJ * possible initial heap size and the default page size, setting aside the∂ * needed extra space.£ */Ÿ##ifndef SQLITE_WIN32_MAX_CACHE_SIZEŸO#  define SQLITE_WIN32_MAX_CACHE_SIZE   (((SQLITE_WIN32_HEAP_MAX_INIT_SIZE) - \ŸM                                          (SQLITE_WIN32_HEAP_INIT_EXTRA)) / \ŸD                                         (SQLITE_DEFAULT_PAGE_SIZE))¶#endif†¢/*ŸH * This is cache size used in the calculation of the initial size of theŸ/ * Win32-specific heap.  It cannot be negative.£ */ø#ifndef SQLITE_WIN32_CACHE_SIZEŸ"#  if SQLITE_DEFAULT_CACHE_SIZE>=0ŸC#    define SQLITE_WIN32_CACHE_SIZE     (SQLITE_DEFAULT_CACHE_SIZE)ß#  elseŸF#    define SQLITE_WIN32_CACHE_SIZE     (-(SQLITE_DEFAULT_CACHE_SIZE))®#  endif¶#endif†¢/*ŸG * Make sure that the calculated cache size, in pages, cannot cause theŸG * initial size of the Win32-specific heap to exceed the maximum amountŸ= * of memory that can be specified in the call to HeapCreate.£ */Ÿ7#if SQLITE_WIN32_CACHE_SIZE>SQLITE_WIN32_MAX_CACHE_SIZEŸ #  undef SQLITE_WIN32_CACHE_SIZEŸ.#  define SQLITE_WIN32_CACHE_SIZE       (2000)¶#endif†¢/*ŸH * The initial size of the Win32-specific heap.  This value may be zero.£ */Ÿ##ifndef SQLITE_WIN32_HEAP_INIT_SIZEŸF#  define SQLITE_WIN32_HEAP_INIT_SIZE   ((SQLITE_WIN32_CACHE_SIZE) * \ŸG                                         (SQLITE_DEFAULT_PAGE_SIZE) + \ŸH                                         (SQLITE_WIN32_HEAP_INIT_EXTRA))¶#endif†¢/*ŸH * The maximum size of the Win32-specific heap.  This value may be zero.£ */Ÿ"#ifndef SQLITE_WIN32_HEAP_MAX_SIZEŸ+#  define SQLITE_WIN32_HEAP_MAX_SIZE    (0)¶#endif†¢/*ŸM * The extra flags to use in calls to the Win32 heap APIs.  This value may beŸ! * zero for the default behavior.£ */ø#ifndef SQLITE_WIN32_HEAP_FLAGSŸ+#  define SQLITE_WIN32_HEAP_FLAGS       (0)¶#endif††¢/*ŸM** The winMemData structure stores information required by the Win32-specificŸ&** sqlite3_mem_methods implementation.¢*/Ÿ%typedef struct winMemData winMemData;≥struct winMemData {Æ#ifndef NDEBUGŸB  u32 magic1;   /* Magic number to detect structure corruption. */¶#endifŸ-  HANDLE hHeap; /* The handle to our heap. */ŸG  BOOL bOwned;  /* Do we own the heap (i.e. destroy it on shutdown)? */Æ#ifndef NDEBUGŸB  u32 magic2;   /* Magic number to detect structure corruption. */¶#endif¢};†Æ#ifndef NDEBUGŸ$#define WINMEM_MAGIC1     0x42b2830bŸ$#define WINMEM_MAGIC2     0xbd4d7cf4¶#endif†Ÿ)static struct winMemData win_mem_data = {Æ#ifndef NDEBUG∞  WINMEM_MAGIC1,¶#endif≠  NULL, FALSEÆ#ifndef NDEBUG∞  ,WINMEM_MAGIC2¶#endif¢};†Æ#ifndef NDEBUGŸI#define winMemAssertMagic1() assert( win_mem_data.magic1==WINMEM_MAGIC1 )ŸI#define winMemAssertMagic2() assert( win_mem_data.magic2==WINMEM_MAGIC2 )ŸH#define winMemAssertMagic()  winMemAssertMagic1(); winMemAssertMagic2();•#elseª#define winMemAssertMagic()¶#endif†Ÿ)#define winMemGetDataPtr()  &win_mem_dataŸ.#define winMemGetHeap()     win_mem_data.hHeapŸ/#define winMemGetOwned()    win_mem_data.bOwned†Ÿ&static void *winMemMalloc(int nBytes);Ÿ%static void winMemFree(void *pPrior);Ÿ5static void *winMemRealloc(void *pPrior, int nBytes);østatic int winMemSize(void *p);Ÿ static int winMemRoundup(int n);Ÿ&static int winMemInit(void *pAppData);Ÿ+static void winMemShutdown(void *pAppData);†ŸCSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void);Ÿ #endif /* SQLITE_WIN32_MALLOC */†¢/*ŸB** The following variable is (normally) set once and never changesŸ@** thereafter.  It records whether the operating system is Win9x¨** or WinNT.¢**Ÿ!** 0:   Operating system unknown.Ÿ"** 1:   Operating system is Win9x.Ÿ"** 2:   Operating system is WinNT.¢**ŸE** In order to facilitate testing on a WinNT system, the test fixtureŸ>** can manually set this value to 1 to emulate Win98 behavior.¢*/≤#ifdef SQLITE_TESTŸ:SQLITE_API LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;•#elseŸ6static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;¶#endif†Ø#ifndef SYSCALLŸ%#  define SYSCALL sqlite3_syscall_ptr¶#endif†¢/*Ÿ9** This function is not available on Windows CE or WinRT.£ */†Ÿ&#if SQLITE_OS_WINCE || SQLITE_OS_WINRTŸ%#  define osAreFileApisANSI()       1¶#endif†¢/*ŸF** Many system calls are accessed through pointer-to-functions so thatŸI** they may be overridden at runtime to facilitate fault injection duringŸL** testing and sandboxing.  The following array holds the names and pointersŸ$** to all overrideable system calls.¢*/ªstatic struct win_syscall {Ÿ=  const char *zName;            /* Name of the system call */ŸF  sqlite3_syscall_ptr pCurrent; /* Current value of the system call */Ÿ3  sqlite3_syscall_ptr pDefault; /* Default value */∞} aSyscall[] = {Ÿ(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTŸE  { "AreFileApisANSI",         (SYSCALL)AreFileApisANSI,         0 },•#elseŸE  { "AreFileApisANSI",         (SYSCALL)0,                       0 },¶#endif†π#ifndef osAreFileApisANSIŸE#define osAreFileApisANSI ((BOOL(WINAPI*)(VOID))aSyscall[0].pCurrent)¶#endif†Ÿ5#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "CharLowerW",              (SYSCALL)CharLowerW,              0 },•#elseŸE  { "CharLowerW",              (SYSCALL)0,                       0 },¶#endif†ŸD#define osCharLowerW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[1].pCurrent)†Ÿ5#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "CharUpperW",              (SYSCALL)CharUpperW,              0 },•#elseŸE  { "CharUpperW",              (SYSCALL)0,                       0 },¶#endif†ŸD#define osCharUpperW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[2].pCurrent)†ŸE  { "CloseHandle",             (SYSCALL)CloseHandle,             0 },†ŸC#define osCloseHandle ((BOOL(WINAPI*)(HANDLE))aSyscall[3].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "CreateFileA",             (SYSCALL)CreateFileA,             0 },•#elseŸE  { "CreateFileA",             (SYSCALL)0,                       0 },¶#endif†Ÿ=#define osCreateFileA ((HANDLE(WINAPI*)(LPCSTR,DWORD,DWORD, \ŸG        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[4].pCurrent)†Ÿ6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "CreateFileW",             (SYSCALL)CreateFileW,             0 },•#elseŸE  { "CreateFileW",             (SYSCALL)0,                       0 },¶#endif†Ÿ>#define osCreateFileW ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD, \ŸG        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[5].pCurrent)†Ÿ;#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_ANSI) && \ŸB        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) && \Ÿ'        SQLITE_WIN32_CREATEFILEMAPPINGAŸE  { "CreateFileMappingA",      (SYSCALL)CreateFileMappingA,      0 },•#elseŸE  { "CreateFileMappingA",      (SYSCALL)0,                       0 },¶#endif†ŸN#define osCreateFileMappingA ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \Ÿ7        DWORD,DWORD,DWORD,LPCSTR))aSyscall[6].pCurrent)†ŸO#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \Ÿ>        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))ŸE  { "CreateFileMappingW",      (SYSCALL)CreateFileMappingW,      0 },•#elseŸE  { "CreateFileMappingW",      (SYSCALL)0,                       0 },¶#endif†ŸN#define osCreateFileMappingW ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \Ÿ8        DWORD,DWORD,DWORD,LPCWSTR))aSyscall[7].pCurrent)†Ÿ6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "CreateMutexW",            (SYSCALL)CreateMutexW,            0 },•#elseŸE  { "CreateMutexW",            (SYSCALL)0,                       0 },¶#endif†ŸF#define osCreateMutexW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,BOOL, \Ÿ&        LPCWSTR))aSyscall[8].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "DeleteFileA",             (SYSCALL)DeleteFileA,             0 },•#elseŸE  { "DeleteFileA",             (SYSCALL)0,                       0 },¶#endif†ŸC#define osDeleteFileA ((BOOL(WINAPI*)(LPCSTR))aSyscall[9].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "DeleteFileW",             (SYSCALL)DeleteFileW,             0 },•#elseŸE  { "DeleteFileW",             (SYSCALL)0,                       0 },¶#endif†ŸE#define osDeleteFileW ((BOOL(WINAPI*)(LPCWSTR))aSyscall[10].pCurrent)†≥#if SQLITE_OS_WINCEŸE  { "FileTimeToLocalFileTime", (SYSCALL)FileTimeToLocalFileTime, 0 },•#elseŸE  { "FileTimeToLocalFileTime", (SYSCALL)0,                       0 },¶#endif†ŸD#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(CONST FILETIME*, \Ÿ*        LPFILETIME))aSyscall[11].pCurrent)†≥#if SQLITE_OS_WINCEŸE  { "FileTimeToSystemTime",    (SYSCALL)FileTimeToSystemTime,    0 },•#elseŸE  { "FileTimeToSystemTime",    (SYSCALL)0,                       0 },¶#endif†ŸA#define osFileTimeToSystemTime ((BOOL(WINAPI*)(CONST FILETIME*, \Ÿ,        LPSYSTEMTIME))aSyscall[12].pCurrent)†ŸE  { "FlushFileBuffers",        (SYSCALL)FlushFileBuffers,        0 },†ŸI#define osFlushFileBuffers ((BOOL(WINAPI*)(HANDLE))aSyscall[13].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "FormatMessageA",          (SYSCALL)FormatMessageA,          0 },•#elseŸE  { "FormatMessageA",          (SYSCALL)0,                       0 },¶#endif†ŸL#define osFormatMessageA ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPSTR, \Ÿ.        DWORD,va_list*))aSyscall[14].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "FormatMessageW",          (SYSCALL)FormatMessageW,          0 },•#elseŸE  { "FormatMessageW",          (SYSCALL)0,                       0 },¶#endif†ŸM#define osFormatMessageW ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPWSTR, \Ÿ.        DWORD,va_list*))aSyscall[15].pCurrent)†Ÿ(#if !defined(SQLITE_OMIT_LOAD_EXTENSION)ŸE  { "FreeLibrary",             (SYSCALL)FreeLibrary,             0 },•#elseŸE  { "FreeLibrary",             (SYSCALL)0,                       0 },¶#endif†ŸE#define osFreeLibrary ((BOOL(WINAPI*)(HMODULE))aSyscall[16].pCurrent)†ŸE  { "GetCurrentProcessId",     (SYSCALL)GetCurrentProcessId,     0 },†ŸK#define osGetCurrentProcessId ((DWORD(WINAPI*)(VOID))aSyscall[17].pCurrent)†Ÿ6#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "GetDiskFreeSpaceA",       (SYSCALL)GetDiskFreeSpaceA,       0 },•#elseŸE  { "GetDiskFreeSpaceA",       (SYSCALL)0,                       0 },¶#endif†ŸM#define osGetDiskFreeSpaceA ((BOOL(WINAPI*)(LPCSTR,LPDWORD,LPDWORD,LPDWORD, \Ÿ'        LPDWORD))aSyscall[18].pCurrent)†ŸJ#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "GetDiskFreeSpaceW",       (SYSCALL)GetDiskFreeSpaceW,       0 },•#elseŸE  { "GetDiskFreeSpaceW",       (SYSCALL)0,                       0 },¶#endif†ŸN#define osGetDiskFreeSpaceW ((BOOL(WINAPI*)(LPCWSTR,LPDWORD,LPDWORD,LPDWORD, \Ÿ'        LPDWORD))aSyscall[19].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "GetFileAttributesA",      (SYSCALL)GetFileAttributesA,      0 },•#elseŸE  { "GetFileAttributesA",      (SYSCALL)0,                       0 },¶#endif†ŸL#define osGetFileAttributesA ((DWORD(WINAPI*)(LPCSTR))aSyscall[20].pCurrent)†Ÿ6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "GetFileAttributesW",      (SYSCALL)GetFileAttributesW,      0 },•#elseŸE  { "GetFileAttributesW",      (SYSCALL)0,                       0 },¶#endif†ŸM#define osGetFileAttributesW ((DWORD(WINAPI*)(LPCWSTR))aSyscall[21].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "GetFileAttributesExW",    (SYSCALL)GetFileAttributesExW,    0 },•#elseŸE  { "GetFileAttributesExW",    (SYSCALL)0,                       0 },¶#endif†ŸP#define osGetFileAttributesExW ((BOOL(WINAPI*)(LPCWSTR,GET_FILEEX_INFO_LEVELS, \Ÿ&        LPVOID))aSyscall[22].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "GetFileSize",             (SYSCALL)GetFileSize,             0 },•#elseŸE  { "GetFileSize",             (SYSCALL)0,                       0 },¶#endif†ŸM#define osGetFileSize ((DWORD(WINAPI*)(HANDLE,LPDWORD))aSyscall[23].pCurrent)†Ÿ6#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "GetFullPathNameA",        (SYSCALL)GetFullPathNameA,        0 },•#elseŸE  { "GetFullPathNameA",        (SYSCALL)0,                       0 },¶#endif†ŸA#define osGetFullPathNameA ((DWORD(WINAPI*)(LPCSTR,DWORD,LPSTR, \Ÿ&        LPSTR*))aSyscall[24].pCurrent)†ŸJ#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "GetFullPathNameW",        (SYSCALL)GetFullPathNameW,        0 },•#elseŸE  { "GetFullPathNameW",        (SYSCALL)0,                       0 },¶#endif†ŸC#define osGetFullPathNameW ((DWORD(WINAPI*)(LPCWSTR,DWORD,LPWSTR, \Ÿ'        LPWSTR*))aSyscall[25].pCurrent)†ŸE  { "GetLastError",            (SYSCALL)GetLastError,            0 },†ŸD#define osGetLastError ((DWORD(WINAPI*)(VOID))aSyscall[26].pCurrent)†Ÿ(#if !defined(SQLITE_OMIT_LOAD_EXTENSION)≥#if SQLITE_OS_WINCEŸF  /* The GetProcAddressA() routine is only available on Windows CE. */ŸE  { "GetProcAddressA",         (SYSCALL)GetProcAddressA,         0 },•#elseŸ@  /* All other Windows platforms expect GetProcAddress() to takeŸ9  ** an ANSI string regardless of the _UNICODE setting */ŸE  { "GetProcAddressA",         (SYSCALL)GetProcAddress,          0 },¶#endif•#elseŸE  { "GetProcAddressA",         (SYSCALL)0,                       0 },¶#endif†Ÿ7#define osGetProcAddressA ((FARPROC(WINAPI*)(HMODULE, \Ÿ&        LPCSTR))aSyscall[27].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "GetSystemInfo",           (SYSCALL)GetSystemInfo,           0 },•#elseŸE  { "GetSystemInfo",           (SYSCALL)0,                       0 },¶#endif†ŸM#define osGetSystemInfo ((VOID(WINAPI*)(LPSYSTEM_INFO))aSyscall[28].pCurrent)†ŸE  { "GetSystemTime",           (SYSCALL)GetSystemTime,           0 },†ŸL#define osGetSystemTime ((VOID(WINAPI*)(LPSYSTEMTIME))aSyscall[29].pCurrent)†¥#if !SQLITE_OS_WINCEŸE  { "GetSystemTimeAsFileTime", (SYSCALL)GetSystemTimeAsFileTime, 0 },•#elseŸE  { "GetSystemTimeAsFileTime", (SYSCALL)0,                       0 },¶#endif†Ÿ4#define osGetSystemTimeAsFileTime ((VOID(WINAPI*)( \Ÿ*        LPFILETIME))aSyscall[30].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "GetTempPathA",            (SYSCALL)GetTempPathA,            0 },•#elseŸE  { "GetTempPathA",            (SYSCALL)0,                       0 },¶#endif†ŸK#define osGetTempPathA ((DWORD(WINAPI*)(DWORD,LPSTR))aSyscall[31].pCurrent)†Ÿ6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "GetTempPathW",            (SYSCALL)GetTempPathW,            0 },•#elseŸE  { "GetTempPathW",            (SYSCALL)0,                       0 },¶#endif†ŸL#define osGetTempPathW ((DWORD(WINAPI*)(DWORD,LPWSTR))aSyscall[32].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "GetTickCount",            (SYSCALL)GetTickCount,            0 },•#elseŸE  { "GetTickCount",            (SYSCALL)0,                       0 },¶#endif†ŸD#define osGetTickCount ((DWORD(WINAPI*)(VOID))aSyscall[33].pCurrent)†Ÿ?#if defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_GETVERSIONEXŸE  { "GetVersionExA",           (SYSCALL)GetVersionExA,           0 },•#elseŸE  { "GetVersionExA",           (SYSCALL)0,                       0 },¶#endif†Ÿ*#define osGetVersionExA ((BOOL(WINAPI*)( \Ÿ0        LPOSVERSIONINFOA))aSyscall[34].pCurrent)†Ÿ;#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \Ÿ!        SQLITE_WIN32_GETVERSIONEXŸE  { "GetVersionExW",           (SYSCALL)GetVersionExW,           0 },•#elseŸE  { "GetVersionExW",           (SYSCALL)0,                       0 },¶#endif†Ÿ*#define osGetVersionExW ((BOOL(WINAPI*)( \Ÿ0        LPOSVERSIONINFOW))aSyscall[35].pCurrent)†ŸE  { "HeapAlloc",               (SYSCALL)HeapAlloc,               0 },†Ÿ5#define osHeapAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD, \Ÿ&        SIZE_T))aSyscall[36].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "HeapCreate",              (SYSCALL)HeapCreate,              0 },•#elseŸE  { "HeapCreate",              (SYSCALL)0,                       0 },¶#endif†Ÿ6#define osHeapCreate ((HANDLE(WINAPI*)(DWORD,SIZE_T, \Ÿ&        SIZE_T))aSyscall[37].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "HeapDestroy",             (SYSCALL)HeapDestroy,             0 },•#elseŸE  { "HeapDestroy",             (SYSCALL)0,                       0 },¶#endif†ŸD#define osHeapDestroy ((BOOL(WINAPI*)(HANDLE))aSyscall[38].pCurrent)†ŸE  { "HeapFree",                (SYSCALL)HeapFree,                0 },†ŸN#define osHeapFree ((BOOL(WINAPI*)(HANDLE,DWORD,LPVOID))aSyscall[39].pCurrent)†ŸE  { "HeapReAlloc",             (SYSCALL)HeapReAlloc,             0 },†Ÿ>#define osHeapReAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD,LPVOID, \Ÿ&        SIZE_T))aSyscall[40].pCurrent)†ŸE  { "HeapSize",                (SYSCALL)HeapSize,                0 },†Ÿ4#define osHeapSize ((SIZE_T(WINAPI*)(HANDLE,DWORD, \Ÿ'        LPCVOID))aSyscall[41].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "HeapValidate",            (SYSCALL)HeapValidate,            0 },•#elseŸE  { "HeapValidate",            (SYSCALL)0,                       0 },¶#endif†Ÿ6#define osHeapValidate ((BOOL(WINAPI*)(HANDLE,DWORD, \Ÿ'        LPCVOID))aSyscall[42].pCurrent)†Ÿ(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTŸE  { "HeapCompact",             (SYSCALL)HeapCompact,             0 },•#elseŸE  { "HeapCompact",             (SYSCALL)0,                       0 },¶#endif†ŸJ#define osHeapCompact ((UINT(WINAPI*)(HANDLE,DWORD))aSyscall[43].pCurrent)†ŸJ#if defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_OMIT_LOAD_EXTENSION)ŸE  { "LoadLibraryA",            (SYSCALL)LoadLibraryA,            0 },•#elseŸE  { "LoadLibraryA",            (SYSCALL)0,                       0 },¶#endif†ŸH#define osLoadLibraryA ((HMODULE(WINAPI*)(LPCSTR))aSyscall[44].pCurrent)†Ÿ;#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \Ÿ,        !defined(SQLITE_OMIT_LOAD_EXTENSION)ŸE  { "LoadLibraryW",            (SYSCALL)LoadLibraryW,            0 },•#elseŸE  { "LoadLibraryW",            (SYSCALL)0,                       0 },¶#endif†ŸI#define osLoadLibraryW ((HMODULE(WINAPI*)(LPCWSTR))aSyscall[45].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "LocalFree",               (SYSCALL)LocalFree,               0 },•#elseŸE  { "LocalFree",               (SYSCALL)0,                       0 },¶#endif†ŸD#define osLocalFree ((HLOCAL(WINAPI*)(HLOCAL))aSyscall[46].pCurrent)†Ÿ(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTŸE  { "LockFile",                (SYSCALL)LockFile,                0 },•#elseŸE  { "LockFile",                (SYSCALL)0,                       0 },¶#endif†≤#ifndef osLockFileŸ>#define osLockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ÿ%        DWORD))aSyscall[47].pCurrent)¶#endif†¥#if !SQLITE_OS_WINCEŸE  { "LockFileEx",              (SYSCALL)LockFileEx,              0 },•#elseŸE  { "LockFileEx",              (SYSCALL)0,                       0 },¶#endif†¥#ifndef osLockFileExŸF#define osLockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,DWORD, \Ÿ,        LPOVERLAPPED))aSyscall[48].pCurrent)¶#endif†Ÿ-#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && \Ÿ>        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))ŸE  { "MapViewOfFile",           (SYSCALL)MapViewOfFile,           0 },•#elseŸE  { "MapViewOfFile",           (SYSCALL)0,                       0 },¶#endif†ŸE#define osMapViewOfFile ((LPVOID(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ÿ&        SIZE_T))aSyscall[49].pCurrent)†ŸE  { "MultiByteToWideChar",     (SYSCALL)MultiByteToWideChar,     0 },†ŸL#define osMultiByteToWideChar ((int(WINAPI*)(UINT,DWORD,LPCSTR,int,LPWSTR, \Ÿ#        int))aSyscall[50].pCurrent)†ŸE  { "QueryPerformanceCounter", (SYSCALL)QueryPerformanceCounter, 0 },†Ÿ4#define osQueryPerformanceCounter ((BOOL(WINAPI*)( \Ÿ.        LARGE_INTEGER*))aSyscall[51].pCurrent)†ŸE  { "ReadFile",                (SYSCALL)ReadFile,                0 },†ŸA#define osReadFile ((BOOL(WINAPI*)(HANDLE,LPVOID,DWORD,LPDWORD, \Ÿ,        LPOVERLAPPED))aSyscall[52].pCurrent)†ŸE  { "SetEndOfFile",            (SYSCALL)SetEndOfFile,            0 },†ŸE#define osSetEndOfFile ((BOOL(WINAPI*)(HANDLE))aSyscall[53].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "SetFilePointer",          (SYSCALL)SetFilePointer,          0 },•#elseŸE  { "SetFilePointer",          (SYSCALL)0,                       0 },¶#endif†Ÿ>#define osSetFilePointer ((DWORD(WINAPI*)(HANDLE,LONG,PLONG, \Ÿ%        DWORD))aSyscall[54].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "Sleep",                   (SYSCALL)Sleep,                   0 },•#elseŸE  { "Sleep",                   (SYSCALL)0,                       0 },¶#endif†Ÿ=#define osSleep ((VOID(WINAPI*)(DWORD))aSyscall[55].pCurrent)†ŸE  { "SystemTimeToFileTime",    (SYSCALL)SystemTimeToFileTime,    0 },†ŸC#define osSystemTimeToFileTime ((BOOL(WINAPI*)(CONST SYSTEMTIME*, \Ÿ*        LPFILETIME))aSyscall[56].pCurrent)†Ÿ(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTŸE  { "UnlockFile",              (SYSCALL)UnlockFile,              0 },•#elseŸE  { "UnlockFile",              (SYSCALL)0,                       0 },¶#endif†¥#ifndef osUnlockFileŸ@#define osUnlockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ÿ%        DWORD))aSyscall[57].pCurrent)¶#endif†¥#if !SQLITE_OS_WINCEŸE  { "UnlockFileEx",            (SYSCALL)UnlockFileEx,            0 },•#elseŸE  { "UnlockFileEx",            (SYSCALL)0,                       0 },¶#endif†ŸB#define osUnlockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ÿ,        LPOVERLAPPED))aSyscall[58].pCurrent)†ŸJ#if SQLITE_OS_WINCE || !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0ŸE  { "UnmapViewOfFile",         (SYSCALL)UnmapViewOfFile,         0 },•#elseŸE  { "UnmapViewOfFile",         (SYSCALL)0,                       0 },¶#endif†ŸI#define osUnmapViewOfFile ((BOOL(WINAPI*)(LPCVOID))aSyscall[59].pCurrent)†ŸE  { "WideCharToMultiByte",     (SYSCALL)WideCharToMultiByte,     0 },†ŸP#define osWideCharToMultiByte ((int(WINAPI*)(UINT,DWORD,LPCWSTR,int,LPSTR,int, \Ÿ-        LPCSTR,LPBOOL))aSyscall[60].pCurrent)†ŸE  { "WriteFile",               (SYSCALL)WriteFile,               0 },†ŸC#define osWriteFile ((BOOL(WINAPI*)(HANDLE,LPCVOID,DWORD,LPDWORD, \Ÿ,        LPOVERLAPPED))aSyscall[61].pCurrent)†≥#if SQLITE_OS_WINRTŸE  { "CreateEventExW",          (SYSCALL)CreateEventExW,          0 },•#elseŸE  { "CreateEventExW",          (SYSCALL)0,                       0 },¶#endif†ŸK#define osCreateEventExW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,LPCWSTR, \Ÿ+        DWORD,DWORD))aSyscall[62].pCurrent)†¥#if !SQLITE_OS_WINRTŸE  { "WaitForSingleObject",     (SYSCALL)WaitForSingleObject,     0 },•#elseŸE  { "WaitForSingleObject",     (SYSCALL)0,                       0 },¶#endif†Ÿ8#define osWaitForSingleObject ((DWORD(WINAPI*)(HANDLE, \Ÿ%        DWORD))aSyscall[63].pCurrent)†¥#if !SQLITE_OS_WINCEŸE  { "WaitForSingleObjectEx",   (SYSCALL)WaitForSingleObjectEx,   0 },•#elseŸE  { "WaitForSingleObjectEx",   (SYSCALL)0,                       0 },¶#endif†Ÿ@#define osWaitForSingleObjectEx ((DWORD(WINAPI*)(HANDLE,DWORD, \Ÿ$        BOOL))aSyscall[64].pCurrent)†≥#if SQLITE_OS_WINRTŸE  { "SetFilePointerEx",        (SYSCALL)SetFilePointerEx,        0 },•#elseŸE  { "SetFilePointerEx",        (SYSCALL)0,                       0 },¶#endif†ŸB#define osSetFilePointerEx ((BOOL(WINAPI*)(HANDLE,LARGE_INTEGER, \Ÿ4        PLARGE_INTEGER,DWORD))aSyscall[65].pCurrent)†≥#if SQLITE_OS_WINRTŸO  { "GetFileInformationByHandleEx", (SYSCALL)GetFileInformationByHandleEx, 0 },•#elseŸE  { "GetFileInformationByHandleEx", (SYSCALL)0,                  0 },¶#endif†Ÿ@#define osGetFileInformationByHandleEx ((BOOL(WINAPI*)(HANDLE, \ŸF        FILE_INFO_BY_HANDLE_CLASS,LPVOID,DWORD))aSyscall[66].pCurrent)†ŸL#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)ŸE  { "MapViewOfFileFromApp",    (SYSCALL)MapViewOfFileFromApp,    0 },•#elseŸE  { "MapViewOfFileFromApp",    (SYSCALL)0,                       0 },¶#endif†ŸH#define osMapViewOfFileFromApp ((LPVOID(WINAPI*)(HANDLE,ULONG,ULONG64, \Ÿ&        SIZE_T))aSyscall[67].pCurrent)†≥#if SQLITE_OS_WINRTŸE  { "CreateFile2",             (SYSCALL)CreateFile2,             0 },•#elseŸE  { "CreateFile2",             (SYSCALL)0,                       0 },¶#endif†ŸD#define osCreateFile2 ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD,DWORD, \ŸA        LPCREATEFILE2_EXTENDED_PARAMETERS))aSyscall[68].pCurrent)†Ÿ;#if SQLITE_OS_WINRT && !defined(SQLITE_OMIT_LOAD_EXTENSION)ŸE  { "LoadPackagedLibrary",     (SYSCALL)LoadPackagedLibrary,     0 },•#elseŸE  { "LoadPackagedLibrary",     (SYSCALL)0,                       0 },¶#endif†Ÿ;#define osLoadPackagedLibrary ((HMODULE(WINAPI*)(LPCWSTR, \Ÿ%        DWORD))aSyscall[69].pCurrent)†≥#if SQLITE_OS_WINRTŸE  { "GetTickCount64",          (SYSCALL)GetTickCount64,          0 },•#elseŸE  { "GetTickCount64",          (SYSCALL)0,                       0 },¶#endif†ŸJ#define osGetTickCount64 ((ULONGLONG(WINAPI*)(VOID))aSyscall[70].pCurrent)†≥#if SQLITE_OS_WINRTŸE  { "GetNativeSystemInfo",     (SYSCALL)GetNativeSystemInfo,     0 },•#elseŸE  { "GetNativeSystemInfo",     (SYSCALL)0,                       0 },¶#endif†Ÿ0#define osGetNativeSystemInfo ((VOID(WINAPI*)( \Ÿ-        LPSYSTEM_INFO))aSyscall[71].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)ŸE  { "OutputDebugStringA",      (SYSCALL)OutputDebugStringA,      0 },•#elseŸE  { "OutputDebugStringA",      (SYSCALL)0,                       0 },¶#endif†ŸK#define osOutputDebugStringA ((VOID(WINAPI*)(LPCSTR))aSyscall[72].pCurrent)†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)ŸE  { "OutputDebugStringW",      (SYSCALL)OutputDebugStringW,      0 },•#elseŸE  { "OutputDebugStringW",      (SYSCALL)0,                       0 },¶#endif†ŸL#define osOutputDebugStringW ((VOID(WINAPI*)(LPCWSTR))aSyscall[73].pCurrent)†ŸE  { "GetProcessHeap",          (SYSCALL)GetProcessHeap,          0 },†ŸG#define osGetProcessHeap ((HANDLE(WINAPI*)(VOID))aSyscall[74].pCurrent)†ŸL#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)ŸG  { "CreateFileMappingFromApp", (SYSCALL)CreateFileMappingFromApp, 0 },•#elseŸE  { "CreateFileMappingFromApp", (SYSCALL)0,                      0 },¶#endif†Ÿ>#define osCreateFileMappingFromApp ((HANDLE(WINAPI*)(HANDLE, \ŸK        LPSECURITY_ATTRIBUTES,ULONG,ULONG64,LPCWSTR))aSyscall[75].pCurrent)†¢/*ŸI** NOTE: On some sub-platforms, the InterlockedCompareExchange "function"ŸJ**       is really just a macro that uses a compiler intrinsic (e.g. x64).ŸD**       So do not try to make this is into a redefinable interface.¢*/Ÿ'#if defined(InterlockedCompareExchange)ŸE  { "InterlockedCompareExchange", (SYSCALL)0,                    0 },†Ÿ?#define osInterlockedCompareExchange InterlockedCompareExchange•#elseŸK  { "InterlockedCompareExchange", (SYSCALL)InterlockedCompareExchange, 0 },†Ÿ;#define osInterlockedCompareExchange ((LONG(WINAPI*)(LONG \ŸA        SQLITE_WIN32_VOLATILE*, LONG,LONG))aSyscall[76].pCurrent)Ÿ0#endif /* defined(InterlockedCompareExchange) */†ŸA#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUIDŸE  { "UuidCreate",               (SYSCALL)UuidCreate,             0 },•#elseŸE  { "UuidCreate",               (SYSCALL)0,                      0 },¶#endif†ŸK#define osUuidCreate ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[77].pCurrent)†ŸA#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUIDŸE  { "UuidCreateSequential",     (SYSCALL)UuidCreateSequential,   0 },•#elseŸE  { "UuidCreateSequential",     (SYSCALL)0,                      0 },¶#endif†Ÿ #define osUuidCreateSequential \Ÿ>        ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[78].pCurrent)†Ÿ6#if !defined(SQLITE_NO_SYNC) && SQLITE_MAX_MMAP_SIZE>0ŸE  { "FlushViewOfFile",          (SYSCALL)FlushViewOfFile,        0 },•#elseŸE  { "FlushViewOfFile",          (SYSCALL)0,                      0 },¶#endif†ª#define osFlushViewOfFile \Ÿ>        ((BOOL(WINAPI*)(LPCVOID,SIZE_T))aSyscall[79].pCurrent)†Ÿ-}; /* End of the overrideable system calls */†¢/*ŸD** This is the xSetSystemCall() method of sqlite3_vfs for all of theŸB** "win32" VFSes.  Return SQLITE_OK opon successfully updating theŸF** system call pointer, or SQLITE_NOTFOUND if there is no configurableª** system call named zName.¢*/ºstatic int winSetSystemCall(Ÿ@  sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */ŸE  const char *zName,            /* Name of system call to override */ŸF  sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */¢){±  unsigned int i;ª  int rc = SQLITE_NOTFOUND;†Ω  UNUSED_PARAMETER(pNotUsed);±  if( zName==0 ){ŸF    /* If no zName is given, restore all system calls to their defaultø    ** settings and return NULL¶    */≥    rc = SQLITE_OK;Ÿ:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ÿ!      if( aSyscall[i].pDefault ){Ÿ4        aSyscall[i].pCurrent = aSyscall[i].pDefault;ß      }•    }®  }else{ŸA    /* If zName is specified, operate on only the one system call±    ** specified.¶    */Ÿ:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ÿ0      if( strcmp(zName, aSyscall[i].zName)==0 ){Ÿ&        if( aSyscall[i].pDefault==0 ){Ÿ6          aSyscall[i].pDefault = aSyscall[i].pCurrent;©        }∑        rc = SQLITE_OK;Ÿ:        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;Ÿ(        aSyscall[i].pCurrent = pNewFunc;Æ        break;ß      }•    }£  }¨  return rc;°}†¢/*ŸD** Return the value of a system call.  Return NULL if zName is not aŸI** recognized system call name.  NULL is also returned if the system call∫** is currently undefined.¢*/Ÿ,static sqlite3_syscall_ptr winGetSystemCall(∏  sqlite3_vfs *pNotUsed,≥  const char *zName¢){±  unsigned int i;†Ω  UNUSED_PARAMETER(pNotUsed);Ÿ8  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){ŸJ    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;£  }´  return 0;°}†¢/*ŸH** Return the name of the first system call after zName.  If zName==NULLŸG** then return the name of the first system call.  Return NULL if zNameŸA** is the last system call or if zName is not the name of a validØ** system call.¢*/ŸHstatic const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){≠  int i = -1;†∂  UNUSED_PARAMETER(p);Æ  if( zName ){Ÿ+    for(i=0; i<ArraySize(aSyscall)-1; i++){Ÿ6      if( strcmp(zName, aSyscall[i].zName)==0 ) break;•    }£  }Ÿ'  for(i++; i<ArraySize(aSyscall); i++){Ÿ;    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;£  }´  return 0;°}†∫#ifdef SQLITE_WIN32_MALLOC¢/*ŸL** If a Win32 native heap has been configured, this function will attempt toŸL** compact it.  Upon success, SQLITE_OK will be returned.  Upon failure, oneŸK** of SQLITE_NOMEM, SQLITE_ERROR, or SQLITE_NOTFOUND will be returned.  TheŸL** "pnLargest" argument, if non-zero, will be used to return the size of theŸ6** largest committed free block in the heap, in bytes.¢*/Ÿ<SQLITE_API int sqlite3_win32_compact_heap(LPUINT pnLargest){µ  int rc = SQLITE_OK;¥  UINT nLargest = 0;Ø  HANDLE hHeap;†∂  winMemAssertMagic();∫  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ÿ(  assert( hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ŸA  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¶#endifŸ(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTŸD  if( (nLargest=osHeapCompact(hHeap, SQLITE_WIN32_HEAP_FLAGS))==0 ){Ÿ'    DWORD lastErrno = osGetLastError();æ    if( lastErrno==NO_ERROR ){ŸL      sqlite3_log(SQLITE_NOMEM, "failed to HeapCompact (no space), heap=%p",Ÿ                   (void*)hHeap);Ω      rc = SQLITE_NOMEM_BKPT;™    }else{ŸG      sqlite3_log(SQLITE_ERROR, "failed to HeapCompact (%lu), heap=%p",Ÿ2                  osGetLastError(), (void*)hHeap);∏      rc = SQLITE_ERROR;•    }£  }•#elseŸ@  sqlite3_log(SQLITE_NOTFOUND, "failed to HeapCompact, heap=%p",º              (void*)hHeap);∑  rc = SQLITE_NOTFOUND;¶#endifŸ(  if( pnLargest ) *pnLargest = nLargest;¨  return rc;°}†¢/*ŸL** If a Win32 native heap has been configured, this function will attempt toŸL** destroy and recreate it.  If the Win32 native heap is not isolated and/orŸL** the sqlite3_memory_used() function does not return zero, SQLITE_BUSY willŸD** be returned and no changes will be made to the Win32 native heap.¢*/Ÿ*SQLITE_API int sqlite3_win32_reset_heap(){©  int rc;ŸD  MUTEX_LOGIC( sqlite3_mutex *pMaster; ) /* The main static mutex */ŸF  MUTEX_LOGIC( sqlite3_mutex *pMem; )    /* The memsys static mutex */ŸI  MUTEX_LOGIC( pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )ŸC  MUTEX_LOGIC( pMem = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); )ø  sqlite3_mutex_enter(pMaster);º  sqlite3_mutex_enter(pMem);∂  winMemAssertMagic();ŸN  if( winMemGetHeap()!=NULL && winMemGetOwned() && sqlite3_memory_used()==0 ){¶    /*ŸJ    ** At this point, there should be no outstanding memory allocations onŸL    ** the heap.  Also, since both the master and memsys locks are currentlyŸL    ** being held by us, no other function (i.e. from another thread) shouldŸL    ** be able to even access the heap.  Attempt to destroy and recreate ourŸ&    ** isolated Win32 native heap now.¶    */Ÿ$    assert( winMemGetHeap()!=NULL );ø    assert( winMemGetOwned() );Ÿ'    assert( sqlite3_memory_used()==0 );Ÿ'    winMemShutdown(winMemGetDataPtr());Ÿ$    assert( winMemGetHeap()==NULL );Ÿ     assert( !winMemGetOwned() );Ÿ'    assert( sqlite3_memory_used()==0 );Ÿ(    rc = winMemInit(winMemGetDataPtr());Ÿ5    assert( rc!=SQLITE_OK || winMemGetHeap()!=NULL );Ÿ0    assert( rc!=SQLITE_OK || winMemGetOwned() );Ÿ8    assert( rc!=SQLITE_OK || sqlite3_memory_used()==0 );®  }else{¶    /*ŸI    ** The Win32 native heap cannot be modified because it may be in use.¶    */µ    rc = SQLITE_BUSY;£  }º  sqlite3_mutex_leave(pMem);ø  sqlite3_mutex_leave(pMaster);¨  return rc;°}Ÿ #endif /* SQLITE_WIN32_MALLOC */†¢/*ŸJ** This function outputs the specified (ANSI) string to the Win32 debugger≤** (if available).¢*/†ŸFSQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf){Ÿ*  char zDbgBuf[SQLITE_WIN32_DBG_BUF_SIZE];ŸO  int nMin = MIN(nBuf, (SQLITE_WIN32_DBG_BUF_SIZE - 1)); /* may be negative. */Ÿ?  if( nMin<-1 ) nMin = -1; /* all negative values become -1. */ŸB  assert( nMin==-1 || nMin==0 || nMin<SQLITE_WIN32_DBG_BUF_SIZE );æ#ifdef SQLITE_ENABLE_API_ARMORÆ  if( !zBuf ){Ω    (void)SQLITE_MISUSE_BKPT;´    return;£  }¶#endifŸ"#if defined(SQLITE_WIN32_HAS_ANSI)Ø  if( nMin>0 ){Ÿ2    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);Ÿ     memcpy(zDbgBuf, zBuf, nMin);Ÿ"    osOutputDebugStringA(zDbgBuf);®  }else{ø    osOutputDebugStringA(zBuf);£  }Ÿ$#elif defined(SQLITE_WIN32_HAS_WIDE)Ÿ0  memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);Ω  if ( osMultiByteToWideChar(Ÿ;          osAreFileApisANSI() ? CP_ACP : CP_OEMCP, 0, zBuf,ŸO          nMin, (LPWSTR)zDbgBuf, SQLITE_WIN32_DBG_BUF_SIZE/sizeof(WCHAR))<=0 ){´    return;£  }Ÿ)  osOutputDebugStringW((LPCWSTR)zDbgBuf);•#elseØ  if( nMin>0 ){Ÿ2    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);Ÿ     memcpy(zDbgBuf, zBuf, nMin);Ÿ#    fprintf(stderr, "%s", zDbgBuf);®  }else{Ÿ     fprintf(stderr, "%s", zBuf);£  }¶#endif°}†¢/*ŸD** The following routine suspends the current thread for at least msŸD** milliseconds.  This is equivalent to the Win32 Sleep() interface.¢*/≥#if SQLITE_OS_WINRTæstatic HANDLE sleepObj = NULL;¶#endif†Ÿ8SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds){≥#if SQLITE_OS_WINRT∏  if ( sleepObj==NULL ){ŸF    sleepObj = osCreateEventExW(NULL, NULL, CREATE_EVENT_MANUAL_RESET,Ÿ-                                SYNCHRONIZE);£  }ª  assert( sleepObj!=NULL );Ÿ9  osWaitForSingleObjectEx(sleepObj, milliseconds, FALSE);•#else∏  osSleep(milliseconds);¶#endif°}†ŸL#if SQLITE_MAX_WORKER_THREADS>0 && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \ª        SQLITE_THREADSAFE>0Ÿ6SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject){´  DWORD rc;Ÿ9  while( (rc = osWaitForSingleObjectEx(hObject, INFINITE,ŸE                                       TRUE))==WAIT_IO_COMPLETION ){}¨  return rc;°}¶#endif†¢/*ŸF** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,Ÿ=** or WinCE.  Return false (zero) for Win95, Win98, or WinME.¢**ŸD** Here is an interesting observation:  Win95, Win98, and WinME lackŸG** the LockFileEx() API.  But we can still statically link against thatŸG** API as long as we don't call it when running Win95/98/ME.  A call toŸB** this routine is used to determine if the host is Win95/98/ME orŸE** WinNT/2K/XP so that we will know whether or not we can safely call∏** the LockFileEx() API.¢*/†æ#if !SQLITE_WIN32_GETVERSIONEX∂# define osIsNT()  (1)ŸK#elif SQLITE_OS_WINCE || SQLITE_OS_WINRT || !defined(SQLITE_WIN32_HAS_ANSI)∂# define osIsNT()  (1)Ÿ%#elif !defined(SQLITE_WIN32_HAS_WIDE)∂# define osIsNT()  (0)•#elseŸB# define osIsNT()  ((sqlite3_os_type==2) || sqlite3_win32_is_nt())¶#endif†¢/*ŸJ** This function determines if the machine is running a version of Windows∫** based on the NT kernel.¢*/Ÿ)SQLITE_API int sqlite3_win32_is_nt(void){≥#if SQLITE_OS_WINRT§  /*ŸI  ** NOTE: The WinRT sub-platform is always assumed to be based on the NT≤  **       kernel.§  */´  return 1;ø#elif SQLITE_WIN32_GETVERSIONEXŸ@  if( osInterlockedCompareExchange(&sqlite3_os_type, 0, 0)==0 ){Ÿ"#if defined(SQLITE_WIN32_HAS_ANSI)π    OSVERSIONINFOA sInfo;Ÿ.    sInfo.dwOSVersionInfoSize = sizeof(sInfo);º    osGetVersionExA(&sInfo);Ÿ2    osInterlockedCompareExchange(&sqlite3_os_type,ŸB        (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);Ÿ$#elif defined(SQLITE_WIN32_HAS_WIDE)π    OSVERSIONINFOW sInfo;Ÿ.    sInfo.dwOSVersionInfoSize = sizeof(sInfo);º    osGetVersionExW(&sInfo);Ÿ2    osInterlockedCompareExchange(&sqlite3_os_type,ŸB        (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);¶#endif£  }ŸA  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;±#elif SQLITE_TESTŸA  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;•#else§  /*ŸE  ** NOTE: All sub-platforms where the GetVersionEx[AW] functions areŸF  **       deprecated are always assumed to be based on the NT kernel.§  */´  return 1;¶#endif°}†∫#ifdef SQLITE_WIN32_MALLOC¢/*Ω** Allocate nBytes of memory.¢*/Ÿ&static void *winMemMalloc(int nBytes){Ø  HANDLE hHeap;™  void *p;†∂  winMemAssertMagic();∫  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ÿ(  assert( hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ŸA  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¶#endif∂  assert( nBytes>=0 );ŸB  p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);´  if( !p ){ŸL    sqlite3_log(SQLITE_NOMEM, "failed to HeapAlloc %u bytes (%lu), heap=%p",Ÿ8                nBytes, osGetLastError(), (void*)hHeap);£  }´  return p;°}†¢/*Ø** Free memory.¢*/Ÿ%static void winMemFree(void *pPrior){Ø  HANDLE hHeap;†∂  winMemAssertMagic();∫  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ÿ(  assert( hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ŸC  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );¶#endifŸD  if( !pPrior ) return; /* Passing NULL to HeapFree is undefined. */Ÿ<  if( !osHeapFree(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) ){ŸK    sqlite3_log(SQLITE_NOMEM, "failed to HeapFree block %p (%lu), heap=%p",Ÿ8                pPrior, osGetLastError(), (void*)hHeap);£  }°}†¢/*Ÿ3** Change the size of an existing memory allocation¢*/Ÿ5static void *winMemRealloc(void *pPrior, int nBytes){Ø  HANDLE hHeap;™  void *p;†∂  winMemAssertMagic();∫  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ÿ(  assert( hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ŸC  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );¶#endif∂  assert( nBytes>=0 );∞  if( !pPrior ){ŸD    p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);®  }else{ŸN    p = osHeapReAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior, (SIZE_T)nBytes);£  }´  if( !p ){ŸE    sqlite3_log(SQLITE_NOMEM, "failed to %s %u bytes (%lu), heap=%p",ŸO                pPrior ? "HeapReAlloc" : "HeapAlloc", nBytes, osGetLastError(),æ                (void*)hHeap);£  }´  return p;°}†¢/*Ÿ:** Return the size of an outstanding allocation, in bytes.¢*/østatic int winMemSize(void *p){Ø  HANDLE hHeap;´  SIZE_T n;†∂  winMemAssertMagic();∫  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ÿ(  assert( hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)Ÿ>  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, p) );¶#endif¥  if( !p ) return 0;Ÿ4  n = osHeapSize(hHeap, SQLITE_WIN32_HEAP_FLAGS, p);∂  if( n==(SIZE_T)-1 ){ŸK    sqlite3_log(SQLITE_NOMEM, "failed to HeapSize block %p (%lu), heap=%p",Ÿ3                p, osGetLastError(), (void*)hHeap);≠    return 0;£  }∞  return (int)n;°}†¢/*Ÿ=** Round up a request size to the next valid allocation size.¢*/Ÿ static int winMemRoundup(int n){´  return n;°}†¢/*∫** Initialize this module.¢*/Ÿ&static int winMemInit(void *pAppData){Ÿ3  winMemData *pWinMemData = (winMemData *)pAppData;†Ÿ)  if( !pWinMemData ) return SQLITE_ERROR;Ÿ/  assert( pWinMemData->magic1==WINMEM_MAGIC1 );Ÿ/  assert( pWinMemData->magic2==WINMEM_MAGIC2 );†Ÿ0#if !SQLITE_OS_WINRT && SQLITE_WIN32_HEAP_CREATEº  if( !pWinMemData->hHeap ){Ÿ6    DWORD dwInitialSize = SQLITE_WIN32_HEAP_INIT_SIZE;Ÿ;    DWORD dwMaximumSize = (DWORD)sqlite3GlobalConfig.nHeap;ª    if( dwMaximumSize==0 ){Ÿ1      dwMaximumSize = SQLITE_WIN32_HEAP_MAX_SIZE;Ÿ,    }else if( dwInitialSize>dwMaximumSize ){Ÿ$      dwInitialSize = dwMaximumSize;•    }Ÿ>    pWinMemData->hHeap = osHeapCreate(SQLITE_WIN32_HEAP_FLAGS,ŸD                                      dwInitialSize, dwMaximumSize);æ    if( !pWinMemData->hHeap ){ø      sqlite3_log(SQLITE_NOMEM,ŸL          "failed to HeapCreate (%lu), flags=%u, initSize=%lu, maxSize=%lu",ŸC          osGetLastError(), SQLITE_WIN32_HEAP_FLAGS, dwInitialSize,π          dwMaximumSize);ø      return SQLITE_NOMEM_BKPT;•    }ø    pWinMemData->bOwned = TRUE;Ÿ"    assert( pWinMemData->bOwned );£  }•#elseŸ*  pWinMemData->hHeap = osGetProcessHeap();º  if( !pWinMemData->hHeap ){Ω    sqlite3_log(SQLITE_NOMEM,Ÿ<        "failed to GetProcessHeap (%lu)", osGetLastError());Ω    return SQLITE_NOMEM_BKPT;£  }æ  pWinMemData->bOwned = FALSE;Ÿ!  assert( !pWinMemData->bOwned );¶#endifŸ"  assert( pWinMemData->hHeap!=0 );Ÿ5  assert( pWinMemData->hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ŸN  assert( osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¶#endif≥  return SQLITE_OK;°}†¢/*º** Deinitialize this module.¢*/Ÿ+static void winMemShutdown(void *pAppData){Ÿ3  winMemData *pWinMemData = (winMemData *)pAppData;†º  if( !pWinMemData ) return;Ÿ/  assert( pWinMemData->magic1==WINMEM_MAGIC1 );Ÿ/  assert( pWinMemData->magic2==WINMEM_MAGIC2 );†ª  if( pWinMemData->hHeap ){Ÿ7    assert( pWinMemData->hHeap!=INVALID_HANDLE_VALUE );Ÿ=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ŸP    assert( osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¶#endifæ    if( pWinMemData->bOwned ){Ÿ/      if( !osHeapDestroy(pWinMemData->hHeap) ){ŸI        sqlite3_log(SQLITE_NOMEM, "failed to HeapDestroy (%lu), heap=%p",ŸA                    osGetLastError(), (void*)pWinMemData->hHeap);ß      }Ÿ"      pWinMemData->bOwned = FALSE;•    }æ    pWinMemData->hHeap = NULL;£  }°}†¢/*Ÿ@** Populate the low-level memory allocation function pointers inŸH** sqlite3GlobalConfig.m with pointers to the routines in this file. TheŸ3** arguments specify the block of memory to manage.¢**ŸA** This routine is only called by sqlite3_config(), and thereforeŸ0** is not required to be threadsafe (it is not).¢*/ŸCSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void){Ÿ4  static const sqlite3_mem_methods winMemMethods = {±    winMemMalloc,Ø    winMemFree,≤    winMemRealloc,Ø    winMemSize,≤    winMemRoundup,Ø    winMemInit,≥    winMemShutdown,±    &win_mem_data§  };∏  return &winMemMethods;°}†Ÿ/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ÿ=  sqlite3_config(SQLITE_CONFIG_MALLOC, sqlite3MemGetWin32());°}Ÿ #endif /* SQLITE_WIN32_MALLOC */†¢/*Ÿ/** Convert a UTF-8 string to Microsoft Unicode.¢**ŸG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ÿ2static LPWSTR winUtf8ToUnicode(const char *zText){¨  int nChar;≥  LPWSTR zWideText;†Ÿ@  nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);±  if( nChar==0 ){≠    return 0;£  }Ÿ7  zWideText = sqlite3MallocZero( nChar*sizeof(WCHAR) );µ  if( zWideText==0 ){≠    return 0;£  }ŸA  nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText,Ÿ'                                nChar);±  if( nChar==0 ){º    sqlite3_free(zWideText);≤    zWideText = 0;£  }≥  return zWideText;°}†¢/*Ÿ/** Convert a Microsoft Unicode string to UTF-8.¢**ŸG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ÿ1static char *winUnicodeToUtf8(LPCWSTR zWideText){¨  int nByte;Æ  char *zText;†ŸG  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);≥  if( nByte == 0 ){≠    return 0;£  }Ÿ%  zText = sqlite3MallocZero( nByte );±  if( zText==0 ){≠    return 0;£  }ŸH  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte,Ÿ&                                0, 0);≥  if( nByte == 0 ){∏    sqlite3_free(zText);Æ    zText = 0;£  }Ø  return zText;°}†¢/*ŸE** Convert an ANSI string to Microsoft Unicode, using the ANSI or OEM≠** code page.¢**ŸG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ÿ?static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi){¨  int nByte;≥  LPWSTR zMbcsText;Ÿ-  int codepage = useAnsi ? CP_ACP : CP_OEMCP;†Ÿ=  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,Ÿ1                                0)*sizeof(WCHAR);±  if( nByte==0 ){≠    return 0;£  }Ÿ7  zMbcsText = sqlite3MallocZero( nByte*sizeof(WCHAR) );µ  if( zMbcsText==0 ){≠    return 0;£  }ŸB  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,Ÿ'                                nByte);±  if( nByte==0 ){º    sqlite3_free(zMbcsText);≤    zMbcsText = 0;£  }≥  return zMbcsText;°}†¢/*ŸG** Convert a Microsoft Unicode string to a multi-byte character string,Ÿ#** using the ANSI or OEM code page.¢**ŸG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ÿ>static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi){¨  int nByte;Æ  char *zText;Ÿ-  int codepage = useAnsi ? CP_ACP : CP_OEMCP;†ŸH  nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);≥  if( nByte == 0 ){≠    return 0;£  }Ÿ%  zText = sqlite3MallocZero( nByte );±  if( zText==0 ){≠    return 0;£  }ŸB  nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, zText,Ÿ-                                nByte, 0, 0);≥  if( nByte == 0 ){∏    sqlite3_free(zText);Æ    zText = 0;£  }Ø  return zText;°}†¢/*Ÿ2** Convert a multi-byte character string to UTF-8.¢**ŸG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ÿ;static char *winMbcsToUtf8(const char *zText, int useAnsi){≤  char *zTextUtf8;≤  LPWSTR zTmpWide;†Ÿ.  zTmpWide = winMbcsToUnicode(zText, useAnsi);¥  if( zTmpWide==0 ){≠    return 0;£  }Ÿ)  zTextUtf8 = winUnicodeToUtf8(zTmpWide);π  sqlite3_free(zTmpWide);≥  return zTextUtf8;°}†¢/*Ÿ;** Convert a UTF-8 string to a multi-byte character string.¢**ŸG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ÿ;static char *winUtf8ToMbcs(const char *zText, int useAnsi){≤  char *zTextMbcs;≤  LPWSTR zTmpWide;†Ÿ%  zTmpWide = winUtf8ToUnicode(zText);¥  if( zTmpWide==0 ){≠    return 0;£  }Ÿ2  zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);π  sqlite3_free(zTmpWide);≥  return zTextMbcs;°}†¢/*Ÿ@** This is a public wrapper for the winUtf8ToUnicode() function.¢*/ŸCSQLITE_API LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText){æ#ifdef SQLITE_ENABLE_API_ARMORØ  if( !zText ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ!  return winUtf8ToUnicode(zText);°}†¢/*Ÿ@** This is a public wrapper for the winUnicodeToUtf8() function.¢*/ŸBSQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText){æ#ifdef SQLITE_ENABLE_API_ARMOR≥  if( !zWideText ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ%  return winUnicodeToUtf8(zWideText);°}†¢/*Ÿ=** This is a public wrapper for the winMbcsToUtf8() function.¢*/Ÿ?SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zText){æ#ifdef SQLITE_ENABLE_API_ARMORØ  if( !zText ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ3  return winMbcsToUtf8(zText, osAreFileApisANSI());°}†¢/*Ÿ=** This is a public wrapper for the winMbcsToUtf8() function.¢*/ŸOSQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi){æ#ifdef SQLITE_ENABLE_API_ARMORØ  if( !zText ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ'  return winMbcsToUtf8(zText, useAnsi);°}†¢/*Ÿ=** This is a public wrapper for the winUtf8ToMbcs() function.¢*/Ÿ?SQLITE_API char *sqlite3_win32_utf8_to_mbcs(const char *zText){æ#ifdef SQLITE_ENABLE_API_ARMORØ  if( !zText ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ3  return winUtf8ToMbcs(zText, osAreFileApisANSI());°}†¢/*Ÿ=** This is a public wrapper for the winUtf8ToMbcs() function.¢*/ŸOSQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi){æ#ifdef SQLITE_ENABLE_API_ARMORØ  if( !zText ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endifº#ifndef SQLITE_OMIT_AUTOINITŸ&  if( sqlite3_initialize() ) return 0;¶#endifŸ'  return winUtf8ToMbcs(zText, useAnsi);°}†¢/*ŸL** This function sets the data directory or the temporary directory based onŸK** the provided arguments.  The type argument must be 1 in order to set theŸK** data directory or 2 in order to set the temporary directory.  The zValueŸJ** argument is the name of the directory to use.  The return value will beª** SQLITE_OK if successful.¢*/ŸGSQLITE_API int sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue){π  char **ppDirectory = 0;º#ifndef SQLITE_OMIT_AUTOINITŸ   int rc = sqlite3_initialize();µ  if( rc ) return rc;¶#endifŸ/  if( type==SQLITE_WIN32_DATA_DIRECTORY_TYPE ){Ÿ*    ppDirectory = &sqlite3_data_directory;Ÿ5  }else if( type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE ){Ÿ*    ppDirectory = &sqlite3_temp_directory;£  }Ÿ@  assert( !ppDirectory || type==SQLITE_WIN32_DATA_DIRECTORY_TYPEŸ3          || type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE§  );ŸO  assert( !ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP) );¥  if( ppDirectory ){π    char *zValueUtf8 = 0;æ    if( zValue && zValue[0] ){Ÿ,      zValueUtf8 = winUnicodeToUtf8(zValue);ª      if ( zValueUtf8==0 ){Ÿ!        return SQLITE_NOMEM_BKPT;ß      }•    }ø    sqlite3_free(*ppDirectory);æ    *ppDirectory = zValueUtf8;µ    return SQLITE_OK;£  }∂  return SQLITE_ERROR;°}†¢/*Ÿ)** The return value of winGetLastErrorMsgŸ?** is zero if the error message fits in the buffer, or non-zeroŸ,** otherwise (if the message was truncated).¢*/ŸEstatic int winGetLastErrorMsg(DWORD lastErrno, int nBuf, char *zBuf){Ÿ6  /* FormatMessage returns 0 on failure.  Otherwise itŸ7  ** returns the number of TCHARs written to the outputŸ1  ** buffer, excluding the terminating null char.§  */≤  DWORD dwLen = 0;±  char *zOut = 0;†±  if( osIsNT() ){≥#if SQLITE_OS_WINRTŸ5    WCHAR zTempWide[SQLITE_WIN32_MAX_ERRMSG_CHARS+1];Ÿ9    dwLen = osFormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |Ÿ;                             FORMAT_MESSAGE_IGNORE_INSERTS,Ÿ"                             NULL,Ÿ'                             lastErrno,ø                             0,Ÿ'                             zTempWide,Ÿ;                             SQLITE_WIN32_MAX_ERRMSG_CHARS,Ÿ                              0);•#elseº    LPWSTR zTempWide = NULL;Ÿ=    dwLen = osFormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |Ÿ9                             FORMAT_MESSAGE_FROM_SYSTEM |Ÿ;                             FORMAT_MESSAGE_IGNORE_INSERTS,Ÿ"                             NULL,Ÿ'                             lastErrno,ø                             0,Ÿ1                             (LPWSTR) &zTempWide,ø                             0,Ÿ                              0);¶#endif¥    if( dwLen > 0 ){Ÿ1      /* allocate a buffer and convert to UTF8 */Ÿ!      sqlite3BeginBenignMalloc();Ÿ)      zOut = winUnicodeToUtf8(zTempWide);ø      sqlite3EndBenignMalloc();¥#if !SQLITE_OS_WINRTŸ=      /* free the system buffer allocated by FormatMessage */Ω      osLocalFree(zTempWide);¶#endif•    }£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{∑    char *zTemp = NULL;Ÿ=    dwLen = osFormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |Ÿ9                             FORMAT_MESSAGE_FROM_SYSTEM |Ÿ;                             FORMAT_MESSAGE_IGNORE_INSERTS,Ÿ"                             NULL,Ÿ'                             lastErrno,ø                             0,Ÿ,                             (LPSTR) &zTemp,ø                             0,Ÿ                              0);¥    if( dwLen > 0 ){Ÿ1      /* allocate a buffer and convert to UTF8 */Ÿ!      sqlite3BeginBenignMalloc();Ÿ7      zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());ø      sqlite3EndBenignMalloc();Ÿ=      /* free the system buffer allocated by FormatMessage */π      osLocalFree(zTemp);•    }£  }¶#endif≥  if( 0 == dwLen ){ŸN    sqlite3_snprintf(nBuf, zBuf, "OsError 0x%lx (%lu)", lastErrno, lastErrno);®  }else{Ÿ7    /* copy a maximum of nBuf chars to output buffer */Ÿ-    sqlite3_snprintf(nBuf, zBuf, "%s", zOut);æ    /* free the UTF8 buffer */∑    sqlite3_free(zOut);£  }´  return 0;°}†¢/*¢**ŸJ** This function - winLogErrorAtLine() - is only ever called via the macro±** winLogError().¢**ŸC** This routine is invoked after an error occurs in an OS function.ŸH** It logs a message using sqlite3_log() containing the current value ofŸB** error code and, if possible, the human-readable equivalent from±** FormatMessage.¢**ŸG** The first argument passed to the macro should be the error code thatŸJ** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN).ŸJ** The two subsequent arguments should be the name of the OS function thatŸ6** failed and the associated file-system path, if any.¢*/ŸB#define winLogError(a,b,c,d)   winLogErrorAtLine(a,b,c,d,__LINE__)Ωstatic int winLogErrorAtLine(Ÿ9  int errcode,                    /* SQLite error code */Ÿ8  DWORD lastErrno,                /* Win32 last error */ŸG  const char *zFunc,              /* Name of OS function that failed */ŸG  const char *zPath,              /* File path associated with error */ŸO  int iLine                       /* Source line number where error occurred */¢){ŸA  char zMsg[500];                 /* Human readable error text */Ÿ4  int i;                          /* Loop counter */†Æ  zMsg[0] = 0;Ÿ4  winGetLastErrorMsg(lastErrno, sizeof(zMsg), zMsg);ø  assert( errcode!=SQLITE_OK );º  if( zPath==0 ) zPath = "";Ÿ<  for(i=0; zMsg[i] && zMsg[i]!='\r' && zMsg[i]!='\n'; i++){}Æ  zMsg[i] = 0;∂  sqlite3_log(errcode,Ÿ'      "os_win.c:%d: (%lu) %s(%s) - %s",Ÿ*      iLine, lastErrno, zFunc, zPath, zMsg§  );†±  return errcode;°}†¢/*ŸG** The number of times that a ReadFile(), WriteFile(), and DeleteFile()ŸA** will be retried following a locking error - probably caused byŸF** antivirus software.  Also the initial delay before the first retry.Ÿ0** The delay increases linearly with each retry.¢*/Ÿ #ifndef SQLITE_WIN32_IOERR_RETRYŸ$# define SQLITE_WIN32_IOERR_RETRY 10¶#endifŸ&#ifndef SQLITE_WIN32_IOERR_RETRY_DELAYŸ*# define SQLITE_WIN32_IOERR_RETRY_DELAY 25¶#endifŸ4static int winIoerrRetry = SQLITE_WIN32_IOERR_RETRY;Ÿ?static int winIoerrRetryDelay = SQLITE_WIN32_IOERR_RETRY_DELAY;†¢/*ŸI** The "winIoerrCanRetry1" macro is used to determine if a particular I/OŸH** error code obtained via GetLastError() is eligible to be retried.  ItŸJ** must accept the error code DWORD as its only argument and should returnŸF** non-zero if the error code is transient in nature and the operationŸI** responsible for generating the original error might succeed upon beingŸ=** retried.  The argument to this macro should be a variable.¢**ŸI** Additionally, a macro named "winIoerrCanRetry2" may be defined.  If itŸK** is defined, it will be consulted only when the macro "winIoerrCanRetry1"ŸJ** returns zero.  The "winIoerrCanRetry2" macro is completely optional andŸG** may be used to include additional error codes in the set that shouldŸG** result in the failing I/O operation being retried by the caller.  IfŸI** defined, the "winIoerrCanRetry2" macro must exhibit external semanticsŸ7** identical to those of the "winIoerrCanRetry1" macro.¢*/ø#if !defined(winIoerrCanRetry1)ŸD#define winIoerrCanRetry1(a) (((a)==ERROR_ACCESS_DENIED)        || \ŸD                              ((a)==ERROR_SHARING_VIOLATION)    || \ŸD                              ((a)==ERROR_LOCK_VIOLATION)       || \ŸD                              ((a)==ERROR_DEV_NOT_EXIST)        || \ŸD                              ((a)==ERROR_NETNAME_DELETED)      || \ŸD                              ((a)==ERROR_SEM_TIMEOUT)          || \Ÿ?                              ((a)==ERROR_NETWORK_UNREACHABLE))¶#endif†¢/*ŸC** If a ReadFile() or WriteFile() error occurs, invoke this routineŸG** to see if it should be retried.  Return TRUE to retry.  Return FALSEº** to give up with an error.¢*/Ÿ6static int winRetryIoerr(int *pnRetry, DWORD *pError){Ω  DWORD e = osGetLastError();Ÿ   if( *pnRetry>=winIoerrRetry ){±    if( pError ){≤      *pError = e;•    }≠    return 0;£  }Ω  if( winIoerrCanRetry1(e) ){Ÿ9    sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));Ø    ++*pnRetry;≠    return 1;£  }æ#if defined(winIoerrCanRetry2)Ÿ"  else if( winIoerrCanRetry2(e) ){Ÿ9    sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));Ø    ++*pnRetry;≠    return 1;£  }¶#endifØ  if( pError ){∞    *pError = e;£  }´  return 0;°}†¢/*Ÿ!** Log a I/O error retry episode.¢*/Ÿ0static void winLogIoerr(int nRetry, int lineno){Ø  if( nRetry ){æ    sqlite3_log(SQLITE_NOTICE,Ÿ:      "delayed %dms for lock/sharing conflict at line %d",Ÿ4      winIoerrRetryDelay*nRetry*(nRetry+1)/2, lineno¶    );£  }°}†¢/*ŸC** This #if does not rely on the SQLITE_OS_WINCE define because theŸ3** corresponding section in "date.c" cannot use it.¢*/Ÿ?#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) && \ŸG    (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)¢/*ŸB** The MSVC CRT on Windows CE may not have a localtime() function.∫** So define a substitute.¢*/π/* #  include <time.h> */Ÿ-struct tm *__cdecl localtime(const time_t *t)°{µ  static struct tm y;¥  FILETIME uTm, lTm;±  SYSTEMTIME pTm;¥  sqlite3_int64 t64;´  t64 = *t;Ÿ%  t64 = (t64 + 11644473600)*10000000;Ÿ0  uTm.dwLowDateTime = (DWORD)(t64 & 0xFFFFFFFF);Ÿ)  uTm.dwHighDateTime= (DWORD)(t64 >> 32);Ÿ'  osFileTimeToLocalFileTime(&uTm,&lTm);Ÿ$  osFileTimeToSystemTime(&lTm,&pTm);ø  y.tm_year = pTm.wYear - 1900;º  y.tm_mon = pTm.wMonth - 1;Ω  y.tm_wday = pTm.wDayOfWeek;∑  y.tm_mday = pTm.wDay;∏  y.tm_hour = pTm.wHour;π  y.tm_min = pTm.wMinute;π  y.tm_sec = pTm.wSecond;¨  return &y;°}¶#endif†≥#if SQLITE_OS_WINCEŸJ/*************************************************************************Ÿ-** This section contains code for WinCE only.¢*/ŸM#define HANDLE_TO_WINFILE(a) (winFile*)&((char*)a)[-(int)offsetof(winFile,h)]†¢/*Ÿ!** Acquire a lock on the handle h¢*/Ÿ(static void winceMutexAcquire(HANDLE h){Ø   DWORD dwErr;ß   do {Ÿ0     dwErr = osWaitForSingleObject(h, INFINITE);Ÿ?   } while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED);°}¢/*Ÿ1** Release a lock acquired by winceMutexAcquire()¢*/Ÿ,#define winceMutexRelease(h) ReleaseMutex(h)†¢/*ŸB** Create the mutex and shared memory used for locking in the file≥** descriptor pFile¢*/ŸBstatic int winceCreateLock(const char *zFilename, winFile *pFile){Æ  LPWSTR zTok;Ø  LPWSTR zName;≤  DWORD lastErrno;∑  BOOL bLogged = FALSE;¥  BOOL bInit = TRUE;†Ÿ&  zName = winUtf8ToUnicode(zFilename);±  if( zName==0 ){∑    /* out of memory */Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }†Ÿ%  /* Initialize the local lockdata */Ÿ1  memset(&pFile->local, 0, sizeof(pFile->local));†Ÿ?  /* Replace the backslashes from the filename and lowercase itø  ** to derive a mutex name. */Ω  zTok = osCharLowerW(zName);∂  for (;*zTok;zTok++){Ÿ#    if (*zTok == '\\') *zTok = '_';£  }†Ÿ#  /* Create/open the named mutex */Ÿ5  pFile->hMutex = osCreateMutexW(NULL, FALSE, zName);∂  if (!pFile->hMutex){Ÿ(    pFile->lastErrno = osGetLastError();∏    sqlite3_free(zName);Ÿ6    return winLogError(SQLITE_IOERR, pFile->lastErrno,Ÿ6                       "winceCreateLock1", zFilename);£  }†Ÿ+  /* Acquire the mutex before continuing */Ÿ#  winceMutexAcquire(pFile->hMutex);†ŸH  /* Since the names of named mutexes, semaphores, file mappings etc areŸI  ** case-sensitive, take advantage of that by uppercasing the mutex nameŸ3  ** and using that as the shared filemapping name.§  */∂  osCharUpperW(zName);ŸC  pFile->hShared = osCreateFileMappingW(INVALID_HANDLE_VALUE, NULL,ŸM                                        PAGE_READWRITE, 0, sizeof(winceLock),Ÿ/                                        zName);†ŸI  /* Set a flag that indicates we're the first to create the memory so itŸ   ** must be zero-initialized */ø  lastErrno = osGetLastError();Ÿ)  if (lastErrno == ERROR_ALREADY_EXISTS){≤    bInit = FALSE;£  }†∂  sqlite3_free(zName);†ŸC  /* If we succeeded in making the shared memory handle, map it. */∑  if( pFile->hShared ){Ÿ?    pFile->shared = (winceLock*)osMapViewOfFile(pFile->hShared,ŸD             FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, sizeof(winceLock));ŸH    /* If mapping failed, close the shared memory handle and erase it */π    if( !pFile->shared ){Ÿ*      pFile->lastErrno = osGetLastError();Ÿ1      winLogError(SQLITE_IOERR, pFile->lastErrno,Ÿ1                  "winceCreateLock2", zFilename);µ      bLogged = TRUE;Ÿ$      osCloseHandle(pFile->hShared);º      pFile->hShared = NULL;•    }£  }†ŸL  /* If shared memory could not be created, then close the mutex and fail */Ω  if( pFile->hShared==NULL ){≥    if( !bLogged ){Ÿ#      pFile->lastErrno = lastErrno;Ÿ1      winLogError(SQLITE_IOERR, pFile->lastErrno,Ÿ1                  "winceCreateLock3", zFilename);µ      bLogged = TRUE;•    }Ÿ%    winceMutexRelease(pFile->hMutex);Ÿ!    osCloseHandle(pFile->hMutex);π    pFile->hMutex = NULL;∏    return SQLITE_IOERR;£  }†Ÿ9  /* Initialize the shared memory if we're supposed to */Æ  if( bInit ){Ÿ0    memset(pFile->shared, 0, sizeof(winceLock));£  }†Ÿ#  winceMutexRelease(pFile->hMutex);≥  return SQLITE_OK;°}†¢/*Ÿ:** Destroy the part of winFile that deals with wince locks¢*/Ÿ-static void winceDestroyLock(winFile *pFile){µ  if (pFile->hMutex){ª    /* Acquire the mutex */Ÿ%    winceMutexAcquire(pFile->hMutex);†ŸJ    /* The following blocks should probably assert in debug mode, but theyŸ8       are to cleanup in case any locks remained open */ø    if (pFile->local.nReaders){Ÿ!      pFile->shared->nReaders --;•    }Ÿ     if (pFile->local.bReserved){Ÿ'      pFile->shared->bReserved = FALSE;•    }ø    if (pFile->local.bPending){Ÿ&      pFile->shared->bPending = FALSE;•    }Ÿ!    if (pFile->local.bExclusive){Ÿ(      pFile->shared->bExclusive = FALSE;•    }†ŸE    /* De-reference and close our copy of the shared memory handle */Ÿ%    osUnmapViewOfFile(pFile->shared);Ÿ"    osCloseHandle(pFile->hShared);†Ω    /* Done with the mutex */Ÿ%    winceMutexRelease(pFile->hMutex);Ÿ!    osCloseHandle(pFile->hMutex);π    pFile->hMutex = NULL;£  }°}†¢/*Ÿ<** An implementation of the LockFile() API of Windows for CE¢*/∫static BOOL winceLockFile(≤  LPHANDLE phFile,∏  DWORD dwFileOffsetLow,π  DWORD dwFileOffsetHigh,Ÿ   DWORD nNumberOfBytesToLockLow,Ÿ   DWORD nNumberOfBytesToLockHigh¢){Ÿ-  winFile *pFile = HANDLE_TO_WINFILE(phFile);∑  BOOL bReturn = FALSE;†Ÿ%  UNUSED_PARAMETER(dwFileOffsetHigh);Ÿ-  UNUSED_PARAMETER(nNumberOfBytesToLockHigh);†Ÿ"  if (!pFile->hMutex) return TRUE;Ÿ#  winceMutexAcquire(pFile->hMutex);†Ÿ"  /* Wanting an exclusive lock? */Ÿ,  if (dwFileOffsetLow == (DWORD)SHARED_FIRSTŸ9       && nNumberOfBytesToLockLow == (DWORD)SHARED_SIZE){ŸH    if (pFile->shared->nReaders == 0 && pFile->shared->bExclusive == 0){Ÿ(       pFile->shared->bExclusive = TRUE;Ÿ&       pFile->local.bExclusive = TRUE;∂       bReturn = TRUE;•    }£  }†æ  /* Want a read-only lock? */Ÿ4  else if (dwFileOffsetLow == (DWORD)SHARED_FIRST &&Ÿ)           nNumberOfBytesToLockLow == 1){Ÿ(    if (pFile->shared->bExclusive == 0){ø      pFile->local.nReaders ++;Ÿ&      if (pFile->local.nReaders == 1){Ÿ#        pFile->shared->nReaders ++;ß      }µ      bReturn = TRUE;•    }£  }†º  /* Want a pending lock? */Ÿ1  else if (dwFileOffsetLow == (DWORD)PENDING_BYTEŸ,           && nNumberOfBytesToLockLow == 1){Ÿ?    /* If no pending lock has been acquired, then acquire it */Ÿ'    if (pFile->shared->bPending == 0) {Ÿ%      pFile->shared->bPending = TRUE;Ÿ#      pFile->local.bPending = TRUE;µ      bReturn = TRUE;•    }£  }†Ω  /* Want a reserved lock? */Ÿ2  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTEŸ,           && nNumberOfBytesToLockLow == 1){Ÿ(    if (pFile->shared->bReserved == 0) {Ÿ&      pFile->shared->bReserved = TRUE;Ÿ$      pFile->local.bReserved = TRUE;µ      bReturn = TRUE;•    }£  }†Ÿ#  winceMutexRelease(pFile->hMutex);±  return bReturn;°}†¢/*Ÿ<** An implementation of the UnlockFile API of Windows for CE¢*/ºstatic BOOL winceUnlockFile(≤  LPHANDLE phFile,∏  DWORD dwFileOffsetLow,π  DWORD dwFileOffsetHigh,Ÿ"  DWORD nNumberOfBytesToUnlockLow,Ÿ"  DWORD nNumberOfBytesToUnlockHigh¢){Ÿ-  winFile *pFile = HANDLE_TO_WINFILE(phFile);∑  BOOL bReturn = FALSE;†Ÿ%  UNUSED_PARAMETER(dwFileOffsetHigh);Ÿ/  UNUSED_PARAMETER(nNumberOfBytesToUnlockHigh);†Ÿ"  if (!pFile->hMutex) return TRUE;Ÿ#  winceMutexAcquire(pFile->hMutex);†Ÿ4  /* Releasing a reader lock or an exclusive lock */Ÿ.  if (dwFileOffsetLow == (DWORD)SHARED_FIRST){Ÿ(    /* Did we have an exclusive lock? */Ÿ!    if (pFile->local.bExclusive){Ÿ>      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE);Ÿ&      pFile->local.bExclusive = FALSE;Ÿ(      pFile->shared->bExclusive = FALSE;µ      bReturn = TRUE;•    }†Ÿ)    /* Did we just have a reader lock? */Ÿ$    else if (pFile->local.nReaders){Ÿ<      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZEŸ0             || nNumberOfBytesToUnlockLow == 1);ø      pFile->local.nReaders --;Ÿ%      if (pFile->local.nReaders == 0)ß      {Ÿ#        pFile->shared->nReaders --;ß      }µ      bReturn = TRUE;•    }£  }†Ÿ   /* Releasing a pending lock */Ÿ1  else if (dwFileOffsetLow == (DWORD)PENDING_BYTEŸ.           && nNumberOfBytesToUnlockLow == 1){ø    if (pFile->local.bPending){Ÿ$      pFile->local.bPending = FALSE;Ÿ&      pFile->shared->bPending = FALSE;µ      bReturn = TRUE;•    }£  }Ÿ!  /* Releasing a reserved lock */Ÿ2  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTEŸ.           && nNumberOfBytesToUnlockLow == 1){Ÿ!    if (pFile->local.bReserved) {Ÿ%      pFile->local.bReserved = FALSE;Ÿ'      pFile->shared->bReserved = FALSE;µ      bReturn = TRUE;•    }£  }†Ÿ#  winceMutexRelease(pFile->hMutex);±  return bReturn;°}¢/*Ÿ$** End of the special code for winceŸN*****************************************************************************/º#endif /* SQLITE_OS_WINCE */†¢/*∂** Lock a file region.¢*/∏static BOOL winLockFile(≤  LPHANDLE phFile,Æ  DWORD flags,≤  DWORD offsetLow,≥  DWORD offsetHigh,¥  DWORD numBytesLow,¥  DWORD numBytesHigh¢){≥#if SQLITE_OS_WINCE§  /*ŸK  ** NOTE: Windows CE is handled differently here due its lack of the Win32∏  **       API LockFile.§  */Ÿ5  return winceLockFile(phFile, offsetLow, offsetHigh,Ÿ2                       numBytesLow, numBytesHigh);•#else±  if( osIsNT() ){¥    OVERLAPPED ovlp;Ÿ)    memset(&ovlp, 0, sizeof(OVERLAPPED));º    ovlp.Offset = offsetLow;Ÿ!    ovlp.OffsetHigh = offsetHigh;ŸM    return osLockFileEx(*phFile, flags, 0, numBytesLow, numBytesHigh, &ovlp);®  }else{ŸB    return osLockFile(*phFile, offsetLow, offsetHigh, numBytesLow,Ÿ$                      numBytesHigh);£  }¶#endif°}†¢/*∏** Unlock a file region.£ */∫static BOOL winUnlockFile(≤  LPHANDLE phFile,≤  DWORD offsetLow,≥  DWORD offsetHigh,¥  DWORD numBytesLow,¥  DWORD numBytesHigh¢){≥#if SQLITE_OS_WINCE§  /*ŸK  ** NOTE: Windows CE is handled differently here due its lack of the Win32∫  **       API UnlockFile.§  */Ÿ7  return winceUnlockFile(phFile, offsetLow, offsetHigh,Ÿ4                         numBytesLow, numBytesHigh);•#else±  if( osIsNT() ){¥    OVERLAPPED ovlp;Ÿ)    memset(&ovlp, 0, sizeof(OVERLAPPED));º    ovlp.Offset = offsetLow;Ÿ!    ovlp.OffsetHigh = offsetHigh;ŸH    return osUnlockFileEx(*phFile, 0, numBytesLow, numBytesHigh, &ovlp);®  }else{ŸD    return osUnlockFile(*phFile, offsetLow, offsetHigh, numBytesLow,Ÿ&                        numBytesHigh);£  }¶#endif°}†ŸN/*****************************************************************************ŸA** The next group of routines implement the I/O methods specifiedŸ$** by the sqlite3_io_methods object.ŸO******************************************************************************/†¢/*Ÿ1** Some Microsoft compilers lack this definition.¢*/Ÿ #ifndef INVALID_SET_FILE_POINTERŸ-# define INVALID_SET_FILE_POINTER ((DWORD)-1)¶#endif†¢/*ŸC** Move the current position of the file handle passed as the firstŸG** argument to offset iOffset within the file. If successful, return 0.Ÿ7** Otherwise, set pFile->lastErrno and return non-zero.¢*/Ÿ>static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset){¥#if !SQLITE_OS_WINRTŸG  LONG upperBits;                 /* Most sig. 32 bits of new offset */ŸH  LONG lowerBits;                 /* Least sig. 32 bits of new offset */ŸJ  DWORD dwRet;                    /* Value returned by SetFilePointer() */ŸH  DWORD lastErrno;                /* Value returned by GetLastError() */†Ÿ>  OSTRACE(("SEEK file=%p, offset=%lld\n", pFile->h, iOffset));†Ÿ1  upperBits = (LONG)((iOffset>>32) & 0x7fffffff);Ÿ+  lowerBits = (LONG)(iOffset & 0xffffffff);†Ÿ@  /* API oddity: If successful, SetFilePointer() returns a dwordŸJ  ** containing the lower 32-bits of the new file-offset. Or, if it fails,ŸD  ** it returns INVALID_SET_FILE_POINTER. However according to MSDN,ŸM  ** INVALID_SET_FILE_POINTER may also be a valid new offset. So to determineŸI  ** whether an error has actually occurred, it is also necessary to call¥  ** GetLastError().§  */ŸH  dwRet = osSetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN);†Ÿ&  if( (dwRet==INVALID_SET_FILE_POINTERŸ7      && ((lastErrno = osGetLastError())!=NO_ERROR)) ){Ÿ!    pFile->lastErrno = lastErrno;Ÿ4    winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,Ÿ-                "winSeekFile", pFile->zPath);Ÿ@    OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));≠    return 1;£  }†Ÿ6  OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));´  return 0;•#else§  /*ŸD  ** Same as above, except that this implementation works for WinRT.§  */†Ÿ6  LARGE_INTEGER x;                /* The new offset */ŸL  BOOL bRet;                      /* Value returned by SetFilePointerEx() */†∑  x.QuadPart = iOffset;Ÿ8  bRet = osSetFilePointerEx(pFile->h, x, 0, FILE_BEGIN);†¨  if(!bRet){Ÿ(    pFile->lastErrno = osGetLastError();Ÿ4    winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,Ÿ-                "winSeekFile", pFile->zPath);Ÿ@    OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));≠    return 1;£  }†Ÿ6  OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));´  return 0;¶#endif°}†∫#if SQLITE_MAX_MMAP_SIZE>0ŸK/* Forward references to VFS helper methods used for memory mapped files */Ÿ/static int winMapfile(winFile*, sqlite3_int64);Ÿ"static int winUnmapfile(winFile*);¶#endif†¢/*∞** Close a file.¢**ŸC** It is reported that an attempt to close a handle might sometimesŸF** fail.  This is a very unreasonable result, but Windows is notoriousŸE** for being unreasonable so I do not doubt that it might happen.  IfŸD** the close fails, we pause for 100 milliseconds and try again.  AsŸH** many as MX_CLOSE_ATTEMPT attempts to close the handle are made beforeŸ$** giving up and returning an error.¢*/∫#define MX_CLOSE_ATTEMPT 3Ÿ&static int winClose(sqlite3_file *id){≤  int rc, cnt = 0;Ÿ   winFile *pFile = (winFile*)id;†≤  assert( id!=0 );∑#ifndef SQLITE_OMIT_WALª  assert( pFile->pShm==0 );¶#endifŸ=  assert( pFile->h!=NULL && pFile->h!=INVALID_HANDLE_VALUE );Ÿ0  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p\n",Ÿ6           osGetCurrentProcessId(), pFile, pFile->h));†∫#if SQLITE_MAX_MMAP_SIZE>0∂  winUnmapfile(pFile);¶#endif†•  do{Ÿ!    rc = osCloseHandle(pFile->h);Ÿ9    /* SimulateIOError( rc=0; cnt=MX_CLOSE_ATTEMPT; ); */ŸO  }while( rc==0 && ++cnt < MX_CLOSE_ATTEMPT && (sqlite3_win32_sleep(100), 1) );≥#if SQLITE_OS_WINCEŸ!#define WINCE_DELETION_ATTEMPTS 3£  {ŸD    winVfsAppData *pAppData = (winVfsAppData*)pFile->pVfs->pAppData;Ÿ/    if( pAppData==NULL || !pAppData->bNoLock ){æ      winceDestroyLock(pFile);•    }£  }æ  if( pFile->zDeleteOnClose ){∞    int cnt = 0;™    while(Ÿ2           osDeleteFileW(pFile->zDeleteOnClose)==0ŸB        && osGetFileAttributesW(pFile->zDeleteOnClose)!=0xffffffffŸ*        && cnt++ < WINCE_DELETION_ATTEMPTS¶    ){ŸI       sqlite3_win32_sleep(100);  /* Wait a little before trying again */•    }Ÿ(    sqlite3_free(pFile->zDeleteOnClose);£  }¶#endif´  if( rc ){¥    pFile->h = NULL;£  }≤  OpenCounter(-1);Ÿ7  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p, rc=%s\n",ŸL           osGetCurrentProcessId(), pFile, pFile->h, rc ? "ok" : "failed"));∑  return rc ? SQLITE_OKŸ?            : winLogError(SQLITE_IOERR_CLOSE, osGetLastError(),Ÿ4                          "winClose", pFile->zPath);°}†¢/*Ÿ@** Read data from a file into a buffer.  Return SQLITE_OK if allŸA** bytes were read successfully and SQLITE_IOERR if anything goes©** wrong.¢*/≥static int winRead(Ÿ4  sqlite3_file *id,          /* File to read from */ŸA  void *pBuf,                /* Write content into this buffer */Ÿ:  int amt,                   /* Number of bytes to read */Ÿ?  sqlite3_int64 offset       /* Begin reading at this offset */¢){Ÿ<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)Ÿ@  OVERLAPPED overlapped;          /* The offset for ReadFile. */¶#endifŸ3  winFile *pFile = (winFile*)id;  /* file handle */ŸO  DWORD nRead;                    /* Number of bytes actually read from file */Ÿ8  int nRetry = 0;                 /* Number of retrys */†≤  assert( id!=0 );≤  assert( amt>0 );∂  assert( offset>=0 );Ÿ,  SimulateIOError(return SQLITE_IOERR_READ);ŸD  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "ŸD           "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,Ÿ:           pFile->h, pBuf, amt, offset, pFile->locktype));†∫#if SQLITE_MAX_MMAP_SIZE>0ŸF  /* Deal with as much of this read request as possible by transferingŸ5  ** data from the memory mapping using memcpy().  */ø  if( offset<pFile->mmapSize ){Ÿ(    if( offset+amt <= pFile->mmapSize ){Ÿ>      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);ŸF      OSTRACE(("READ-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ÿ:               osGetCurrentProcessId(), pFile, pFile->h));∑      return SQLITE_OK;™    }else{Ÿ2      int nCopy = (int)(pFile->mmapSize - offset);Ÿ@      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);Ÿ"      pBuf = &((u8 *)pBuf)[nCopy];≥      amt -= nCopy;∂      offset += nCopy;•    }£  }¶#endif†Ÿ:#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)Ÿ#  if( winSeekFile(pFile, offset) ){ŸA    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",Ÿ8             osGetCurrentProcessId(), pFile, pFile->h));∑    return SQLITE_FULL;£  }Ÿ7  while( !osReadFile(pFile->h, pBuf, amt, &nRead, 0) ){•#elseŸ-  memset(&overlapped, 0, sizeof(OVERLAPPED));Ÿ2  overlapped.Offset = (LONG)(offset & 0xffffffff);Ÿ<  overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);ŸA  while( !osReadFile(pFile->h, pBuf, amt, &nRead, &overlapped) &&Ÿ.         osGetLastError()!=ERROR_HANDLE_EOF ){¶#endif¥    DWORD lastErrno;Ÿ6    if( winRetryIoerr(&nRetry, &lastErrno) ) continue;Ÿ!    pFile->lastErrno = lastErrno;ŸG    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_READ\n",Ÿ8             osGetCurrentProcessId(), pFile, pFile->h));Ÿ;    return winLogError(SQLITE_IOERR_READ, pFile->lastErrno,Ÿ0                       "winRead", pFile->zPath);£  }Ÿ   winLogIoerr(nRetry, __LINE__);π  if( nRead<(DWORD)amt ){Ÿ8    /* Unread parts of the buffer must be zero-filled */Ÿ0    memset(&((char*)pBuf)[nRead], 0, amt-nRead);ŸM    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n",Ÿ8             osGetCurrentProcessId(), pFile, pFile->h));Ÿ#    return SQLITE_IOERR_SHORT_READ;£  }†Ÿ=  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ÿ6           osGetCurrentProcessId(), pFile, pFile->h));≥  return SQLITE_OK;°}†¢/*ŸE** Write data from a buffer into a file.  Return SQLITE_OK on successŸ'** or some other error code on failure.¢*/¥static int winWrite(Ÿ:  sqlite3_file *id,               /* File to write into */Ÿ?  const void *pBuf,               /* The bytes to be written */Ÿ@  int amt,                        /* Number of bytes to write */ŸP  sqlite3_int64 offset            /* Offset into the file to begin writing at */¢){ŸN  int rc = 0;                     /* True if error has occurred, else false */Ÿ3  winFile *pFile = (winFile*)id;  /* File handle */Ÿ9  int nRetry = 0;                 /* Number of retries */†≤  assert( amt>0 );≤  assert( pFile );Ÿ-  SimulateIOError(return SQLITE_IOERR_WRITE);Ÿ,  SimulateDiskfullError(return SQLITE_FULL);†ŸE  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "ŸD           "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,Ÿ:           pFile->h, pBuf, amt, offset, pFile->locktype));†Ÿ<#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0ŸG  /* Deal with as much of this write request as possible by transferingŸ5  ** data from the memory mapping using memcpy().  */ø  if( offset<pFile->mmapSize ){Ÿ(    if( offset+amt <= pFile->mmapSize ){Ÿ>      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);ŸG      OSTRACE(("WRITE-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ÿ:               osGetCurrentProcessId(), pFile, pFile->h));∑      return SQLITE_OK;™    }else{Ÿ2      int nCopy = (int)(pFile->mmapSize - offset);Ÿ@      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);Ÿ"      pBuf = &((u8 *)pBuf)[nCopy];≥      amt -= nCopy;∂      offset += nCopy;•    }£  }¶#endif†Ÿ:#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)Ÿ"  rc = winSeekFile(pFile, offset);Æ  if( rc==0 ){•#else£  {¶#endifŸ<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)ŸA    OVERLAPPED overlapped;        /* The offset for WriteFile. */¶#endifŸ>    u8 *aRem = (u8 *)pBuf;        /* Data yet to be written */ŸI    int nRem = amt;               /* Number of bytes yet to be written */ŸN    DWORD nWrite;                 /* Bytes written by each WriteFile() call */ŸH    DWORD lastErrno = NO_ERROR;   /* Value returned by GetLastError() */†Ÿ<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)Ÿ/    memset(&overlapped, 0, sizeof(OVERLAPPED));Ÿ4    overlapped.Offset = (LONG)(offset & 0xffffffff);Ÿ>    overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);¶#endif†¥    while( nRem>0 ){Ÿ:#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)Ÿ;      if( !osWriteFile(pFile->h, aRem, nRem, &nWrite, 0) ){•#elseŸE      if( !osWriteFile(pFile->h, aRem, nRem, &nWrite, &overlapped) ){¶#endifŸ:        if( winRetryIoerr(&nRetry, &lastErrno) ) continue;Æ        break;ß      }Ÿ1      assert( nWrite==0 || nWrite<=(DWORD)nRem );Ÿ,      if( nWrite==0 || nWrite>(DWORD)nRem ){Ÿ%        lastErrno = osGetLastError();Æ        break;ß      }Ÿ<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)∑      offset += nWrite;Ÿ6      overlapped.Offset = (LONG)(offset & 0xffffffff);Ÿ@      overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);¶#endifµ      aRem += nWrite;µ      nRem -= nWrite;•    }±    if( nRem>0 ){Ÿ#      pFile->lastErrno = lastErrno;≠      rc = 1;•    }£  }†´  if( rc ){Ÿ6    if(   ( pFile->lastErrno==ERROR_HANDLE_DISK_FULL )Ÿ1       || ( pFile->lastErrno==ERROR_DISK_FULL )){ŸD      OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",Ÿ:               osGetCurrentProcessId(), pFile, pFile->h));Ÿ7      return winLogError(SQLITE_FULL, pFile->lastErrno,Ÿ4                         "winWrite1", pFile->zPath);•    }ŸI    OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_WRITE\n",Ÿ8             osGetCurrentProcessId(), pFile, pFile->h));Ÿ<    return winLogError(SQLITE_IOERR_WRITE, pFile->lastErrno,Ÿ2                       "winWrite2", pFile->zPath);®  }else{Ÿ"    winLogIoerr(nRetry, __LINE__);£  }Ÿ>  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ÿ6           osGetCurrentProcessId(), pFile, pFile->h));≥  return SQLITE_OK;°}†¢/*Ÿ,** Truncate an open file to a specified size¢*/Ÿ>static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){Ÿ:  winFile *pFile = (winFile*)id;  /* File handle object */ŸE  int rc = SQLITE_OK;             /* Return code for this function */≤  DWORD lastErrno;†≤  assert( pFile );Ÿ0  SimulateIOError(return SQLITE_IOERR_TRUNCATE);ŸG  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, size=%lld, lock=%d\n",ŸN           osGetCurrentProcessId(), pFile, pFile->h, nByte, pFile->locktype));†ŸH  /* If the user has configured a chunk-size for this file, truncate theŸF  ** file so that it consists of an integer number of chunks (i.e. theŸJ  ** actual file size after the operation may be larger than the requested´  ** size).§  */π  if( pFile->szChunk>0 ){ŸK    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;£  }†ŸO  /* SetEndOfFile() returns non-zero when successful, or zero when it fails. */Ÿ"  if( winSeekFile(pFile, nByte) ){Ÿ=    rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,Ÿ3                     "winTruncate1", pFile->zPath);Ÿ*  }else if( 0==osSetEndOfFile(pFile->h) &&ŸG            ((lastErrno = osGetLastError())!=ERROR_USER_MAPPED_FILE) ){Ÿ!    pFile->lastErrno = lastErrno;Ÿ=    rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,Ÿ3                     "winTruncate2", pFile->zPath);£  }†∫#if SQLITE_MAX_MMAP_SIZE>0ŸC  /* If the file was truncated to a size smaller than the currentlyŸJ  ** mapped region, reduce the effective mapping size as well. SQLite willŸI  ** use read() and write() to access data beyond this point from now on.§  */Ÿ3  if( pFile->pMapRegion && nByte<pFile->mmapSize ){º    pFile->mmapSize = nByte;£  }¶#endif†Ÿ:  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, rc=%s\n",ŸJ           osGetCurrentProcessId(), pFile, pFile->h, sqlite3ErrName(rc)));¨  return rc;°}†≤#ifdef SQLITE_TEST¢/*ŸH** Count the number of fullsyncs and normal syncs.  This is used to testŸ<** that syncs and fullsyncs are occuring at the right times.¢*/Ÿ&SQLITE_API int sqlite3_sync_count = 0;Ÿ*SQLITE_API int sqlite3_fullsync_count = 0;¶#endif†¢/*ŸC** Make sure all writes to a particular file are committed to disk.¢*/Ÿ0static int winSync(sqlite3_file *id, int flags){∂#ifndef SQLITE_NO_SYNC§  /*Ÿ2  ** Used only when SQLITE_NO_SYNC is not defined.•   */™  BOOL rc;¶#endifŸ5#if !defined(NDEBUG) || !defined(SQLITE_NO_SYNC) || \Ÿ!    defined(SQLITE_HAVE_OS_TRACE)§  /*ŸG  ** Used when SQLITE_NO_SYNC is not defined and by the assert() and/or∂  ** OSTRACE() macros.•   */Ÿ   winFile *pFile = (winFile*)id;•#else∑  UNUSED_PARAMETER(id);¶#endif†≤  assert( pFile );Ÿ?  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */Ÿ)  assert((flags&0x0F)==SQLITE_SYNC_NORMALŸ'      || (flags&0x0F)==SQLITE_SYNC_FULL§  );†ŸI  /* Unix cannot, but some systems may return SQLITE_FULL from here. ThisŸ?  ** line is to test that doing so does not cause any problems.§  */Ÿ.  SimulateDiskfullError( return SQLITE_FULL );†ŸB  OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, flags=%x, lock=%d\n",Ÿ;           osGetCurrentProcessId(), pFile, pFile->h, flags,Ω           pFile->locktype));†≥#ifndef SQLITE_TEST∫  UNUSED_PARAMETER(flags);•#elseŸ'  if( (flags&0x0F)==SQLITE_SYNC_FULL ){Ω    sqlite3_fullsync_count++;£  }∑  sqlite3_sync_count++;¶#endif†ŸC  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a™  ** no-op§  */µ#ifdef SQLITE_NO_SYNCŸA  OSTRACE(("SYNC-NOP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ÿ6           osGetCurrentProcessId(), pFile, pFile->h));≥  return SQLITE_OK;•#else∫#if SQLITE_MAX_MMAP_SIZE>0∫  if( pFile->pMapRegion ){Ÿ2    if( osFlushViewOfFile(pFile->pMapRegion, 0) ){Ÿ=      OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "Ÿ9               "rc=SQLITE_OK\n", osGetCurrentProcessId(),Ÿ*               pFile, pFile->pMapRegion));™    }else{Ÿ*      pFile->lastErrno = osGetLastError();Ÿ=      OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "ŸA               "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(),Ÿ*               pFile, pFile->pMapRegion));Ÿ=      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,Ÿ3                         "winSync1", pFile->zPath);•    }£  }¶#endifŸ$  rc = osFlushFileBuffers(pFile->h);æ  SimulateIOError( rc=FALSE );´  if( rc ){Ÿ?    OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ÿ8             osGetCurrentProcessId(), pFile, pFile->h));µ    return SQLITE_OK;®  }else{Ÿ(    pFile->lastErrno = osGetLastError();ŸH    OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_FSYNC\n",Ÿ8             osGetCurrentProcessId(), pFile, pFile->h));Ÿ<    return winLogError(SQLITE_IOERR_FSYNC, pFile->lastErrno,Ÿ1                       "winSync2", pFile->zPath);£  }¶#endif°}†¢/*Ÿ0** Determine the current size of a file in bytes¢*/Ÿ?static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){Ÿ   winFile *pFile = (winFile*)id;µ  int rc = SQLITE_OK;†≤  assert( id!=0 );µ  assert( pSize!=0 );Ÿ-  SimulateIOError(return SQLITE_IOERR_FSTAT);Ÿ9  OSTRACE(("SIZE file=%p, pSize=%p\n", pFile->h, pSize));†≥#if SQLITE_OS_WINRT£  {º    FILE_STANDARD_INFO info;ŸB    if( osGetFileInformationByHandleEx(pFile->h, FileStandardInfo,Ÿ<                                     &info, sizeof(info)) ){Ÿ'      *pSize = info.EndOfFile.QuadPart;™    }else{Ÿ*      pFile->lastErrno = osGetLastError();Ÿ<      rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,Ÿ4                       "winFileSize", pFile->zPath);•    }£  }•#else£  {¥    DWORD upperBits;¥    DWORD lowerBits;¥    DWORD lastErrno;†Ÿ4    lowerBits = osGetFileSize(pFile->h, &upperBits);Ÿ:    *pSize = (((sqlite3_int64)upperBits)<<32) + lowerBits;Ÿ*    if(   (lowerBits == INVALID_FILE_SIZE)Ÿ7       && ((lastErrno = osGetLastError())!=NO_ERROR) ){Ÿ#      pFile->lastErrno = lastErrno;Ÿ<      rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,Ÿ4                       "winFileSize", pFile->zPath);•    }£  }¶#endifŸ:  OSTRACE(("SIZE file=%p, pSize=%p, *pSize=%lld, rc=%s\n",Ÿ9           pFile->h, pSize, *pSize, sqlite3ErrName(rc)));¨  return rc;°}†¢/*ŸB** LOCKFILE_FAIL_IMMEDIATELY is undefined on some Windows systems.¢*/Ÿ!#ifndef LOCKFILE_FAIL_IMMEDIATELYŸ$# define LOCKFILE_FAIL_IMMEDIATELY 1¶#endif†ø#ifndef LOCKFILE_EXCLUSIVE_LOCKŸ"# define LOCKFILE_EXCLUSIVE_LOCK 2¶#endif†¢/*ŸL** Historically, SQLite has used both the LockFile and LockFileEx functions.ŸF** When the LockFile function was used, it was always expected to failŸN** immediately if the lock could not be obtained.  Also, it always expected toŸO** obtain an exclusive lock.  These flags are used with the LockFileEx functionŸI** and reflect those expectations; therefore, they should not be changed.¢*/Ω#ifndef SQLITE_LOCKFILE_FLAGSŸ?# define SQLITE_LOCKFILE_FLAGS   (LOCKFILE_FAIL_IMMEDIATELY | \Ÿ:                                  LOCKFILE_EXCLUSIVE_LOCK)¶#endif†¢/*ŸL** Currently, SQLite never calls the LockFileEx function without wanting theŸ;** call to fail immediately if the lock cannot be obtained.¢*/ø#ifndef SQLITE_LOCKFILEEX_FLAGSŸ<# define SQLITE_LOCKFILEEX_FLAGS (LOCKFILE_FAIL_IMMEDIATELY)¶#endif†¢/*π** Acquire a reader lock.ŸE** Different API routines are called depending on whether or not thisµ** is Win9x or WinNT.¢*/Ÿ*static int winGetReadLock(winFile *pFile){™  int res;ŸG  OSTRACE(("READ-LOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));±  if( osIsNT() ){≥#if SQLITE_OS_WINCE¶    /*ŸM    ** NOTE: Windows CE is handled differently here due its lack of the Win32º    **       API LockFileEx.¶    */Ÿ:    res = winceLockFile(&pFile->h, SHARED_FIRST, 0, 1, 0);•#elseŸJ    res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS, SHARED_FIRST, 0,Ÿ&                      SHARED_SIZE, 0);¶#endif£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{´    int lk;Ÿ(    sqlite3_randomness(sizeof(lk), &lk);ŸI    pFile->sharedLockByte = (short)((lk & 0x7fffffff)%(SHARED_SIZE - 1));Ÿ7    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,ŸC                      SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);£  }¶#endif±  if( res == 0 ){Ÿ(    pFile->lastErrno = osGetLastError();Ÿ*    /* No need to log a failure to lock */£  }Ÿ=  OSTRACE(("READ-LOCK file=%p, result=%d\n", pFile->h, res));≠  return res;°}†¢/*≤** Undo a readlock¢*/Ÿ-static int winUnlockReadLock(winFile *pFile){™  int res;≤  DWORD lastErrno;ŸI  OSTRACE(("READ-UNLOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));±  if( osIsNT() ){ŸD    res = winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{ŸP    res = winUnlockFile(&pFile->h, SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);£  }¶#endifŸE  if( res==0 && ((lastErrno = osGetLastError())!=ERROR_NOT_LOCKED) ){Ÿ!    pFile->lastErrno = lastErrno;Ÿ6    winLogError(SQLITE_IOERR_UNLOCK, pFile->lastErrno,Ÿ3                "winUnlockReadLock", pFile->zPath);£  }Ÿ?  OSTRACE(("READ-UNLOCK file=%p, result=%d\n", pFile->h, res));≠  return res;°}†¢/*ŸD** Lock the file with the lock specified by parameter locktype - one¥** of the following:¢**∂**     (1) SHARED_LOCK∏**     (2) RESERVED_LOCK∑**     (3) PENDING_LOCKπ**     (4) EXCLUSIVE_LOCK¢**ŸC** Sometimes when requesting one lock state, additional lock statesŸG** are inserted in between.  The locking might fail on one of the laterŸH** transitions leaving the lock state different from what it started butŸB** still short of its goal.  The following chart shows the allowedŸ4** transitions and the inserted intermediate states:¢**∏**    UNLOCKED -> SHARED∏**    SHARED -> RESERVEDŸ&**    SHARED -> (PENDING) -> EXCLUSIVEŸ(**    RESERVED -> (PENDING) -> EXCLUSIVE∫**    PENDING -> EXCLUSIVE¢**ŸC** This routine will only increase a lock.  The winUnlock() routineŸJ** erases all locks at once and returns us immediately to locking level 0.ŸI** It is not possible to lower the locking level one step at a time.  YouŸ'** must go straight to locking level 0.¢*/Ÿ3static int winLock(sqlite3_file *id, int locktype){Ÿ;  int rc = SQLITE_OK;    /* Return code from subroutines */Ÿ<  int res = 1;           /* Result of a Windows lock call */ŸO  int newLocktype;       /* Set pFile->locktype to this value before exiting */ŸK  int gotPendingLock = 0;/* True if we acquired a PENDING lock this time */Ÿ   winFile *pFile = (winFile*)id;Ω  DWORD lastErrno = NO_ERROR;†≤  assert( id!=0 );Ÿ8  OSTRACE(("LOCK file=%p, oldLock=%d(%d), newLock=%d\n",ŸH           pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));†ŸG  /* If there is already a lock of this type or more restrictive on theŸ>  ** OsFile, do nothing. Don't use the end_lock: exit path, asŸ2  ** sqlite3OsEnterMutex() hasn't been called yet.§  */Ÿ"  if( pFile->locktype>=locktype ){Ÿ=    OSTRACE(("LOCK-HELD file=%p, rc=SQLITE_OK\n", pFile->h));µ    return SQLITE_OK;£  }†Ÿ@  /* Do not allow any kind of write-lock on a read-only database§  */ŸJ  if( (pFile->ctrlFlags & WINFILE_RDONLY)!=0 && locktype>=RESERVED_LOCK ){Ω    return SQLITE_IOERR_LOCK;£  }†Ÿ.  /* Make sure the locking sequence is correct§  */Ÿ>  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );Ÿ#  assert( locktype!=PENDING_LOCK );ŸD  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );†ŸG  /* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock orŸJ  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition ofŸ(  ** the PENDING_LOCK byte is temporary.§  */Ÿ   newLocktype = pFile->locktype;æ  if( pFile->locktype==NO_LOCKŸB   || (locktype==EXCLUSIVE_LOCK && pFile->locktype<=RESERVED_LOCK)§  ){∞    int cnt = 3;ŸJ    while( cnt-->0 && (res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,ŸF                                         PENDING_BYTE, 0, 1, 0))==0 ){ŸE      /* Try 3 times to get the pending lock.  This is needed to workŸI      ** around problems caused by indexing and/or anti-virus software onπ      ** Windows systems.ŸL      ** If you are using this code as a model for alternative VFSes, do notŸH      ** copy this retry logic.  It is a hack intended for Windows only.®      */Ÿ#      lastErrno = osGetLastError();ŸB      OSTRACE(("LOCK-PENDING-FAIL file=%p, count=%d, result=%d\n",Ÿ$               pFile->h, cnt, res));Ÿ,      if( lastErrno==ERROR_INVALID_HANDLE ){Ÿ%        pFile->lastErrno = lastErrno;ø        rc = SQLITE_IOERR_LOCK;Ÿ8        OSTRACE(("LOCK-FAIL file=%p, count=%d, rc=%s\n",Ÿ5                 pFile->h, cnt, sqlite3ErrName(rc)));≤        return rc;ß      }Ÿ'      if( cnt ) sqlite3_win32_sleep(1);•    }π    gotPendingLock = res;Ø    if( !res ){Ÿ#      lastErrno = osGetLastError();•    }£  }†∫  /* Acquire a shared lock§  */Ÿ%  if( locktype==SHARED_LOCK && res ){Ÿ'    assert( pFile->locktype==NO_LOCK );Ÿ     res = winGetReadLock(pFile);Æ    if( res ){Ÿ       newLocktype = SHARED_LOCK;™    }else{Ÿ#      lastErrno = osGetLastError();•    }£  }†º  /* Acquire a RESERVED lock§  */Ÿ'  if( locktype==RESERVED_LOCK && res ){Ÿ+    assert( pFile->locktype==SHARED_LOCK );ŸP    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, RESERVED_BYTE, 0, 1, 0);Æ    if( res ){Ÿ"      newLocktype = RESERVED_LOCK;™    }else{Ÿ#      lastErrno = osGetLastError();•    }£  }†ª  /* Acquire a PENDING lock§  */Ÿ(  if( locktype==EXCLUSIVE_LOCK && res ){ø    newLocktype = PENDING_LOCK;∑    gotPendingLock = 0;£  }†æ  /* Acquire an EXCLUSIVE lock§  */Ÿ(  if( locktype==EXCLUSIVE_LOCK && res ){Ÿ+    assert( pFile->locktype>=SHARED_LOCK );Ÿ#    res = winUnlockReadLock(pFile);ŸH    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, SHARED_FIRST, 0,Ÿ&                      SHARED_SIZE, 0);Æ    if( res ){Ÿ#      newLocktype = EXCLUSIVE_LOCK;™    }else{Ÿ#      lastErrno = osGetLastError();º      winGetReadLock(pFile);•    }£  }†ŸE  /* If we are holding a PENDING lock that ought to be released, then¥  ** release it now.§  */Ÿ0  if( gotPendingLock && locktype==SHARED_LOCK ){Ÿ4    winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);£  }†ŸF  /* Update the state of the lock has held in the file descriptor thenŸ(  ** return the appropriate result code.§  */¨  if( res ){≥    rc = SQLITE_OK;®  }else{Ÿ!    pFile->lastErrno = lastErrno;µ    rc = SQLITE_BUSY;Ÿ6    OSTRACE(("LOCK-FAIL file=%p, wanted=%d, got=%d\n",Ÿ/             pFile->h, locktype, newLocktype));£  }Ÿ$  pFile->locktype = (u8)newLocktype;Ÿ,  OSTRACE(("LOCK file=%p, lock=%d, rc=%s\n",Ÿ;           pFile->h, pFile->locktype, sqlite3ErrName(rc)));¨  return rc;°}†¢/*ŸH** This routine checks if there is a RESERVED lock held on the specifiedŸD** file by this or any other process. If such a lock is held, returnº** non-zero, otherwise zero.¢*/Ÿ@static int winCheckReservedLock(sqlite3_file *id, int *pResOut){™  int res;Ÿ   winFile *pFile = (winFile*)id;†Ÿ<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );ŸE  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p\n", pFile->h, pResOut));†≤  assert( id!=0 );Ÿ'  if( pFile->locktype>=RESERVED_LOCK ){¨    res = 1;ŸJ    OSTRACE(("TEST-WR-LOCK file=%p, result=%d (local)\n", pFile->h, res));®  }else{ŸN    res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS,RESERVED_BYTE,0,1,0);Æ    if( res ){Ÿ7      winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);•    }Ø    res = !res;ŸK    OSTRACE(("TEST-WR-LOCK file=%p, result=%d (remote)\n", pFile->h, res));£  }±  *pResOut = res;ŸK  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",Ÿ)           pFile->h, pResOut, *pResOut));≥  return SQLITE_OK;°}†¢/*ŸG** Lower the locking level on file descriptor id to locktype.  locktypeŸ)** must be either NO_LOCK or SHARED_LOCK.¢**ŸE** If the locking level of the file descriptor is already at or belowŸ8** the requested locking level, this routine is a no-op.¢**ŸE** It is not possible for this routine to fail if the second argumentŸG** is NO_LOCK.  If the second argument is SHARED_LOCK then this routineΩ** might return SQLITE_IOERR;¢*/Ÿ5static int winUnlock(sqlite3_file *id, int locktype){´  int type;Ÿ   winFile *pFile = (winFile*)id;µ  int rc = SQLITE_OK;µ  assert( pFile!=0 );Ÿ"  assert( locktype<=SHARED_LOCK );Ÿ:  OSTRACE(("UNLOCK file=%p, oldLock=%d(%d), newLock=%d\n",ŸH           pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));π  type = pFile->locktype;Ω  if( type>=EXCLUSIVE_LOCK ){Ÿ>    winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);Ÿ:    if( locktype==SHARED_LOCK && !winGetReadLock(pFile) ){Ÿ?      /* This should never happen.  We should always be able toŸ#      ** reacquire the read lock */Ÿ=      rc = winLogError(SQLITE_IOERR_UNLOCK, osGetLastError(),Ÿ2                       "winUnlock", pFile->zPath);•    }£  }º  if( type>=RESERVED_LOCK ){Ÿ5    winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);£  }Ÿ/  if( locktype==NO_LOCK && type>=SHARED_LOCK ){Ω    winUnlockReadLock(pFile);£  }ª  if( type>=PENDING_LOCK ){Ÿ4    winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);£  }Ÿ!  pFile->locktype = (u8)locktype;Ÿ.  OSTRACE(("UNLOCK file=%p, lock=%d, rc=%s\n",Ÿ;           pFile->h, pFile->locktype, sqlite3ErrName(rc)));¨  return rc;°}†ŸO/******************************************************************************ŸO****************************** No-op Locking **********************************¢**ŸG** Of the various locking implementations available, this is by far theŸJ** simplest:  locking is ignored.  No attempt is made to lock the databaseø** file for reading or writing.¢**ŸB** This locking mode is appropriate for use on read-only databasesŸD** (ex: databases that are burned into CD-ROM, for example.)  It canŸE** also be used if the application employs some external mechanism toŸB** prevent simultaneous access of the same database by two or moreŸA** database connections.  But there is a serious risk of databaseŸG** corruption if this locking mode is used in situations where multipleŸH** database connections are accessing the same database file at the sameŸ9** time and one or more of those connections are writing.¢*/†Ÿ9static int winNolockLock(sqlite3_file *id, int locktype){∑  UNUSED_PARAMETER(id);Ω  UNUSED_PARAMETER(locktype);≥  return SQLITE_OK;°}†ŸFstatic int winNolockCheckReservedLock(sqlite3_file *id, int *pResOut){∑  UNUSED_PARAMETER(id);º  UNUSED_PARAMETER(pResOut);≥  return SQLITE_OK;°}†Ÿ;static int winNolockUnlock(sqlite3_file *id, int locktype){∑  UNUSED_PARAMETER(id);Ω  UNUSED_PARAMETER(locktype);≥  return SQLITE_OK;°}†ŸO/******************* End of the no-op lock implementation *********************ŸO******************************************************************************/†¢/*ŸE** If *pArg is initially negative then this is a query.  Set *pArg toŸJ** 1 or 0 depending on whether or not bit mask of pFile->ctrlFlags is set.¢**ŸJ** If *pArg is 0 or 1, then clear or set the mask bit of pFile->ctrlFlags.¢*/ŸFstatic void winModeBit(winFile *pFile, unsigned char mask, int *pArg){∞  if( *pArg<0 ){Ÿ)    *pArg = (pFile->ctrlFlags & mask)!=0;π  }else if( (*pArg)==0 ){æ    pFile->ctrlFlags &= ~mask;®  }else{Ω    pFile->ctrlFlags |= mask;£  }°}†ŸG/* Forward references to VFS helper methods used for temporary files */Ÿ2static int winGetTempname(sqlite3_vfs *, char **);Ÿ"static int winIsDir(const void *);Ÿ3static BOOL winIsDriveLetterAndColon(const char *);†¢/*Ÿ-** Control and query of the open file handle.¢*/Ÿ@static int winFileControl(sqlite3_file *id, int op, void *pArg){Ÿ   winFile *pFile = (winFile*)id;ŸC  OSTRACE(("FCNTL file=%p, op=%d, pArg=%p\n", pFile->h, op, pArg));Ø  switch( op ){Ÿ"    case SQLITE_FCNTL_LOCKSTATE: {Ÿ$      *(int*)pArg = pFile->locktype;Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ#    case SQLITE_FCNTL_LAST_ERRNO: {Ÿ*      *(int*)pArg = (int)pFile->lastErrno;Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ#    case SQLITE_FCNTL_CHUNK_SIZE: {Ÿ$      pFile->szChunk = *(int *)pArg;Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ"    case SQLITE_FCNTL_SIZE_HINT: {Ω      if( pFile->szChunk>0 ){º        sqlite3_int64 oldSz;Ÿ)        int rc = winFileSize(id, &oldSz);º        if( rc==SQLITE_OK ){Ÿ6          sqlite3_int64 newSz = *(sqlite3_int64*)pArg;º          if( newSz>oldSz ){Ÿ%            SimulateIOErrorBenign(1);Ÿ(            rc = winTruncate(id, newSz);Ÿ%            SimulateIOErrorBenign(0);´          }©        }ŸJ        OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));≤        return rc;ß      }Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ$    case SQLITE_FCNTL_PERSIST_WAL: {Ÿ9      winModeBit(pFile, WINFILE_PERSIST_WAL, (int*)pArg);Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ,    case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {Ÿ2      winModeBit(pFile, WINFILE_PSOW, (int*)pArg);Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ     case SQLITE_FCNTL_VFSNAME: {Ÿ@      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ'    case SQLITE_FCNTL_WIN32_AV_RETRY: {∫      int *a = (int*)pArg;≥      if( a[0]>0 ){Ω        winIoerrRetry = a[0];¨      }else{Ω        a[0] = winIoerrRetry;ß      }≥      if( a[1]>0 ){Ÿ"        winIoerrRetryDelay = a[1];¨      }else{Ÿ"        a[1] = winIoerrRetryDelay;ß      }Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }Ÿ)    case SQLITE_FCNTL_WIN32_GET_HANDLE: {Ÿ'      LPHANDLE phFile = (LPHANDLE)pArg;π      *phFile = pFile->h;Ÿ;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));∑      return SQLITE_OK;•    }≤#ifdef SQLITE_TESTŸ)    case SQLITE_FCNTL_WIN32_SET_HANDLE: {Ÿ'      LPHANDLE phFile = (LPHANDLE)pArg;Ÿ!      HANDLE hOldFile = pFile->h;π      pFile->h = *phFile;π      *phFile = hOldFile;Ÿ>      OSTRACE(("FCNTL oldFile=%p, newFile=%p, rc=SQLITE_OK\n",Ÿ$               hOldFile, pFile->h));∑      return SQLITE_OK;•    }¶#endifŸ%    case SQLITE_FCNTL_TEMPFILENAME: {∑      char *zTFile = 0;Ÿ4      int rc = winGetTempname(pFile->pVfs, &zTFile);∫      if( rc==SQLITE_OK ){ø        *(char**)pArg = zTFile;ß      }ŸH      OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));∞      return rc;•    }∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ"    case SQLITE_FCNTL_MMAP_SIZE: {Ÿ!      i64 newLimit = *(i64*)pArg;π      int rc = SQLITE_OK;Ÿ0      if( newLimit>sqlite3GlobalConfig.mxMmap ){Ÿ.        newLimit = sqlite3GlobalConfig.mxMmap;ß      }†ŸL      /* The value of newLimit may be eventually cast to (SIZE_T) and passedŸL      ** to MapViewOfFile(). Restrict its value to 2GB if (SIZE_T) is not atŸ       ** least a 64-bit type. */Ÿ+      if( newLimit>0 && sizeof(SIZE_T)<8 ){Ÿ+        newLimit = (newLimit & 0x7FFFFFFF);ß      }†Ÿ'      *(i64*)pArg = pFile->mmapSizeMax;ŸO      if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){Ÿ&        pFile->mmapSizeMax = newLimit;Ÿ         if( pFile->mmapSize>0 ){æ          winUnmapfile(pFile);Ÿ%          rc = winMapfile(pFile, -1);©        }ß      }ŸH      OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));∞      return rc;•    }¶#endif£  }Ÿ=  OSTRACE(("FCNTL file=%p, rc=SQLITE_NOTFOUND\n", pFile->h));π  return SQLITE_NOTFOUND;°}†¢/*ŸE** Return the sector size in bytes of the underlying block device forŸB** the specified file. This is almost always 512 bytes, but may beª** larger for some devices.¢**ŸF** SQLite code assumes this function cannot fail. It also assumes thatŸC** if two files are created in the same file-system directory (i.e.ŸD** a database and its journal file) that the sector size will be the±** same for both.¢*/Ÿ+static int winSectorSize(sqlite3_file *id){´  (void)id;Ÿ$  return SQLITE_DEFAULT_SECTOR_SIZE;°}†¢/*Ÿ-** Return a vector of device characteristics.¢*/Ÿ6static int winDeviceCharacteristics(sqlite3_file *id){º  winFile *p = (winFile*)id;Ÿ-  return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN |ŸL         ((p->ctrlFlags & WINFILE_PSOW)?SQLITE_IOCAP_POWERSAFE_OVERWRITE:0);°}†¢/*Ÿ6** Windows will only let you create file view mappingsŸ-** on allocation size granularity boundaries.Ÿ3** During sqlite3_os_init() we do a GetSystemInfo()ø** to get the granularity size.¢*/æstatic SYSTEM_INFO winSysInfo;†∑#ifndef SQLITE_OMIT_WAL†¢/*ŸB** Helper functions to obtain and relinquish the global mutex. TheŸB** global mutex is used to protect the winLockInfo objects used byŸ=** this file, all of which may be shared by multiple threads.¢**ŸG** Function winShmMutexHeld() is used to assert() that the global mutexŸH** is held when required. This function is only used as part of assert()≥** statements. e.g.¢**∑**   winShmEnterMutex()Ÿ#**     assert( winShmMutexHeld() );∑**   winShmLeaveMutex()¢*/Ÿ%static sqlite3_mutex *winBigLock = 0;Ÿ#static void winShmEnterMutex(void){Ÿ"  sqlite3_mutex_enter(winBigLock);°}Ÿ#static void winShmLeaveMutex(void){Ÿ"  sqlite3_mutex_leave(winBigLock);°}Æ#ifndef NDEBUGŸ"static int winShmMutexHeld(void) {Ÿ(  return sqlite3_mutex_held(winBigLock);°}¶#endif†¢/*ŸG** Object used to represent a single file opened and mmapped to provideŸ?** shared memory.  When multiple threads all reference the sameŸD** log-summary, each thread has its own winFile object, but they allŸC** point to a single instance of this object.  In other words, eachŸ/** log-summary is opened only once per process.¢**Ÿ=** winShmMutexHeld() must be true when creating or destroyingŸ@** this object or while reading or writing the following fields:¢**¨**      nRef≠**      pNext¢**ŸB** The following fields are read-only after the object is created:¢**´**      fid±**      zFilename¢**ŸA** Either winShmNode.mutex must be held or winShmNode.nRef==0 andŸD** winShmMutexHeld() is true when reading or writing any other fieldµ** in this structure.¢**¢*/≥struct winShmNode {Ÿ>  sqlite3_mutex *mutex;      /* Mutex to access this object */Ÿ3  char *zFilename;           /* Name of the file */Ÿ;  winFile hFile;             /* File handle from winOpen */†Ÿ@  int szRegion;              /* Size of shared-memory regions */Ÿ9  int nRegion;               /* Size of array apRegion */Ÿ4  u8 isReadonly;             /* True if read-only */Ÿ;  u8 isUnlocked;             /* True if no DMS lock held */†¥  struct ShmRegion {ŸE    HANDLE hMap;             /* File handle from CreateFileMapping */Ø    void *pMap;≠  } *aRegion;ŸL  DWORD lastErrno;           /* The Windows errno from the last I/O error */†ŸL  int nRef;                  /* Number of winShm objects pointing to this */ŸF  winShm *pFirst;            /* All winShm objects pointing to this */ŸI  winShmNode *pNext;         /* Next in list of all winShmNode objects */Ÿ:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)ŸA  u8 nextShmId;              /* Next available winShm.id value */¶#endif¢};†¢/*Ÿ,** A global array of all winShmNode objects.¢**ŸI** The winShmMutexHeld() must be true while reading or writing this list.¢*/Ÿ&static winShmNode *winShmNodeList = 0;†¢/*ŸB** Structure used internally by this VFS to record the state of anŸ!** open shared memory connection.¢**ŸG** The following fields are initialized when this object is created andº** are read-only thereafter:¢**µ**    winShm.pShmNodeØ**    winShm.id¢**ŸL** All other fields are read/write.  The winShm.pShmNode->mutex must be heldŸ)** while accessing any read/write fields.¢*/Østruct winShm {ŸC  winShmNode *pShmNode;      /* The underlying winShmNode object */ŸG  winShm *pNext;             /* Next winShm with the same winShmNode */ŸG  u8 hasMutex;               /* True if holding the winShmNode mutex */Ÿ<  u16 sharedMask;            /* Mask of shared locks held */Ÿ?  u16 exclMask;              /* Mask of exclusive locks held */Ÿ:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)ŸL  u8 id;                     /* Id of this connection with its winShmNode */¶#endif¢};†¢/*Ω** Constants used for locking¢*/ŸM#define WIN_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)        /* first lock byte */ŸL#define WIN_SHM_DMS    (WIN_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */†¢/*Ÿ:** Apply advisory locks for all n bytes beginning at ofst.¢*/∑#define WINSHM_UNLCK  1∑#define WINSHM_RDLCK  2∑#define WINSHM_WRLCK  3ºstatic int winShmSystemLock(ŸL  winShmNode *pFile,    /* Apply locks to this open shared-memory segment */ŸI  int lockType,         /* WINSHM_UNLCK, WINSHM_RDLCK, or WINSHM_WRLCK */ŸH  int ofst,             /* Offset to first byte to be locked/unlocked */Ÿ?  int nByte             /* Number of bytes to lock or unlock */¢){ŸB  int rc = 0;           /* Result code form Lock/UnlockFileEx() */†ŸC  /* Access to the winShmNode object is serialized by the caller */Ÿ?  assert( pFile->nRef==0 || sqlite3_mutex_held(pFile->mutex) );†Ÿ=  OSTRACE(("SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\n",Ÿ3           pFile->hFile.h, lockType, ofst, nByte));†Ÿ-  /* Release/Acquire the system-level lock */ø  if( lockType==WINSHM_UNLCK ){Ÿ;    rc = winUnlockFile(&pFile->hFile.h, ofst, 0, nByte, 0);®  }else{Ÿ+    /* Initialize the locking parameters */Ÿ.    DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;ŸF    if( lockType == WINSHM_WRLCK ) dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;ŸB    rc = winLockFile(&pFile->hFile.h, dwFlags, ofst, 0, nByte, 0);£  }†Ø  if( rc!= 0 ){≥    rc = SQLITE_OK;®  }else{Ÿ)    pFile->lastErrno =  osGetLastError();µ    rc = SQLITE_BUSY;£  }†Ÿ;  OSTRACE(("SHM-LOCK file=%p, func=%s, errno=%lu, rc=%s\n",ŸI           pFile->hFile.h, (lockType == WINSHM_UNLCK) ? "winUnlockFile" :ŸA           "winLockFile", pFile->lastErrno, sqlite3ErrName(rc)));†¨  return rc;°}†Ÿ'/* Forward references to VFS methods */ŸDstatic int winOpen(sqlite3_vfs*,const char*,sqlite3_file*,int,int*);Ÿ4static int winDelete(sqlite3_vfs *,const char*,int);†¢/*ŸH** Purge the winShmNodeList list of all entries with winShmNode.nRef==0.¢**ŸJ** This is not a VFS shared-memory method; it is a utility function calledŸ ** by VFS shared-memory methods.¢*/Ÿ;static void winShmPurge(sqlite3_vfs *pVfs, int deleteFlag){≤  winShmNode **pp;∞  winShmNode *p;æ  assert( winShmMutexHeld() );Ÿ0  OSTRACE(("SHM-PURGE pid=%lu, deleteFlag=%d\n",Ÿ1           osGetCurrentProcessId(), deleteFlag));∑  pp = &winShmNodeList;∏  while( (p = *pp)!=0 ){µ    if( p->nRef==0 ){¨      int i;Ÿ5      if( p->mutex ){ sqlite3_mutex_free(p->mutex); }Ÿ"      for(i=0; i<p->nRegion; i++){Ÿ9        BOOL bRc = osUnmapViewOfFile(p->aRegion[i].pMap);Ÿ?        OSTRACE(("SHM-PURGE-UNMAP pid=%lu, region=%d, rc=%s\n",ŸE                 osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));Ÿ#        UNUSED_VARIABLE_VALUE(bRc);Ÿ0        bRc = osCloseHandle(p->aRegion[i].hMap);Ÿ?        OSTRACE(("SHM-PURGE-CLOSE pid=%lu, region=%d, rc=%s\n",ŸE                 osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));Ÿ#        UNUSED_VARIABLE_VALUE(bRc);ß      }ŸA      if( p->hFile.h!=NULL && p->hFile.h!=INVALID_HANDLE_VALUE ){Ÿ!        SimulateIOErrorBenign(1);Ÿ,        winClose((sqlite3_file *)&p->hFile);Ÿ!        SimulateIOErrorBenign(0);ß      }∑      if( deleteFlag ){Ÿ!        SimulateIOErrorBenign(1);Ÿ#        sqlite3BeginBenignMalloc();Ÿ)        winDelete(pVfs, p->zFilename, 0);Ÿ!        sqlite3EndBenignMalloc();Ÿ!        SimulateIOErrorBenign(0);ß      }µ      *pp = p->pNext;ø      sqlite3_free(p->aRegion);∂      sqlite3_free(p);™    }else{µ      pp = &p->pNext;•    }£  }°}†¢/*ŸG** The DMS lock has not yet been taken on shm file pShmNode. Attempt toŸB** take it now. Return SQLITE_OK if successful, or an SQLite error≤** code otherwise.¢**Ÿ?** If the DMS cannot be locked because this is a readonly_shm=1Ÿ?** connection and no other process already holds a lock, returnŸ;** SQLITE_READONLY_CANTINIT and set pShmNode->isUnlocked=1.¢*/Ÿ5static int winLockSharedMemory(winShmNode *pShmNode){ŸD  int rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, WIN_SHM_DMS, 1);†∂  if( rc==SQLITE_OK ){ø    if( pShmNode->isReadonly ){ø      pShmNode->isUnlocked = 1;Ÿ?      winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);Ÿ&      return SQLITE_READONLY_CANTINIT;Ÿ@    }else if( winTruncate((sqlite3_file*)&pShmNode->hFile, 0) ){Ÿ?      winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);Ÿ@      return winLogError(SQLITE_IOERR_SHMOPEN, osGetLastError(),ŸE                         "winLockSharedMemory", pShmNode->zFilename);•    }£  }†∂  if( rc==SQLITE_OK ){Ÿ=    winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);£  }†ŸB  return winShmSystemLock(pShmNode, WINSHM_RDLCK, WIN_SHM_DMS, 1);°}†¢/*ŸC** Open the shared-memory area associated with database file pDbFd.¢**ŸG** When opening a new shared-memory file, if no other instances of thatŸG** file are currently open, in this process or in other processes, thenŸH** the file must be truncated to zero length or have its header cleared.¢*/Ÿ/static int winOpenSharedMemory(winFile *pDbFd){ŸF  struct winShm *p;                  /* The connection to be opened */ŸF  winShmNode *pShmNode = 0;          /* The underlying mmapped file */Ÿ6  int rc = SQLITE_OK;                /* Result code */ŸE  winShmNode *pNew;                  /* Newly allocated winShmNode */ŸA  int nName;                         /* Size of zName in bytes */†Ÿ:  assert( pDbFd->pShm==0 );    /* Not previously opened */†ŸG  /* Allocate space for the new sqlite3_shm object.  Also speculativelyŸ6  ** allocate space for a new winShmNode and filename.§  */Ÿ&  p = sqlite3MallocZero( sizeof(*p) );Ÿ,  if( p==0 ) return SQLITE_IOERR_NOMEM_BKPT;Ÿ(  nName = sqlite3Strlen30(pDbFd->zPath);Ÿ=  pNew = sqlite3MallocZero( sizeof(*pShmNode) + nName + 17 );∞  if( pNew==0 ){¥    sqlite3_free(p);Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }Ÿ$  pNew->zFilename = (char*)&pNew[1];ŸF  sqlite3_snprintf(nName+15, pNew->zFilename, "%s-shm", pDbFd->zPath);Ÿ4  sqlite3FileSuffix3(pDbFd->zPath, pNew->zFilename);†ŸE  /* Look to see if there is an existing winShmNode that can be used.ŸB  ** If no matching winShmNode currently exists, create a new one.§  */µ  winShmEnterMutex();ŸE  for(pShmNode = winShmNodeList; pShmNode; pShmNode=pShmNode->pNext){Ÿ;    /* TBD need to come up with better match here.  PerhapsŸ+    ** use FILE_ID_BOTH_DIR_INFO Structure.¶    */ŸH    if( sqlite3StrICmp(pShmNode->zFilename, pNew->zFilename)==0 ) break;£  }±  if( pShmNode ){∑    sqlite3_free(pNew);®  }else{Ÿ"    int inFlags = SQLITE_OPEN_WAL;µ    int outFlags = 0;†¥    pShmNode = pNew;≠    pNew = 0;Ÿ=    ((winFile*)(&pShmNode->hFile))->h = INVALID_HANDLE_VALUE;Ÿ%    pShmNode->pNext = winShmNodeList;æ    winShmNodeList = pShmNode;†Ÿ)    if( sqlite3GlobalConfig.bCoreMutex ){Ÿ?      pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);ø      if( pShmNode->mutex==0 ){Ÿ%        rc = SQLITE_IOERR_NOMEM_BKPT;∫        goto shm_open_err;ß      }•    }†ŸB    if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){Ÿ<      inFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;™    }else{Ÿ&      inFlags |= SQLITE_OPEN_READONLY;•    }Ÿ2    rc = winOpen(pDbFd->pVfs, pShmNode->zFilename,Ÿ1                 (sqlite3_file*)&pShmNode->hFile,Ÿ%                 inFlags, &outFlags);∏    if( rc!=SQLITE_OK ){Ÿ:      rc = winLogError(rc, osGetLastError(), "winOpenShm",Ÿ,                       pShmNode->zFilename);∏      goto shm_open_err;•    }ŸB    if( outFlags==SQLITE_OPEN_READONLY ) pShmNode->isReadonly = 1;†Ÿ'    rc = winLockSharedMemory(pShmNode);ŸJ    if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;£  }†Ÿ9  /* Make the new connection a child of the winShmNode */π  p->pShmNode = pShmNode;Ÿ:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)Ÿ   p->id = pShmNode->nextShmId++;¶#endif≥  pShmNode->nRef++;≤  pDbFd->pShm = p;µ  winShmLeaveMutex();†ŸG  /* The reference count on pShmNode has already been incremented underŸG  ** the cover of the winShmEnterMutex() mutex and the pointer from theŸI  ** new (struct winShm) object to the pShmNode has been set. All that isŸG  ** left to do is to link the new object into the linked list startingŸM  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex´  ** mutex.§  */Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);æ  p->pNext = pShmNode->pFirst;∑  pShmNode->pFirst = p;Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);¨  return rc;†æ  /* Jump here on any error */≠shm_open_err:Ÿ;  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);ŸN  winShmPurge(pDbFd->pVfs, 0);      /* This call frees pShmNode if required */≤  sqlite3_free(p);µ  sqlite3_free(pNew);µ  winShmLeaveMutex();¨  return rc;°}†¢/*Ÿ>** Close a connection to shared-memory.  Delete the underlyingŸ!** storage if deleteFlag is true.¢*/∑static int winShmUnmap(ŸA  sqlite3_file *fd,          /* Database holding shared memory */Ÿ?  int deleteFlag             /* Delete after closing if true */¢){Ÿ<  winFile *pDbFd;       /* Database holding shared-memory */Ÿ9  winShm *p;            /* The connection to be closed */Ÿ?  winShmNode *pShmNode; /* The underlying shared-memory file */ŸB  winShm **pp;          /* For looping over sibling connections */†∑  pDbFd = (winFile*)fd;≤  p = pDbFd->pShm;æ  if( p==0 ) return SQLITE_OK;π  pShmNode = p->pShmNode;†Ÿ?  /* Remove connection p from the set of connections associatedµ  ** with pShmNode */Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);Ÿ;  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}±  *pp = p->pNext;†Ω  /* Free the connection p */≤  sqlite3_free(p);≤  pDbFd->pShm = 0;Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);†Ÿ?  /* If pShmNode->nRef has reached 0, then close the underlyingø  ** shared-memory file, too */µ  winShmEnterMutex();Ω  assert( pShmNode->nRef>0 );≥  pShmNode->nRef--;∫  if( pShmNode->nRef==0 ){Ÿ)    winShmPurge(pDbFd->pVfs, deleteFlag);£  }µ  winShmLeaveMutex();†≥  return SQLITE_OK;°}†¢/*Ÿ5** Change the lock state for a shared-memory segment.¢*/∂static int winShmLock(ŸJ  sqlite3_file *fd,          /* Database file holding the shared memory */ŸC  int ofst,                  /* First lock to acquire or release */ŸH  int n,                     /* Number of locks to acquire or release */Ÿ;  int flags                  /* What to do with the lock */¢){ŸN  winFile *pDbFd = (winFile*)fd;        /* Connection holding shared memory */ŸL  winShm *p = pDbFd->pShm;              /* The shared memory being locked */ŸK  winShm *pX;                           /* For looping over all siblings */Ÿ%  winShmNode *pShmNode = p->pShmNode;Ÿ9  int rc = SQLITE_OK;                   /* Result code */ŸN  u16 mask;                             /* Mask of locks to take or release */†Ÿ0  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );±  assert( n>=1 );Ÿ6  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)Ÿ9       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)Ÿ8       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)Ÿ>       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );Ÿ6  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );†Ÿ,  mask = (u16)((1U<<(ofst+n)) - (1U<<ofst));Ÿ#  assert( n>1 || mask==(1<<ofst) );Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);Ÿ"  if( flags & SQLITE_SHM_UNLOCK ){Ÿ9    u16 allMask = 0; /* Mask of locks held by siblings */†Ÿ1    /* See if any siblings hold this same lock */Ÿ/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){ª      if( pX==p ) continue;Ÿ@      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );Ÿ       allMask |= pX->sharedMask;•    }†Ÿ'    /* Unlock the system-level locks */æ    if( (mask & allMask)==0 ){ŸJ      rc = winShmSystemLock(pShmNode, WINSHM_UNLCK, ofst+WIN_SHM_BASE, n);™    }else{µ      rc = SQLITE_OK;•    }†æ    /* Undo the local locks */∏    if( rc==SQLITE_OK ){ª      p->exclMask &= ~mask;Ω      p->sharedMask &= ~mask;•    }Ÿ(  }else if( flags & SQLITE_SHM_SHARED ){ŸO    u16 allShared = 0;  /* Union of locks held by connections other than "p" */†ŸK    /* Find out which shared locks are already held by sibling connections.ŸJ    ** If any sibling already holds an exclusive lock, go ahead and return≥    ** SQLITE_BUSY.¶    */Ÿ/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){Ÿ%      if( (pX->exclMask & mask)!=0 ){π        rc = SQLITE_BUSY;Æ        break;ß      }Ÿ"      allShared |= pX->sharedMask;•    }†Ÿ<    /* Get shared locks at the system level, if necessary */∏    if( rc==SQLITE_OK ){Ÿ"      if( (allShared & mask)==0 ){ŸL        rc = winShmSystemLock(pShmNode, WINSHM_RDLCK, ofst+WIN_SHM_BASE, n);¨      }else{∑        rc = SQLITE_OK;ß      }•    }†Ÿ$    /* Get the local shared locks */∏    if( rc==SQLITE_OK ){º      p->sharedMask |= mask;•    }®  }else{ŸG    /* Make sure no sibling connections hold locks that will block thisŸ7    ** lock.  If any do, return SQLITE_BUSY right away.¶    */Ÿ/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){ŸC      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){π        rc = SQLITE_BUSY;Æ        break;ß      }•    }†ŸG    /* Get the exclusive locks at the system level.  Then if successfulŸ6    ** also mark the local connection as being locked.¶    */∏    if( rc==SQLITE_OK ){ŸJ      rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, ofst+WIN_SHM_BASE, n);∫      if( rc==SQLITE_OK ){Ÿ,        assert( (p->sharedMask & mask)==0 );º        p->exclMask |= mask;ß      }•    }£  }Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);ŸN  OSTRACE(("SHM-LOCK pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x, rc=%s\n",ŸF           osGetCurrentProcessId(), p->id, p->sharedMask, p->exclMask,Ÿ            sqlite3ErrName(rc)));¨  return rc;°}†¢/*Ÿ?** Implement a memory barrier or memory fence on shared memory.¢**ŸE** All loads and stores begun before the barrier must complete beforeŸ-** any load or store begun after the barrier.¢*/∫static void winShmBarrier(ŸD  sqlite3_file *fd          /* Database holding the shared memory */¢){∑  UNUSED_PARAMETER(fd);ŸA  sqlite3MemoryBarrier();   /* compiler-defined memory barrier */Ÿ<  winShmEnterMutex();       /* Also mutex, for redundancy */µ  winShmLeaveMutex();°}†¢/*ŸG** This function is called to obtain a pointer to region iRegion of theŸL** shared-memory associated with the database file fd. Shared-memory regionsŸI** are numbered starting from zero. Each shared-memory region is szRegion±** bytes in size.¢**ŸH** If an error occurs, an error code is returned and *pp is set to NULL.¢**ŸK** Otherwise, if the isWrite parameter is 0 and the requested shared-memoryŸK** region has not been allocated (by any client, including one running in aŸH** separate process), then *pp is set to NULL and SQLITE_OK returned. IfŸI** isWrite is non-zero and the requested shared-memory region has not yetŸ4** been allocated, it is allocated by this function.¢**ŸL** If the shared-memory region has already been allocated or is allocated byŸF** this call as described above, then it is mapped into this processesŸJ** address space (if it is not already), *pp is set to point to the mappedŸ!** memory and SQLITE_OK returned.¢*/µstatic int winShmMap(ŸD  sqlite3_file *fd,               /* Handle open on database file */Ÿ:  int iRegion,                    /* Region to retrieve */Ÿ7  int szRegion,                   /* Size of regions */ŸH  int isWrite,                    /* True to extend file if necessary */Ÿ:  void volatile **pp              /* OUT: Mapped memory */¢){Ÿ   winFile *pDbFd = (winFile*)fd;Ω  winShm *pShm = pDbFd->pShm;∑  winShmNode *pShmNode;Ÿ!  DWORD protect = PAGE_READWRITE;Ÿ/  DWORD flags = FILE_MAP_WRITE | FILE_MAP_READ;µ  int rc = SQLITE_OK;†Æ  if( !pShm ){Ÿ$    rc = winOpenSharedMemory(pDbFd);Ÿ"    if( rc!=SQLITE_OK ) return rc;∑    pShm = pDbFd->pShm;£  }º  pShmNode = pShm->pShmNode;†Ÿ'  sqlite3_mutex_enter(pShmNode->mutex);Ω  if( pShmNode->isUnlocked ){Ÿ'    rc = winLockSharedMemory(pShmNode);Ÿ)    if( rc!=SQLITE_OK ) goto shmpage_out;Ω    pShmNode->isUnlocked = 0;£  }ŸA  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );†Ÿ#  if( pShmNode->nRegion<=iRegion ){Ÿ@    struct ShmRegion *apNew;           /* New aRegion[] array */ŸG    int nByte = (iRegion+1)*szRegion;  /* Minimum required file size */ŸK    sqlite3_int64 sz;                  /* Current size of wal-index file */†Ÿ"    pShmNode->szRegion = szRegion;†ŸL    /* The requested region is not mapped into this processes address space.ŸK    ** Check to see if it has been allocated (i.e. if the wal-index file isŸ5    ** large enough to contain the requested region).¶    */Ÿ<    rc = winFileSize((sqlite3_file *)&pShmNode->hFile, &sz);∏    if( rc!=SQLITE_OK ){Ÿ>      rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),Ÿ3                       "winShmMap1", pDbFd->zPath);∑      goto shmpage_out;•    }†≥    if( sz<nByte ){ŸI      /* The requested memory region does not exist. If isWrite is set toŸJ      ** zero, exit early. *pp will be set to NULL and SQLITE_OK returned.®      **ŸK      ** Alternatively, if isWrite is non-zero, use ftruncate() to allocateŸ%      ** the requested memory region.®      */Ÿ&      if( !isWrite ) goto shmpage_out;Ÿ@      rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);∫      if( rc!=SQLITE_OK ){Ÿ@        rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),Ÿ5                         "winShmMap2", pDbFd->zPath);π        goto shmpage_out;ß      }•    }†ŸL    /* Map the requested memory region into this processes address space. */Ÿ2    apNew = (struct ShmRegion *)sqlite3_realloc64(Ÿ7        pShmNode->aRegion, (iRegion+1)*sizeof(apNew[0])¶    );±    if( !apNew ){Ÿ#      rc = SQLITE_IOERR_NOMEM_BKPT;∑      goto shmpage_out;•    }æ    pShmNode->aRegion = apNew;†ø    if( pShmNode->isReadonly ){æ      protect = PAGE_READONLY;º      flags = FILE_MAP_READ;•    }†Ÿ(    while( pShmNode->nRegion<=iRegion ){Ÿ;      HANDLE hMap = NULL;         /* file-mapping handle */Ÿ<      void *pMap = 0;             /* Mapped memory region */†≥#if SQLITE_OS_WINRTŸ:      hMap = osCreateFileMappingFromApp(pShmNode->hFile.h,Ÿ$          NULL, protect, nByte, NULL®      );Ÿ$#elif defined(SQLITE_WIN32_HAS_WIDE)Ÿ4      hMap = osCreateFileMappingW(pShmNode->hFile.h,Ÿ'          NULL, protect, 0, nByte, NULL®      );ŸG#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGAŸ4      hMap = osCreateFileMappingA(pShmNode->hFile.h,Ÿ'          NULL, protect, 0, nByte, NULL®      );¶#endifŸE      OSTRACE(("SHM-MAP-CREATE pid=%lu, region=%d, size=%d, rc=%s\n",ŸA               osGetCurrentProcessId(), pShmNode->nRegion, nByte,Ÿ(               hMap ? "ok" : "failed"));±      if( hMap ){Ÿ1        int iOffset = pShmNode->nRegion*szRegion;ŸH        int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;≥#if SQLITE_OS_WINRTŸ2        pMap = osMapViewOfFileFromApp(hMap, flags,Ÿ;            iOffset - iOffsetShift, szRegion + iOffsetShift™        );•#elseŸ+        pMap = osMapViewOfFile(hMap, flags,Ÿ>            0, iOffset - iOffsetShift, szRegion + iOffsetShift™        );¶#endifŸO        OSTRACE(("SHM-MAP-MAP pid=%lu, region=%d, offset=%d, size=%d, rc=%s\n",ŸE                 osGetCurrentProcessId(), pShmNode->nRegion, iOffset,Ÿ4                 szRegion, pMap ? "ok" : "failed"));ß      }≤      if( !pMap ){Ÿ/        pShmNode->lastErrno = osGetLastError();ŸB        rc = winLogError(SQLITE_IOERR_SHMMAP, pShmNode->lastErrno,Ÿ5                         "winShmMap3", pDbFd->zPath);Ÿ'        if( hMap ) osCloseHandle(hMap);π        goto shmpage_out;ß      }†Ÿ7      pShmNode->aRegion[pShmNode->nRegion].pMap = pMap;Ÿ7      pShmNode->aRegion[pShmNode->nRegion].hMap = hMap;∫      pShmNode->nRegion++;•    }£  }†¨shmpage_out:Ÿ"  if( pShmNode->nRegion>iRegion ){Ÿ#    int iOffset = iRegion*szRegion;ŸD    int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;Ÿ6    char *p = (char *)pShmNode->aRegion[iRegion].pMap;Ÿ#    *pp = (void *)&p[iOffsetShift];®  }else{¨    *pp = 0;£  }ŸC  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;Ÿ'  sqlite3_mutex_leave(pShmNode->mutex);¨  return rc;°}†•#else∏# define winShmMap     0∏# define winShmLock    0∏# define winShmBarrier 0∏# define winShmUnmap   0Ÿ$#endif /* #ifndef SQLITE_OMIT_WAL */†¢/*Ÿ=** Cleans up the mapped region of the specified file, if any.¢*/∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ(static int winUnmapfile(winFile *pFile){µ  assert( pFile!=0 );ŸC  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, pMapRegion=%p, "ŸD           "mmapSize=%lld, mmapSizeActual=%lld, mmapSizeMax=%lld\n",ŸJ           osGetCurrentProcessId(), pFile, pFile->hMap, pFile->pMapRegion,ŸH           pFile->mmapSize, pFile->mmapSizeActual, pFile->mmapSizeMax));∫  if( pFile->pMapRegion ){Ÿ0    if( !osUnmapViewOfFile(pFile->pMapRegion) ){Ÿ*      pFile->lastErrno = osGetLastError();Ÿ>      OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, pMapRegion=%p, "ŸH               "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(), pFile,Ÿ#               pFile->pMapRegion));Ÿ=      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,Ÿ8                         "winUnmapfile1", pFile->zPath);•    }∫    pFile->pMapRegion = 0;∏    pFile->mmapSize = 0;æ    pFile->mmapSizeActual = 0;£  }∫  if( pFile->hMap!=NULL ){Ÿ&    if( !osCloseHandle(pFile->hMap) ){Ÿ*      pFile->lastErrno = osGetLastError();ŸO      OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, rc=SQLITE_IOERR_MMAP\n",Ÿ=               osGetCurrentProcessId(), pFile, pFile->hMap));Ÿ=      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,Ÿ8                         "winUnmapfile2", pFile->zPath);•    }∑    pFile->hMap = NULL;£  }Ÿ:  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",Ÿ,           osGetCurrentProcessId(), pFile));≥  return SQLITE_OK;°}†¢/*ŸJ** Memory map or remap the file opened by file-descriptor pFd (if the fileŸJ** is already mapped, the existing mapping is replaced by the new). Or, ifŸD** there already exists a mapping for this file, and there are stillŸC** outstanding xFetch() references to it, this function is a no-op.¢**ŸG** If parameter nByte is non-negative, then it is the requested size ofŸI** the mapping to create. Otherwise, if nByte is less than zero, then theŸI** requested size is the size of the file on disk. The actual size of theŸG** created mapping is either the requested size or the value configuredŸ6** using SQLITE_FCNTL_MMAP_SIZE, whichever is smaller.¢**ŸG** SQLITE_OK is returned if no error occurs (even if the mapping is notŸF** recreated as a result of outstanding references) or an SQLite error≤** code otherwise.¢*/Ÿ9static int winMapfile(winFile *pFd, sqlite3_int64 nByte){Ω  sqlite3_int64 nMap = nByte;©  int rc;†Ÿ)  assert( nMap>=0 || pFd->nFetchOut==0 );Ÿ5  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, size=%lld\n",Ÿ1           osGetCurrentProcessId(), pFd, nByte));†Ÿ*  if( pFd->nFetchOut>0 ) return SQLITE_OK;†Ø  if( nMap<0 ){Ÿ0    rc = winFileSize((sqlite3_file*)pFd, &nMap);≠    if( rc ){ŸE      OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_IOERR_FSTAT\n",Ÿ.               osGetCurrentProcessId(), pFd));Ÿ       return SQLITE_IOERR_FSTAT;•    }£  }æ  if( nMap>pFd->mmapSizeMax ){º    nMap = pFd->mmapSizeMax;£  }Ÿ6  nMap &= ~(sqlite3_int64)(winSysInfo.dwPageSize - 1);†Ÿ#  if( nMap==0 && pFd->mmapSize>0 ){∂    winUnmapfile(pFd);£  }º  if( nMap!=pFd->mmapSize ){≥    void *pNew = 0;Ÿ"    DWORD protect = PAGE_READONLY;Ÿ     DWORD flags = FILE_MAP_READ;†∂    winUnmapfile(pFd);º#ifdef SQLITE_MMAP_READWRITEŸ/    if( (pFd->ctrlFlags & WINFILE_RDONLY)==0 ){ø      protect = PAGE_READWRITE;æ      flags |= FILE_MAP_WRITE;•    }¶#endif≥#if SQLITE_OS_WINRTŸN    pFd->hMap = osCreateFileMappingFromApp(pFd->h, NULL, protect, nMap, NULL);Ÿ$#elif defined(SQLITE_WIN32_HAS_WIDE)Ÿ;    pFd->hMap = osCreateFileMappingW(pFd->h, NULL, protect,ŸA                                (DWORD)((nMap>>32) & 0xffffffff),ŸB                                (DWORD)(nMap & 0xffffffff), NULL);ŸG#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGAŸ;    pFd->hMap = osCreateFileMappingA(pFd->h, NULL, protect,ŸA                                (DWORD)((nMap>>32) & 0xffffffff),ŸB                                (DWORD)(nMap & 0xffffffff), NULL);¶#endif∫    if( pFd->hMap==NULL ){Ÿ(      pFd->lastErrno = osGetLastError();Ÿ9      rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,Ÿ2                       "winMapfile1", pFd->zPath);ŸK      /* Log the error, but continue normal operation using xRead/xWrite */Ÿ<      OSTRACE(("MAP-FILE-CREATE pid=%lu, pFile=%p, rc=%s\n",ŸB               osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));∑      return SQLITE_OK;•    }Ÿ0    assert( (nMap % winSysInfo.dwPageSize)==0 );ŸH    assert( sizeof(SIZE_T)==sizeof(sqlite3_int64) || nMap<=0xffffffff );≥#if SQLITE_OS_WINRTŸE    pNew = osMapViewOfFileFromApp(pFd->hMap, flags, 0, (SIZE_T)nMap);•#elseŸA    pNew = osMapViewOfFile(pFd->hMap, flags, 0, 0, (SIZE_T)nMap);¶#endifµ    if( pNew==NULL ){ø      osCloseHandle(pFd->hMap);∑      pFd->hMap = NULL;Ÿ(      pFd->lastErrno = osGetLastError();Ÿ9      rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,Ÿ2                       "winMapfile2", pFd->zPath);ŸK      /* Log the error, but continue normal operation using xRead/xWrite */Ÿ9      OSTRACE(("MAP-FILE-MAP pid=%lu, pFile=%p, rc=%s\n",ŸB               osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));∑      return SQLITE_OK;•    }ª    pFd->pMapRegion = pNew;π    pFd->mmapSize = nMap;ø    pFd->mmapSizeActual = nMap;£  }†Ÿ8  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",Ÿ*           osGetCurrentProcessId(), pFd));≥  return SQLITE_OK;°}Ÿ##endif /* SQLITE_MAX_MMAP_SIZE>0 */†¢/*ŸK** If possible, return a pointer to a mapping of file fd starting at offsetŸ;** iOff. The mapping must be valid for at least nAmt bytes.¢**ŸK** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.ŸL** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.ŸJ** Finally, if an error does occur, return an SQLite error code. The finalŸ*** value of *pp is undefined in this case.¢**ŸE** If this function does return a pointer, the caller must eventuallyŸ1** release the reference by calling winUnfetch().¢*/ŸEstatic int winFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){∫#if SQLITE_MAX_MMAP_SIZE>0ŸC  winFile *pFd = (winFile*)fd;   /* The underlying database file */¶#endif™  *pp = 0;†ŸF  OSTRACE(("FETCH pid=%lu, pFile=%p, offset=%lld, amount=%d, pp=%p\n",Ÿ9           osGetCurrentProcessId(), fd, iOff, nAmt, pp));†∫#if SQLITE_MAX_MMAP_SIZE>0ª  if( pFd->mmapSizeMax>0 ){Ω    if( pFd->pMapRegion==0 ){Ÿ#      int rc = winMapfile(pFd, -1);∫      if( rc!=SQLITE_OK ){Ÿ4        OSTRACE(("FETCH pid=%lu, pFile=%p, rc=%s\n",ŸD                 osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));≤        return rc;ß      }•    }Ÿ%    if( pFd->mmapSize >= iOff+nAmt ){Ÿ+      *pp = &((u8 *)pFd->pMapRegion)[iOff];∑      pFd->nFetchOut++;•    }£  }¶#endif†ŸD  OSTRACE(("FETCH pid=%lu, pFile=%p, pp=%p, *pp=%p, rc=SQLITE_OK\n",Ÿ2           osGetCurrentProcessId(), fd, pp, *pp));≥  return SQLITE_OK;°}†¢/*ŸC** If the third argument is non-NULL, then this function releases aŸB** reference obtained by an earlier call to winFetch(). The secondŸI** argument passed to this function must be the same as the correspondingŸ9** argument that was passed to the winFetch() invocation.¢**ŸH** Or, if the third argument is NULL, then this function is being calledŸI** to inform the VFS layer that, according to POSIX, any existing mappingŸ-** may now be invalid and should be unmapped.¢*/Ÿ;static int winUnfetch(sqlite3_file *fd, i64 iOff, void *p){∫#if SQLITE_MAX_MMAP_SIZE>0ŸC  winFile *pFd = (winFile*)fd;   /* The underlying database file */†ŸF  /* If p==0 (unmap the entire file) then there must be no outstandingŸH  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),Ÿ5  ** then there must be at least one outstanding.  */Ÿ(  assert( (p==0)==(pFd->nFetchOut==0) );†Ÿ.  /* If p!=0, it must match the iOff value. */Ÿ6  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] );†Ÿ<  OSTRACE(("UNFETCH pid=%lu, pFile=%p, offset=%lld, p=%p\n",Ÿ3           osGetCurrentProcessId(), pFd, iOff, p));†™  if( p ){µ    pFd->nFetchOut--;®  }else{ŸH    /* FIXME:  If Windows truly always prevents truncating or deleting aŸK    ** file while a mapping is held, then the following winUnmapfile() callŸ<    ** is unnecessary can be omitted - potentially improving∑    ** performance.  */∂    winUnmapfile(pFd);£  }†æ  assert( pFd->nFetchOut>=0 );¶#endif†Ÿ7  OSTRACE(("UNFETCH pid=%lu, pFile=%p, rc=SQLITE_OK\n",Ÿ)           osGetCurrentProcessId(), fd));≥  return SQLITE_OK;°}†¢/*Ÿ<** Here ends the implementation of all sqlite3_file methods.¢**ŸO********************** End sqlite3_file Methods *******************************ŸO******************************************************************************/†¢/*Ÿ=** This vector defines all the methods that can operate on an∫** sqlite3_file for win32.¢*/Ÿ/static const sqlite3_io_methods winIoMethod = {Ÿ0  3,                              /* iVersion */Ÿ.  winClose,                       /* xClose */Ÿ-  winRead,                        /* xRead */Ÿ.  winWrite,                       /* xWrite */Ÿ1  winTruncate,                    /* xTruncate */Ÿ-  winSync,                        /* xSync */Ÿ1  winFileSize,                    /* xFileSize */Ÿ-  winLock,                        /* xLock */Ÿ/  winUnlock,                      /* xUnlock */Ÿ:  winCheckReservedLock,           /* xCheckReservedLock */Ÿ4  winFileControl,                 /* xFileControl */Ÿ3  winSectorSize,                  /* xSectorSize */Ÿ>  winDeviceCharacteristics,       /* xDeviceCharacteristics */Ÿ/  winShmMap,                      /* xShmMap */Ÿ0  winShmLock,                     /* xShmLock */Ÿ3  winShmBarrier,                  /* xShmBarrier */Ÿ1  winShmUnmap,                    /* xShmUnmap */Ÿ.  winFetch,                       /* xFetch */Ÿ0  winUnfetch                      /* xUnfetch */¢};†¢/*Ÿ=** This vector defines all the methods that can operate on anŸ9** sqlite3_file for win32 without performing any locking.¢*/Ÿ5static const sqlite3_io_methods winIoNolockMethod = {Ÿ0  3,                              /* iVersion */Ÿ.  winClose,                       /* xClose */Ÿ-  winRead,                        /* xRead */Ÿ.  winWrite,                       /* xWrite */Ÿ1  winTruncate,                    /* xTruncate */Ÿ-  winSync,                        /* xSync */Ÿ1  winFileSize,                    /* xFileSize */Ÿ-  winNolockLock,                  /* xLock */Ÿ/  winNolockUnlock,                /* xUnlock */Ÿ:  winNolockCheckReservedLock,     /* xCheckReservedLock */Ÿ4  winFileControl,                 /* xFileControl */Ÿ3  winSectorSize,                  /* xSectorSize */Ÿ>  winDeviceCharacteristics,       /* xDeviceCharacteristics */Ÿ/  winShmMap,                      /* xShmMap */Ÿ0  winShmLock,                     /* xShmLock */Ÿ3  winShmBarrier,                  /* xShmBarrier */Ÿ1  winShmUnmap,                    /* xShmUnmap */Ÿ.  winFetch,                       /* xFetch */Ÿ0  winUnfetch                      /* xUnfetch */¢};†Ÿ#static winVfsAppData winAppData = {Ÿ#  &winIoMethod,       /* pMethod */Ÿ$  0,                  /* pAppData */Ÿ#  0                   /* bNoLock */¢};†Ÿ)static winVfsAppData winNolockAppData = {Ÿ#  &winIoNolockMethod, /* pMethod */Ÿ$  0,                  /* pAppData */Ÿ#  1                   /* bNoLock */¢};†ŸM/****************************************************************************ŸM**************************** sqlite3_vfs methods ****************************¢**Ÿ>** This division contains the implementation of methods on the∂** sqlite3_vfs object.¢*/†∑#if defined(__CYGWIN__)¢/*ŸC** Convert a filename from whatever the underlying operating systemŸB** supports for filenames into UTF-8.  Space to hold the result isŸB** obtained from malloc and must be freed by the calling function.¢*/Ÿ=static char *winConvertToUtf8Filename(const void *zFilename){∑  char *zConverted = 0;±  if( osIsNT() ){Ÿ-    zConverted = winUnicodeToUtf8(zFilename);£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{Ÿ?    zConverted = winMbcsToUtf8(zFilename, osAreFileApisANSI());£  }¶#endifŸ(  /* caller will handle out of memory */¥  return zConverted;°}¶#endif†¢/*Ÿ=** Convert a UTF-8 filename into whatever form the underlyingŸA** operating system wants filenames in.  Space to hold the resultŸ;** is obtained from malloc and must be freed by the calling¨** function.¢*/Ÿ?static void *winConvertFromUtf8Filename(const char *zFilename){∑  void *zConverted = 0;±  if( osIsNT() ){Ÿ-    zConverted = winUtf8ToUnicode(zFilename);£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{Ÿ?    zConverted = winUtf8ToMbcs(zFilename, osAreFileApisANSI());£  }¶#endifŸ(  /* caller will handle out of memory */¥  return zConverted;°}†¢/*ŸF** This function returns non-zero if the specified UTF-8 string bufferŸD** ends with a directory separator character or one was successfullyØ** added to it.¢*/Ÿ4static int winMakeEndInDirSep(int nBuf, char *zBuf){≠  if( zBuf ){Ÿ%    int nLen = sqlite3Strlen30(zBuf);±    if( nLen>0 ){Ÿ&      if( winIsDirSep(zBuf[nLen-1]) ){±        return 1;æ      }else if( nLen+1<nBuf ){Ÿ$        zBuf[nLen] = winGetDirSep();º        zBuf[nLen+1] = '\0';±        return 1;ß      }•    }£  }´  return 0;°}†¢/*ŸK** Create a temporary file name and store the resulting pointer into pzBuf.ŸB** The pointer returned in pzBuf must be freed via sqlite3_free().¢*/Ÿ;static int winGetTempname(sqlite3_vfs *pVfs, char **pzBuf){∏  static char zChars[] =Ÿ     "abcdefghijklmnopqrstuvwxyz"Ÿ     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"±    "0123456789";Æ  size_t i, j;Ÿ6  int nPre = sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX);Ω  int nMax, nBuf, nDir, nLen;≠  char *zBuf;†ŸC  /* It's odd to simulate an io-error here, but really this is justŸG  ** using the io-error infrastructure to test that SQLite handles this∂  ** function failing.§  */Ÿ)  SimulateIOError( return SQLITE_IOERR );†ŸB  /* Allocate a temporary buffer to store the fully qualified fileŸE  ** name for the temporary file.  If this fails, we cannot continue.§  */Ÿ+  nMax = pVfs->mxPathname; nBuf = nMax + 2;Ÿ#  zBuf = sqlite3MallocZero( nBuf );Æ  if( !zBuf ){Ÿ7    OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }†ŸG  /* Figure out the effective temporary directory.  First, check if oneŸG  ** has been explicitly set by the application; otherwise, use the oneŸ(  ** configured by the operating system.§  */º  nDir = nMax - (nPre + 15);≥  assert( nDir>0 );ø  if( sqlite3_temp_directory ){Ÿ:    int nDirLen = sqlite3Strlen30(sqlite3_temp_directory);¥    if( nDirLen>0 ){Ÿ<      if( !winIsDirSep(sqlite3_temp_directory[nDirLen-1]) ){≤        nDirLen++;ß      }π      if( nDirLen>nDir ){ª        sqlite3_free(zBuf);Ÿ5        OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));ŸB        return winLogError(SQLITE_ERROR, 0, "winGetTempname1", 0);ß      }ŸA      sqlite3_snprintf(nMax, zBuf, "%s", sqlite3_temp_directory);•    }£  }∑#if defined(__CYGWIN__)ß  else{Ÿ#    static const char *azDirs[] = {Ÿ'       0, /* getenv("SQLITE_TMPDIR") */Ÿ        0, /* getenv("TMPDIR") */Ω       0, /* getenv("TMP") */æ       0, /* getenv("TEMP") */Ÿ%       0, /* getenv("USERPROFILE") */≤       "/var/tmp",≤       "/usr/tmp",Æ       "/tmp",´       ".",Ÿ%       0        /* List terminator */¶    };≥    unsigned int i;π    const char *zDir = 0;†Ÿ9    if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");Ÿ2    if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");Ÿ/    if( !azDirs[2] ) azDirs[2] = getenv("TMP");Ÿ0    if( !azDirs[3] ) azDirs[3] = getenv("TEMP");Ÿ7    if( !azDirs[4] ) azDirs[4] = getenv("USERPROFILE");ŸC    for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){∑      void *zConverted;Ω      if( zDir==0 ) continue;ŸE      /* If the path starts with a drive letter followed by the colonŸH      ** character, assume it is already a native Win32 path; otherwise,ŸG      ** it must be converted to a native Win32 path via the Cygwin APIª      ** prior to using it.®      */Ÿ+      if( winIsDriveLetterAndColon(zDir) ){Ÿ6        zConverted = winConvertFromUtf8Filename(zDir);∫        if( !zConverted ){Ω          sqlite3_free(zBuf);Ÿ=          OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ)          return SQLITE_IOERR_NOMEM_BKPT;©        }Ÿ#        if( winIsDir(zConverted) ){Ÿ3          sqlite3_snprintf(nMax, zBuf, "%s", zDir);Ÿ#          sqlite3_free(zConverted);∞          break;©        }Ÿ!        sqlite3_free(zConverted);¨      }else{Ÿ1        zConverted = sqlite3MallocZero( nMax+1 );∫        if( !zConverted ){Ω          sqlite3_free(zBuf);Ÿ=          OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ)          return SQLITE_IOERR_NOMEM_BKPT;©        }Ω        if( cygwin_conv_path(ŸI                osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A, zDir,Ÿ(                zConverted, nMax+1)<0 ){Ÿ#          sqlite3_free(zConverted);Ω          sqlite3_free(zBuf);Ÿ@          OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\n"));ŸA          return winLogError(SQLITE_IOERR_CONVPATH, (DWORD)errno,Ÿ6                             "winGetTempname2", zDir);©        }Ÿ#        if( winIsDir(zConverted) ){ŸM          /* At this point, we know the candidate directory exists and shouldŸL          ** be used.  However, we may need to convert the string containingŸB          ** its name into UTF-8 (i.e. if it is UTF-16 right now).¨          */Ÿ=          char *zUtf8 = winConvertToUtf8Filename(zConverted);∑          if( !zUtf8 ){Ÿ%            sqlite3_free(zConverted);ø            sqlite3_free(zBuf);Ÿ?            OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ+            return SQLITE_IOERR_NOMEM_BKPT;´          }Ÿ4          sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);æ          sqlite3_free(zUtf8);Ÿ#          sqlite3_free(zConverted);∞          break;©        }Ÿ!        sqlite3_free(zConverted);ß      }•    }£  }Ÿ.#elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)∂  else if( osIsNT() ){±    char *zMulti;Ÿ?    LPWSTR zWidePath = sqlite3MallocZero( nMax*sizeof(WCHAR) );µ    if( !zWidePath ){π      sqlite3_free(zBuf);Ÿ9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }Ÿ-    if( osGetTempPathW(nMax, zWidePath)==0 ){æ      sqlite3_free(zWidePath);π      sqlite3_free(zBuf);Ÿ?      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));ŸD      return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),Ÿ/                         "winGetTempname2", 0);•    }Ÿ)    zMulti = winUnicodeToUtf8(zWidePath);±    if( zMulti ){Ÿ1      sqlite3_snprintf(nMax, zBuf, "%s", zMulti);ª      sqlite3_free(zMulti);æ      sqlite3_free(zWidePath);™    }else{æ      sqlite3_free(zWidePath);π      sqlite3_free(zBuf);Ÿ9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{∞    char *zUtf8;Ÿ0    char *zMbcsPath = sqlite3MallocZero( nMax );µ    if( !zMbcsPath ){π      sqlite3_free(zBuf);Ÿ9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }Ÿ-    if( osGetTempPathA(nMax, zMbcsPath)==0 ){π      sqlite3_free(zBuf);Ÿ?      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));ŸD      return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),Ÿ/                         "winGetTempname3", 0);•    }Ÿ:    zUtf8 = winMbcsToUtf8(zMbcsPath, osAreFileApisANSI());∞    if( zUtf8 ){Ÿ0      sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);∫      sqlite3_free(zUtf8);™    }else{π      sqlite3_free(zBuf);Ÿ9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }£  }Ÿ"#endif /* SQLITE_WIN32_HAS_ANSI */Ω#endif /* !SQLITE_OS_WINRT */†§  /*ŸH  ** Check to make sure the temporary directory ends with an appropriateŸI  ** separator.  If it does not and there is not enough space left to addØ  ** one, fail.§  */Ÿ*  if( !winMakeEndInDirSep(nDir+1, zBuf) ){∑    sqlite3_free(zBuf);Ÿ1    OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));Ÿ>    return winLogError(SQLITE_ERROR, 0, "winGetTempname4", 0);£  }†§  /*ŸH  ** Check that the output buffer is large enough for the temporary fileŸ"  ** name in the following format:§  **Ÿ9  **   "<temporary_directory>/etilqs_XXXXXXXXXXXXXXX\0\0"§  **ŸI  ** If not, return SQLITE_ERROR.  The number 17 is used here in order toŸI  ** account for the space used by the 15 character random suffix and theŸJ  ** two trailing NUL characters.  The final directory separator characterŸ5  ** has already added if it was not already present.§  */ø  nLen = sqlite3Strlen30(zBuf);Ÿ"  if( (nLen + nPre + 17) > nBuf ){∑    sqlite3_free(zBuf);Ÿ1    OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));Ÿ>    return winLogError(SQLITE_ERROR, 0, "winGetTempname5", 0);£  }†ŸE  sqlite3_snprintf(nBuf-16-nLen, zBuf+nLen, SQLITE_TEMP_FILE_PREFIX);†º  j = sqlite3Strlen30(zBuf);Ÿ#  sqlite3_randomness(15, &zBuf[j]);ª  for(i=0; i<15; i++, j++){ŸJ    zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];£  }Æ  zBuf[j] = 0;∞  zBuf[j+1] = 0;∞  *pzBuf = zBuf;†Ÿ;  OSTRACE(("TEMP-FILENAME name=%s, rc=SQLITE_OK\n", zBuf));≥  return SQLITE_OK;°}†¢/*ŸH** Return TRUE if the named file is really a directory.  Return false ifŸL** it is something other than a directory, or if there is any kind of memory∂** allocation failure.¢*/Ÿ,static int winIsDir(const void *zConverted){≠  DWORD attr;≠  int rc = 0;≤  DWORD lastErrno;†±  if( osIsNT() ){∞    int cnt = 0;Ÿ(    WIN32_FILE_ATTRIBUTE_DATA sAttrData;Ÿ-    memset(&sAttrData, 0, sizeof(sAttrData));Ÿ=    while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,Ÿ3                             GetFileExInfoStandard,ŸP                             &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}Æ    if( !rc ){Ÿ#      return 0; /* Invalid name? */•    }Ÿ&    attr = sAttrData.dwFileAttributes;∂#if SQLITE_OS_WINCE==0®  }else{Ÿ3    attr = osGetFileAttributesA((char*)zConverted);¶#endif£  }ŸL  return (attr!=INVALID_FILE_ATTRIBUTES) && (attr&FILE_ATTRIBUTE_DIRECTORY);°}†∑/* forward reference */µstatic int winAccess(Ÿ4  sqlite3_vfs *pVfs,         /* Not used on win32 */Ÿ8  const char *zFilename,     /* Name of file to check */ŸD  int flags,                 /* Type of test to make on this file */Ÿ.  int *pResOut               /* OUT: Result */¢);†¢/*Ø** Open a file.¢*/≥static int winOpen(ŸM  sqlite3_vfs *pVfs,        /* Used to get maximum path length and AppData */Ÿ:  const char *zName,        /* Name of the file (UTF-8) */ŸC  sqlite3_file *id,         /* Write the SQLite file handle here */Ÿ1  int flags,                /* Open mode flags */Ÿ5  int *pOutFlags            /* Status return flags */¢){´  HANDLE h;∂  DWORD lastErrno = 0;∏  DWORD dwDesiredAccess;¥  DWORD dwShareMode;æ  DWORD dwCreationDisposition;Ÿ!  DWORD dwFlagsAndAttributes = 0;≥#if SQLITE_OS_WINCE±  int isTemp = 0;¶#endif∫  winVfsAppData *pAppData;Ÿ   winFile *pFile = (winFile*)id;Ÿ>  void *zConverted;              /* Filename in OS encoding */ŸA  const char *zUtf8Name = zName; /* Filename in UTF-8 encoding */Æ  int cnt = 0;†ŸK  /* If argument zPath is a NULL pointer, this function is required to openŸA  ** a temporary file. Use this buffer to store the file name in.§  */ŸA  char *zTmpname = 0; /* For temporary filename, if necessary. */†Ÿ;  int rc = SQLITE_OK;            /* Function Return Code */Ÿ'#if !defined(NDEBUG) || SQLITE_OS_WINCEŸ;  int eType = flags&0xFFFFFF00;  /* Type of file to open */¶#endif†Ÿ5  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);Ÿ9  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);Ÿ2  int isCreate     = (flags & SQLITE_OPEN_CREATE);Ÿ4  int isReadonly   = (flags & SQLITE_OPEN_READONLY);Ÿ5  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);†Æ#ifndef NDEBUGŸ$  int isOpenJournal = (isCreate && (Ÿ)        eType==SQLITE_OPEN_MASTER_JOURNALŸ'     || eType==SQLITE_OPEN_MAIN_JOURNALæ     || eType==SQLITE_OPEN_WAL•  ));¶#endif†Ÿ>  OSTRACE(("OPEN name=%s, pFile=%p, flags=%x, pOutFlags=%p\n",Ÿ-           zUtf8Name, id, flags, pOutFlags));†Ÿ-  /* Check the following statements are true:§  **ŸK  **   (a) Exactly one of the READWRITE and READONLY flags must be set, andŸA  **   (b) if CREATE is set, then READWRITE must also be set, andŸ=  **   (c) if EXCLUSIVE is set, then CREATE must also be set.ŸA  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.§  */ŸK  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));Ÿ%  assert(isCreate==0 || isReadWrite);Ÿ%  assert(isExclusive==0 || isCreate);Ÿ"  assert(isDelete==0 || isCreate);†ŸE  /* The main DB, main journal, WAL file and master journal are neverŸB  ** automatically deleted. Nor are they ever temporary files.  */Ÿ?  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );ŸD  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );ŸF  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );Ÿ;  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );†ŸI  /* Assert that the upper layer has set one of the "file-type" flags. */ŸG  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DBŸL       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNALŸN       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNALŸC       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL§  );†µ  assert( pFile!=0 );Ÿ$  memset(pFile, 0, sizeof(winFile));Ÿ"  pFile->h = INVALID_HANDLE_VALUE;†≥#if SQLITE_OS_WINRTŸ.  if( !zUtf8Name && !sqlite3_temp_directory ){Ω    sqlite3_log(SQLITE_ERROR,ŸC        "sqlite3_temp_directory variable should be set for WinRT");£  }¶#endif†Ÿ@  /* If the second argument to this function is NULL, generate aø  ** temporary file name to use§  */≥  if( !zUtf8Name ){Ÿ)    assert( isDelete && !isOpenJournal );Ÿ)    rc = winGetTempname(pVfs, &zTmpname);∏    if( rc!=SQLITE_OK ){ŸF      OSTRACE(("OPEN name=%s, rc=%s", zUtf8Name, sqlite3ErrName(rc)));∞      return rc;•    }π    zUtf8Name = zTmpname;£  }†ŸB  /* Database filenames are double-zero terminated if they are notŸA  ** URIs with parameters.  Hence, they can always be passed intoΩ  ** sqlite3_uri_parameter().§  */ŸF  assert( (eType!=SQLITE_OPEN_MAIN_DB) || (flags & SQLITE_OPEN_URI) ||Ÿ4       zUtf8Name[sqlite3Strlen30(zUtf8Name)+1]==0 );†Ÿ4  /* Convert the filename to the system encoding. */Ÿ5  zConverted = winConvertFromUtf8Filename(zUtf8Name);∂  if( zConverted==0 ){ª    sqlite3_free(zTmpname);Ÿ@    OSTRACE(("OPEN name=%s, rc=SQLITE_IOERR_NOMEM", zUtf8Name));Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }†Ω  if( winIsDir(zConverted) ){Ω    sqlite3_free(zConverted);ª    sqlite3_free(zTmpname);ŸC    OSTRACE(("OPEN name=%s, rc=SQLITE_CANTOPEN_ISDIR", zUtf8Name));Ÿ!    return SQLITE_CANTOPEN_ISDIR;£  }†¥  if( isReadWrite ){Ÿ3    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;®  }else{Ÿ#    dwDesiredAccess = GENERIC_READ;£  }†ŸB  /* SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file isŸB  ** created. SQLite doesn't use it to indicate "exclusive access"Ÿ!  ** as it is usually understood.§  */¥  if( isExclusive ){Ÿ@    /* Creates a new file, only if it does not already exist. */Ÿ'    /* If the file exists, it fails. */Ÿ'    dwCreationDisposition = CREATE_NEW;∑  }else if( isCreate ){Ÿ;    /* Open existing file, or create if it doesn't exist */Ÿ(    dwCreationDisposition = OPEN_ALWAYS;®  }else{Ÿ*    /* Opens a file, only if it exists. */Ÿ*    dwCreationDisposition = OPEN_EXISTING;£  }†Ÿ3  dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;†±  if( isDelete ){≥#if SQLITE_OS_WINCEŸ1    dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN;Ø    isTemp = 1;•#elseŸ3    dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARYŸ6                               | FILE_ATTRIBUTE_HIDDENŸ;                               | FILE_FLAG_DELETE_ON_CLOSE;¶#endif®  }else{Ÿ1    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;£  }Ÿ=  /* Reports from the internet are that performance is alwaysŸA  ** better if FILE_FLAG_RANDOM_ACCESS is used.  Ticket #2699. */≥#if SQLITE_OS_WINCEŸ2  dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;¶#endif†±  if( osIsNT() ){≥#if SQLITE_OS_WINRTŸ7    CREATEFILE2_EXTENDED_PARAMETERS extendedParameters;ŸH    extendedParameters.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);Ÿ)    extendedParameters.dwFileAttributes =Ÿ7            dwFlagsAndAttributes & FILE_ATTRIBUTE_MASK;ŸK    extendedParameters.dwFileFlags = dwFlagsAndAttributes & FILE_FLAG_MASK;Ÿ?    extendedParameters.dwSecurityQosFlags = SECURITY_ANONYMOUS;Ÿ3    extendedParameters.lpSecurityAttributes = NULL;Ÿ,    extendedParameters.hTemplateFile = NULL;ß    do{Ÿ,      h = osCreateFile2((LPCWSTR)zConverted,Ÿ(                        dwDesiredAccess,Ÿ$                        dwShareMode,Ÿ.                        dwCreationDisposition,Ÿ-                        &extendedParameters);Ÿ*      if( h!=INVALID_HANDLE_VALUE ) break;∏      if( isReadWrite ){∫        int rc2, isRO = 0;Ÿ#        sqlite3BeginBenignMalloc();Ÿ@        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);Ÿ!        sqlite3EndBenignMalloc();Ÿ+        if( rc2==SQLITE_OK && isRO ) break;ß      }Ÿ.    }while( winRetryIoerr(&cnt, &lastErrno) );•#elseß    do{Ÿ,      h = osCreateFileW((LPCWSTR)zConverted,Ÿ(                        dwDesiredAccess,Ÿ*                        dwShareMode, NULL,Ÿ.                        dwCreationDisposition,Ÿ-                        dwFlagsAndAttributes,æ                        NULL);Ÿ*      if( h!=INVALID_HANDLE_VALUE ) break;∏      if( isReadWrite ){∫        int rc2, isRO = 0;Ÿ#        sqlite3BeginBenignMalloc();Ÿ@        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);Ÿ!        sqlite3EndBenignMalloc();Ÿ+        if( rc2==SQLITE_OK && isRO ) break;ß      }Ÿ.    }while( winRetryIoerr(&cnt, &lastErrno) );¶#endif£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{ß    do{Ÿ+      h = osCreateFileA((LPCSTR)zConverted,Ÿ(                        dwDesiredAccess,Ÿ*                        dwShareMode, NULL,Ÿ.                        dwCreationDisposition,Ÿ-                        dwFlagsAndAttributes,æ                        NULL);Ÿ*      if( h!=INVALID_HANDLE_VALUE ) break;∏      if( isReadWrite ){∫        int rc2, isRO = 0;Ÿ#        sqlite3BeginBenignMalloc();Ÿ@        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);Ÿ!        sqlite3EndBenignMalloc();Ÿ+        if( rc2==SQLITE_OK && isRO ) break;ß      }Ÿ.    }while( winRetryIoerr(&cnt, &lastErrno) );£  }¶#endifΩ  winLogIoerr(cnt, __LINE__);†ŸF  OSTRACE(("OPEN file=%p, name=%s, access=%lx, rc=%s\n", h, zUtf8Name,ŸJ           dwDesiredAccess, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok"));†Ÿ   if( h==INVALID_HANDLE_VALUE ){Ω    sqlite3_free(zConverted);ª    sqlite3_free(zTmpname);Ÿ&    if( isReadWrite && !isExclusive ){Ÿ%      return winOpen(pVfs, zName, id,Ÿ(         ((flags|SQLITE_OPEN_READONLY) &ŸB                     ~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE)),¥         pOutFlags);™    }else{Ÿ#      pFile->lastErrno = lastErrno;ŸK      winLogError(SQLITE_CANTOPEN, pFile->lastErrno, "winOpen", zUtf8Name);Ÿ"      return SQLITE_CANTOPEN_BKPT;•    }£  }†≤  if( pOutFlags ){∂    if( isReadWrite ){Ÿ)      *pOutFlags = SQLITE_OPEN_READWRITE;™    }else{Ÿ(      *pOutFlags = SQLITE_OPEN_READONLY;•    }£  }†ŸM  OSTRACE(("OPEN file=%p, name=%s, access=%lx, pOutFlags=%p, *pOutFlags=%d, "ŸK           "rc=%s\n", h, zUtf8Name, dwDesiredAccess, pOutFlags, pOutFlags ?ŸI           *pOutFlags : 0, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok"));†Ÿ,  pAppData = (winVfsAppData*)pVfs->pAppData;†≥#if SQLITE_OS_WINCE£  {Ÿ1    if( isReadWrite && eType==SQLITE_OPEN_MAIN_DBŸ4         && ((pAppData==NULL) || !pAppData->bNoLock)Ÿ;         && (rc = winceCreateLock(zName, pFile))!=SQLITE_OK¶    ){∑      osCloseHandle(h);ø      sqlite3_free(zConverted);Ω      sqlite3_free(zTmpname);ŸL      OSTRACE(("OPEN-CE-LOCK name=%s, rc=%s\n", zName, sqlite3ErrName(rc)));∞      return rc;•    }£  }Ø  if( isTemp ){Ÿ'    pFile->zDeleteOnClose = zConverted;ß  }else¶#endif£  {Ω    sqlite3_free(zConverted);£  }†π  sqlite3_free(zTmpname);Ÿ?  pFile->pMethod = pAppData ? pAppData->pMethod : &winIoMethod;µ  pFile->pVfs = pVfs;Ø  pFile->h = h;≥  if( isReadonly ){Ÿ'    pFile->ctrlFlags |= WINFILE_RDONLY;£  }ŸG  if( sqlite3_uri_boolean(zName, "psow", SQLITE_POWERSAFE_OVERWRITE) ){Ÿ%    pFile->ctrlFlags |= WINFILE_PSOW;£  }æ  pFile->lastErrno = NO_ERROR;∑  pFile->zPath = zName;∫#if SQLITE_MAX_MMAP_SIZE>0µ  pFile->hMap = NULL;∏  pFile->pMapRegion = 0;∂  pFile->mmapSize = 0;º  pFile->mmapSizeActual = 0;Ÿ2  pFile->mmapSizeMax = sqlite3GlobalConfig.szMmap;¶#endif†≤  OpenCounter(+1);¨  return rc;°}†¢/*π** Delete the named file.¢**ŸF** Note that Windows does not allow a file to be deleted if some otherŸF** process has it open.  Sometimes a virus scanner or indexing programŸF** will open a journal file shortly after it is created in order to doŸ=** whatever it does.  While this other process is holding theŸB** file open, we will be unable to delete it.  To work around thisŸB** problem, we delay 100 milliseconds and try to delete again.  UpŸB** to MX_DELETION_ATTEMPTs deletion attempts are run before givingΩ** up and returning an error.¢*/µstatic int winDelete(Ÿ5  sqlite3_vfs *pVfs,          /* Not used on win32 */Ÿ:  const char *zFilename,      /* Name of file to delete */Ÿ5  int syncDir                 /* Not used on win32 */¢){Æ  int cnt = 0;©  int rc;≠  DWORD attr;∂  DWORD lastErrno = 0;≥  void *zConverted;π  UNUSED_PARAMETER(pVfs);º  UNUSED_PARAMETER(syncDir);†Ÿ.  SimulateIOError(return SQLITE_IOERR_DELETE);Ÿ@  OSTRACE(("DELETE name=%s, syncDir=%d\n", zFilename, syncDir));†Ÿ5  zConverted = winConvertFromUtf8Filename(zFilename);∂  if( zConverted==0 ){ŸD    OSTRACE(("DELETE name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }±  if( osIsNT() ){®    do {≥#if SQLITE_OS_WINRTŸ*      WIN32_FILE_ATTRIBUTE_DATA sAttrData;Ÿ/      memset(&sAttrData, 0, sizeof(sAttrData));ŸD      if ( osGetFileAttributesExW(zConverted, GetFileExInfoStandard,Ÿ0                                  &sAttrData) ){Ÿ*        attr = sAttrData.dwFileAttributes;¨      }else{Ÿ%        lastErrno = osGetLastError();Ÿ+        if( lastErrno==ERROR_FILE_NOT_FOUNDŸ.         || lastErrno==ERROR_PATH_NOT_FOUND ){Ÿ=          rc = SQLITE_IOERR_DELETE_NOENT; /* Already gone? */Æ        }else{º          rc = SQLITE_ERROR;©        }Æ        break;ß      }•#elseŸ.      attr = osGetFileAttributesW(zConverted);¶#endifŸ+      if ( attr==INVALID_FILE_ATTRIBUTES ){Ÿ%        lastErrno = osGetLastError();Ÿ+        if( lastErrno==ERROR_FILE_NOT_FOUNDŸ.         || lastErrno==ERROR_PATH_NOT_FOUND ){Ÿ=          rc = SQLITE_IOERR_DELETE_NOENT; /* Already gone? */Æ        }else{º          rc = SQLITE_ERROR;©        }Æ        break;ß      }Ÿ+      if ( attr&FILE_ATTRIBUTE_DIRECTORY ){Ÿ,        rc = SQLITE_ERROR; /* Files only. */Æ        break;ß      }Ÿ'      if ( osDeleteFileW(zConverted) ){Ÿ)        rc = SQLITE_OK; /* Deleted OK. */Æ        break;ß      }Ÿ.      if ( !winRetryIoerr(&cnt, &lastErrno) ){Ÿ1        rc = SQLITE_ERROR; /* No more retries. */Æ        break;ß      }Ø    } while(1);£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{®    do {Ÿ.      attr = osGetFileAttributesA(zConverted);Ÿ+      if ( attr==INVALID_FILE_ATTRIBUTES ){Ÿ%        lastErrno = osGetLastError();Ÿ+        if( lastErrno==ERROR_FILE_NOT_FOUNDŸ.         || lastErrno==ERROR_PATH_NOT_FOUND ){Ÿ=          rc = SQLITE_IOERR_DELETE_NOENT; /* Already gone? */Æ        }else{º          rc = SQLITE_ERROR;©        }Æ        break;ß      }Ÿ+      if ( attr&FILE_ATTRIBUTE_DIRECTORY ){Ÿ,        rc = SQLITE_ERROR; /* Files only. */Æ        break;ß      }Ÿ'      if ( osDeleteFileA(zConverted) ){Ÿ)        rc = SQLITE_OK; /* Deleted OK. */Æ        break;ß      }Ÿ.      if ( !winRetryIoerr(&cnt, &lastErrno) ){Ÿ1        rc = SQLITE_ERROR; /* No more retries. */Æ        break;ß      }Ø    } while(1);£  }¶#endifŸ,  if( rc && rc!=SQLITE_IOERR_DELETE_NOENT ){ŸM    rc = winLogError(SQLITE_IOERR_DELETE, lastErrno, "winDelete", zFilename);®  }else{ø    winLogIoerr(cnt, __LINE__);£  }ª  sqlite3_free(zConverted);ŸF  OSTRACE(("DELETE name=%s, rc=%s\n", zFilename, sqlite3ErrName(rc)));¨  return rc;°}†¢/*Ÿ,** Check the existence and status of a file.¢*/µstatic int winAccess(Ÿ4  sqlite3_vfs *pVfs,         /* Not used on win32 */Ÿ8  const char *zFilename,     /* Name of file to check */ŸD  int flags,                 /* Type of test to make on this file */Ÿ.  int *pResOut               /* OUT: Result */¢){≠  DWORD attr;≠  int rc = 0;∂  DWORD lastErrno = 0;≥  void *zConverted;π  UNUSED_PARAMETER(pVfs);†Ÿ1  SimulateIOError( return SQLITE_IOERR_ACCESS; );Ÿ4  OSTRACE(("ACCESS name=%s, flags=%x, pResOut=%p\n",Ÿ'           zFilename, flags, pResOut));†Ÿ5  zConverted = winConvertFromUtf8Filename(zFilename);∂  if( zConverted==0 ){ŸD    OSTRACE(("ACCESS name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }±  if( osIsNT() ){∞    int cnt = 0;Ÿ(    WIN32_FILE_ATTRIBUTE_DATA sAttrData;Ÿ-    memset(&sAttrData, 0, sizeof(sAttrData));Ÿ=    while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,Ÿ3                             GetFileExInfoStandard,ŸP                             &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}≠    if( rc ){ŸD      /* For an SQLITE_ACCESS_EXISTS query, treat a zero-length fileŸ!      ** as if it does not exist.®      */Ÿ(      if(    flags==SQLITE_ACCESS_EXISTSŸ'          && sAttrData.nFileSizeHigh==0Ÿ)          && sAttrData.nFileSizeLow==0 ){Ÿ'        attr = INVALID_FILE_ATTRIBUTES;¨      }else{Ÿ*        attr = sAttrData.dwFileAttributes;ß      }™    }else{Ÿ!      winLogIoerr(cnt, __LINE__);ŸO      if( lastErrno!=ERROR_FILE_NOT_FOUND && lastErrno!=ERROR_PATH_NOT_FOUND ){Ÿ!        sqlite3_free(zConverted);ŸG        return winLogError(SQLITE_IOERR_ACCESS, lastErrno, "winAccess",Ÿ&                           zFilename);¨      }else{Ÿ'        attr = INVALID_FILE_ATTRIBUTES;ß      }•    }£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{Ÿ3    attr = osGetFileAttributesA((char*)zConverted);£  }¶#endifª  sqlite3_free(zConverted);≤  switch( flags ){º    case SQLITE_ACCESS_READ:æ    case SQLITE_ACCESS_EXISTS:Ÿ)      rc = attr!=INVALID_FILE_ATTRIBUTES;¨      break;Ÿ!    case SQLITE_ACCESS_READWRITE:Ÿ+      rc = attr!=INVALID_FILE_ATTRIBUTES &&Ÿ1             (attr & FILE_ATTRIBUTE_READONLY)==0;¨      break;¨    default:Ÿ(      assert(!"Invalid flags argument");£  }∞  *pResOut = rc;ŸE  OSTRACE(("ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",Ÿ*           zFilename, pResOut, *pResOut));≥  return SQLITE_OK;°}†¢/*ŸI** Returns non-zero if the specified path name starts with a drive letterŸ!** followed by a colon character.¢*/Ÿ%static BOOL winIsDriveLetterAndColon(∑  const char *zPathname¢){Ÿ?  return ( sqlite3Isalpha(zPathname[0]) && zPathname[1]==':' );°}†¢/*ŸK** Returns non-zero if the specified path name should be used verbatim.  IfŸL** non-zero is returned from this function, the calling function must simplyŸL** use the provided path name verbatim -OR- resolve it into a full path nameŸ?** using the GetFullPathName Win32 API function (if available).¢*/Ÿ"static BOOL winIsVerbatimPathname(∑  const char *zPathname¢){§  /*ŸN  ** If the path name starts with a forward slash or a backslash, it is eitherŸN  ** a legal UNC name, a volume relative path, or an absolute path name in theŸM  ** "Unix" format on Windows.  There is no easy way to differentiate betweenŸM  ** the final two cases; therefore, we return the safer return value of TRUEŸB  ** so that callers of this function will simply use it verbatim.§  */Ÿ#  if ( winIsDirSep(zPathname[0]) ){∞    return TRUE;£  }†§  /*ŸL  ** If the path name starts with a letter and a colon it is either a volumeŸJ  ** relative path or an absolute path.  Callers of this function must notŸM  ** attempt to treat it as a relative path name (i.e. they should simply use≤  ** it verbatim).§  */Ÿ-  if ( winIsDriveLetterAndColon(zPathname) ){∞    return TRUE;£  }†§  /*ŸO  ** If we get to this point, the path name should almost certainly be a purelyŸO  ** relative one (i.e. not a UNC name, not absolute, and not volume relative).§  */Ø  return FALSE;°}†¢/*ŸA** Turn a relative pathname into a full pathname.  Write the fullŸB** pathname into zOut[].  zOut[] will be at least pVfs->mxPathname±** bytes in size.¢*/ªstatic int winFullPathname(Ÿ;  sqlite3_vfs *pVfs,            /* Pointer to vfs object */ŸB  const char *zRelative,        /* Possibly relative input path */ŸD  int nFull,                    /* Size of output buffer in bytes */Ÿ3  char *zFull                   /* Output buffer */¢){Ÿ@#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)Æ  DWORD nByte;≥  void *zConverted;≠  char *zOut;¶#endif†ŸE  /* If this path name begins with "/X:", where "X" is any alphabeticŸ:  ** character, discard the initial "/" from the pathname.§  */ŸC  if( zRelative[0]=='/' && winIsDriveLetterAndColon(zRelative+1) ){∞    zRelative++;£  }†∑#if defined(__CYGWIN__)Ÿ)  SimulateIOError( return SQLITE_ERROR );∫  UNUSED_PARAMETER(nFull);Ÿ$  assert( nFull>=pVfs->mxPathname );ŸE  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){¶    /*ŸB    ** NOTE: We are dealing with a relative path name and the dataŸD    **       directory has been set.  Therefore, use it as the basisŸA    **       for converting the relative path name to an absoluteŸ>    **       one by prepending the data directory and a slash.¶    */Ÿ9    char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );∞    if( !zOut ){Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }π    if( cygwin_conv_path(ŸB            (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A) |ŸC            CCP_RELATIVE, zRelative, zOut, pVfs->mxPathname+1)<0 ){π      sqlite3_free(zOut);Ÿ@      return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,Ÿ8                         "winFullPathname1", zRelative);™    }else{Ÿ3      char *zUtf8 = winConvertToUtf8Filename(zOut);≥      if( !zUtf8 ){ª        sqlite3_free(zOut);Ÿ'        return SQLITE_IOERR_NOMEM_BKPT;ß      }ŸE      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",ŸF                       sqlite3_data_directory, winGetDirSep(), zUtf8);∫      sqlite3_free(zUtf8);π      sqlite3_free(zOut);•    }®  }else{Ÿ9    char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );∞    if( !zOut ){Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }π    if( cygwin_conv_path(ŸA            (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A),Ÿ5            zRelative, zOut, pVfs->mxPathname+1)<0 ){π      sqlite3_free(zOut);Ÿ@      return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,Ÿ8                         "winFullPathname2", zRelative);™    }else{Ÿ3      char *zUtf8 = winConvertToUtf8Filename(zOut);≥      if( !zUtf8 ){ª        sqlite3_free(zOut);Ÿ'        return SQLITE_IOERR_NOMEM_BKPT;ß      }ŸI      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zUtf8);∫      sqlite3_free(zUtf8);π      sqlite3_free(zOut);•    }£  }≥  return SQLITE_OK;¶#endif†Ÿ@#if (SQLITE_OS_WINCE || SQLITE_OS_WINRT) && !defined(__CYGWIN__)Ÿ)  SimulateIOError( return SQLITE_ERROR );ŸE  /* WinCE has no concept of a relative pathname, or so I am told. */ŸG  /* WinRT has no way to convert a relative path to an absolute one. */ŸE  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){¶    /*ŸB    ** NOTE: We are dealing with a relative path name and the dataŸD    **       directory has been set.  Therefore, use it as the basisŸA    **       for converting the relative path name to an absoluteŸB    **       one by prepending the data directory and a backslash.¶    */ŸC    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",ŸH                     sqlite3_data_directory, winGetDirSep(), zRelative);®  }else{ŸK    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zRelative);£  }≥  return SQLITE_OK;¶#endif†Ÿ@#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)ŸC  /* It's odd to simulate an io-error here, but really this is justŸG  ** using the io-error infrastructure to test that SQLite handles thisŸD  ** function failing. This function could fail if, for example, theŸ1  ** current working directory has been unlinked.§  */Ÿ)  SimulateIOError( return SQLITE_ERROR );ŸE  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){¶    /*ŸB    ** NOTE: We are dealing with a relative path name and the dataŸD    **       directory has been set.  Therefore, use it as the basisŸA    **       for converting the relative path name to an absoluteŸB    **       one by prepending the data directory and a backslash.¶    */ŸC    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",ŸH                     sqlite3_data_directory, winGetDirSep(), zRelative);µ    return SQLITE_OK;£  }Ÿ5  zConverted = winConvertFromUtf8Filename(zRelative);∂  if( zConverted==0 ){Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }±  if( osIsNT() ){±    LPWSTR zTemp;Ÿ=    nByte = osGetFullPathNameW((LPCWSTR)zConverted, 0, 0, 0);≥    if( nByte==0 ){ø      sqlite3_free(zConverted);ŸD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ÿ8                         "winFullPathname1", zRelative);•    }Ø    nByte += 3;Ÿ8    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );≥    if( zTemp==0 ){ø      sqlite3_free(zConverted);Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }ŸE    nByte = osGetFullPathNameW((LPCWSTR)zConverted, nByte, zTemp, 0);≥    if( nByte==0 ){ø      sqlite3_free(zConverted);∫      sqlite3_free(zTemp);ŸD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ÿ8                         "winFullPathname2", zRelative);•    }Ω    sqlite3_free(zConverted);Ÿ#    zOut = winUnicodeToUtf8(zTemp);∏    sqlite3_free(zTemp);£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{∞    char *zTemp;Ÿ;    nByte = osGetFullPathNameA((char*)zConverted, 0, 0, 0);≥    if( nByte==0 ){ø      sqlite3_free(zConverted);ŸD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ÿ8                         "winFullPathname3", zRelative);•    }Ø    nByte += 3;Ÿ8    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );≥    if( zTemp==0 ){ø      sqlite3_free(zConverted);Ÿ%      return SQLITE_IOERR_NOMEM_BKPT;•    }ŸC    nByte = osGetFullPathNameA((char*)zConverted, nByte, zTemp, 0);≥    if( nByte==0 ){ø      sqlite3_free(zConverted);∫      sqlite3_free(zTemp);ŸD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ÿ8                         "winFullPathname4", zRelative);•    }Ω    sqlite3_free(zConverted);Ÿ5    zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());∏    sqlite3_free(zTemp);£  }¶#endif≠  if( zOut ){ŸF    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zOut);∑    sqlite3_free(zOut);µ    return SQLITE_OK;®  }else{Ÿ#    return SQLITE_IOERR_NOMEM_BKPT;£  }¶#endif°}†Ÿ"#ifndef SQLITE_OMIT_LOAD_EXTENSION¢/*Ÿ@** Interfaces for opening a shared library, finding entry pointsŸ=** within the shared library, and closing the shared library.¢*/ŸAstatic void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){´  HANDLE h;∑#if defined(__CYGWIN__)Ÿ!  int nFull = pVfs->mxPathname+1;Ÿ+  char *zFull = sqlite3MallocZero( nFull );∑  void *zConverted = 0;±  if( zFull==0 ){ŸB    OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));≠    return 0;£  }ŸB  if( winFullPathname(pVfs, zFilename, nFull, zFull)!=SQLITE_OK ){∏    sqlite3_free(zFull);ŸB    OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));≠    return 0;£  }Ÿ1  zConverted = winConvertFromUtf8Filename(zFull);∂  sqlite3_free(zFull);•#elseŸ;  void *zConverted = winConvertFromUtf8Filename(zFilename);π  UNUSED_PARAMETER(pVfs);¶#endif∂  if( zConverted==0 ){ŸB    OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));≠    return 0;£  }±  if( osIsNT() ){≥#if SQLITE_OS_WINRTŸ6    h = osLoadPackagedLibrary((LPCWSTR)zConverted, 0);•#elseŸ,    h = osLoadLibraryW((LPCWSTR)zConverted);¶#endif£  }º#ifdef SQLITE_WIN32_HAS_ANSIß  else{Ÿ*    h = osLoadLibraryA((char*)zConverted);£  }¶#endifŸ@  OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)h));ª  sqlite3_free(zConverted);≤  return (void*)h;°}ŸCstatic void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){π  UNUSED_PARAMETER(pVfs);Ÿ6  winGetLastErrorMsg(osGetLastError(), nBuf, zBufOut);°}ŸKstatic void (*winDlSym(sqlite3_vfs *pVfs,void *pH,const char *zSym))(void){Ø  FARPROC proc;π  UNUSED_PARAMETER(pVfs);Ÿ-  proc = osGetProcAddressA((HANDLE)pH, zSym);Ÿ6  OSTRACE(("DLSYM handle=%p, symbol=%s, address=%p\n",Ÿ*           (void*)pH, zSym, (void*)proc));Ω  return (void(*)(void))proc;°}Ÿ9static void winDlClose(sqlite3_vfs *pVfs, void *pHandle){π  UNUSED_PARAMETER(pVfs);Ÿ!  osFreeLibrary((HANDLE)pHandle);Ÿ3  OSTRACE(("DLCLOSE handle=%p\n", (void*)pHandle));°}Ÿ5#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */∂  #define winDlOpen  0∂  #define winDlError 0∂  #define winDlSym   0∂  #define winDlClose 0¶#endif†Ÿ4/* State information for the randomness gatherer. */Ÿ/typedef struct EntropyGatherer EntropyGatherer;∏struct EntropyGatherer {Ÿ;  unsigned char *a;   /* Gather entropy into this buffer */Ÿ0  int na;             /* Size of a[] in bytes */Ÿ4  int i;              /* XOR next input into a[i] */Ÿ9  int nXor;           /* Number of XOR operations done */¢};†Ÿ=#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)Ÿ%/* Mix sz bytes of entropy into p. */ŸDstatic void xorMemory(EntropyGatherer *p, unsigned char *x, int sz){´  int j, k;æ  for(j=0, k=p->i; j<sz; j++){∂    p->a[k++] ^= x[j];π    if( k>=p->na ) k = 0;£  }´  p->i = k;∞  p->nXor += sz;°}ŸF#endif /* !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS) */†¢/*Ÿ2** Write up to nBuf bytes of randomness into zBuf.¢*/ŸBstatic int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){Ÿ;#if defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS)π  UNUSED_PARAMETER(pVfs);∏  memset(zBuf, 0, nBuf);Æ  return nBuf;•#else¥  EntropyGatherer e;π  UNUSED_PARAMETER(pVfs);∏  memset(zBuf, 0, nBuf);Ω  e.a = (unsigned char*)zBuf;Æ  e.na = nBuf;≠  e.nXor = 0;™  e.i = 0;£  {±    SYSTEMTIME x;∏    osGetSystemTime(&x);Ÿ:    xorMemory(&e, (unsigned char*)&x, sizeof(SYSTEMTIME));£  }£  {Ÿ(    DWORD pid = osGetCurrentProcessId();Ÿ7    xorMemory(&e, (unsigned char*)&pid, sizeof(DWORD));£  }≥#if SQLITE_OS_WINRT£  {Ÿ'    ULONGLONG cnt = osGetTickCount64();Ÿ;    xorMemory(&e, (unsigned char*)&cnt, sizeof(ULONGLONG));£  }•#else£  {Ÿ!    DWORD cnt = osGetTickCount();Ÿ7    xorMemory(&e, (unsigned char*)&cnt, sizeof(DWORD));£  }º#endif /* SQLITE_OS_WINRT */£  {¥    LARGE_INTEGER i;Ÿ"    osQueryPerformanceCounter(&i);Ÿ=    xorMemory(&e, (unsigned char*)&i, sizeof(LARGE_INTEGER));£  }ŸA#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID£  {¨    UUID id;Ÿ!    memset(&id, 0, sizeof(UUID));∂    osUuidCreate(&id);Ÿ5    xorMemory(&e, (unsigned char*)&id, sizeof(UUID));Ÿ!    memset(&id, 0, sizeof(UUID));Ÿ     osUuidCreateSequential(&id);Ÿ5    xorMemory(&e, (unsigned char*)&id, sizeof(UUID));£  }ŸJ#endif /* !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID */Ÿ%  return e.nXor>nBuf ? nBuf : e.nXor;ŸD#endif /* defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS) */°}††¢/*Ÿ>** Sleep for a little while.  Return the amount of time slept.¢*/Ÿ5static int winSleep(sqlite3_vfs *pVfs, int microsec){Ÿ+  sqlite3_win32_sleep((microsec+999)/1000);π  UNUSED_PARAMETER(pVfs);Ÿ$  return ((microsec+999)/1000)*1000;°}†¢/*ŸH** The following variable, if set to a non-zero value, is interpreted asŸD** the number of seconds since 1970 and is used to set the result ofŸ)** sqlite3OsCurrentTime() during testing.¢*/≤#ifdef SQLITE_TESTŸWSQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */¶#endif†¢/*ŸL** Find the current time (in Universal Coordinated Time).  Write into *piNowŸI** the current time and date as a Julian Day number times 86_400_000.  InŸM** other words, write into *piNow the number of milliseconds since the JulianŸG** epoch of noon in Greenwich on November 24, 4714 B.C according to theŸ ** proleptic Gregorian calendar.¢**ŸJ** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date≥** cannot be found.¢*/ŸHstatic int winCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow){ŸD  /* FILETIME structure is a 64-bit value representing the number ofŸE     100-nanosecond intervals since January 1, 1601 (= JD 2305813.5).§  */Æ  FILETIME ft;ŸP  static const sqlite3_int64 winFiletimeEpoch = 23058135*(sqlite3_int64)8640000;≤#ifdef SQLITE_TESTŸI  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;¶#endifŸ5  /* 2^32 - to avoid use of LL and warnings in gcc */Ÿ,  static const sqlite3_int64 max32BitValue =Ÿ=      (sqlite3_int64)2000000000 + (sqlite3_int64)2000000000 +ø      (sqlite3_int64)294967296;†≥#if SQLITE_OS_WINCE≤  SYSTEMTIME time;π  osGetSystemTime(&time);Ÿ9  /* if SystemTimeToFileTime() fails, it returns zero. */Ÿ*  if (!osSystemTimeToFileTime(&time,&ft)){∏    return SQLITE_ERROR;£  }•#elseŸ#  osGetSystemTimeAsFileTime( &ft );¶#endif†Ω  *piNow = winFiletimeEpoch +ŸA            ((((sqlite3_int64)ft.dwHighDateTime)*max32BitValue) +ŸE               (sqlite3_int64)ft.dwLowDateTime)/(sqlite3_int64)10000;†≤#ifdef SQLITE_TESTΩ  if( sqlite3_current_time ){ŸB    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;£  }¶#endifπ  UNUSED_PARAMETER(pVfs);≥  return SQLITE_OK;°}†¢/*ŸD** Find the current time (in Universal Coordinated Time).  Write theŸ?** current time and date as a Julian Day number into *prNow andŸ<** return 0.  Return 1 if the time and date cannot be found.¢*/Ÿ<static int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){©  int rc;≤  sqlite3_int64 i;Ÿ%  rc = winCurrentTimeInt64(pVfs, &i);¨  if( !rc ){∫    *prNow = i/86400000.0;£  }¨  return rc;°}†¢/*Ÿ=** The idea is that this function works like a combination ofŸ>** GetLastError() and FormatMessage() on Windows (or errno andŸ=** strerror_r() on Unix). After an error is returned by an OSŸ=** function, SQLite calls this function with zBuf pointing toŸ;** a buffer of nBuf bytes. The OS layer should populate theŸ;** buffer with a nul-terminated UTF-8 encoded error messageŸC** describing the last IO error to have occurred within the calling™** thread.¢**Ÿ=** If the error message is too large for the supplied buffer,Ÿ<** it should be truncated. The return value of xGetLastErrorŸ?** is zero if the error message fits in the buffer, or non-zeroŸE** otherwise (if the message was truncated). If non-zero is returned,ŸC** then it is not necessary to include the nul-terminator character∏** in the output buffer.¢**Ÿ=** Not supplying an error message will have no adverse effectŸ=** on SQLite. It is fine to have an implementation that neverº** returns an error message:¢**Ÿ@**   int xGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){Ω**     assert(zBuf[0]=='\0');∞**     return 0;¶**   }¢**ŸC** However if an error message is supplied, it will be incorporatedŸ?** by sqlite into the error message available to the user usingŸ?** sqlite3_errmsg(), possibly making IO errors easier to debug.¢*/ŸDstatic int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){Ω  DWORD e = osGetLastError();π  UNUSED_PARAMETER(pVfs);Ÿ1  if( nBuf>0 ) winGetLastErrorMsg(e, nBuf, zBuf);´  return e;°}†¢/*Ÿ>** Initialize and deinitialize the operating system interface.¢*/Ÿ%SQLITE_API int sqlite3_os_init(void){ø  static sqlite3_vfs winVfs = {Ÿ)    3,                     /* iVersion */Ÿ)    sizeof(winFile),       /* szOsFile */Ÿ1    SQLITE_WIN32_MAX_PATH_BYTES, /* mxPathname */Ÿ&    0,                     /* pNext */Ÿ&    "win32",               /* zName */Ÿ)    &winAppData,           /* pAppData */Ÿ&    winOpen,               /* xOpen */Ÿ(    winDelete,             /* xDelete */Ÿ(    winAccess,             /* xAccess */Ÿ.    winFullPathname,       /* xFullPathname */Ÿ(    winDlOpen,             /* xDlOpen */Ÿ)    winDlError,            /* xDlError */Ÿ'    winDlSym,              /* xDlSym */Ÿ)    winDlClose,            /* xDlClose */Ÿ,    winRandomness,         /* xRandomness */Ÿ'    winSleep,              /* xSleep */Ÿ-    winCurrentTime,        /* xCurrentTime */Ÿ.    winGetLastError,       /* xGetLastError */Ÿ2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ÿ/    winSetSystemCall,      /* xSetSystemCall */Ÿ/    winGetSystemCall,      /* xGetSystemCall */Ÿ0    winNextSystemCall,     /* xNextSystemCall */§  };Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)Ÿ'  static sqlite3_vfs winLongPathVfs = {Ÿ)    3,                     /* iVersion */Ÿ)    sizeof(winFile),       /* szOsFile */Ÿ1    SQLITE_WINNT_MAX_PATH_BYTES, /* mxPathname */Ÿ&    0,                     /* pNext */Ÿ&    "win32-longpath",      /* zName */Ÿ)    &winAppData,           /* pAppData */Ÿ&    winOpen,               /* xOpen */Ÿ(    winDelete,             /* xDelete */Ÿ(    winAccess,             /* xAccess */Ÿ.    winFullPathname,       /* xFullPathname */Ÿ(    winDlOpen,             /* xDlOpen */Ÿ)    winDlError,            /* xDlError */Ÿ'    winDlSym,              /* xDlSym */Ÿ)    winDlClose,            /* xDlClose */Ÿ,    winRandomness,         /* xRandomness */Ÿ'    winSleep,              /* xSleep */Ÿ-    winCurrentTime,        /* xCurrentTime */Ÿ.    winGetLastError,       /* xGetLastError */Ÿ2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ÿ/    winSetSystemCall,      /* xSetSystemCall */Ÿ/    winGetSystemCall,      /* xGetSystemCall */Ÿ0    winNextSystemCall,     /* xNextSystemCall */§  };¶#endifŸ%  static sqlite3_vfs winNolockVfs = {Ÿ)    3,                     /* iVersion */Ÿ)    sizeof(winFile),       /* szOsFile */Ÿ1    SQLITE_WIN32_MAX_PATH_BYTES, /* mxPathname */Ÿ&    0,                     /* pNext */Ÿ&    "win32-none",          /* zName */Ÿ)    &winNolockAppData,     /* pAppData */Ÿ&    winOpen,               /* xOpen */Ÿ(    winDelete,             /* xDelete */Ÿ(    winAccess,             /* xAccess */Ÿ.    winFullPathname,       /* xFullPathname */Ÿ(    winDlOpen,             /* xDlOpen */Ÿ)    winDlError,            /* xDlError */Ÿ'    winDlSym,              /* xDlSym */Ÿ)    winDlClose,            /* xDlClose */Ÿ,    winRandomness,         /* xRandomness */Ÿ'    winSleep,              /* xSleep */Ÿ-    winCurrentTime,        /* xCurrentTime */Ÿ.    winGetLastError,       /* xGetLastError */Ÿ2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ÿ/    winSetSystemCall,      /* xSetSystemCall */Ÿ/    winGetSystemCall,      /* xGetSystemCall */Ÿ0    winNextSystemCall,     /* xNextSystemCall */§  };Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)Ÿ-  static sqlite3_vfs winLongPathNolockVfs = {Ÿ)    3,                     /* iVersion */Ÿ)    sizeof(winFile),       /* szOsFile */Ÿ1    SQLITE_WINNT_MAX_PATH_BYTES, /* mxPathname */Ÿ&    0,                     /* pNext */Ÿ&    "win32-longpath-none", /* zName */Ÿ)    &winNolockAppData,     /* pAppData */Ÿ&    winOpen,               /* xOpen */Ÿ(    winDelete,             /* xDelete */Ÿ(    winAccess,             /* xAccess */Ÿ.    winFullPathname,       /* xFullPathname */Ÿ(    winDlOpen,             /* xDlOpen */Ÿ)    winDlError,            /* xDlError */Ÿ'    winDlSym,              /* xDlSym */Ÿ)    winDlClose,            /* xDlClose */Ÿ,    winRandomness,         /* xRandomness */Ÿ'    winSleep,              /* xSleep */Ÿ-    winCurrentTime,        /* xCurrentTime */Ÿ.    winGetLastError,       /* xGetLastError */Ÿ2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ÿ/    winSetSystemCall,      /* xSetSystemCall */Ÿ/    winGetSystemCall,      /* xGetSystemCall */Ÿ0    winNextSystemCall,     /* xNextSystemCall */§  };¶#endif†Ÿ@  /* Double-check that the aSyscall[] array has been constructedŸ2  ** correctly.  See ticket [bb3a86e890c8e96ab] */Ÿ$  assert( ArraySize(aSyscall)==80 );†Ÿ-  /* get memory map allocation granularity */Ÿ.  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));≥#if SQLITE_OS_WINRTŸ%  osGetNativeSystemInfo(&winSysInfo);•#elseø  osGetSystemInfo(&winSysInfo);¶#endifŸ1  assert( winSysInfo.dwAllocationGranularity>0 );Ÿ$  assert( winSysInfo.dwPageSize>0 );†Ÿ#  sqlite3_vfs_register(&winVfs, 1);†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)Ÿ+  sqlite3_vfs_register(&winLongPathVfs, 0);¶#endif†Ÿ)  sqlite3_vfs_register(&winNolockVfs, 0);†Ÿ"#if defined(SQLITE_WIN32_HAS_WIDE)Ÿ1  sqlite3_vfs_register(&winLongPathNolockVfs, 0);¶#endif†∑#ifndef SQLITE_OMIT_WALŸ;  winBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);¶#endif†≥  return SQLITE_OK;°}†Ÿ$SQLITE_API int sqlite3_os_end(void){≥#if SQLITE_OS_WINRT∑  if( sleepObj!=NULL ){º    osCloseHandle(sleepObj);¥    sleepObj = NULL;£  }¶#endif†∑#ifndef SQLITE_OMIT_WAL±  winBigLock = 0;¶#endif†≥  return SQLITE_OK;°}†∫#endif /* SQLITE_OS_WIN */†ŸO/************** End of os_win.c **********************************************/ŸO/************** Begin file memdb.c *******************************************/¢/*≠** 2016-09-07¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸN******************************************************************************¢**ŸL** This file implements an in-memory VFS. A database is held as a contiguous≥** block of memory.¢**Ÿ>** This file also implements interface sqlite3_serialize() andπ** sqlite3_deserialize().¢*/Ÿ #ifdef SQLITE_ENABLE_DESERIALIZEº/* #include "sqliteInt.h" */†¢/*Ÿ6** Forward declaration of objects used by this utility¢*/Ÿ"typedef struct sqlite3_vfs MemVfs;øtypedef struct MemFile MemFile;†ŸF/* Access to a lower-level VFS that (might) implement dynamic loading,Ω** access to randomness, etc.¢*/Ÿ2#define ORIGVFS(p) ((sqlite3_vfs*)((p)->pAppData))†≤/* An open file */∞struct MemFile {Ÿ2  sqlite3_file base;              /* IO methods */Ÿ8  sqlite3_int64 sz;               /* Size of the file */Ÿ@  sqlite3_int64 szMax;            /* Space allocated to aData */Ÿ;  unsigned char *aData;           /* content of the file */ŸE  int nMmap;                      /* Number of memory mapped pages */Ÿ-  unsigned mFlags;                /* Flags */ŸJ  int eLock;                      /* Most recent lock against this file */¢};†¢/*∂** Methods for MemFile¢*/Ÿ%static int memdbClose(sqlite3_file*);ŸJstatic int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);ŸOstatic int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);Ÿ<static int memdbTruncate(sqlite3_file*, sqlite3_int64 size);Ÿ/static int memdbSync(sqlite3_file*, int flags);Ÿ>static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);Ÿ)static int memdbLock(sqlite3_file*, int);ŸP/* static int memdbCheckReservedLock(sqlite3_file*, int *pResOut);// not used */Ÿ?static int memdbFileControl(sqlite3_file*, int op, void *pArg);Ÿ</* static int memdbSectorSize(sqlite3_file*); // not used */Ÿ5static int memdbDeviceCharacteristics(sqlite3_file*);ŸOstatic int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);ŸEstatic int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);†¢/*µ** Methods for MemVfs¢*/ŸMstatic int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);ŸK/* static int memdbDelete(sqlite3_vfs*, const char *zName, int syncDir); */ŸJstatic int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);ŸOstatic int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);Ÿ>static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);ŸAstatic void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);ŸMstatic void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);Ÿ.static void memdbDlClose(sqlite3_vfs*, void*);Ÿ@static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);Ÿ6static int memdbSleep(sqlite3_vfs*, int microseconds);Ÿ9/* static int memdbCurrentTime(sqlite3_vfs*, double*); */Ÿ8static int memdbGetLastError(sqlite3_vfs*, int, char *);Ÿ?static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);†Ÿ static sqlite3_vfs memdb_vfs = {Ÿ-  2,                           /* iVersion */ŸC  0,                           /* szOsFile (set when registered) */Ÿ/  1024,                        /* mxPathname */Ÿ*  0,                           /* pNext */Ÿ*  "memdb",                     /* zName */ŸD  0,                           /* pAppData (set when registered) */ Ÿ*  memdbOpen,                   /* xOpen */Ÿ,  0, /* memdbDelete, */        /* xDelete */Ÿ,  memdbAccess,                 /* xAccess */Ÿ2  memdbFullPathname,           /* xFullPathname */Ÿ,  memdbDlOpen,                 /* xDlOpen */Ÿ-  memdbDlError,                /* xDlError */Ÿ+  memdbDlSym,                  /* xDlSym */Ÿ-  memdbDlClose,                /* xDlClose */Ÿ0  memdbRandomness,             /* xRandomness */Ÿ+  memdbSleep,                  /* xSleep */Ÿ1  0, /* memdbCurrentTime, */   /* xCurrentTime */Ÿ2  memdbGetLastError,           /* xGetLastError */Ÿ6  memdbCurrentTimeInt64        /* xCurrentTimeInt64 */¢};†Ÿ4static const sqlite3_io_methods memdb_io_methods = {Ÿ0  3,                              /* iVersion */Ÿ/  memdbClose,                      /* xClose */Ÿ.  memdbRead,                       /* xRead */Ÿ/  memdbWrite,                      /* xWrite */Ÿ2  memdbTruncate,                   /* xTruncate */Ÿ.  memdbSync,                       /* xSync */Ÿ2  memdbFileSize,                   /* xFileSize */Ÿ.  memdbLock,                       /* xLock */ŸN  memdbLock,                       /* xUnlock - same as xLock in this case */ Ÿ;  0, /* memdbCheckReservedLock, */ /* xCheckReservedLock */Ÿ5  memdbFileControl,                /* xFileControl */Ÿ4  0, /* memdbSectorSize,*/         /* xSectorSize */Ÿ?  memdbDeviceCharacteristics,      /* xDeviceCharacteristics */Ÿ0  0,                               /* xShmMap */Ÿ1  0,                               /* xShmLock */Ÿ4  0,                               /* xShmBarrier */Ÿ2  0,                               /* xShmUnmap */Ÿ/  memdbFetch,                      /* xFetch */Ÿ1  memdbUnfetch                     /* xUnfetch */¢};†††¢/*∑** Close an memdb-file.¢**ŸE** The pData pointer is owned by the application, so there is nothing´** to free.¢*/Ÿ+static int memdbClose(sqlite3_file *pFile){Ÿ   MemFile *p = (MemFile *)pFile;ŸJ  if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ) sqlite3_free(p->aData);≥  return SQLITE_OK;°}†¢/*Ÿ ** Read data from an memdb-file.¢*/µstatic int memdbRead(∑  sqlite3_file *pFile, Æ  void *zBuf, ¨  int iAmt, ¥  sqlite_int64 iOfst¢){Ÿ   MemFile *p = (MemFile *)pFile;π  if( iOfst+iAmt>p->sz ){∫    memset(zBuf, 0, iAmt);ŸB    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);Ÿ#    return SQLITE_IOERR_SHORT_READ;£  }Ÿ%  memcpy(zBuf, p->aData+iOfst, iAmt);≥  return SQLITE_OK;°}†¢/*ŸA** Try to enlarge the memory allocation to hold at least sz bytes¢*/Ÿ9static int memdbEnlarge(MemFile *p, sqlite3_int64 newSz){∂  unsigned char *pNew;ŸE  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || p->nMmap>0 ){∑    return SQLITE_FULL;£  }Ÿ,  pNew = sqlite3_realloc64(p->aData, newSz);Ÿ$  if( pNew==0 ) return SQLITE_NOMEM;≤  p->aData = pNew;≥  p->szMax = newSz;≥  return SQLITE_OK;°}†¢/*ø** Write data to an memdb-file.¢*/∂static int memdbWrite(∂  sqlite3_file *pFile,∞  const void *z,´  int iAmt,¥  sqlite_int64 iOfst¢){Ÿ   MemFile *p = (MemFile *)pFile;π  if( iOfst+iAmt>p->sz ){´    int rc;ª    if( iOfst+iAmt>p->szMaxŸ9     && (rc = memdbEnlarge(p, (iOfst+iAmt)*2))!=SQLITE_OK¶    ){∞      return rc;•    }Ÿ=    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);∑    p->sz = iOfst+iAmt;£  }Ÿ"  memcpy(p->aData+iOfst, z, iAmt);≥  return SQLITE_OK;°}†¢/*∫** Truncate an memdb-file.¢**ŸG** In rollback mode (which is always the case for memdb, as it does notŸA** support WAL mode) the truncate() method is only used to reduceŸ2** the size of a file, never to increase the size.¢*/ŸAstatic int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){Ÿ   MemFile *p = (MemFile *)pFile;Ÿ-  if( NEVER(size>p->sz) ) return SQLITE_FULL;∞  p->sz = size; ≥  return SQLITE_OK;°}†¢/*∂** Sync an memdb-file.¢*/Ÿ5static int memdbSync(sqlite3_file *pFile, int flags){≥  return SQLITE_OK;°}†¢/*Ÿ1** Return the current file-size of an memdb-file.¢*/ŸCstatic int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){Ÿ   MemFile *p = (MemFile *)pFile;±  *pSize = p->sz;≥  return SQLITE_OK;°}†¢/*∂** Lock an memdb-file.¢*/Ÿ5static int memdbLock(sqlite3_file *pFile, int eLock){Ÿ   MemFile *p = (MemFile *)pFile;≥  p->eLock = eLock;≥  return SQLITE_OK;°}†ŸA#if 0 /* Never used because memdbAccess() always returns false */¢/*ŸG** Check if another file-handle holds a RESERVED lock on an memdb-file.¢*/ŸEstatic int memdbCheckReservedLock(sqlite3_file *pFile, int *pResOut){Ø  *pResOut = 0;≥  return SQLITE_OK;°}¶#endif†¢/*Ÿ?** File control method. For custom operations on an memdb-file.¢*/ŸEstatic int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){Ÿ   MemFile *p = (MemFile *)pFile;ª  int rc = SQLITE_NOTFOUND;Ÿ!  if( op==SQLITE_FCNTL_VFSNAME ){ŸG    *(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);≥    rc = SQLITE_OK;£  }¨  return rc;°}†ŸA#if 0  /* Not used because of SQLITE_IOCAP_POWERSAFE_OVERWRITE */¢/*Ÿ5** Return the sector-size in bytes for an memdb-file.¢*/Ÿ0static int memdbSectorSize(sqlite3_file *pFile){Æ  return 1024;°}¶#endif†¢/*ŸE** Return the device characteristic flags supported by an memdb-file.¢*/Ÿ;static int memdbDeviceCharacteristics(sqlite3_file *pFile){ø  return SQLITE_IOCAP_ATOMIC | Ÿ+         SQLITE_IOCAP_POWERSAFE_OVERWRITE |Ÿ#         SQLITE_IOCAP_SAFE_APPEND |Ÿ!         SQLITE_IOCAP_SEQUENTIAL;°}†Ÿ*/* Fetch a page of a memory-mapped file */∂static int memdbFetch(∂  sqlite3_file *pFile,∂  sqlite3_int64 iOfst,´  int iAmt,´  void **pp¢){Ÿ   MemFile *p = (MemFile *)pFile;≠  p->nMmap++;Ÿ"  *pp = (void*)(p->aData + iOfst);≥  return SQLITE_OK;°}†Ÿ"/* Release a memory-mapped page */ŸOstatic int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){Ÿ   MemFile *p = (MemFile *)pFile;≠  p->nMmap--;≥  return SQLITE_OK;°}†¢/*ª** Open an mem file handle.¢*/µstatic int memdbOpen(¥  sqlite3_vfs *pVfs,¥  const char *zName,∂  sqlite3_file *pFile,¨  int flags,∞  int *pOutFlags¢){ø  MemFile *p = (MemFile*)pFile;Ÿ)  if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){ŸO    return ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pFile, flags, pOutFlags);£  }ª  memset(p, 0, sizeof(*p));ŸM  p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;ŸH  assert( pOutFlags!=0 );  /* True because flags==SQLITE_OPEN_MAIN_DB */Ÿ*  *pOutFlags = flags | SQLITE_OPEN_MEMORY;Ÿ'  p->base.pMethods = &memdb_io_methods;≥  return SQLITE_OK;°}†ŸH#if 0 /* Only used to delete rollback journals, master journals, and WALŸO      ** files, none of which exist in memdb.  So this routine is never used */¢/*ŸE** Delete the file located at zPath. If the dirSync argument is true,ŸA** ensure the file-system modifications are synced to disk before≠** returning.¢*/ŸJstatic int memdbDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){Ω  return SQLITE_IOERR_DELETE;°}¶#endif†¢/*ŸG** Test for access permissions. Return true if the requested permissionŸ$** is available, or false otherwise.¢**ŸD** With memdb, no files ever exist on disk.  So always return false.¢*/∑static int memdbAccess(µ  sqlite3_vfs *pVfs, µ  const char *zPath, ≠  int flags, Æ  int *pResOut¢){Ø  *pResOut = 0;≥  return SQLITE_OK;°}†¢/*ŸF** Populate buffer zOut with the full canonical pathname correspondingŸD** to the pathname in zPath. zOut is guaranteed to point to a bufferŸ+** of at least (INST_MAX_PATHNAME+1) bytes.¢*/Ωstatic int memdbFullPathname(µ  sqlite3_vfs *pVfs, µ  const char *zPath, ¨  int nOut, ¨  char *zOut¢){Ÿ,  sqlite3_snprintf(nOut, zOut, "%s", zPath);≥  return SQLITE_OK;°}†¢/*ŸA** Open the dynamic library located at zPath and return a handle.¢*/Ÿ?static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){Ÿ6  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);°}†¢/*ŸG** Populate the buffer zErrMsg (size nByte bytes) with a human readableŸH** utf-8 string describing the most recent error encountered associated ∫** with dynamic libraries.¢*/ŸFstatic void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){Ÿ9  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);°}†¢/*ŸI** Return a pointer to the symbol zSymbol in the dynamic library pHandle.¢*/ŸNstatic void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){Ÿ7  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);°}†¢/*Ÿ,** Close the dynamic library handle pHandle.¢*/Ÿ;static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){Ÿ2  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);°}†¢/*ŸA** Populate the buffer pointed to by zBufOut with nByte bytes of Ø** random data.¢*/ŸHstatic int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){ŸC  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);°}†¢/*ŸD** Sleep for nMicro microseconds. Return the number of microseconds ≤** actually slept.¢*/Ÿ5static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){Ÿ6  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);°}†ŸD#if 0  /* Never used.  Modern cores only call xCurrentTimeInt64() */¢/*Ÿ?** Return the current time as a Julian Day number in *pTimeOut.¢*/ŸAstatic int memdbCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){Ÿ>  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);°}¶#endif†Ÿ@static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){Ÿ;  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);°}ŸFstatic int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){Ÿ<  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);°}†¢/*ŸA** Translate a database connection pointer and schema name into a≥** MemFile pointer.¢*/ŸDstatic MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){±  MemFile *p = 0;ŸL  int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);¥  if( rc ) return 0;Ÿ5  if( p->base.pMethods!=&memdb_io_methods ) return 0;´  return p;°}†¢/*Ÿ)** Return the serialization of a database¢*/Ÿ,SQLITE_API unsigned char *sqlite3_serialize(Ÿ9  sqlite3 *db,              /* The database connection */ŸF  const char *zSchema,      /* Which database within the connection */Ÿ>  sqlite3_int64 *piSize,    /* Write size here, if not NULL */Ÿ?  unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */¢){≠  MemFile *p;™  int iDb;≠  Btree *pBt;≥  sqlite3_int64 sz;±  int szPage = 0;∫  sqlite3_stmt *pStmt = 0;∂  unsigned char *pOut;≠  char *zSql;©  int rc;†æ#ifdef SQLITE_ENABLE_API_ARMORŸ"  if( !sqlite3SafetyCheckOk(db) ){Ω    (void)SQLITE_MISUSE_BKPT;≠    return 0;£  }¶#endif†Ÿ1  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;Ÿ%  p = memdbFromDbSchema(db, zSchema);Ÿ'  iDb = sqlite3FindDbName(db, zSchema);º  if( piSize ) *piSize = -1;∑  if( iDb<0 ) return 0;™  if( p ){Ÿ!    if( piSize ) *piSize = p->sz;Ÿ+    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){∂      pOut = p->aData;™    }else{Ÿ'      pOut = sqlite3_malloc64( p->sz );Ÿ/      if( pOut ) memcpy(pOut, p->aData, p->sz);•    }∞    return pOut;£  }π  pBt = db->aDb[iDb].pBt;∏  if( pBt==0 ) return 0;Ÿ(  szPage = sqlite3BtreeGetPageSize(pBt);Ÿ>  zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);ŸI  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;µ  sqlite3_free(zSql);¥  if( rc ) return 0;ª  rc = sqlite3_step(pStmt);∑  if( rc!=SQLITE_ROW ){≠    pOut = 0;®  }else{Ÿ/    sz = sqlite3_column_int64(pStmt, 0)*szPage;æ    if( piSize ) *piSize = sz;Ÿ+    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){Ø      pOut = 0;™    }else{Ÿ$      pOut = sqlite3_malloc64( sz );±      if( pOut ){Ÿ1        int nPage = sqlite3_column_int(pStmt, 0);Ÿ/        Pager *pPager = sqlite3BtreePager(pBt);±        int pgno;Ÿ)        for(pgno=1; pgno<=nPage; pgno++){º          DbPage *pPage = 0;ŸE          unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);ŸB          rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);æ          if( rc==SQLITE_OK ){Ÿ<            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);∞          }else{Ÿ#            memset(pTo, 0, szPage);´          }Ÿ*          sqlite3PagerUnref(pPage);       ©        }ß      }•    }£  }∫  sqlite3_finalize(pStmt);Æ  return pOut;°}†Ÿ9/* Convert zSchema to a MemDB and initialize its content.¢*/Ÿ#SQLITE_API int sqlite3_deserialize(Ÿ7  sqlite3 *db,            /* The database connection */ŸK  const char *zSchema,    /* Which DB to reopen with the deserialization */Ÿ?  unsigned char *pData,   /* The serialized database content */ŸC  sqlite3_int64 szDb,     /* Number bytes in the deserialization */Ÿ<  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */ŸG  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */¢){≠  MemFile *p;≠  char *zSql;∫  sqlite3_stmt *pStmt = 0;©  int rc;™  int iDb;†æ#ifdef SQLITE_ENABLE_API_ARMORŸ"  if( !sqlite3SafetyCheckOk(db) ){æ    return SQLITE_MISUSE_BKPT;£  }Ÿ)  if( szDb<0 ) return SQLITE_MISUSE_BKPT;Ÿ*  if( szBuf<0 ) return SQLITE_MISUSE_BKPT;¶#endif†Ÿ!  sqlite3_mutex_enter(db->mutex);Ÿ1  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;Ÿ'  iDb = sqlite3FindDbName(db, zSchema);Æ  if( iDb<0 ){∂    rc = SQLITE_ERROR;π    goto end_deserialize;ß  }    Ÿ4  zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);Ÿ3  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);µ  sqlite3_free(zSql);Ÿ   if( rc ) goto end_deserialize;π  db->init.iDb = (u8)iDb;ª  db->init.reopenMemdb = 1;ª  rc = sqlite3_step(pStmt);ª  db->init.reopenMemdb = 0;∏  if( rc!=SQLITE_DONE ){∂    rc = SQLITE_ERROR;π    goto end_deserialize;£  }Ÿ%  p = memdbFromDbSchema(db, zSchema);≠  if( p==0 ){∂    rc = SQLITE_ERROR;®  }else{µ    p->aData = pData;±    p->sz = szDb;µ    p->szMax = szBuf;∑    p->mFlags = mFlags;≥    rc = SQLITE_OK;£  }†∞end_deserialize:∫  sqlite3_finalize(pStmt);Ÿ!  sqlite3_mutex_leave(db->mutex);¨  return rc;°}†£/* Ÿ7** This routine is called when the extension is loaded.∏** Register the new VFS.¢*/Ÿ*SQLITE_PRIVATE int sqlite3MemdbInit(void){Ÿ,  sqlite3_vfs *pLower = sqlite3_vfs_find(0);º  int sz = pLower->szOsFile;æ  memdb_vfs.pAppData = pLower;ŸA  /* In all known configurations of SQLite, the size of a defaultŸC  ** sqlite3_file is greater than the size of a memdb sqlite3_file.Ÿ=  ** Should that ever change, remove the following NEVER() */Ÿ7  if( NEVER(sz<sizeof(MemFile)) ) sz = sizeof(MemFile);∫  memdb_vfs.szOsFile = sz;Ÿ-  return sqlite3_vfs_register(&memdb_vfs, 0);°}Ÿ&#endif /* SQLITE_ENABLE_DESERIALIZE */†ŸO/************** End of memdb.c ***********************************************/ŸO/************** Begin file bitvec.c ******************************************/¢/*≥** 2008 February 16¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ@** This file implements an object that represents a fixed-lengthŸ.** bitmap.  Bits are numbered starting with 1.¢**ŸF** A bitmap is used to record which pages of a database file have beenŸH** journalled during a transaction, or which pages have the "dont-write"ŸA** property.  Usually only a few pages are meet either condition.Ÿ;** So the bitmap is usually sparse and has low cardinality.ŸG** But sometimes (for example when during a DROP of a large table) mostŸJ** or all of the pages in a database can get journalled.  In those cases, ŸH** the bitmap becomes dense with high cardinality.  The algorithm needs Ω** to handle both cases well.¢**Ÿ>** The size of the bitmap is fixed when the object is created.¢**ŸB** All bits are clear when the bitmap is created.  Individual bitsŸ'** may be set or cleared one at a time.¢**ŸG** Test operations are about 100 times more common that set operations.ŸD** Clear operations are exceedingly rare.  There are usually betweenŸL** 5 and 500 set operations per Bitvec object, though the number of sets canŸD** sometimes grow into tens of thousands or larger.  The size of theŸC** Bitvec object is the number of pages in the database file at theŸH** start of a transaction, and is thus usually less than a few thousand,Ÿ>** but can be as large as 2 billion for a really big database.¢*/º/* #include "sqliteInt.h" */†Ÿ,/* Size of the Bitvec structure in bytes. */º#define BITVEC_SZ        512†ŸO/* Round the union size down to the nearest pointer boundary, since that's how Ÿ2** it will be aligned within the Bitvec struct. */∂#define BITVEC_USIZE \ŸC    (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))†Ÿ>/* Type of the array "element" for the bitmap representation. ŸI** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE. ŸB** Setting this to the "natural word" size of your CPU may improve≤** performance. */ª#define BITVEC_TELEM     u8Ÿ+/* Size, in bits, of the bitmap element. */∫#define BITVEC_SZELEM    8Ÿ+/* Number of elements in a bitmap array. */Ÿ<#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))Ÿ)/* Number of bits in the bitmap array. */Ÿ5#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM)†Ÿ)/* Number of u32 values in hash table. */Ÿ3#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))Ÿ2/* Maximum number of entries in hash table before Ÿ"** sub-dividing and re-hashing. */Ÿ(#define BITVEC_MXHASH    (BITVEC_NINT/2)Ÿ1/* Hashing function for the aHash representation.Ÿ4** Empirical testing showed that the *37 multiplier Ÿ5** (an arbitrary prime)in the hash function provided Ÿ,** no fewer collisions than the no-op *1. */Ÿ.#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT)†Ÿ8#define BITVEC_NPTR      (BITVEC_USIZE/sizeof(Bitvec *))††¢/*Ÿ6** A bitmap is an instance of the following structure.¢**Ÿ9** This bitmap records the existence of zero or more bitsŸ.** with values between 1 and iSize, inclusive.¢**Ÿ:** There are three possible representations of the bitmap.Ÿ?** If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straightŸ/** bitmap.  The least significant bit is bit 1.¢**Ÿ@** If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] isŸC** a hash table that will hold up to BITVEC_MXHASH distinct values.¢**Ÿ?** Otherwise, the value i is redirected into one of BITVEC_NPTRŸ>** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmapŸ?** handles up to iDivisor separate values of i.  apSub[0] holdsŸ@** values between 1 and iDivisor.  apSub[1] holds values betweenŸ<** iDivisor+1 and 2*iDivisor.  apSub[N] holds values betweenŸA** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalizedŸ3** to hold deal with values between 1 and iDivisor.¢*/Østruct Bitvec {ŸG  u32 iSize;      /* Maximum bit index.  Max iSize is 4,294,967,296. */ŸG  u32 nSet;       /* Number of bits that are set - only valid for aHashŸI                  ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,Ÿ*                  ** this would be 125. */ŸE  u32 iDivisor;   /* Number of bits handled by each apSub[] entry. */Ÿ5                  /* Should >=0 for apSub element. */ŸD                  /* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */ŸI                  /* For a BITVEC_SZ of 512, this would be 34,359,739. */©  union {ŸF    BITVEC_TELEM aBitmap[BITVEC_NELEM];    /* Bitmap representation */Ÿ@    u32 aHash[BITVEC_NINT];      /* Hash table representation */Ÿ?    Bitvec *apSub[BITVEC_NPTR];  /* Recursive representation */¶  } u;¢};†¢/*ŸF** Create a new bitmap object able to handle bits between 0 and iSize,ŸC** inclusive.  Return a pointer to the new object.  Return NULL if ∞** malloc fails.¢*/Ÿ6SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize){¨  Bitvec *p;Ÿ"  assert( sizeof(*p)==BITVEC_SZ );Ÿ&  p = sqlite3MallocZero( sizeof(*p) );™  if( p ){µ    p->iSize = iSize;£  }´  return p;°}†¢/*Ÿ>** Check to see if the i-th bit is set.  Return true or false.Ÿ:** If p is NULL (if the bitmap has not been created) or ifŸ(** i is out of range, then return false.¢*/Ÿ>SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){±  assert( p!=0 );¶  i--;Ω  if( i>=p->iSize ) return 0;∑  while( p->iDivisor ){º    u32 bin = i/p->iDivisor;∂    i = i%p->iDivisor;∏    p = p->u.apSub[bin];≠    if (!p) {Ø      return 0;•    }£  }æ  if( p->iSize<=BITVEC_NBIT ){ŸK    return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;©  } else{Ω    u32 h = BITVEC_HASH(i++);ª    while( p->u.aHash[h] ){Ÿ&      if( p->u.aHash[h]==i ) return 1;æ      h = (h+1) % BITVEC_NINT;•    }≠    return 0;£  }°}Ÿ7SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i){Ÿ/  return p!=0 && sqlite3BitvecTestNotNull(p,i);°}†¢/*Ÿ>** Set the i-th bit.  Return 0 on success and an error code if∑** anything goes wrong.¢**ŸA** This routine might cause sub-bitmaps to be allocated.  FailingŸ>** to get the memory needed to hold the sub-bitmap is the onlyŸ@** that can go wrong with an insert, assuming p and i are valid.¢**ŸC** The calling function must ensure that p is a valid Bitvec objectŸC** and that the value for "i" is within range of the Bitvec object.Ÿ'** Otherwise the behavior is undefined.¢*/Ÿ6SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i){®  u32 h;æ  if( p==0 ) return SQLITE_OK;∞  assert( i>0 );∏  assert( i<=p->iSize );¶  i--;Ÿ2  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {º    u32 bin = i/p->iDivisor;∂    i = i%p->iDivisor;Ω    if( p->u.apSub[bin]==0 ){Ÿ;      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );Ÿ8      if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM_BKPT;•    }∏    p = p->u.apSub[bin];£  }æ  if( p->iSize<=BITVEC_NBIT ){Ÿ@    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));µ    return SQLITE_OK;£  }∑  h = BITVEC_HASH(i++);Ÿ:  /* if there wasn't a hash collision, and this doesn't */Ÿ:  /* completely fill the hash, then just add it without */Ÿ2  /* worring about sub-dividing and re-hashing. */∑  if( !p->u.aHash[h] ){Ÿ"    if (p->nSet<(BITVEC_NINT-1)) {∫      goto bitvec_set_end;¨    } else {Ω      goto bitvec_set_rehash;•    }£  }Ÿ;  /* there was a collision, check to see if it's already */Ÿ2  /* in hash, if not, try to find a spot for it */¶  do {Ÿ,    if( p->u.aHash[h]==i ) return SQLITE_OK;®    h++;ø    if( h>=BITVEC_NINT ) h = 0;ª  } while( p->u.aHash[h] );Ÿ=  /* we didn't find it in the hash.  h points to the first */Ÿ=  /* available free spot. check to see if this is going to */Ÿ"  /* make our hash too "full".  */≤bitvec_set_rehash:ø  if( p->nSet>=BITVEC_MXHASH ){≥    unsigned int j;´    int rc;Ÿ@    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));∂    if( aiValues==0 ){ø      return SQLITE_NOMEM_BKPT;™    }else{Ÿ7      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));Ÿ0      memset(p->u.apSub, 0, sizeof(p->u.apSub));Ÿ=      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;Ÿ"      rc = sqlite3BitvecSet(p, i);Ÿ#      for(j=0; j<BITVEC_NINT; j++){ŸA        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);ß      }Ÿ$      sqlite3StackFree(0, aiValues);∞      return rc;•    }£  }Øbitvec_set_end:¨  p->nSet++;¥  p->u.aHash[h] = i;≥  return SQLITE_OK;°}†¢/*∂** Clear the i-th bit.¢**ŸJ** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storageŸ6** that BitvecClear can use to rebuilt its hash table.¢*/ŸESQLITE_PRIVATE void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){¥  if( p==0 ) return;∞  assert( i>0 );¶  i--;∑  while( p->iDivisor ){º    u32 bin = i/p->iDivisor;∂    i = i%p->iDivisor;∏    p = p->u.apSub[bin];≠    if (!p) {≠      return;•    }£  }æ  if( p->iSize<=BITVEC_NBIT ){ŸC    p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));®  }else{≥    unsigned int j;π    u32 *aiValues = pBuf;Ÿ5    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));Ÿ.    memset(p->u.aHash, 0, sizeof(p->u.aHash));∞    p->nSet = 0;Ÿ!    for(j=0; j<BITVEC_NINT; j++){Ÿ.      if( aiValues[j] && aiValues[j]!=(i+1) ){Ÿ+        u32 h = BITVEC_HASH(aiValues[j]-1);≤        p->nSet++;ø        while( p->u.aHash[h] ){Æ          h++;Ÿ%          if( h>=BITVEC_NINT ) h = 0;©        }Ÿ$        p->u.aHash[h] = aiValues[j];ß      }•    }£  }°}†¢/*Ÿ5** Destroy a bitmap object.  Reclaim all memory used.¢*/Ÿ4SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p){¥  if( p==0 ) return;¥  if( p->iDivisor ){≥    unsigned int i;Ÿ!    for(i=0; i<BITVEC_NPTR; i++){Ÿ*      sqlite3BitvecDestroy(p->u.apSub[i]);•    }£  }≤  sqlite3_free(p);°}†¢/*ŸC** Return the value of the iSize parameter specified when Bitvec *pØ** was created.¢*/Ÿ0SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec *p){≤  return p->iSize;°}†π#ifndef SQLITE_UNTESTABLE¢/*Ÿ@** Let V[] be an array of unsigned characters sufficient to holdŸ?** up to N bits.  Let I be an integer between 0 and N.  0<=I<N.Ÿ?** Then the following macros can be used to set, clear, or testº** individual bits within V.¢*/Ÿ.#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))Ÿ/#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))Ÿ0#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0†¢/*Ÿ:** This routine runs an extensive test of the Bitvec code.¢**Ÿ;** The input is an array of integers that acts as a programŸ9** to test the Bitvec.  The integers are opcodes followedŸ<** by 0, 1, or 3 operands, depending on the opcode.  AnotherŸ5** opcode follows immediately after the last operand.¢**Ÿ;** There are 6 opcodes numbered from 0 through 5.  0 is theŸ,** "halt" opcode and causes the test to end.¢**Ÿ5**    0          Halt and return the number of errorsŸB**    1 N S X    Set N bits beginning with S and incrementing by XŸD**    2 N S X    Clear N bits beginning with S and incrementing by XŸ+**    3 N        Set N randomly chosen bitsŸ-**    4 N        Clear N randomly chosen bitsŸK**    5 N S X    Set N bits from S increment X in array only, not in bitvec¢**ŸI** The opcodes 1 through 4 perform set and clear operations are performedŸN** on both a Bitvec object and on a linear array of bits obtained from malloc.Ÿ>** Opcode 5 works on the linear array only, not on the Bitvec.Ÿ>** Opcode 5 is used to deliberately induce a fault in order toŸ&** confirm that error detection works.¢**Ÿ=** At the conclusion of the test the linear array is comparedŸ<** against the Bitvec object.  If there are any differences,ŸA** an error is returned.  If they are the same, zero is returned.¢**Ÿ2** If a memory allocation error occurs, return -1.¢*/Ÿ>SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){∂  Bitvec *pBitvec = 0;∏  unsigned char *pV = 0;Æ  int rc = -1;¥  int i, nx, pc, op;≤  void *pTmpSpace;†Ÿ;  /* Allocate the Bitvec to be tested and a linear array ofŸ$  ** bits to act as the reference */Ÿ&  pBitvec = sqlite3BitvecCreate( sz );Ÿ)  pV = sqlite3MallocZero( (sz+7)/8 + 1 );Ÿ*  pTmpSpace = sqlite3_malloc64(BITVEC_SZ);Ÿ=  if( pBitvec==0 || pV==0 || pTmpSpace==0  ) goto bitvec_end;†∫  /* NULL pBitvec tests */π  sqlite3BitvecSet(0, 1);Ÿ&  sqlite3BitvecClear(0, 1, pTmpSpace);†∑  /* Run the program */©  pc = 0;Ω  while( (op = aOp[pc])!=0 ){±    switch( op ){≠      case 1:≠      case 2:Ø      case 5: {Ø        nx = 4;∫        i = aOp[pc+2] - 1;ø        aOp[pc+2] += aOp[pc+3];Æ        break;ß      }≠      case 3:Æ      case 4: ∞      default: {Ø        nx = 2;Ÿ*        sqlite3_randomness(sizeof(i), &i);Æ        break;ß      }•    }Ÿ#    if( (--aOp[pc+1]) > 0 ) nx = 0;≠    pc += nx;º    i = (i & 0x7fffffff)%sz;∂    if( (op & 1)!=0 ){∏      SETBIT(pV, (i+1));≤      if( op!=5 ){Ÿ=        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;ß      }™    }else{∫      CLEARBIT(pV, (i+1));Ÿ2      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);•    }£  }†Ÿ;  /* Test to make sure the linear array exactly matches theŸ;  ** Bitvec object.  Start with the assumption that they doŸ;  ** match (rc==0).  Change rc to non-zero if a discrepancyÆ  ** is found.§  */Ÿ@  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)Ÿ)          + sqlite3BitvecTest(pBitvec, 0)Ÿ.          + (sqlite3BitvecSize(pBitvec) - sz);∑  for(i=1; i<=sz; i++){Ÿ9    if(  (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){≠      rc = i;¨      break;•    }£  }†Ÿ   /* Free allocated structure */´bitvec_end:∫  sqlite3_free(pTmpSpace);≥  sqlite3_free(pV);Ÿ   sqlite3BitvecDestroy(pBitvec);¨  return rc;°}æ#endif /* SQLITE_UNTESTABLE */†ŸO/************** End of bitvec.c **********************************************/ŸO/************** Begin file pcache.c ******************************************/¢/*±** 2008 August 05¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************Ÿ(** This file implements that page cache.¢*/º/* #include "sqliteInt.h" */†¢/*ŸA** A complete page cache is an instance of this structure.  EveryŸD** entry in the cache holds a single page of the database file.  TheŸF** btree layer only operates on the cached copy of the database pages.¢**ŸH** A page cache entry is "clean" if it exactly matches what is currentlyŸF** on disk.  A page is "dirty" if it has been modified and needs to beµ** persisted to disk.¢**ø** pDirty, pDirtyTail, pSynced:ŸA**   All dirty pages are linked into the doubly linked list usingŸI**   PgHdr.pDirtyNext and pDirtyPrev. The list is maintained in LRU orderŸH**   such that p was added to the list more recently than p->pDirtyNext.ŸG**   PCache.pDirty points to the first (newest) element in the list andŸ%**   pDirtyTail to the last (oldest).¢**ŸJ**   The PCache.pSynced variable is used to optimize searching for a dirtyŸH**   page to eject from the cache mid-transaction. It is better to ejectŸE**   a page that does not require a journal sync than one that does. ŸG**   Therefore, pSynced is maintained to that it *almost* always pointsŸG**   to either the oldest page in the pDirty/pDirtyTail list that has aŸH**   clear PGHDR_NEED_SYNC flag or to a page that is older than this oneŸJ**   (so that the right page to eject can be found by following pDirtyPrevØ**   pointers).¢*/Østruct PCache {ŸL  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */ŸO  PgHdr *pSynced;                     /* Last synced page in dirty page list */ŸL  int nRefSum;                        /* Sum of ref counts over all pages */ŸA  int szCache;                        /* Configured cache size */ŸG  int szSpill;                        /* Size before spilling occurs */ŸL  int szPage;                         /* Size of every page in this cache */ŸM  int szExtra;                        /* Size of extra space for each page */ŸN  u8 bPurgeable;                      /* True if pages are on backing store */ŸJ  u8 eCreate;                         /* eCreate value for for xFetch() */ŸI  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */Ÿ?  void *pStress;                      /* Argument to xStress */ŸB  sqlite3_pcache *pCache;             /* Pluggable cache module */¢};†ŸP/********************************** Test and Debug Logic **********************/¢/*ŸB** Debug tracing macros.  Enable by by changing the "0" to "1" andØ** recompiling.¢**ŸG** When sqlite3PcacheTrace is 1, single line trace messages are issued.ŸO** When sqlite3PcacheTrace is 2, a dump of the pcache showing all cache entriesŸB** is displayed for many operations, resulting in a lot of output.¢*/æ#if defined(SQLITE_DEBUG) && 0ŸK  int sqlite3PcacheTrace = 2;       /* 0: off  1: simple  2: cache dumps */ŸL  int sqlite3PcacheMxDump = 9999;   /* Max cache entries for pcacheDump() */ŸE# define pcacheTrace(X) if(sqlite3PcacheTrace){sqlite3DebugPrintf X;}Ÿ"  void pcacheDump(PCache *pCache){™    int N;≠    int i, j;Ÿ     sqlite3_pcache_page *pLower;Ø    PgHdr *pPg;µ    unsigned char *a;¢  Ÿ&    if( sqlite3PcacheTrace<2 ) return;Ÿ#    if( pCache->pCache==0 ) return;Ÿ'    N = sqlite3PcachePagecount(pCache);Ÿ8    if( N>sqlite3PcacheMxDump ) N = sqlite3PcacheMxDump;∏    for(i=1; i<=N; i++){ŸI       pLower = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, i, 0);Ÿ        if( pLower==0 ) continue;Ÿ$       pPg = (PgHdr*)pLower->pExtra;ŸI       printf("%3d: nRef %2d flgs %02x data ", i, pPg->nRef, pPg->flags);Ÿ)       a = (unsigned char *)pLower->pBuf;Ÿ0       for(j=0; j<12; j++) printf("%02x", a[j]);¥       printf("\n");ª       if( pPg->pPage==0 ){ŸG         sqlite3GlobalConfig.pcache2.xUnpin(pCache->pCache, pLower, 0);®       }•    }£  }ß  #else∑# define pcacheTrace(X)∂# define pcacheDump(X)¶#endif†¢/*ŸG** Check invariants on a PgHdr entry.  Return true if everything is OK.Ÿ-** Return false if any invariant is violated.¢**ŸC** This routine is for use inside of assert() statements only.  For´** example:¢**Ÿ3**          assert( sqlite3PcachePageSanity(pPg) );¢*/≥#ifdef SQLITE_DEBUGŸ7SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr *pPg){±  PCache *pCache;≥  assert( pPg!=0 );ŸL  assert( pPg->pgno>0 || pPg->pPager==0 );    /* Page number is 1 or more */∑  pCache = pPg->pCache;ŸE  assert( pCache!=0 );      /* Every page has an associated PCache */Ÿ!  if( pPg->flags & PGHDR_CLEAN ){ŸP    assert( (pPg->flags & PGHDR_DIRTY)==0 );/* Cannot be both CLEAN and DIRTY */ŸO    assert( pCache->pDirty!=pPg );          /* CLEAN pages not on dirty list */Ÿ&    assert( pCache->pDirtyTail!=pPg );£  }Ÿ*  /* WRITEABLE pages must also be DIRTY */Ÿ%  if( pPg->flags & PGHDR_WRITEABLE ){ŸI    assert( pPg->flags & PGHDR_DIRTY );     /* WRITEABLE implies DIRTY */£  }ŸG  /* NEED_SYNC can be set independently of WRITEABLE.  This can happen,ŸF  ** for example, when using the sqlite3PagerDontWrite() optimization:ŸD  **    (1)  Page X is journalled, and gets WRITEABLE and NEED_SEEK.Ÿ;  **    (2)  Page X moved to freelist, WRITEABLE is clearedŸ2  **    (3)  Page X reused, WRITEABLE is set againŸH  ** If NEED_SYNC had been cleared in step 2, then it would not be resetŸI  ** in step 3, and page might be written into the database without firstŸJ  ** syncing the rollback journal, which might cause corruption on a power™  ** loss.§  **ŸG  ** Another example is when the database page size is smaller than theŸJ  ** disk sector size.  When any page of a sector is journalled, all pagesŸK  ** in that sector are marked NEED_SYNC even if they are still CLEAN, justŸH  ** in case they are later modified, since all pages in the same sectorŸJ  ** must be journalled and synced before any of those pages can be safely≠  ** written.§  */´  return 1;°}π#endif /* SQLITE_DEBUG */††ŸP/********************************** Linked List Management ********************/†ŸC/* Allowed values for second argument to pcacheManageDirtyList() */ŸI#define PCACHE_DIRTYLIST_REMOVE   1    /* Remove pPage from dirty list */ŸH#define PCACHE_DIRTYLIST_ADD      2    /* Add pPage to the dirty list */ŸP#define PCACHE_DIRTYLIST_FRONT    3    /* Move pPage to the front of the list */†¢/*ŸI** Manage pPage's participation on the dirty list.  Bits of the addRemoveŸF** argument determines what operation to do.  The 0x01 bit means firstŸF** remove pPage from the dirty list.  The 0x02 means add pPage back toŸJ** the dirty list.  Doing both moves pPage to the front of the dirty list.¢*/Ÿ>static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){º  PCache *p = pPage->pCache;†Ÿ)  pcacheTrace(("%p.DIRTYLIST.%s %d\n", p,ŸI                addRemove==1 ? "REMOVE" : addRemove==2 ? "ADD" : "FRONT",æ                pPage->pgno));Ÿ,  if( addRemove & PCACHE_DIRTYLIST_REMOVE ){Ÿ8    assert( pPage->pDirtyNext || pPage==p->pDirtyTail );Ÿ4    assert( pPage->pDirtyPrev || pPage==p->pDirty );¢  Ÿ;    /* Update the PCache1.pSynced variable if necessary. */º    if( p->pSynced==pPage ){Ÿ%      p->pSynced = pPage->pDirtyPrev;•    }¢  º    if( pPage->pDirtyNext ){Ÿ8      pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;™    }else{Ÿ%      assert( pPage==p->pDirtyTail );Ÿ(      p->pDirtyTail = pPage->pDirtyPrev;•    }º    if( pPage->pDirtyPrev ){Ÿ8      pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;™    }else{ŸI      /* If there are now no dirty pages in the cache, set eCreate to 2. ŸI      ** This is an optimization that allows sqlite3PcacheFetch() to skipŸI      ** searching for a dirty page to eject from the cache when it mightø      ** otherwise have to.  */Ÿ!      assert( pPage==p->pDirty );Ÿ$      p->pDirty = pPage->pDirtyNext;Ÿ/      assert( p->bPurgeable || p->eCreate==2 );Ÿ:      if( p->pDirty==0 ){         /*OPTIMIZATION-IF-TRUE*/Ÿ4        assert( p->bPurgeable==0 || p->eCreate==1 );∑        p->eCreate = 2;ß      }•    }£  }Ÿ)  if( addRemove & PCACHE_DIRTYLIST_ADD ){∫    pPage->pDirtyPrev = 0;Ÿ"    pPage->pDirtyNext = p->pDirty;º    if( pPage->pDirtyNext ){Ÿ1      assert( pPage->pDirtyNext->pDirtyPrev==0 );Ÿ,      pPage->pDirtyNext->pDirtyPrev = pPage;™    }else{º      p->pDirtyTail = pPage;∫      if( p->bPurgeable ){Ÿ         assert( p->eCreate==2 );∑        p->eCreate = 1;ß      }•    }∂    p->pDirty = pPage;†ŸG    /* If pSynced is NULL and this page has a clear NEED_SYNC flag, setŸA    ** pSynced to point to it. Checking the NEED_SYNC flag is an ŸF    ** optimization, as if pSynced points to a page with the NEED_SYNCŸF    ** flag set sqlite3PcacheFetchStress() searches through all newer ŸL    ** entries of the dirty-list for a page with NEED_SYNC clear anyway.  */¥    if( !p->pSynced ŸE     && 0==(pPage->flags&PGHDR_NEED_SYNC)   /*OPTIMIZATION-IF-FALSE*/¶    ){π      p->pSynced = pPage;•    }£  }∞  pcacheDump(p);°}†¢/*ŸE** Wrapper around the pluggable caches xUnpin method. If the cache isŸB** being used for an in-memory database, this function is a no-op.¢*/Ÿ"static void pcacheUnpin(PgHdr *p){æ  if( p->pCache->bPurgeable ){Ÿ7    pcacheTrace(("%p.UNPIN %d\n", p->pCache, p->pgno));ŸG    sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);∫    pcacheDump(p->pCache);£  }°}†¢/*ŸF** Compute the number of pages of cache requested.   p->szCache is theŸ=** cache size requested by the "PRAGMA cache_size" statement.¢*/Ÿ)static int numberOfCachePages(PCache *p){∂  if( p->szCache>=0 ){ŸN    /* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then theŸ+    ** suggested cache size is set to N. */∂    return p->szCache;®  }else{ŸK    /* IMPLEMENTATION-OF: R-61436-13639 If the argument N is negative, thenŸM    ** the number of cache pages is adjusted to use approximately abs(N*1024)∫    ** bytes of memory. */ŸA    return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));£  }°}†ŸN/*************************************************** General Interfaces ******¢**ŸF** Initialize and shutdown the page cache subsystem. Neither of these º** functions are threadsafe.¢*/Ÿ1SQLITE_PRIVATE int sqlite3PcacheInitialize(void){Ÿ-  if( sqlite3GlobalConfig.pcache2.xInit==0 ){ŸO    /* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then theŸM    ** built-in default page cache is used instead of the application definedµ    ** page cache. */æ    sqlite3PCacheSetDefault();£  }ŸM  return sqlite3GlobalConfig.pcache2.xInit(sqlite3GlobalConfig.pcache2.pArg);°}Ÿ0SQLITE_PRIVATE void sqlite3PcacheShutdown(void){Ÿ.  if( sqlite3GlobalConfig.pcache2.xShutdown ){ŸN    /* IMPLEMENTATION-OF: R-26000-56589 The xShutdown() method may be NULL. */ŸL    sqlite3GlobalConfig.pcache2.xShutdown(sqlite3GlobalConfig.pcache2.pArg);£  }°}†¢/*Ÿ/** Return the size in bytes of a PCache object.¢*/ŸDSQLITE_PRIVATE int sqlite3PcacheSize(void){ return sizeof(PCache); }†¢/*Ÿ?** Create a new PCache object. Storage space to hold the objectŸA** has already been allocated and is passed in as the p pointer. Ÿ@** The caller discovers how much space needs to be allocated by ø** calling sqlite3PcacheSize().¢**ŸB** szExtra is some extra space allocated for each page.  The firstŸF** 8 bytes of the extra space will be zeroed as the page is allocated,ŸD** but remaining content will be uninitialized.  Though it is opaqueŸC** to this module, the extra space really ends up being the MemPage∫** structure in the pager.¢*/Ÿ%SQLITE_PRIVATE int sqlite3PcacheOpen(Ÿ7  int szPage,                  /* Size of every page */ŸJ  int szExtra,                 /* Extra space associated with each page */ŸG  int bPurgeable,              /* True if pages are on backing store */ŸD  int (*xStress)(void*,PgHdr*),/* Call to try to make pages clean */Ÿ8  void *pStress,               /* Argument to xStress */ŸF  PCache *p                    /* Preallocated space for the PCache */¢){ø  memset(p, 0, sizeof(PCache));∞  p->szPage = 1;∑  p->szExtra = szExtra;Ÿ;  assert( szExtra>=8 );  /* First 8 bytes will be zeroed */Ω  p->bPurgeable = bPurgeable;±  p->eCreate = 2;∑  p->xStress = xStress;∑  p->pStress = pStress;≥  p->szCache = 100;±  p->szSpill = 1;ŸI  pcacheTrace(("%p.OPEN szPage %d bPurgeable %d\n",p,szPage,bPurgeable));Ÿ-  return sqlite3PcacheSetPageSize(p, szPage);°}†¢/*ŸL** Change the page size for PCache object. The caller must ensure that thereŸC** are no outstanding page references when this function is called.¢*/ŸHSQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){Ÿ4  assert( pCache->nRefSum==0 && pCache->pDirty==0 );∑  if( pCache->szPage ){π    sqlite3_pcache *pNew;Ÿ/    pNew = sqlite3GlobalConfig.pcache2.xCreate(Ÿ@                szPage, pCache->szExtra + ROUND8(sizeof(PgHdr)),Ÿ"                pCache->bPurgeable¶    );Ÿ+    if( pNew==0 ) return SQLITE_NOMEM_BKPT;ŸM    sqlite3GlobalConfig.pcache2.xCachesize(pNew, numberOfCachePages(pCache));π    if( pCache->pCache ){Ÿ;      sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);•    }∫    pCache->pCache = pNew;º    pCache->szPage = szPage;Ÿ4    pcacheTrace(("%p.PAGESIZE %d\n",pCache,szPage));£  }≥  return SQLITE_OK;°}†¢/*Ÿ'** Try to obtain a page from the cache.¢**ŸE** This routine returns a pointer to an sqlite3_pcache_page object ifŸB** such an object is already in cache, or if a new one is created.ŸE** This routine returns a NULL pointer if the object was not in cacheº** and could not be created.¢**ŸE** The createFlags should be 0 to check for existing pages and shouldŸ3** be 3 (not 1, but 3) to try to create a new page.¢**ŸC** If the createFlag is 0, then NULL is always returned if the pageŸD** is not already in the cache.  If createFlag is 1, then a new pageŸC** is created only if that can be done without spilling dirty pagesŸ.** and without exceeding the cache size limit.¢**ŸD** The caller needs to invoke sqlite3PcacheFetchFinish() to properlyŸB** initialize the sqlite3_pcache_page object and convert it into aŸI** PgHdr object.  The sqlite3PcacheFetch() and sqlite3PcacheFetchFinish()ŸF** routines are split this way for performance reasons. When separatedŸC** they can both (usually) operate without having to push values toŸB** the stack on entry and pop them back off on exit, which saves aæ** lot of pushing and popping.¢*/Ÿ7SQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(Ÿ=  PCache *pCache,       /* Obtain the page from this cache */Ÿ3  Pgno pgno,            /* Page number to obtain */ŸO  int createFlag        /* If true, create page if it does not exist already */¢){Æ  int eCreate;º  sqlite3_pcache_page *pRes;†∂  assert( pCache!=0 );æ  assert( pCache->pCache!=0 );Ÿ+  assert( createFlag==3 || createFlag==0 );ŸN  assert( pCache->eCreate==((pCache->bPurgeable && pCache->pDirty) ? 1 : 2) );†Ÿ;  /* eCreate defines what to do if the page does not exist.Ÿ:  **    0     Do not allocate a new page.  (createFlag==0)Ÿ=  **    1     Allocate a new page if doing so is inexpensive.Ÿ7  **          (createFlag==1 AND bPurgeable AND pDirty)Ÿ@  **    2     Allocate a new page even it doing so is difficult.Ÿ9  **          (createFlag==1 AND !(bPurgeable AND pDirty)§  */Ÿ)  eCreate = createFlag & pCache->eCreate;Ÿ3  assert( eCreate==0 || eCreate==1 || eCreate==2 );Ÿ6  assert( createFlag==0 || pCache->eCreate==eCreate );ŸO  assert( createFlag==0 || eCreate==1+(!pCache->bPurgeable||!pCache->pDirty) );ŸK  pRes = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, eCreate);Ÿ:  pcacheTrace(("%p.FETCH %d%s (result: %p)\n",pCache,pgno,Ÿ.               createFlag?" create":"",pRes));Æ  return pRes;°}†¢/*ŸB** If the sqlite3PcacheFetch() routine is unable to allocate a newŸD** page because no clean pages are available for reuse and the cacheŸD** size limit has been reached, then this routine can be invoked to ŸG** try harder to allocate a page.  This routine might invoke the stressŸE** callback to spill dirty pages to the journal.  It will then try toŸE** allocate the new page and will only fail to allocate a new page on∞** an OOM error.¢**ŸH** This routine should be invoked only after sqlite3PcacheFetch() fails.¢*/Ÿ,SQLITE_PRIVATE int sqlite3PcacheFetchStress(ŸG  PCache *pCache,                 /* Obtain the page from this cache */Ÿ=  Pgno pgno,                      /* Page number to obtain */Ÿ9  sqlite3_pcache_page **ppPage    /* Write result here */¢){≠  PgHdr *pPg;Ÿ$  if( pCache->eCreate==2 ) return 0;†Ÿ7  if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){ŸG    /* Find a dirty page to write-out and recycle. First try to find a ŸJ    ** page that does not require a journal-sync (one with PGHDR_NEED_SYNCŸB    ** cleared), but if that is not possible settle for any other ø    ** unreferenced dirty page.¶    **ŸI    ** If the LRU page in the dirty list that has a clear PGHDR_NEED_SYNCŸI    ** flag is currently referenced, then the following may leave pSyncedŸJ    ** set incorrectly (pointing to other than the LRU page with NEED_SYNCŸD    ** cleared). This is Ok, as pSynced is just an optimization.  */Ω    for(pPg=pCache->pSynced; Ÿ<        pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC)); ª        pPg=pPg->pDirtyPrev¶    );∫    pCache->pSynced = pPg;Ø    if( !pPg ){ŸI      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);•    }Æ    if( pPg ){≠      int rc;Ω#ifdef SQLITE_LOG_CACHE_SPILLø      sqlite3_log(SQLITE_FULL, ŸI                  "spill page %d making room for %d - cache used: %d/%d",Ÿ"                  pPg->pgno, pgno,ŸI                  sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache),Ÿ,                numberOfCachePages(pCache));¶#endifŸ6      pcacheTrace(("%p.SPILL %d\n",pCache,pPg->pgno));Ÿ1      rc = pCache->xStress(pCache->pStress, pPg);π      pcacheDump(pCache);Ÿ-      if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){≤        return rc;ß      }•    }£  }ŸH  *ppPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, 2);Ÿ4  return *ppPage==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;°}†¢/*Ÿ:** This is a helper routine for sqlite3PcacheFetchFinish()¢**ŸA** In the uncommon case where the page being fetched has not beenŸA** initialized, this routine is invoked to do the initialization.Ÿ?** This routine is broken out into a separate function since itŸF** requires extra stack manipulation that can be avoided in the common®** case.¢*/Ÿ8static SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit(ŸC  PCache *pCache,             /* Obtain the page from this cache */Ÿ8  Pgno pgno,                  /* Page number obtained */ŸM  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */¢){∞  PgHdr *pPgHdr;µ  assert( pPage!=0 );Ÿ!  pPgHdr = (PgHdr*)pPage->pExtra;Ω  assert( pPgHdr->pPage==0 );ŸE  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));∏  pPgHdr->pPage = pPage;æ  pPgHdr->pData = pPage->pBuf;Ÿ&  pPgHdr->pExtra = (void *)&pPgHdr[1];ø  memset(pPgHdr->pExtra, 0, 8);∫  pPgHdr->pCache = pCache;∂  pPgHdr->pgno = pgno;æ  pPgHdr->flags = PGHDR_CLEAN;Ÿ5  return sqlite3PcacheFetchFinish(pCache,pgno,pPage);°}†¢/*ŸC** This routine converts the sqlite3_pcache_page object returned byŸG** sqlite3PcacheFetch() into an initialized PgHdr object.  This routineŸE** must be called after sqlite3PcacheFetch() in order to get a usable™** result.¢*/Ÿ/SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(ŸC  PCache *pCache,             /* Obtain the page from this cache */Ÿ8  Pgno pgno,                  /* Page number obtained */ŸM  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */¢){∞  PgHdr *pPgHdr;†µ  assert( pPage!=0 );Ÿ"  pPgHdr = (PgHdr *)pPage->pExtra;†∑  if( !pPgHdr->pPage ){Ÿ:    return pcacheFetchFinishWithInit(pCache, pgno, pPage);£  }¥  pCache->nRefSum++;±  pPgHdr->nRef++;Ÿ,  assert( sqlite3PcachePageSanity(pPgHdr) );∞  return pPgHdr;°}†¢/*ŸH** Decrement the reference count on a page. If the page is clean and theŸF** reference count drops to 0, then it is made eligible for recycling.¢*/ŸCSQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){∂  assert( p->nRef>0 );∑  p->pCache->nRefSum--;∑  if( (--p->nRef)==0 ){ø    if( p->flags&PGHDR_CLEAN ){µ      pcacheUnpin(p);™    }else{Ÿ7      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);•    }£  }°}†¢/*Ÿ8** Increase the reference count of a supplied page by 1.¢*/Ÿ/SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p){¥  assert(p->nRef>0);Ÿ'  assert( sqlite3PcachePageSanity(p) );¨  p->nRef++;∑  p->pCache->nRefSum++;°}†¢/*ŸI** Drop a page from the cache. There must be exactly one reference to theŸF** page. This function deletes that reference, so after it returns theŸ#** page pointed to by p is invalid.¢*/Ÿ0SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p){∑  assert( p->nRef==1 );Ÿ'  assert( sqlite3PcachePageSanity(p) );Ω  if( p->flags&PGHDR_DIRTY ){Ÿ6    pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);£  }∑  p->pCache->nRefSum--;ŸE  sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);°}†¢/*ŸD** Make sure the page is marked as dirty. If it isn't dirty already,Æ** make it so.¢*/Ÿ5SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr *p){∂  assert( p->nRef>0 );Ÿ'  assert( sqlite3PcachePageSanity(p) );ŸO  if( p->flags & (PGHDR_CLEAN|PGHDR_DONT_WRITE) ){    /*OPTIMIZATION-IF-FALSE*/Ÿ"    p->flags &= ~PGHDR_DONT_WRITE;Ÿ!    if( p->flags & PGHDR_CLEAN ){Ÿ,      p->flags ^= (PGHDR_DIRTY|PGHDR_CLEAN);Ÿ7      pcacheTrace(("%p.DIRTY %d\n",p->pCache,p->pgno));ŸD      assert( (p->flags & (PGHDR_DIRTY|PGHDR_CLEAN))==PGHDR_DIRTY );Ÿ5      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_ADD);•    }Ÿ)    assert( sqlite3PcachePageSanity(p) );£  }°}†¢/*ŸD** Make sure the page is marked as clean. If it isn't clean already,Æ** make it so.¢*/Ÿ5SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr *p){Ÿ'  assert( sqlite3PcachePageSanity(p) );Ÿ(  assert( (p->flags & PGHDR_DIRTY)!=0 );Ÿ(  assert( (p->flags & PGHDR_CLEAN)==0 );Ÿ4  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);Ÿ=  p->flags &= ~(PGHDR_DIRTY|PGHDR_NEED_SYNC|PGHDR_WRITEABLE);∫  p->flags |= PGHDR_CLEAN;Ÿ3  pcacheTrace(("%p.CLEAN %d\n",p->pCache,p->pgno));Ÿ'  assert( sqlite3PcachePageSanity(p) );≥  if( p->nRef==0 ){≥    pcacheUnpin(p);£  }°}†¢/*Ÿ&** Make every page in the cache clean.¢*/Ÿ:SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache){´  PgHdr *p;Ÿ)  pcacheTrace(("%p.CLEAN-ALL\n",pCache));Ÿ#  while( (p = pCache->pDirty)!=0 ){æ    sqlite3PcacheMakeClean(p);£  }°}†¢/*ŸK** Clear the PGHDR_NEED_SYNC and PGHDR_WRITEABLE flag from all dirty pages.¢*/Ÿ?SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache *pCache){´  PgHdr *p;Ÿ/  pcacheTrace(("%p.CLEAR-WRITEABLE\n",pCache));Ÿ,  for(p=pCache->pDirty; p; p=p->pDirtyNext){Ÿ3    p->flags &= ~(PGHDR_NEED_SYNC|PGHDR_WRITEABLE);£  }Ÿ'  pCache->pSynced = pCache->pDirtyTail;°}†¢/*Ÿ7** Clear the PGHDR_NEED_SYNC flag from all dirty pages.¢*/Ÿ@SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache){´  PgHdr *p;Ÿ,  for(p=pCache->pDirty; p; p=p->pDirtyNext){Ÿ!    p->flags &= ~PGHDR_NEED_SYNC;£  }Ÿ'  pCache->pSynced = pCache->pDirtyTail;°}†¢/*Ÿ0** Change the page number of page p to newPgno. ¢*/Ÿ>SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){Ω  PCache *pCache = p->pCache;∂  assert( p->nRef>0 );∂  assert( newPgno>0 );Ÿ'  assert( sqlite3PcachePageSanity(p) );Ÿ=  pcacheTrace(("%p.MOVE %d -> %d\n",pCache,p->pgno,newPgno));ŸP  sqlite3GlobalConfig.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno,newPgno);¥  p->pgno = newPgno;Ÿ=  if( (p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC) ){Ÿ5    pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);£  }°}†¢/*ŸG** Drop every cache entry whose page number is greater than "pgno". TheŸK** caller must ensure that there are no outstanding references to any pagesŸ:** other than page 1 with a page number greater than pgno.¢**ŸJ** If there is a reference to page 1 and the pgno parameter passed to thisŸJ** function is 0, then the data area associated with page 1 is zeroed, butŸ"** the page object is not dropped.¢*/ŸESQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){∑  if( pCache->pCache ){≠    PgHdr *p;±    PgHdr *pNext;Ÿ2    pcacheTrace(("%p.TRUNCATE %d\n",pCache,pgno));Ÿ&    for(p=pCache->pDirty; p; p=pNext){º      pNext = p->pDirtyNext;ŸG      /* This routine never gets call with a positive pgno except rightŸE      ** after sqlite3PcacheCleanAll().  So if there are dirty pages,Ÿ!      ** it must be that pgno==0.®      */∫      assert( p->pgno>0 );π      if( p->pgno>pgno ){Ÿ'        assert( p->flags&PGHDR_DIRTY );Ÿ"        sqlite3PcacheMakeClean(p);ß      }•    }Ÿ%    if( pgno==0 && pCache->nRefSum ){Ÿ"      sqlite3_pcache_page *pPage1;ŸF      pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache,1,0);ŸL      if( ALWAYS(pPage1) ){  /* Page 1 is always available in cache, becauseŸ4                             ** pCache->nRefSum>0 */Ÿ0        memset(pPage1->pBuf, 0, pCache->szPage);±        pgno = 1;ß      }•    }ŸB    sqlite3GlobalConfig.pcache2.xTruncate(pCache->pCache, pgno+1);£  }°}†¢/*±** Close a cache.¢*/Ÿ7SQLITE_PRIVATE void sqlite3PcacheClose(PCache *pCache){æ  assert( pCache->pCache!=0 );Ÿ%  pcacheTrace(("%p.CLOSE\n",pCache));Ÿ7  sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);°}†£/* Ÿ%** Discard the contents of the cache.¢*/Ÿ7SQLITE_PRIVATE void sqlite3PcacheClear(PCache *pCache){Ÿ#  sqlite3PcacheTruncate(pCache, 0);°}†¢/*ŸB** Merge two lists of pages connected by pDirty and in pgno order.Ÿ0** Do not bother fixing the pDirtyPrev pointers.¢*/Ÿ9static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){∑  PgHdr result, *pTail;≤  pTail = &result;ª  assert( pA!=0 && pB!=0 );™  for(;;){º    if( pA->pgno<pB->pgno ){π      pTail->pDirty = pA;±      pTail = pA;∂      pA = pA->pDirty;≤      if( pA==0 ){ª        pTail->pDirty = pB;Æ        break;ß      }™    }else{π      pTail->pDirty = pB;±      pTail = pB;∂      pB = pB->pDirty;≤      if( pB==0 ){ª        pTail->pDirty = pA;Æ        break;ß      }•    }£  }∑  return result.pDirty;°}†¢/*Ÿ@** Sort the list of pages in accending order by pgno.  Pages areŸ=** connected by pDirty pointers.  The pDirtyPrev pointers are∫** corrupted by this sort.¢**ŸE** Since there cannot be more than 2^31 distinct pages in a database,ŸE** there cannot be more than 31 buckets required by the merge sorter.Ÿ@** One extra bucket is added to catch overflow in case somethingŸ8** ever changes to make the previous sentence incorrect.¢*/π#define N_SORT_BUCKET  32Ÿ.static PgHdr *pcacheSortDirtyList(PgHdr *pIn){æ  PgHdr *a[N_SORT_BUCKET], *p;®  int i;∫  memset(a, 0, sizeof(a));Ø  while( pIn ){¨    p = pIn;¥    pIn = p->pDirty;≤    p->pDirty = 0;Ÿ-    for(i=0; ALWAYS(i<N_SORT_BUCKET-1); i++){¥      if( a[i]==0 ){±        a[i] = p;Æ        break;¨      }else{Ÿ*        p = pcacheMergeDirtyList(a[i], p);±        a[i] = 0;ß      }•    }Ÿ$    if( NEVER(i==N_SORT_BUCKET-1) ){ŸD      /* To get here, there need to be 2^(N_SORT_BUCKET) elements inŸ1      ** the input list.  But that is impossible.®      */Ÿ+      a[i] = pcacheMergeDirtyList(a[i], p);•    }£  }´  p = a[0];Ÿ!  for(i=1; i<N_SORT_BUCKET; i++){ª    if( a[i]==0 ) continue;Ÿ1    p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];£  }´  return p;°}†¢/*ŸH** Return a list of all dirty pages in the cache, sorted by page number.¢*/Ÿ=SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){´  PgHdr *p;Ÿ,  for(p=pCache->pDirty; p; p=p->pDirtyNext){æ    p->pDirty = p->pDirtyNext;£  }Ÿ-  return pcacheSortDirtyList(pCache->pDirty);°}†£/* ŸH** Return the total number of references to all pages held by the cache.¢**ŸG** This is not the total number of pages referenced, but the sum of theŸ!** reference count for all pages.¢*/Ÿ9SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){π  return pCache->nRefSum;°}†¢/*ŸG** Return the number of references to the page supplied as an argument.¢*/Ÿ7SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p){±  return p->nRef;°}†£/* Ÿ1** Return the total number of pages in the cache.¢*/Ÿ:SQLITE_PRIVATE int sqlite3PcachePagecount(PCache *pCache){æ  assert( pCache->pCache!=0 );Ÿ@  return sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache);°}†≤#ifdef SQLITE_TEST¢/*Ÿ&** Get the suggested cache-size value.¢*/Ÿ=SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *pCache){Ÿ$  return numberOfCachePages(pCache);°}¶#endif†¢/*Ÿ&** Set the suggested cache-size value.¢*/ŸJSQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){æ  assert( pCache->pCache!=0 );ª  pCache->szCache = mxPage;Ÿ8  sqlite3GlobalConfig.pcache2.xCachesize(pCache->pCache,ŸE                                         numberOfCachePages(pCache));°}†¢/*ŸB** Set the suggested cache-spill value.  Make no changes if if theŸG** argument is zero.  Return the effective cache-spill size, which willŸ,** be the larger of the szSpill and szCache.¢*/ŸDSQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *p, int mxPage){™  int res;π  assert( p->pCache!=0 );Ø  if( mxPage ){≥    if( mxPage<0 ){ŸA      mxPage = (int)((-1024*(i64)mxPage)/(p->szPage+p->szExtra));•    }∏    p->szSpill = mxPage;£  }æ  res = numberOfCachePages(p);Ÿ)  if( res<p->szSpill ) res = p->szSpill; ≠  return res;°}†¢/*Ÿ:** Free up as much memory as possible from the page cache.¢*/Ÿ8SQLITE_PRIVATE void sqlite3PcacheShrink(PCache *pCache){æ  assert( pCache->pCache!=0 );Ÿ6  sqlite3GlobalConfig.pcache2.xShrink(pCache->pCache);°}†¢/*Ÿ?** Return the size of the header added by this middleware layerø** in the page-cache hierarchy.¢*/ŸQSQLITE_PRIVATE int sqlite3HeaderSizePcache(void){ return ROUND8(sizeof(PgHdr)); }†¢/*ŸK** Return the number of dirty pages currently in the cache, as a percentageŸ ** of the configured cache size.¢*/Ÿ=SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache *pCache){∞  PgHdr *pDirty;±  int nDirty = 0;Ÿ*  int nCache = numberOfCachePages(pCache);ŸI  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;Ÿ:  return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0;°}†Ÿ8#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)¢/*ŸC** For all dirty pages currently in the cache, invoke the specifiedŸA** callback. This is only used if the SQLITE_CHECK_PAGES macro is´** defined.¢*/ŸVSQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){∞  PgHdr *pDirty;Ÿ@  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext){≤    xIter(pDirty);£  }°}¶#endif†ŸO/************** End of pcache.c **********************************************/ŸO/************** Begin file pcache1.c *****************************************/¢/*≥** 2008 November 05¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸB** This file implements the default page cache implementation (theŸI** sqlite3_pcache interface). It also contains part of the implementationŸH** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.ŸJ** If the default page cache implementation is overridden, then neither ofŸ$** these two features are available.¢**Ÿ%** A Page cache line looks like this:¢**ŸA**  -------------------------------------------------------------ŸA**  |  database page content   |  PgHdr1  |  MemPage  |  PgHdr  |ŸA**  -------------------------------------------------------------¢**ŸJ** The database page content is up front (so that buffer overreads tend toŸM** flow harmlessly into the PgHdr1, MemPage, and PgHdr extensions).   MemPageŸK** is the extension added by the btree.c module containing information suchŸI** as the database page number and how that database page is used.  PgHdrŸM** is added by the pcache.c layer and contains information used to keep trackŸD** of which pages are "dirty".  PgHdr1 is an extension added by thisŸO** module (pcache1.c).  The PgHdr1 header is a subclass of sqlite3_pcache_page.ŸK** PgHdr1 contains information needed to look up a page by its page number.ŸE** The superclass sqlite3_pcache_page.pBuf points to the start of theŸH** database page content and sqlite3_pcache_page.pExtra points to PgHdr.¢**ŸH** The size of the extension (MemPage+PgHdr+PgHdr1) can be determined atŸH** runtime using sqlite3_config(SQLITE_CONFIG_PCACHE_HDRSZ, &size).  TheŸG** sizes of the extensions sum to 272 bytes on x64 for 3.8.10, but thisŸE** size can vary according to architecture, compile-time options, andŸ!** SQLite library version number.¢**ŸN** If SQLITE_PCACHE_SEPARATE_HEADER is defined, then the extension is obtainedŸK** using a separate memory allocation from the database page content.  ThisŸC** seeks to overcome the "clownshoe" problem (also called "internalŸH** fragmentation" in academic literature) of allocating a few bytes moreŸH** than a power of two with the memory allocator rounding up to the nextŸ9** power of two, and leaving the rounded-up space unused.¢**ŸM** This module tracks pointers to PgHdr1 objects.  Only pcache.c communicatesŸN** with this module.  Information is passed back and forth as PgHdr1 pointers.¢**ŸC** The pcache.c and pager.c modules deal pointers to PgHdr objects.Ÿ=** The btree.c module deals with pointers to MemPage objects.¢**ø** SOURCE OF PAGE CACHE MEMORY:¢**Ÿ:** Memory for a page might come from any of three sources:¢**ŸA**    (1)  The general-purpose memory allocator - sqlite3Malloc()ŸH**    (2)  Global page-cache memory provided using sqlite3_config() withŸ#**         SQLITE_CONFIG_PAGECACHE.Ÿ(**    (3)  PCache-local bulk allocation.¢**ŸK** The third case is a chunk of heap memory (defaulting to 100 pages worth)ŸK** that is allocated when the page cache is created.  The size of the localŸ)** bulk allocation can be adjusted using ¢**Ÿ?**     sqlite3_config(SQLITE_CONFIG_PAGECACHE, (void*)0, 0, N).¢**ŸN** If N is positive, then N pages worth of memory are allocated using a singleŸP** sqlite3Malloc() call and that memory is used for the first N pages allocated.ŸK** Or if N is negative, then -1024*N bytes of memory are allocated and usedŸ+** for as many pages as can be accomodated.¢**ŸK** Only one of (2) or (3) can be used.  Once the memory available to (2) orŸL** (3) is exhausted, subsequent allocations fail over to the general-purpose∏** memory allocator (1).¢**ŸM** Earlier versions of SQLite used only methods (1) and (2).  But experimentsŸM** show that method (3) with N==100 provides about a 5% performance boost for¥** common workloads.¢*/º/* #include "sqliteInt.h" */†øtypedef struct PCache1 PCache1;Ωtypedef struct PgHdr1 PgHdr1;Ÿ%typedef struct PgFreeslot PgFreeslot;Ωtypedef struct PGroup PGroup;†¢/*ŸC** Each cache entry is represented by an instance of the following ŸJ** structure. Unless SQLITE_PCACHE_SEPARATE_HEADER is defined, a buffer ofŸK** PgHdr1.pCache->szPage bytes is allocated directly before this structure ≠** in memory.¢*/Østruct PgHdr1 {ŸO  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf & pExtra */Ÿ>  unsigned int iKey;             /* Key value (page number) */ŸH  u8 isBulkLocal;                /* This page from bulk local storage */ŸE  u8 isAnchor;                   /* This is the PGroup.lru element */Ÿ?  PgHdr1 *pNext;                 /* Next in hash table chain */ŸJ  PCache1 *pCache;               /* Cache that currently owns this page */ŸI  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */ŸM  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */¢};†¢/*Ÿ/** A page is pinned if it is no on the LRU list¢*/Ÿ/#define PAGE_IS_PINNED(p)    ((p)->pLruNext==0)Ÿ/#define PAGE_IS_UNPINNED(p)  ((p)->pLruNext!=0)†ŸG/* Each page cache (or PCache) belongs to a PGroup.  A PGroup is a set ŸH** of one or more PCaches that are able to recycle each other's unpinnedŸI** pages when they are under memory pressure.  A PGroup is an instance of∏** the following object.¢**Ÿ<** This page cache implementation works in one of two modes:¢**ŸF**   (1)  Every PCache is the sole member of its own PGroup.  There isŸ **        one PGroup per PCache.¢**ŸG**   (2)  There is a single global PGroup that all PCaches are a member≠**        of.¢**ŸF** Mode 1 uses more memory (since PCache instances are not able to robŸI** unused pages from other PCaches) but it also operates without a mutex,ŸI** and is therefore often faster.  Mode 2 requires a mutex in order to beŸ3** threadsafe, but recycles pages more efficiently.¢**ŸK** For mode (1), PGroup.mutex is NULL.  For mode (2) there is only a singleŸC** PGroup which is the pcache1.grp global variable and its mutex isª** SQLITE_MUTEX_STATIC_LRU.¢*/Østruct PGroup {Ÿ?  sqlite3_mutex *mutex;          /* MUTEX_STATIC_LRU or NULL */ŸG  unsigned int nMaxPage;         /* Sum of nMax for purgeable caches */ŸG  unsigned int nMinPage;         /* Sum of nMin for purgeable caches */Ÿ?  unsigned int mxPinned;         /* nMaxpage + 10 - nMinPage */ŸJ  unsigned int nPurgeable;       /* Number of purgeable pages allocated */ŸL  PgHdr1 lru;                    /* The beginning and end of the LRU list */¢};†ŸA/* Each page cache is an instance of the following object.  EveryŸA** open database file (including each in-memory database and eachŸA** temporary or transient database) has a single page cache whichŸ!** is an instance of this object.¢**Ÿ@** Pointers to structures of this type are cast and returned as Ÿ"** opaque sqlite3_pcache* handles.¢*/∞struct PCache1 {ŸI  /* Cache configuration parameters. Page size (szPage) and the purgeableŸG  ** flag (bPurgeable) and the pnPurgeable pointer are all set when theŸD  ** cache is created and are never changed thereafter. nMax may be ŸE  ** modified at any time by a call to the pcache1Cachesize() method.Ÿ7  ** The PGroup mutex must be held when accessing nMax.§  */ŸH  PGroup *pGroup;                     /* PGroup this cache belongs to */ŸI  unsigned int *pnPurgeable;          /* Pointer to pGroup->nPurgeable */ŸL  int szPage;                         /* Size of database content section */ŸI  int szExtra;                        /* sizeof(MemPage)+sizeof(PgHdr) */ŸI  int szAlloc;                        /* Total size of one pcache line */ŸF  int bPurgeable;                     /* True if cache is purgeable */ŸL  unsigned int nMin;                  /* Minimum number of pages reserved */ŸI  unsigned int nMax;                  /* Configured "cache_size" value */Ÿ5  unsigned int n90pct;                /* nMax*9/10 */ŸN  unsigned int iMaxKey;               /* Largest key seen since xTruncate() */†ŸJ  /* Hash table of all pages. The following variables may only be accessedŸ3  ** when the accessor is holding the PGroup mutex.§  */ŸK  unsigned int nRecyclable;           /* Number of pages in the LRU list */ŸK  unsigned int nPage;                 /* Total number of pages in apHash */ŸG  unsigned int nHash;                 /* Number of slots in apHash[] */ŸM  PgHdr1 **apHash;                    /* Hash table for fast lookup by key */ŸM  PgHdr1 *pFree;                      /* List of unused pcache-local pages */ŸL  void *pBulk;                        /* Bulk memory used by pcache-local */¢};†¢/*ŸF** Free slots in the allocator used to divide up the global page cacheŸ?** buffer provided using the SQLITE_CONFIG_PAGECACHE mechanism.¢*/≥struct PgFreeslot {Ÿ*  PgFreeslot *pNext;  /* Next free slot */¢};†¢/*Ÿ"** Global data used by this cache.¢*/Ÿ'static SQLITE_WSD struct PCacheGlobal {ŸE  PGroup grp;                    /* The global PGroup for mode (2) */†Ÿ@  /* Variables related to SQLITE_CONFIG_PAGECACHE settings.  TheŸE  ** szSlot, nSlot, pStart, pEnd, nReserve, and isInit values are allŸL  ** fixed at sqlite3_initialize() time and do not require mutex protection.Ÿ@  ** The nFreeSlot and pFree values do require mutex protection.§  */Ÿ:  int isInit;                    /* True if initialized */ŸG  int separateCache;             /* Use a new PGroup for each PCache */ŸF  int nInitPage;                 /* Initial bulk allocation size */   Ÿ=  int szSlot;                    /* Size of each free slot */ŸA  int nSlot;                     /* The number of pcache slots */ŸG  int nReserve;                  /* Try to keep nFreeSlot above this */ŸI  void *pStart, *pEnd;           /* Bounds of global page cache memory */ŸK  /* Above requires no mutex.  Use mutex below for variable that follow. */ŸI  sqlite3_mutex *mutex;          /* Mutex for accessing the following: */Ÿ7  PgFreeslot *pFree;             /* Free page blocks */ŸD  int nFreeSlot;                 /* Number of unused pcache slots */ŸJ  /* The following value requires a mutex to change.  We skip the mutex onŸL  ** reading because (1) most platforms read a 32-bit integer atomically andŸM  ** (2) even if an incorrect value is read, no great harm is done since thisŸ'  ** is really just an optimization. */ŸF  int bUnderPressure;            /* True if low on PAGECACHE memory */¨} pcache1_g;†¢/*ŸI** All code in this file should access the global structure above via theŸD** alias "pcache1". This ensures that the WSD emulation is used whenŸ6** compiling for systems that do not support real WSD.¢*/Ÿ8#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))†¢/*Ÿ2** Macros to enter and leave the PCache LRU mutex.¢*/ŸE#if !defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) || SQLITE_THREADSAFE==0Ÿ4# define pcache1EnterMutex(X)  assert((X)->mutex==0)Ÿ4# define pcache1LeaveMutex(X)  assert((X)->mutex==0)Ÿ(# define PCACHE1_MIGHT_USE_GROUP_MUTEX 0•#elseŸ=# define pcache1EnterMutex(X) sqlite3_mutex_enter((X)->mutex)Ÿ=# define pcache1LeaveMutex(X) sqlite3_mutex_leave((X)->mutex)Ÿ(# define PCACHE1_MIGHT_USE_GROUP_MUTEX 1¶#endif†ŸP/******************************************************************************/ŸP/******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/††¢/*ŸG** This function is called during initialization if a static buffer is ŸL** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHEŸI** verb to sqlite3_config(). Parameter pBuf points to an allocation largeŸ4** enough to contain 'n' buffers of 'sz' bytes each.¢**ŸK** This routine is called from sqlite3_initialize() and so it is guaranteedŸD** to be serialized already.  There is no need for further mutexing.¢*/ŸHSQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){∑  if( pcache1.isInit ){≤    PgFreeslot *p;Ω    if( pBuf==0 ) sz = n = 0;∂    if( n==0 ) sz = 0;∏    sz = ROUNDDOWN8(sz);∏    pcache1.szSlot = sz;Ÿ*    pcache1.nSlot = pcache1.nFreeSlot = n;Ÿ.    pcache1.nReserve = n>90 ? 10 : (n/10 + 1);∫    pcache1.pStart = pBuf;∂    pcache1.pFree = 0;ø    pcache1.bUnderPressure = 0;±    while( n-- ){º      p = (PgFreeslot*)pBuf;ø      p->pNext = pcache1.pFree;∏      pcache1.pFree = p;Ÿ'      pBuf = (void*)&((char*)pBuf)[sz];•    }∏    pcache1.pEnd = pBuf;£  }°}†¢/*ŸH** Try to initialize the pCache->pFree and pCache->pBulk fields.  ReturnŸC** true if pCache->pFree ends up containing one or more free pages.¢*/Ÿ,static int pcache1InitBulk(PCache1 *pCache){≠  i64 szBulk;Æ  char *zBulk;Ÿ&  if( pcache1.nInitPage==0 ) return 0;ŸI  /* Do not bother with a bulk allocation if the cache size very small */Ÿ   if( pCache->nMax<3 ) return 0;Ω  sqlite3BeginBenignMalloc();º  if( pcache1.nInitPage>0 ){Ÿ6    szBulk = pCache->szAlloc * (i64)pcache1.nInitPage;®  }else{Ÿ,    szBulk = -1024 * (i64)pcache1.nInitPage;£  }Ÿ3  if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){Ÿ/    szBulk = pCache->szAlloc*(i64)pCache->nMax;£  }Ÿ2  zBulk = pCache->pBulk = sqlite3Malloc( szBulk );ª  sqlite3EndBenignMalloc();Æ  if( zBulk ){Ÿ9    int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;ß    do{Ÿ3      PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];º      pX->page.pBuf = zBulk;ø      pX->page.pExtra = &pX[1];∫      pX->isBulkLocal = 1;∑      pX->isAnchor = 0;Ÿ       pX->pNext = pCache->pFree;π      pCache->pFree = pX;ø      zBulk += pCache->szAlloc;∂    }while( --nBulk );£  }∫  return pCache->pFree!=0;°}†¢/*ŸJ** Malloc function used within this file to allocate space from the bufferŸJ** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no ŸK** such buffer exists or there is no space left in it, this function falls ª** back to sqlite3Malloc().¢**ŸL** Multiple threads can run this routine at the same time.  Global variablesŸ-** in pcache1 need to be protected via mutex.¢*/Ÿ%static void *pcache1Alloc(int nByte){Æ  void *p = 0;Ÿ5  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );æ  if( nByte<=pcache1.szSlot ){Ÿ'    sqlite3_mutex_enter(pcache1.mutex);Ÿ     p = (PgHdr1 *)pcache1.pFree;¨    if( p ){Ÿ+      pcache1.pFree = pcache1.pFree->pNext;∫      pcache1.nFreeSlot--;ŸB      pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;Ÿ%      assert( pcache1.nFreeSlot>=0 );ŸB      sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);Ÿ7      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);•    }Ÿ'    sqlite3_mutex_leave(pcache1.mutex);£  }≠  if( p==0 ){ŸH    /* Memory is not available in the SQLITE_CONFIG_PAGECACHE pool.  GetŸ%    ** it from sqlite3Malloc instead.¶    */Ω    p = sqlite3Malloc(nByte);Ÿ/#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS¨    if( p ){Ÿ$      int sz = sqlite3MallocSize(p);Ÿ)      sqlite3_mutex_enter(pcache1.mutex);ŸB      sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);Ÿ<      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);Ÿ)      sqlite3_mutex_leave(pcache1.mutex);•    }¶#endifŸ.    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);£  }´  return p;°}†¢/*Ÿ9** Free an allocated buffer obtained from pcache1Alloc().¢*/Ÿ!static void pcache1Free(void *p){¥  if( p==0 ) return;Ÿ7  if( SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd) ){∂    PgFreeslot *pSlot;Ÿ'    sqlite3_mutex_enter(pcache1.mutex);Ÿ7    sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);ª    pSlot = (PgFreeslot*)p;Ÿ!    pSlot->pNext = pcache1.pFree;∫    pcache1.pFree = pSlot;∏    pcache1.nFreeSlot++;Ÿ@    pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;Ÿ/    assert( pcache1.nFreeSlot<=pcache1.nSlot );Ÿ'    sqlite3_mutex_leave(pcache1.mutex);®  }else{Ÿ8    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );Ÿ,    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);Ÿ/#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS•    {µ      int nFreed = 0;Ÿ$      nFreed = sqlite3MallocSize(p);Ÿ)      sqlite3_mutex_enter(pcache1.mutex);ŸB      sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);Ÿ)      sqlite3_mutex_leave(pcache1.mutex);•    }¶#endif¥    sqlite3_free(p);£  }°}†Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT¢/*Ÿ)** Return the size of a pcache allocation¢*/Ÿ#static int pcache1MemSize(void *p){Ÿ,  if( p>=pcache1.pStart && p<pcache1.pEnd ){∫    return pcache1.szSlot;®  }else{Æ    int iSize;Ÿ8    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );Ÿ,    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);Ÿ!    iSize = sqlite3MallocSize(p);Ÿ.    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);±    return iSize;£  }°}Ÿ,#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */†¢/*ŸE** Allocate a new page object initially associated with cache pCache.¢*/ŸCstatic PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){∞  PgHdr1 *p = 0;¨  void *pPg;†Ÿ6  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );ŸG  if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){∂    p = pCache->pFree;Ω    pCache->pFree = p->pNext;±    p->pNext = 0;®  }else{Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTŸM    /* The group mutex must be released before pcache1Alloc() is called. ThisŸM    ** is because it might call sqlite3_release_memory(), which assumes that Ÿ!    ** this mutex is not held. */Ÿ'    assert( pcache1.separateCache==0 );Ÿ+    assert( pCache->pGroup==&pcache1.grp );Ÿ&    pcache1LeaveMutex(pCache->pGroup);¶#endifŸ5    if( benignMalloc ){ sqlite3BeginBenignMalloc(); }Ÿ$#ifdef SQLITE_PCACHE_SEPARATE_HEADERŸ'    pPg = pcache1Alloc(pCache->szPage);Ÿ8    p = sqlite3Malloc(sizeof(PgHdr1) + pCache->szExtra);µ    if( !pPg || !p ){∑      pcache1Free(pPg);∂      sqlite3_free(p);Æ      pPg = 0;•    }•#elseŸ(    pPg = pcache1Alloc(pCache->szAlloc);Ÿ/    p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];¶#endifŸ3    if( benignMalloc ){ sqlite3EndBenignMalloc(); }Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTŸ&    pcache1EnterMutex(pCache->pGroup);¶#endif∫    if( pPg==0 ) return 0;∑    p->page.pBuf = pPg;ª    p->page.pExtra = &p[1];∑    p->isBulkLocal = 0;¥    p->isAnchor = 0;£  }ª  (*pCache->pnPurgeable)++;´  return p;°}†¢/*Ÿ6** Free a page object allocated by pcache1AllocPage().¢*/Ÿ'static void pcache1FreePage(PgHdr1 *p){≤  PCache1 *pCache;±  assert( p!=0 );µ  pCache = p->pCache;Ÿ9  assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );∑  if( p->isBulkLocal ){Ω    p->pNext = pCache->pFree;∂    pCache->pFree = p;®  }else{æ    pcache1Free(p->page.pBuf);Ÿ$#ifdef SQLITE_PCACHE_SEPARATE_HEADER¥    sqlite3_free(p);¶#endif£  }ª  (*pCache->pnPurgeable)--;°}†¢/*ŸL** Malloc function used by SQLite to obtain space from the buffer configuredŸJ** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such bufferŸ7** exists, this function falls back to sqlite3Malloc().¢*/Ÿ/SQLITE_PRIVATE void *sqlite3PageMalloc(int sz){∫  return pcache1Alloc(sz);°}†¢/*Ÿ>** Free an allocated buffer obtained from sqlite3PageMalloc().¢*/Ÿ-SQLITE_PRIVATE void sqlite3PageFree(void *p){±  pcache1Free(p);°}††¢/*ŸC** Return true if it desirable to avoid allocating a new page cache©** entry.¢**Ÿ?** If memory was allocated specifically to the page cache usingŸB** SQLITE_CONFIG_PAGECACHE but that memory has all been used, thenŸE** it is desirable to avoid allocating a new page cache entry becauseŸB** presumably SQLITE_CONFIG_PAGECACHE was suppose to be sufficientŸ?** for all page cache needs and we should not need to spill theº** allocation onto the heap.¢**ŸA** Or, the heap is used for all page cache memory but the heap isŸ=** under memory pressure, then again it is desirable to avoidŸ@** allocating a new page cache entry in order to avoid stressingπ** the heap even further.¢*/Ÿ7static int pcache1UnderMemoryPressure(PCache1 *pCache){ŸJ  if( pcache1.nSlot && (pCache->szPage+pCache->szExtra)<=pcache1.szSlot ){Ÿ"    return pcache1.bUnderPressure;®  }else{Ÿ#    return sqlite3HeapNearlyFull();£  }°}†ŸP/******************************************************************************/ŸP/******** General Implementation Functions ************************************/†¢/*ŸJ** This function is used to resize the hash table used by the cache passedπ** as the first argument.¢**Ÿ>** The PCache mutex must be held when this function is called.¢*/Ÿ*static void pcache1ResizeHash(PCache1 *p){±  PgHdr1 **apNew;¥  unsigned int nNew;±  unsigned int i;†Ÿ1  assert( sqlite3_mutex_held(p->pGroup->mutex) );†¥  nNew = p->nHash*2;±  if( nNew<256 ){Ø    nNew = 256;£  }†ø  pcache1LeaveMutex(p->pGroup);Ÿ/  if( p->nHash ){ sqlite3BeginBenignMalloc(); }Ÿ>  apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);Ÿ-  if( p->nHash ){ sqlite3EndBenignMalloc(); }ø  pcache1EnterMutex(p->pGroup);Æ  if( apNew ){æ    for(i=0; i<p->nHash; i++){¥      PgHdr1 *pPage;Ÿ#      PgHdr1 *pNext = p->apHash[i];Ÿ"      while( (pPage = pNext)!=0 ){Ÿ,        unsigned int h = pPage->iKey % nNew;Ω        pNext = pPage->pNext;Ÿ         pPage->pNext = apNew[h];π        apNew[h] = pPage;ß      }•    }º    sqlite3_free(p->apHash);∂    p->apHash = apNew;¥    p->nHash = nNew;£  }°}†¢/*ŸF** This function is used internally to remove the page pPage from the ŸH** PGroup LRU list, if is part of it. If pPage is not part of the PGroupŸ+** LRU list, then this function is a no-op.¢**Ÿ>** The PGroup mutex must be held when this function is called.¢*/Ÿ-static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){µ  assert( pPage!=0 );Ÿ$  assert( PAGE_IS_UNPINNED(pPage) );º  assert( pPage->pLruNext );º  assert( pPage->pLruPrev );Ÿ=  assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );Ÿ.  pPage->pLruPrev->pLruNext = pPage->pLruNext;Ÿ.  pPage->pLruNext->pLruPrev = pPage->pLruPrev;∂  pPage->pLruNext = 0;∂  pPage->pLruPrev = 0;ø  assert( pPage->isAnchor==0 );Ÿ3  assert( pPage->pCache->pGroup->lru.isAnchor==1 );ø  pPage->pCache->nRecyclable--;Ø  return pPage;°}††¢/*Ÿ?** Remove the page supplied as an argument from the hash table Ÿ=** (PCache1.apHash structure) that it is currently stored in.Ÿ*** Also free the page if freePage is true.¢**Ÿ>** The PGroup mutex must be held when this function is called.¢*/Ÿ?static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){±  unsigned int h;Ÿ"  PCache1 *pCache = pPage->pCache;Æ  PgHdr1 **pp;†Ÿ6  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );Ÿ"  h = pPage->iKey % pCache->nHash;Ÿ=  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);µ  *pp = (*pp)->pNext;†≤  pCache->nPage--;Ÿ(  if( freeFlag ) pcache1FreePage(pPage);°}†¢/*ŸA** If there are currently more than nMaxPage pages allocated, tryŸ?** to recycle pages to reduce the number allocated to nMaxPage.¢*/Ÿ3static void pcache1EnforceMaxPage(PCache1 *pCache){Ÿ"  PGroup *pGroup = pCache->pGroup;¨  PgHdr1 *p;Ÿ.  assert( sqlite3_mutex_held(pGroup->mutex) );Ÿ,  while( pGroup->nPurgeable>pGroup->nMaxPageŸ.      && (p=pGroup->lru.pLruPrev)->isAnchor==0§  ){Ÿ(    assert( p->pCache->pGroup==pGroup );Ÿ"    assert( PAGE_IS_UNPINNED(p) );∂    pcache1PinPage(p);Ÿ     pcache1RemoveFromHash(p, 1);£  }Ÿ*  if( pCache->nPage==0 && pCache->pBulk ){Ÿ     sqlite3_free(pCache->pBulk);Ÿ&    pCache->pBulk = pCache->pFree = 0;£  }°}†¢/*ŸF** Discard all pages from cache pCache with a page number (key value) ŸD** greater than or equal to iLimit. Any pinned pages that meet this Ÿ3** criteria are unpinned before they are discarded.¢**Ÿ>** The PCache mutex must be held when this function is called.¢*/Ÿ"static void pcache1TruncateUnsafe(Ÿ:  PCache1 *pCache,             /* The cache to truncate */ŸH  unsigned int iLimit          /* Drop pages with this pgno or larger */¢){ŸF  TESTONLY( int nPage = 0; )  /* To assert pCache->nPage is correct */∏  unsigned int h, iStop;Ÿ6  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );Ÿ&  assert( pCache->iMaxKey >= iLimit );æ  assert( pCache->nHash > 0 );Ÿ1  if( pCache->iMaxKey - iLimit < pCache->nHash ){ŸC    /* If we are just shaving the last few pages off the end of theŸG    ** cache, then there is no point in scanning the entire hash table.ŸG    ** Only scan those hash slots that might contain pages that need toµ    ** be removed. */ø    h = iLimit % pCache->nHash;Ÿ,    iStop = pCache->iMaxKey % pCache->nHash;ŸL    TESTONLY( nPage = -10; )  /* Disable the pCache->nPage validity check */®  }else{ŸC    /* This is the general case where many pages are being removed.Ÿ7    ** It is necessary to scan the entire hash table */∏    h = pCache->nHash/2;≤    iStop = h - 1;£  }™  for(;;){∞    PgHdr1 **pp;≤    PgHdr1 *pPage;æ    assert( h<pCache->nHash );Ω    pp = &pCache->apHash[h]; æ    while( (pPage = *pp)!=0 ){Ÿ       if( pPage->iKey>=iLimit ){∏        pCache->nPage--;ª        *pp = pPage->pNext;Ÿ<        if( PAGE_IS_UNPINNED(pPage) ) pcache1PinPage(pPage);ø        pcache1FreePage(pPage);¨      }else{ª        pp = &pPage->pNext;Ÿ+        TESTONLY( if( nPage>=0 ) nPage++; )ß      }•    }π    if( h==iStop ) break;æ    h = (h+1) % pCache->nHash;£  }Ÿ6  assert( nPage<0 || pCache->nPage==(unsigned)nPage );°}†ŸP/******************************************************************************/ŸP/******** sqlite3_pcache Methods **********************************************/†¢/*Ÿ5** Implementation of the sqlite3_pcache.xInit method.¢*/Ÿ&static int pcache1Init(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);æ  assert( pcache1.isInit==0 );Ÿ'  memset(&pcache1, 0, sizeof(pcache1));††§  /*ŸJ  ** The pcache1.separateCache variable is true if each PCache has its ownŸK  ** private PGroup (mode-1).  pcache1.separateCache is false if the singleŸ@  ** PGroup in pcache1.grp is used for all page caches (mode-2).§  **ŸI  **   *  Always use a unified cache (mode-2) if ENABLE_MEMORY_MANAGEMENT§  **ŸG  **   *  Use a unified cache in single-threaded applications that haveŸK  **      configured a start-time buffer for use as page-cache memory usingŸM  **      sqlite3_config(SQLITE_CONFIG_PAGECACHE, pBuf, sz, N) with non-NULL ∏  **      pBuf argument.§  **Ÿ0  **   *  Otherwise use separate caches (mode-1)§  */Ÿ,#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT)º  pcache1.separateCache = 0;∑#elif SQLITE_THREADSAFEŸ6  pcache1.separateCache = sqlite3GlobalConfig.pPage==0Ÿ>                          || sqlite3GlobalConfig.bCoreMutex>0;•#elseŸ7  pcache1.separateCache = sqlite3GlobalConfig.pPage==0;¶#endif†µ#if SQLITE_THREADSAFEŸ'  if( sqlite3GlobalConfig.bCoreMutex ){ŸC    pcache1.grp.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU);Ÿ@    pcache1.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PMEM);£  }¶#endifª  if( pcache1.separateCacheŸ"   && sqlite3GlobalConfig.nPage!=0Ÿ"   && sqlite3GlobalConfig.pPage==0§  ){Ÿ2    pcache1.nInitPage = sqlite3GlobalConfig.nPage;®  }else{∫    pcache1.nInitPage = 0;£  }º  pcache1.grp.mxPinned = 10;µ  pcache1.isInit = 1;≥  return SQLITE_OK;°}†¢/*Ÿ9** Implementation of the sqlite3_pcache.xShutdown method.Ÿ6** Note that the static mutex allocated in xInit does ∏** not need to be freed.¢*/Ÿ+static void pcache1Shutdown(void *NotUsed){º  UNUSED_PARAMETER(NotUsed);æ  assert( pcache1.isInit!=0 );Ÿ'  memset(&pcache1, 0, sizeof(pcache1));°}†π/* forward declaration */Ÿ.static void pcache1Destroy(sqlite3_pcache *p);†¢/*Ÿ7** Implementation of the sqlite3_pcache.xCreate method.¢**∏** Allocate a new cache.¢*/ŸNstatic sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){Ÿ:  PCache1 *pCache;      /* The newly created page cache */ŸI  PGroup *pGroup;       /* The group the new page cache will belong to */ŸP  int sz;               /* Bytes of memory required to allocate the new cache */†ŸE  assert( (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 );∫  assert( szExtra < 300 );†Ÿ>  sz = sizeof(PCache1) + sizeof(PGroup)*pcache1.separateCache;Ÿ,  pCache = (PCache1 *)sqlite3MallocZero(sz);Ø  if( pCache ){Ÿ     if( pcache1.separateCache ){Ÿ#      pGroup = (PGroup*)&pCache[1];º      pGroup->mxPinned = 10;™    }else{º      pGroup = &pcache1.grp;•    }Ÿ"    if( pGroup->lru.isAnchor==0 ){ø      pGroup->lru.isAnchor = 1;ŸA      pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;•    }º    pCache->pGroup = pGroup;º    pCache->szPage = szPage;æ    pCache->szExtra = szExtra;Ÿ@    pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));Ÿ.    pCache->bPurgeable = (bPurgeable ? 1 : 0);æ    pcache1EnterMutex(pGroup);æ    pcache1ResizeHash(pCache);µ    if( bPurgeable ){∏      pCache->nMin = 10;Ÿ'      pGroup->nMinPage += pCache->nMin;ŸB      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;Ÿ0      pCache->pnPurgeable = &pGroup->nPurgeable;™    }else{Ÿ+      static unsigned int dummyCurrentPage;Ÿ.      pCache->pnPurgeable = &dummyCurrentPage;•    }æ    pcache1LeaveMutex(pGroup);ª    if( pCache->nHash==0 ){Ÿ.      pcache1Destroy((sqlite3_pcache*)pCache);±      pCache = 0;•    }£  }Ÿ"  return (sqlite3_pcache *)pCache;°}†¢/*Ÿ;** Implementation of the sqlite3_pcache.xCachesize method. ¢**Ÿ.** Configure the cache_size limit for a cache.¢*/Ÿ:static void pcache1Cachesize(sqlite3_pcache *p, int nMax){Ÿ!  PCache1 *pCache = (PCache1 *)p;ª  if( pCache->bPurgeable ){Ÿ$    PGroup *pGroup = pCache->pGroup;æ    pcache1EnterMutex(pGroup);Ÿ.    pGroup->nMaxPage += (nMax - pCache->nMax);Ÿ@    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;∏    pCache->nMax = nMax;Ÿ'    pCache->n90pct = pCache->nMax*9/10;Ÿ"    pcache1EnforceMaxPage(pCache);æ    pcache1LeaveMutex(pGroup);£  }°}†¢/*Ÿ8** Implementation of the sqlite3_pcache.xShrink method. ¢**Ÿ&** Free up as much memory as possible.¢*/Ÿ-static void pcache1Shrink(sqlite3_pcache *p){Ÿ   PCache1 *pCache = (PCache1*)p;ª  if( pCache->bPurgeable ){Ÿ$    PGroup *pGroup = pCache->pGroup;µ    int savedMaxPage;æ    pcache1EnterMutex(pGroup);Ÿ$    savedMaxPage = pGroup->nMaxPage;π    pGroup->nMaxPage = 0;Ÿ"    pcache1EnforceMaxPage(pCache);Ÿ$    pGroup->nMaxPage = savedMaxPage;æ    pcache1LeaveMutex(pGroup);£  }°}†¢/*Ÿ;** Implementation of the sqlite3_pcache.xPagecount method. ¢*/Ÿ/static int pcache1Pagecount(sqlite3_pcache *p){®  int n;Ÿ   PCache1 *pCache = (PCache1*)p;Ÿ$  pcache1EnterMutex(pCache->pGroup);¥  n = pCache->nPage;Ÿ$  pcache1LeaveMutex(pCache->pGroup);´  return n;°}††¢/*ŸH** Implement steps 3, 4, and 5 of the pcache1Fetch() algorithm describedŸ1** in the header of the pcache1Fetch() procedure.¢**ŸG** This steps are broken out into a separate procedure because they areŸH** usually not needed, and by avoiding the stack initialization requiredŸE** for these steps, the main pcache1Fetch() procedure can run faster.¢*/Ÿ2static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(≥  PCache1 *pCache, µ  unsigned int iKey, ∞  int createFlag¢){∑  unsigned int nPinned;Ÿ"  PGroup *pGroup = pCache->pGroup;¥  PgHdr1 *pPage = 0;†ŸE  /* Step 3: Abort if createFlag is 1 but the cache is nearly full */Ÿ1  assert( pCache->nPage >= pCache->nRecyclable );Ÿ0  nPinned = pCache->nPage - pCache->nRecyclable;ŸI  assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );Ÿ0  assert( pCache->n90pct == pCache->nMax*9/10 );∏  if( createFlag==1 && (Ÿ!        nPinned>=pGroup->mxPinnedø     || nPinned>=pCache->n90pctŸK     || (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)•  )){≠    return 0;£  }†Ÿ?  if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);Ÿ.  assert( pCache->nHash>0 && pCache->apHash );†Ÿ&  /* Step 4. Try to recycle a page. */∏  if( pCache->bPurgeableŸ%   && !pGroup->lru.pLruPrev->isAnchorŸM   && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))§  ){¥    PCache1 *pOther;Ÿ!    pPage = pGroup->lru.pLruPrev;Ÿ&    assert( PAGE_IS_UNPINNED(pPage) );Ÿ$    pcache1RemoveFromHash(pPage, 0);∫    pcache1PinPage(pPage);ª    pOther = pPage->pCache;Ÿ-    if( pOther->szAlloc != pCache->szAlloc ){Ω      pcache1FreePage(pPage);∞      pPage = 0;™    }else{ŸF      pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);•    }£  }†Ÿ?  /* Step 5. If a usable page buffer has still not been found, Ÿ$  ** attempt to allocate a new one. §  */Ø  if( !pPage ){Ÿ4    pPage = pcache1AllocPage(pCache, createFlag==1);£  }†Æ  if( pPage ){Ÿ*    unsigned int h = iKey % pCache->nHash;¥    pCache->nPage++;∑    pPage->iKey = iKey;Ÿ%    pPage->pNext = pCache->apHash[h];ª    pPage->pCache = pCache;∏    pPage->pLruPrev = 0;∏    pPage->pLruNext = 0;Ÿ%    *(void **)pPage->page.pExtra = 0;æ    pCache->apHash[h] = pPage;ø    if( iKey>pCache->iMaxKey ){Ω      pCache->iMaxKey = iKey;•    }£  }Ø  return pPage;°}†¢/*Ÿ7** Implementation of the sqlite3_pcache.xFetch method. ¢**Ω** Fetch a page by key value.¢**ŸI** Whether or not a new page may be allocated by this function depends onŸG** the value of the createFlag argument.  0 means do not allocate a newŸG** page.  1 means allocate a new page if space is easily available.  2 Ÿ3** means to try really hard to allocate a new page.¢**ŸJ** For a non-purgeable cache (a cache used as the storage for an in-memoryŸJ** database) there is really no difference between createFlag 1 and 2.  SoŸG** the calling function (pcache.c) will never have a createFlag of 1 onπ** a non-purgeable cache.¢**ŸF** There are three different approaches to obtaining space for a page,ŸK** depending on the value of parameter createFlag (which may be 0, 1 or 2).¢**ŸK**   1. Regardless of the value of createFlag, the cache is searched for a ŸD**      copy of the requested page. If one is found, it is returned.¢**ŸJ**   2. If createFlag==0 and the page is not already in the cache, NULL is±**      returned.¢**ŸJ**   3. If createFlag is 1, and the page is not already in the cache, thenŸH**      return NULL (do not allocate a new page) if any of the followingº**      conditions are true:¢**ŸD**       (a) the number of pages pinned by the cache is greater thanΩ**           PCache1.nMax, or¢**ŸD**       (b) the number of pages pinned by the cache is greater thanŸG**           the sum of nMax for all purgeable caches, less the sum of Ÿ4**           nMin for all other purgeable caches, or¢**ŸK**   4. If none of the first three conditions apply and the cache is markedŸ:**      as purgeable, and if one of the following is true:¢**ŸD**       (a) The number of pages allocated for the cache is already Ω**           PCache1.nMax, or¢**ŸF**       (b) The number of pages allocated for all purgeable caches isŸE**           already equal to or greater than the sum of nMax for allæ**           purgeable caches,¢**ŸC**       (c) The system is under memory pressure and wants to avoidŸ6**           unnecessary pages cache entry allocations¢**ŸL**      then attempt to recycle a page from the LRU list. If it is the rightŸH**      size, return the recycled buffer. Otherwise, free the buffer andª**      proceed to step 5. ¢**Ÿ9**   5. Otherwise, allocate and return a new page buffer.¢**ŸF** There are two versions of this routine.  pcache1FetchWithMutex() isŸJ** the general case.  pcache1FetchNoMutex() is a faster implementation forŸK** the common case where pGroup->mutex is NULL.  The pcache1Fetch() wrapperŸ#** invokes the appropriate routine.¢*/Ÿ#static PgHdr1 *pcache1FetchNoMutex(µ  sqlite3_pcache *p, µ  unsigned int iKey, ∞  int createFlag¢){Ÿ!  PCache1 *pCache = (PCache1 *)p;¥  PgHdr1 *pPage = 0;†Ÿ<  /* Step 1: Search the hash table for an existing entry. */Ÿ/  pPage = pCache->apHash[iKey % pCache->nHash];Ÿ>  while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }†ŸE  /* Step 2: If the page was found in the hash table, then return it.ŸF  ** If the page was not in the hash table and createFlag is 0, abort.ŸA  ** Otherwise (page not in hash and createFlag!=0) continue withŸ3  ** subsequent steps to try to create the page. */Æ  if( pPage ){Ÿ"    if( PAGE_IS_UNPINNED(pPage) ){Ÿ#      return pcache1PinPage(pPage);™    }else{≥      return pPage;•    }π  }else if( createFlag ){Ÿ:    /* Steps 3, 4, and 5 implemented by this subroutine */Ÿ8    return pcache1FetchStage2(pCache, iKey, createFlag);®  }else{≠    return 0;£  }°}Ÿ!#if PCACHE1_MIGHT_USE_GROUP_MUTEXŸ%static PgHdr1 *pcache1FetchWithMutex(µ  sqlite3_pcache *p, µ  unsigned int iKey, ∞  int createFlag¢){Ÿ!  PCache1 *pCache = (PCache1 *)p;∞  PgHdr1 *pPage;†Ÿ$  pcache1EnterMutex(pCache->pGroup);Ÿ3  pPage = pcache1FetchNoMutex(p, iKey, createFlag);Ÿ.  assert( pPage==0 || pCache->iMaxKey>=iKey );Ÿ$  pcache1LeaveMutex(pCache->pGroup);Ø  return pPage;°}¶#endifŸ)static sqlite3_pcache_page *pcache1Fetch(µ  sqlite3_pcache *p, µ  unsigned int iKey, ∞  int createFlag¢){Ÿ:#if PCACHE1_MIGHT_USE_GROUP_MUTEX || defined(SQLITE_DEBUG)Ÿ!  PCache1 *pCache = (PCache1 *)p;¶#endif†Ÿ%  assert( offsetof(PgHdr1,page)==0 );Ÿ0  assert( pCache->bPurgeable || createFlag!=1 );Ÿ2  assert( pCache->bPurgeable || pCache->nMin==0 );Ÿ6  assert( pCache->bPurgeable==0 || pCache->nMin==10 );Ÿ2  assert( pCache->nMin==0 || pCache->bPurgeable );º  assert( pCache->nHash>0 );Ÿ!#if PCACHE1_MIGHT_USE_GROUP_MUTEXæ  if( pCache->pGroup->mutex ){ŸL    return (sqlite3_pcache_page*)pcache1FetchWithMutex(p, iKey, createFlag);ß  }else¶#endif£  {ŸJ    return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);£  }°}††¢/*Ÿ6** Implementation of the sqlite3_pcache.xUnpin method.¢**ŸA** Mark a page as unpinned (eligible for asynchronous recycling).¢*/πstatic void pcache1Unpin(µ  sqlite3_pcache *p, º  sqlite3_pcache_page *pPg, ≥  int reuseUnlikely¢){Ÿ!  PCache1 *pCache = (PCache1 *)p;Ÿ   PgHdr1 *pPage = (PgHdr1 *)pPg;Ÿ"  PGroup *pGroup = pCache->pGroup;° Ÿ"  assert( pPage->pCache==pCache );º  pcache1EnterMutex(pGroup);†ŸA  /* It is an error to call this function if the page is already Ÿ!  ** part of the PGroup LRU list.§  */Ÿ5  assert( pPage->pLruPrev==0 && pPage->pLruNext==0 );Ÿ"  assert( PAGE_IS_PINNED(pPage) );†Ÿ=  if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){Ÿ$    pcache1RemoveFromHash(pPage, 1);®  }else{Ÿ.    /* Add the page to the PGroup LRU list. */Ÿ-    PgHdr1 **ppFirst = &pGroup->lru.pLruNext;Ÿ#    pPage->pLruPrev = &pGroup->lru;Ÿ3    (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;µ    *ppFirst = pPage;∫    pCache->nRecyclable++;£  }†Ÿ$  pcache1LeaveMutex(pCache->pGroup);°}†¢/*Ÿ7** Implementation of the sqlite3_pcache.xRekey method. ¢*/πstatic void pcache1Rekey(¥  sqlite3_pcache *p,ª  sqlite3_pcache_page *pPg,¥  unsigned int iOld,≥  unsigned int iNew¢){Ÿ!  PCache1 *pCache = (PCache1 *)p;Ÿ   PgHdr1 *pPage = (PgHdr1 *)pPg;Æ  PgHdr1 **pp;≤  unsigned int h; æ  assert( pPage->iKey==iOld );Ÿ"  assert( pPage->pCache==pCache );†Ÿ$  pcache1EnterMutex(pCache->pGroup);†π  h = iOld%pCache->nHash;∫  pp = &pCache->apHash[h];∏  while( (*pp)!=pPage ){∑    pp = &(*pp)->pNext;£  }µ  *pp = pPage->pNext;†π  h = iNew%pCache->nHash;µ  pPage->iKey = iNew;Ÿ#  pPage->pNext = pCache->apHash[h];º  pCache->apHash[h] = pPage;Ω  if( iNew>pCache->iMaxKey ){ª    pCache->iMaxKey = iNew;£  }†Ÿ$  pcache1LeaveMutex(pCache->pGroup);°}†¢/*Ÿ:** Implementation of the sqlite3_pcache.xTruncate method. ¢**ŸF** Discard all unpinned pages in the cache with a page number equal toŸH** or greater than parameter iLimit. Any pinned pages with a page numberŸ;** equal to or greater than iLimit are implicitly unpinned.¢*/ŸDstatic void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){Ÿ!  PCache1 *pCache = (PCache1 *)p;Ÿ$  pcache1EnterMutex(pCache->pGroup);Ÿ   if( iLimit<=pCache->iMaxKey ){Ÿ*    pcache1TruncateUnsafe(pCache, iLimit);ø    pCache->iMaxKey = iLimit-1;£  }Ÿ$  pcache1LeaveMutex(pCache->pGroup);°}†¢/*Ÿ9** Implementation of the sqlite3_pcache.xDestroy method. ¢**Ÿ3** Destroy a cache allocated using pcache1Create().¢*/Ÿ.static void pcache1Destroy(sqlite3_pcache *p){Ÿ!  PCache1 *pCache = (PCache1 *)p;Ÿ"  PGroup *pGroup = pCache->pGroup;ŸG  assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );º  pcache1EnterMutex(pGroup);Ÿ7  if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);Ÿ-  assert( pGroup->nMaxPage >= pCache->nMax );Ÿ#  pGroup->nMaxPage -= pCache->nMax;Ÿ-  assert( pGroup->nMinPage >= pCache->nMin );Ÿ#  pGroup->nMinPage -= pCache->nMin;Ÿ>  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;Ÿ   pcache1EnforceMaxPage(pCache);º  pcache1LeaveMutex(pGroup);æ  sqlite3_free(pCache->pBulk);ø  sqlite3_free(pCache->apHash);∑  sqlite3_free(pCache);°}†¢/*ŸJ** This function is called during initialization (sqlite3_initialize()) toŸH** install the default pluggable cache module, assuming the user has notŸ#** already provided an alternative.¢*/Ÿ2SQLITE_PRIVATE void sqlite3PCacheSetDefault(void){Ÿ9  static const sqlite3_pcache_methods2 defaultMethods = {Ÿ+    1,                       /* iVersion */Ÿ'    0,                       /* pArg */Ÿ(    pcache1Init,             /* xInit */Ÿ,    pcache1Shutdown,         /* xShutdown */Ÿ*    pcache1Create,           /* xCreate */Ÿ-    pcache1Cachesize,        /* xCachesize */Ÿ-    pcache1Pagecount,        /* xPagecount */Ÿ)    pcache1Fetch,            /* xFetch */Ÿ)    pcache1Unpin,            /* xUnpin */Ÿ)    pcache1Rekey,            /* xRekey */Ÿ,    pcache1Truncate,         /* xTruncate */Ÿ+    pcache1Destroy,          /* xDestroy */Ÿ*    pcache1Shrink            /* xShrink */§  };Ÿ9  sqlite3_config(SQLITE_CONFIG_PCACHE2, &defaultMethods);°}†¢/*ŸL** Return the size of the header on each page of this PCACHE implementation.¢*/ŸSSQLITE_PRIVATE int sqlite3HeaderSizePcache1(void){ return ROUND8(sizeof(PgHdr1)); }†¢/*ŸC** Return the global mutex used by this PCACHE implementation.  TheŸ7** sqlite3_status() routine needs access to this mutex.¢*/Ÿ8SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void){∑  return pcache1.mutex;°}†Ÿ&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT¢/*ŸK** This function is called to free superfluous dynamically allocated memoryŸH** held by the pager system. Memory in use by any SQLite pager allocatedŸ1** by the current thread may be sqlite3_free()ed.¢**ŸE** nReq is the number of bytes of memory required. Once this much hasŸM** been released, the function returns. The return value is the total number ø** of bytes of memory released.¢*/Ÿ8SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){∞  int nFree = 0;Ÿ5  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );Ÿ1  assert( sqlite3_mutex_notheld(pcache1.mutex) );Ÿ%  if( sqlite3GlobalConfig.pPage==0 ){Æ    PgHdr1 *p;Ÿ$    pcache1EnterMutex(&pcache1.grp);Ÿ!    while( (nReq<0 || nFree<nReq)Ÿ*       &&  (p=pcache1.grp.lru.pLruPrev)!=0π       &&  p->isAnchor==0¶    ){Ÿ,      nFree += pcache1MemSize(p->page.pBuf);Ÿ$#ifdef SQLITE_PCACHE_SEPARATE_HEADERŸ!      nFree += sqlite3MemSize(p);¶#endifŸ$      assert( PAGE_IS_UNPINNED(p) );∏      pcache1PinPage(p);Ÿ"      pcache1RemoveFromHash(p, 1);•    }Ÿ$    pcache1LeaveMutex(&pcache1.grp);£  }Ø  return nFree;°}Ÿ,#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */†≤#ifdef SQLITE_TEST¢/*ŸI** This function is used by test procedures to inspect the internal state∑** of the global cache.¢*/Ÿ'SQLITE_PRIVATE void sqlite3PcacheStats(Ÿ>  int *pnCurrent,      /* OUT: Total number of pages cached */Ÿ;  int *pnMax,          /* OUT: Global maximum cache size */ŸJ  int *pnMin,          /* OUT: Sum of PCache1.nMin for purgeable caches */ŸO  int *pnRecyclable    /* OUT: Total number of pages available for recycling */¢){¨  PgHdr1 *p;∂  int nRecyclable = 0;ŸD  for(p=pcache1.grp.lru.pLruNext; p && !p->isAnchor; p=p->pLruNext){Ÿ"    assert( PAGE_IS_UNPINNED(p) );≤    nRecyclable++;£  }Ÿ&  *pnCurrent = pcache1.grp.nPurgeable;Ÿ%  *pnMax = (int)pcache1.grp.nMaxPage;Ÿ%  *pnMin = (int)pcache1.grp.nMinPage;æ  *pnRecyclable = nRecyclable;°}¶#endif†ŸO/************** End of pcache1.c *********************************************/ŸO/************** Begin file rowset.c ******************************************/¢/*≤** 2008 December 3¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**Ÿ7** This module implements an object we call a "RowSet".¢**Ÿ7** The RowSet object is a collection of rowids.  RowidsŸ?** are inserted into the RowSet in an arbitrary order.  InsertsŸ@** can be intermixed with tests to see if a given rowid has beenŸ'** previously inserted into the RowSet.¢**Ÿ@** After all inserts are finished, it is possible to extract theŸ@** elements of the RowSet in sorted order.  Once this extractionŸ8** process has started, no new elements may be inserted.¢**Ÿ4** Hence, the primitive operations for a RowSet are:¢**¨**    CREATE¨**    INSERT™**    TESTÆ**    SMALLEST≠**    DESTROY¢**ŸH** The CREATE and DESTROY primitives are the constructor and destructor,ŸE** obviously.  The INSERT primitive adds a new element to the RowSet.ŸG** TEST checks to see if an element is already in the RowSet.  SMALLESTŸ,** extracts the least value from the RowSet.¢**ŸD** The INSERT primitive might allocate additional memory.  Memory isŸF** allocated in chunks so most INSERTs do no allocation.  There is an ŸC** upper bound on the size of allocated memory.  No memory is freed±** until DESTROY.¢**ŸD** The TEST primitive includes a "batch" number.  The TEST primitiveŸC** will only see elements that were inserted before the last changeŸD** in the batch number.  In other words, if an INSERT occurs betweenŸA** two TESTs where the TESTs have the same batch nubmer, then theŸD** value added by the INSERT will not be visible to the second TEST.ŸG** The initial batch number is zero, so if the very first TEST containsŸ:** a non-zero batch number, it will see all prior INSERTs.¢**ŸE** No INSERTs may occurs after a SMALLEST.  An assertion will fail ifµ** that is attempted.¢**ŸD** The cost of an INSERT is roughly constant.  (Sometimes new memoryŸD** has to be allocated on an INSERT.)  The cost of a TEST with a newŸL** batch number is O(NlogN) where N is the number of elements in the RowSet.ŸG** The cost of a TEST using the same batch number is O(logN).  The costŸE** of the first SMALLEST is O(NlogN).  Second and subsequent SMALLESTŸ>** primitives are constant time.  The cost of DESTROY is O(N).¢**ŸF** TEST and SMALLEST may not be used by the same RowSet.  This used toŸH** be possible, but the feature was not used, so it was removed in order∏** to simplify the code.¢*/º/* #include "sqliteInt.h" */††¢/*Ÿ%** Target size for allocation chunks.¢*/Ÿ##define ROWSET_ALLOCATION_SIZE 1024†¢/*Ÿ5** The number of rowset entries per allocation chunk.¢*/Ÿ!#define ROWSET_ENTRY_PER_CHUNK  \ŸN                       ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))†¢/*ŸA** Each entry in a RowSet is an instance of the following object.¢**ŸL** This same object is reused to store a linked list of trees of RowSetEntryŸE** objects.  In that alternative use, pRight points to the next entryŸ?** in the list, pLeft points to the tree, and v is unused.  TheŸ?** RowSet.pForest value points to the head of this forest list.¢*/Ÿ struct RowSetEntry {            Ÿ@  i64 v;                        /* ROWID value for this entry */ŸL  struct RowSetEntry *pRight;   /* Right subtree (larger entries) or list */ŸD  struct RowSetEntry *pLeft;    /* Left subtree (smaller entries) */¢};†¢/*ŸF** RowSetEntry objects are allocated in large chunks (instances of theŸB** following structure) to reduce memory allocation overhead.  TheŸC** chunks are kept on a linked list so that they can be deallocatedŸ ** when the RowSet is destroyed.¢*/¥struct RowSetChunk {ŸM  struct RowSetChunk *pNextChunk;        /* Next chunk on list of them all */ŸL  struct RowSetEntry aEntry[ROWSET_ENTRY_PER_CHUNK]; /* Allocated entries */¢};†¢/*Ÿ6** A RowSet in an instance of the following structure.¢**Ÿ7** A typedef of this structure if found in sqliteInt.h.¢*/Østruct RowSet {ŸD  struct RowSetChunk *pChunk;    /* List of all chunk allocations */Ÿ>  sqlite3 *db;                   /* The database connection */ŸC  struct RowSetEntry *pEntry;    /* List of entries using pRight */ŸD  struct RowSetEntry *pLast;     /* Last entry on the pEntry list */ŸB  struct RowSetEntry *pFresh;    /* Source of new entry objects */ŸF  struct RowSetEntry *pForest;   /* List of binary trees of entries */ŸB  u16 nFresh;                    /* Number of objects on pFresh */Ÿ4  u16 rsFlags;                   /* Various flags */Ÿ;  int iBatch;                    /* Current insert batch */¢};†¢/*Ÿ$** Allowed values for RowSet.rsFlags¢*/ŸC#define ROWSET_SORTED  0x01   /* True if RowSet.pEntry is sorted */ŸO#define ROWSET_NEXT    0x02   /* True if sqlite3RowSetNext() has been called */†¢/*Ÿ<** Turn bulk memory into a RowSet object.  N bytes of memoryŸG** are available at pSpace.  The db pointer is used as a memory contextŸ5** for any subsequent allocations that need to occur.Ÿ-** Return a pointer to the new RowSet object.¢**ŸE** It must be the case that N is sufficient to make a Rowset.  If notΩ** an assertion fault occurs.£** ŸA** If N is larger than the minimum, use the surplus as an initialŸ0** allocation of entries available to be filled.¢*/ŸTSQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3 *db, void *pSpace, unsigned int N){¨  RowSet *p;Ÿ$  assert( N >= ROUND8(sizeof(*p)) );≠  p = pSpace;∞  p->pChunk = 0;≠  p->db = db;∞  p->pEntry = 0;Ø  p->pLast = 0;±  p->pForest = 0;ŸC  p->pFresh = (struct RowSetEntry*)(ROUND8(sizeof(*p)) + (char*)p);ŸI  p->nFresh = (u16)((N - ROUND8(sizeof(*p)))/sizeof(struct RowSetEntry));Ω  p->rsFlags = ROWSET_SORTED;∞  p->iBatch = 0;´  return p;°}†¢/*ŸC** Deallocate all chunks from a RowSet.  This frees all memory thatŸ?** the RowSet has allocated over its lifetime.  This routine isŸ!** the destructor for the RowSet.¢*/Ÿ2SQLITE_PRIVATE void sqlite3RowSetClear(RowSet *p){Ÿ*  struct RowSetChunk *pChunk, *pNextChunk;Ÿ5  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){Ÿ$    pNextChunk = pChunk->pNextChunk;Ÿ!    sqlite3DbFree(p->db, pChunk);£  }∞  p->pChunk = 0;∞  p->nFresh = 0;∞  p->pEntry = 0;Ø  p->pLast = 0;±  p->pForest = 0;Ω  p->rsFlags = ROWSET_SORTED;°}†¢/*Ÿ@** Allocate a new RowSetEntry object that is associated with theŸJ** given RowSet.  Return a pointer to the new and completely uninitialized¨** objected.¢**ŸH** In an OOM situation, the RowSet.db->mallocFailed flag is set and this∏** routine returns NULL.¢*/Ÿ7static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){±  assert( p!=0 );Ÿ0  if( p->nFresh==0 ){  /*OPTIMIZATION-IF-FALSE*/ŸL    /* We could allocate a fresh RowSetEntry each time one is needed, but itŸF    ** is more efficient to pull a preallocated entry from the pool */Ω    struct RowSetChunk *pNew;Ÿ6    pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));≤    if( pNew==0 ){Ø      return 0;•    }Ÿ!    pNew->pNextChunk = p->pChunk;µ    p->pChunk = pNew;Ω    p->pFresh = pNew->aEntry;Ÿ'    p->nFresh = ROWSET_ENTRY_PER_CHUNK;£  }Æ  p->nFresh--;µ  return p->pFresh++;°}†¢/*Ÿ$** Insert a new value into a RowSet.¢**Ÿ?** The mallocFailed flag of the database connection is set if aª** memory allocation fails.¢*/Ÿ>SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet *p, i64 rowid){Ÿ2  struct RowSetEntry *pEntry;  /* The new entry */Ÿ9  struct RowSetEntry *pLast;   /* The last prior entry */†Ÿ>  /* This routine is never called after sqlite3RowSetNext() */Ÿ2  assert( p!=0 && (p->rsFlags & ROWSET_NEXT)==0 );†ø  pEntry = rowSetEntryAlloc(p);π  if( pEntry==0 ) return;¥  pEntry->v = rowid;µ  pEntry->pRight = 0;≥  pLast = p->pLast;Æ  if( pLast ){Ÿ5    if( rowid<=pLast->v ){  /*OPTIMIZATION-IF-FALSE*/ŸF      /* Avoid unnecessary sorts by preserving the ROWSET_SORTED flags∫      ** where possible */Ÿ#      p->rsFlags &= ~ROWSET_SORTED;•    }ª    pLast->pRight = pEntry;®  }else{∑    p->pEntry = pEntry;£  }¥  p->pLast = pEntry;°}†¢/*Ÿ>** Merge two lists of RowSetEntry objects.  Remove duplicates.¢**Ÿ=** The input lists are connected via pRight pointers and are Ÿ.** assumed to each already be in sorted order.¢*/Ÿ,static struct RowSetEntry *rowSetEntryMerge(ŸA  struct RowSetEntry *pA,    /* First sorted list to be merged */ŸB  struct RowSetEntry *pB     /* Second sorted list to be merged */¢){∫  struct RowSetEntry head;º  struct RowSetEntry *pTail;†∞  pTail = &head;ª  assert( pA!=0 && pB!=0 );™  for(;;){Ÿ4    assert( pA->pRight==0 || pA->v<=pA->pRight->v );Ÿ4    assert( pB->pRight==0 || pB->v<=pB->pRight->v );∑    if( pA->v<=pB->v ){Ÿ3      if( pA->v<pB->v ) pTail = pTail->pRight = pA;∂      pA = pA->pRight;≤      if( pA==0 ){ª        pTail->pRight = pB;Æ        break;ß      }™    }else{Ÿ!      pTail = pTail->pRight = pB;∂      pB = pB->pRight;≤      if( pB==0 ){ª        pTail->pRight = pA;Æ        break;ß      }•    }£  }µ  return head.pRight;°}†¢/*ŸE** Sort all elements on the list of RowSetEntry objects into order of∞** increasing v.£*/ ŸDstatic struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){±  unsigned int i;Ÿ*  struct RowSetEntry *pNext, *aBucket[40];†Ÿ&  memset(aBucket, 0, sizeof(aBucket));Ø  while( pIn ){∏    pNext = pIn->pRight;¥    pIn->pRight = 0;æ    for(i=0; aBucket[i]; i++){Ÿ.      pIn = rowSetEntryMerge(aBucket[i], pIn);µ      aBucket[i] = 0;•    }µ    aBucket[i] = pIn;∞    pIn = pNext;£  }≥  pIn = aBucket[0];Ÿ6  for(i=1; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){Ÿ!    if( aBucket[i]==0 ) continue;Ÿ?    pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];£  }≠  return pIn;°}††¢/*ŸH** The input, pIn, is a binary tree (or subtree) of RowSetEntry objects.ŸH** Convert this tree into a linked list connected by the pRight pointersŸF** and return pointers to the first and last elements of the new list.¢*/Ωstatic void rowSetTreeToList(Ÿ?  struct RowSetEntry *pIn,         /* Root of the input tree */ŸK  struct RowSetEntry **ppFirst,    /* Write head of the output list here */ŸK  struct RowSetEntry **ppLast      /* Write tail of the output list here */¢){≥  assert( pIn!=0 );≥  if( pIn->pLeft ){∫    struct RowSetEntry *p;Ÿ.    rowSetTreeToList(pIn->pLeft, ppFirst, &p);¥    p->pRight = pIn;®  }else{≥    *ppFirst = pIn;£  }¥  if( pIn->pRight ){Ÿ8    rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);®  }else{≤    *ppLast = pIn;£  }Ÿ!  assert( (*ppLast)->pRight==0 );°}††¢/*ŸH** Convert a sorted list of elements (connected by pRight) into a binaryŸL** tree with depth of iDepth.  A depth of 1 means the tree contains a singleŸG** node taken from the head of *ppList.  A depth of 2 means a tree withæ** three nodes.  And so forth.¢**ŸE** Use as many entries from the input list as required and update theŸE** *ppList to point to the unused elements of the list.  If the inputŸD** list contains too few elements, then construct an incomplete treeŸ!** and leave *ppList set to NULL.¢**Ÿ?** Return a pointer to the root of the constructed binary tree.¢*/Ÿ+static struct RowSetEntry *rowSetNDeepTree(æ  struct RowSetEntry **ppList,¨  int iDepth¢){Ÿ;  struct RowSetEntry *p;         /* Root of the new tree */Ÿ3  struct RowSetEntry *pLeft;     /* Left subtree */Ÿ,  if( *ppList==0 ){ /*OPTIMIZATION-IF-TRUE*/ŸG    /* Prevent unnecessary deep recursion when we run out of entries */Æ    return 0; £  }Ÿ,  if( iDepth>1 ){   /*OPTIMIZATION-IF-TRUE*/ŸJ    /* This branch causes a *balanced* tree to be generated.  A valid treeŸE    ** is still generated without this branch, but the tree is wildlyŸ%    ** unbalanced and inefficient. */Ÿ.    pLeft = rowSetNDeepTree(ppList, iDepth-1);∞    p = *ppList;Ÿ-    if( p==0 ){     /*OPTIMIZATION-IF-FALSE*/ŸA      /* It is safe to always return here, but the resulting treeø      ** would be unbalanced */≥      return pLeft;•    }µ    p->pLeft = pLeft;∏    *ppList = p->pRight;Ÿ2    p->pRight = rowSetNDeepTree(ppList, iDepth-1);®  }else{∞    p = *ppList;∏    *ppList = p->pRight;Ω    p->pLeft = p->pRight = 0;£  }´  return p;°}†¢/*ŸF** Convert a sorted list of elements into a binary tree. Make the treeŸA** as deep as it needs to be in order to contain the entire list.¢*/ŸGstatic struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){Ÿ6  int iDepth;           /* Depth of the tree so far */Ÿ6  struct RowSetEntry *p;       /* Current tree root */Ÿ1  struct RowSetEntry *pLeft;   /* Left subtree */†µ  assert( pList!=0 );¨  p = pList;¥  pList = p->pRight;ª  p->pLeft = p->pRight = 0;Ÿ!  for(iDepth=1; pList; iDepth++){Æ    pLeft = p;Æ    p = pList;∂    pList = p->pRight;µ    p->pLeft = pLeft;Ÿ0    p->pRight = rowSetNDeepTree(&pList, iDepth);£  }´  return p;°}†¢/*Ÿ0** Extract the smallest element from the RowSet.Ÿ@** Write the element into *pRowid.  Return 1 on success.  ReturnŸ$** 0 if the RowSet is already empty.¢**Ÿ@** After this routine has been called, the sqlite3RowSetInsert()Ÿ#** routine may not be called again.¢**Ÿ?** This routine may not be called after sqlite3RowSetTest() hasŸ@** been used.  Older versions of RowSet allowed that, but as theŸ@** capability was not used by the code generator, it was removed¥** for code economy.¢*/Ÿ=SQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid){±  assert( p!=0 );ŸI  assert( p->pForest==0 );  /* Cannot be used with sqlite3RowSetText() */†Ÿ@  /* Merge the forest into a single sorted list on first call */ŸA  if( (p->rsFlags & ROWSET_NEXT)==0 ){  /*OPTIMIZATION-IF-FALSE*/ŸE    if( (p->rsFlags & ROWSET_SORTED)==0 ){  /*OPTIMIZATION-IF-FALSE*/Ÿ-      p->pEntry = rowSetEntrySort(p->pEntry);•    }Ÿ,    p->rsFlags |= ROWSET_SORTED|ROWSET_NEXT;£  }†Ÿ)  /* Return the next entry on the list */≤  if( p->pEntry ){ª    *pRowid = p->pEntry->v;Ÿ"    p->pEntry = p->pEntry->pRight;Ÿ0    if( p->pEntry==0 ){ /*OPTIMIZATION-IF-TRUE*/ŸN      /* Free memory immediately, rather than waiting on sqlite3_finalize() */º      sqlite3RowSetClear(p);•    }≠    return 1;®  }else{≠    return 0;£  }°}†¢/*ŸA** Check to see if element iRowid was inserted into the rowset asŸ<** part of any insert batch prior to iBatch.  Return 1 or 0.¢**ŸF** If this is the first test of a new batch and if there exist entriesŸA** on pRowSet->pEntry, then sort those entries into the forest atŸ/** pRowSet->pForest so that they can be tested.¢*/ŸXSQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){Ÿ   struct RowSetEntry *p, *pTree;†Ÿ>  /* This routine is never called after sqlite3RowSetNext() */Ÿ>  assert( pRowSet!=0 && (pRowSet->rsFlags & ROWSET_NEXT)==0 );†ŸC  /* Sort entries into the forest on the first test of a new batch.ŸJ  ** To save unnecessary work, only do this when the batch number changes.§  */Ÿ;  if( iBatch!=pRowSet->iBatch ){  /*OPTIMIZATION-IF-FALSE*/∏    p = pRowSet->pEntry;¨    if( p ){Ÿ:      struct RowSetEntry **ppPrevTree = &pRowSet->pForest;ŸL      if( (pRowSet->rsFlags & ROWSET_SORTED)==0 ){ /*OPTIMIZATION-IF-FALSE*/ŸC        /* Only sort the current set of entiries if they need it */ø        p = rowSetEntrySort(p);ß      }Ÿ@      for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){Ÿ$        ppPrevTree = &pTree->pRight;æ        if( pTree->pLeft==0 ){Ÿ-          pTree->pLeft = rowSetListToTree(p);∞          break;Æ        }else{Ÿ+          struct RowSetEntry *pAux, *pTail;Ÿ8          rowSetTreeToList(pTree->pLeft, &pAux, &pTail);ª          pTree->pLeft = 0;Ÿ(          p = rowSetEntryMerge(pAux, p);©        }ß      }µ      if( pTree==0 ){Ÿ8        *ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);¥        if( pTree ){∑          pTree->v = 0;º          pTree->pRight = 0;Ÿ-          pTree->pLeft = rowSetListToTree(p);©        }ß      }∫      pRowSet->pEntry = 0;π      pRowSet->pLast = 0;Ÿ(      pRowSet->rsFlags |= ROWSET_SORTED;•    }Ω    pRowSet->iBatch = iBatch;£  }†ŸD  /* Test to see if the iRowid value appears anywhere in the forest.Ÿ&  ** Return 1 if it does and 0 if not.§  */Ÿ<  for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){µ    p = pTree->pLeft;Ø    while( p ){∏      if( p->v<iRowid ){∂        p = p->pRight;æ      }else if( p->v>iRowid ){µ        p = p->pLeft;¨      }else{±        return 1;ß      }•    }£  }´  return 0;°}†ŸO/************** End of rowset.c **********************************************/ŸO/************** Begin file pager.c *******************************************/¢/*¥** 2001 September 15¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸE** This is the implementation of the page cache subsystem or "pager".£** ŸC** The pager is used to access a database disk file.  It implementsŸD** atomic commit and rollback through the use of a journal file thatŸF** is separate from the database file.  The pager also implements fileŸB** locking to prevent two processes from writing the same databaseŸF** file simultaneously, or one process from reading the database while∂** another is writing.¢*/∫#ifndef SQLITE_OMIT_DISKIOº/* #include "sqliteInt.h" */ŸO/************** Include wal.h in the middle of pager.c ***********************/ŸO/************** Begin file wal.h *********************************************/¢/*≤** 2010 February 1¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************ŸE** This header file defines the interface to the write-ahead logging ŸJ** system. Refer to the comments below and the header comment attached to ŸD** the implementation of each function in log.c for further details.¢*/†¥#ifndef SQLITE_WAL_H¥#define SQLITE_WAL_H†º/* #include "sqliteInt.h" */†ŸF/* Macros for extracting appropriate sync flags for either transactionŸJ** commits (WAL_SYNC_FLAGS(X)) or for checkpoint ops (CKPT_SYNC_FLAGS(X)):¢*/Ÿ&#define WAL_SYNC_FLAGS(X)   ((X)&0x03)Ÿ+#define CKPT_SYNC_FLAGS(X)  (((X)>>2)&0x03)†∂#ifdef SQLITE_OMIT_WALŸ2# define sqlite3WalOpen(x,y,z)                   0Ω# define sqlite3WalLimit(x,y)Ÿ2# define sqlite3WalClose(v,w,x,y,z)              0Ÿ2# define sqlite3WalBeginReadTransaction(y,z)     0Ÿ(# define sqlite3WalEndReadTransaction(z)Ÿ2# define sqlite3WalDbsize(y)                     0Ÿ2# define sqlite3WalBeginWriteTransaction(y)      0Ÿ2# define sqlite3WalEndWriteTransaction(x)        0Ÿ2# define sqlite3WalUndo(x,y,z)                   0Ÿ!# define sqlite3WalSavepoint(y,z)Ÿ2# define sqlite3WalSavepointUndo(y,z)            0Ÿ2# define sqlite3WalFrames(u,v,w,x,y,z)           0Ÿ4# define sqlite3WalCheckpoint(q,r,s,t,u,v,w,x,y,z) 0Ÿ2# define sqlite3WalCallback(z)                   0Ÿ2# define sqlite3WalExclusiveMode(y,z)            0Ÿ2# define sqlite3WalHeapMemory(z)                 0Ÿ2# define sqlite3WalFramesize(z)                  0Ÿ2# define sqlite3WalFindFrame(x,y,z)              0Ÿ2# define sqlite3WalFile(x)                       0•#else†Ω#define WAL_SAVEPOINT_NDATA 4†Ÿ//* Connection to a write-ahead log (WAL) file. Ÿ4** There is one object of this type for each pager. ¢*/∑typedef struct Wal Wal;†Ÿ7/* Open and close a connection to a write-ahead log. */Ÿ^SQLITE_PRIVATE int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *, int, i64, Wal**);ŸSSQLITE_PRIVATE int sqlite3WalClose(Wal *pWal, sqlite3*, int sync_flags, int, u8 *);†Ÿ*/* Set the limiting size of a WAL file. */Ÿ/SQLITE_PRIVATE void sqlite3WalLimit(Wal*, i64);†ŸD/* Used by readers to open (lock) and close (unlock) a snapshot.  A ŸH** snapshot is like a read-transaction.  It is the state of the databaseŸF** at an instant in time.  sqlite3WalOpenSnapshot gets a read lock andŸE** preserves the current state even if the other threads or processesŸH** write to or checkpoint the WAL.  sqlite3WalCloseSnapshot() closes theŸ%** transaction and releases the lock.¢*/ŸDSQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *);Ÿ<SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal);†Ÿ=/* Read a page from the write-ahead log, if it is present. */Ÿ;SQLITE_PRIVATE int sqlite3WalFindFrame(Wal *, Pgno, u32 *);Ÿ>SQLITE_PRIVATE int sqlite3WalReadFrame(Wal *, u32, int, u8 *);†Ÿ?/* If the WAL is not empty, return the size of the database. */Ÿ0SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal);†Ÿ(/* Obtain or release the WRITER lock. */Ÿ>SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal);Ÿ<SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal);†Ÿ</* Undo any frames written (but not committed) to the log */ŸYSQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx);†ŸA/* Return an integer that records the current (uncommitted) writeπ** position in the WAL */ŸBSQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData);†Ÿ@/* Move the write position of the WAL back to iFrame.  Called inŸ(** response to a ROLLBACK TO command. */ŸESQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData);†Ÿ)/* Write a frame or frames to the log. */ŸMSQLITE_PRIVATE int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int);†Ÿ3/* Copy pages from the log to the database file */ Ÿ(SQLITE_PRIVATE int sqlite3WalCheckpoint(ŸB  Wal *pWal,                      /* Write-ahead log connection */ŸJ  sqlite3 *db,                    /* Check this handle's interrupt flag */ŸH  int eMode,                      /* One of PASSIVE, FULL and RESTART */ŸB  int (*xBusy)(void*),            /* Function to call when busy */ŸI  void *pBusyArg,                 /* Context argument for xBusyHandler */ŸI  int sync_flags,                 /* Flags to sync db file with (or 0) */Ÿ;  int nBuf,                       /* Size of buffer nBuf */Ÿ?  u8 *zBuf,                       /* Temporary buffer to use */ŸD  int *pnLog,                     /* OUT: Number of frames in WAL */ŸO  int *pnCkpt                     /* OUT: Number of backfilled frames in WAL */¢);†Ÿ?/* Return the value to pass to a sqlite3_wal_hook callback, theŸD** number of frames in the WAL at the point of the last commit sinceŸF** sqlite3WalCallback() was called.  If no commits have occurred sinceŸ ** the last call, then return 0.¢*/Ÿ1SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal);†ŸL/* Tell the wal layer that an EXCLUSIVE lock has been obtained (or released)Ÿ+** by the pager layer on the database file.¢*/Ÿ>SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op);†ŸF/* Return true if the argument is non-NULL and the WAL module is usingŸK** heap-memory for the wal-index. Otherwise, if the argument is NULL or theŸ4** WAL module is using shared-memory, return false. ¢*/Ÿ3SQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal);†Ω#ifdef SQLITE_ENABLE_SNAPSHOTŸSSQLITE_PRIVATE int sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot);ŸSSQLITE_PRIVATE void sqlite3WalSnapshotOpen(Wal *pWal, sqlite3_snapshot *pSnapshot);Ÿ8SQLITE_PRIVATE int sqlite3WalSnapshotRecover(Wal *pWal);¶#endif†ª#ifdef SQLITE_ENABLE_ZIPVFSŸF/* If the WAL file is not empty, return the number of bytes of contentŸI** stored in each frame (i.e. the db page-size when the WAL was created).¢*/Ÿ2SQLITE_PRIVATE int sqlite3WalFramesize(Wal *pWal);¶#endif†Ÿ5/* Return the sqlite3_file object for the WAL file */Ÿ7SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal);†Ÿ##endif /* ifndef SQLITE_OMIT_WAL */π#endif /* SQLITE_WAL_H */†ŸO/************** End of wal.h *************************************************/ŸO/************** Continuing where we left off in pager.c **********************/††ŸN/******************* NOTES ON THE DESIGN OF THE PAGER ************************¢**ŸJ** This comment block describes invariants that hold when using a rollbackŸ@** journal.  These invariants do not apply for journal_mode=WAL,Ÿ,** journal_mode=MEMORY, or journal_mode=OFF.¢**ŸB** Within this comment block, a page is deemed to have been syncedŸF** automatically as soon as it is written when PRAGMA synchronous=OFF.ŸF** Otherwise, the page is not synced until the xSync method of the VFSŸ:** is called successfully on the file containing the page.¢**ŸL** Definition:  A page of the database file is said to be "overwriteable" ifŸ8** one or more of the following are true about the page:£** ŸJ**     (a)  The original content of the page as it was at the beginning ofŸJ**          the transaction has been written into the rollback journal and≥**          synced.£** ŸN**     (b)  The page was a freelist leaf page at the start of the transaction.£** ŸL**     (c)  The page number is greater than the largest page that existed inŸ>**          the database file at the start of the transaction.£** ŸI** (1) A page of the database file is never overwritten unless one of the∫**     following are true:£** ŸM**     (a) The page and all other pages on the same sector are overwriteable.£** ŸH**     (b) The atomic page write optimization is enabled, and the entireŸH**         transaction other than the update of the transaction sequenceŸ3**         number consists of a single page change.£** ŸN** (2) The content of a page written into the rollback journal exactly matchesŸM**     both the content in the database when the rollback journal was writtenŸF**     and the content in the database at the beginning of the current≥**     transaction.£** ŸK** (3) Writes to the database file are an integer multiple of the page sizeŸ4**     in length and are aligned on a page boundary.£** ŸM** (4) Reads from the database file are either aligned on a page boundary andŸK**     an integer multiple of the page size in length or are taken from theŸ,**     first 100 bytes of the database file.£** ŸO** (5) All writes to the database file are synced prior to the rollback journalŸ+**     being deleted, truncated, or zeroed.£** ŸM** (6) If a master journal file is used, then all writes to the database fileŸ<**     are synced prior to the master journal being deleted.£** ŸI** Definition: Two databases (or the same database at two points it time)ŸH** are said to be "logically equivalent" if they give the same answer toŸ@** all queries.  Note in particular the content of freelist leafŸM** pages can be changed arbitrarily without affecting the logical equivalence≥** of the database.£** ŸM** (7) At any time, if any subset, including the empty set and the total set,ŸI**     of the unsynced changes to a rollback journal are removed and the ŸL**     journal is rolled back, the resulting database file will be logicallyŸK**     equivalent to the database file at the beginning of the transaction.£** ŸI** (8) When a transaction is rolled back, the xTruncate method of the VFSŸH**     is called to restore the database file to the same size it was atŸG**     the beginning of the transaction.  (In some VFSes, the xTruncateŸK**     method is a no-op, but that does not change the fact the SQLite will≤**     invoke it.)£** ŸL** (9) Whenever the database file is modified, at least one bit in the rangeŸO**     of bytes from 24 through 39 inclusive will be changed prior to releasingŸG**     the EXCLUSIVE lock, thus signaling other connections on the sameŸ&**     database to flush their caches.¢**ŸK** (10) The pattern of bits in bytes 24 through 39 shall not repeat in lessŸ&**      than one billion transactions.¢**ŸM** (11) A database file is well-formed at the beginning and at the conclusionΩ**      of every transaction.¢**ŸF** (12) An EXCLUSIVE lock is held on the database file when writing to∫**      the database file.¢**ŸD** (13) A SHARED lock is held on the database file while reading anyŸ)**      content out of the database file.¢**ŸO******************************************************************************/†¢/*Ÿ3** Macros for troubleshooting.  Normally turned off¢*/•#if 0Ÿ6int sqlite3PagerTrace=1;  /* True to enable tracing */Ÿ!#define sqlite3DebugPrintf printfŸJ#define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }•#elseµ#define PAGERTRACE(X)¶#endif†¢/*ŸI** The following two macros are used within the PAGERTRACE() macros aboveŸ"** to print out file-descriptors. ¢**ŸC** PAGERID() takes a pointer to a Pager struct as its argument. TheŸO** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file∫** struct as its argument.¢*/Ÿ-#define PAGERID(p) (SQLITE_PTR_TO_INT(p->fd))Ÿ0#define FILEHANDLEID(fd) (SQLITE_PTR_TO_INT(fd))†¢/*ŸE** The Pager.eState variable stores the current 'state' of a pager. AŸE** pager may be in any one of the seven states shown in the following±** state diagram.¢**Ÿ2**                            OPEN <------+------+Ÿ2**                              |         |      |Ÿ2**                              V         |      |Ÿ2**               +---------> READER-------+      |Ÿ2**               |              |                |Ÿ2**               |              V                |Ÿ4**               |<-------WRITER_LOCKED------> ERRORŸ4**               |              |                ^  Ÿ2**               |              V                |Ÿ2**               |<------WRITER_CACHEMOD-------->|Ÿ2**               |              |                |Ÿ2**               |              V                |Ÿ2**               |<-------WRITER_DBMOD---------->|Ÿ2**               |              |                |Ÿ2**               |              V                |Ÿ2**               +<------WRITER_FINISHED-------->+¢**¢**ŸE** List of state transitions and the C [function] that performs each:£** ŸF**   OPEN              -> READER              [sqlite3PagerSharedLock]Ÿ<**   READER            -> OPEN                [pager_unlock]¢**ŸA**   READER            -> WRITER_LOCKED       [sqlite3PagerBegin]ŸB**   WRITER_LOCKED     -> WRITER_CACHEMOD     [pager_open_journal]Ÿ;**   WRITER_CACHEMOD   -> WRITER_DBMOD        [syncJournal]ŸJ**   WRITER_DBMOD      -> WRITER_FINISHED     [sqlite3PagerCommitPhaseOne]ŸE**   WRITER_***        -> READER              [pager_end_transaction]¢**Ÿ;**   WRITER_***        -> ERROR               [pager_error]Ÿ<**   ERROR             -> OPEN                [pager_unlock]£** ¢**©**  OPEN:¢**ŸF**    The pager starts up in this state. Nothing is guaranteed in thisŸH**    state - the file may or may not be locked and the database size isŸ7**    unknown. The database may not be read or written.¢**Ÿ/**    * No read or write transaction is active.ŸF**    * Any lock, or no lock at all, may be held on the database file.ŸK**    * The dbSize, dbOrigSize and dbFileSize variables may not be trusted.¢**´**  READER:¢**ŸE**    In this state all the requirements for reading the database in ŸG**    rollback (non-WAL) mode are met. Unless the pager is (or recentlyŸG**    was) in exclusive-locking mode, a user-level read transaction is Ÿ5**    open. The database size is known in this state.¢**ŸJ**    A connection running with locking_mode=normal enters this state whenŸF**    it opens a read-transaction on the database and returns to stateŸH**    OPEN after the read-transaction is completed. However a connectionŸM**    running in locking_mode=exclusive (including temp databases) remains inŸH**    this state even after the read-transaction is closed. The only wayŸL**    a locking_mode=exclusive connection can transition from READER to OPENŸ)**    is via the ERROR state (see below).£** ŸJ**    * A read transaction may be active (but a write-transaction cannot).Ÿ>**    * A SHARED or greater lock is held on the database file.ŸF**    * The dbSize variable may be trusted (even if a user-level read ŸK**      transaction is not active). The dbOrigSize and dbFileSize variablesŸ)**      may not be trusted at this point.ŸK**    * If the database is a WAL database, then the WAL connection is open.ŸF**    * Even if a read-transaction is not open, it is guaranteed that Ÿ3**      there is no hot-journal in the file-system.¢**≤**  WRITER_LOCKED:¢**ŸH**    The pager moves to this state from READER when a write-transactionŸI**    is first opened on the database. In WRITER_LOCKED state, all locks ŸD**    required to start a write-transaction are held, but no actual Ÿ>**    modifications to the cache or database have taken place.¢**ŸJ**    In rollback mode, a RESERVED or (if the transaction was opened with ŸK**    BEGIN EXCLUSIVE) EXCLUSIVE lock is obtained on the database file whenŸM**    moving to this state, but the journal file is not written to or opened ŸM**    to in this state. If the transaction is committed or rolled back while ŸM**    in WRITER_LOCKED state, all that is required is to unlock the database ´**    file.¢**ŸM**    IN WAL mode, WalBeginWriteTransaction() is called to lock the log file.ŸJ**    If the connection is running with locking_mode=exclusive, an attemptŸ?**    is made to obtain an EXCLUSIVE lock on the database file.¢**Ÿ&**    * A write transaction is active.ŸJ**    * If the connection is open in rollback-mode, a RESERVED or greater Ÿ***      lock is held on the database file.ŸF**    * If the connection is open in WAL-mode, a WAL write transactionŸM**      is open (i.e. sqlite3WalBeginWriteTransaction() has been successfully∞**      called).ŸF**    * The dbSize, dbOrigSize and dbFileSize variables are all valid.Ÿ?**    * The contents of the pager cache have not been modified.Ÿ0**    * The journal file may or may not be open.ŸL**    * Nothing (not even the first header) has been written to the journal.¢**¥**  WRITER_CACHEMOD:¢**ŸI**    A pager moves from WRITER_LOCKED state to this state when a page isŸJ**    first modified by the upper layer. In rollback mode the journal fileŸG**    is opened (if it is not already open) and a header written to theŸC**    start of it. The database file on disk has not been modified.¢**Ÿ&**    * A write transaction is active.Ÿ@**    * A RESERVED or greater lock is held on the database file.ŸG**    * The journal file is open and the first header has been written Ÿ:**      to it, but the header has not been synced to disk.Ÿ:**    * The contents of the page cache have been modified.¢**±**  WRITER_DBMOD:¢**ŸH**    The pager transitions from WRITER_CACHEMOD into WRITER_DBMOD stateŸI**    when it modifies the contents of the database file. WAL connectionsŸI**    never enter this state (since they do not modify the database file,π**    just the log file).¢**Ÿ&**    * A write transaction is active.ŸB**    * An EXCLUSIVE or greater lock is held on the database file.ŸG**    * The journal file is open and the first header has been written ª**      and synced to disk.ŸG**    * The contents of the page cache have been modified (and possiblyπ**      written to disk).¢**¥**  WRITER_FINISHED:¢**ŸB**    It is not possible for a WAL connection to enter this state.¢**ŸN**    A rollback-mode pager changes to WRITER_FINISHED state from WRITER_DBMODŸO**    state after the entire transaction has been successfully written into theŸJ**    database file. In this state the transaction may be committed simplyŸK**    by finalizing the journal file. Once in WRITER_FINISHED state, it is ŸL**    not possible to modify the database further. At this point, the upper Ÿ;**    layer must either commit or rollback the transaction.¢**Ÿ&**    * A write transaction is active.ŸB**    * An EXCLUSIVE or greater lock is held on the database file.ŸJ**    * All writing and syncing of journal and database data has finished.ŸL**      If no error occurred, all that remains is to finalize the journal toŸK**      commit the transaction. If an error did occur, the caller will needŸ%**      to rollback the transaction. ¢**™**  ERROR:¢**ŸI**    The ERROR state is entered when an IO or disk-full error (includingŸF**    SQLITE_IOERR_NOMEM) occurs at a point in the code that makes it ŸK**    difficult to be sure that the in-memory pager state (cache contents, ŸH**    db size etc.) are consistent with the contents of the file-system.¢**ŸK**    Temporary pager files may enter the ERROR state, but in-memory pagers≠**    cannot.¢**ŸF**    For example, if an IO error occurs while performing a rollback, ŸJ**    the contents of the page-cache may be left in an inconsistent state.ŸH**    At this point it would be dangerous to change back to READER stateŸI**    (as usually happens after a rollback). Any subsequent readers mightŸH**    report database corruption (due to the inconsistent cache), and ifŸJ**    they upgrade to writers, they may inadvertently corrupt the databaseŸI**    file. To avoid this hazard, the pager switches into the ERROR stateŸ0**    instead of READER following such an error.¢**ŸG**    Once it has entered the ERROR state, any attempt to use the pagerŸC**    to read or write data returns an error. Eventually, once all ŸH**    outstanding transactions have been abandoned, the pager is able toŸD**    transition back to OPEN state, discarding the contents of the ŸK**    page-cache and any other in-memory state at the same time. EverythingŸN**    is reloaded from disk (and, if necessary, hot-journal rollback peformed)ŸH**    when a read-transaction is next opened on the pager (transitioningŸK**    the pager into READER state). At that point the system has recovered µ**    from the error.¢**Ÿ<**    Specifically, the pager jumps into the ERROR state if:¢**ŸG**      1. An error occurs while attempting a rollback. This happens inŸ+**         function sqlite3PagerRollback().¢**ŸF**      2. An error occurs while attempting to finalize a journal fileŸG**         following a commit in function sqlite3PagerCommitPhaseTwo().¢**ŸF**      3. An error occurs while attempting to write to the journal orŸF**         database file in function pagerStress() in order to free up≤**         memory.¢**ŸK**    In other cases, the error is returned to the b-tree layer. The b-treeŸG**    layer then attempts a rollback operation. If the error condition ŸI**    persists, the pager enters the ERROR state via condition (1) above.¢**ŸK**    Condition (3) is necessary because it can be triggered by a read-onlyŸI**    statement executed within a transaction. In this case, if the errorŸG**    code were simply returned to the user, the b-tree layer would notŸH**    automatically attempt a rollback, as it assumes that an error in aŸO**    read-only statement cannot leave the pager in an internally inconsistent ¨**    state.¢**ŸL**    * The Pager.errCode variable is set to something other than SQLITE_OK.ŸH**    * There are one or more outstanding references to pages (after theŸL**      last reference is dropped the pager should move back to OPEN state).Ÿ,**    * The pager is not an in-memory pager.¶**    ¢**©** Notes:¢**ŸG**   * A pager is never in WRITER_DBMOD or WRITER_FINISHED state if theŸH**     connection is open in WAL mode. A WAL connection is always in oneŸ **     of the first four states.¢**ŸK**   * Normally, a connection open in exclusive mode is never in PAGER_OPENŸL**     state. There are two exceptions: immediately after exclusive-mode hasŸE**     been turned on (and before any read or write transactions are ŸB**     executed), and when the pager is leaving the "error state".¢**Ÿ&**   * See also: assert_pager_state().¢*/Ÿ%#define PAGER_OPEN                  0Ÿ%#define PAGER_READER                1Ÿ%#define PAGER_WRITER_LOCKED         2Ÿ%#define PAGER_WRITER_CACHEMOD       3Ÿ%#define PAGER_WRITER_DBMOD          4Ÿ%#define PAGER_WRITER_FINISHED       5Ÿ%#define PAGER_ERROR                 6†¢/*Ÿ?** The Pager.eLock variable is almost always set to one of the ŸD** following locking-states, according to the lock currently held onŸL** the database file: NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.ŸF** This variable is kept up to date as locks are taken and released byŸ2** the pagerLockDb() and pagerUnlockDb() wrappers.¢**ŸJ** If the VFS xLock() or xUnlock() returns an error other than SQLITE_BUSYŸJ** (i.e. one of the SQLITE_IOERR subtypes), it is not clear whether or notŸI** the operation was successful. In these circumstances pagerLockDb() andŸI** pagerUnlockDb() take a conservative approach - eLock is always updatedŸI** when unlocking the file, and only updated when locking the file if theŸH** VFS call is successful. This way, the Pager.eLock variable may be setŸH** to a less exclusive (lower) value than the lock that is actually heldŸF** at the system level, but it is never set to a more exclusive value.¢**ŸK** This is usually safe. If an xUnlock fails or appears to fail, there may ŸI** be a few redundant xLock() calls or a lock may be held for longer thanŸ+** required, but nothing really goes wrong.¢**ŸI** The exception is when the database file is unlocked as the pager movesŸK** from ERROR to OPEN state. At this point there may be a hot-journal file ŸN** in the file-system that needs to be rolled back (as part of an OPEN->SHAREDŸH** transition, by the same pager or any other). If the call to xUnlock()ŸL** fails at this point and the pager is left holding an EXCLUSIVE lock, thisŸG** can confuse the call to xCheckReservedLock() call made later as partº** of hot-journal detection.¢**ŸM** xCheckReservedLock() is defined as returning true "if there is a RESERVED ŸG** lock held by this process or any others". So xCheckReservedLock may ŸJ** return true because the caller itself is holding an EXCLUSIVE lock (butŸK** doesn't know it because of a previous error in xUnlock). If this happensŸI** a hot-journal may be mistaken for a journal being created by an activeŸK** transaction in another process, causing SQLite to read from the databaseª** without rolling it back.¢**ŸG** To work around this, if a call to xUnlock() fails when unlocking theŸF** database in the ERROR state, Pager.eLock is set to UNKNOWN_LOCK. ItŸG** is only changed back to a real locking state after a successful callŸN** to xLock(EXCLUSIVE). Also, the code to do the OPEN->SHARED state transitionŸK** omits the check for a hot-journal if Pager.eLock is set to UNKNOWN_LOCK ŸJ** lock. Instead, it assumes a hot-journal exists and obtains an EXCLUSIVEŸL** lock on the database file before attempting to roll it back. See functionŸ%** PagerSharedLock() for more detail.¢**ŸD** Pager.eLock may only be set to UNKNOWN_LOCK when the pager is in ¥** PAGER_OPEN state.¢*/Ÿ6#define UNKNOWN_LOCK                (EXCLUSIVE_LOCK+1)†¢/*Ÿ6** A macro used for invoking the codec if there is one¢*/∑#ifdef SQLITE_HAS_CODECº# define CODEC1(P,D,N,X,E) \Ÿ:    if( P->xCodec && P->xCodec(P->pCodec,D,N,X)==0 ){ E; }æ# define CODEC2(P,D,N,X,E,O) \Ÿ+    if( P->xCodec==0 ){ O=(char*)D; }else \Ÿ:    if( (O=(char*)(P->xCodec(P->pCodec,D,N,X)))==0 ){ E; }•#elseŸ(# define CODEC1(P,D,N,X,E)   /* NO-OP */Ÿ'# define CODEC2(P,D,N,X,E,O) O=(char*)D¶#endif†¢/*ŸG** The maximum allowed sector size. 64KiB. If the xSectorsize() method ŸJ** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.ŸG** This could conceivably cause corruption following a power failure onŸ:** such a system. This is currently an undocumented limit.¢*/ø#define MAX_SECTOR_SIZE 0x10000††¢/*ŸF** An instance of the following structure is allocated for each activeŸI** savepoint and statement transaction in the system. All such structuresŸE** are stored in the Pager.aSavepoint[] array, which is allocated andŸ"** resized using sqlite3Realloc().¢**ŸF** When a savepoint is created, the PagerSavepoint.iHdrOffset field isŸG** set to 0. If a journal-header is written into the main journal whileŸF** the savepoint is active, then iHdrOffset is set to the byte offset ŸF** immediately following the last journal record written into the mainŸG** journal before the journal-header. This is required during savepointŸ+** rollback (see pagerPlaybackSavepoint()).¢*/Ÿ-typedef struct PagerSavepoint PagerSavepoint;∑struct PagerSavepoint {ŸD  i64 iOffset;                 /* Starting offset in main journal */Ÿ.  i64 iHdrOffset;              /* See above */ŸC  Bitvec *pInSavepoint;        /* Set of pages in this savepoint */ŸE  Pgno nOrig;                  /* Original number of pages in file */ŸI  Pgno iSubRec;                /* Index of first record in sub-journal */∑#ifndef SQLITE_OMIT_WALŸG  u32 aWalData[WAL_SAVEPOINT_NDATA];        /* WAL savepoint context */¶#endif¢};†¢/*ŸE** Bits of the Pager.doNotSpill flag.  See further description below.¢*/ŸK#define SPILLFLAG_OFF         0x01 /* Never spill cache.  Set via pragma */ŸN#define SPILLFLAG_ROLLBACK    0x02 /* Current rolling back, so do not spill */ŸE#define SPILLFLAG_NOSYNC      0x04 /* Spill is ok, but do not sync */†¢/*ŸF** An open page cache is an instance of struct Pager. A description ofŸ7** some of the more important member variables follows:¢**©** eState¢**ŸG**   The current 'state' of the pager object. See the comment and stateŸ8**   diagram above for a description of the pager state.¢**®** eLock¢**ŸN**   For a real on-disk database, the current lock held on the database file -Ÿ;**   NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.¢**ŸH**   For a temporary or in-memory database (neither of which require anyŸF**   locks), this variable is always set to EXCLUSIVE_LOCK. Since suchŸH**   databases always have Pager.exclusiveMode==1, this tricks the pagerŸG**   logic into thinking that it already has all the locks it will everŸ***   need (and no reason to release them).¢**ŸF**   In some (obscure) circumstances, this variable may also be set toŸH**   UNKNOWN_LOCK. See the comment above the #define of UNKNOWN_LOCK for≠**   details.¢**≤** changeCountDone¢**ŸH**   This boolean variable is used to make sure that the change-counter ŸI**   (the 4-byte header field at byte offset 24 of the database file) is Ÿ,**   not updated more often than necessary. ¢**ŸG**   It is set to true when the change-counter field is updated, which ŸG**   can only happen if an exclusive lock is held on the database file.Ÿ@**   It is cleared (set to false) whenever an exclusive lock is ŸM**   relinquished on the database file. Each time a transaction is committed,ŸF**   The changeCountDone flag is inspected. If it is true, the work ofŸH**   updating the change-counter is omitted for the current transaction.¢**ŸL**   This mechanism means that when running in exclusive mode, a connection ŸH**   need only update the change-counter once, for the first transactionØ**   committed.¢**¨** setMaster¢**ŸI**   When PagerCommitPhaseOne() is called to commit a transaction, it mayŸG**   (or may not) specify a master-journal name to be written into the Ÿ.**   journal file before it is synced to disk.¢**ŸM**   Whether or not a journal file contains a master-journal pointer affects ŸM**   the way in which the journal file is finalized after the transaction is ŸJ**   committed or rolled back when running in "journal_mode=PERSIST" mode.ŸG**   If a journal file does not contain a master-journal pointer, it isŸF**   finalized by overwriting the first journal header with zeroes. IfŸL**   it does contain a master-journal pointer the journal file is finalized ŸD**   by truncating it to zero bytes, just as if the connection were Ÿ-**   running in "journal_mode=truncate" mode.¢**ŸK**   Journal files that contain master journal pointers cannot be finalizedŸG**   simply by overwriting the first journal-header with zeroes, as theŸL**   master journal pointer could interfere with hot-journal rollback of anyŸG**   subsequently interrupted transaction that reuses the journal file.¢**ŸI**   The flag is cleared as soon as the journal file is finalized (eitherŸJ**   by PagerCommitPhaseTwo or PagerRollback). If an IO error prevents theŸG**   journal file from being successfully finalized, the setMaster flagŸ@**   is cleared anyway (and the pager will move to ERROR state).¢**≠** doNotSpill¢**ŸH**   This variables control the behavior of cache-spills  (calls made byŸH**   the pcache module to the pagerStress() routine to write cached dataŸ4**   to the file-system in order to free up memory).¢**ŸI**   When bits SPILLFLAG_OFF or SPILLFLAG_ROLLBACK of doNotSpill are set,ŸG**   writing to the database from pagerStress() is disabled altogether.ŸD**   The SPILLFLAG_ROLLBACK case is done in a very obscure case thatŸG**   comes up during savepoint rollback that requires the pcache moduleŸJ**   to allocate a new page to prevent the journal file from being writtenŸP**   while it is being traversed by code in pager_playback().  The SPILLFLAG_OFFø**   case is a user preference.£** ŸE**   If the SPILLFLAG_NOSYNC bit is set, writing to the database fromŸE**   pagerStress() is permitted, but syncing the journal file is not.ŸM**   This flag is set by sqlite3PagerWrite() when the file-system sector-sizeŸM**   is larger than the database page-size in order to prevent a journal syncŸP**   from happening in between the journalling of two pages on the same sector. ¢**Ø** subjInMemory¢**ŸG**   This is a boolean variable. If true, then any required sub-journalŸE**   is opened as an in-memory journal file. If false, then in-memoryŸ:**   sub-journals are only used for in-memory pager files.¢**ŸA**   This variable is updated by the upper layer each time a new Ÿ!**   write-transaction is opened.¢**Ÿ!** dbSize, dbOrigSize, dbFileSize¢**ŸH**   Variable dbSize is set to the number of pages in the database file.ŸI**   It is valid in PAGER_READER and higher states (all states except for∂**   OPEN and ERROR). ¢**ŸH**   dbSize is set based on the size of the database file, which may be ŸE**   larger than the size of the database (the value stored at offsetŸE**   28 of the database header by the btree). If the size of the fileŸE**   is not an integer multiple of the page-size, the value stored inŸN**   dbSize is rounded down (i.e. a 5KB file with 2K page-size has dbSize==2).ŸH**   Except, any file that is greater than 0 bytes in size is consideredŸH**   to have at least one page. (i.e. a 1KB file with 2K page-size leads≥**   to dbSize==1).¢**ŸH**   During a write-transaction, if pages with page-numbers greater thanŸE**   dbSize are modified in the cache, dbSize is updated accordingly.ŸI**   Similarly, if the database is truncated using PagerTruncateImage(), ∑**   dbSize is updated.¢**Ÿ=**   Variables dbOrigSize and dbFileSize are valid in states ŸG**   PAGER_WRITER_LOCKED and higher. dbOrigSize is a copy of the dbSizeŸJ**   variable at the start of the transaction. It is used during rollback,ŸG**   and to determine whether or not pages need to be journalled before¥**   being modified.¢**ŸD**   Throughout a write-transaction, dbFileSize contains the size ofŸF**   the file on disk in pages. It is set to a copy of dbSize when theŸK**   write-transaction is first opened, and updated when VFS calls are madeŸ5**   to write or truncate the database file on disk. ¢**ŸH**   The only reason the dbFileSize variable is required is to suppress ŸJ**   unnecessary calls to xTruncate() after committing a transaction. If, ŸH**   when a transaction is committed, the dbFileSize variable indicates ŸN**   that the database file is larger than the database image (Pager.dbSize), ŸK**   pager_truncate() is called. The pager_truncate() call uses xFilesize()ŸM**   to measure the database file on disk, and then truncates it if required.ŸI**   dbFileSize is not used when rolling back a transaction. In this caseŸI**   pager_truncate() is called unconditionally (which means there may beŸJ**   a call to xFilesize() that is not strictly required). In either case,ŸE**   pager_truncate() may cause the file to become smaller or larger.¢**≠** dbHintSize¢**ŸI**   The dbHintSize variable is used to limit the number of calls made toŸ3**   the VFS xFileControl(FCNTL_SIZE_HINT) method. ¢**Ÿ>**   dbHintSize is set to a copy of the dbSize variable when aŸD**   write-transaction is opened (at the same time as dbFileSize andŸH**   dbOrigSize). If the xFileControl(FCNTL_SIZE_HINT) method is called,ŸJ**   dbHintSize is increased to the number of pages that correspond to theŸI**   size-hint passed to the method call. See pager_write_pagelist() for ≠**   details.¢**™** errCode¢**ŸJ**   The Pager.errCode variable is only ever used in PAGER_ERROR state. ItŸM**   is set to zero in all other states. In PAGER_ERROR state, Pager.errCode ŸO**   is always set to SQLITE_FULL, SQLITE_IOERR or one of the SQLITE_IOERR_XXX Ø**   sub-codes.¢**∫** syncFlags, walSyncFlags¢**ŸN**   syncFlags is either SQLITE_SYNC_NORMAL (0x02) or SQLITE_SYNC_FULL (0x03).ŸL**   syncFlags is used for rollback mode.  walSyncFlags is used for WAL modeŸI**   and contains the flags used to sync the checkpoint operations in theŸK**   lower two bits, and sync flags used for transaction commits in the WALŸO**   file in bits 0x04 and 0x08.  In other words, to get the correct sync flagsŸN**   for checkpoint operations, use (walSyncFlags&0x03) and to get the correctŸK**   sync flags for transaction commit, use ((walSyncFlags>>2)&0x03).  NoteŸO**   that with synchronous=NORMAL in WAL mode, transaction commit is not syncedŸ7**   meaning that the 0x04 and 0x08 bits are both zero.¢*/Æstruct Pager {Ÿ>  sqlite3_vfs *pVfs;          /* OS functions to use for IO */ŸL  u8 exclusiveMode;           /* Boolean. True if locking_mode==EXCLUSIVE */ŸI  u8 journalMode;             /* One of the PAGER_JOURNALMODE_* values */ŸG  u8 useJournal;              /* Use a rollback journal on this file */ŸC  u8 noSync;                  /* Do not sync the journal if true */ŸP  u8 fullSync;                /* Do extra syncs of the journal for robustness */ŸG  u8 extraSync;               /* sync directory after journal delete */ŸF  u8 syncFlags;               /* SYNC_NORMAL or SYNC_FULL otherwise */Ÿ9  u8 walSyncFlags;            /* See description above */ŸN  u8 tempFile;                /* zFilename is a temporary or immutable file */ŸD  u8 noLock;                  /* Do not lock (except in WAL mode) */ŸA  u8 readOnly;                /* True for a read-only database */Ÿ@  u8 memDb;                   /* True to inhibit all file I/O */†ŸM  /**************************************************************************ŸH  ** The following block contains those class members that change duringŸI  ** routine operation.  Class members not in this block are either fixedŸH  ** when the pager is first created or else only change when there is aŸK  ** significant mode change (such as changing the page_size, locking_mode,ŸK  ** or the journal_mode).  From another view, these class members describeŸE  ** the "state" of the pager, while other class members describe theŸ"  ** "configuration" of the pager.§  */ŸO  u8 eState;                  /* Pager state (OPEN, READER, WRITER_LOCKED..) */ŸF  u8 eLock;                   /* Current lock held on database file */ŸM  u8 changeCountDone;         /* Set after incrementing the change-counter */ŸO  u8 setMaster;               /* True if a m-j name has been written to jrnl */ŸH  u8 doNotSpill;              /* Do not spill the cache when non-zero */ŸF  u8 subjInMemory;            /* True to use in-memory sub-journals */Ÿ8  u8 bUseFetch;               /* True to use xFetch() */ŸL  u8 hasHeldSharedLock;       /* True if a shared lock has ever been held */ŸC  Pgno dbSize;                /* Number of pages in the database */ŸI  Pgno dbOrigSize;            /* dbSize before the current transaction */ŸH  Pgno dbFileSize;            /* Number of pages in the database file */ŸH  Pgno dbHintSize;            /* Value passed to FCNTL_SIZE_HINT call */ŸB  int errCode;                /* One of several kinds of errors */ŸP  int nRec;                   /* Pages journalled since last j-header written */ŸN  u32 cksumInit;              /* Quasi-random value added to every checksum */ŸL  u32 nSubRec;                /* Number of records written to sub-journal */ŸN  Bitvec *pInJournal;         /* One bit for each page in the database file */Ÿ@  sqlite3_file *fd;           /* File descriptor for database */ŸD  sqlite3_file *jfd;          /* File descriptor for main journal */ŸC  sqlite3_file *sjfd;         /* File descriptor for sub-journal */ŸL  i64 journalOff;             /* Current write offset in the journal file */ŸJ  i64 journalHdr;             /* Byte offset to previous journal header */ŸO  sqlite3_backup *pBackup;    /* Pointer to list of ongoing backup processes */Ÿ>  PagerSavepoint *aSavepoint; /* Array of active savepoints */ŸF  int nSavepoint;             /* Number of elements in aSavepoint[] */ŸM  u32 iDataVersion;           /* Changes whenever database content changes */ŸJ  char dbFileVers[16];        /* Changes whenever database file changes */†ŸN  int nMmapOut;               /* Number of mmap pages currently outstanding */Ÿ=  sqlite3_int64 szMmap;       /* Desired maximum mmap size */ŸK  PgHdr *pMmapFreelist;       /* List of free mmap page headers (pDirty) */§  /*Ÿ0  ** End of the routinely-changing class membersŸN  ***************************************************************************/†ŸN  u16 nExtra;                 /* Add this many bytes to each in-memory page */ŸN  i16 nReserve;               /* Number of unused bytes at end of each page */ŸA  u32 vfsFlags;               /* Flags for sqlite3_vfs.xOpen() */ŸG  u32 sectorSize;             /* Assumed sector size during rollback */Ÿ=  int pageSize;               /* Number of bytes in a page */ŸH  Pgno mxPgno;                /* Maximum allowed size of the database */ŸK  i64 journalSizeLimit;       /* Size limit for persistent journal files */Ÿ=  char *zFilename;            /* Name of the database file */Ÿ<  char *zJournal;             /* Name of the journal file */Ÿ>  int (*xBusyHandler)(void*); /* Function to call when busy */ŸE  void *pBusyHandlerArg;      /* Context argument for xBusyHandler */ŸL  int aStat[4];               /* Total cache hits, misses, writes, spills */≤#ifdef SQLITE_TESTŸ7  int nRead;                  /* Database pages read */¶#endifŸJ  void (*xReiniter)(DbPage*); /* Call this routine when reloading pages */ŸG  int (*xGet)(Pager*,Pgno,DbPage**,int); /* Routine to fetch a patch */∑#ifdef SQLITE_HAS_CODECŸK  void *(*xCodec)(void*,void*,Pgno,int); /* Routine for en/decoding data */ŸJ  void (*xCodecSizeChng)(void*,int,int); /* Notify of page size changes */ŸG  void (*xCodecFree)(void*);             /* Destructor for the codec */ŸG  void *pCodec;               /* First argument to xCodec... methods */¶#endifŸM  char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */Ÿ@  PCache *pPCache;            /* Pointer to page cache object */∑#ifndef SQLITE_OMIT_WALŸN  Wal *pWal;                  /* Write-ahead log used by "journal_mode=wal" */ŸA  char *zWal;                 /* File name for write-ahead log */¶#endif¢};†¢/*ŸG** Indexes for use with Pager.aStat[]. The Pager.aStat[] array containsŸH** the values accessed by passing SQLITE_DBSTATUS_CACHE_HIT, CACHE_MISS Ÿ)** or CACHE_WRITE to sqlite3_db_status().¢*/∫#define PAGER_STAT_HIT   0∫#define PAGER_STAT_MISS  1∫#define PAGER_STAT_WRITE 2∫#define PAGER_STAT_SPILL 3†¢/*Ÿ8** The following global variables hold counters used forŸ:** testing purposes only.  These variables do not exist inŸ=** a non-testing build.  These variables are not thread-safe.¢*/≤#ifdef SQLITE_TESTŸYSQLITE_API int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */ŸZSQLITE_API int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */ŸZSQLITE_API int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */ª# define PAGER_INCR(v)  v++•#else∂# define PAGER_INCR(v)¶#endif†††¢/*ŸA** Journal files begin with the following magic string.  The dataŸE** was obtained from /dev/random.  It is used only as a sanity check.¢**ŸE** Since version 2.8.0, the journal format contains additional sanityŸG** checking information.  If the power fails while the journal is beingŸ@** written, semi-random garbage data might appear in the journalŸ<** file after power is restored.  If an attempt is then madeŸM** to roll the journal back, the database could be corrupted.  The additionalŸD** sanity checking data is an attempt to discover the garbage in theπ** journal and ignore it.¢**ŸF** The sanity checking information for the new journal format consistsŸG** of a 32-bit checksum on each page of data.  The checksum covers bothŸG** the page number and the pPager->pageSize bytes of data for the page.ŸI** This cksum is initialized to a 32-bit random value that appears in theŸM** journal file right after the header.  The random initializer is important,ŸF** because garbage data that appears at the end of a journal is likelyŸH** data that was once in other files that have now been deleted.  If theŸG** garbage data came from an obsolete journal file, the checksums mightŸF** be correct.  But by initializing the checksum to random value whichŸ9** is different for every journal, we minimize that risk.¢*/Ÿ.static const unsigned char aJournalMagic[] = {Ÿ1  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,¢};†¢/*ŸA** The size of the of each page record in the journal is given by∑** the following macro.¢*/Ÿ7#define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8)†¢/*ŸD** The journal header size for this pager. This is usually the same Ÿ:** size as a single disk sector. See also setSectorSize().¢*/Ÿ3#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)†¢/*ŸH** The macro MEMDB is true if we are dealing with an in-memory database.ŸJ** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,ŸG** the value of MEMDB will be a constant and the compiler will optimizeŸ%** out code that would never execute.¢*/ª#ifdef SQLITE_OMIT_MEMORYDB∞# define MEMDB 0•#elseº# define MEMDB pPager->memDb¶#endif†¢/*ŸN** The macro USEFETCH is true if we are allowed to use the xFetch and xUnfetchŸ=** interfaces to access the database using memory-mapped I/O.¢*/∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ%# define USEFETCH(x) ((x)->bUseFetch)•#else∂# define USEFETCH(x) 0¶#endif†¢/*Ÿ/** The maximum legal page number is (2^31 - 1).¢*/Ÿ!#define PAGER_MAX_PGNO 2147483647†¢/*ŸH** The argument to this macro is a file descriptor (type sqlite3_file*).Ÿ@** Return 0 if it is not open, or non-zero (but not 1) if it is.¢**Ÿ1** This is so that expressions can be written as:¢**Ÿ#**   if( isOpen(pPager->jfd) ){ ...¢**≠** instead of¢**Ÿ%**   if( pPager->jfd->pMethods ){ ...¢*/Ÿ(#define isOpen(pFd) ((pFd)->pMethods!=0)†¢/*ŸF** Return true if this pager uses a write-ahead log to read page pgno.ŸC** Return false if the pager reads pgno directly from the database.¢*/ŸE#if !defined(SQLITE_OMIT_WAL) && defined(SQLITE_DIRECT_OVERFLOW_READ)Ÿ@SQLITE_PRIVATE int sqlite3PagerUseWal(Pager *pPager, Pgno pgno){∞  u32 iRead = 0;©  int rc;Ÿ!  if( pPager->pWal==0 ) return 0;Ÿ7  rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);µ  return rc || iRead;°}¶#endif∑#ifndef SQLITE_OMIT_WALŸ&# define pagerUseWal(x) ((x)->pWal!=0)•#elseπ# define pagerUseWal(x) 0æ# define pagerRollbackWal(x) 0Ÿ"# define pagerWalFrames(v,w,x,y) 0Ÿ+# define pagerOpenWalIfPresent(z) SQLITE_OKŸ/# define pagerBeginReadTransaction(z) SQLITE_OK¶#endif†Ø#ifndef NDEBUG ¢/*©** Usage:¢**Ÿ***   assert( assert_pager_state(pPager) );¢**ŸD** This function runs many asserts to try to find inconsistencies inŸ*** the internal state of the Pager object.¢*/Ÿ(static int assert_pager_state(Pager *p){¥  Pager *pPager = p;†º  /* State must be valid. */ø  assert( p->eState==PAGER_OPENŸ!       || p->eState==PAGER_READERŸ(       || p->eState==PAGER_WRITER_LOCKEDŸ*       || p->eState==PAGER_WRITER_CACHEMODŸ'       || p->eState==PAGER_WRITER_DBMODŸ*       || p->eState==PAGER_WRITER_FINISHEDŸ        || p->eState==PAGER_ERROR§  );†ŸK  /* Regardless of the current state, a temp-file connection always behavesŸJ  ** as if it has an exclusive lock on the database file. It never updatesŸI  ** the change-counter field, so the changeCountDone flag is always set.§  */Ÿ7  assert( p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK );Ÿ6  assert( p->tempFile==0 || pPager->changeCountDone );†ŸF  /* If the useJournal flag is clear, the journal-mode must be "OFF". ŸI  ** And if the journal-mode is "OFF", the journal file must not be open.§  */ŸC  assert( p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal );ŸE  assert( p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) );†ŸF  /* Check that MEMDB implies noSync. And an in-memory journal. Since ŸN  ** this means an in-memory pager performs no IO at all, it cannot encounter ŸL  ** either SQLITE_IOERR or SQLITE_FULL during rollback or while finalizing ŸH  ** a journal file. (although the in-memory journal implementation may ŸL  ** return SQLITE_IOERR_NOMEM while the journal file is being written). It ŸI  ** is therefore not possible for an in-memory pager to enter the ERROR ´  ** state.§  */Æ  if( MEMDB ){Ω    assert( !isOpen(p->fd) );∏    assert( p->noSync );Ÿ2    assert( p->journalMode==PAGER_JOURNALMODE_OFF Ÿ5         || p->journalMode==PAGER_JOURNALMODE_MEMORY ¶    );Ÿ>    assert( p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN );Ÿ     assert( pagerUseWal(p)==0 );£  }†ŸG  /* If changeCountDone is set, a RESERVED lock or greater must be held±  ** on the file.§  */ŸG  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );Ÿ#  assert( p->eLock!=PENDING_LOCK );†∂  switch( p->eState ){¥    case PAGER_OPEN:∑      assert( !MEMDB );Ÿ+      assert( pPager->errCode==SQLITE_OK );ŸN      assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );¨      break;†∂    case PAGER_READER:Ÿ+      assert( pPager->errCode==SQLITE_OK );Ÿ'      assert( p->eLock!=UNKNOWN_LOCK );Ÿ&      assert( p->eLock>=SHARED_LOCK );¨      break;†Ω    case PAGER_WRITER_LOCKED:Ÿ'      assert( p->eLock!=UNKNOWN_LOCK );Ÿ+      assert( pPager->errCode==SQLITE_OK );Ÿ!      if( !pagerUseWal(pPager) ){Ÿ*        assert( p->eLock>=RESERVED_LOCK );ß      }Ÿ3      assert( pPager->dbSize==pPager->dbOrigSize );Ÿ7      assert( pPager->dbOrigSize==pPager->dbFileSize );Ÿ7      assert( pPager->dbOrigSize==pPager->dbHintSize );Ÿ%      assert( pPager->setMaster==0 );¨      break;†ø    case PAGER_WRITER_CACHEMOD:Ÿ'      assert( p->eLock!=UNKNOWN_LOCK );Ÿ+      assert( pPager->errCode==SQLITE_OK );Ÿ!      if( !pagerUseWal(pPager) ){ŸH        /* It is possible that if journal_mode=wal here that neither theŸF        ** journal file nor the WAL file are open. This happens duringŸE        ** a rollback transaction that switches from journal_mode=offø        ** to journal_mode=wal.™        */Ÿ*        assert( p->eLock>=RESERVED_LOCK );ø        assert( isOpen(p->jfd) Ÿ6             || p->journalMode==PAGER_JOURNALMODE_OFF Ÿ6             || p->journalMode==PAGER_JOURNALMODE_WAL ™        );ß      }Ÿ7      assert( pPager->dbOrigSize==pPager->dbFileSize );Ÿ7      assert( pPager->dbOrigSize==pPager->dbHintSize );¨      break;†º    case PAGER_WRITER_DBMOD:Ÿ)      assert( p->eLock==EXCLUSIVE_LOCK );Ÿ+      assert( pPager->errCode==SQLITE_OK );Ÿ%      assert( !pagerUseWal(pPager) );Ÿ)      assert( p->eLock>=EXCLUSIVE_LOCK );Ω      assert( isOpen(p->jfd) Ÿ4           || p->journalMode==PAGER_JOURNALMODE_OFF Ÿ4           || p->journalMode==PAGER_JOURNALMODE_WAL ŸO           || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)®      );Ÿ7      assert( pPager->dbOrigSize<=pPager->dbHintSize );¨      break;†ø    case PAGER_WRITER_FINISHED:Ÿ)      assert( p->eLock==EXCLUSIVE_LOCK );Ÿ+      assert( pPager->errCode==SQLITE_OK );Ÿ%      assert( !pagerUseWal(pPager) );Ω      assert( isOpen(p->jfd) Ÿ4           || p->journalMode==PAGER_JOURNALMODE_OFF Ÿ4           || p->journalMode==PAGER_JOURNALMODE_WAL ŸO           || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)®      );¨      break;†µ    case PAGER_ERROR:ŸI      /* There must be at least one outstanding reference to the pager ifŸH      ** in ERROR state. Otherwise the pager should have already droppedº      ** back to OPEN state.®      */Ÿ+      assert( pPager->errCode!=SQLITE_OK );ŸM      assert( sqlite3PcacheRefCount(pPager->pPCache)>0 || pPager->tempFile );¨      break;£  }†´  return 1;°}∫#endif /* ifndef NDEBUG */†¥#ifdef SQLITE_DEBUG ¢/*ŸA** Return a pointer to a human readable string in a static bufferŸG** containing the state of the Pager object passed as an argument. ThisŸJ** is intended to be used within debuggers. For example, as an alternativeΩ** to "print *pPager" in gdb:¢**Ÿ/** (gdb) printf "%s", print_pager_state(pPager)¢*/Ÿ)static char *print_pager_state(Pager *p){π  static char zRet[1024];†æ  sqlite3_snprintf(1024, zRet,ª      "Filename:      %s\n"Ÿ&      "State:         %s errCode=%d\n"ª      "Lock:          %s\n"Ÿ(      "Locking mode:  locking_mode=%s\n"Ÿ(      "Journal mode:  journal_mode=%s\n"Ÿ;      "Backing store: tempFile=%d memDb=%d useJournal=%d\n"Ÿ8      "Journal:       journalOff=%lld journalHdr=%lld\n"Ÿ>      "Size:          dbsize=%d dbOrigSize=%d dbFileSize=%d\n"¥      , p->zFilenameŸ3      , p->eState==PAGER_OPEN            ? "OPEN" :Ÿ5        p->eState==PAGER_READER          ? "READER" :Ÿ<        p->eState==PAGER_WRITER_LOCKED   ? "WRITER_LOCKED" :Ÿ>        p->eState==PAGER_WRITER_CACHEMOD ? "WRITER_CACHEMOD" :Ÿ;        p->eState==PAGER_WRITER_DBMOD    ? "WRITER_DBMOD" :Ÿ>        p->eState==PAGER_WRITER_FINISHED ? "WRITER_FINISHED" :Ÿ>        p->eState==PAGER_ERROR           ? "ERROR" : "?error?"∑      , (int)p->errCodeŸ/      , p->eLock==NO_LOCK         ? "NO_LOCK" :Ÿ0        p->eLock==RESERVED_LOCK   ? "RESERVED" :Ÿ1        p->eLock==EXCLUSIVE_LOCK  ? "EXCLUSIVE" :Ÿ.        p->eLock==SHARED_LOCK     ? "SHARED" :Ÿ9        p->eLock==UNKNOWN_LOCK    ? "UNKNOWN" : "?error?"Ÿ1      , p->exclusiveMode ? "exclusive" : "normal"Ÿ?      , p->journalMode==PAGER_JOURNALMODE_MEMORY   ? "memory" :Ÿ<        p->journalMode==PAGER_JOURNALMODE_OFF      ? "off" :Ÿ?        p->journalMode==PAGER_JOURNALMODE_DELETE   ? "delete" :Ÿ@        p->journalMode==PAGER_JOURNALMODE_PERSIST  ? "persist" :ŸA        p->journalMode==PAGER_JOURNALMODE_TRUNCATE ? "truncate" :ŸF        p->journalMode==PAGER_JOURNALMODE_WAL      ? "wal" : "?error?"Ÿ;      , (int)p->tempFile, (int)p->memDb, (int)p->useJournalŸ$      , p->journalOff, p->journalHdrŸ>      , (int)p->dbSize, (int)p->dbOrigSize, (int)p->dbFileSize§  );†Æ  return zRet;°}¶#endif†Ÿ4/* Forward references to the various page getters */Ÿ3static int getPageNormal(Pager*,Pgno,DbPage**,int);Ÿ2static int getPageError(Pager*,Pgno,DbPage**,int);∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ1static int getPageMMap(Pager*,Pgno,DbPage**,int);¶#endif†¢/*ŸF** Set the Pager.xGet method for the appropriate routine used to fetch∫** content from the pager.¢*/Ÿ+static void setGetterMethod(Pager *pPager){∏  if( pPager->errCode ){Ÿ     pPager->xGet = getPageError;∫#if SQLITE_MAX_MMAP_SIZE>0º  }else if( USEFETCH(pPager)∑#ifdef SQLITE_HAS_CODEC∑   && pPager->xCodec==0¶#endif§  ){ø    pPager->xGet = getPageMMap;Ÿ##endif /* SQLITE_MAX_MMAP_SIZE>0 */®  }else{Ÿ!    pPager->xGet = getPageNormal;£  }°}†¢/*ŸJ** Return true if it is necessary to write page *pPg into the sub-journal.ŸF** A page needs to be written into the sub-journal if there exists oneŸ%** or more open savepoints for which:¢**ŸI**   * The page-number is less than or equal to PagerSavepoint.nOrig, andŸ=**   * The bit corresponding to the page-number is not set inŸ#**     PagerSavepoint.pInSavepoint.¢*/Ÿ(static int subjRequiresPage(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;¥  PagerSavepoint *p;∏  Pgno pgno = pPg->pgno;®  int i;Ÿ&  for(i=0; i<pPager->nSavepoint; i++){ø    p = &pPager->aSavepoint[i];ŸO    if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){Ø      return 1;•    }£  }´  return 0;°}†≥#ifdef SQLITE_DEBUG¢/*Ÿ:** Return true if the page is already in the journal file.¢*/Ÿ4static int pageInJournal(Pager *pPager, PgHdr *pPg){Ÿ:  return sqlite3BitvecTest(pPager->pInJournal, pPg->pgno);°}¶#endif†¢/*ŸK** Read a 32-bit integer from the given file descriptor.  Store the integerŸG** that is read in *pRes.  Return SQLITE_OK if everything worked, or anŸ&** error code is something goes wrong.¢**Ÿ/** All values are stored on disk as big-endian.¢*/Ÿ?static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){∂  unsigned char ac[4];Ÿ5  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);∂  if( rc==SQLITE_OK ){Ÿ     *pRes = sqlite3Get4byte(ac);£  }¨  return rc;°}†¢/*ŸH** Write a 32-bit integer into a string buffer in big-endian byte order.¢*/Ÿ1#define put32bits(A,B)  sqlite3Put4byte((u8*)A,B)††¢/*ŸK** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OKŸ7** on success or an error code is something goes wrong.¢*/Ÿ>static int write32bits(sqlite3_file *fd, i64 offset, u32 val){≠  char ac[4];µ  put32bits(ac, val);Ÿ+  return sqlite3OsWrite(fd, ac, 4, offset);°}†¢/*ŸH** Unlock the database file to level eLock, which must be either NO_LOCKŸE** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()ŸL** succeeds, set the Pager.eLock variable to match the (attempted) new lock.¢**ŸF** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function isŸB** called, do not modify it. See the comment above the #define of Ÿ+** UNKNOWN_LOCK for an explanation of this.¢*/Ÿ3static int pagerUnlockDb(Pager *pPager, int eLock){µ  int rc = SQLITE_OK;†Ÿ;  assert( !pPager->exclusiveMode || pPager->eLock==eLock );Ÿ1  assert( eLock==NO_LOCK || eLock==SHARED_LOCK );Ÿ5  assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );ª  if( isOpen(pPager->fd) ){Ÿ#    assert( pPager->eLock>=eLock );ŸI    rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);Ÿ&    if( pPager->eLock!=UNKNOWN_LOCK ){Ÿ       pPager->eLock = (u8)eLock;•    }Ÿ.    IOTRACE(("UNLOCK %p %d\n", pPager, eLock))£  }¨  return rc;°}†¢/*ŸK** Lock the database file to level eLock, which must be either SHARED_LOCK,ŸH** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set theŸ2** Pager.eLock variable to the new locking state. ¢**ŸG** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is ŸL** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. ŸH** See the comment above the #define of UNKNOWN_LOCK for an explanation ´** of this.¢*/Ÿ1static int pagerLockDb(Pager *pPager, int eLock){µ  int rc = SQLITE_OK;†ŸP  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );Ÿ;  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){ŸG    rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);ŸP    if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){Ÿ       pPager->eLock = (u8)eLock;Ÿ.      IOTRACE(("LOCK %p %d\n", pPager, eLock))•    }£  }¨  return rc;°}†¢/*Ÿ>** This function determines whether or not the atomic-write orŸD** atomic-batch-write optimizations can be used with this pager. TheŸ,** atomic-write optimization can be used if:¢**ŸF**  (a) the value returned by OsDeviceCharacteristics() indicates thatŸ6**      a database page may be written atomically, andŸB**  (b) the value returned by OsSectorSize() is less than or equalπ**      to the page size.¢**ŸI** If it can be used, then the value returned is the size of the journal Ÿ<** file when it contains rollback data for exactly one page.¢**ŸO** The atomic-batch-write optimization can be used if OsDeviceCharacteristics()ŸD** returns a value with the SQLITE_IOCAP_BATCH_ATOMIC bit set. -1 isπ** returned in this case.¢**Ÿ6** If neither optimization can be used, 0 is returned.¢*/Ÿ)static int jrnlBufferSize(Pager *pPager){≥  assert( !MEMDB );†Ÿ)#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \Ÿ- || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ÿ@  int dc;                           /* Device characteristics */†ø  assert( isOpen(pPager->fd) );Ÿ2  dc = sqlite3OsDeviceCharacteristics(pPager->fd);•#elseª  UNUSED_PARAMETER(pPager);¶#endif†Ÿ'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITEŸ;  if( pPager->dbSize>0 && (dc&SQLITE_IOCAP_BATCH_ATOMIC) ){Æ    return -1;£  }¶#endif†Ÿ!#ifdef SQLITE_ENABLE_ATOMIC_WRITE£  {Ÿ%    int nSector = pPager->sectorSize;Ÿ"    int szPage = pPager->pageSize;†Ÿ-    assert(SQLITE_IOCAP_ATOMIC512==(512>>8));Ÿ/    assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));ŸF    if( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){Ø      return 0;•    }£  }†Ÿ8  return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);¶#endif†´  return 0;°}†¢/*ŸC** If SQLITE_CHECK_PAGES is defined then we do some sanity checkingŸ@** on the cache using a hash function.  This is used for testing∂** and debugging only.¢*/π#ifdef SQLITE_CHECK_PAGES¢/*Ÿ3** Return a 32-bit hash of the page data for pPage.¢*/Ÿ;static u32 pager_datahash(int nByte, unsigned char *pData){Ø  u32 hash = 0;®  int i;π  for(i=0; i<nByte; i++){Ÿ"    hash = (hash*1039) + pData[i];£  }Æ  return hash;°}Ÿ(static u32 pager_pagehash(PgHdr *pPage){ŸP  return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData);°}Ÿ-static void pager_set_pagehash(PgHdr *pPage){Ÿ*  pPage->pageHash = pager_pagehash(pPage);°}†¢/*ŸL** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGESŸF** is defined, and NDEBUG is not defined, an assert() statement checksŸK** that the page is either dirty or still matches the calculated page-hash.¢*/Ÿ"#define CHECK_PAGE(x) checkPage(x)Ÿ"static void checkPage(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;Ÿ(  assert( pPager->eState!=PAGER_ERROR );ŸK  assert( (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) );°}†•#elseæ#define pager_datahash(X,Y)  0º#define pager_pagehash(X)  0Ω#define pager_set_pagehash(X)µ#define CHECK_PAGE(x)Ÿ #endif  /* SQLITE_CHECK_PAGES */†¢/*ŸF** When this is called the journal file for pager pPager must be open.ŸF** This function attempts to read a master journal file name from the ŸF** end of the file and, if successful, copies it into memory supplied ŸH** by the caller. See comments above writeMasterJournal() for the formatŸI** used to store a master journal file name at the end of a journal file.¢**ŸH** zMaster must point to a buffer of at least nMaster bytes allocated byŸJ** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there isŸH** enough space to write the master journal name). If the master journalŸ@** name in the journal is longer than nMaster bytes (including aŸE** nul-terminator), then this is handled as if no master journal nameø** were present in the journal.¢**ŸE** If a master journal file name is present at the end of the journalŸC** file, then it is copied into the buffer pointed to by zMaster. AŸE** nul-terminator byte is appended to the buffer following the masterµ** journal file name.¢**ŸC** If it is determined that no master journal file name is present Ÿ1** zMaster[0] is set to 0 and SQLITE_OK returned.¢**ŸD** If an error occurs while reading from the journal file, an SQLite∫** error code is returned.¢*/ŸNstatic int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){Ÿ.  int rc;                    /* Return code */ŸI  u32 len;                   /* Length in bytes of master journal name */ŸL  i64 szJ;                   /* Total size in bytes of journal file pJrnl */ŸF  u32 cksum;                 /* MJ checksum value read from journal */Ÿ8  u32 u;                     /* Unsigned loop counter */ŸD  unsigned char aMagic[8];   /* A buffer to hold the magic header */¥  zMaster[0] = '\0';†Ÿ6  if( SQLITE_OK!=(rc = sqlite3OsFileSize(pJrnl, &szJ))¨   || szJ<16Ÿ7   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-16, &len))≥   || len>=nMaster ∞   || len>szJ-16≠   || len==0 Ÿ9   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-12, &cksum))Ÿ>   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))Ÿ&   || memcmp(aMagic, aJournalMagic, 8)ŸF   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len))§  ){Æ    return rc;£  }†Ÿ;  /* See if the checksum matches the master journal name */∑  for(u=0; u<len; u++){∏    cksum -= zMaster[u];£  }Æ  if( cksum ){ŸK    /* If the checksum doesn't add up, then one or more of the disk sectorsŸF    ** containing the master journal filename is corrupted. This meansŸH    ** definitely roll back, so just return SQLITE_OK and report a (nul)ø    ** master-journal filename.¶    */¨    len = 0;£  }∂  zMaster[len] = '\0';£   ≥  return SQLITE_OK;°}†¢/*Ÿ>** Return the offset of the sector boundary at or immediately Ÿ@** following the value in pPager->journalOff, assuming a sector Ÿ$** size of pPager->sectorSize bytes.¢**Ÿ ** i.e for a sector size of 512:¢**Ÿ+**   Pager.journalOff          Return valueŸ,**   ---------------------------------------Ÿ **   0                         0Ÿ"**   512                       512Ÿ"**   100                       512Ÿ#**   2000                      2048£** ¢*/Ÿ+static i64 journalHdrOffset(Pager *pPager){±  i64 offset = 0;Ω  i64 c = pPager->journalOff;™  if( c ){ŸI    offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);£  }Ÿ-  assert( offset%JOURNAL_HDR_SZ(pPager)==0 );∂  assert( offset>=c );Ÿ.  assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );∞  return offset;°}†¢/*Ÿ>** The journal file must be open when this function is called.¢**ŸG** This function is a no-op if the journal file has not been written toŸ@** within the current transaction (i.e. if Pager.journalOff==0).¢**ŸF** If doTruncate is non-zero or the Pager.journalSizeLimit variable isŸM** set to 0, then truncate the journal file to zero bytes in size. Otherwise,ŸM** zero the 28-byte header at the start of the journal file. In either case, ŸJ** if the pager is not in no-sync mode, sync the journal file immediately Ÿ"** after writing or truncating it.¢**ŸF** If Pager.journalSizeLimit is set to a positive, non-zero value, andŸG** following the truncation or zeroing described above the size of the ŸE** journal file in bytes is larger than this value, then truncate theŸF** journal file to Pager.journalSizeLimit bytes. The journal file doesŸ2** not need to be synced following this operation.¢**ŸJ** If an IO error occurs, abandon processing and return the IO error code.ø** Otherwise, return SQLITE_OK.¢*/Ÿ9static int zeroJournalHdr(Pager *pPager, int doTruncate){ŸE  int rc = SQLITE_OK;                               /* Return code */Ÿ   assert( isOpen(pPager->jfd) );Ÿ3  assert( !sqlite3JournalIsInMemory(pPager->jfd) );ª  if( pPager->journalOff ){ŸL    const i64 iLimit = pPager->journalSizeLimit;    /* Local cache of jsl */†Ÿ&    IOTRACE(("JZEROHDR %p\n", pPager))Ÿ"    if( doTruncate || iLimit==0 ){Ÿ-      rc = sqlite3OsTruncate(pPager->jfd, 0);™    }else{Ÿ*      static const char zeroHdr[28] = {0};ŸD      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);•    }Ÿ+    if( rc==SQLITE_OK && !pPager->noSync ){ŸN      rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);•    }†ŸE    /* At this point the transaction is committed but the write lock ŸJ    ** is still held on the file. If there is a size limit configured for ŸJ    ** the persistent journal and the journal file currently consumes moreŸJ    ** space than that limit allows for, truncate it now. There is no needŸ1    ** to sync the file following this operation.¶    */Ÿ$    if( rc==SQLITE_OK && iLimit>0 ){≠      i64 sz;Ÿ/      rc = sqlite3OsFileSize(pPager->jfd, &sz);Ÿ'      if( rc==SQLITE_OK && sz>iLimit ){Ÿ4        rc = sqlite3OsTruncate(pPager->jfd, iLimit);ß      }•    }£  }¨  return rc;°}†¢/*ŸG** The journal file must be open when this routine is called. A journalŸH** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the¥** current location.¢**Ÿ3** The format for the journal header is as follows:Ÿ/** - 8 bytes: Magic identifying journal format.ŸE** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.Ÿ/** - 4 bytes: Random number used for page hash.Ÿ*** - 4 bytes: Initial database page count.ŸF** - 4 bytes: Sector size used by the process that wrote this journal.Ÿ!** - 4 bytes: Database page size.£** Ÿ;** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.¢*/Ÿ*static int writeJournalHdr(Pager *pPager){Ÿ7  int rc = SQLITE_OK;                 /* Return code */ŸP  char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */ŸP  u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */ŸJ  u32 nWrite;                         /* Bytes of header sector written */Ÿ8  int ii;                             /* Loop counter */†ŸF  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */†Ÿ'  if( nHeader>JOURNAL_HDR_SZ(pPager) ){Ÿ%    nHeader = JOURNAL_HDR_SZ(pPager);£  }†ŸA  /* If there are active savepoints and any of them were created ŸB  ** since the most recent journal header was written, update the Ÿ*  ** PagerSavepoint.iHdrOffset fields now.§  */Ÿ)  for(ii=0; ii<pPager->nSavepoint; ii++){Ÿ/    if( pPager->aSavepoint[ii].iHdrOffset==0 ){Ÿ=      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;•    }£  }†ŸE  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);†•  /* ŸG  ** Write the nRec Field - the number of page records that follow thisŸJ  ** journal header. Normally, zero is written to this value at this time.ŸI  ** After the records are added to the journal (and the journal synced, ŸH  ** if in full-sync mode), the zero is overwritten with the true numberŸ$  ** of records (see syncJournal()).§  **ŸH  ** A faster alternative is to write 0xFFFFFFFF to the nRec field. WhenŸC  ** reading the journal this value tells SQLite to assume that theŸJ  ** rest of the journal file contains valid page records. This assumptionŸI  ** is dangerous, as if a failure occurred whilst writing to the journalŸC  ** file it may contain some garbage data. There are two scenariosŸ$  ** where this risk can be ignored:§  **ŸC  **   * When the pager is in no-sync mode. Corruption can follow aŸ+  **     power failure in this case anyway.§  **ŸG  **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guaranteesŸA  **     that garbage data is never appended to the journal file.§  */Ÿ1  assert( isOpen(pPager->fd) || pPager->noSync );ŸG  if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)ŸL   || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) §  ){Ÿ:    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));Ÿ;    put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);®  }else{Ÿ0    memset(zHeader, 0, sizeof(aJournalMagic)+4);£  }†Ÿ*  /* The random check-hash initializer */ ŸD  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);ŸB  put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);Ÿ!  /* The initial database size */ŸC  put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);Ÿ0  /* The assumed sector size for this process */ŸD  put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);†µ  /* The page size */ŸB  put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize);†ŸF  /* Initializing the tail of the buffer is not necessary.  EverythingŸG  ** works find if the following memset() is omitted.  But initializingŸH  ** the memory prevents valgrind from complaining, so we are willing toæ  ** take the performance hit.§  */Ÿ/  memset(&zHeader[sizeof(aJournalMagic)+20], 0,Ÿ-         nHeader-(sizeof(aJournalMagic)+20));†ŸD  /* In theory, it is only necessary to write the 28 bytes that the ŸJ  ** journal header consumes to the journal file here. Then increment the ŸB  ** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next ŸI  ** record is written to the following sector (leaving a gap in the fileŸ2  ** that will be implicitly filled in by the OS).§  **ŸJ  ** However it has been discovered that on some systems this pattern can ŸH  ** be significantly slower than contiguously writing data to the file,Ÿ@  ** even if that means explicitly writing data to the block of ŸG  ** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is whatÆ  ** is done. §  **ŸJ  ** The loop is required here in case the sector-size is larger than the ŸH  ** database page size. Since the zHeader buffer is only Pager.pageSizeŸJ  ** bytes in size, more than one call to sqlite3OsWrite() may be requiredŸ2  ** to populate the entire journal header sector.•  */ ŸO  for(nWrite=0; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){ŸG    IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))ŸK    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);Ÿ7    assert( pPager->journalHdr <= pPager->journalOff );Ÿ"    pPager->journalOff += nHeader;£  }†¨  return rc;°}†¢/*ŸK** The journal file must be open when this is called. A journal header fileŸJ** (JOURNAL_HDR_SZ bytes) is read from the current location in the journalŸ=** file. The current location in the journal file is given byŸH** pPager->journalOff. See comments above function writeJournalHdr() forŸ.** a description of the journal header format.¢**ŸE** If the header is read successfully, *pNRec is set to the number ofŸL** page records following this header and *pDbSize is set to the size of theŸK** database before the transaction began, in pages. Also, pPager->cksumInitŸJ** is set to the value read from the journal header. SQLITE_OK is returned∞** in this case.¢**ŸE** If the journal header file appears to be corrupted, SQLITE_DONE isŸK** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytesŸB** cannot be read from the journal file an error code is returned.¢*/∫static int readJournalHdr(Ÿ1  Pager *pPager,               /* Pager object */¨  int isHot,ŸK  i64 journalSize,             /* Size of the open journal file in bytes */ŸH  u32 *pNRec,                  /* OUT: Value read from the nRec field */ŸO  u32 *pDbSize                 /* OUT: Value of original database size field */¢){Ÿ0  int rc;                      /* Return code */ŸF  unsigned char aMagic[8];     /* A buffer to hold the magic header */ŸH  i64 iHdrOff;                 /* Offset of journal header being read */†ŸF  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */†ŸE  /* Advance Pager.journalOff to the start of the next sector. If theŸF  ** journal file is too small for there to be a header stored at thisø  ** point, return SQLITE_DONE.§  */Ÿ0  pPager->journalOff = journalHdrOffset(pPager);Ÿ@  if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){∑    return SQLITE_DONE;£  }ø  iHdrOff = pPager->journalOff;†ŸJ  /* Read in the first 8 bytes of the journal header. If they do not matchŸH  ** the  magic string found at the start of each journal header, returnŸI  ** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,≠  ** proceed.§  */Ÿ-  if( isHot || iHdrOff!=pPager->journalHdr ){ŸE    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);≠    if( rc ){∞      return rc;•    }Ÿ;    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){π      return SQLITE_DONE;•    }£  }†ŸG  /* Read the first three 32-bit fields of the journal header: The nRecŸG  ** field, the checksum-initializer and the database size at the startŸE  ** of the transaction. Return an error code if anything goes wrong.§  */ŸA  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))ŸO   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))ŸD   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))§  ){Æ    return rc;£  }†æ  if( pPager->journalOff==0 ){ŸH    u32 iPageSize;               /* Page-size field of journal header */ŸJ    u32 iSectorSize;             /* Sector-size field of journal header */†ŸC    /* Read the page-size and sector-size journal header fields. */ŸK    if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))ŸI     || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))¶    ){∞      return rc;•    }†ŸG    /* Versions of SQLite prior to 3.5.8 set the page-size field of theŸK    ** journal header to zero. In this case, assume that the Pager.pageSizeŸ8    ** variable is already set to the correct page size.¶    */∑    if( iPageSize==0 ){Ÿ#      iPageSize = pPager->pageSize;•    }†ŸK    /* Check that the values read from the page-size and sector-size fieldsŸI    ** are within range. To be 'in range', both values need to be a powerŸM    ** of two greater than or equal to 512 or 32, and not greater than their Ÿ.    ** respective compile time maximum limits.¶    */Ÿ8    if( iPageSize<512                  || iSectorSize<32ŸE     || iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZEŸK     || ((iPageSize-1)&iPageSize)!=0   || ((iSectorSize-1)&iSectorSize)!=0 ¶    ){ŸM      /* If the either the page-size or sector-size in the journal-header is ŸK      ** invalid, then the process that wrote the journal-header must have ŸI      ** crashed before the header was synced. In this case stop reading ø      ** the journal file here.®      */π      return SQLITE_DONE;•    }†ŸF    /* Update the page-size to match the value read from the journal. ŸF    ** Use a testcase() macro to make sure that malloc failure within Ÿ$    ** PagerSetPagesize() is tested.¶    */Ÿ9    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);æ    testcase( rc!=SQLITE_OK );†ŸA    /* Update the assumed sector-size to match the value used by ŸA    ** the process that created this journal. If this journal wasŸB    ** created by a process other than this one, then this routineŸD    ** is being called from within pager_playback(). The local valueŸB    ** of Pager.sectorSize is restored at the end of that routine.¶    */Ÿ%    pPager->sectorSize = iSectorSize;£  }†Ÿ/  pPager->journalOff += JOURNAL_HDR_SZ(pPager);¨  return rc;°}††¢/*ŸI** Write the supplied master journal name into the journal file for pagerŸK** pPager at the current location. The master journal name must be the lastŸJ** thing written to a journal file. If the pager is in full-sync mode, theŸI** journal file descriptor is advanced to the next sector boundary beforeŸ&** anything is written. The format is:¢**æ**   + 4 bytes: PAGER_MJ_PGNO.Ÿ1**   + N bytes: Master journal filename in utf-8.ŸN**   + 4 bytes: N (length of master journal name in bytes, no nul-terminator).Ÿ-**   + 4 bytes: Master journal name checksum.Ÿ **   + 8 bytes: aJournalMagic[].¢**ŸI** The master journal page checksum is the sum of the bytes in the masterŸJ** journal name, where each byte is interpreted as a signed 8-bit integer.¢**ŸL** If zMaster is a NULL pointer (occurs for a single database transaction), ∏** this call is a no-op.¢*/ŸBstatic int writeMasterJournal(Pager *pPager, const char *zMaster){Ÿ4  int rc;                          /* Return code */ŸA  int nMaster;                     /* Length of string zMaster */ŸI  i64 iHdrOff;                     /* Offset of header in journal file */ŸE  i64 jrnlSize;                    /* Size of journal file on disk */ŸC  u32 cksum = 0;                   /* Checksum of string zMaster */†Ÿ!  assert( pPager->setMaster==0 );Ÿ!  assert( !pagerUseWal(pPager) );†Ø  if( !zMaster Ÿ4   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY ∫   || !isOpen(pPager->jfd)§  ){µ    return SQLITE_OK;£  }∏  pPager->setMaster = 1;Ÿ5  assert( pPager->journalHdr <= pPager->journalOff );†ŸA  /* Calculate the length in bytes and the checksum of zMaster */Ÿ.  for(nMaster=0; zMaster[nMaster]; nMaster++){æ    cksum += zMaster[nMaster];£  }†ŸI  /* If in full-sync mode, advance to the next disk sector before writingŸJ  ** the master journal name. This is in case the previous page written toŸ)  ** the journal has already been synced.§  */π  if( pPager->fullSync ){Ÿ2    pPager->journalOff = journalHdrOffset(pPager);£  }ø  iHdrOff = pPager->journalOff;†ŸE  /* Write the master journal data to the end of the journal file. IfŸ:  ** an error occurs, return the error code to the caller.§  */ŸL  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))ŸL   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))ŸH   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))ŸH   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))Ÿ?   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,Ÿ7                                 iHdrOff+4+nMaster+8)))§  ){Æ    return rc;£  }Ÿ%  pPager->journalOff += (nMaster+20);†ŸB  /* If the pager is in peristent-journal mode, then the physical ŸD  ** journal-file may extend past the end of the master-journal nameŸA  ** and 8 bytes of magic data just written to the file. This is Ÿ>  ** dangerous because the code to rollback a hot-journal fileŸC  ** will not be able to find the master-journal name to determine Ÿ(  ** whether or not the journal is hot. §  **ŸE  ** Easiest thing to do in this scenario is to truncate the journal ø  ** file to the required size.•  */ ŸA  if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))Ÿ!   && jrnlSize>pPager->journalOff§  ){Ÿ<    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);£  }¨  return rc;°}†¢/*Ÿ;** Discard the entire contents of the in-memory page-cache.¢*/Ÿ'static void pager_reset(Pager *pPager){π  pPager->iDataVersion++;Ÿ(  sqlite3BackupRestart(pPager->pBackup);Ÿ&  sqlite3PcacheClear(pPager->pPCache);°}†¢/*Ÿ(** Return the pPager->iDataVersion value¢*/Ÿ:SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager *pPager){Ÿ&  assert( pPager->eState>PAGER_OPEN );æ  return pPager->iDataVersion;°}†¢/*ŸC** Free all structures in the Pager.aSavepoint[] array and set bothŸG** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journalŸ8** if it is open and the pager is not in exclusive mode.¢*/Ÿ0static void releaseAllSavepoints(Pager *pPager){ŸK  int ii;               /* Iterator for looping through Pager.aSavepoint */Ÿ)  for(ii=0; ii<pPager->nSavepoint; ii++){Ÿ>    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);£  }ŸI  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){Ÿ!    sqlite3OsClose(pPager->sjfd);£  }Ÿ#  sqlite3_free(pPager->aSavepoint);π  pPager->aSavepoint = 0;π  pPager->nSavepoint = 0;∂  pPager->nSubRec = 0;°}†¢/*Ÿ>** Set the bit number pgno in the PagerSavepoint.pInSavepoint ŸA** bitvecs of all open savepoints. Return SQLITE_OK if successfulŸ.** or SQLITE_NOMEM if a malloc failure occurs.¢*/Ÿ;static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){Ÿ.  int ii;                   /* Loop counter */Ÿ-  int rc = SQLITE_OK;       /* Result code */†Ÿ)  for(ii=0; ii<pPager->nSavepoint; ii++){Ÿ0    PagerSavepoint *p = &pPager->aSavepoint[ii];π    if( pgno<=p->nOrig ){Ÿ4      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);Ÿ#      testcase( rc==SQLITE_NOMEM );Ÿ2      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );•    }£  }¨  return rc;°}†¢/*ŸE** This function is a no-op if the pager is in exclusive mode and notŸE** in the ERROR state. Otherwise, it switches the pager to PAGER_OPEN©** state.¢**ŸE** If the pager is not in exclusive-access mode, the database file isŸH** completely unlocked. If the file is unlocked and the file-system doesŸF** not exhibit the UNDELETABLE_WHEN_OPEN property, the journal file is∫** closed (if it is open).¢**ŸD** If the pager is in ERROR state when this function is called, the ŸF** contents of the pager cache are discarded before switching back to ŸG** the OPEN state. Regardless of whether the pager is in exclusive-modeŸC** or not, any journal file left in the file-system will be treatedŸD** as a hot-journal and rolled back the next time a read-transactionŸ2** is opened (by this or by any other connection).¢*/Ÿ(static void pager_unlock(Pager *pPager){†Ÿ'  assert( pPager->eState==PAGER_READER Ÿ%       || pPager->eState==PAGER_OPEN Ÿ&       || pPager->eState==PAGER_ERROR §  );†Ÿ+  sqlite3BitvecDestroy(pPager->pInJournal);π  pPager->pInJournal = 0;ø  releaseAllSavepoints(pPager);†º  if( pagerUseWal(pPager) ){Ÿ#    assert( !isOpen(pPager->jfd) );Ÿ/    sqlite3WalEndReadTransaction(pPager->pWal);Ÿ     pPager->eState = PAGER_OPEN;Ÿ%  }else if( !pPager->exclusiveMode ){ŸN    int rc;                       /* Error code returned by pagerUnlockDb() */ŸN    int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;†ŸC    /* If the operating system support deletion of open files, thenŸI    ** close the journal file when dropping the database lock.  OtherwiseŸH    ** another connection with journal_mode=delete might delete the fileπ    ** out from under us.¶    */Ÿ2    assert( (PAGER_JOURNALMODE_MEMORY   & 5)!=1 );Ÿ2    assert( (PAGER_JOURNALMODE_OFF      & 5)!=1 );Ÿ2    assert( (PAGER_JOURNALMODE_WAL      & 5)!=1 );Ÿ2    assert( (PAGER_JOURNALMODE_DELETE   & 5)!=1 );Ÿ2    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );Ÿ2    assert( (PAGER_JOURNALMODE_PERSIST  & 5)==1 );Ÿ5    if( 0==(iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)Ÿ$     || 1!=(pPager->journalMode & 5)¶    ){Ÿ"      sqlite3OsClose(pPager->jfd);•    }†ŸM    /* If the pager is in the ERROR state and the call to unlock the databaseŸH    ** file fails, set the current lock to UNKNOWN_LOCK. See the commentŸH    ** above the #define for UNKNOWN_LOCK for an explanation of why this¥    ** is necessary.¶    */Ÿ(    rc = pagerUnlockDb(pPager, NO_LOCK);Ÿ7    if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){Ÿ#      pPager->eLock = UNKNOWN_LOCK;•    }†ŸI    /* The pager state may be changed from PAGER_ERROR to PAGER_OPEN hereŸG    ** without clearing the error code. This is intentional - the errorŸ>    ** code is cleared and the cache reset in the block below.¶    */Ÿ=    assert( pPager->errCode || pPager->eState!=PAGER_ERROR );Ÿ     pPager->changeCountDone = 0;Ÿ     pPager->eState = PAGER_OPEN;£  }†ŸG  /* If Pager.errCode is set, the contents of the pager cache cannot beŸH  ** trusted. Now that there are no outstanding references to the pager,ŸF  ** it can safely move back to PAGER_OPEN state. This happens in bothŸ'  ** normal and exclusive-locking mode.§  */Ÿ1  assert( pPager->errCode==SQLITE_OK || !MEMDB );∏  if( pPager->errCode ){æ    if( pPager->tempFile==0 ){∫      pager_reset(pPager);Ÿ"      pPager->changeCountDone = 0;Ÿ"      pPager->eState = PAGER_OPEN;™    }else{ŸI      pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);•    }Ÿ>    if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);Ÿ     pPager->errCode = SQLITE_OK;º    setGetterMethod(pPager);£  }†π  pPager->journalOff = 0;π  pPager->journalHdr = 0;∏  pPager->setMaster = 0;°}†¢/*ŸH** This function is called whenever an IOERR or FULL error that requiresŸB** the pager to transition into the ERROR state may ahve occurred.ŸF** The first argument is a pointer to the pager structure, the second ŸD** the error-code about to be returned by a pager API function. The ŸE** value returned is a copy of the second argument to this function. ¢**ŸD** If the second argument is SQLITE_FULL, SQLITE_IOERR or one of theŸG** IOERR sub-codes, the pager enters the ERROR state and the error codeŸJ** is stored in Pager.errCode. While the pager remains in the ERROR state,ŸJ** all major API calls on the Pager will immediately return Pager.errCode.¢**ŸB** The ERROR state indicates that the contents of the pager-cache ŸI** cannot be trusted. This state can be cleared by completely discarding ŸD** the contents of the pager-cache. If a transaction was active whenŸD** the persistent error occurred, then the rollback journal may needŸE** to be replayed to restore the contents of the database file (as if∫** it were a hot-journal).¢*/Ÿ.static int pager_error(Pager *pPager, int rc){∂  int rc2 = rc & 0xff;Ÿ$  assert( rc==SQLITE_OK || !MEMDB );©  assert(Ÿ&       pPager->errCode==SQLITE_FULL ||Ÿ$       pPager->errCode==SQLITE_OK ||Ÿ-       (pPager->errCode & 0xff)==SQLITE_IOERR§  );Ÿ.  if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){π    pPager->errCode = rc;Ÿ!    pPager->eState = PAGER_ERROR;º    setGetterMethod(pPager);£  }¨  return rc;°}†Ÿ5static int pager_truncate(Pager *pPager, Pgno nPage);†¢/*ŸG** The write transaction open on pPager is being committed (bCommit==1)ø** or rolled back (bCommit==0).¢**ŸH** Return TRUE if and only if all dirty pages should be flushed to disk.¢**©** Rules:¢**ŸG**   *  For non-TEMP databases, always sync to disk.  This is necessaryŸ'**      for transactions to be durable.¢**ŸM**   *  Sync TEMP database only on a COMMIT (not a ROLLBACK) when the backingŸH**      file has been created already (via a spill on pagerStress()) andŸI**      when the number of dirty pages in memory exceeds 25% of the total≥**      cache size.¢*/Ÿ:static int pagerFlushOnCommit(Pager *pPager, int bCommit){Ÿ%  if( pPager->tempFile==0 ) return 1;∫  if( !bCommit ) return 0;Ÿ%  if( !isOpen(pPager->fd) ) return 0;Ÿ:  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);°}†¢/*ŸF** This routine ends a transaction. A transaction is usually ended by ŸG** either a COMMIT or a ROLLBACK operation. This routine may be called ŸG** after rollback of a hot-journal, or if an error occurs while openingŸA** the journal file or writing the very first journal-header of a∏** database transaction.£** ŸE** This routine is never called in PAGER_ERROR state. If it is calledŸ@** in PAGER_NONE or PAGER_SHARED state and the lock held is lessŸ1** exclusive than a RESERVED lock, it is a no-op.¢**Ÿ1** Otherwise, any active savepoints are released.¢**ŸG** If the journal file is open, then it is "finalized". Once a journal ŸG** file has been finalized it is not possible to use it to roll back a ŸE** transaction. Nor will it be considered to be a hot-journal by thisŸG** or any other database connection. Exactly how a journal is finalizedŸG** depends on whether or not the pager is running in exclusive mode andŸB** the current journal-mode (Pager.journalMode value), as follows:¢**∏**   journalMode==MEMORYŸB**     Journal file descriptor is simply closed. This destroys an π**     in-memory journal.¢**∫**   journalMode==TRUNCATEŸ7**     Journal file is truncated to zero bytes in size.¢**π**   journalMode==PERSISTŸJ**     The first 28 bytes of the journal file are zeroed. This invalidatesŸI**     the first journal header in the file, and hence the entire journalŸ;**     file. An invalid journal file cannot be rolled back.¢**∏**   journalMode==DELETEŸF**     The journal file is closed and deleted using sqlite3OsDelete().¢**ŸK**     If the pager is running in exclusive mode, this method of finalizingŸE**     the journal file is never used. Instead, if the journalMode isŸL**     DELETE and the pager is in exclusive mode, the method described underŸ,**     journalMode==PERSIST is used instead.¢**ŸI** After the journal is finalized, the pager moves to PAGER_READER state.ŸF** If running in non-exclusive rollback mode, the lock on the file is ø** downgraded to a SHARED_LOCK.¢**ŸF** SQLITE_OK is returned if no error occurs. If an error occurs duringŸF** any of the IO operations to finalize the journal file or unlock theŸC** database then the IO error code is returned to the user. If the ŸD** operation to finalize the journal file fails, then the code stillŸE** tries to unlock the database file if not in exclusive mode. If theŸD** unlock operation fails as well, then the first error code relatedŸC** to the first error encountered (the journal finalization one) is¨** returned.¢*/ŸLstatic int pager_end_transaction(Pager *pPager, int hasMaster, int bCommit){ŸO  int rc = SQLITE_OK;      /* Error code from journal finalization operation */ŸI  int rc2 = SQLITE_OK;     /* Error code from db file unlock operation */†ŸD  /* Do nothing if the pager does not have an open write transactionŸH  ** or at least a RESERVED lock. This function may be called when thereŸE  ** is no write-transaction active but a RESERVED or greater lock isŸ"  ** held under two circumstances:§  **ŸD  **   1. After a successful hot-journal rollback, it is called withŸ7  **      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.§  **ŸK  **   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE ŸG  **      lock switches back to locking_mode=normal and then executes aŸN  **      read-transaction, this function is called with eState==PAGER_READER ŸH  **      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.§  */Ÿ'  assert( assert_pager_state(pPager) );Ÿ(  assert( pPager->eState!=PAGER_ERROR );ŸJ  if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){µ    return SQLITE_OK;£  }†ø  releaseAllSavepoints(pPager);Ÿ7  assert( isOpen(pPager->jfd) || pPager->pInJournal==0 ŸO      || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_BATCH_ATOMIC)§  );º  if( isOpen(pPager->jfd) ){Ÿ#    assert( !pagerUseWal(pPager) );†Ÿ$    /* Finalize the journal file. */Ÿ0    if( sqlite3JournalIsInMemory(pPager->jfd) ){ŸD      /* assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ); */Ÿ"      sqlite3OsClose(pPager->jfd);Ÿ@    }else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){Ÿ"      if( pPager->journalOff==0 ){∑        rc = SQLITE_OK;¨      }else{Ÿ/        rc = sqlite3OsTruncate(pPager->jfd, 0);Ÿ0        if( rc==SQLITE_OK && pPager->fullSync ){ŸN          /* Make sure the new file size is written into the inode right away.ŸM          ** Otherwise the journal might resurrect following a power loss andŸ:          ** cause the last transaction to roll back.  SeeŸA          ** https://bugzilla.mozilla.org/show_bug.cgi?id=1072773¨          */Ÿ=          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);©        }ß      }Ω      pPager->journalOff = 0;Ÿ<    }else if( pPager->journalMode==PAGER_JOURNALMODE_PERSISTŸN      || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)¶    ){Ÿ?      rc = zeroJournalHdr(pPager, hasMaster||pPager->tempFile);Ω      pPager->journalOff = 0;™    }else{ŸF      /* This branch may be executed with Pager.journalMode==MEMORY ifŸE      ** a hot-journal was just rolled back. In this case the journalŸH      ** file should be closed and deleted. If this connection writes toŸE      ** the database file, it will do so using an in-memory journal.®      */Ÿ&      int bDelete = !pPager->tempFile;Ÿ9      assert( sqlite3JournalIsInMemory(pPager->jfd)==0 );Ÿ<      assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE Ÿ<           || pPager->journalMode==PAGER_JOURNALMODE_MEMORY Ÿ9           || pPager->journalMode==PAGER_JOURNALMODE_WAL ®      );Ÿ"      sqlite3OsClose(pPager->jfd);¥      if( bDelete ){ŸP        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);ß      }•    }£  }†π#ifdef SQLITE_CHECK_PAGESŸA  sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);ŸF  if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){Ÿ-    PgHdr *p = sqlite3PagerLookup(pPager, 1);¨    if( p ){∂      p->pageHash = 0;Ÿ"      sqlite3PagerUnrefNotNull(p);•    }£  }¶#endif†Ÿ+  sqlite3BitvecDestroy(pPager->pInJournal);π  pPager->pInJournal = 0;≥  pPager->nRec = 0;∂  if( rc==SQLITE_OK ){Ÿ7    if( MEMDB || pagerFlushOnCommit(pPager, bCommit) ){Ÿ-      sqlite3PcacheCleanAll(pPager->pPCache);™    }else{Ÿ2      sqlite3PcacheClearWritable(pPager->pPCache);•    }Ÿ;    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);£  }†º  if( pagerUseWal(pPager) ){ŸG    /* Drop the WAL write-lock, if any. Also, if the connection was in ŸH    ** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE Ÿ&    ** lock held on the database file.¶    */Ÿ6    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);Ω    assert( rc2==SQLITE_OK );ŸL  }else if( rc==SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize ){ŸM    /* This branch is taken when committing a transaction in rollback-journalŸK    ** mode if the database file on disk is larger than the database image.ŸH    ** At this point the journal has been finalized and the transaction ŸJ    ** successfully committed, but the EXCLUSIVE lock is still held on theŸG    ** file. So it is safe to truncate the database file to its minimumπ    ** required size.  */Ÿ,    assert( pPager->eLock==EXCLUSIVE_LOCK );Ÿ0    rc = pager_truncate(pPager, pPager->dbSize);£  }†Ÿ!  if( rc==SQLITE_OK && bCommit ){ŸK    rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);Ÿ-    if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;£  }†Ω  if( !pPager->exclusiveMode ŸH   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))§  ){Ÿ-    rc2 = pagerUnlockDb(pPager, SHARED_LOCK);Ÿ     pPager->changeCountDone = 0;£  }Ÿ   pPager->eState = PAGER_READER;∏  pPager->setMaster = 0;†Ÿ   return (rc==SQLITE_OK?rc2:rc);°}†¢/*Ÿ@** Execute a rollback if a transaction is active and unlock the ≤** database file. ¢**ŸD** If the pager has already entered the ERROR state, do not attempt ŸD** the rollback at this time. Instead, pager_unlock() is called. TheŸB** call to pager_unlock() will discard all in-memory pages, unlockŸD** the database file and move the pager back to OPEN state. If this ŸG** means that there is a hot-journal left in the file-system, the next ŸK** connection to obtain a shared lock on the pager (which may be this one) µ** will roll it back.¢**ŸE** If the pager has not already entered the ERROR state, but an IO orŸF** malloc error occurs during a rollback, then this will itself cause ŸC** the pager to enter the ERROR state. Which will be cleared by theŸ.** call to pager_unlock(), as described above.¢*/Ÿ2static void pagerUnlockAndRollback(Pager *pPager){ŸB  if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){Ÿ)    assert( assert_pager_state(pPager) );Ÿ.    if( pPager->eState>=PAGER_WRITER_LOCKED ){Ÿ!      sqlite3BeginBenignMalloc();Ÿ#      sqlite3PagerRollback(pPager);ø      sqlite3EndBenignMalloc();Ÿ'    }else if( !pPager->exclusiveMode ){Ÿ-      assert( pPager->eState==PAGER_READER );Ÿ*      pager_end_transaction(pPager, 0, 0);•    }£  }∑  pager_unlock(pPager);°}†¢/*ŸC** Parameter aData must point to a buffer of pPager->pageSize bytesŸH** of data. Compute and return a checksum based ont the contents of the Ÿ;** page of data and the current value of pPager->cksumInit.¢**ŸA** This is not a real checksum. It is really just the sum of the Ÿ@** random initial value (pPager->cksumInit) and every 200th byteŸF** of the page data, starting with byte offset (pPager->pageSize%200).Ÿ9** Each byte is interpreted as an 8-bit unsigned integer.¢**ŸC** Changing the formula used to compute this checksum results in anŸ$** incompatible journal file format.¢**ŸH** If journal corruption occurs due to a power failure, the most likely ŸH** scenario is that one end or the other of the record will be changed. ŸI** It is much less likely that the two ends of the journal record will beŸD** correct and the middle be corrupt.  Thus, this "checksum" scheme,ŸH** though fast and simple, catches the mostly likely kind of corruption.¢*/Ÿ7static u32 pager_cksum(Pager *pPager, const u8 *aData){ŸG  u32 cksum = pPager->cksumInit;         /* Checksum value to return */Ÿ;  int i = pPager->pageSize-200;          /* Loop counter */Ø  while( i>0 ){∂    cksum += aData[i];≠    i -= 200;£  }Ø  return cksum;°}†¢/*ŸA** Report the current page size and number of reserved bytes back∞** to the codec.¢*/∑#ifdef SQLITE_HAS_CODECŸ+static void pagerReportSize(Pager *pPager){ø  if( pPager->xCodecSizeChng ){Ÿ<    pPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,Ÿ2                           (int)pPager->nReserve);£  }°}•#elseŸH# define pagerReportSize(X)     /* No-op if we do not support a codec */¶#endif†∑#ifdef SQLITE_HAS_CODEC¢/*ŸG** Make sure the number of reserved bits is the same in the destinationŸI** pager as it is in the source.  This comes up when a VACUUM changes theŸ3** number of reserved bits to the "optimal" amount.¢*/ŸHSQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager *pDest, Pager *pSrc){Ÿ(  if( pDest->nReserve!=pSrc->nReserve ){Ÿ%    pDest->nReserve = pSrc->nReserve;ª    pagerReportSize(pDest);£  }°}¶#endif†¢/*ŸH** Read a single page from either the journal file (if isMainJrnl==1) orŸB** from the sub-journal (if isMainJrnl==0) and playback that page.ŸA** The page begins at offset *pOffset into the file. The *pOffsetŸC** value is increased to the start of the next page in the journal.¢**ŸI** The main rollback journal uses checksums - the statement journal does ß** not.¢**ŸI** If the page number of the page record read from the (sub-)journal fileŸF** is greater than the current value of Pager.dbSize, then playback isŸ%** skipped and SQLITE_OK is returned.¢**ŸG** If pDone is not NULL, then it is a record of pages that have alreadyŸJ** been played back.  If the page at *pOffset has already been played backŸB** (if the corresponding pDone bit is set) then skip the playback.ŸD** Make sure the pDone bit corresponding to the *pOffset page is set∂** prior to returning.¢**ŸF** If the page record is successfully read from the (sub-)journal fileŸE** and played back, then SQLITE_OK is returned. If an IO error occursŸH** while reading the record from the (sub-)journal file or while writingŸD** to the database file, then the IO error code is returned. If dataŸE** is successfully read from the (sub-)journal file but appears to beŸF** corrupted, SQLITE_DONE is returned. Data is considered corrupted inµ** two circumstances:£** ŸD**   * If the record page-number is illegal (0 or PAGER_MJ_PGNO), orŸD**   * If the record is being rolled back from the main journal fileŸ@**     and the checksum field does not match the record content.¢**ŸK** Neither of these two scenarios are possible during a savepoint rollback.¢**ŸJ** If this is a savepoint rollback, then memory may have to be dynamicallyŸK** allocated by this function. If this is the case and an allocation fails,º** SQLITE_NOMEM is returned.¢*/Ÿ#static int pager_playback_one_page(ŸA  Pager *pPager,                /* The pager being played back */ŸB  i64 *pOffset,                 /* Offset of record to playback */ŸI  Bitvec *pDone,                /* Bitvec of pages already played back */ŸJ  int isMainJrnl,               /* 1 -> main journal. 0 -> sub-journal. */ŸC  int isSavepnt                 /* True for a savepoint rollback */¢){©  int rc;ŸC  PgHdr *pPg;                   /* An existing page in the cache */ŸJ  Pgno pgno;                    /* The page number of a page in journal */ŸG  u32 cksum;                    /* Checksum used for sanity checking */ŸD  char *aData;                  /* Temporary storage for the page */ŸN  sqlite3_file *jfd;            /* The file descriptor for the journal file */ŸD  int isSynced;                 /* True if journal page is synced */∑#ifdef SQLITE_HAS_CODECŸG  /* The jrnlEnc flag is true if Journal pages should be passed throughŸ<  ** the codec.  It is false for pure in-memory journals. */Ÿ>  const int jrnlEnc = (isMainJrnl || pPager->subjInMemory==0);¶#endif†Ÿ?  assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */Ÿ>  assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */ŸL  assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */ŸL  assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */†º  aData = pPager->pTmpSpace;ŸN  assert( aData );         /* Temp storage must have already been allocated */ŸA  assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) );†ŸK  /* Either the state is greater than PAGER_WRITER_CACHEMOD (a transaction ŸH  ** or savepoint rollback done at the request of the caller) or this isŸG  ** a hot-journal rollback. If it is a hot-journal rollback, the pagerŸG  ** is in state OPEN and holds an EXCLUSIVE lock. Hot-journal rollbackŸ;  ** only reads from the main journal, not the sub-journal.§  */Ÿ/  assert( pPager->eState>=PAGER_WRITER_CACHEMODŸG       || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)§  );Ÿ@  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );†ŸG  /* Read the page number and page data from the journal or sub-journalŸD  ** file. Return an error code to the caller if an IO error occurs.§  */Ÿ0  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;Ÿ(  rc = read32bits(jfd, *pOffset, &pgno);Ÿ   if( rc!=SQLITE_OK ) return rc;ŸF  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);Ÿ   if( rc!=SQLITE_OK ) return rc;Ÿ2  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;†ŸK  /* Sanity checking on the page.  This is more important that I originallyŸL  ** thought.  If a power failure occurs while the journal is being written,ŸL  ** it could cause invalid data to be written into the journal.  We need toŸD  ** detect this invalid data (with high probability) and ignore it.§  */Ÿ/  if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){π    assert( !isSavepnt );∑    return SQLITE_DONE;£  }ŸD  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){µ    return SQLITE_OK;£  }≥  if( isMainJrnl ){Ÿ/    rc = read32bits(jfd, (*pOffset)-4, &cksum);∑    if( rc ) return rc;Ÿ?    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){π      return SQLITE_DONE;•    }£  }†ŸH  /* If this page has already been played back before during the currentŸ7  ** rollback, then don't bother to play it back again.§  */ŸA  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=SQLITE_OK ){Æ    return rc;£  }†Ÿ;  /* When playing back page 1, restore the nReserve setting§  */Ÿ6  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){Ÿ(    pPager->nReserve = ((u8*)aData)[20];º    pagerReportSize(pPager);£  }†ŸI  /* If the pager is in CACHEMOD state, then there must be a copy of thisŸG  ** page in the pager cache. In this case just update the pager cache,ŸG  ** not the database file. The page is left marked dirty in this case.§  **ŸG  ** An exception to the above rule: If the database is in no-sync modeŸG  ** and a page is moved during an incremental vacuum then the page mayŸG  ** not be in the pager cache. Later: if a malloc() or IO error occursŸD  ** during a Movepage() call, then the page may not be in the cacheŸE  ** either. So the condition described in the above paragraph is not≤  ** assert()able.§  **ŸJ  ** If in WRITER_DBMOD, WRITER_FINISHED or OPEN state, then we update theŸI  ** pager cache if it exists and the main file. The page is then marked ŸH  ** not dirty. Since this code is only executed in PAGER_OPEN state forŸJ  ** a hot-journal rollback, it is guaranteed that the page-cache is emptyŸ#  ** if the pager is in OPEN state.§  **ŸL  ** Ticket #1171:  The statement journal might contain page content that isŸE  ** different from the page content at the start of the transaction.ŸI  ** This occurs when a page is changed prior to the start of a statementŸG  ** then changed again within the statement.  When rolling back such aŸH  ** statement we must not write to the original database unless we knowŸN  ** for certain that original page contents are synced into the main rollbackŸG  ** journal.  Otherwise, a power loss might leave modified data in theŸD  ** database file without an entry in the rollback journal that canŸG  ** restore the database to its original form.  Two conditions must beŸG  ** met before writing to the database files. (1) the database must beŸH  ** locked.  (2) we know that the original page content is fully syncedŸH  ** in the main journal either because the page is not in cache or elseŸ'  ** the page is marked as needSync==0.§  **ŸG  ** 2008-04-14:  When attempting to vacuum a corrupt database file, itŸK  ** is possible to fail a statement on a database that does not yet exist.ŸD  ** Do not attempt to write if database file has never been opened.§  */º  if( pagerUseWal(pPager) ){¨    pPg = 0;®  }else{Ÿ+    pPg = sqlite3PagerLookup(pPager, pgno);£  }∫  assert( pPg || !MEMDB );ŸE  assert( pPager->eState!=PAGER_OPEN || pPg==0 || pPager->tempFile );Ÿ4  PAGERTRACE(("PLAYBACK %d page %d hash(%08x) %s\n",ŸO           PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),Ÿ4           (isMainJrnl?"main-journal":"sub-journal")•  ));≥  if( isMainJrnl ){ŸB    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);®  }else{Ÿ=    isSynced = (pPg==0 || 0==(pPg->flags & PGHDR_NEED_SYNC));£  }∏  if( isOpen(pPager->fd)ŸH   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)Æ   && isSynced§  ){Ÿ.    i64 ofst = (pgno-1)*(i64)pPager->pageSize;ŸH    testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );Ÿ#    assert( !pagerUseWal(pPager) );†ŸH    /* Write the data read from the journal back into the database file.ŸH    ** This is usually safe even for an encrypted database - as the dataŸM    ** was encrypted before it was written to the journal file. The exceptionŸJ    ** is if the data was just read from an in-memory sub-journal. In thatŸK    ** case it must be encrypted here before it is copied into the database∞    ** file.  */∑#ifdef SQLITE_HAS_CODEC≥    if( !jrnlEnc ){ŸB      CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT, aData);ŸK      rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);Ÿ;      CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);©    }else¶#endifŸI    rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);†Ÿ"    if( pgno>pPager->dbFileSize ){Ÿ       pPager->dbFileSize = pgno;•    }∫    if( pPager->pBackup ){∑#ifdef SQLITE_HAS_CODEC¥      if( jrnlEnc ){Ÿ=        CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);Ÿ?        sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);ŸC        CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT,aData);´      }else¶#endifŸ=      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);•    }Ÿ$  }else if( !isMainJrnl && pPg==0 ){ŸG    /* If this is a rollback of a savepoint and data was not written toŸG    ** the database and the page is not in-memory, there is a potentialŸF    ** problem. When the page is next fetched by the b-tree layer, it ŸD    ** will be read from the database file, which may or may not be ∞    ** current. ¶    **ŸJ    ** There are a couple of different ways this can happen. All are quiteŸG    ** obscure. When running in synchronous mode, this can only happen ŸL    ** if the page is on the free-list at the start of the transaction, thenŸ:    ** populated, then moved using sqlite3PagerMovepage().¶    **ŸG    ** The solution is to add an in-memory page to the cache containingŸG    ** the data just read from the sub-journal. Mark the page as dirty ŸG    ** and if the pager requires a journal-sync, then mark the page as Ÿ5    ** requiring a journal-sync before it is written.¶    */∏    assert( isSavepnt );Ÿ;    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)==0 );Ÿ-    pPager->doNotSpill |= SPILLFLAG_ROLLBACK;Ÿ0    rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);Ÿ;    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)!=0 );Ÿ.    pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;Ÿ"    if( rc!=SQLITE_OK ) return rc;Ÿ     sqlite3PcacheMakeDirty(pPg);£  }¨  if( pPg ){ŸK    /* No page should ever be explicitly rolled back that is in use, exceptŸG    ** for page 1 which is held in use in order to keep the lock on theŸJ    ** database active. However such a page may be rolled back as a resultŸ=    ** of an internal error resulting in an automatic call toæ    ** sqlite3PagerRollback().¶    */∞    void *pData;∑    pData = pPg->pData;Ÿ0    memcpy(pData, (u8*)aData, pPager->pageSize);ª    pPager->xReiniter(pPg);ŸK    /* It used to be that sqlite3PcacheMakeClean(pPg) was called here.  ButŸL    ** that call was dangerous and had no detectable benefit since the cacheŸK    ** is normally cleaned by sqlite3PcacheCleanAll() after rollback and soª    ** has been removed. */º    pager_set_pagehash(pPg);†ŸF    /* If this was page 1, then restore the value of Pager.dbFileVers.Ÿ&    ** Do this before any decoding. */≤    if( pgno==1 ){ŸP      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));•    }†Ÿ-    /* Decode the page just read from disk */¥#if SQLITE_HAS_CODECŸO    if( jrnlEnc ){ CODEC1(pPager, pData, pPg->pgno, 3, rc=SQLITE_NOMEM_BKPT); }¶#endifæ    sqlite3PcacheRelease(pPg);£  }¨  return rc;°}†¢/*ŸK** Parameter zMaster is the name of a master journal file. A single journalŸK** file that referred to the master journal file has just been rolled back.ŸK** This routine checks if it is possible to delete the master journal file,∏** and does so if it is.¢**ŸH** Argument zMaster may point to Pager.pTmpSpace. So that buffer is not Ÿ*** available for use within this function.¢**ŸI** When a master journal file is created, it is populated with the names ŸG** of all of its child journals, one after another, formatted as utf-8 ŸE** encoded text. The end of each child journal file is marked with a ŸK** nul-terminator byte (0x00). i.e. the entire contents of a master journalŸ;** file for a transaction involving two databases might be:¢**Ÿ=**   "/home/bill/a.db-journal\x00/home/bill/b.db-journal\x00"¢**ŸC** A master journal file may only be deleted once all of its child Ÿ"** journals have been rolled back.¢**ŸD** This function reads the contents of the master-journal file into Ÿ@** memory and loops through each of the child journal names. ForŸ$** each child journal, it checks if:¢**Ÿ-**   * if the child journal exists, and if soŸC**   * if the child journal contains a reference to master journal ≥**     file zMaster¢**ŸD** If a child journal can be found that matches both of the criteriaŸE** above, this function returns without doing anything. Otherwise, ifŸC** no such child journal can be found, file zMaster is deleted fromŸ+** the file-system using sqlite3OsDelete().¢**ŸG** If an IO error within this function, an error code is returned. ThisŸI** function allocates memory by calling sqlite3Malloc(). If an allocationŸI** fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors Ÿ ** occur, SQLITE_OK is returned.¢**ŸA** TODO: This function allocates a single block of memory to loadŸ@** the entire contents of the master journal file. This could beŸB** a couple of kilobytes or so - potentially larger than the page ®** size.¢*/Ÿ?static int pager_delmaster(Pager *pPager, const char *zMaster){Ÿ#  sqlite3_vfs *pVfs = pPager->pVfs;Ÿ-  int rc;                   /* Return code */ŸI  sqlite3_file *pMaster;    /* Malloc'd master-journal file descriptor */ŸH  sqlite3_file *pJournal;   /* Malloc'd child-journal file descriptor */ŸA  char *zMasterJournal = 0; /* Contents of master journal file */Ÿ=  i64 nMasterJournal;       /* Size of master journal file */ŸG  char *zJournal;           /* Pointer to one journal within MJ file */ŸO  char *zMasterPtr;         /* Space to hold MJ filename from a journal file */ŸK  int nMasterPtr;           /* Amount of space allocated to zMasterPtr[] */†ŸG  /* Allocate space for both the pJournal and pMaster file descriptors.Ÿ=  ** If successful, open the master journal file for reading.§  */ŸB  pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);Ÿ@  pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);±  if( !pMaster ){ª    rc = SQLITE_NOMEM_BKPT;®  }else{ŸH    const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL);Ÿ9    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);£  }Ÿ)  if( rc!=SQLITE_OK ) goto delmaster_out;†ŸA  /* Load the entire master journal file into space obtained fromŸE  ** sqlite3_malloc() and pointed to by zMasterJournal.   Also obtainŸA  ** sufficient space (in zMasterPtr) to hold the names of masterŸ<  ** journal files extracted from regular rollback-journals.§  */Ÿ3  rc = sqlite3OsFileSize(pMaster, &nMasterJournal);Ÿ)  if( rc!=SQLITE_OK ) goto delmaster_out;Ÿ"  nMasterPtr = pVfs->mxPathname+1;ŸB  zMasterJournal = sqlite3Malloc(nMasterJournal + nMasterPtr + 1);∏  if( !zMasterJournal ){ª    rc = SQLITE_NOMEM_BKPT;∑    goto delmaster_out;£  }Ÿ1  zMasterPtr = &zMasterJournal[nMasterJournal+1];ŸF  rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);Ÿ)  if( rc!=SQLITE_OK ) goto delmaster_out;Ÿ%  zMasterJournal[nMasterJournal] = 0;†º  zJournal = zMasterJournal;Ÿ4  while( (zJournal-zMasterJournal)<nMasterJournal ){Ø    int exists;ŸH    rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);∏    if( rc!=SQLITE_OK ){π      goto delmaster_out;•    }±    if( exists ){ŸE      /* One of the journals pointed to by the master journal exists.ŸA      ** Open it and check if it points at the master journal. IfŸ=      ** so, return without deleting the master journal file.®      */¨      int c;ŸB      int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL);Ÿ=      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);∫      if( rc!=SQLITE_OK ){ª        goto delmaster_out;ß      }†Ÿ?      rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);ø      sqlite3OsClose(pJournal);∫      if( rc!=SQLITE_OK ){ª        goto delmaster_out;ß      }†Ÿ=      c = zMasterPtr[0]!=0 && strcmp(zMasterPtr, zMaster)==0;Æ      if( c ){ŸE        /* We have a match. Do not delete the master journal file. */ª        goto delmaster_out;ß      }•    }Ÿ.    zJournal += (sqlite3Strlen30(zJournal)+1);£  }° ∫  sqlite3OsClose(pMaster);Ÿ)  rc = sqlite3OsDelete(pVfs, zMaster, 0);†Ædelmaster_out:ø  sqlite3_free(zMasterJournal);∞  if( pMaster ){º    sqlite3OsClose(pMaster);Ÿ     assert( !isOpen(pJournal) );∫    sqlite3_free(pMaster);£  }¨  return rc;°}††¢/*ŸC** This function is used to change the actual size of the database ŸL** file in the file-system. This only happens when committing a transaction,ŸH** or rolling back a transaction (including rolling back a hot-journal).¢**ŸG** If the main database file is not open, or the pager is not in eitherŸF** DBMOD or OPEN state, this function is a no-op. Otherwise, the size ŸI** of the file is changed to nPage pages (nPage*pPager->pageSize bytes). ŸM** If the file on disk is currently larger than nPage pages, then use the VFSŸ%** xTruncate() method to truncate it.¢**ŸB** Or, it might be the case that the file on disk is smaller than ŸJ** nPage pages. Some operating system implementations can get confused if ŸB** you try to truncate a file to some size that is larger than it ŸE** currently is, so detect this case and write a single zero byte to Ÿ#** the end of the new file instead.¢**ŸI** If successful, return SQLITE_OK. If an IO error occurs while modifyingŸ:** the database file, return the error code to the caller.¢*/Ÿ5static int pager_truncate(Pager *pPager, Pgno nPage){µ  int rc = SQLITE_OK;Ÿ(  assert( pPager->eState!=PAGER_ERROR );Ÿ)  assert( pPager->eState!=PAGER_READER );¢  π  if( isOpen(pPager->fd) ŸI   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN) §  ){Ω    i64 currentSize, newSize;Ÿ"    int szPage = pPager->pageSize;Ÿ,    assert( pPager->eLock==EXCLUSIVE_LOCK );Ÿ8    /* TODO: Is it safe to use Pager.dbFileSize here? */Ÿ5    rc = sqlite3OsFileSize(pPager->fd, &currentSize);Ÿ     newSize = szPage*(i64)nPage;Ÿ0    if( rc==SQLITE_OK && currentSize!=newSize ){Ÿ       if( currentSize>newSize ){Ÿ4        rc = sqlite3OsTruncate(pPager->fd, newSize);Ÿ0      }else if( (currentSize+szPage)<=newSize ){Ÿ'        char *pTmp = pPager->pTmpSpace;Ÿ         memset(pTmp, 0, szPage);Ÿ4        testcase( (newSize-szPage) == currentSize );Ÿ4        testcase( (newSize-szPage) >  currentSize );ŸF        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);ß      }∫      if( rc==SQLITE_OK ){Ÿ#        pPager->dbFileSize = nPage;ß      }•    }£  }¨  return rc;°}†¢/*ŸF** Return a sanitized version of the sector-size of OS file pFile. TheŸD** return value is guaranteed to lie between 32 and MAX_SECTOR_SIZE.¢*/Ÿ:SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *pFile){Ÿ(  int iRet = sqlite3OsSectorSize(pFile);∞  if( iRet<32 ){Ø    iRet = 512;Ÿ#  }else if( iRet>MAX_SECTOR_SIZE ){Ÿ#    assert( MAX_SECTOR_SIZE>=512 );ª    iRet = MAX_SECTOR_SIZE;£  }Æ  return iRet;°}†¢/*Ÿ?** Set the value of the Pager.sectorSize variable for the givenŸ>** pager based on the value returned by the xSectorSize methodŸ;** of the open database file. The sector size will be used Ÿ=** to determine the size and alignment of journal header and Ÿ8** master journal pointers within created journal files.¢**ŸE** For temporary files the effective sector size is always 512 bytes.¢**ŸC** Otherwise, for non-temporary files, the effective sector size isŸE** the value returned by the xSectorSize() method rounded up to 32 ifŸ?** it is less than 32, or rounded down to MAX_SECTOR_SIZE if itŸ#** is greater than MAX_SECTOR_SIZE.¢**ŸJ** If the file has the SQLITE_IOCAP_POWERSAFE_OVERWRITE property, then setŸH** the effective sector size to its minimum value (512).  The purpose ofŸC** pPager->sectorSize is to define the "blast radius" of bytes thatŸC** might change if a crash occurs while writing to a single byte inŸF** that range.  But with POWERSAFE_OVERWRITE, the blast radius is zeroŸF** (that is what POWERSAFE_OVERWRITE means), so we minimize the sectorŸJ** size.  For backwards compatibility of the rollback journal file format,Ÿ8** we cannot reduce the effective sector size below 512.¢*/Ÿ)static void setSectorSize(Pager *pPager){Ÿ3  assert( isOpen(pPager->fd) || pPager->tempFile );†∂  if( pPager->tempFileŸ4   || (sqlite3OsDeviceCharacteristics(pPager->fd) & Ÿ2              SQLITE_IOCAP_POWERSAFE_OVERWRITE)!=0§  ){ŸE    /* Sector size doesn't matter for temporary files. Also, the fileŸE    ** may not have been opened yet, in which case the OsSectorSize()Ω    ** call will segfault. */Ω    pPager->sectorSize = 512;®  }else{Ÿ7    pPager->sectorSize = sqlite3SectorSize(pPager->fd);£  }°}†¢/*Ÿ=** Playback the journal and thus restore the database file toŸ:** the state it was in before we started making changes.  ¢**Ÿ*** The journal file format is as follows: ¢**Ÿ3**  (1)  8 byte prefix.  A copy of aJournalMagic[].ŸL**  (2)  4 byte big-endian integer which is the number of valid page recordsŸG**       in the journal.  If this value is 0xffffffff, then compute theŸ6**       number of page records from the journal size.ŸF**  (3)  4 byte big-endian integer which is the initial value for the π**       sanity checksum.ŸD**  (4)  4 byte integer which is the number of pages to truncate theŸ'**       database to during a rollback.ŸH**  (5)  4 byte big-endian integer which is the sector size.  The headerŸ$**       is this many bytes in size.Ÿ:**  (6)  4 byte big-endian integer which is the page size.Ÿ2**  (7)  zero padding out to the next sector size.Ÿ7**  (8)  Zero or more pages instances, each as follows:Ÿ **        +  4 byte page number.Ÿ,**        +  pPager->pageSize bytes of data.º**        +  4 byte checksum¢**ŸH** When we speak of the journal header, we mean the first 7 items above.Ÿ<** Each entry in the journal is an instance of the 8th item.¢**ŸG** Call the value from the second bullet "nRec".  nRec is the number ofŸI** valid page entries in the journal.  In most cases, you can compute theŸC** value of nRec from the size of the journal file.  But if a powerŸH** failure occurred while the journal was being written, it could be theŸH** case that the size of the journal file had already been increased butŸI** the extra entries had not yet made it safely to disk.  In such a case,ŸI** the value of nRec computed from the file size would be too large.  ForŸ;** that reason, we always use the nRec value in the header.¢**ŸH** If the nRec value is 0xffffffff it means that nRec should be computedŸD** from the file size.  This value is used when the user selects theŸL** no-sync option for the journal.  A power failure could lead to corruptionŸD** in this case.  But for things like temporary table (which will beŸ7** deleted when the power is restored) we don't care.  ¢**Ÿ>** If the file opened as the journal file is not a well-formedŸH** journal file then all pages up to the first corrupted page are rolledŸJ** back (or no pages if the journal header is corrupted). The journal fileŸG** is then deleted and SQLITE_OK returned, just as if no corruption had¥** been encountered.¢**ŸF** If an I/O or malloc() error occurs, the journal-file is not deletedŸ!** and an error code is returned.¢**ŸI** The isHot parameter indicates that we are trying to rollback a journalŸE** that might be a hot journal.  Or, it could be that the journal is ŸD** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.ŸD** If the journal really is hot, reset the pager cache prior rollingŸF** back any content.  If the journal is merely persistent, no reset is™** needed.¢*/Ÿ4static int pager_playback(Pager *pPager, int isHot){Ÿ#  sqlite3_vfs *pVfs = pPager->pVfs;ŸB  i64 szJ;                 /* Size of the journal file in bytes */ŸA  u32 nRec;                /* Number of Records in the journal */Ÿ6  u32 u;                   /* Unsigned loop counter */ŸC  Pgno mxPg = 0;           /* Size of the original file in pages */Ÿ<  int rc;                  /* Result code of a subroutine */ŸD  int res = 1;             /* Value returned by sqlite3OsAccess() */ŸC  char *zMaster = 0;       /* Name of master journal file if any */ŸP  int needPagerReset;      /* True to reset page prior to first page rollback */ŸL  int nPlayback = 0;       /* Total number of pages restored from journal */Ÿ'  u32 savedPageSize = pPager->pageSize;†ŸD  /* Figure out how many records are in the journal.  Abort early if∫  ** the journal is empty.§  */Ÿ   assert( isOpen(pPager->jfd) );Ÿ,  rc = sqlite3OsFileSize(pPager->jfd, &szJ);∂  if( rc!=SQLITE_OK ){∂    goto end_playback;£  }†ŸE  /* Read the master journal name from the journal, if it is present.ŸD  ** If a master journal file name is specified, but the file is notŸI  ** present on disk, then the journal is not hot and does not need to be±  ** played back.§  **ŸH  ** TODO: Technically the following is an error because it assumes thatŸH  ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. thatŸG  ** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,ŸH  ** mxPathname is 512, which is the same as the minimum allowable value≤  ** for pageSize.§  */æ  zMaster = pPager->pTmpSpace;ŸK  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);Ÿ$  if( rc==SQLITE_OK && zMaster[0] ){ŸD    rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);£  }Æ  zMaster = 0;æ  if( rc!=SQLITE_OK || !res ){∂    goto end_playback;£  }π  pPager->journalOff = 0;π  needPagerReset = isHot;†Ÿ<  /* This loop terminates either when a readJournalHdr() or ŸG  ** pager_playback_one_page() call returns SQLITE_DONE or an IO error ≠  ** occurs. §  */≠  while( 1 ){ŸH    /* Read the next journal header from the journal file.  If there areŸJ    ** not enough bytes left in the journal file for a complete header, orŸI    ** it is corrupted, then a process must have failed while writing it.Ÿ;    ** This indicates nothing more needs to be rolled back.¶    */Ÿ:    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);π    if( rc!=SQLITE_OK ){ º      if( rc==SQLITE_DONE ){∑        rc = SQLITE_OK;ß      }∏      goto end_playback;•    }†ŸH    /* If nRec is 0xffffffff, then this journal was created by a processŸG    ** working in no-sync mode. This means that the rest of the journalŸI    ** file consists of pages, there are no more journal headers. ComputeŸ2    ** the value of nRec based on this assumption.¶    */ª    if( nRec==0xffffffff ){Ÿ;      assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );ŸI      nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));•    }†ŸI    /* If nRec is 0 and this rollback is of a transaction created by thisŸL    ** process and if this is the final header in the journal, then it meansŸJ    ** that this part of the journal was being filled but has not yet beenŸJ    ** synced to disk.  Compute the number of pages based on the remaining∏    ** size of the file.¶    **Ÿ@    ** The third term of the test was added to fix ticket #2565.ŸJ    ** When rolling back a hot journal, nRec==0 always means that the nextŸG    ** chunk of the journal contains zero pages to be rolled back.  ButŸG    ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk inŸF    ** the journal, it means that the journal might contain additionalŸF    ** pages that need to be rolled back and that the number of pages Ÿ9    ** should be computed based on the journal file size.¶    */º    if( nRec==0 && !isHot &&ŸH        pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){ŸG      nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));•    }†ŸF    /* If this is the first header read from the journal, truncate theŸ/    ** database file back to its original size.¶    */Ÿ5    if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){Ÿ(      rc = pager_truncate(pPager, mxPg);∫      if( rc!=SQLITE_OK ){∫        goto end_playback;ß      }º      pPager->dbSize = mxPg;•    }†Ÿ@    /* Copy original pages out of the journal and back into the Ÿ'    ** database file and/or page cache.¶    */∫    for(u=0; u<nRec; u++){ª      if( needPagerReset ){º        pager_reset(pPager);ª        needPagerReset = 0;ß      }ŸE      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);∫      if( rc==SQLITE_OK ){¥        nPlayback++;¨      }else{æ        if( rc==SQLITE_DONE ){Ÿ#          pPager->journalOff = szJ;∞          break;Ÿ0        }else if( rc==SQLITE_IOERR_SHORT_READ ){ŸG          /* If the journal has been truncated, simply stop reading andŸI          ** processing the journal. This might happen if the journal wasŸI          ** not completely written and synced prior to a crash.  In thatŸE          ** case, the database should have never been written in theŸG          ** first place so it is OK to simply abandon the rollback. */π          rc = SQLITE_OK;º          goto end_playback;Æ        }else{ŸD          /* If we are unable to rollback, quit and return the errorŸF          ** code.  This will cause the pager to enter the error stateŸD          ** so that no further harm will be done.  Perhaps the nextŸI          ** process to come along will be able to rollback the database.¨          */º          goto end_playback;©        }ß      }•    }£  }∞  /*NOTREACHED*/Æ  assert( 0 );†≠end_playback:∂  if( rc==SQLITE_OK ){Ÿ=    rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);£  }ŸK  /* Following a rollback, the database file should be back in its originalŸ?  ** state prior to the start of the transaction, so invoke theŸA  ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable theŸ9  ** assertion that the transaction counter was modified.§  */≥#ifdef SQLITE_DEBUGŸC  sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);¶#endif†ŸI  /* If this playback is happening automatically as a result of an IO or ŸI  ** malloc error that occurred after the change-counter was updated but ŸC  ** before the transaction was committed, then the change-counter ŸL  ** modification may just have been reverted. If this happens in exclusive ŸL  ** mode, then subsequent transactions performed by the connection will notŸK  ** update the change-counter at all. This may lead to cache inconsistencyŸG  ** problems for other processes at some point in the future. So, justŸC  ** in case this has happened, clear the changeCountDone flag now.§  */Ÿ-  pPager->changeCountDone = pPager->tempFile;†∂  if( rc==SQLITE_OK ){Ÿ     zMaster = pPager->pTmpSpace;ŸM    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);æ    testcase( rc!=SQLITE_OK );£  }≥  if( rc==SQLITE_OKŸH   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)§  ){Ÿ%    rc = sqlite3PagerSync(pPager, 0);£  }∂  if( rc==SQLITE_OK ){Ÿ<    rc = pager_end_transaction(pPager, zMaster[0]!='\0', 0);æ    testcase( rc!=SQLITE_OK );£  }Ÿ+  if( rc==SQLITE_OK && zMaster[0] && res ){ŸJ    /* If there was a master journal and this routine will return success,Ÿ:    ** see if it is possible to delete the master journal.¶    */Ÿ*    rc = pager_delmaster(pPager, zMaster);æ    testcase( rc!=SQLITE_OK );£  }ª  if( isHot && nPlayback ){ŸM    sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",Ÿ-                nPlayback, pPager->zJournal);£  }†ŸF  /* The Pager.sectorSize variable may have been updated while rollingŸE  ** back a journal created by a process with a different sector sizeŸ;  ** value. Reset it to the correct value for this process.§  */∏  setSectorSize(pPager);¨  return rc;°}††¢/*ŸD** Read the content for page pPg out of the database file (or out ofŸ@** the WAL if that is where the most recent copy if found) into ŸD** pPg->pData. A shared lock or greater must be held on the databaseŸ'** file before this function is called.¢**ŸD** If page 1 is read, then the value of Pager.dbFileVers[] is set toŸ)** the value read from the database file.¢**ŸF** If an IO error occurs, then the IO error is returned to the caller.Ÿ$** Otherwise, SQLITE_OK is returned.¢*/Ÿ"static int readDbPage(PgHdr *pPg){ŸJ  Pager *pPager = pPg->pPager; /* Pager object associated with page pPg */Ÿ0  int rc = SQLITE_OK;          /* Return code */†∑#ifndef SQLITE_OMIT_WALŸA  u32 iFrame = 0;              /* Frame of WAL containing pgno */†Ÿ3  assert( pPager->eState>=PAGER_READER && !MEMDB );ø  assert( isOpen(pPager->fd) );†º  if( pagerUseWal(pPager) ){Ÿ?    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);∑    if( rc ) return rc;£  }Ø  if( iFrame ){ŸO    rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);ß  }else¶#endif£  {Ÿ6    i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;ŸJ    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);Ÿ&    if( rc==SQLITE_IOERR_SHORT_READ ){µ      rc = SQLITE_OK;•    }£  }†µ  if( pPg->pgno==1 ){≠    if( rc ){ŸG      /* If the read is unsuccessful, set the dbFileVers[] to somethingŸI      ** that will never be a valid file version.  dbFileVers[] is a copyŸH      ** of bytes 24..39 of the database.  Bytes 28..31 should always beŸJ      ** zero or the size of the database in page. Bytes 32..35 and 35..39ŸG      ** should be page numbers which are never 0xffffffff.  So fillingŸA      ** pPager->dbFileVers[] with all 0xff bytes should suffice.®      **ŸI      ** For an encrypted database, the situation is more complex:  bytesŸH      ** 24..39 of the database are white noise.  But the probability ofŸF      ** white noise equaling 16 bytes of 0xff is vanishingly small soø      ** we should still be ok.®      */ŸC      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));™    }else{Ÿ.      u8 *dbFileVers = &((u8*)pPg->pData)[24];ŸJ      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));•    }£  }ŸC  CODEC1(pPager, pPg->pData, pPg->pgno, 3, rc = SQLITE_NOMEM_BKPT);†Ÿ)  PAGER_INCR(sqlite3_pager_readdb_count);º  PAGER_INCR(pPager->nRead);Ÿ/  IOTRACE(("PGIN %p %d\n", pPager, pPg->pgno));Ÿ.  PAGERTRACE(("FETCH %d page %d hash(%08x)\n",ŸA               PAGERID(pPager), pPg->pgno, pager_pagehash(pPg)));†¨  return rc;°}†¢/*ŸA** Update the value of the change-counter at offsets 24 and 92 inŸ9** the header and the sqlite version number at offset 96.¢**ŸL** This is an unconditional update.  See also the pager_incr_changecounter()ŸJ** routine which only updates the change-counter if the update is actuallyŸG** needed, as determined by the pPager->changeCountDone state variable.¢*/Ÿ2static void pager_write_changecounter(PgHdr *pPg){µ  u32 change_counter;†ŸC  /* Increment the value just read and write it back to byte 24. */ŸC  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;Ÿ4  put32bits(((char*)pPg->pData)+24, change_counter);†Ÿ@  /* Also store the SQLite version number in bytes 96..99 and inŸG  ** bytes 92..95 store the change counter for which the version number±  ** is valid. */Ÿ4  put32bits(((char*)pPg->pData)+92, change_counter);Ÿ;  put32bits(((char*)pPg->pData)+96, SQLITE_VERSION_NUMBER);°}†∑#ifndef SQLITE_OMIT_WAL¢/*ŸE** This function is invoked once for each page that has already been ŸC** written into the log file when a WAL transaction is rolled back.ŸD** Parameter iPg is the page number of said page. The pCtx argument Ÿ0** is actually a pointer to the Pager structure.¢**ŸJ** If page iPg is present in the cache, and has no outstanding references,ŸC** it is discarded. Otherwise, if there are one or more outstandingŸE** references, the page content is reloaded from the database. If theŸF** attempt to reload content from the database is required and fails, Ÿ5** return an SQLite error code. Otherwise, SQLITE_OK.¢*/Ÿ3static int pagerUndoCallback(void *pCtx, Pgno iPg){µ  int rc = SQLITE_OK;Ÿ   Pager *pPager = (Pager *)pCtx;≠  PgHdr *pPg;†Ÿ   assert( pagerUseWal(pPager) );Ÿ(  pPg = sqlite3PagerLookup(pPager, iPg);¨  if( pPg ){Ÿ,    if( sqlite3PcachePageRefcount(pPg)==1 ){Ω      sqlite3PcacheDrop(pPg);™    }else{ª      rc = readDbPage(pPg);∫      if( rc==SQLITE_OK ){ø        pPager->xReiniter(pPg);ß      }Ÿ$      sqlite3PagerUnrefNotNull(pPg);•    }£  }†ŸH  /* Normally, if a transaction is rolled back, any backup processes areŸG  ** updated as data is copied out of the rollback journal and into theŸE  ** database. This is not generally possible with a WAL database, asŸH  ** rollback involves simply truncating the log file. Therefore, if oneŸH  ** or more frames have already been written to the log (and therefore ŸH  ** also copied into the backup databases) as part of this transaction,Ÿ#  ** the backups must be restarted.§  */Ÿ(  sqlite3BackupRestart(pPager->pBackup);†¨  return rc;°}†¢/*ŸG** This function is called to rollback a transaction on a WAL database.¢*/Ÿ+static int pagerRollbackWal(Pager *pPager){Ÿ3  int rc;                         /* Return Code */ŸE  PgHdr *pList;                   /* List of dirty pages to revert */†ŸH  /* For all pages in the cache that are currently dirty or have alreadyŸE  ** been written (but not committed) to the log file, do one of the Ø  ** following:§  **Ÿ5  **   + Discard the cached page (if refcount==0), orŸ?  **   + Reload page content from the database (if refcount>0).§  */Ÿ&  pPager->dbSize = pPager->dbOrigSize;ŸG  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);Ÿ2  pList = sqlite3PcacheDirtyList(pPager->pPCache);Ÿ"  while( pList && rc==SQLITE_OK ){Ÿ!    PgHdr *pNext = pList->pDirty;Ÿ8    rc = pagerUndoCallback((void *)pPager, pList->pgno);≤    pList = pNext;£  }†¨  return rc;°}†¢/*ŸK** This function is a wrapper around sqlite3WalFrames(). As well as loggingŸK** the contents of the list of pages headed by pList (connected by pDirty),ŸI** this function notifies any active backup processes that the pages have¨** changed. ¢**ŸN** The list of pages passed into this routine is always sorted by page number.ŸL** Hence, if page 1 appears anywhere on the list, it will be the first page.£*/ ∫static int pagerWalFrames(Ÿ4  Pager *pPager,                  /* Pager object */Ÿ=  PgHdr *pList,                   /* List of frames to log */ŸG  Pgno nTruncate,                 /* Database size after this commit */Ÿ@  int isCommit                    /* True if this is a commit */¢){Ÿ3  int rc;                         /* Return code */Ÿ@  int nList;                      /* Number of pages in pList */Ÿ>  PgHdr *p;                       /* For looping over pages */†π  assert( pPager->pWal );≤  assert( pList );≥#ifdef SQLITE_DEBUGŸ7  /* Verify that the page list is in accending order */Ÿ,  for(p=pList; p && p->pDirty; p=p->pDirty){Ÿ(    assert( p->pgno < p->pDirty->pgno );£  }¶#endif†Ÿ)  assert( pList->pDirty==0 || isCommit );±  if( isCommit ){ŸL    /* If a WAL transaction is being committed, there is no point in writingŸL    ** any pages with page numbers greater than nTruncate into the WAL file.ŸL    ** They will never be read by any client. So remove them from the pDirty¥    ** list here. */º    PgHdr **ppNext = &pList;Æ    nList = 0;Ÿ0    for(p=pList; (*ppNext = p)!=0; p=p->pDirty){ø      if( p->pgno<=nTruncate ){º        ppNext = &p->pDirty;∞        nList++;ß      }•    }¥    assert( pList );®  }else{Æ    nList = 1;£  }Ÿ+  pPager->aStat[PAGER_STAT_WRITE] += nList;†Ÿ8  if( pList->pgno==1 ) pager_write_changecounter(pList);Ÿ&  rc = sqlite3WalFrames(pPager->pWal, ŸH      pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags§  );Ÿ)  if( rc==SQLITE_OK && pPager->pBackup ){Ÿ!    for(p=pList; p; p=p->pDirty){ŸD      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);•    }£  }†π#ifdef SQLITE_CHECK_PAGESŸ2  pList = sqlite3PcacheDirtyList(pPager->pPCache);ø  for(p=pList; p; p=p->pDirty){∫    pager_set_pagehash(p);£  }¶#endif†¨  return rc;°}†¢/*Ÿ'** Begin a read transaction on the WAL.¢**ŸN** This routine used to be called "pagerOpenSnapshot()" because it essentiallyŸN** makes a snapshot of the database at the current point in time and preservesŸJ** that snapshot for use by the reader in spite of concurrently changes byŸ"** other writers or checkpointers.¢*/Ÿ4static int pagerBeginReadTransaction(Pager *pPager){Ÿ3  int rc;                         /* Return code */ŸC  int changed = 0;                /* True if cache must be reset */†Ÿ   assert( pagerUseWal(pPager) );ŸG  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );†ŸC  /* sqlite3WalEndReadTransaction() was not called for the previousŸC  ** transaction in locking_mode=EXCLUSIVE.  So call it now.  If weŸD  ** are in locking_mode=NORMAL and EndRead() was previously called,Ÿ$  ** the duplicate call is harmless.§  */Ÿ-  sqlite3WalEndReadTransaction(pPager->pWal);†Ÿ>  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);Ÿ!  if( rc!=SQLITE_OK || changed ){∏    pager_reset(pPager);Ÿ>    if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);£  }†¨  return rc;°}¶#endif†¢/*ŸD** This function is called as part of the transition from PAGER_OPENŸC** to PAGER_READER state to determine the size of the database fileŸH** in pages (assuming the page size currently stored in Pager.pageSize).¢**ŸI** If no error occurs, SQLITE_OK is returned and the size of the databaseŸC** in pages is stored in *pnPage. Otherwise, an error code (perhapsŸB** SQLITE_IOERR_FSTAT) is returned and *pnPage is left unmodified.¢*/Ÿ7static int pagerPagecount(Pager *pPager, Pgno *pnPage){ŸC  Pgno nPage;                     /* Value to return via *pnPage */†ŸD  /* Query the WAL sub-system for the database size. The WalDbsize()ŸJ  ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), orŸD  ** if the database size is not available. The database size is notŸB  ** available from the WAL sub-system if the log file is empty orŸ.  ** contains no valid committed transactions.§  */Ÿ'  assert( pPager->eState==PAGER_OPEN );Ÿ'  assert( pPager->eLock>=SHARED_LOCK );ø  assert( isOpen(pPager->fd) );Ÿ   assert( pPager->tempFile==0 );Ÿ)  nPage = sqlite3WalDbsize(pPager->pWal);†ŸE  /* If the number of pages in the database is not available from theŸB  ** WAL sub-system, determine the page count based on the size ofŸC  ** the database file.  If the size of the database file is not anŸ<  ** integer multiple of the page-size, round up the result.§  */Ÿ/  if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){Ÿ@    i64 n = 0;                    /* Size of db file in bytes */Ÿ/    int rc = sqlite3OsFileSize(pPager->fd, &n);∏    if( rc!=SQLITE_OK ){∞      return rc;•    }Ÿ>    nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);£  }†ŸC  /* If the current number of pages in the file is greater than theŸC  ** configured maximum pager number, increase the allowed limit soø  ** that the file can be read.§  */Ω  if( nPage>pPager->mxPgno ){Ÿ!    pPager->mxPgno = (Pgno)nPage;£  }†≤  *pnPage = nPage;≥  return SQLITE_OK;°}†∑#ifndef SQLITE_OMIT_WAL¢/*ŸL** Check if the *-wal file that corresponds to the database opened by pPagerŸI** exists if the database is not empy, or verify that the *-wal file doesŸ<** not exist (by deleting it) if the database file is empty.¢**ŸI** If the database is not empty and the *-wal file exists, open the pagerŸH** in WAL mode.  If the database is empty or if no *-wal file exists andŸ@** if no error occurs, make sure Pager.journalMode is not set toπ** PAGER_JOURNALMODE_WAL.¢**Ÿ%** Return SQLITE_OK or an error code.¢**ŸG** The caller must hold a SHARED lock on the database file to call thisŸL** function. Because an EXCLUSIVE lock on the db file is required to delete ŸK** a WAL on a none-empty database, this ensures there is no race condition ŸG** between the xAccess() below and an xDelete() being executed by some ¥** other connection.¢*/Ÿ0static int pagerOpenWalIfPresent(Pager *pPager){µ  int rc = SQLITE_OK;Ÿ'  assert( pPager->eState==PAGER_OPEN );Ÿ'  assert( pPager->eLock>=SHARED_LOCK );†∫  if( !pPager->tempFile ){Ÿ?    int isWal;                    /* True if WAL file exists */π    rc = sqlite3OsAccess(Ÿ@        pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal¶    );∏    if( rc==SQLITE_OK ){≤      if( isWal ){ŸE        Pgno nPage;                   /* Size of the database file */†Ÿ,        rc = pagerPagecount(pPager, &nPage);ª        if( rc ) return rc;∑        if( nPage==0 ){Ÿ>          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);Æ        }else{ŸA          testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );Ÿ.          rc = sqlite3PagerOpenWal(pPager, 0);©        }Ÿ=      }else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){Ÿ7        pPager->journalMode = PAGER_JOURNALMODE_DELETE;ß      }•    }£  }¨  return rc;°}¶#endif†¢/*ŸH** Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playbackŸI** the entire master journal file. The case pSavepoint==NULL occurs when ŸI** a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction ≠** savepoint.¢**ŸG** When pSavepoint is not NULL (meaning a non-transaction savepoint is ŸH** being rolled back), then the rollback consists of up to three stages,Ÿ$** performed in the order specified:¢**ŸC**   * Pages are played back from the main journal starting at byteŸ7**     offset PagerSavepoint.iOffset and continuing to ŸC**     PagerSavepoint.iHdrOffset, or to the end of the main journalŸ1**     file if PagerSavepoint.iHdrOffset is zero.¢**ŸF**   * If PagerSavepoint.iHdrOffset is not zero, then pages are playedŸC**     back starting from the journal header immediately following ŸE**     PagerSavepoint.iHdrOffset to the end of the main journal file.¢**ŸE**   * Pages are then played back from the sub-journal file, startingŸC**     with the PagerSavepoint.iSubRec and continuing to the end of∏**     the journal file.¢**ŸH** Throughout the rollback process, each time a page is rolled back, theŸH** corresponding bit is set in a bitvec structure (variable pDone in theŸD** implementation below). This is used to ensure that a page is onlyŸB** rolled back the first time it is encountered in either journal.¢**ŸG** If pSavepoint is NULL, then pages are only played back from the mainŸ<** journal file. There is no need for a bitvec in this case.¢**ŸF** In either case, before playback commences the Pager.dbSize variableŸD** is reset to the value that it held at the start of the savepoint ŸG** (or transaction). No page with a page-number greater than this valueŸ>** is played back. If one is encountered it is simply skipped.¢*/ŸMstatic int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){ŸC  i64 szJ;                 /* Effective size of the main journal */ŸM  i64 iHdrOff;             /* End of first segment of main-journal records */Ÿ,  int rc = SQLITE_OK;      /* Return code */ŸM  Bitvec *pDone = 0;       /* Bitvec to ensure pages played back only once */†Ÿ(  assert( pPager->eState!=PAGER_ERROR );Ÿ0  assert( pPager->eState>=PAGER_WRITER_LOCKED );†ŸF  /* Allocate a bitvec to use to store the set of pages rolled back */≥  if( pSavepoint ){Ÿ3    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);±    if( !pDone ){ø      return SQLITE_NOMEM_BKPT;•    }£  }†ŸI  /* Set the database size back to the value it was before the savepoint ø  ** being reverted was opened.§  */ŸG  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;Ÿ-  pPager->changeCountDone = pPager->tempFile;†Ÿ+  if( !pSavepoint && pagerUseWal(pPager) ){Ÿ$    return pagerRollbackWal(pPager);£  }†ŸF  /* Use pPager->journalOff as the effective size of the main rollbackŸ;  ** journal.  The actual file might be larger than this inŸK  ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anythingŸ1  ** past pPager->journalOff is off-limits to us.§  */ª  szJ = pPager->journalOff;Ÿ-  assert( pagerUseWal(pPager)==0 || szJ==0 );†ŸD  /* Begin by rolling back records from the main journal starting atŸF  ** PagerSavepoint.iOffset and continuing to the next journal header.ŸG  ** There might be records in the main journal that have a page numberŸF  ** greater than the current database size (pPager->dbSize) but thoseŸE  ** will be skipped automatically.  Pages are added to pDone as theyµ  ** are played back.§  */Ÿ+  if( pSavepoint && !pagerUseWal(pPager) ){ŸD    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;Ÿ-    pPager->journalOff = pSavepoint->iOffset;Ÿ9    while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){ŸM      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);•    }æ    assert( rc!=SQLITE_DONE );®  }else{ª    pPager->journalOff = 0;£  }†ŸF  /* Continue rolling back records out of the main journal starting atŸI  ** the first journal header seen and continuing until the effective endŸG  ** of the main journal file.  Continue to skip out-of-range pages andŸ0  ** continue adding pages rolled back to pDone.§  */Ÿ3  while( rc==SQLITE_OK && pPager->journalOff<szJ ){Ÿ)    u32 ii;            /* Loop counter */Ÿ6    u32 nJRec = 0;     /* Number of Journal Records */Æ    u32 dummy;Ÿ8    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);æ    assert( rc!=SQLITE_DONE );†¶    /*ŸJ    ** The "pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff"ŸB    ** test is related to ticket #2565.  See the discussion in theŸ<    ** pager_playback() function for additional information.¶    */±    if( nJRec==0 ŸE     && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff¶    ){ŸF      nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));•    }ŸI    for(ii=0; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){ŸM      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);•    }æ    assert( rc!=SQLITE_DONE );£  }Ÿ5  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );†ŸC  /* Finally,  rollback pages from the sub-journal.  Page that wereŸL  ** previously rolled back out of the main journal (and are hence in pDone)Ÿ;  ** will be skipped.  Out-of-range pages are also skipped.§  */≥  if( pSavepoint ){Ÿ)    u32 ii;            /* Loop counter */Ÿ?    i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);†æ    if( pagerUseWal(pPager) ){ŸG      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);•    }ŸK    for(ii=pSavepoint->iSubRec; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){Ÿ5      assert( offset==(i64)ii*(4+pPager->pageSize) );ŸA      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);•    }æ    assert( rc!=SQLITE_DONE );£  }†æ  sqlite3BitvecDestroy(pDone);∂  if( rc==SQLITE_OK ){Ω    pPager->journalOff = szJ;£  }†¨  return rc;°}†¢/*Ÿ@** Change the maximum number of in-memory pages that are allowedŸ7** before attempting to recycle clean and unused pages.¢*/ŸHSQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){Ÿ5  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);°}†¢/*Ÿ@** Change the maximum number of in-memory pages that are allowedŸ/** before attempting to spill pages to journal.¢*/ŸGSQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){Ÿ<  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);°}†¢/*ŸF** Invoke SQLITE_FCNTL_MMAP_SIZE based on the current value of szMmap.¢*/Ÿ,static void pagerFixMaplimit(Pager *pPager){∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ   sqlite3_file *fd = pPager->fd;Ÿ0  if( isOpen(fd) && fd->pMethods->iVersion>=3 ){µ    sqlite3_int64 sz;∏    sz = pPager->szMmap;ø    pPager->bUseFetch = (sz>0);º    setGetterMethod(pPager);ŸF    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);£  }¶#endif°}†¢/*ŸK** Change the maximum size of any memory mapping made of the database file.¢*/ŸRSQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){∫  pPager->szMmap = szMmap;ª  pagerFixMaplimit(pPager);°}†¢/*Ÿ2** Free as much memory as possible from the pager.¢*/Ÿ6SQLITE_PRIVATE void sqlite3PagerShrink(Pager *pPager){Ÿ'  sqlite3PcacheShrink(pPager->pPCache);°}†¢/*ŸL** Adjust settings of the pager to those specified in the pgFlags parameter.¢**ŸF** The "level" in pgFlags & PAGER_SYNCHRONOUS_MASK sets the robustnessŸC** of the database to damage due to OS crashes or power failures byŸ=** changing the number of syncs()s when writing the journals.π** There are four levels:¢**ŸE**    OFF       sqlite3OsSync() is never called.  This is the defaultŸ2**              for temporary and transient files.¢**ŸE**    NORMAL    The journal is synced once before writes begin on theŸD**              database.  This is normally adequate protection, butŸC**              it is theoretically possible, though very unlikely,ŸH**              that an inopertune power failure could leave the journalŸC**              in a state which would cause damage to the databaseŸ'**              when it is rolled back.¢**ŸF**    FULL      The journal is synced twice before writes begin on theŸK**              database (with some additional information - the nRec fieldŸH**              of the journal header - being written in between the twoŸ4**              syncs).  If we assume that writing aŸE**              single disk sector is atomic, then this mode providesŸG**              assurance that the journal will not be corrupted to theŸH**              point of causing damage to the database during rollback.¢**ŸI**    EXTRA     This is like FULL except that is also syncs the directoryŸE**              that contains the rollback journal after the rollbackŸ$**              journal is unlinked.¢**ŸI** The above is for a rollback-journal mode.  For WAL mode, OFF continuesŸI** to mean that no syncs ever occur.  NORMAL means that the WAL is syncedŸH** prior to the start of checkpoint and that the database file is syncedŸG** at the conclusion of the checkpoint if the entire content of the WALŸH** was written back into the database.  But no sync operations occur forŸG** an ordinary commit in NORMAL mode with WAL.  FULL means that the WALŸE** file is synced following each commit operation, in addition to theŸE** syncs associated with NORMAL.  There is no difference between FULL∫** and EXTRA for WAL mode.¢**Ÿ>** Do not confuse synchronous=FULL with SQLITE_SYNC_FULL.  TheŸB** SQLITE_SYNC_FULL macro means to use the MacOSX-style full-fsyncŸ?** using fcntl(F_FULLFSYNC).  SQLITE_SYNC_NORMAL means to do anŸJ** ordinary fsync() call.  There is no difference between SQLITE_SYNC_FULLŸB** and SQLITE_SYNC_NORMAL on platforms other than MacOSX.  But theŸE** synchronous=FULL versus synchronous=NORMAL setting determines whenŸB** the xSync primitive is called and is relevant to all platforms.¢**ŸD** Numeric values associated with these states are OFF==1, NORMAL=2,Æ** and FULL=3.¢*/Ÿ!#ifndef SQLITE_OMIT_PAGER_PRAGMASŸ)SQLITE_PRIVATE void sqlite3PagerSetFlags(Ÿ?  Pager *pPager,        /* The pager to set safety level for */Ÿ+  unsigned pgFlags      /* Various flags */¢){Ÿ4  unsigned level = pgFlags & PAGER_SYNCHRONOUS_MASK;π  if( pPager->tempFile ){∑    pPager->noSync = 1;π    pPager->fullSync = 0;∫    pPager->extraSync = 0;®  }else{Ÿ8    pPager->noSync =  level==PAGER_SYNCHRONOUS_OFF ?1:0;Ÿ:    pPager->fullSync = level>=PAGER_SYNCHRONOUS_FULL ?1:0;Ÿ<    pPager->extraSync = level==PAGER_SYNCHRONOUS_EXTRA ?1:0;£  }∑  if( pPager->noSync ){∫    pPager->syncFlags = 0;Ÿ(  }else if( pgFlags & PAGER_FULLFSYNC ){Ÿ)    pPager->syncFlags = SQLITE_SYNC_FULL;®  }else{Ÿ+    pPager->syncFlags = SQLITE_SYNC_NORMAL;£  }Ÿ0  pPager->walSyncFlags = (pPager->syncFlags<<2);π  if( pPager->fullSync ){Ÿ.    pPager->walSyncFlags |= pPager->syncFlags;£  }Ÿ<  if( (pgFlags & PAGER_CKPT_FULLFSYNC) && !pPager->noSync ){Ÿ2    pPager->walSyncFlags |= (SQLITE_SYNC_FULL<<2);£  }Ÿ#  if( pgFlags & PAGER_CACHESPILL ){Ÿ)    pPager->doNotSpill &= ~SPILLFLAG_OFF;®  }else{Ÿ(    pPager->doNotSpill |= SPILLFLAG_OFF;£  }°}¶#endif†¢/*ŸD** The following global variable is incremented whenever the libraryŸC** attempts to open a temporary file.  This information is used forø** testing and analysis only.  ¢*/≤#ifdef SQLITE_TESTŸ*SQLITE_API int sqlite3_opentemp_count = 0;¶#endif†¢/*π** Open a temporary file.¢**ŸF** Write the file descriptor into *pFile. Return SQLITE_OK on success ŸB** or some other error code if we fail. The OS will automatically Ÿ/** delete the temporary file when it is closed.¢**ŸE** The flags passed to the VFS layer xOpen() call are those specifiedŸ1** by parameter vfsFlags ORed with the following:¢**º**     SQLITE_OPEN_READWRITEπ**     SQLITE_OPEN_CREATEº**     SQLITE_OPEN_EXCLUSIVEŸ **     SQLITE_OPEN_DELETEONCLOSE¢*/πstatic int pagerOpentemp(Ÿ.  Pager *pPager,        /* The pager object */Ÿ<  sqlite3_file *pFile,  /* Write the file descriptor here */Ÿ=  int vfsFlags          /* Flags passed through to the VFS */¢){Ÿ)  int rc;               /* Return code */†≤#ifdef SQLITE_TESTŸE  sqlite3_opentemp_count++;  /* Used for testing and analysis only */¶#endif†Ÿ;  vfsFlags |=  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |Ÿ>            SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;Ÿ:  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);Ÿ+  assert( rc!=SQLITE_OK || isOpen(pFile) );¨  return rc;°}†¢/*Ÿ!** Set the busy handler function.¢**ŸA** The pager invokes the busy-handler if sqlite3OsLock() returns ŸD** SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,ŸB** or when trying to upgrade from a RESERVED lock to an EXCLUSIVE ŸB** lock. It does *not* invoke the busy handler when upgrading fromŸA** SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVEŸ7** (which occurs during hot-journal rollback). Summary:¢**Ÿ=**   Transition                        | Invokes xBusyHandlerŸ=**   --------------------------------------------------------Ÿ,**   NO_LOCK       -> SHARED_LOCK      | YesŸ+**   SHARED_LOCK   -> RESERVED_LOCK    | NoŸ+**   SHARED_LOCK   -> EXCLUSIVE_LOCK   | NoŸ,**   RESERVED_LOCK -> EXCLUSIVE_LOCK   | Yes¢**Ÿ>** If the busy-handler callback returns non-zero, the lock is Ÿ=** retried. If it returns zero, then the SQLITE_BUSY error isŸ4** returned to the caller of the pager API function.¢*/Ÿ/SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Ÿ9  Pager *pPager,                       /* Pager object */ŸM  int (*xBusyHandler)(void *),         /* Pointer to busy-handler function */ŸM  void *pBusyHandlerArg                /* Argument to pass to xBusyHandler */¢){¨  void **ap;Ÿ&  pPager->xBusyHandler = xBusyHandler;Ÿ,  pPager->pBusyHandlerArg = pBusyHandlerArg;Ÿ&  ap = (void **)&pPager->xBusyHandler;Ÿ4  assert( ((int(*)(void *))(ap[0]))==xBusyHandler );Ÿ#  assert( ap[1]==pBusyHandlerArg );ŸM  sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);°}†¢/*ŸD** Change the page size used by the Pager object. The new page size ª** is passed in *pPageSize.¢**ŸF** If the pager is in the error state when this function is called, itŸF** is a no-op. The value returned is the error state error code (i.e. ŸE** one of SQLITE_IOERR, an SQLITE_IOERR_xxx sub-code or SQLITE_FULL).¢**Ÿ/** Otherwise, if all of the following are true:¢**ŸA**   * the new page size (value of *pPageSize) is valid (a power ŸC**     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and¢**Ÿ4**   * there are no outstanding page references, and¢**Ÿ@**   * the database is either not an in-memory database or it isŸC**     an in-memory database that currently consists of zero pages.¢**Ÿ8** then the pager object page size is set to *pPageSize.¢**ŸM** If the page size is changed, then this function uses sqlite3PagerMalloc() ŸF** to obtain a new Pager.pTmpSpace buffer. If this allocation attempt ŸH** fails, SQLITE_NOMEM is returned and the page size remains unchanged. Ÿ-** In all other cases, SQLITE_OK is returned.¢**ŸH** If the page size is not changed, either because one of the enumeratedŸG** conditions above is not true, the pager was in error state when thisŸI** function was called, or because the memory allocation attempt failed, ŸJ** then *pPageSize is set to the old, retained page size before returning.¢*/ŸXSQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){µ  int rc = SQLITE_OK;†ŸG  /* It is not possible to do a full assert_pager_state() here, as thisŸE  ** function may be called from within PagerOpen(), before the stateŸ2  ** of the Pager object is internally consistent.§  **ŸF  ** At one point this function returned an error if the pager was in ŸC  ** PAGER_ERROR state. But since PAGER_ERROR state guarantees thatŸD  ** there is at least one outstanding page reference, this functionŸ%  ** is a no-op for that case anyhow.§  */†º  u32 pageSize = *pPageSize;ŸM  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );Ÿ-  if( (pPager->memDb==0 || pPager->dbSize==0)Ÿ0   && sqlite3PcacheRefCount(pPager->pPCache)==0 Ÿ2   && pageSize && pageSize!=(u32)pPager->pageSize §  ){Ÿ7    char *pNew = NULL;             /* New temp space */≤    i64 nByte = 0;†Ÿ:    if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){Ÿ1      rc = sqlite3OsFileSize(pPager->fd, &nByte);•    }∏    if( rc==SQLITE_OK ){Ÿ1      pNew = (char *)sqlite3PageMalloc(pageSize);Ÿ)      if( !pNew ) rc = SQLITE_NOMEM_BKPT;•    }†∏    if( rc==SQLITE_OK ){∫      pager_reset(pPager);Ÿ?      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);•    }∏    if( rc==SQLITE_OK ){Ÿ)      sqlite3PageFree(pPager->pTmpSpace);ø      pPager->pTmpSpace = pNew;Ÿ;      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);Ÿ"      pPager->pageSize = pageSize;™    }else{º      sqlite3PageFree(pNew);•    }£  }†Ÿ   *pPageSize = pPager->pageSize;∂  if( rc==SQLITE_OK ){Ÿ1    if( nReserve<0 ) nReserve = pPager->nReserve;Ÿ+    assert( nReserve>=0 && nReserve<1000 );Ÿ%    pPager->nReserve = (i16)nReserve;º    pagerReportSize(pPager);Ω    pagerFixMaplimit(pPager);£  }¨  return rc;°}†¢/*ŸB** Return a pointer to the "temporary page" buffer held internallyŸA** by the pager.  This is a buffer that is big enough to hold theŸE** entire content of a database page.  This buffer is used internallyŸ>** during rollback and will be overwritten whenever a rollbackŸ@** occurs.  But other modules are free to use it too, as long asæ** no rollbacks are happening.¢*/Ÿ:SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager *pPager){ª  return pPager->pTmpSpace;°}†¢/*ŸI** Attempt to set the maximum database page count if mxPage is positive. ŸG** Make no changes if mxPage is zero or negative.  And never reduce theŸ=** maximum page count below the current size of the database.¢**Ÿ?** Regardless of mxPage, return the current maximum page count.¢*/ŸGSQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){±  if( mxPage>0 ){º    pPager->mxPgno = mxPage;£  }ŸM  assert( pPager->eState!=PAGER_OPEN );      /* Called only by OP_MaxPgcnt */ŸL  assert( pPager->mxPgno>=pPager->dbSize );  /* OP_MaxPgcnt enforces this */∏  return pPager->mxPgno;°}†¢/*ŸB** The following set of routines are used to disable the simulatedŸC** I/O error mechanism.  These routines are used to avoid simulatedŸ6** errors in places where we do not care about errors.¢**Ÿ@** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops∏** and generate no code.¢*/≤#ifdef SQLITE_TESTŸ/SQLITE_API extern int sqlite3_io_error_pending;Ÿ+SQLITE_API extern int sqlite3_io_error_hit;µstatic int saved_cnt;Ÿ'void disable_simulated_io_errors(void){Ÿ'  saved_cnt = sqlite3_io_error_pending;Ÿ   sqlite3_io_error_pending = -1;°}Ÿ&void enable_simulated_io_errors(void){Ÿ'  sqlite3_io_error_pending = saved_cnt;°}•#elseŸ&# define disable_simulated_io_errors()Ÿ%# define enable_simulated_io_errors()¶#endif†¢/*ŸD** Read the first N bytes from the beginning of the file into memoryπ** that pDest points to. ¢**ŸB** If the pager was opened on a transient file (zFilename==""), orŸC** opened on a file less than N bytes in size, the output buffer isŸF** zeroed and SQLITE_OK returned. The rationale for this is that this ŸD** function is used to read database headers, and a new transient orŸE** zero sized database has a header than consists entirely of zeroes.¢**ŸE** If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,ŸC** the error code is returned to the caller and the contents of theª** output buffer undefined.¢*/ŸZSQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){µ  int rc = SQLITE_OK;∂  memset(pDest, 0, N);Ÿ3  assert( isOpen(pPager->fd) || pPager->tempFile );†ŸD  /* This routine is only called by btree immediately after creatingŸG  ** the Pager object.  There has not been an opportunity to transitionµ  ** to WAL mode yet.§  */Ÿ!  assert( !pagerUseWal(pPager) );†ª  if( isOpen(pPager->fd) ){Ÿ+    IOTRACE(("DBHDR %p 0 %d\n", pPager, N))Ÿ0    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);Ÿ&    if( rc==SQLITE_IOERR_SHORT_READ ){µ      rc = SQLITE_OK;•    }£  }¨  return rc;°}†¢/*ŸF** This function may only be called when a read-transaction is open onŸC** the pager. It returns the total number of pages in the database.¢**ŸI** However, if the file is between 1 and <page-size> bytes in size, then Ÿ$** this is considered a 1 page file.¢*/ŸFSQLITE_PRIVATE void sqlite3PagerPagecount(Pager *pPager, int *pnPage){Ÿ)  assert( pPager->eState>=PAGER_READER );Ÿ2  assert( pPager->eState!=PAGER_WRITER_FINISHED );Ÿ   *pnPage = (int)pPager->dbSize;°}††¢/*ŸA** Try to obtain a lock of type locktype on the database file. IfŸF** a similar or greater lock is already held, this function is a no-opŸ%** (returning SQLITE_OK immediately).¢**ŸG** Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke ŸD** the busy callback if the lock is currently not available. Repeat ŸA** until the busy callback returns false or until the attempt to º** obtain the lock succeeds.¢**ŸD** Return SQLITE_OK on success and an error code if we cannot obtainŸG** the lock. If the lock is obtained successfully, set the Pager.state Ÿ)** variable to locktype before returning.¢*/Ÿ;static int pager_wait_on_lock(Pager *pPager, int locktype){Ÿ8  int rc;                              /* Return code */†ŸF  /* Check that this is either a no-op (because the requested lock is ŸC  ** already held), or one of the transitions that the busy-handlerŸ:  ** may be invoked during, according to the comment aboveŸ"  ** sqlite3PagerSetBusyhandler().§  */Ÿ#  assert( (pPager->eLock>=locktype)Ÿ;       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)ŸD       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)§  );†¶  do {Ÿ'    rc = pagerLockDb(pPager, locktype);ŸM  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );¨  return rc;°}†¢/*ŸD** Function assertTruncateConstraint(pPager) checks that one of the ŸE** following is true for all dirty pages currently in the page-cache:¢**ŸA**   a) The page number is less than or equal to the size of the Ÿ,**      current database image, in pages, OR¢**ŸC**   b) if the page content were written at this time, it would notŸH**      be necessary to write the current content out to the sub-journalŸ7**      (as determined by function subjRequiresPage()).¢**ŸD** If the condition asserted by this function were not true, and theŸG** dirty page were to be discarded from the cache via the pagerStress()ŸE** routine, pagerStress() would not write the current page content toŸG** the database file. If a savepoint transaction were rolled back afterŸF** this happened, the correct behavior would be to restore the currentŸL** content of the page. However, since this content is not present in eitherŸ@** the database file or the portion of the rollback journal and ŸD** sub-journal rolled back the content could not be restored and theŸG** database image would become corrupt. It is therefore fortunate that Ÿ"** this circumstance cannot arise.¢*/π#if defined(SQLITE_DEBUG)Ÿ3static void assertTruncateConstraintCb(PgHdr *pPg){Ÿ#  assert( pPg->flags&PGHDR_DIRTY );ŸE  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );°}Ÿ4static void assertTruncateConstraint(Pager *pPager){ŸI  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);°}•#elseŸ)# define assertTruncateConstraint(pPager)¶#endif†¢/*ŸC** Truncate the in-memory database file image to nPage pages. This ŸC** function does not actually modify the database file on disk. It Ÿ@** just sets the internal state of the pager object so that the ŸE** truncation will be done when the current transaction is committed.¢**ŸF** This function is only called right before committing a transaction.ŸE** Once this function has been called, the transaction must either beŸE** rolled back or committed. It is not safe to call this function andŸ)** then continue writing to the database.¢*/ŸISQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){Ÿ"  assert( pPager->dbSize>=nPage );Ÿ2  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );π  pPager->dbSize = nPage;†ŸD  /* At one point the code here called assertTruncateConstraint() toŸF  ** ensure that all pages being truncated away by this operation are,ŸB  ** if one or more savepoints are open, present in the savepoint ŸD  ** journal so that they can be restored if the savepoint is rolledŸC  ** back. This is no longer necessary as this function is now onlyŸC  ** called right before committing a transaction. So although the ŸH  ** Pager object may still have open savepoints (Pager.nSavepoint!=0), ŸG  ** they cannot be rolled back. So the assertTruncateConstraint() callΩ  ** is no longer correct. */°}††¢/*ŸG** This function is called before attempting a hot-journal rollback. ItŸF** syncs the journal file to disk, then sets pPager->journalHdr to theŸF** size of the journal file so that the pager_playback() routine knowsŸ0** that the entire journal file has been synced.¢**ŸK** Syncing a hot-journal to disk before attempting to roll it back ensures ŸG** that if a power-failure occurs during the rollback, the process thatŸD** attempts rollback following system recovery sees the same journalª** content as this process.¢**ŸD** If everything goes as planned, SQLITE_OK is returned. Otherwise, ∏** an SQLite error code.¢*/Ÿ.static int pagerSyncHotJournal(Pager *pPager){µ  int rc = SQLITE_OK;∏  if( !pPager->noSync ){Ÿ8    rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);£  }∂  if( rc==SQLITE_OK ){Ÿ=    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);£  }¨  return rc;°}†∫#if SQLITE_MAX_MMAP_SIZE>0¢/*ŸK** Obtain a reference to a memory mapped page object for page number pgno. ŸE** The new object will use the pointer pData, obtained from xFetch().Ÿ@** If successful, set *ppPage to point to the new page referenceŸG** and return SQLITE_OK. Otherwise, return an SQLite error code and set≥** *ppPage to zero.¢**ŸG** Page references obtained by calling this function should be releasedŸ$** by calling pagerReleaseMapPage().¢*/østatic int pagerAcquireMapPage(Ÿ4  Pager *pPager,                  /* Pager object */Ÿ3  Pgno pgno,                      /* Page number */ŸE  void *pData,                    /* xFetch()'d data for this page */ŸA  PgHdr **ppPage                  /* OUT: Acquired page object */¢){ŸD  PgHdr *p;                       /* Memory mapped page to return */¢  æ  if( pPager->pMmapFreelist ){Ÿ(    *ppPage = p = pPager->pMmapFreelist;Ÿ&    pPager->pMmapFreelist = p->pDirty;≤    p->pDirty = 0;Ÿ     assert( pPager->nExtra>=8 );º    memset(p->pExtra, 0, 8);®  }else{ŸM    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);Ø    if( p==0 ){ŸL      sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);ø      return SQLITE_NOMEM_BKPT;•    }æ    p->pExtra = (void *)&p[1];∫    p->flags = PGHDR_MMAP;∞    p->nRef = 1;∑    p->pPager = pPager;£  }†Ÿ%  assert( p->pExtra==(void *)&p[1] );∏  assert( p->pPage==0 );Ÿ!  assert( p->flags==PGHDR_MMAP );æ  assert( p->pPager==pPager );∑  assert( p->nRef==1 );†±  p->pgno = pgno;≥  p->pData = pData;µ  pPager->nMmapOut++;†≥  return SQLITE_OK;°}¶#endif†¢/*ŸF** Release a reference to page pPg. pPg must have been returned by an Ÿ)** earlier call to pagerAcquireMapPage().¢*/Ÿ,static void pagerReleaseMapPage(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;µ  pPager->nMmapOut--;Ÿ&  pPg->pDirty = pPager->pMmapFreelist;æ  pPager->pMmapFreelist = pPg;†Ÿ.  assert( pPager->fd->pMethods->iVersion>=3 );ŸP  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);°}†¢/*ŸA** Free all PgHdr objects stored in the Pager.pMmapFreelist list.¢*/Ÿ,static void pagerFreeMapHdrs(Pager *pPager){´  PgHdr *p;Ø  PgHdr *pNext;Ÿ+  for(p=pPager->pMmapFreelist; p; p=pNext){∂    pNext = p->pDirty;¥    sqlite3_free(p);£  }°}†ŸG/* Verify that the database file has not be deleted or renamed out fromŸM** under the pager.  Return SQLITE_OK if the database is still where it oughtŸO** to be on disk.  Return non-zero (SQLITE_READONLY_DBMOVED or some other errorŸA** code from sqlite3OsAccess()) if the database has gone missing.¢*/Ÿ,static int databaseIsUnmoved(Pager *pPager){¥  int bHasMoved = 0;©  int rc;†Ÿ*  if( pPager->tempFile ) return SQLITE_OK;Ÿ+  if( pPager->dbSize==0 ) return SQLITE_OK;Ÿ6  assert( pPager->zFilename && pPager->zFilename[0] );ŸL  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);º  if( rc==SQLITE_NOTFOUND ){ŸK    /* If the HAS_MOVED file-control is unimplemented, assume that the fileŸO    ** has not been moved.  That is the historical behavior of SQLite: prior toŸ)    ** version 3.8.3, it never checked */≥    rc = SQLITE_OK;Ÿ)  }else if( rc==SQLITE_OK && bHasMoved ){Ÿ!    rc = SQLITE_READONLY_DBMOVED;£  }¨  return rc;°}††¢/*ŸA** Shutdown the page cache.  Free all memory and close all files.¢**ŸE** If a transaction was in progress when this routine is called, thatŸE** transaction is rolled back.  All outstanding pages are invalidatedŸC** and their memory is freed.  Any attempt to use a page associatedŸ?** with this page cache after this function returns will likely∏** result in a coredump.¢**ŸG** This function always succeeds. If a transaction is active an attemptŸC** is made to roll it back. If an error occurs during the rollback ŸG** a hot journal may be left in the filesystem but no error is returned±** to the caller.¢*/ŸASQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3 *db){Ÿ$  u8 *pTmp = (u8*)pPager->pTmpSpace;Ÿ)  assert( db || pagerUseWal(pPager)==0 );Ÿ'  assert( assert_pager_state(pPager) );Ÿ   disable_simulated_io_errors();Ω  sqlite3BeginBenignMalloc();ª  pagerFreeMapHdrs(pPager);º  /* pPager->errCode = 0; */º  pPager->exclusiveMode = 0;∑#ifndef SQLITE_OMIT_WAL£  {Æ    u8 *a = 0;Ÿ$    assert( db || pPager->pWal==0 );Ÿ4    if( db && 0==(db->flags & SQLITE_NoCkptOnClose) Ÿ,     && SQLITE_OK==databaseIsUnmoved(pPager)¶    ){Ø      a = pTmp;•    }ŸP    sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);µ    pPager->pWal = 0;£  }¶#endif∂  pager_reset(pPager);Æ  if( MEMDB ){π    pager_unlock(pPager);®  }else{ŸM    /* If it is open, sync the journal file before calling UnlockAndRollback.ŸI    ** If this is not done, then an unsynced portion of the open journal ŸL    ** file may be played back into the database. If a power failure occurs ŸB    ** while this is happening, the database could become corrupt.¶    **ŸK    ** If an error occurs while trying to sync the journal, shift the pagerŸH    ** into the ERROR state. This causes UnlockAndRollback to unlock theŸH    ** database and close the journal file without attempting to roll itŸN    ** back or finalize it. The next database user will have to do hot-journalŸ3    ** rollback before accessing the database file.¶    */æ    if( isOpen(pPager->jfd) ){Ÿ7      pager_error(pPager, pagerSyncHotJournal(pPager));•    }Ÿ#    pagerUnlockAndRollback(pPager);£  }ª  sqlite3EndBenignMalloc();ø  enable_simulated_io_errors();Ÿ.  PAGERTRACE(("CLOSE %d\n", PAGERID(pPager)));Ÿ!  IOTRACE(("CLOSE %p\n", pPager))æ  sqlite3OsClose(pPager->jfd);Ω  sqlite3OsClose(pPager->fd);∏  sqlite3PageFree(pTmp);Ÿ&  sqlite3PcacheClose(pPager->pPCache);†∑#ifdef SQLITE_HAS_CODECŸ>  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);¶#endif†Ÿ7  assert( !pPager->aSavepoint && !pPager->pInJournal );Ÿ:  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) );†∑  sqlite3_free(pPager);≥  return SQLITE_OK;°}†Ÿ,#if !defined(NDEBUG) || defined(SQLITE_TEST)¢/*Ÿ'** Return the page number for page pPg.¢*/Ÿ8SQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage *pPg){≥  return pPg->pgno;°}¶#endif†¢/*Ÿ.** Increment the reference count for page pPg.¢*/Ÿ1SQLITE_PRIVATE void sqlite3PagerRef(DbPage *pPg){∏  sqlite3PcacheRef(pPg);°}†¢/*ŸF** Sync the journal. In other words, make sure all the pages that haveŸG** been written to the journal have actually reached the surface of theŸC** disk and can be restored in the event of a hot-journal rollback.¢**ŸB** If the Pager.noSync flag is set, then this function is a no-op.ŸF** Otherwise, the actions required depend on the journal-mode and the Ÿ9** device characteristics of the file-system, as follows:¢**ŸG**   * If the journal file is an in-memory journal file, no action need∞**     be taken.¢**ŸJ**   * Otherwise, if the device does not support the SAFE_APPEND property,ŸF**     then the nRec field of the most recently written journal headerŸD**     is updated to contain the number of journal records that haveŸH**     been written following it. If the pager is operating in full-syncŸJ**     mode, then the journal file is synced before this field is updated.¢**ŸD**   * If the device does not support the SEQUENTIAL property, then æ**     journal file is synced.¢**∂** Or, in pseudo-code:¢**Ÿ#**   if( NOT <in-memory journal> ){Ω**     if( NOT SAFE_APPEND ){Ÿ6**       if( <full-sync mode> ) xSync(<journal file>);º**       <update nRec field>©**     } Ÿ2**     if( NOT SEQUENTIAL ) xSync(<journal file>);¶**   }¢**ŸH** If successful, this routine clears the PGHDR_NEED_SYNC flag of every ŸE** page currently held in memory before returning SQLITE_OK. If an IOŸJ** error is encountered, then the IO error code is returned to the caller.¢*/Ÿ2static int syncJournal(Pager *pPager, int newHdr){Ÿ3  int rc;                         /* Return code */†Ÿ/  assert( pPager->eState==PAGER_WRITER_CACHEMODŸ,       || pPager->eState==PAGER_WRITER_DBMOD§  );Ÿ'  assert( assert_pager_state(pPager) );Ÿ!  assert( !pagerUseWal(pPager) );†Ÿ)  rc = sqlite3PagerExclusiveLock(pPager);Ÿ   if( rc!=SQLITE_OK ) return rc;†∏  if( !pPager->noSync ){Ÿ     assert( !pPager->tempFile );ŸO    if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){ŸA      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);Ÿ$      assert( isOpen(pPager->jfd) );†Ÿ.      if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){ŸK        /* This block deals with an obscure problem. If the last connectionŸJ        ** that wrote to this database was operating in persistent-journalŸK        ** mode, then the journal file may at this point actually be largerŸH        ** than Pager.journalOff bytes. If the next thing in the journalŸF        ** file happens to be a journal-header (written as part of theŸL        ** previous connection's transaction), and a crash or power-failure ŸJ        ** occurs after nRec is updated but before this connection writes ŸH        ** anything else to the journal file (or commits/rolls back its ŸH        ** transaction), then SQLite may become confused when doing the ŸH        ** hot-journal rollback following recovery. It may roll back allŸJ        ** of this connections data, then proceed to rolling back the old,ŸA        ** out-of-date data that follows it. Database corruption.™        **ŸJ        ** To work around this, if the journal file does appear to containŸG        ** a valid header following Pager.journalOff, then write a 0x00ŸG        ** byte to the start of it to prevent it from being recognized.™        **ŸE        ** Variable iNextHdrOffset is set to the offset at which thisŸG        ** problematic header will occur, if it exists. aMagic is used ŸH        ** as a temporary buffer to inspect the first couple of bytes ofŸ(        ** the potential journal header.™        */ª        i64 iNextHdrOffset;µ        u8 aMagic[8];Ÿ,        u8 zHeader[sizeof(aJournalMagic)+4];†Ÿ>        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));ŸA        put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);†Ÿ2        iNextHdrOffset = journalHdrOffset(pPager);ŸC        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);ŸC        if( rc==SQLITE_OK && 0==memcmp(aMagic, aJournalMagic, 8) ){Ÿ'          static const u8 zerobyte = 0;ŸI          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);©        }Ÿ;        if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){¥          return rc;©        }†ŸC        /* Write the nRec value into the journal file header. If inŸK        ** full-synchronous mode, sync the journal first. This ensures thatŸJ        ** all data has really hit the disk before nRec is updated to markŸ*        ** it as a candidate for rollback.™        **ŸD        ** This is not required if the persistent media supports theŸI        ** SAFE_APPEND property. Because in this case it is not possible ŸF        ** for garbage data to be appended to the file, the nRec fieldŸJ        ** is populated with 0xFFFFFFFF when the journal header is writtenŸ)        ** and never needs to be updated.™        */ŸC        if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){Ÿ@          PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));Ÿ)          IOTRACE(("JSYNC %p\n", pPager))Ÿ=          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);Ÿ(          if( rc!=SQLITE_OK ) return rc;©        }Ÿ@        IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));º        rc = sqlite3OsWrite(ŸE            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr™        );Ÿ&        if( rc!=SQLITE_OK ) return rc;ß      }Ÿ-      if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){Ÿ>        PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));Ÿ'        IOTRACE(("JSYNC %p\n", pPager))Ÿ;        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags| ŸF          (pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)™        );Ÿ&        if( rc!=SQLITE_OK ) return rc;ß      }†Ÿ.      pPager->journalHdr = pPager->journalOff;Ÿ8      if( newHdr && 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){π        pPager->nRec = 0;Ÿ%        rc = writeJournalHdr(pPager);Ÿ&        if( rc!=SQLITE_OK ) return rc;ß      }™    }else{Ÿ.      pPager->journalHdr = pPager->journalOff;•    }£  }†ŸC  /* Unless the pager is in noSync mode, the journal file was just ŸH  ** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on Ø  ** all pages.§  */Ÿ/  sqlite3PcacheClearSyncFlags(pPager->pPCache);Ÿ&  pPager->eState = PAGER_WRITER_DBMOD;Ÿ'  assert( assert_pager_state(pPager) );≥  return SQLITE_OK;°}†¢/*ŸF** The argument is the first in a linked list of dirty pages connectedŸD** by the PgHdr.pDirty pointer. This function writes each one of theŸE** in-memory pages in the list to the database file. The argument mayŸE** be NULL, representing an empty list. In this case this function is´** a no-op.¢**ŸB** The pager must hold at least a RESERVED lock when this functionŸE** is called. Before writing anything to the database file, this lockŸD** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,ŸG** SQLITE_BUSY is returned and no data is written to the database file.£** ŸD** If the pager is a temp-file pager and the actual file-system fileŸ@** is not yet open, it is created and opened before any data is Ø** written out.¢**ŸF** Once the lock has been upgraded and, if necessary, the file opened,ŸH** the pages are written out to the database file in list order. WritingŸB** a page is skipped if it meets either of the following criteria:¢**Ÿ7**   * The page number is greater than Pager.dbSize, orŸ4**   * The PGHDR_DONT_WRITE flag is set on the page.¢**ŸK** If writing out a page causes the database file to grow, Pager.dbFileSizeŸJ** is updated accordingly. If page 1 is written out, then the value cachedŸD** in Pager.dbFileVers[] is updated to match the new value stored inµ** the database file.¢**ŸF** If everything is successful, SQLITE_OK is returned. If an IO error ŸI** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannotŸ(** be obtained, SQLITE_BUSY is returned.¢*/Ÿ=static int pager_write_pagelist(Pager *pPager, PgHdr *pList){Ÿ8  int rc = SQLITE_OK;                  /* Return code */†ŸO  /* This function is only called for rollback pagers in WRITER_DBMOD state. */Ÿ!  assert( !pagerUseWal(pPager) );ŸC  assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );Ÿ*  assert( pPager->eLock==EXCLUSIVE_LOCK );Ÿ3  assert( isOpen(pPager->fd) || pList->pDirty==0 );†ŸH  /* If the file is a temp-file has not yet been opened, open it now. ItŸE  ** is not possible for rc to be other than SQLITE_OK if this branchŸA  ** is taken, as pager_wait_on_lock() is a no-op for temp-files.§  */º  if( !isOpen(pPager->fd) ){Ÿ0    assert( pPager->tempFile && rc==SQLITE_OK );Ÿ=    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);£  }†ŸB  /* Before the first write, give the VFS a hint of what the final∑  ** file size will be.§  */Ÿ0  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );¥  if( rc==SQLITE_OK Ÿ'   && pPager->dbHintSize<pPager->dbSizeŸ7   && (pList->pDirty || pList->pgno>pPager->dbHintSize)§  ){ŸL    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;ŸJ    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);Ÿ(    pPager->dbHintSize = pPager->dbSize;£  }†Ÿ"  while( rc==SQLITE_OK && pList ){º    Pgno pgno = pList->pgno;†ŸK    /* If there are dirty pages in the page cache with page numbers greaterŸN    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called toŸK    ** make the file smaller (presumably by auto-vacuum code). Do not writeŸ"    ** any such pages to the file.¶    **ŸI    ** Also, do not write out any page that has the PGHDR_DONT_WRITE flagŸ,    ** set (set by sqlite3PagerDontWrite()).¶    */ŸE    if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){ŸJ      i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */ŸL      char *pData;                                   /* Data to write */    †Ÿ2      assert( (pList->flags&PGHDR_NEED_SYNC)==0 );Ÿ<      if( pList->pgno==1 ) pager_write_changecounter(pList);†ø      /* Encode the database */ŸM      CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM_BKPT, pData);†Ÿ$      /* Write out the page data. */ŸG      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);†ŸE      /* If page 1 was just written, update Pager.dbFileVers to matchŸD      ** the value now stored in the database file. If writing this ŸC      ** page caused the database file to grow, update dbFileSize. ®      */¥      if( pgno==1 ){ŸL        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));ß      }Ÿ$      if( pgno>pPager->dbFileSize ){Ÿ"        pPager->dbFileSize = pgno;ß      }Ÿ(      pPager->aStat[PAGER_STAT_WRITE]++;†ŸI      /* Update any backup objects copying the contents of this pager. */ŸD      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);†Ÿ2      PAGERTRACE(("STORE %d page %d hash(%08x)\n",ŸB                   PAGERID(pPager), pgno, pager_pagehash(pList)));Ÿ/      IOTRACE(("PGOUT %p %d\n", pPager, pgno));Ÿ.      PAGER_INCR(sqlite3_pager_writedb_count);™    }else{ŸB      PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));•    }æ    pager_set_pagehash(pList);∫    pList = pList->pDirty;£  }†¨  return rc;°}†¢/*ŸI** Ensure that the sub-journal file is open. If it is already open, this ∑** function is a no-op.¢**ŸB** SQLITE_OK is returned if everything goes according to plan. An ŸH** SQLITE_IOERR_XXX error code is returned if a call to sqlite3OsOpen() ©** fails.¢*/Ÿ)static int openSubJournal(Pager *pPager){µ  int rc = SQLITE_OK;æ  if( !isOpen(pPager->sjfd) ){ŸF    const int flags =  SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_READWRITE Ÿ3      | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE Ÿ"      | SQLITE_OPEN_DELETEONCLOSE;Ÿ.    int nStmtSpill = sqlite3Config.nStmtSpill;ŸP    if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){∂      nStmtSpill = -1;•    }ŸN    rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);£  }¨  return rc;°}†¢/*ŸH** Append a record of the current state of page pPg to the sub-journal. ¢**ŸG** If successful, set the bit corresponding to pPg->pgno in the bitvecsŸ,** for all open savepoints before returning.¢**ŸE** This function returns SQLITE_OK if everything is successful, an IOŸC** error code if the attempt to write to the sub-journal fails, or ŸD** SQLITE_NOMEM if a malloc fails while setting a bit in a savepoint™** bitvec.¢*/Ÿ&static int subjournalPage(PgHdr *pPg){µ  int rc = SQLITE_OK;æ  Pager *pPager = pPg->pPager;Ÿ3  if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){†ŸA    /* Open the sub-journal, if it has not already been opened */Ÿ!    assert( pPager->useJournal );Ÿ9    assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );Ÿ9    assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );Ÿ     assert( pagerUseWal(pPager) Ÿ'         || pageInJournal(pPager, pPg) Ÿ)         || pPg->pgno>pPager->dbOrigSize ¶    );Ÿ     rc = openSubJournal(pPager);†ŸH    /* If the sub-journal was opened successfully (or was already open),Ÿ2    ** write the journal record into the file.  */∏    if( rc==SQLITE_OK ){ø      void *pData = pPg->pData;Ÿ=      i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);≥      char *pData2;†∑#if SQLITE_HAS_CODEC   Ÿ"      if( !pPager->subjInMemory ){ŸN        CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);´      }else¶#endifµ      pData2 = pData;ŸL      PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));Ÿ8      rc = write32bits(pPager->sjfd, offset, pPg->pgno);∫      if( rc==SQLITE_OK ){ŸN        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);ß      }•    }£  }∂  if( rc==SQLITE_OK ){∂    pPager->nSubRec++;Ÿ#    assert( pPager->nSavepoint>0 );Ÿ2    rc = addToSavepointBitvecs(pPager, pPg->pgno);£  }¨  return rc;°}Ÿ0static int subjournalPageIfRequired(PgHdr *pPg){æ  if( subjRequiresPage(pPg) ){ø    return subjournalPage(pPg);®  }else{µ    return SQLITE_OK;£  }°}†¢/*ŸG** This function is called by the pcache layer when it has reached someŸG** soft memory limit. The first argument is a pointer to a Pager objectŸG** (cast as a void*). The pager is always 'purgeable' (not an in-memoryŸC** database). The second argument is a reference to a page that is Ÿ>** currently dirty but has no outstanding references. The pageŸB** is always associated with the Pager object passed as the first ¨** argument.¢**ŸH** The job of this function is to make pPg clean by writing its contentsŸF** out to the database file, if possible. This may involve syncing the±** journal file. ¢**ŸD** If successful, sqlite3PcacheMakeClean() is called on the page andŸE** SQLITE_OK returned. If an IO error occurs while trying to make theŸC** page clean, the IO error code is returned. If the page cannot beŸH** made clean for some other reason, but no error occurs, then SQLITE_OKŸ9** is returned by sqlite3PcacheMakeClean() is not called.¢*/Ÿ,static int pagerStress(void *p, PgHdr *pPg){Ω  Pager *pPager = (Pager *)p;µ  int rc = SQLITE_OK;†Ÿ   assert( pPg->pPager==pPager );Ÿ#  assert( pPg->flags&PGHDR_DIRTY );†ŸG  /* The doNotSpill NOSYNC bit is set during times when doing a sync ofŸC  ** journal (and adding a new header) is not allowed.  This occursŸI  ** during calls to sqlite3PagerWrite() while trying to journal multipleŸ(  ** pages belonging to the same sector.§  **ŸE  ** The doNotSpill ROLLBACK and OFF bits inhibits all cache spillingŸI  ** regardless of whether or not a sync is required.  This is set duringŸ1  ** a rollback or by user request, respectively.§  **ŸH  ** Spilling is also prohibited when in an error state since that couldŸE  ** lead to database corruption.   In the current implementation it ŸK  ** is impossible for sqlite3PcacheFetch() to be called with createFlag==3ŸI  ** while in the error state, hence it is impossible for this routine toŸF  ** be called in the error state.  Nevertheless, we include a NEVER()ŸD  ** test for the error state as a safeguard against future changes.§  */Ÿ0  if( NEVER(pPager->errCode) ) return SQLITE_OK;Ÿ6  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );Ÿ1  testcase( pPager->doNotSpill & SPILLFLAG_OFF );Ÿ4  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );∏  if( pPager->doNotSpillŸC   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0Ÿ+      || (pPg->flags & PGHDR_NEED_SYNC)!=0)§  ){µ    return SQLITE_OK;£  }†Ÿ$  pPager->aStat[PAGER_STAT_SPILL]++;≤  pPg->pDirty = 0;º  if( pagerUseWal(pPager) ){Ÿ8    /* Write a single frame for this page to the log. */Ÿ(    rc = subjournalPageIfRequired(pPg); ∏    if( rc==SQLITE_OK ){Ÿ-      rc = pagerWalFrames(pPager, pPg, 0, 0);•    }®  }else{§    Ÿ'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITEæ    if( pPager->tempFile==0 ){Ÿ-      rc = sqlite3JournalCreate(pPager->jfd);Ÿ9      if( rc!=SQLITE_OK ) return pager_error(pPager, rc);•    }¶#endif¢  Ÿ,    /* Sync the journal file if required. */Ÿ#    if( pPg->flags&PGHDR_NEED_SYNC Ÿ-     || pPager->eState==PAGER_WRITER_CACHEMOD¶    ){Ÿ"      rc = syncJournal(pPager, 1);•    }¢  ŸB    /* Write the contents of the page out to the database file. */∏    if( rc==SQLITE_OK ){Ÿ0      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );Ÿ-      rc = pager_write_pagelist(pPager, pPg);•    }£  }†ø  /* Mark the page as clean. */∂  if( rc==SQLITE_OK ){ŸD    PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));Ÿ     sqlite3PcacheMakeClean(pPg);£  }†Ÿ"  return pager_error(pPager, rc); °}†¢/*Ÿ.** Flush all unreferenced dirty pages to disk.¢*/Ÿ4SQLITE_PRIVATE int sqlite3PagerFlush(Pager *pPager){ª  int rc = pPager->errCode;Ø  if( !MEMDB ){Ÿ;    PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);Ÿ)    assert( assert_pager_state(pPager) );Ÿ$    while( rc==SQLITE_OK && pList ){Ÿ#      PgHdr *pNext = pList->pDirty;ª      if( pList->nRef==0 ){Ÿ/        rc = pagerStress((void*)pPager, pList);ß      }¥      pList = pNext;•    }£  }†¨  return rc;°}†¢/*ŸE** Allocate and initialize a new Pager object and put a pointer to itŸB** in *ppPager. The pager should eventually be freed by passing it∫** to sqlite3PagerClose().¢**ŸC** The zFilename argument is the path to the database file to open.ŸG** If zFilename is NULL then a randomly-named temporary file is createdŸD** and used as the file to be cached. Temporary files are be deletedŸG** automatically when they are closed. If zFilename is ":memory:" then ŸB** all information is held in cache. It is never written to disk. Ÿ7** This can be used to implement an in-memory database.¢**ŸH** The nExtra parameter specifies the number of bytes of space allocatedŸF** along with each page reference. This space is available to the userŸI** via the sqlite3PagerGetExtra() API.  When a new page is allocated, theŸM** first 8 bytes of this space are zeroed but the remainder is uninitialized.Ÿ<** (The extra space is used by btree as the MemPage object.)¢**ŸC** The flags argument is used to specify properties that affect theŸG** operation of the pager. It should be passed some bitwise combination∏** of the PAGER_* flags.¢**ŸE** The vfsFlags parameter is a bitmask to pass to the flags parameterŸA** of the xOpen() method of the supplied VFS when opening files. ¢**ŸB** If the pager object is allocated and the specified file opened ŸC** successfully, SQLITE_OK is returned and *ppPager set to point toŸD** the new pager object. If an error occurs, *ppPager is set to NULLŸA** and error code returned. This function may return SQLITE_NOMEMŸD** (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or Ÿ ** various SQLITE_IO_XXX errors.¢*/Ÿ$SQLITE_PRIVATE int sqlite3PagerOpen(Ÿ?  sqlite3_vfs *pVfs,       /* The virtual file system to use */ŸE  Pager **ppPager,         /* OUT: Return the Pager structure here */ŸB  const char *zFilename,   /* Name of the database file to open */ŸJ  int nExtra,              /* Extra bytes append to each in-memory page */Ÿ<  int flags,               /* flags controlling this file */ŸL  int vfsFlags,            /* flags passed through to sqlite3_vfs.xOpen() */Ÿ?  void (*xReinit)(DbPage*) /* Function to reinitialize pages */¢){´  u8 *pPtr;ŸD  Pager *pPager = 0;       /* Pager object to allocate and return */Ÿ,  int rc = SQLITE_OK;      /* Return code */ŸL  int tempFile = 0;        /* True for temp files (incl. in-memory files) */ŸB  int memDb = 0;           /* True if this is an in-memory file */Ÿ #ifdef SQLITE_ENABLE_DESERIALIZEŸ4  int memJM = 0;           /* Memory journal mode */•#else∞# define memJM 0¶#endifŸA  int readOnly = 0;        /* True if this is a read-only file */ŸF  int journalFileSize;     /* Bytes to allocate for each journal fd */Ÿ;  char *zPathname = 0;     /* Full path to database file */Ÿ=  int nPathname = 0;       /* Number of bytes in zPathname */ŸO  int useJournal = (flags & PAGER_OMIT_JOURNAL)==0; /* False to omit journal */ŸP  int pcacheSize = sqlite3PcacheSize();       /* Bytes to allocate for PCache */ŸE  u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */Ÿ1  const char *zUri = 0;    /* URI args to copy */ŸE  int nUri = 0;            /* Number of bytes of URI args at *zUri */†ŸG  /* Figure out how much space is required for each journal file-handleŸG  ** (there are two of them, the main journal and the sub-journal).  */Ÿ5  journalFileSize = ROUND8(sqlite3JournalSize(pVfs));†Ÿ@  /* Set the output variable to NULL in case an error occurs. */Ø  *ppPager = 0;†º#ifndef SQLITE_OMIT_MEMORYDBΩ  if( flags & PAGER_MEMORY ){Æ    memDb = 1;Ÿ$    if( zFilename && zFilename[0] ){Ÿ0      zPathname = sqlite3DbStrDup(0, zFilename);Ÿ3      if( zPathname==0  ) return SQLITE_NOMEM_BKPT;Ÿ-      nPathname = sqlite3Strlen30(zPathname);¥      zFilename = 0;•    }£  }¶#endif†ŸG  /* Compute and store the full pathname in an allocated buffer pointedŸH  ** to by zPathname, length nPathname. Or, if this is a temporary file,Ÿ1  ** leave both nPathname and zPathname set to 0.§  */Ÿ"  if( zFilename && zFilename[0] ){≤    const char *z;Ÿ#    nPathname = pVfs->mxPathname+1;Ÿ3    zPathname = sqlite3DbMallocRaw(0, nPathname*2);∑    if( zPathname==0 ){ø      return SQLITE_NOMEM_BKPT;•    }ŸN    zPathname[0] = 0; /* Make sure initialized even if FullPathname() fails */ŸF    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);Ÿ+    nPathname = sqlite3Strlen30(zPathname);Ÿ8    z = zUri = &zFilename[sqlite3Strlen30(zFilename)+1];∞    while( *z ){Ÿ       z += sqlite3Strlen30(z)+1;Ÿ       z += sqlite3Strlen30(z)+1;•    }ø    nUri = (int)(&z[1] - zUri);∂    assert( nUri>=0 );Ÿ8    if( rc==SQLITE_OK && nPathname+8>pVfs->mxPathname ){Ÿ?      /* This branch is taken when the journal path required byŸE      ** the database being opened will be more than pVfs->mxPathnameŸC      ** bytes in length. This means the database cannot be opened,ŸD      ** as it will not be possible to open the journal file or evenŸ0      ** check for a hot-journal before reading.®      */Ÿ       rc = SQLITE_CANTOPEN_BKPT;•    }∏    if( rc!=SQLITE_OK ){Ÿ"      sqlite3DbFree(0, zPathname);∞      return rc;•    }£  }†Ÿ@  /* Allocate memory for the Pager structure, PCache object, theŸD  ** three file descriptors, the database file name and the journal Ÿ3  ** file name. The layout in memory is as follows:§  **Ÿ>  **     Pager object                    (sizeof(Pager) bytes)ŸD  **     PCache object                   (sqlite3PcacheSize() bytes)Ÿ?  **     Database file handle            (pVfs->szOsFile bytes)Ÿ@  **     Sub-journal file handle         (journalFileSize bytes)Ÿ@  **     Main journal file handle        (journalFileSize bytes)Ÿ<  **     Database file name              (nPathname+1 bytes)Ÿ>  **     Journal file name               (nPathname+8+1 bytes)§  */Ÿ!  pPtr = (u8 *)sqlite3MallocZero(Ÿ8    ROUND8(sizeof(*pPager)) +      /* Pager structure */Ÿ6    ROUND8(pcacheSize) +           /* PCache object */Ÿ9    ROUND8(pVfs->szOsFile) +       /* The main db file */Ÿ?    journalFileSize * 2 +          /* The two journal files */ Ÿ2    nPathname + 1 + nUri +         /* zFilename */Ÿ1    nPathname + 8 + 2              /* zJournal */∑#ifndef SQLITE_OMIT_WALŸ-    + nPathname + 4 + 2            /* zWal */¶#endif§  );ŸE  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) );Æ  if( !pPtr ){Ÿ     sqlite3DbFree(0, zPathname);Ω    return SQLITE_NOMEM_BKPT;£  }Ÿ'  pPager =              (Pager*)(pPtr);ŸB  pPager->pPCache =    (PCache*)(pPtr += ROUND8(sizeof(*pPager)));Ÿ=  pPager->fd =   (sqlite3_file*)(pPtr += ROUND8(pcacheSize));ŸA  pPager->sjfd = (sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));Ÿ:  pPager->jfd =  (sqlite3_file*)(pPtr += journalFileSize);Ÿ:  pPager->zFilename =    (char*)(pPtr += journalFileSize);Ÿ.  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );†ŸL  /* Fill in the Pager.zFilename and Pager.zJournal buffers, if required. */≤  if( zPathname ){∫    assert( nPathname>0 );Ÿ?    pPager->zJournal =   (char*)(pPtr += nPathname + 1 + nUri);Ÿ4    memcpy(pPager->zFilename, zPathname, nPathname);ŸC    if( nUri ) memcpy(&pPager->zFilename[nPathname+1], zUri, nUri);Ÿ3    memcpy(pPager->zJournal, zPathname, nPathname);Ÿ>    memcpy(&pPager->zJournal[nPathname], "-journal\000", 8+2);Ÿ<    sqlite3FileSuffix3(pPager->zFilename, pPager->zJournal);∑#ifndef SQLITE_OMIT_WALŸ4    pPager->zWal = &pPager->zJournal[nPathname+8+1];Ÿ/    memcpy(pPager->zWal, zPathname, nPathname);Ÿ6    memcpy(&pPager->zWal[nPathname], "-wal\000", 4+1);Ÿ8    sqlite3FileSuffix3(pPager->zFilename, pPager->zWal);¶#endifŸ     sqlite3DbFree(0, zPathname);£  }∂  pPager->pVfs = pVfs;æ  pPager->vfsFlags = vfsFlags;†π  /* Open the pager file.§  */Ÿ"  if( zFilename && zFilename[0] ){ŸH    int fout = 0;                    /* VFS flags returned by xOpen() */ŸM    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);µ    assert( !memDb );Ÿ #ifdef SQLITE_ENABLE_DESERIALIZEŸ)    memJM = (fout&SQLITE_OPEN_MEMORY)!=0;¶#endifŸ.    readOnly = (fout&SQLITE_OPEN_READONLY)!=0;†ŸA    /* If the file was successfully opened for read/write access,Ÿ?    ** choose a default page size in case we have to create theŸ>    ** database file. The default page size is the maximum of:¶    **Ÿ%    **    + SQLITE_DEFAULT_PAGE_SIZE,Ÿ7    **    + The value returned by sqlite3OsSectorSize()ŸA    **    + The largest page size that can be written atomically.¶    */∏    if( rc==SQLITE_OK ){Ÿ;      int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);∂      if( !readOnly ){æ        setSectorSize(pPager);ŸG        assert(SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE);Ÿ,        if( szPageDflt<pPager->sectorSize ){Ÿ@          if( pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE ){Ÿ6            szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;∞          }else{Ÿ1            szPageDflt = (u32)pPager->sectorSize;´          }©        }Ÿ!#ifdef SQLITE_ENABLE_ATOMIC_WRITE©        {±          int ii;Ÿ3          assert(SQLITE_IOCAP_ATOMIC512==(512>>8));Ÿ5          assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));Ÿ6          assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);ŸH          for(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){Ÿ4            if( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ){æ              szPageDflt = ii;≠            }´          }©        }¶#endifß      }ŸC      pPager->noLock = sqlite3_uri_boolean(zFilename, "nolock", 0);Ÿ+      if( (iDc & SQLITE_IOCAP_IMMUTABLE)!=0Ÿ;       || sqlite3_uri_boolean(zFilename, "immutable", 0) ){Ÿ+          vfsFlags |= SQLITE_OPEN_READONLY;Ÿ"          goto act_like_temp_file;ß      }•    }®  }else{ŸF    /* If a temporary file is requested, it is not opened immediately.ŸF    ** In this case we accept the default page size and delay actuallyŸ:    ** opening the file until the first call to OsWrite().¶    **ŸF    ** This branch is also run for an in-memory database. An in-memoryŸG    ** database is the same as a temp-file that is never written out toŸ3    ** disk and uses an in-memory rollback journal.¶    **Ÿ;    ** This branch also runs for files marked as immutable.ß    */ ≥act_like_temp_file:±    tempFile = 1;ŸK    pPager->eState = PAGER_READER;     /* Pretend we already have a lock */ŸM    pPager->eLock = EXCLUSIVE_LOCK;    /* Pretend we are in EXCLUSIVE mode */Ÿ:    pPager->noLock = 1;                /* Do no locking */Ÿ/    readOnly = (vfsFlags&SQLITE_OPEN_READONLY);£  }†ŸI  /* The following call to PagerSetPagesize() serves to set the value of Ÿ?  ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.§  */∂  if( rc==SQLITE_OK ){ø    assert( pPager->memDb==0 );Ÿ:    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);æ    testcase( rc!=SQLITE_OK );£  }†Ÿ%  /* Initialize the PCache object. */∂  if( rc==SQLITE_OK ){º    nExtra = ROUND8(nExtra);Ÿ'    assert( nExtra>=8 && nExtra<1000 );Ÿ6    rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,ŸN                       !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);£  }†ŸN  /* If an error occurred above, free the  Pager structure and close the file.§  */∂  if( rc!=SQLITE_OK ){ø    sqlite3OsClose(pPager->fd);Ÿ'    sqlite3PageFree(pPager->pTmpSpace);π    sqlite3_free(pPager);Æ    return rc;£  }†ŸL  PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));Ÿ6  IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename))†Ÿ&  pPager->useJournal = (u8)useJournal;Ω  /* pPager->stmtOpen = 0; */æ  /* pPager->stmtInUse = 0; */π  /* pPager->nRef = 0; */Ω  /* pPager->stmtSize = 0; */æ  /* pPager->stmtJSize = 0; */∫  /* pPager->nPage = 0; */Ÿ)  pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;Ÿ%  /* pPager->state = PAGER_UNLOCK; */º  /* pPager->errMask = 0; */Ÿ"  pPager->tempFile = (u8)tempFile;Ÿ-  assert( tempFile==PAGER_LOCKINGMODE_NORMAL Ÿ5          || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE );Ÿ+  assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );Ÿ(  pPager->exclusiveMode = (u8)tempFile; Ÿ-  pPager->changeCountDone = pPager->tempFile;º  pPager->memDb = (u8)memDb;Ÿ"  pPager->readOnly = (u8)readOnly;Ÿ+  assert( useJournal || pPager->tempFile );Ÿ$  pPager->noSync = pPager->tempFile;∑  if( pPager->noSync ){Ÿ"    assert( pPager->fullSync==0 );Ÿ#    assert( pPager->extraSync==0 );Ÿ#    assert( pPager->syncFlags==0 );Ÿ&    assert( pPager->walSyncFlags==0 );®  }else{π    pPager->fullSync = 1;∫    pPager->extraSync = 0;Ÿ+    pPager->syncFlags = SQLITE_SYNC_NORMAL;ŸH    pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);£  }ª  /* pPager->pFirst = 0; */Ÿ!  /* pPager->pFirstSynced = 0; */∫  /* pPager->pLast = 0; */ø  pPager->nExtra = (u16)nExtra;Ÿ?  pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;Ÿ+  assert( isOpen(pPager->fd) || tempFile );∏  setSectorSize(pPager);¥  if( !useJournal ){Ÿ0    pPager->journalMode = PAGER_JOURNALMODE_OFF;Ω  }else if( memDb || memJM ){Ÿ3    pPager->journalMode = PAGER_JOURNALMODE_MEMORY;£  }Ÿ!  /* pPager->xBusyHandler = 0; */Ÿ$  /* pPager->pBusyHandlerArg = 0; */æ  pPager->xReiniter = xReinit;∫  setGetterMethod(pPager);Ÿ8  /* memset(pPager->aHash, 0, sizeof(pPager->aHash)); */ŸK  /* pPager->szMmap = SQLITE_DEFAULT_MMAP_SIZE // will be set by btree.c */†¥  *ppPager = pPager;≥  return SQLITE_OK;°}†††¢/*ŸC** This function is called after transitioning from PAGER_UNLOCK toŸD** PAGER_SHARED state. It tests if there is a hot journal present inŸB** the file-system for the given pager. A hot journal is one that ŸE** needs to be played back. According to this function, a hot-journalŸ1** file exists if the following criteria are met:¢**Ÿ6**   * The journal file exists in the file system, andŸL**   * No process holds a RESERVED or greater lock on the database file, andŸD**   * The database file itself is greater than 0 bytes in size, andŸA**   * The first byte of the journal file exists and is not 0x00.¢**ŸC** If the current size of the database file is 0 but a journal fileŸA** exists, that is probably an old journal left over from a priorŸ@** database with the same name. In this case the journal file isŸB** just deleted using OsDelete, *pExists is set to 0 and SQLITE_OKØ** is returned.¢**ŸD** This routine does not check if there is a master journal filenameŸD** at the end of the file. If there is, and that master journal fileŸC** does not exist, then the journal file is not really hot. In thisŸG** case this routine will return a false-positive. The pager_playback()ŸE** routine will discover that the journal file is not really hot and ∫** will not roll it back. ¢**ŸE** If a hot-journal file is found to exist, *pExists is set to 1 and ŸE** SQLITE_OK returned. If no hot-journal file is present, *pExists isŸF** set to 0 and SQLITE_OK returned. If an IO error occurs while tryingŸF** to determine whether or not a hot-journal file exists, the IO errorŸ;** code is returned and the value of *pExists is undefined.¢*/Ÿ6static int hasHotJournal(Pager *pPager, int *pExists){Ÿ*  sqlite3_vfs * const pVfs = pPager->pVfs;Ÿ1  int rc = SQLITE_OK;           /* Return code */ŸG  int exists = 1;               /* True if a journal file is present */Ÿ'  int jrnlOpen = !!isOpen(pPager->jfd);†ø  assert( pPager->useJournal );ø  assert( isOpen(pPager->fd) );Ÿ'  assert( pPager->eState==PAGER_OPEN );†ŸH  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &Ÿ&    SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN•  ));†Ø  *pExists = 0;≤  if( !jrnlOpen ){ŸP    rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);£  }Ÿ   if( rc==SQLITE_OK && exists ){ŸP    int locked = 0;             /* True if some process holds a RESERVED lock */†ŸH    /* Race condition here:  Another process might have been holding theŸJ    ** the RESERVED lock and have a journal open at the sqlite3OsAccess() ŸG    ** call above, but then delete the journal and drop the lock beforeŸJ    ** we get to the following sqlite3OsCheckReservedLock() call.  If thatŸH    ** is the case, this routine might think there is a hot journal whenŸJ    ** in fact there is none.  This results in a false-positive which willŸ<    ** be dealt with by the playback routine.  Ticket #3883.¶    */Ÿ9    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);Ÿ#    if( rc==SQLITE_OK && !locked ){ŸH      Pgno nPage;                 /* Number of pages in database file */†Ÿ$      assert( pPager->tempFile==0 );Ÿ*      rc = pagerPagecount(pPager, &nPage);∫      if( rc==SQLITE_OK ){ŸP        /* If the database is zero pages in size, that means that either (1) theŸN        ** journal is a remnant from a prior database with the same name whereŸP        ** the database file but not the journal was deleted, or (2) the initialŸJ        ** transaction that populates a new database is being rolled back.ŸO        ** In either case, the journal file can be deleted.  However, take careŸF        ** not to delete the journal file if it is already open due toŸ         ** journal_mode=PERSIST.™        */Ÿ$        if( nPage==0 && !jrnlOpen ){Ÿ%          sqlite3BeginBenignMalloc();Ÿ>          if( pagerLockDb(pPager, RESERVED_LOCK)==SQLITE_OK ){Ÿ7            sqlite3OsDelete(pVfs, pPager->zJournal, 0);ŸL            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);´          }Ÿ#          sqlite3EndBenignMalloc();Æ        }else{ŸK          /* The journal file exists and no other connection has a reservedŸJ          ** or greater lock on the database file. Now check that there isŸJ          ** at least one non-zero bytes at the start of the journal file.ŸK          ** If there is, then we consider this journal to be hot. If not, ø          ** it can be ignored.¨          */∫          if( !jrnlOpen ){ŸB            int f = SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL;ŸK            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);´          }æ          if( rc==SQLITE_OK ){π            u8 first = 0;ŸB            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);Ÿ.            if( rc==SQLITE_IOERR_SHORT_READ ){Ω              rc = SQLITE_OK;≠            }º            if( !jrnlOpen ){Ÿ*              sqlite3OsClose(pPager->jfd);≠            }Ÿ"            *pExists = (first!=0);Ÿ*          }else if( rc==SQLITE_CANTOPEN ){ŸM            /* If we cannot open the rollback journal file in order to see ifŸJ            ** it has a zero header, that might be due to an I/O error, orŸK            ** it might be due to the race condition described above and inŸI            ** ticket #3883.  Either way, assume that the journal is hot.ŸF            ** This might be a false positive.  But if it is, then theŸJ            ** automatic journal playback and recovery mechanism will dealŸF            ** with it under an EXCLUSIVE lock where we do not need toŸ2            ** worry so much with race conditions.Æ            */π            *pExists = 1;ª            rc = SQLITE_OK;´          }©        }ß      }•    }£  }†¨  return rc;°}†¢/*ŸH** This function is called to obtain a shared lock on the database file.ŸD** It is illegal to call sqlite3PagerGet() until after this functionŸF** has been successfully called. If a shared-lock is already held whenŸ*** this function is called, it is a no-op.¢**Ÿ@** The following operations are also performed by this function.¢**ŸC**   1) If the pager is currently in PAGER_OPEN state (no lock heldŸB**      on the database file), then an attempt is made to obtain aŸE**      SHARED lock on the database file. Immediately after obtainingŸF**      the SHARED lock, the file-system is checked for a hot-journal,ŸC**      which is played back if present. Following any hot-journal ŸE**      rollback, the contents of the cache are validated by checkingŸB**      the 'change-counter' field of the database file header andŸ2**      discarded if they are found to be invalid.¢**ŸJ**   2) If the pager is running in exclusive-mode, and there are currentlyŸJ**      no outstanding references to any pages, and is in the error state,ŸF**      then an attempt is made to clear the error state by discardingŸH**      the contents of the page cache and rolling back any open journal≠**      file.¢**ŸF** If everything is successful, SQLITE_OK is returned. If an IO error ŸI** occurs while locking the database, checking for a hot-journal file or Ÿ>** rolling back a journal file, the IO error code is returned.¢*/Ÿ9SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){Ÿ6  int rc = SQLITE_OK;                /* Return code */†ŸG  /* This routine is only called from b-tree and only when there are noŸG  ** outstanding pages. This implies that the pager state should eitherŸJ  ** be OPEN or READER. READER is only possible if the pager is or was in ø  ** exclusive access mode.  */Ÿ6  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );Ÿ'  assert( assert_pager_state(pPager) );ŸG  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );Ÿ'  assert( pPager->errCode==SQLITE_OK );†Ÿ;  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){ŸO    int bHotJournal = 1;          /* True if there exists a hot journal-file */†µ    assert( !MEMDB );ŸC    assert( pPager->tempFile==0 || pPager->eLock==EXCLUSIVE_LOCK );†Ÿ1    rc = pager_wait_on_lock(pPager, SHARED_LOCK);∏    if( rc!=SQLITE_OK ){ŸF      assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );≤      goto failed;•    }†ŸE    /* If a journal file exists, and there is no RESERVED lock on theŸH    ** database file, then it either needs to be played back or deleted.¶    */Ÿ%    if( pPager->eLock<=SHARED_LOCK ){Ÿ/      rc = hasHotJournal(pPager, &bHotJournal);•    }∏    if( rc!=SQLITE_OK ){≤      goto failed;•    }∂    if( bHotJournal ){Ω      if( pPager->readOnly ){Ÿ&        rc = SQLITE_READONLY_ROLLBACK;¥        goto failed;ß      }†ŸH      /* Get an EXCLUSIVE lock on the database file. At this point it isŸI      ** important that a RESERVED lock is not obtained on the way to theŸC      ** EXCLUSIVE lock. If it were, another process might open theŸG      ** database file, detect the RESERVED lock, and conclude that theŸJ      ** database is safe to read while this process is still rolling the ∫      ** hot-journal back.©      ** ŸE      ** Because the intermediate RESERVED lock is not requested, anyŸJ      ** other process attempting to access the database file will get to ŸJ      ** this point in the code and fail to obtain its own EXCLUSIVE lock æ      ** on the database file.®      **ŸH      ** Unless the pager is in locking_mode=exclusive mode, the lock isŸ@      ** downgraded to SHARED_LOCK before this function returns.®      */Ÿ/      rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);∫      if( rc!=SQLITE_OK ){¥        goto failed;ß      }° ŸI      /* If it is not already open and the file exists on disk, open the ŸI      ** journal for read/write access. Write access is required because ŸH      ** in exclusive-access mode the file descriptor will be kept open ŸJ      ** and possibly used for a transaction later on. Also, write-access ŸM      ** is usually required to finalize the journal in journal_mode=persist ŸC      ** mode (and also for journal_mode=truncate on some systems).®      **ŸC      ** If the journal does not exist, it usually means that some ŸD      ** other connection managed to get in and roll it back before ŸC      ** this connection obtained the exclusive lock above. Or, it ŸA      ** may mean that the pager was in the error-state when thisŸA      ** function was called and the journal file does not exist.®      */Ÿ!      if( !isOpen(pPager->jfd) ){Ÿ0        sqlite3_vfs * const pVfs = pPager->pVfs;ŸC        int bExists;              /* True if journal file exists */Ω        rc = sqlite3OsAccess(ŸD            pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);Ÿ'        if( rc==SQLITE_OK && bExists ){∑          int fout = 0;ŸA          int f = SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_JOURNAL;Ÿ&          assert( !pPager->tempFile );ŸL          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);Ÿ9          assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );Ÿ;          if( rc==SQLITE_OK && fout&SQLITE_OPEN_READONLY ){Ÿ&            rc = SQLITE_CANTOPEN_BKPT;Ÿ(            sqlite3OsClose(pPager->jfd);´          }©        }ß      }° ŸB      /* Playback and delete the journal.  Drop the database writeŸA      ** lock and reacquire the read lock. Purge the cache beforeŸB      ** playing back the hot-journal so that we don't end up withŸD      ** an inconsistent cache.  Sync the hot journal before playingŸH      ** it back since the process that crashed and left the hot journalŸD      ** probably did not sync it and we are required to always syncŸ,      ** the journal before playing it back.®      */Ÿ       if( isOpen(pPager->jfd) ){Ÿ         assert( rc==SQLITE_OK );Ÿ)        rc = pagerSyncHotJournal(pPager);º        if( rc==SQLITE_OK ){Ÿ9          rc = pager_playback(pPager, !pPager->tempFile);Ÿ&          pPager->eState = PAGER_OPEN;©        }Ÿ)      }else if( !pPager->exclusiveMode ){Ÿ+        pagerUnlockDb(pPager, SHARED_LOCK);ß      }†∫      if( rc!=SQLITE_OK ){ŸG        /* This branch is taken if an error occurs while trying to openŸJ        ** or roll back a hot-journal while holding an EXCLUSIVE lock. TheŸK        ** pager_unlock() routine will be called before returning to unlockŸJ        ** the file. If the unlock attempt fails, then Pager.eLock must beŸF        ** set to UNKNOWN_LOCK (see the comment above the #define for Ÿ3        ** UNKNOWN_LOCK above for an explanation). ™        **ŸI        ** In order to get pager_unlock() to do this, set Pager.eState toŸH        ** PAGER_ERROR now. This is not actually counted as a transitionŸG        ** to ERROR state in the state diagram at the top of this file,ŸG        ** since we know that the same call to pager_unlock() will veryŸI        ** shortly transition the pager object to the OPEN state. CallingŸL        ** assert_pager_state() would fail now, as it should not be possibleŸE        ** to be in ERROR state when there are zero outstanding page ∂        ** references.™        */Ÿ         pager_error(pPager, rc);¥        goto failed;ß      }†Ÿ+      assert( pPager->eState==PAGER_OPEN );Ÿ*      assert( (pPager->eLock==SHARED_LOCK)ŸB           || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)®      );•    }†Ÿ9    if( !pPager->tempFile && pPager->hasHeldSharedLock ){Ÿ=      /* The shared-lock has just been acquired then check toŸM      ** see if the database has been modified.  If the database has changed,ŸH      ** flush the cache.  The hasHeldSharedLock flag prevents this fromŸI      ** occurring on the very first access to a file, in order to save aŸA      ** single unnecessary sqlite3OsRead() call at the start-up.®      **ŸG      ** Database changes are detected by looking at 15 bytes beginningŸG      ** at offset 24 into the file.  The first 4 of these 16 bytes areŸD      ** a 32-bit counter that is incremented with each change.  TheŸ?      ** other bytes change randomly with each file change whenª      ** a codec is in use.©      ** ŸG      ** There is a vanishingly small chance that a change will not be ŸG      ** detected.  The chance of an undetected change is so small thatΩ      ** it can be neglected.®      */Ÿ2      char dbFileVers[sizeof(pPager->dbFileVers)];†Ÿ>      IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));ŸJ      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);∫      if( rc!=SQLITE_OK ){Ÿ*        if( rc!=SQLITE_IOERR_SHORT_READ ){∂          goto failed;©        }Ÿ2        memset(dbFileVers, 0, sizeof(dbFileVers));ß      }†ŸJ      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){º        pager_reset(pPager);†ŸJ        /* Unmap the database file. It is possible that external processesŸI        ** may have truncated the database file and then extended it backŸJ        ** to its original size while this process was not holding a lock.ŸI        ** In this case there may exist a Pager.pMap mapping that appearsŸE        ** to be the right size but is not actually valid. Avoid thisŸ3        ** possibility by unmapping the db here. */ø        if( USEFETCH(pPager) ){Ÿ-          sqlite3OsUnfetch(pPager->fd, 0, 0);©        }ß      }•    }†ŸK    /* If there is a WAL file in the file-system, open this database in WALŸ?    ** mode. Otherwise, the following function call is a no-op.¶    */Ÿ'    rc = pagerOpenWalIfPresent(pPager);∑#ifndef SQLITE_OMIT_WALŸ/    assert( pPager->pWal==0 || rc==SQLITE_OK );¶#endif£  }†º  if( pagerUseWal(pPager) ){º    assert( rc==SQLITE_OK );Ÿ+    rc = pagerBeginReadTransaction(pPager);£  }†ŸK  if( pPager->tempFile==0 && pPager->eState==PAGER_OPEN && rc==SQLITE_OK ){Ÿ1    rc = pagerPagecount(pPager, &pPager->dbSize);£  }†® failed:∂  if( rc!=SQLITE_OK ){µ    assert( !MEMDB );π    pager_unlock(pPager);Ÿ)    assert( pPager->eState==PAGER_OPEN );®  }else{Ÿ"    pPager->eState = PAGER_READER;Ÿ"    pPager->hasHeldSharedLock = 1;£  }¨  return rc;°}†¢/*Ÿ?** If the reference count has reached zero, rollback any activeŸ$** transaction and unlock the pager.¢**Ÿ@** Except, in locking_mode=EXCLUSIVE when there is nothing to inŸA** the rollback journal, the unlock is not performed and there isŸ3** nothing to rollback, so this routine is a no-op.£*/ Ÿ/static void pagerUnlockIfUnused(Pager *pPager){Ÿ2  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){ŸM    assert( pPager->nMmapOut==0 ); /* because page1 is never memory mapped */Ÿ#    pagerUnlockAndRollback(pPager);£  }°}†¢/*Ÿ?** The page getter methods each try to acquire a reference to aŸ=** page with page number pgno. If the requested reference is ŸI** successfully obtained, it is copied to *ppPage and SQLITE_OK returned.¢**ŸE** There are different implementations of the getter method dependingŸ%** on the current state of the pager.¢**Ÿ4**     getPageNormal()         --  The normal getterŸI**     getPageError()          --  Used if the pager is in an error stateŸG**     getPageMmap()           --  Used if memory-mapped I/O is enabled¢**ŸB** If the requested page is already in the cache, it is returned. ŸD** Otherwise, a new page object is allocated and populated with dataŸD** read from the database file. In some cases, the pcache module mayŸE** choose not to allocate a new page object and may reuse an existingŸ)** object with no outstanding references.¢**ŸH** The extra data appended to a page is always initialized to zeros the ŸE** first time a page is loaded into memory. If the page requested is ŸD** already in the cache when this function is called, then the extraŸ=** data is left as it was when the page object was last used.¢**ŸB** If the database image is smaller than the requested page or if ŸD** the flags parameter contains the PAGER_GET_NOCONTENT bit and the Ÿ>** requested page is not already stored in the cache, then no ŸA** actual disk read occurs. In this case the memory image of the Ÿ%** page is initialized to all zeros. ¢**ŸE** If PAGER_GET_NOCONTENT is true, it means that we do not care aboutŸ:** the contents of the page. This occurs in two scenarios:¢**ŸA**   a) When reading a free-list leaf page from the database, and¢**ŸA**   b) When a savepoint is being rolled back and we need to loadŸA**      a new page into the cache to be filled with the data readŸ#**      from the savepoint journal.¢**ŸK** If PAGER_GET_NOCONTENT is true, then the data returned is zeroed insteadŸH** of being read from the database. Additionally, the bits correspondingŸF** to pgno in Pager.pInJournal (bitvec of pages already written to theŸH** journal file) and the PagerSavepoint.pInSavepoint bitvecs of any openŸE** savepoints are set. This means if the page is made writable at anyŸI** point in the future, using a call to sqlite3PagerWrite(), its contentsŸ(** will not be journaled. This saves IO.¢**ŸA** The acquisition might fail for several reasons.  In all cases,ŸD** an appropriate error code is returned and *ppPage is set to NULL.¢**ŸI** See also sqlite3PagerLookup().  Both this routine and Lookup() attemptŸK** to find a page in the in-memory cache first.  If the page is not alreadyŸF** in memory, this routine goes to disk to read it in whereas Lookup()ŸG** just returns 0.  This routine acquires a read-lock the first time itŸJ** has to go to disk, and could also playback an old journal if necessary.ŸE** Since Lookup() never goes to disk, it never has to deal with locks¥** or journal files.¢*/πstatic int getPageNormal(Ÿ?  Pager *pPager,      /* The pager open on the database file */Ÿ0  Pgno pgno,          /* Page number to fetch */Ÿ<  DbPage **ppPage,    /* Write a pointer to the page here */Ÿ/  int flags           /* PAGER_GET_XXX flags */¢){µ  int rc = SQLITE_OK;≠  PgHdr *pPg;ŸJ  u8 noContent;                   /* True if PAGER_GET_NOCONTENT is set */Ω  sqlite3_pcache_page *pBase;†Ÿ'  assert( pPager->errCode==SQLITE_OK );Ÿ)  assert( pPager->eState>=PAGER_READER );Ÿ'  assert( assert_pager_state(pPager) );Ÿ)  assert( pPager->hasHeldSharedLock==1 );†Ÿ+  if( pgno==0 ) return SQLITE_CORRUPT_BKPT;Ÿ7  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);±  if( pBase==0 ){¨    pPg = 0;ŸA    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);Ÿ/    if( rc!=SQLITE_OK ) goto pager_acquire_err;≥    if( pBase==0 ){Ω      rc = SQLITE_NOMEM_BKPT;Ω      goto pager_acquire_err;•    }£  }ŸI  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);ª  assert( pPg==(*ppPage) );º  assert( pPg->pgno==pgno );Ÿ2  assert( pPg->pPager==pPager || pPg->pPager==0 );†Ÿ/  noContent = (flags & PAGER_GET_NOCONTENT)!=0;Ÿ"  if( pPg->pPager && !noContent ){ŸF    /* In this case the pcache already contains an initialized copy ofŸ0    ** the page. Return without further ado.  */ŸB    assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );Ÿ$    pPager->aStat[PAGER_STAT_HIT]++;µ    return SQLITE_OK;†®  }else{ŸD    /* The pager cache has created a new page. Its content needs to Ÿ3    ** be initialized. But first some error checks:¶    **Ÿ*    ** (1) The maximum page number is 2^31Ÿ.    ** (2) Never try to fetch the locking page¶    */Ÿ=    if( pgno>PAGER_MAX_PGNO || pgno==PAGER_MJ_PGNO(pPager) ){ø      rc = SQLITE_CORRUPT_BKPT;Ω      goto pager_acquire_err;•    }†π    pPg->pPager = pPager;†Ÿ,    assert( !isOpen(pPager->fd) || !MEMDB );ŸB    if( !isOpen(pPager->fd) || pPager->dbSize<pgno || noContent ){Ÿ       if( pgno>pPager->mxPgno ){π        rc = SQLITE_FULL;ø        goto pager_acquire_err;ß      }∂      if( noContent ){ŸJ        /* Failure to set the bits in the InJournal bit-vectors is benign.ŸI        ** It merely means that we might do some extra work to journal a ŸK        ** page that does not need to be journaled.  Nevertheless, be sure ŸL        ** to test the case where a malloc error occurs while trying to set Ÿ!        ** a bit in a bit vector.™        */Ÿ#        sqlite3BeginBenignMalloc();Ÿ'        if( pgno<=pPager->dbOrigSize ){ŸF          TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);Ÿ'          testcase( rc==SQLITE_NOMEM );©        }Ÿ=        TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);Ÿ%        testcase( rc==SQLITE_NOMEM );Ÿ!        sqlite3EndBenignMalloc();ß      }Ÿ.      memset(pPg->pData, 0, pPager->pageSize);Ÿ.      IOTRACE(("ZERO %p %d\n", pPager, pgno));™    }else{Ÿ$      assert( pPg->pPager==pPager );Ÿ'      pPager->aStat[PAGER_STAT_MISS]++;ª      rc = readDbPage(pPg);∫      if( rc!=SQLITE_OK ){ø        goto pager_acquire_err;ß      }•    }º    pager_set_pagehash(pPg);£  }≥  return SQLITE_OK;†≤pager_acquire_err:∫  assert( rc!=SQLITE_OK );¨  if( pPg ){ª    sqlite3PcacheDrop(pPg);£  }æ  pagerUnlockIfUnused(pPager);Æ  *ppPage = 0;¨  return rc;°}†∫#if SQLITE_MAX_MMAP_SIZE>0Ÿ;/* The page getter for when memory-mapped I/O is enabled */∑static int getPageMMap(Ÿ?  Pager *pPager,      /* The pager open on the database file */Ÿ0  Pgno pgno,          /* Page number to fetch */Ÿ<  DbPage **ppPage,    /* Write a pointer to the page here */Ÿ/  int flags           /* PAGER_GET_XXX flags */¢){µ  int rc = SQLITE_OK;±  PgHdr *pPg = 0;ŸC  u32 iFrame = 0;                 /* Frame to read from WAL file */†ŸH  /* It is acceptable to use a read-only (mmap) page for any page exceptŸI  ** page 1 if there is no write-transaction open or the ACQUIRE_READONLYŸF  ** flag was specified by the caller. And so long as the db is not a Ÿ)  ** temporary or in-memory database.  */Ω  const int bMmapOk = (pgno>1ŸD   && (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))§  );†Ω  assert( USEFETCH(pPager) );∑#ifdef SQLITE_HAS_CODECæ  assert( pPager->xCodec==0 );¶#endif†ŸH  /* Optimization note:  Adding the "pgno<=1" term before "pgno==0" hereŸG  ** allows the compiler optimizer to reuse the results of the "pgno>1"ŸE  ** test in the previous statement, and avoid testing pgno==0 in theŸ(  ** common case where pgno is large. */ª  if( pgno<=1 && pgno==0 ){ø    return SQLITE_CORRUPT_BKPT;£  }Ÿ)  assert( pPager->eState>=PAGER_READER );Ÿ'  assert( assert_pager_state(pPager) );Ÿ)  assert( pPager->hasHeldSharedLock==1 );Ÿ'  assert( pPager->errCode==SQLITE_OK );†Ÿ'  if( bMmapOk && pagerUseWal(pPager) ){Ÿ:    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);∏    if( rc!=SQLITE_OK ){≤      *ppPage = 0;∞      return rc;•    }£  }Ω  if( bMmapOk && iFrame==0 ){¥    void *pData = 0;Ÿ$    rc = sqlite3OsFetch(pPager->fd, ŸB        (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData¶    );Ÿ!    if( rc==SQLITE_OK && pData ){Ÿ<      if( pPager->eState>PAGER_READER || pPager->tempFile ){Ÿ/        pPg = sqlite3PagerLookup(pPager, pgno);ß      }≥      if( pPg==0 ){Ÿ<        rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);¨      }else{ŸL        sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);ß      }∞      if( pPg ){Ÿ         assert( rc==SQLITE_OK );∂        *ppPage = pPg;π        return SQLITE_OK;ß      }•    }∏    if( rc!=SQLITE_OK ){≤      *ppPage = 0;∞      return rc;•    }£  }Ÿ4  return getPageNormal(pPager, pgno, ppPage, flags);°}Ÿ##endif /* SQLITE_MAX_MMAP_SIZE>0 */†ŸA/* The page getter method for when the pager is an error state */∏static int getPageError(Ÿ?  Pager *pPager,      /* The pager open on the database file */Ÿ0  Pgno pgno,          /* Page number to fetch */Ÿ<  DbPage **ppPage,    /* Write a pointer to the page here */Ÿ/  int flags           /* PAGER_GET_XXX flags */¢){π  UNUSED_PARAMETER(pgno);∫  UNUSED_PARAMETER(flags);Ÿ'  assert( pPager->errCode!=SQLITE_OK );Æ  *ppPage = 0;π  return pPager->errCode;°}††ŸE/* Dispatch all page fetch requests to the appropriate getter method.¢*/Ÿ#SQLITE_PRIVATE int sqlite3PagerGet(Ÿ?  Pager *pPager,      /* The pager open on the database file */Ÿ0  Pgno pgno,          /* Page number to fetch */Ÿ<  DbPage **ppPage,    /* Write a pointer to the page here */Ÿ/  int flags           /* PAGER_GET_XXX flags */¢){Ÿ3  return pPager->xGet(pPager, pgno, ppPage, flags);°}†¢/*Ÿ>** Acquire a page if it is already in the in-memory cache.  DoŸ>** not read the page from disk.  Return a pointer to the page,Ÿ%** or 0 if the page is not in cache. ¢**ŸC** See also sqlite3PagerGet().  The difference between this routineŸD** and sqlite3PagerGet() is that _get() will go to the disk and readŸA** in the page if the page is not already in cache.  This routineŸC** returns NULL if the page is not in cache or if a disk I/O error µ** has ever happened.¢*/ŸDSQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){Ω  sqlite3_pcache_page *pPage;∂  assert( pPager!=0 );¥  assert( pgno!=0 );ø  assert( pPager->pPCache!=0 );Ÿ7  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);Ÿ2  assert( pPage==0 || pPager->hasHeldSharedLock );∫  if( pPage==0 ) return 0;Ÿ@  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);°}†¢/*º** Release a page reference.¢**ŸE** The sqlite3PagerUnref() and sqlite3PagerUnrefNotNull() may only beŸE** used if we know that the page being released is not the last page.ŸH** The btree layer always holds page1 open until the end, so these firstŸJ** to routines can be used to release any page other than BtShared.pPage1.¢**ŸH** Use sqlite3PagerUnrefPageOne() to release page1.  This latter routineŸD** checks the total number of outstanding pages and if the number ofŸ1** pages reaches zero it drops the database lock.¢*/Ÿ:SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage *pPg){Ÿ*  TESTONLY( Pager *pPager = pPg->pPager; )≥  assert( pPg!=0 );Ÿ   if( pPg->flags & PGHDR_MMAP ){Ÿ?    assert( pPg->pgno!=1 );  /* Page1 is never memory mapped */Ω    pagerReleaseMapPage(pPg);®  }else{æ    sqlite3PcacheRelease(pPg);£  }ŸF  /* Do not use this routine to release the last reference to page1 */Ÿ5  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );°}Ÿ3SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){Ÿ*  if( pPg ) sqlite3PagerUnrefNotNull(pPg);°}Ÿ:SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage *pPg){∞  Pager *pPager;≥  assert( pPg!=0 );π  assert( pPg->pgno==1 );ŸL  assert( (pPg->flags & PGHDR_MMAP)==0 ); /* Page1 is never memory mapped */∑  pPager = pPg->pPager;Ÿ'  sqlite3PagerResetLockTimeout(pPager);º  sqlite3PcacheRelease(pPg);æ  pagerUnlockIfUnused(pPager);°}†¢/*ŸC** This function is called at the start of every write transaction.ŸF** There must already be a RESERVED or EXCLUSIVE lock on the database Ÿ$** file when this routine is called.¢**ŸD** Open the journal file for pager pPager and write a journal headerŸK** to the start of it. If there are active savepoints, open the sub-journalŸF** as well. This function is only used when the journal file is being ŸD** opened to write a rollback log for a transaction. It is not used Ÿ3** when opening a hot journal file to roll it back.¢**ŸH** If the journal file is already open (as it may be in exclusive mode),ŸF** then this function just writes a journal header to the start of the∂** already open file. ¢**ŸB** Whether or not the journal file is opened by this function, theŸ2** Pager.pInJournal bitvec structure is allocated.¢**ŸC** Return SQLITE_OK if everything is successful. Otherwise, return ŸF** SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or ŸA** an IO error code if opening or writing the journal file fails.¢*/Ÿ-static int pager_open_journal(Pager *pPager){Ÿ>  int rc = SQLITE_OK;                        /* Return code */ŸM  sqlite3_vfs * const pVfs = pPager->pVfs;   /* Local cache of vfs pointer */†Ÿ0  assert( pPager->eState==PAGER_WRITER_LOCKED );Ÿ'  assert( assert_pager_state(pPager) );Ÿ"  assert( pPager->pInJournal==0 );¢  ŸE  /* If already in the error state, this function is a no-op.  But onŸF  ** the other hand, this routine is never called if we are already in∑  ** an error state. */Ÿ6  if( NEVER(pPager->errCode) ) return pPager->errCode;†ŸK  if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){Ÿ=    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);Ÿ     if( pPager->pInJournal==0 ){ø      return SQLITE_NOMEM_BKPT;•    }¢  Ÿ:    /* Open the journal file if it is not already open. */ø    if( !isOpen(pPager->jfd) ){Ÿ:      if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){Ÿ+        sqlite3MemJournalOpen(pPager->jfd);¨      }else{Ÿ=        int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;≥        int nSpill;†ø        if( pPager->tempFile ){ŸH          flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL);Ÿ,          nSpill = sqlite3Config.nStmtSpill;Æ        }else{Ÿ,          flags |= SQLITE_OPEN_MAIN_JOURNAL;Ÿ*          nSpill = jrnlBufferSize(pPager);©        }™          ŸJ        /* Verify that the database still has the same name as it did whenŸ'        ** it was originally opened. */Ÿ'        rc = databaseIsUnmoved(pPager);º        if( rc==SQLITE_OK ){Ÿ#          rc = sqlite3JournalOpen (Ÿ@              pVfs, pPager->zJournal, pPager->jfd, flags, nSpill¨          );©        }ß      }Ÿ5      assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );•    }¢  ¢  ŸC    /* Write the first journal header to the journal file and open Ÿ$    ** the sub-journal if necessary.¶    */∏    if( rc==SQLITE_OK ){Ÿ<      /* TODO: Check if all of these are really required. */∑      pPager->nRec = 0;Ω      pPager->journalOff = 0;º      pPager->setMaster = 0;Ω      pPager->journalHdr = 0;Ÿ#      rc = writeJournalHdr(pPager);•    }£  }†∂  if( rc!=SQLITE_OK ){Ÿ-    sqlite3BitvecDestroy(pPager->pInJournal);ª    pPager->pInJournal = 0;®  }else{Ÿ2    assert( pPager->eState==PAGER_WRITER_LOCKED );Ÿ+    pPager->eState = PAGER_WRITER_CACHEMOD;£  }†¨  return rc;°}†¢/*ŸA** Begin a write-transaction on the specified pager object. If a ŸG** write-transaction has already been opened, this function is a no-op.¢**ŸD** If the exFlag argument is false, then acquire at least a RESERVEDŸF** lock on the database file. If exFlag is true, then acquire at leastŸA** an EXCLUSIVE lock. If such a lock is already held, no locking º** functions need be called.¢**ŸH** If the subjInMemory argument is non-zero, then any sub-journal openedŸD** within this transaction will be opened as an in-memory file. ThisŸH** has no effect if the sub-journal is already opened (as it may be whenŸF** running in exclusive mode) or if the transaction does not require aŸG** sub-journal. If the subjInMemory argument is zero, then any requiredŸL** sub-journal is implemented in-memory if pPager is an in-memory database, Ÿ'** or using a temporary file otherwise.¢*/ŸRSQLITE_PRIVATE int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){µ  int rc = SQLITE_OK;†Ÿ/  if( pPager->errCode ) return pPager->errCode;ŸG  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );Ÿ*  pPager->subjInMemory = (u8)subjInMemory;†Ÿ-  if( ALWAYS(pPager->eState==PAGER_READER) ){Ÿ$    assert( pPager->pInJournal==0 );†æ    if( pagerUseWal(pPager) ){ŸI      /* If the pager is configured to use locking_mode=exclusive, and anŸK      ** exclusive lock on the database is not already held, obtain it now.®      */ŸO      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){Ÿ1        rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);º        if( rc!=SQLITE_OK ){¥          return rc;©        }Ÿ7        (void)sqlite3WalExclusiveMode(pPager->pWal, 1);ß      }†ŸG      /* Grab the write lock on the log file. If successful, upgrade toŸM      ** PAGER_RESERVED state. Otherwise, return an error code to the caller.ŸF      ** The busy-handler is not invoked if another connection alreadyŸI      ** holds the write-lock. If possible, the upper layer will call it.®      */Ÿ9      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);™    }else{ŸM      /* Obtain a RESERVED lock on the database file. If the exFlag parameterŸI      ** is true, then immediately upgrade this to an EXCLUSIVE lock. TheŸJ      ** busy-handler callback can be used when upgrading to the EXCLUSIVEŸ8      ** lock, but not when obtaining the RESERVED lock.®      */Ÿ.      rc = pagerLockDb(pPager, RESERVED_LOCK);Ÿ$      if( rc==SQLITE_OK && exFlag ){Ÿ8        rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);ß      }•    }†∏    if( rc==SQLITE_OK ){Ÿ'      /* Change to WRITER_LOCKED state.®      **ŸF      ** WAL mode sets Pager.eState to PAGER_WRITER_LOCKED or CACHEMODŸI      ** when it has an open transaction, but never to DBMOD or FINISHED.ŸI      ** This is because in those states the code to roll back savepoint ŸK      ** transactions may copy data from the sub-journal into the database ŸJ      ** file as well as into the page cache. Which would be incorrect in ≤      ** WAL mode.®      */Ÿ+      pPager->eState = PAGER_WRITER_LOCKED;Ÿ*      pPager->dbHintSize = pPager->dbSize;Ÿ*      pPager->dbFileSize = pPager->dbSize;Ÿ*      pPager->dbOrigSize = pPager->dbSize;Ω      pPager->journalOff = 0;•    }†Ÿ<    assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );ŸC    assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );Ÿ)    assert( assert_pager_state(pPager) );£  }†Ÿ4  PAGERTRACE(("TRANSACTION %d\n", PAGERID(pPager)));¨  return rc;°}†¢/*Ÿ7** Write page pPg onto the end of the rollback journal.¢*/ŸEstatic SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;©  int rc;¨  u32 cksum;Ø  char *pData2;Ÿ   i64 iOff = pPager->journalOff;†Ÿ<  /* We should never write to the journal file the page thatŸ@  ** contains the database locks.  The following assert verifies∑  ** that we do not. */Ÿ-  assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) );†Ÿ3  assert( pPager->journalHdr<=pPager->journalOff );ŸM  CODEC2(pPager, pPg->pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);Ÿ+  cksum = pager_cksum(pPager, (u8*)pData2);†ŸA  /* Even if an IO or diskfull error occurs while journalling theŸB  ** page in the block above, set the need-sync flag for the page.ŸA  ** Otherwise, when the transaction is rolled back, the logic inŸF  ** playback_one_page() will think that the page needs to be restoredŸD  ** in the database file. And if an IO error occurs while doing so,Ÿ   ** then corruption may follow.§  */Ÿ   pPg->flags |= PGHDR_NEED_SYNC;†Ÿ1  rc = write32bits(pPager->jfd, iOff, pPg->pgno);Ÿ   if( rc!=SQLITE_OK ) return rc;ŸE  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);Ÿ   if( rc!=SQLITE_OK ) return rc;Ÿ@  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);Ÿ   if( rc!=SQLITE_OK ) return rc;†Ÿ6  IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno, Ÿ2           pPager->journalOff, pPager->pageSize));Ÿ)  PAGER_INCR(sqlite3_pager_writej_count);Ÿ<  PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",Ÿ#       PAGERID(pPager), pPg->pgno, ŸA       ((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg)));†Ÿ-  pPager->journalOff += 8 + pPager->pageSize;±  pPager->nRec++;Ÿ"  assert( pPager->pInJournal!=0 );Ÿ7  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);ø  testcase( rc==SQLITE_NOMEM );Ÿ.  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );Ÿ1  rc |= addToSavepointBitvecs(pPager, pPg->pgno);Ÿ.  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );¨  return rc;°}†¢/*ŸF** Mark a single data page as writeable. The page is written into the ŸG** main journal or sub-journal as required. If the page is written intoŸ<** one of the journals, the corresponding bit is set in the ŸF** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecsŸ)** of any open savepoints as appropriate.¢*/Ÿ#static int pager_write(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;µ  int rc = SQLITE_OK;†ŸG  /* This routine is not called unless a write-transaction has already ŸI  ** been started. The journal file may or may not be open at this point.Ÿ+  ** It is never called in the ERROR state.§  */Ÿ-  assert( pPager->eState==PAGER_WRITER_LOCKEDŸ/       || pPager->eState==PAGER_WRITER_CACHEMODŸ,       || pPager->eState==PAGER_WRITER_DBMOD§  );Ÿ'  assert( assert_pager_state(pPager) );ø  assert( pPager->errCode==0 );Ÿ   assert( pPager->readOnly==0 );≤  CHECK_PAGE(pPg);†ŸL  /* The journal file needs to be opened. Higher level routines have alreadyŸI  ** obtained the necessary locks to begin the write-transaction, but theŸM  ** rollback journal might not yet be open. Open it now if this is the case.§  **ŸG  ** This is done before calling sqlite3PcacheMakeDirty() on the page. ŸL  ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), thenŸK  ** an error might occur and the pager would end up in WRITER_LOCKED stateŸ-  ** with pages marked as dirty in the cache.§  */Ÿ,  if( pPager->eState==PAGER_WRITER_LOCKED ){Ÿ$    rc = pager_open_journal(pPager);Ÿ"    if( rc!=SQLITE_OK ) return rc;£  }Ÿ2  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );Ÿ'  assert( assert_pager_state(pPager) );†Ÿ<  /* Mark the page that is about to be modified as dirty. */æ  sqlite3PcacheMakeDirty(pPg);†ŸK  /* If a rollback journal is in use, them make sure the page that is aboutŸK  ** to change is in the rollback journal, or if the page is a new page offŸE  ** then end of the file, make sure it is marked as PGHDR_NEED_SYNC.§  */Ÿ;  assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );ª  if( pPager->pInJournal!=0Ÿ@   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0§  ){Ÿ%    assert( pagerUseWal(pPager)==0 );Ÿ(    if( pPg->pgno<=pPager->dbOrigSize ){Ÿ.      rc = pagerAddPageToRollbackJournal(pPg);∫      if( rc!=SQLITE_OK ){≤        return rc;ß      }™    }else{Ÿ/      if( pPager->eState!=PAGER_WRITER_DBMOD ){Ÿ&        pPg->flags |= PGHDR_NEED_SYNC;ß      }Ÿ4      PAGERTRACE(("APPEND %d page %d needSync=%d\n",Ÿ)              PAGERID(pPager), pPg->pgno,Ÿ2             ((pPg->flags&PGHDR_NEED_SYNC)?1:0)));•    }£  }†ŸO  /* The PGHDR_DIRTY bit is set above when the page was added to the dirty-listŸL  ** and before writing the page into the rollback journal.  Wait until now,ŸH  ** after the page has been successfully journalled, before setting theŸM  ** PGHDR_WRITEABLE bit that indicates that the page can be safely modified.§  */Ÿ   pPg->flags |= PGHDR_WRITEABLE;¢  Ÿ@  /* If the statement journal is open and the page is not in it,Ÿ4  ** then write the page into the statement journal.§  */Ω  if( pPager->nSavepoint>0 ){Ÿ'    rc = subjournalPageIfRequired(pPg);£  }†Ÿ,  /* Update the database size and return. */Ÿ!  if( pPager->dbSize<pPg->pgno ){ø    pPager->dbSize = pPg->pgno;£  }¨  return rc;°}†¢/*ŸJ** This is a variant of sqlite3PagerWrite() that runs when the sector sizeŸO** is larger than the page size.  SQLite makes the (reasonable) assumption thatŸO** all bytes of a sector are written together by hardware.  Hence, all bytes ofŸJ** a sector need to be journalled in case of a power loss in the middle of´** a write.¢**ŸL** Usually, the sector size is less than or equal to the page size, in whichŸI** case pages can be individually written.  This routine only runs in theŸH** exceptional case where the page size is smaller than the sector size.¢*/Ÿ=static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){Ÿ0  int rc = SQLITE_OK;          /* Return code */ŸK  Pgno nPageCount;             /* Total number of pages in database file */ŸP  Pgno pg1;                    /* First page of the sector pPg is located on. */ŸO  int nPage = 0;               /* Number of pages starting at pg1 to journal */Ÿ1  int ii;                      /* Loop counter */ŸI  int needSync = 0;            /* True if any page has PGHDR_NEED_SYNC */Ÿ<  Pager *pPager = pPg->pPager; /* The pager that owns pPg */Ÿ>  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);†ŸH  /* Set the doNotSpill NOSYNC bit to 1. This is because we cannot allowŸB  ** a journal header to be written between the pages journaled by≥  ** this function.§  */≥  assert( !MEMDB );Ÿ7  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)==0 );Ÿ)  pPager->doNotSpill |= SPILLFLAG_NOSYNC;†ŸC  /* This trick assumes that both the page-size and sector-size areŸB  ** an integer power of 2. It sets variable pg1 to the identifierŸ7  ** of the first page of the sector pPg is located on.§  */Ÿ2  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;†æ  nPageCount = pPager->dbSize;Ω  if( pPg->pgno>nPageCount ){Ÿ     nPage = (pPg->pgno - pg1)+1;Ÿ0  }else if( (pg1+nPagePerSector-1)>nPageCount ){Ω    nPage = nPageCount+1-pg1;®  }else{ª    nPage = nPagePerSector;£  }≤  assert(nPage>0);π  assert(pg1<=pPg->pgno);Ÿ   assert((pg1+nPage)>pPg->pgno);†Ÿ-  for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){µ    Pgno pg = pg1+ii;±    PgHdr *pPage;ŸF    if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){Ÿ&      if( pg!=PAGER_MJ_PGNO(pPager) ){Ÿ4        rc = sqlite3PagerGet(pPager, pg, &pPage, 0);º        if( rc==SQLITE_OK ){Ÿ"          rc = pager_write(pPage);Ÿ-          if( pPage->flags&PGHDR_NEED_SYNC ){π            needSync = 1;´          }Ÿ*          sqlite3PagerUnrefNotNull(pPage);©        }ß      }Ÿ<    }else if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){Ÿ)      if( pPage->flags&PGHDR_NEED_SYNC ){µ        needSync = 1;ß      }Ÿ&      sqlite3PagerUnrefNotNull(pPage);•    }£  }†ŸC  /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages ŸF  ** starting at pg1, then it needs to be set for all of them. BecauseŸC  ** writing to any of these nPage pages may damage the others, theŸ=  ** journal file must contain sync()ed copies of all of themŸ@  ** before any of them can be written out to the database file.§  */Ÿ"  if( rc==SQLITE_OK && needSync ){µ    assert( !MEMDB );æ    for(ii=0; ii<nPage; ii++){Ÿ8      PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);≤      if( pPage ){Ÿ(        pPage->flags |= PGHDR_NEED_SYNC;Ÿ(        sqlite3PagerUnrefNotNull(pPage);ß      }•    }£  }†Ÿ7  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)!=0 );Ÿ*  pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;¨  return rc;°}†¢/*ŸE** Mark a data page as writeable. This routine must be called before ŸD** making changes to a page. The caller must check the return value ŸF** of this function and be careful not to change any page data unless Ÿ"** this routine returns SQLITE_OK.¢**ŸF** The difference between this function and pager_write() is that thisŸB** function also deals with the special case where 2 or more pagesŸB** fit on a single disk sector. In this case all co-resident pagesŸ?** must have been written to the journal file before returning.¢**ŸC** If an error occurs, SQLITE_NOMEM or an IO error code is returnedŸ(** as appropriate. Otherwise, SQLITE_OK.¢*/Ÿ1SQLITE_PRIVATE int sqlite3PagerWrite(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;Ÿ)  assert( (pPg->flags & PGHDR_MMAP)==0 );Ÿ0  assert( pPager->eState>=PAGER_WRITER_LOCKED );Ÿ'  assert( assert_pager_state(pPager) );ŸG  if( (pPg->flags & PGHDR_WRITEABLE)!=0 && pPager->dbSize>=pPg->pgno ){ŸB    if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);µ    return SQLITE_OK;æ  }else if( pPager->errCode ){ª    return pPager->errCode;Ÿ9  }else if( pPager->sectorSize > (u32)pPager->pageSize ){Ÿ"    assert( pPager->tempFile==0 );Ÿ&    return pagerWriteLargeSector(pPg);®  }else{º    return pager_write(pPg);£  }°}†¢/*ŸF** Return TRUE if the page given in the argument was previously passedŸC** to sqlite3PagerWrite().  In other words, return TRUE if it is okŸ%** to change the content of the page.¢*/Æ#ifndef NDEBUGŸ8SQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage *pPg){Ÿ&  return pPg->flags & PGHDR_WRITEABLE;°}¶#endif†¢/*ŸE** A call to this routine tells the pager that it is not necessary toŸB** write the information on page pPg back to the disk, even thoughŸG** that page might be marked as dirty.  This happens, for example, whenŸ?** the page has been added as a leaf of the freelist and so itsΩ** content no longer matters.¢**ŸG** The overlying software layer calls this routine when all of the dataŸD** on the given page is unused. The pager marks the page as clean soŸ(** that it does not get written to disk.¢**ŸF** Tests show that this optimization can quadruple the speed of large µ** DELETE operations.¢**ŸE** This optimization cannot be used with a temp-file, as the page mayŸD** have been dirty at the start of the transaction. In that case, ifŸH** memory pressure forces page pPg out of the cache, the data does need ŸC** to be written out to disk so that it may be read back in if the Ÿ&** current transaction is rolled back.¢*/Ÿ6SQLITE_PRIVATE void sqlite3PagerDontWrite(PgHdr *pPg){æ  Pager *pPager = pPg->pPager;ŸO  if( !pPager->tempFile && (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){ŸK    PAGERTRACE(("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager)));Ÿ1    IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno))Ÿ#    pPg->flags |= PGHDR_DONT_WRITE;Ÿ#    pPg->flags &= ~PGHDR_WRITEABLE;Ÿ-    testcase( pPg->flags & PGHDR_NEED_SYNC );º    pager_set_pagehash(pPg);£  }°}†¢/*ŸF** This routine is called to increment the value of the database file ŸE** change-counter, stored as a 4-byte big-endian integer starting at ŸE** byte offset 24 of the pager file.  The secondary change counter atŸD** 92 is also updated, as is the SQLite version number at offset 96.¢**ŸF** But this only happens if the pPager->changeCountDone flag is false.ŸD** To avoid excess churning of page 1, the update only happens once.ŸA** See also the pager_write_changecounter() routine that does an Ÿ/** unconditional update of the change counters.¢**ŸB** If the isDirectMode flag is zero, then this is done by calling ŸD** sqlite3PagerWrite() on page 1, then modifying the contents of theŸD** page data. In this case the file will be updated when the currentº** transaction is committed.¢**ŸI** The isDirectMode flag may only be non-zero if the library was compiledŸC** with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,ŸF** if isDirect is non-zero, then the database file is updated directlyŸ?** by writing an updated version of page 1 using a call to the Ω** sqlite3OsWrite() function.¢*/ŸEstatic int pager_incr_changecounter(Pager *pPager, int isDirectMode){µ  int rc = SQLITE_OK;†Ÿ/  assert( pPager->eState==PAGER_WRITER_CACHEMODŸ,       || pPager->eState==PAGER_WRITER_DBMOD§  );Ÿ'  assert( assert_pager_state(pPager) );†Ÿ?  /* Declare and initialize constant integer 'isDirect'. If theŸF  ** atomic-write optimization is enabled in this build, then isDirectŸE  ** is initialized to the value passed as the isDirectMode parameterŸ;  ** to this function. Otherwise, it is always set to zero.§  **Ÿ=  ** The idea is that if the atomic-write optimization is notŸ@  ** enabled at compile time, the compiler can omit the tests ofŸ;  ** 'isDirect' below, as well as the block enclosed in theŸ   ** "if( isDirect )" condition.§  */Ÿ"#ifndef SQLITE_ENABLE_ATOMIC_WRITE∂# define DIRECT_MODE 0º  assert( isDirectMode==0 );Ÿ!  UNUSED_PARAMETER(isDirectMode);•#elseŸ!# define DIRECT_MODE isDirectMode¶#endif†Ÿ=  if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){Ÿ;    PgHdr *pPgHdr;                /* Reference to page 1 */†Ÿ6    assert( !pPager->tempFile && isOpen(pPager->fd) );†Ÿ.    /* Open page 1 of the file for writing. */Ÿ0    rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);Ÿ)    assert( pPgHdr==0 || rc==SQLITE_OK );†ŸE    /* If page one was fetched successfully, and this function is notŸD    ** operating in direct-mode, make page 1 writable.  When not in ŸK    ** direct mode, page 1 is always held in cache and hence the PagerGet()ŸF    ** above is always successful - hence the ALWAYS on rc==SQLITE_OK.¶    */Ÿ0    if( !DIRECT_MODE && ALWAYS(rc==SQLITE_OK) ){Ÿ%      rc = sqlite3PagerWrite(pPgHdr);•    }†∏    if( rc==SQLITE_OK ){Ÿ8      /* Actually do the update of the change counter */Ÿ(      pager_write_changecounter(pPgHdr);†ŸP      /* If running in direct mode, write the contents of page 1 to the file. */∏      if( DIRECT_MODE ){π        const void *zBuf;Ÿ'        assert( pPager->dbFileSize>0 );ŸH        CODEC2(pPager, pPgHdr->pData, 1, 6, rc=SQLITE_NOMEM_BKPT, zBuf);º        if( rc==SQLITE_OK ){ŸE          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);Ÿ,          pPager->aStat[PAGER_STAT_WRITE]++;©        }º        if( rc==SQLITE_OK ){ŸJ          /* Update the pager's copy of the change-counter. Otherwise, theŸE          ** next time a read transaction is opened the cache will beŸG          ** flushed (as the change-counter values will not match).  */ŸF          const void *pCopy = (const void *)&((const char *)zBuf)[24];ŸI          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));Ÿ&          pPager->changeCountDone = 1;©        }¨      }else{Ÿ$        pPager->changeCountDone = 1;ß      }•    }†Ÿ%    /* Release the page reference. */æ    sqlite3PagerUnref(pPgHdr);£  }¨  return rc;°}†¢/*ŸJ** Sync the database file to disk. This is a no-op for in-memory databasesŸ+** or pages with the Pager.noSync flag set.¢**ŸG** If successful, or if called on a pager for which it is a no-op, thisŸG** function returns SQLITE_OK. Otherwise, an IO error code is returned.¢*/ŸHSQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster){µ  int rc = SQLITE_OK;æ  void *pArg = (void*)zMaster;ŸA  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);Ÿ+  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;Ÿ)  if( rc==SQLITE_OK && !pPager->noSync ){µ    assert( !MEMDB );Ÿ6    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);£  }¨  return rc;°}†¢/*ŸJ** This function may only be called while a write-transaction is active inŸE** rollback. If the connection is in WAL mode, this call is a no-op. ŸK** Otherwise, if the connection does not already have an EXCLUSIVE lock on Ÿ7** the database file, an attempt is made to obtain one.¢**ŸG** If the EXCLUSIVE lock is already held or the attempt to obtain it isŸG** successful, or the connection is in WAL mode, SQLITE_OK is returned.ŸF** Otherwise, either SQLITE_BUSY or an SQLITE_IOERR_XXX error code is ¨** returned.¢*/Ÿ<SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager *pPager){ª  int rc = pPager->errCode;Ÿ'  assert( assert_pager_state(pPager) );∂  if( rc==SQLITE_OK ){Ÿ2    assert( pPager->eState==PAGER_WRITER_CACHEMOD Ÿ/         || pPager->eState==PAGER_WRITER_DBMOD Ÿ0         || pPager->eState==PAGER_WRITER_LOCKED ¶    );Ÿ)    assert( assert_pager_state(pPager) );Ÿ!    if( 0==pagerUseWal(pPager) ){Ÿ6      rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);•    }£  }¨  return rc;°}†¢/*ŸJ** Sync the database file for the pager pPager. zMaster points to the nameŸF** of a master journal file that should be written into the individualŸG** journal file. zMaster may be NULL, which is interpreted as no masterŸ+** journal (a single database transaction).¢**Ω** This routine ensures that:¢**Ÿ3**   * The database file change-counter is updated,ŸL**   * the journal is synced (unless the atomic-write optimization is used),Ÿ9**   * all dirty pages are written to the database file, Ÿ8**   * the database file is truncated (if required), andŸ!**   * the database file synced. ¢**ŸH** The only thing that remains to commit the transaction is to finalize ŸE** (delete, truncate or zero the first part of) the journal file (or Ÿ0** delete the master journal file if specified).¢**ŸG** Note that if zMaster==NULL, this does not overwrite a previous valueŸ2** passed to an sqlite3PagerCommitPhaseOne() call.¢**ŸK** If the final parameter - noSync - is true, then the database file itselfŸE** is not synced. The caller must call sqlite3PagerSync() directly toŸG** sync the database file before calling CommitPhaseTwo() to delete theΩ** journal file in this case.¢*/Ÿ.SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Ÿ4  Pager *pPager,                  /* Pager object */ŸL  const char *zMaster,            /* If not NULL, the master journal name */ŸM  int noSync                      /* True to omit the xSync on the db file */¢){Ÿ3  int rc = SQLITE_OK;             /* Return code */†Ÿ-  assert( pPager->eState==PAGER_WRITER_LOCKEDŸ/       || pPager->eState==PAGER_WRITER_CACHEMODŸ,       || pPager->eState==PAGER_WRITER_DBMODŸ%       || pPager->eState==PAGER_ERROR§  );Ÿ'  assert( assert_pager_state(pPager) );†Ÿ;  /* If a prior error occurred, report that error again. */Ÿ6  if( NEVER(pPager->errCode) ) return pPager->errCode;†ŸJ  /* Provide the ability to easily simulate an I/O error during testing */Ÿ1  if( sqlite3FaultSim(400) ) return SQLITE_IOERR;†Ÿ>  PAGERTRACE(("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n", Ÿ3      pPager->zFilename, zMaster, pPager->dbSize));†Ÿ<  /* If no database changes have been made, return early. */Ÿ>  if( pPager->eState<PAGER_WRITER_CACHEMOD ) return SQLITE_OK;†Ÿ)  assert( MEMDB==0 || pPager->tempFile );Ÿ3  assert( isOpen(pPager->fd) || pPager->tempFile );Ÿ)  if( 0==pagerFlushOnCommit(pPager, 1) ){ŸL    /* If this is an in-memory db, or no pages have been written to, or thisŸL    ** function has already been called, it is mostly a no-op.  However, anyŸ4    ** backup in progress needs to be restarted.  */Ÿ*    sqlite3BackupRestart(pPager->pBackup);®  }else{æ    if( pagerUseWal(pPager) ){Ÿ=      PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);∫      PgHdr *pPageOne = 0;µ      if( pList==0 ){Ÿ?        /* Must have at least one page for the WAL commit flag.Ÿ?        ** Ticket [2d1a5c67dfc2363e44f29d9bbd57f] 2011-05-18 */Ÿ6        rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);π        pList = pPageOne;∫        pList->pDirty = 0;ß      }æ      assert( rc==SQLITE_OK );∫      if( ALWAYS(pList) ){Ÿ>        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);ß      }Ÿ"      sqlite3PagerUnref(pPageOne);∫      if( rc==SQLITE_OK ){Ÿ/        sqlite3PcacheCleanAll(pPager->pPCache);ß      }™    }else{ŸK      /* The bBatch boolean is true if the batch-atomic-write commit methodŸN      ** should be used.  No rollback journal is created if batch-atomic-write¥      ** is enabled.®      */Ÿ$      sqlite3_file *fd = pPager->fd;Ÿ'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITEŸP      const int bBatch = zMaster==0    /* An SQLITE_IOCAP_BATCH_ATOMIC commit */ŸK        && (sqlite3OsDeviceCharacteristics(fd) & SQLITE_IOCAP_BATCH_ATOMIC)∫        && !pPager->noSyncŸ1        && sqlite3JournalIsInMemory(pPager->jfd);•#else±# define bBatch 0¶#endif†Ÿ!#ifdef SQLITE_ENABLE_ATOMIC_WRITEŸG      /* The following block updates the change-counter. Exactly how itŸK      ** does this depends on whether or not the atomic-update optimizationŸH      ** was enabled at compile time, and if this transaction meets the Ÿ0      ** runtime criteria to use the operation: ®      **ŸD      **    * The file-system supports the atomic-write property forŸ,      **      blocks of size page-size, and ŸF      **    * This commit is not part of a multi-file transaction, andŸO      **    * Exactly one page has been modified and store in the journal file.®      **ŸF      ** If the optimization was not enabled at compile time, then theŸK      ** pager_incr_changecounter() function is called to update the changeŸK      ** counter in 'indirect-mode'. If the optimization is compiled in butŸK      ** is not applicable to this transaction, call sqlite3JournalCreate()ŸK      ** to make sure the journal file has actually been created, then callŸL      ** pager_incr_changecounter() to update the change-counter in indirectØ      ** mode. ®      **ŸG      ** Otherwise, if the optimization is both enabled and applicable,ŸJ      ** then call pager_incr_changecounter() to update the change-counterŸF      ** in 'direct' mode. In this case the journal file will never beŸ&      ** created for this transaction.®      */∂      if( bBatch==0 ){≥        PgHdr *pPg;Ÿ$        assert( isOpen(pPager->jfd) Ÿ:            || pPager->journalMode==PAGER_JOURNALMODE_OFF Ÿ:            || pPager->journalMode==PAGER_JOURNALMODE_WAL Æ            );Ÿ,        if( !zMaster && isOpen(pPager->jfd) Ÿ7         && pPager->journalOff==jrnlBufferSize(pPager) Ÿ.         && pPager->dbSize>=pPager->dbOrigSizeŸP         && (!(pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)™        ){ŸP          /* Update the db file change counter via the direct-write method. The ŸO          ** following call will modify the in-memory representation of page 1 ŸI          ** to include the updated change counter and then write page 1 ŸH          ** directly to the database file. Because of the atomic-write Ÿ<          ** property of the host file-system, this is safe.¨          */Ÿ3          rc = pager_incr_changecounter(pPager, 1);Æ        }else{Ÿ1          rc = sqlite3JournalCreate(pPager->jfd);æ          if( rc==SQLITE_OK ){Ÿ5            rc = pager_incr_changecounter(pPager, 0);´          }©        }ß      }¶#else Ÿ'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE¥      if( zMaster ){Ÿ/        rc = sqlite3JournalCreate(pPager->jfd);Ÿ7        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;ß      }¶#endifŸ/      rc = pager_incr_changecounter(pPager, 0);¶#endifŸ5      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;¢  ŸJ      /* Write the master journal name into the journal file. If a master ŸI      ** journal file name has already been written to the journal file, ŸN      ** or if zMaster is NULL (no master journal), then this call is a no-op.®      */Ÿ/      rc = writeMasterJournal(pPager, zMaster);Ÿ5      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;¢  ŸI      /* Sync the journal file and write all dirty pages to the database.ŸM      ** If the atomic-update optimization is being used, this sync will not Ÿ8      ** create the journal file or perform any real IO.®      **ŸF      ** Because the change-counter page was just modified, unless theŸI      ** atomic-update optimization is used it is almost certain that theŸI      ** journal requires a sync here. However, in locking_mode=exclusiveŸL      ** on a system under memory pressure it is just possible that this is ŸJ      ** not the case. In this case it is likely enough that the redundantŸC      ** xSync() call will be changed to a no-op by the OS anyhow. ®      */Ÿ"      rc = syncJournal(pPager, 0);Ÿ5      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;†≥      if( bBatch ){ŸJ        /* The pager is now in DBMOD state. But regardless of what happensŸL        ** next, attempting to play the journal back into the database wouldŸI        ** be unsafe. Close it now to make sure that does not happen.  */Ÿ$        sqlite3OsClose(pPager->jfd);ŸJ        rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, 0);Ÿ7        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;ß      }ŸP      rc = pager_write_pagelist(pPager,sqlite3PcacheDirtyList(pPager->pPCache));≥      if( bBatch ){º        if( rc==SQLITE_OK ){ŸM          rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, 0);©        }º        if( rc!=SQLITE_OK ){ŸN          sqlite3OsFileControlHint(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);©        }ß      }†∫      if( rc!=SQLITE_OK ){Ÿ+        assert( rc!=SQLITE_IOERR_BLOCKED );Ÿ#        goto commit_phase_one_exit;ß      }Ÿ-      sqlite3PcacheCleanAll(pPager->pPCache);†ŸE      /* If the file on disk is smaller than the database image, use ŸN      ** pager_truncate to grow the file here. This can happen if the databaseŸK      ** image was extended as part of the current transaction and then theŸK      ** last page in the db image moved to the free-list. In this case theŸJ      ** last page is never written out to disk, leaving the database fileŸ8      ** undersized. Fix this now if it is the case.  */Ÿ.      if( pPager->dbSize>pPager->dbFileSize ){ŸM        Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));Ÿ5        assert( pPager->eState==PAGER_WRITER_DBMOD );Ÿ*        rc = pager_truncate(pPager, nNew);Ÿ7        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;ß      }¢  Ÿ,      /* Finally, sync the database file. */¥      if( !noSync ){Ÿ/        rc = sqlite3PagerSync(pPager, zMaster);ß      }Ÿ&      IOTRACE(("DBSYNC %p\n", pPager))•    }£  }†∂commit_phase_one_exit:Ÿ.  if( rc==SQLITE_OK && !pagerUseWal(pPager) ){Ÿ+    pPager->eState = PAGER_WRITER_FINISHED;£  }¨  return rc;°}††¢/*ŸF** When this function is called, the database file has been completelyŸE** updated to reflect the changes made by the current transaction andŸD** synced to disk. The journal file still exists in the file-system ŸC** though, and if a failure occurs at this point it will eventuallyŸD** be used as a hot-journal and the current transaction rolled back.¢**ŸA** This function finalizes the journal file, either by deleting, ŸA** truncating or partially zeroing it, so that it cannot be used ŸA** for hot-journal rollback. Once this is done the transaction isπ** irrevocably committed.¢**ŸA** If an error occurs, an IO error code is returned and the pagerŸ@** moves into the error state. Otherwise, SQLITE_OK is returned.¢*/Ÿ=SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager *pPager){Ÿ8  int rc = SQLITE_OK;                  /* Return code */†ŸE  /* This routine should not be called if a prior error has occurred.ŸG  ** But if (due to a coding error elsewhere in the system) it does getŸG  ** called, just return the same error code without doing anything. */Ÿ6  if( NEVER(pPager->errCode) ) return pPager->errCode;†Ÿ-  assert( pPager->eState==PAGER_WRITER_LOCKEDŸ/       || pPager->eState==PAGER_WRITER_FINISHEDŸH       || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD)§  );Ÿ'  assert( assert_pager_state(pPager) );†ŸF  /* An optimization. If the database was not actually modified duringŸD  ** this transaction, the pager is running in exclusive-mode and isŸ>  ** using persistent journals, then this function is a no-op.§  **ŸG  ** The start of the journal file currently contains a single journal ŸF  ** header with the nRec field set to 0. If such a journal is used asŸF  ** a hot-journal during hot-journal rollback, 0 changes will be madeŸC  ** to the database file. So there is no need to zero the journal ŸC  ** header. Since the pager is in exclusive mode, there is no needæ  ** to drop any locks either.§  */Ÿ*  if( pPager->eState==PAGER_WRITER_LOCKED º   && pPager->exclusiveMode Ÿ4   && pPager->journalMode==PAGER_JOURNALMODE_PERSIST§  ){ŸP    assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );Ÿ"    pPager->eState = PAGER_READER;µ    return SQLITE_OK;£  }†Ÿ/  PAGERTRACE(("COMMIT %d\n", PAGERID(pPager)));π  pPager->iDataVersion++;Ÿ;  rc = pager_end_transaction(pPager, pPager->setMaster, 1);Ÿ!  return pager_error(pPager, rc);°}†¢/*ŸD** If a write transaction is open, then all changes made within the ŸH** transaction are reverted and the current write-transaction is closed.ŸK** The pager falls back to PAGER_READER state if successful, or PAGER_ERRORº** state if an error occurs.¢**ŸM** If the pager is already in PAGER_ERROR state when this function is called,ŸK** it returns Pager.errCode immediately. No work is performed in this case.¢**ŸE** Otherwise, in rollback mode, this function performs two functions:¢**ŸH**   1) It rolls back the journal file, restoring all database file and ŸL**      in-memory cache pages to the state they were in when the transaction∑**      was opened, and¢**ŸE**   2) It finalizes the journal file, so that it is not used for hotŸ,**      rollback at any point in the future.¢**ŸF** Finalization of the journal file (task 2) is only performed if the ∫** rollback is successful.¢**ŸE** In WAL mode, all cache-entries containing data modified within theŸH** current transaction are either expelled from the cache or reverted toŸF** their pre-transaction state by re-reading data from the database orŸ1** WAL files. The WAL transaction is then closed.¢*/Ÿ7SQLITE_PRIVATE int sqlite3PagerRollback(Pager *pPager){Ÿ8  int rc = SQLITE_OK;                  /* Return code */Ÿ1  PAGERTRACE(("ROLLBACK %d\n", PAGERID(pPager)));†ŸE  /* PagerRollback() is a no-op if called in READER or OPEN state. IfŸB  ** the pager is already in the ERROR state, the rollback is not ŸG  ** attempted here. Instead, the error code is returned to the caller.§  */Ÿ'  assert( assert_pager_state(pPager) );Ÿ;  if( pPager->eState==PAGER_ERROR ) return pPager->errCode;Ÿ6  if( pPager->eState<=PAGER_READER ) return SQLITE_OK;†º  if( pagerUseWal(pPager) ){¨    int rc2;Ÿ?    rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);Ÿ>    rc2 = pager_end_transaction(pPager, pPager->setMaster, 0);Ÿ!    if( rc==SQLITE_OK ) rc = rc2;ŸJ  }else if( !isOpen(pPager->jfd) || pPager->eState==PAGER_WRITER_LOCKED ){Ÿ     int eState = pPager->eState;Ÿ-    rc = pager_end_transaction(pPager, 0, 0);Ÿ/    if( !MEMDB && eState>PAGER_WRITER_LOCKED ){ŸM      /* This can happen using journal_mode=off. Move the pager to the error ŸM      ** state to indicate that the contents of the cache may not be trusted.Ÿ2      ** Any active readers will get SQLITE_ABORT.®      */Ÿ%      pPager->errCode = SQLITE_ABORT;Ÿ#      pPager->eState = PAGER_ERROR;æ      setGetterMethod(pPager);∞      return rc;•    }®  }else{Ÿ#    rc = pager_playback(pPager, 0);£  }†Ÿ:  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );Ÿ@  assert( rc==SQLITE_OK || rc==SQLITE_FULL || rc==SQLITE_CORRUPTŸ9          || rc==SQLITE_NOMEM || (rc&0xFF)==SQLITE_IOERR Ÿ           || rc==SQLITE_CANTOPEN§  );†ŸK  /* If an error occurs during a ROLLBACK, we can no longer trust the pagerŸN  ** cache. So call pager_error() on the way out to make any error persistent.§  */Ÿ!  return pager_error(pPager, rc);°}†¢/*ŸF** Return TRUE if the database file is opened read-only.  Return FALSEŸ+** if the database is (in theory) writable.¢*/Ÿ8SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager *pPager){∫  return pPager->readOnly;°}†≥#ifdef SQLITE_DEBUG¢/*ŸG** Return the sum of the reference counts for all pages held by pPager.¢*/Ÿ7SQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager){Ÿ0  return sqlite3PcacheRefCount(pPager->pPCache);°}¶#endif†¢/*Ÿ=** Return the approximate number of bytes of memory currentlyŸ.** used by the pager and its associated cache.¢*/Ÿ6SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager *pPager){ŸE  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)Ÿ7                                     + 5*sizeof(void*);Ÿ<  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)Ÿ&           + sqlite3MallocSize(pPager)æ           + pPager->pageSize;°}†¢/*Ÿ9** Return the number of references to the specified page.¢*/Ÿ;SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage *pPage){Ÿ*  return sqlite3PcachePageRefcount(pPage);°}†≤#ifdef SQLITE_TEST¢/*Ÿ6** This routine is used for testing and analysis only.¢*/Ÿ5SQLITE_PRIVATE int *sqlite3PagerStats(Pager *pPager){≥  static int a[11];Ÿ0  a[0] = sqlite3PcacheRefCount(pPager->pPCache);Ÿ1  a[1] = sqlite3PcachePagecount(pPager->pPCache);Ÿ4  a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);Ÿ@  a[3] = pPager->eState==PAGER_OPEN ? -1 : (int) pPager->dbSize;∏  a[4] = pPager->eState;π  a[5] = pPager->errCode;Ÿ'  a[6] = pPager->aStat[PAGER_STAT_HIT];Ÿ(  a[7] = pPager->aStat[PAGER_STAT_MISS];Ÿ+  a[8] = 0;  /* Used to be pPager->nOvfl */∑  a[9] = pPager->nRead;Ÿ*  a[10] = pPager->aStat[PAGER_STAT_WRITE];´  return a;°}¶#endif†¢/*ŸK** Parameter eStat must be one of SQLITE_DBSTATUS_CACHE_HIT, _MISS, _WRITE,ŸH** or _WRITE+1.  The SQLITE_DBSTATUS_CACHE_WRITE+1 case is a translationŸM** of SQLITE_DBSTATUS_CACHE_SPILL.  The _SPILL case is not contiguous because∂** it was added later.¢**Ÿ1** Before returning, *pnVal is incremented by theŸL** current cache hit or miss count, according to the value of eStat. If the ŸM** reset parameter is non-zero, the cache hit or miss count is zeroed before ≠** returning.¢*/Ÿ[SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){†Ÿ*  assert( eStat==SQLITE_DBSTATUS_CACHE_HITŸ+       || eStat==SQLITE_DBSTATUS_CACHE_MISSŸ,       || eStat==SQLITE_DBSTATUS_CACHE_WRITEŸ.       || eStat==SQLITE_DBSTATUS_CACHE_WRITE+1§  );†ŸD  assert( SQLITE_DBSTATUS_CACHE_HIT+1==SQLITE_DBSTATUS_CACHE_MISS );ŸE  assert( SQLITE_DBSTATUS_CACHE_HIT+2==SQLITE_DBSTATUS_CACHE_WRITE );Ÿ1  assert( PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1Ÿ;           && PAGER_STAT_WRITE==2 && PAGER_STAT_SPILL==3 );†Ÿ%  eStat -= SQLITE_DBSTATUS_CACHE_HIT;Ÿ!  *pnVal += pPager->aStat[eStat];Æ  if( reset ){Ω    pPager->aStat[eStat] = 0;£  }°}†¢/*ŸA** Return true if this is an in-memory or temp-file backed pager.¢*/Ÿ6SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager){∫  return pPager->tempFile;°}†¢/*ŸI** Check that there are at least nSavepoint savepoints open. If there areŸI** currently less than nSavepoints open, then open one or more savepointsŸD** to make up the difference. If the number of savepoints is alreadyŸ6** equal to nSavepoint, then this function is a no-op.¢**ŸG** If a memory allocation fails, SQLITE_NOMEM is returned. If an error ŸF** occurs while opening the sub-journal file, then an IO error code isŸ"** returned. Otherwise, SQLITE_OK.¢*/ŸMstatic SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){Ÿ=  int rc = SQLITE_OK;                       /* Return code */ŸN  int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */ŸC  int ii;                                   /* Iterator variable */ŸL  PagerSavepoint *aNew;                     /* New Pager.aSavepoint array */†Ÿ0  assert( pPager->eState>=PAGER_WRITER_LOCKED );Ÿ'  assert( assert_pager_state(pPager) );Ÿ6  assert( nSavepoint>nCurrent && pPager->useJournal );†ŸI  /* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEMŸH  ** if the allocation fails. Otherwise, zero the new portion in case a ŸJ  ** malloc failure occurs while populating it in the for(...) loop below.§  */Ÿ*  aNew = (PagerSavepoint *)sqlite3Realloc(Ÿ;      pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint§  );Æ  if( !aNew ){Ω    return SQLITE_NOMEM_BKPT;£  }ŸM  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));º  pPager->aSavepoint = aNew;†Ÿ>  /* Populate the PagerSavepoint structures just allocated. */Ÿ(  for(ii=nCurrent; ii<nSavepoint; ii++){Ÿ$    aNew[ii].nOrig = pPager->dbSize;Ÿ6    if( isOpen(pPager->jfd) && pPager->journalOff>0 ){Ÿ,      aNew[ii].iOffset = pPager->journalOff;™    }else{Ÿ0      aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);•    }Ÿ'    aNew[ii].iSubRec = pPager->nSubRec;Ÿ@    aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);Ÿ!    if( !aNew[ii].pInSavepoint ){ø      return SQLITE_NOMEM_BKPT;•    }æ    if( pagerUseWal(pPager) ){Ÿ;      sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);•    }æ    pPager->nSavepoint = ii+1;£  }Ÿ+  assert( pPager->nSavepoint==nSavepoint );Ÿ#  assertTruncateConstraint(pPager);¨  return rc;°}ŸLSQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){Ÿ0  assert( pPager->eState>=PAGER_WRITER_LOCKED );Ÿ'  assert( assert_pager_state(pPager) );†Ÿ<  if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){Ÿ2    return pagerOpenSavepoint(pPager, nSavepoint);®  }else{µ    return SQLITE_OK;£  }°}††¢/*ŸG** This function is called to rollback or release (commit) a savepoint.ŸF** The savepoint to release or rollback need not be the most recently µ** created savepoint.¢**ŸI** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.ŸJ** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint withŸK** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changesŸ@** that have occurred since the specified savepoint was created.¢**ŸC** The savepoint to rollback or release is identified by parameter ŸG** iSavepoint. A value of 0 means to operate on the outermost savepointŸE** (the first created). A value of (Pager.nSavepoint-1) means operateŸH** on the most recently created savepoint. If iSavepoint is greater thanŸ7** (Pager.nSavepoint-1), then this function is a no-op.¢**ŸC** If a negative value is passed to this function, then the currentŸ<** transaction is rolled back. This is different to calling ŸB** sqlite3PagerRollback() because this function does not terminateŸ@** the transaction or unlock the database, it just restores the Ÿ3** contents of the database to its original state. ¢**ŸE** In any case, all savepoints with an index greater than iSavepoint ŸI** are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),Ÿ/** then savepoint iSavepoint is also destroyed.¢**ŸF** This function may return SQLITE_NOMEM if a memory allocation fails,ŸB** or an IO error code if an IO error occurs while rolling back a Ÿ8** savepoint. If no errors occur, SQLITE_OK is returned.£*/ ŸPSQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){ª  int rc = pPager->errCode;¢  ª#ifdef SQLITE_ENABLE_ZIPVFSŸ-  if( op==SAVEPOINT_RELEASE ) rc = SQLITE_OK;¶#endif†Ÿ<  assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );Ÿ4  assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK );†Ÿ7  if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){Ÿ.    int ii;            /* Iterator variable */ŸJ    int nNew;          /* Number of remaining savepoints after this op. */†ŸE    /* Figure out how many savepoints will still be active after thisŸK    ** operation. Store this value in nNew. Then free resources associated Ÿ@    ** with any savepoints that are destroyed by this operation.¶    */Ÿ<    nNew = iSavepoint + (( op==SAVEPOINT_RELEASE ) ? 0 : 1);Ÿ.    for(ii=nNew; ii<pPager->nSavepoint; ii++){Ÿ@      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);•    }æ    pPager->nSavepoint = nNew;†ŸA    /* If this is a release of the outermost savepoint, truncate Ÿ0    ** the sub-journal to zero bytes in size. */Ÿ     if( op==SAVEPOINT_RELEASE ){Ÿ,      if( nNew==0 && isOpen(pPager->sjfd) ){Ÿ>        /* Only truncate if it is an in-memory sub-journal. */Ÿ5        if( sqlite3JournalIsInMemory(pPager->sjfd) ){Ÿ2          rc = sqlite3OsTruncate(pPager->sjfd, 0);Ÿ"          assert( rc==SQLITE_OK );©        }º        pPager->nSubRec = 0;ß      }•    }ŸK    /* Else this is a rollback operation, playback the specified savepoint.ŸG    ** If this is a temp-file, it is possible that the journal file hasŸF    ** not yet been opened. In this case there have been no changes toŸC    ** the database file, so the playback operation can be skipped.¶    */Ÿ:    else if( pagerUseWal(pPager) || isOpen(pPager->jfd) ){ŸK      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];Ÿ6      rc = pagerPlaybackSavepoint(pPager, pSavepoint);æ      assert(rc!=SQLITE_DONE);•    }§    ª#ifdef SQLITE_ENABLE_ZIPVFSŸI    /* If the cache has been modified but the savepoint cannot be rolled ŸI    ** back journal_mode=off, put the pager in the error state. This way,ŸL    ** if the VFS used by this pager includes ZipVFS, the entire transactionŸ2    ** can be rolled back at the ZipVFS level.  */≠    else if( Ÿ3        pPager->journalMode==PAGER_JOURNALMODE_OFF Ÿ-     && pPager->eState>=PAGER_WRITER_CACHEMOD¶    ){Ÿ%      pPager->errCode = SQLITE_ABORT;Ÿ#      pPager->eState = PAGER_ERROR;æ      setGetterMethod(pPager);•    }¶#endif£  }†¨  return rc;°}†¢/*Ÿ1** Return the full pathname of the database file.¢**ŸI** Except, if the pager is in-memory only, then return an empty string ifŸH** nullIfMemDb is true.  This routine is called with nullIfMemDb==1 whenŸI** used to report the filename to the user, for compatibility with legacyŸK** behavior.  But when the Btree needs to know the filename for matching toŸG** shared cache, it uses nullIfMemDb==0 so that in-memory databases canø** participate in shared-cache.¢*/ŸPSQLITE_PRIVATE const char *sqlite3PagerFilename(Pager *pPager, int nullIfMemDb){ŸA  return (nullIfMemDb && pPager->memDb) ? "" : pPager->zFilename;°}†¢/*Ÿ*** Return the VFS structure for the pager.¢*/Ÿ;SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){∂  return pPager->pVfs;°}†¢/*Ÿ:** Return the file handle for the database file associatedŸ:** with the pager.  This might return NULL if the file has∑** not yet been opened.¢*/Ÿ=SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager){¥  return pPager->fd;°}†Ÿ"#ifdef SQLITE_ENABLE_SETLK_TIMEOUT¢/*Ÿ$** Reset the lock timeout for pager.¢*/Ÿ@SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager){¨  int x = 0;ŸB  sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_LOCK_TIMEOUT, &x);°}¶#endif†¢/*Ÿ>** Return the file handle for the journal file (if it exists).Ÿ<** This will be either the rollback journal or the WAL file.¢*/ŸASQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){≥#if SQLITE_OMIT_WALµ  return pPager->jfd;•#elseŸC  return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;¶#endif°}†¢/*Ÿ0** Return the full pathname of the journal file.¢*/ŸBSQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager){∫  return pPager->zJournal;°}†∑#ifdef SQLITE_HAS_CODEC¢/*Ÿ+** Set or retrieve the codec for this pager¢*/Ÿ)SQLITE_PRIVATE void sqlite3PagerSetCodec(∞  Pager *pPager,Ÿ(  void *(*xCodec)(void*,void*,Pgno,int),Ÿ(  void (*xCodecSizeChng)(void*,int,int),º  void (*xCodecFree)(void*),Æ  void *pCodec¢){Ÿ>  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);Ÿ.  pPager->xCodec = pPager->memDb ? 0 : xCodec;Ÿ*  pPager->xCodecSizeChng = xCodecSizeChng;Ÿ"  pPager->xCodecFree = xCodecFree;∫  pPager->pCodec = pCodec;∫  setGetterMethod(pPager);∫  pagerReportSize(pPager);°}Ÿ9SQLITE_PRIVATE void *sqlite3PagerGetCodec(Pager *pPager){∏  return pPager->pCodec;°}†¢/*ŸF** This function is called by the wal module when writing page contentµ** into the log file.¢**ŸG** This function returns a pointer to a buffer containing the encryptedŸB** page content. If a malloc fails, this function may return NULL.¢*/Ÿ3SQLITE_PRIVATE void *sqlite3PagerCodec(PgHdr *pPg){≤  void *aData = 0;ŸA  CODEC2(pPg->pPager, pPg->pData, pPg->pgno, 6, return 0, aData);Ø  return aData;°}†¢/*Ÿ!** Return the current pager state¢*/Ÿ4SQLITE_PRIVATE int sqlite3PagerState(Pager *pPager){∏  return pPager->eState;°}Ω#endif /* SQLITE_HAS_CODEC */†æ#ifndef SQLITE_OMIT_AUTOVACUUM¢/*Ÿ2** Move the page pPg to location pgno in the file.¢**Ÿ@** There must be no references to the page previously located atŸ@** pgno (which we call pPgOld) though that page is allowed to beŸC** in cache.  If the page previously located at pgno is not alreadyŸC** in the rollback journal, it is not put there by by this routine.¢**Ÿ8** References to the page pPg remain valid. Updating anyŸF** meta-data associated with pPg (i.e. data stored in the nExtra bytesŸF** allocated along with the page) is the responsibility of the caller.¢**ŸJ** A transaction must be active when this routine is called. It used to beŸM** required that a statement transaction was not active, but this restrictionŸG** has been removed (CREATE INDEX needs to move a page when a statement∫** transaction is active).¢**ŸI** If the fourth argument, isCommit, is non-zero, then this page is beingŸJ** moved as part of a database reorganization just before the transaction ŸM** is being committed. In this case, it is guaranteed that the database page ŸF** pPg refers to will not be written to again within this transaction.¢**ŸH** This function may return SQLITE_NOMEM or an IO error code if an errorŸ+** occurs. Otherwise, it returns SQLITE_OK.¢*/Ÿ]SQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){Ÿ@  PgHdr *pPgOld;               /* The page being overwritten. */ŸP  Pgno needSyncPgno = 0;       /* Old value of pPg->pgno, if sync is required */Ÿ0  int rc;                      /* Return code */Ÿ=  Pgno origPgno;               /* The original page number */†∏  assert( pPg->nRef>0 );Ÿ/  assert( pPager->eState==PAGER_WRITER_CACHEMODŸ,       || pPager->eState==PAGER_WRITER_DBMOD§  );Ÿ'  assert( assert_pager_state(pPager) );†ŸH  /* In order to be able to rollback, an in-memory database must journalŸ!  ** the page we are moving from.§  */Ÿ'  assert( pPager->tempFile || !MEMDB );π  if( pPager->tempFile ){Ÿ     rc = sqlite3PagerWrite(pPg);∑    if( rc ) return rc;£  }†ŸJ  /* If the page being moved is dirty and has not been saved by the latestŸD  ** savepoint, then save the current contents of the page into the ŸH  ** sub-journal now. This is required to handle the following scenario:§  **≠  **   BEGIN;Ÿ3  **     <journal page X, then modify it in memory>∑  **     SAVEPOINT one;Ÿ&  **       <Move page X to location Y>π  **     ROLLBACK TO one;§  **ŸE  ** If page X were not written to the sub-journal here, it would notŸC  ** be possible to restore its contents when the "ROLLBACK TO one"Ÿ!  ** statement were is processed.§  **ŸH  ** subjournalPage() may need to allocate space to store pPg->pgno intoŸD  ** one or more savepoint bitvecs. This is the reason this functionΩ  ** may return SQLITE_NOMEM.§  */Ÿ#  if( (pPg->flags & PGHDR_DIRTY)!=0Ÿ5   && SQLITE_OK!=(rc = subjournalPageIfRequired(pPg))§  ){Æ    return rc;£  }†Ÿ=  PAGERTRACE(("MOVE %d page %d (needSync=%d) moves to %d\n", ŸK      PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC)?1:0, pgno));Ÿ7  IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno))†ŸB  /* If the journal needs to be sync()ed before page pPg->pgno canŸC  ** be written to, store pPg->pgno in local variable needSyncPgno.§  **ŸC  ** If the isCommit flag is set, there is no need to remember thatŸE  ** the journal needs to be sync()ed before database page pPg->pgno ŸK  ** can be written to. The caller has already promised not to write to it.§  */Ÿ2  if( (pPg->flags&PGHDR_NEED_SYNC) && !isCommit ){Ω    needSyncPgno = pPg->pgno;Ÿ9    assert( pPager->journalMode==PAGER_JOURNALMODE_OFF ||ŸI            pageInJournal(pPager, pPg) || pPg->pgno>pPager->dbOrigSize );Ÿ%    assert( pPg->flags&PGHDR_DIRTY );£  }†ŸB  /* If the cache contains a page with page-number pgno, remove itŸH  ** from its hash chain. Also, if the PGHDR_NEED_SYNC flag was set for ŸD  ** page pgno before the 'move' operation, it needs to be retained æ  ** for the page moved there.§  */Ÿ!  pPg->flags &= ~PGHDR_NEED_SYNC;Ÿ,  pPgOld = sqlite3PagerLookup(pPager, pgno);Ÿ'  assert( !pPgOld || pPgOld->nRef==1 );Ø  if( pPgOld ){Ÿ2    pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC);ª    if( pPager->tempFile ){ŸG      /* Do not discard pages from an in-memory database since we mightŸG      ** need to rollback later.  Just move the page out of the way. */Ÿ2      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);™    }else{Ÿ       sqlite3PcacheDrop(pPgOld);•    }£  }†∑  origPgno = pPg->pgno;ø  sqlite3PcacheMove(pPg, pgno);æ  sqlite3PcacheMakeDirty(pPg);†ŸE  /* For an in-memory database, make sure the original page continuesŸF  ** to exist, in case the transaction needs to roll back.  Use pPgOldŸ>  ** as the original page since it has already been allocated.§  */Ÿ#  if( pPager->tempFile && pPgOld ){Ÿ(    sqlite3PcacheMove(pPgOld, origPgno);Ÿ%    sqlite3PagerUnrefNotNull(pPgOld);£  }†µ  if( needSyncPgno ){ŸF    /* If needSyncPgno is non-zero, then the journal file needs to be ŸN    ** sync()ed before any data is written to database file page needSyncPgno.Ÿ@    ** Currently, no such page exists in the page-cache and the ŸL    ** "is journaled" bitvec flag has been set. This needs to be remedied byŸL    ** loading the page into the pager-cache and setting the PGHDR_NEED_SYNC¨    ** flag.¶    **ŸF    ** If the attempt to load the page into the page-cache fails, (dueŸF    ** to a malloc() or IO failure), clear the bit in the pInJournal[]ŸC    ** array. Otherwise, if the page is loaded and written again inŸF    ** this transaction, it may be written to the database file beforeŸE    ** it is synced into the journal file. This way, it may end up inŸ9    ** the journal file twice, but that is not a problem.¶    */≤    PgHdr *pPgHdr;Ÿ;    rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);∏    if( rc!=SQLITE_OK ){Ÿ-      if( needSyncPgno<=pPager->dbOrigSize ){Ÿ'        assert( pPager->pTmpSpace!=0 );ŸP        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);ß      }∞      return rc;•    }Ÿ%    pPgHdr->flags |= PGHDR_NEED_SYNC;Ÿ#    sqlite3PcacheMakeDirty(pPgHdr);Ÿ%    sqlite3PagerUnrefNotNull(pPgHdr);£  }†≥  return SQLITE_OK;°}¶#endif†¢/*ŸG** The page handle passed as the first argument refers to a dirty page ŸH** with a page number other than iNew. This function changes the page's ŸF** page number to iNew and sets the value of the PgHdr.flags field to Ÿ+** the value passed as the third parameter.¢*/ŸISQLITE_PRIVATE void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){º  assert( pPg->pgno!=iNew );µ  pPg->flags = flags;ø  sqlite3PcacheMove(pPg, iNew);°}†¢/*Ÿ7** Return a pointer to the data for the specified page.¢*/Ÿ6SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *pPg){Ÿ.  assert( pPg->nRef>0 || pPg->pPager->memDb );¥  return pPg->pData;°}†¢/*Ÿ?** Return a pointer to the Pager.nExtra bytes of "extra" space Ÿ+** allocated along with the specified page.¢*/Ÿ7SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg){µ  return pPg->pExtra;°}†¢/*ŸG** Get/set the locking-mode for this pager. Parameter eMode must be oneŸ;** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or ŸD** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, thenŸ2** the locking-mode is set to the value specified.¢**Ÿ;** The returned value is either PAGER_LOCKINGMODE_NORMAL orŸI** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)∞** locking-mode.¢*/ŸESQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *pPager, int eMode){Ÿ(  assert( eMode==PAGER_LOCKINGMODE_QUERYŸ.            || eMode==PAGER_LOCKINGMODE_NORMALŸ4            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );Ÿ&  assert( PAGER_LOCKINGMODE_QUERY<0 );ŸJ  assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );ŸK  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );ŸM  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){Ÿ&    pPager->exclusiveMode = (u8)eMode;£  }Ÿ$  return (int)pPager->exclusiveMode;°}†¢/*ŸG** Set the journal-mode for this pager. Parameter eMode must be one of:¢**æ**    PAGER_JOURNALMODE_DELETEŸ **    PAGER_JOURNALMODE_TRUNCATEø**    PAGER_JOURNALMODE_PERSISTª**    PAGER_JOURNALMODE_OFFæ**    PAGER_JOURNALMODE_MEMORYª**    PAGER_JOURNALMODE_WAL¢**ŸJ** The journalmode is set to the value specified if the change is allowed.Ÿ:** The change may be disallowed for the following reasons:¢**ŸH**   *  An in-memory database can only have its journal_mode set to _OFF≥**      or _MEMORY.¢**Ÿ9**   *  Temporary databases cannot have _WAL journalmode.¢**ŸE** The returned indicate the current (possibly updated) journal-mode.¢*/ŸHSQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){Ÿ;  u8 eOld = pPager->journalMode;    /* Prior journalmode */†≥#ifdef SQLITE_DEBUGŸK  /* The print_pager_state() routine is intended to be used by the debuggerŸE  ** only.  We invoke it once here to suppress a compiler warning. */º  print_pager_state(pPager);¶#endif††Ÿ+  /* The eMode parameter is always valid */Ÿ.  assert(      eMode==PAGER_JOURNALMODE_DELETEŸ0            || eMode==PAGER_JOURNALMODE_TRUNCATEŸ/            || eMode==PAGER_JOURNALMODE_PERSISTŸ,            || eMode==PAGER_JOURNALMODE_OFF Ÿ,            || eMode==PAGER_JOURNALMODE_WAL Ÿ1            || eMode==PAGER_JOURNALMODE_MEMORY );†ŸD  /* This routine is only called from the OP_JournalMode opcode, andŸD  ** the logic there will never allow a temporary file to be changed±  ** to WAL mode.§  */Ÿ@  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL );†ŸC  /* Do allow the journalmode of an in-memory database to be set toŸ&  ** anything other than MEMORY or OFF§  */Æ  if( MEMDB ){ŸL    assert( eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF );ŸJ    if( eMode!=PAGER_JOURNALMODE_MEMORY && eMode!=PAGER_JOURNALMODE_OFF ){≥      eMode = eOld;•    }£  }†¥  if( eMode!=eOld ){†Ÿ"    /* Change the journal mode. */Ÿ*    assert( pPager->eState!=PAGER_ERROR );Ÿ$    pPager->journalMode = (u8)eMode;†ŸH    /* When transistioning from TRUNCATE or PERSIST to any other journalŸK    ** mode except WAL, unless the pager is in locking_mode=exclusive mode,ø    ** delete the journal file.¶    */Ÿ2    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );Ÿ1    assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );Ÿ0    assert( (PAGER_JOURNALMODE_DELETE & 5)==0 );Ÿ0    assert( (PAGER_JOURNALMODE_MEMORY & 5)==4 );Ÿ-    assert( (PAGER_JOURNALMODE_OFF & 5)==0 );Ÿ-    assert( (PAGER_JOURNALMODE_WAL & 5)==5 );†Ÿ:    assert( isOpen(pPager->fd) || pPager->exclusiveMode );ŸD    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){†ŸH      /* In this case we would like to delete the journal file. If it isŸL      ** not possible, then that is not a problem. Deleting the journal fileŸ&      ** here is an optimization only.®      **ŸH      ** Before deleting the journal file, obtain a RESERVED lock on theŸI      ** database file. This ensures that the journal file is not deletedŸ1      ** while it is in use by some other client.®      */Ÿ"      sqlite3OsClose(pPager->jfd);Ÿ)      if( pPager->eLock>=RESERVED_LOCK ){Ÿ;        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);¨      }else{ª        int rc = SQLITE_OK;Ÿ#        int state = pPager->eState;Ÿ;        assert( state==PAGER_OPEN || state==PAGER_READER );Ÿ         if( state==PAGER_OPEN ){Ÿ.          rc = sqlite3PagerSharedLock(pPager);©        }Ÿ+        if( pPager->eState==PAGER_READER ){Ÿ"          assert( rc==SQLITE_OK );Ÿ2          rc = pagerLockDb(pPager, RESERVED_LOCK);©        }º        if( rc==SQLITE_OK ){Ÿ=          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);©        }Ÿ3        if( rc==SQLITE_OK && state==PAGER_READER ){Ÿ-          pagerUnlockDb(pPager, SHARED_LOCK);Ÿ&        }else if( state==PAGER_OPEN ){ø          pager_unlock(pPager);©        }Ÿ(        assert( state==pPager->eState );ß      }Ÿ-    }else if( eMode==PAGER_JOURNALMODE_OFF ){Ÿ"      sqlite3OsClose(pPager->jfd);•    }£  }†Ÿ#  /* Return the new journal mode */Ÿ"  return (int)pPager->journalMode;°}†¢/*Ÿ#** Return the current journal mode.¢*/Ÿ=SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager *pPager){Ÿ"  return (int)pPager->journalMode;°}†¢/*ŸF** Return TRUE if the pager is in a state where it is OK to change theŸF** journalmode.  Journalmode changes can only happen when the database±** is unmodified.¢*/ŸDSQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager *pPager){Ÿ'  assert( assert_pager_state(pPager) );Ÿ7  if( pPager->eState>=PAGER_WRITER_CACHEMOD ) return 0;ŸD  if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) return 0;´  return 1;°}†¢/*Ÿ<** Get/set the size-limit used for persistent journal files.¢**Ÿ;** Setting the size limit to -1 means no limit is enforced.Ÿ8** An attempt to set a limit smaller than -1 is a no-op.¢*/ŸKSQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){≥  if( iLimit>=-1 ){Ÿ&    pPager->journalSizeLimit = iLimit;Ÿ*    sqlite3WalLimit(pPager->pWal, iLimit);£  }Ÿ"  return pPager->journalSizeLimit;°}†¢/*ŸF** Return a pointer to the pPager->pBackup variable. The backup moduleŸB** in backup.c maintains the content of this variable. This moduleŸ@** uses it opaquely as an argument to sqlite3BackupRestart() andæ** sqlite3BackupUpdate() only.¢*/ŸESQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){∫  return &pPager->pBackup;°}†∫#ifndef SQLITE_OMIT_VACUUM¢/*ŸL** Unless this is an in-memory or temporary database, clear the pager cache.¢*/Ÿ:SQLITE_PRIVATE void sqlite3PagerClearCache(Pager *pPager){Ÿ)  assert( MEMDB==0 || pPager->tempFile );Ÿ0  if( pPager->tempFile==0 ) pager_reset(pPager);°}¶#endif††∑#ifndef SQLITE_OMIT_WAL¢/*ŸI** This function is called when the user invokes "PRAGMA wal_checkpoint",ŸI** "PRAGMA wal_blocking_checkpoint" or calls the sqlite3_wal_checkpoint()Ÿ.** or wal_blocking_checkpoint() API functions.¢**ŸH** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.¢*/Ÿ*SQLITE_PRIVATE int sqlite3PagerCheckpoint(Ÿ@  Pager *pPager,                  /* Checkpoint on this pager */ŸN  sqlite3 *db,                    /* Db handle used to check for interrupts */Ÿ:  int eMode,                      /* Type of checkpoint */ŸJ  int *pnLog,                     /* OUT: Final number of frames in log */ŸP  int *pnCkpt                     /* OUT: Final number of checkpointed frames */¢){µ  int rc = SQLITE_OK;µ  if( pPager->pWal ){Ÿ6    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,ŸF        (eMode==SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager->xBusyHandler),Ÿ         pPager->pBusyHandlerArg,ŸH        pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,µ        pnLog, pnCkpt¶    );Ÿ)    sqlite3PagerResetLockTimeout(pPager);£  }¨  return rc;°}†Ÿ:SQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager){Ÿ*  return sqlite3WalCallback(pPager->pWal);°}†¢/*ŸE** Return true if the underlying VFS for the given pager supports theŸ0** primitives necessary for write-ahead logging.¢*/Ÿ;SQLITE_PRIVATE int sqlite3PagerWalSupported(Pager *pPager){Ÿ<  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;Ÿ   if( pPager->noLock ) return 0;ŸO  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);°}†¢/*ŸL** Attempt to take an exclusive lock on the database file. If a PENDING lockŸ/** is obtained instead, immediately release it.¢*/Ÿ-static int pagerExclusiveLock(Pager *pPager){Ÿ3  int rc;                         /* Return code */†ŸH  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );Ÿ+  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);∂  if( rc!=SQLITE_OK ){ŸE    /* If the attempt to grab the exclusive lock failed, release the Ÿ<    ** pending lock that may have been obtained instead.  */Ÿ'    pagerUnlockDb(pPager, SHARED_LOCK);£  }†¨  return rc;°}†¢/*ŸD** Call sqlite3WalOpen() to open the WAL handle. If the pager is in ŸI** exclusive-locking mode when this function is called, take an EXCLUSIVEŸG** lock on the database file and use heap-memory to store the wal-indexŸ/** in. Otherwise, use the normal shared-memory.¢*/Ÿ'static int pagerOpenWal(Pager *pPager){µ  int rc = SQLITE_OK;†Ÿ3  assert( pPager->pWal==0 && pPager->tempFile==0 );ŸH  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );†ŸH  /* If the pager is already in exclusive-mode, the WAL module will use ŸD  ** heap-memory for the wal-index instead of the VFS shared-memory ŸH  ** implementation. Take the exclusive lock now, before opening the WALŸ%  ** file, to make sure this is safe.§  */æ  if( pPager->exclusiveMode ){Ÿ$    rc = pagerExclusiveLock(pPager);£  }†ŸC  /* Open the connection to the log file. If this operation fails, Ÿ:  ** (e.g. due to malloc() failure), return an error code.§  */∂  if( rc==SQLITE_OK ){Ÿ%    rc = sqlite3WalOpen(pPager->pVfs,Ÿ8        pPager->fd, pPager->zWal, pPager->exclusiveMode,Ÿ/        pPager->journalSizeLimit, &pPager->pWal¶    );£  }ª  pagerFixMaplimit(pPager);†¨  return rc;°}††¢/*ŸH** The caller must be holding a SHARED lock on the database file to call±** this function.¢**ŸG** If the pager passed as the first argument is open on a real databaseŸD** file (not a temp file or an in-memory database), and the WAL fileŸF** is not already open, make an attempt to open it now. If successful,ŸJ** return SQLITE_OK. If an error occurs or the VFS used by the pager does ŸF** not support the xShmXXX() methods, return an error code. *pbOpen isø** not modified in either case.¢**ŸE** If the pager is open on a temp-file (or in-memory database), or ifŸF** the WAL file is already open, set *pbOpen to 1 and return SQLITE_OK∫** without doing anything.¢*/Ÿ'SQLITE_PRIVATE int sqlite3PagerOpenWal(Ÿ4  Pager *pPager,                  /* Pager object */ŸK  int *pbOpen                     /* OUT: Set to true if call is a no-op */¢){Ÿ3  int rc = SQLITE_OK;             /* Return code */†Ÿ'  assert( assert_pager_state(pPager) );Ÿ3  assert( pPager->eState==PAGER_OPEN   || pbOpen );Ÿ4  assert( pPager->eState==PAGER_READER || !pbOpen );Ÿ$  assert( pbOpen==0 || *pbOpen==0 );Ÿ>  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );†Ÿ+  if( !pPager->tempFile && !pPager->pWal ){ŸC    if( !sqlite3PagerWalSupported(pPager) ) return SQLITE_CANTOPEN;†Ÿ4    /* Close any rollback journal previously open */Ÿ     sqlite3OsClose(pPager->jfd);†æ    rc = pagerOpenWal(pPager);∏    if( rc==SQLITE_OK ){Ÿ2      pPager->journalMode = PAGER_JOURNALMODE_WAL;Ÿ"      pPager->eState = PAGER_OPEN;•    }®  }else{∞    *pbOpen = 1;£  }†¨  return rc;°}†¢/*ŸH** This function is called to close the connection to the log file priorŸ*** to switching from WAL to rollback mode.¢**ŸB** Before closing the log file, this function attempts to take an ŸF** EXCLUSIVE lock on the database file. If this cannot be obtained, anŸH** error (SQLITE_BUSY) is returned and the log connection is not closed.ŸF** If successful, the EXCLUSIVE lock is not released before returning.¢*/ŸDSQLITE_PRIVATE int sqlite3PagerCloseWal(Pager *pPager, sqlite3 *db){µ  int rc = SQLITE_OK;†Ÿ7  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL );†ŸL  /* If the log file is not already open, but does exist in the file-system,ŸG  ** it may need to be checkpointed before the connection can switch toŸ3  ** rollback mode. Open it now so this can happen.§  */∂  if( !pPager->pWal ){∂    int logexists = 0;Ÿ*    rc = pagerLockDb(pPager, SHARED_LOCK);∏    if( rc==SQLITE_OK ){ª      rc = sqlite3OsAccess(ŸF          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists®      );•    }Ÿ%    if( rc==SQLITE_OK && logexists ){Ÿ       rc = pagerOpenWal(pPager);•    }£  }§    ŸG  /* Checkpoint and close the log. Because an EXCLUSIVE lock is held onŸF  ** the database file, the log and log-summary files will be deleted.§  */Ÿ&  if( rc==SQLITE_OK && pPager->pWal ){Ÿ$    rc = pagerExclusiveLock(pPager);∏    if( rc==SQLITE_OK ){ŸB      rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,ŸE                           pPager->pageSize, (u8*)pPager->pTmpSpace);∑      pPager->pWal = 0;ø      pagerFixMaplimit(pPager);ŸL      if( rc && !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);•    }£  }¨  return rc;°}†Ω#ifdef SQLITE_ENABLE_SNAPSHOT¢/*ŸG** If this is a WAL database, obtain a snapshot handle for the snapshotŸ.** currently open. Otherwise, return an error.¢*/ŸYSQLITE_PRIVATE int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot){∏  int rc = SQLITE_ERROR;µ  if( pPager->pWal ){Ÿ9    rc = sqlite3WalSnapshotGet(pPager->pWal, ppSnapshot);£  }¨  return rc;°}†¢/*ŸG** If this is a WAL database, store a pointer to pSnapshot. Next time aŸD** read transaction is opened, attempt to read from the snapshot it Ÿ>** identifies. If this is not a WAL database, return an error.¢*/ŸXSQLITE_PRIVATE int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot){µ  int rc = SQLITE_OK;µ  if( pPager->pWal ){Ÿ4    sqlite3WalSnapshotOpen(pPager->pWal, pSnapshot);®  }else{∂    rc = SQLITE_ERROR;£  }¨  return rc;°}†¢/*ŸH** If this is a WAL database, call sqlite3WalSnapshotRecover(). If this Ÿ*** is not a WAL database, return an error.¢*/Ÿ>SQLITE_PRIVATE int sqlite3PagerSnapshotRecover(Pager *pPager){©  int rc;µ  if( pPager->pWal ){Ÿ1    rc = sqlite3WalSnapshotRecover(pPager->pWal);®  }else{∂    rc = SQLITE_ERROR;£  }¨  return rc;°}Ÿ##endif /* SQLITE_ENABLE_SNAPSHOT */Ω#endif /* !SQLITE_OMIT_WAL */†ª#ifdef SQLITE_ENABLE_ZIPVFS¢/*ŸI** A read-lock must be held on the pager when this function is called. IfŸK** the pager is in WAL mode and the WAL file currently contains one or moreŸH** frames, return the size in bytes of the page images stored within theŸG** WAL frames. Otherwise, if this is not a WAL database or the WAL file∂** is empty, return 0.¢*/Ÿ;SQLITE_PRIVATE int sqlite3PagerWalFramesize(Pager *pPager){Ÿ)  assert( pPager->eState>=PAGER_READER );Ÿ+  return sqlite3WalFramesize(pPager->pWal);°}¶#endif†ø#endif /* SQLITE_OMIT_DISKIO */†ŸO/************** End of pager.c ***********************************************/ŸO/************** Begin file wal.c *********************************************/¢/*≤** 2010 February 1¢**ŸC** The author disclaims copyright to this source code.  In place ofŸ&** a legal notice, here is a blessing:¢**Ÿ#**    May you do good and not evil.Ÿ?**    May you find forgiveness for yourself and forgive others.Ÿ<**    May you share freely, never taking more than you give.¢**ŸI*************************************************************************¢**ŸL** This file contains the implementation of a write-ahead log (WAL) used in ª** "journal_mode=WAL" mode.¢**Ÿ$** WRITE-AHEAD LOG (WAL) FILE FORMAT¢**ŸE** A WAL file consists of a header followed by zero or more "frames".ŸC** Each frame records the revised content of a single page from theŸF** database file.  All changes to the database are recorded by writingŸI** frames into the WAL.  Transactions commit when a frame is written thatŸG** contains a commit marker.  A single WAL can and usually does record ŸB** multiple transactions.  Periodically, the content of the WAL isŸC** transferred back into the database file in an operation called a∞** "checkpoint".¢**ŸE** A single WAL file can be used multiple times.  In other words, theŸD** WAL can fill up with frames and then be checkpointed and then newŸH** frames can overwrite the old ones.  A WAL always grows from beginningŸE** toward the end.  Checksums and counters attached to each frame areŸD** used to determine which frames within the WAL are valid and whichŸ(** are leftovers from prior checkpoints.¢**ŸI** The WAL header is 32 bytes in size and consists of the following eightŸ-** big-endian 32-bit unsigned integer values:¢**Ÿ1**     0: Magic number.  0x377f0682 or 0x377f0683Ÿ1**     4: File format version.  Currently 3007000Ÿ,**     8: Database page size.  Example: 1024Ÿ$**    12: Checkpoint sequence numberŸA**    16: Salt-1, random integer incremented with each checkpointŸD**    20: Salt-2, a different random integer changing with each ckptŸK**    24: Checksum-1 (first part of checksum for first 24 bytes of header).ŸL**    28: Checksum-2 (second part of checksum for first 24 bytes of header).¢**ŸE** Immediately following the wal-header are zero or more frames. EachŸK** frame consists of a 24-byte frame-header followed by a <page-size> bytesŸD** of page data. The frame-header is six big-endian 32-bit unsigned æ** integer values, as follows:¢**∂**     0: Page number.ŸF**     4: For commit records, the size of the database image in pages Ÿ8**        after the commit. For all other records, zero.Ÿ)**     8: Salt-1 (copied from the header)Ÿ)**    12: Salt-2 (copied from the header)µ**    16: Checksum-1.µ**    20: Checksum-2.¢**ŸJ** A frame is considered valid if and only if the following conditions are®** true:¢**Ÿ@**    (1) The salt-1 and salt-2 values in the frame-header matchŸ'**        salt values in the wal-header¢**ŸF**    (2) The checksum values in the final 8 bytes of the frame-headerŸB**        exactly match the checksum computed consecutively on theŸH**        WAL header and the first 8 bytes and the content of all framesŸ0**        up to and including the current frame.¢**ŸC** The checksum is computed using 32-bit big-endian integers if theŸD** magic number in the first 4 bytes of the WAL is 0x377f0683 and itŸE** is computed using little-endian if the magic number is 0x377f0682.ŸA** The checksum values are always stored in the frame header in aŸF** big-endian format regardless of which byte order is used to computeŸG** the checksum.  The checksum is computed by interpreting the input asŸF** an even number of unsigned 32-bit integers: x[0] through x[N].  TheŸ1** algorithm used for the checksum is as follows:£** Ÿ **   for i from 0 to n-1 step 2:∑**     s0 += x[i] + s1;π**     s1 += x[i+1] + s0;´**   endfor¢**ŸJ** Note that s0 and s1 are both weighted checksums using fibonacci weightsŸM** in reverse order (the largest fibonacci weight occurs on the first elementŸA** of the sequence being summed.)  The s1 value spans all 32-bit Ÿ9** terms of the sequence whereas s0 omits the final term.¢**ŸL** On a checkpoint, the WAL is first VFS.xSync-ed, then valid content of theŸK** WAL is transferred into the database, then the database is VFS.xSync-ed.ŸI** The VFS.xSync operations serve as write barriers - all writes launchedŸJ** before the xSync must complete before any write that launches after the∞** xSync begins.¢**ŸH** After each checkpoint, the salt-1 value is incremented and the salt-2ŸI** value is randomized.  This prevents old and new frames in the WAL fromŸK** being considered valid at the same time and being checkpointing togetherµ** following a crash.¢**≥** READER ALGORITHM¢**ŸE** To read a page from the database (call it page number P), a readerŸF** first checks the WAL to see if it contains page P.  If so, then theŸE** last valid instance of page P that is a followed by a commit frameŸB** or is a commit frame itself becomes the value read.  If the WALŸE** contains no copies of page P that are valid and which are a commitŸD** frame or are followed by a commit frame, then page P is read fromµ** the database file.¢**ŸH** To start a read transaction, the reader records the index of the lastŸI** valid frame in the WAL.  The reader uses this recorded "mxFrame" valueŸH** for all subsequent read operations.  New transactions can be appendedŸH** to the WAL, but as long as the reader uses its original mxFrame valueŸL** and ignores the newly appended content, it will see a consistent snapshotŸF** of the database from a single point in time.  This technique allowsŸI** multiple concurrent readers to view different versions of the database∫** content simultaneously.¢**ŸH** The reader algorithm in the previous paragraphs works correctly, but ŸD** because frames for page P can appear anywhere within the WAL, theŸG** reader has to scan the entire WAL looking for page P frames.  If theŸF** WAL is large (multiple megabytes is typical) that scan can be slow,ŸF** and read performance suffers.  To overcome this problem, a separateŸD** data structure called the wal-index is maintained to expedite theŸ*** search for frames of a particular page.£** ≥** WAL-INDEX FORMAT¢**ŸK** Conceptually, the wal-index is shared memory, though VFS implementationsŸI** might choose to implement the wal-index using a mmapped file.  BecauseŸL** the wal-index is shared memory, SQLite does not support journal_mode=WAL ŸF** on a network filesystem.  All users of the database must be able to∞** share memory.¢**ŸM** In the default unix and windows implementation, the wal-index is a mmappedŸM** file whose name is the database name with a "-shm" suffix added.  For thatŸ<** reason, the wal-index is sometimes called the "shm" file.¢**ŸL** The wal-index is transient.  After a crash, the wal-index can (and shouldŸN** be) reconstructed from the original WAL file.  In fact, the VFS is requiredŸG** to either truncate or zero the header of the wal-index when the lastŸG** connection to it closes.  Because the wal-index is transient, it canŸN** use an architecture-specific format; it does not have to be cross-platform.ŸI** Hence, unlike the database and WAL file formats which store all valuesŸI** as big endian, the wal-index can store multi-byte values in the nativeŸ#** byte order of the host computer.¢**ŸJ** The purpose of the wal-index is to answer this question quickly:  GivenŸH** a page number P and a maximum frame index M, return the index of the ŸH** last frame in the wal before frame M for page P in the WAL, or returnŸ@** NULL if there are no frames for page P in the WAL prior to M.¢**ŸC** The wal-index consists of a header region, followed by an one or∑** more index blocks.  ¢**ŸJ** The wal-index header contains the total number of frames within the WAL∏** in the mxFrame field.¢**ŸA** Each index block except for the first contains information on ŸH** HASHTABLE_NPAGE frames. The first index block contains information onŸE** HASHTABLE_NPAGE_ONE frames. The values of HASHTABLE_NPAGE_ONE and ŸI** HASHTABLE_NPAGE are selected so that together the wal-index header andŸG** first index block are the same size as all other index blocks in the≠** wal-index.¢**ŸK** Each index block contains two sections, a page-mapping that contains theŸI** database page number associated with each wal frame, and a hash-table ŸJ** that allows readers to query an index block for a specific page number.ŸJ** The page-mapping is an array of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONEŸJ** for the first index block) 32-bit page numbers. The first entry in the ŸK** first index-block contains the database page number corresponding to theŸI** first frame in the WAL file. The first entry in the second index blockŸH** in the WAL file corresponds to the (HASHTABLE_NPAGE_ONE+1)th frame in∂** the log, and so on.¢**ŸJ** The last index block in a wal-index usually contains less than the fullŸG** complement of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE) page-numbers,ŸF** depending on the contents of the WAL file. This does not change theŸK** allocated size of the page-mapping array - the page-mapping array merelyª** contains unused entries.¢**Ÿ?** Even without using the hash table, the last frame for page PŸI** can be found by scanning the page-mapping sections of each index blockŸF** starting with the last index block and moving toward the first, andŸE** within each index block, starting at the end and moving toward theŸE** beginning.  The first entry that equals P corresponds to the frameŸ%** holding the content for that page.¢**ŸG** The hash table consists of HASHTABLE_NSLOT 16-bit unsigned integers.ŸE** HASHTABLE_NSLOT = 2*HASHTABLE_NPAGE, and there is one entry in theŸG** hash table for each page number in the mapping section, so the hash ŸJ** table is never more than half full.  The expected number of collisions ŸE** prior to finding a match is 1.  Each entry of the hash table is anŸ?** 1-based index of an entry in the mapping section of the sameŸD** index block.   Let K be the 1-based index of the largest entry inŸF** the mapping section.  (For index blocks other than the last, K willŸH** always be exactly HASHTABLE_NPAGE (4096) and for the last index blockŸH** K will be (mxFrame%HASHTABLE_NPAGE).)  Unused slots of the hash table∏** contain a value of 0.¢**ŸE** To look for page P in the hash table, first compute a hash iKey on∞** P as follows:¢**Ÿ***      iKey = (P * 383) % HASHTABLE_NSLOT¢**ŸD** Then start scanning entries of the hash table, starting with iKeyŸF** (wrapping around to the beginning when the end of the hash table isŸI** reached) until an unused hash slot is found. Let the first unused slotŸF** be at index iUnused.  (iUnused might be less than iKey if there wasŸE** wrap-around.) Because the hash table is never more than half full,ŸD** the search is guaranteed to eventually hit an unused entry.  Let ŸB** iMax be the value between iKey and iUnused, closest to iUnused,ŸD** where aHash[iMax]==P.  If there is no iMax entry (if there existsŸ@** no hash slot such that aHash[i]==p) then page P is not in theŸC** current index block.  Otherwise the iMax-th mapping entry of theŸE** current index block corresponds to the last entry that references ™** page P.¢**ŸF** A hash search begins with the last index block and moves toward theŸF** first index block, looking for entries corresponding to page P.  OnŸB** average, only two or three slots in each index block need to beŸD** examined in order to either find the last entry for page P, or toŸF** establish that no such entry exists in the block.  Each index blockŸH** holds over 4000 entries.  So two or three index blocks are sufficientŸG** to cover a typical 10 megabyte WAL file, assuming 1K pages.  8 or 10ŸC** comparisons (on average) suffice to either locate a frame in theŸF** WAL or to establish that the frame does not exist in the WAL.  ThisŸ4** is much faster than scanning the entire 10MB WAL.¢**ŸD** Note that entries are added in order of increasing K.  Hence, oneŸG** reader might be using some value K0 and a second reader that startedŸG** at a later time (after additional transactions were added to the WALŸJ** and to the wal-index) might be using a different value K1, where K1>K0.ŸF** Both readers can use the same hash table and mapping section to getŸC** the correct result.  There may be entries in the hash table withŸG** K>K0 but to the first reader, those entries will appear to be unusedŸH** slots in the hash table and so the first reader will get an answer asŸJ** if no values greater than K0 had ever been inserted into the hash tableŸG** in the first place - which is what reader one wants.  Meanwhile, theŸG** second reader using K1 will see additional values that were insertedŸ3** later, which is exactly what reader two wants.  ¢**ŸJ** When a rollback occurs, the value of K is decreased. Hash table entriesŸE** that correspond to frames greater than the new K value are removedŸ%** from the hash table at this point.¢*/∑#ifndef SQLITE_OMIT_WAL†∂/* #include "wal.h" */†¢/*∂** Trace output macros¢*/Ÿ1#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)Ÿ'SQLITE_PRIVATE int sqlite3WalTrace = 0;Ÿ># define WALTRACE(X)  if(sqlite3WalTrace) sqlite3DebugPrintf X•#else¥# define WALTRACE(X)¶#endif†¢/*ŸC** The maximum (and only) versions of the wal and wal-index formatsŸ5** that may be interpreted by this version of SQLite.¢**ŸK** If a client begins recovering a WAL file and finds that (a) the checksumŸH** values in the wal-header are correct and (b) the version field is notŸF** WAL_MAX_VERSION, recovery fails and SQLite returns SQLITE_CANTOPEN.¢**ŸJ** Similarly, if a client successfully reads a wal-index header (i.e. the ŸG** checksum test is successful) and finds that the version field is notŸF** WALINDEX_MAX_VERSION, then no read-transaction is opened and SQLiteª** returns SQLITE_CANTOPEN.¢*/Ÿ$#define WAL_MAX_VERSION      3007000Ÿ$#define WALINDEX_MAX_VERSION 3007000†¢/*ŸG** Index numbers for various locking bytes.   WAL_NREADER is the numberŸC** of available reader locks and should be at least 3.  The defaultŸ.** is SQLITE_SHM_NLOCK==8 and  WAL_NREADER==5.¢**ŸK** Technically, the various VFSes are free to implement these locks howeverŸH** they see fit.  However, compatibility is encouraged so that VFSes canŸI** interoperate.  The standard implemention used on both unix and windowsŸ=** is for the index number to indicate a byte offset into theŸJ** WalCkptInfo.aLock[] array in the wal-index header.  In other words, allŸG** locks are on the shm file.  The WALINDEX_LOCK_OFFSET constant (whichŸG** should be 120) is the location in the shm file for the first locking®** byte.¢*/Ÿ #define WAL_WRITE_LOCK         0Ÿ #define WAL_ALL_BUT_WRITE      1Ÿ #define WAL_CKPT_LOCK          1Ÿ #define WAL_RECOVER_LOCK       2Ÿ&#define WAL_READ_LOCK(I)       (3+(I))Ÿ3#define WAL_NREADER            (SQLITE_SHM_NLOCK-3)††π/* Object declarations */Ÿ'typedef struct WalIndexHdr WalIndexHdr;Ÿ'typedef struct WalIterator WalIterator;Ÿ'typedef struct WalCkptInfo WalCkptInfo;††¢/*ŸE** The following object holds a copy of the wal-index header content.¢**ŸD** The actual header in the wal-index consists of two copies of thisŸ=** object followed by one instance of the WalCkptInfo object.ŸA** For all versions of SQLite through 3.10.0 and probably beyond,Ÿ@** the locking bytes (WalCkptInfo.aLock) start at offset 120 andŸ&** the total header size is 136 bytes.¢**ŸK** The szPage value can be any power of 2 between 512 and 32768, inclusive.ŸF** Or it can be 1 to represent a 65536-byte page.  The latter case wasŸ9** added in 3.7.1 when support for 64K pages was added.  ¢*/¥struct WalIndexHdr {Ÿ9  u32 iVersion;                   /* Wal-index version */Ÿ>  u32 unused;                     /* Unused (padding) field */ŸL  u32 iChange;                    /* Counter incremented each transaction */Ÿ:  u8 isInit;                      /* 1 when initialized */ŸO  u8 bigEndCksum;                 /* True if checksums in WAL are big-endian */ŸK  u16 szPage;                     /* Database page size in bytes. 1==64K */ŸL  u32 mxFrame;                    /* Index of last valid frame in the WAL */ŸA  u32 nPage;                      /* Size of database in pages */ŸE  u32 aFrameCksum[2];             /* Checksum of last frame in log */ŸN  u32 aSalt[2];                   /* Two salt values copied from WAL header */ŸF  u32 aCksum[2];                  /* Checksum over all prior fields */¢};†¢/*ŸE** A copy of the following object occurs in the wal-index immediatelyŸD** following the second copy of the WalIndexHdr.  This object storesŸ"** information used by checkpoint.¢**ŸF** nBackfill is the number of frames in the WAL that have been writtenŸI** back into the database. (We call the act of moving content from WAL toŸG** database "backfilling".)  The nBackfill number is never greater thanŸC** WalIndexHdr.mxFrame.  nBackfill can only be increased by threadsŸE** holding the WAL_CKPT_LOCK lock (which includes a recovery thread).ŸH** However, a WAL_WRITE_LOCK thread can move the value of nBackfill fromŸ.** mxFrame back to zero when the WAL is reset.¢**ŸI** nBackfillAttempted is the largest value of nBackfill that a checkpointŸL** has attempted to achieve.  Normally nBackfill==nBackfillAtempted, howeverŸG** the nBackfillAttempted is set before any backfilling is done and theŸM** nBackfill is only set after all backfilling completes.  So if a checkpointŸC** crashes, nBackfillAttempted might be larger than nBackfill.  TheŸB** WalIndexHdr.mxFrame must never be less than nBackfillAttempted.¢**ŸL** The aLock[] field is a set of bytes used for locking.  These bytes shouldº** never be read or written.¢**ŸG** There is one entry in aReadMark[] for each reader lock.  If a readerŸG** holds read-lock K, then the value in aReadMark[K] is no greater thanŸI** the mxFrame for that reader.  The value READMARK_NOT_USED (0xffffffff)ŸD** for any aReadMark[] means that entry is unused.  aReadMark[0] is ŸJ** a special case; its value is never used and it exists as a place-holderŸH** to avoid having to offset aReadMark[] indexs by one.  Readers holdingŸE** WAL_READ_LOCK(0) always ignore the entire WAL and read all contentæ** directly from the database.¢**ŸA** The value of aReadMark[K] may only be changed by a thread thatŸH** is holding an exclusive lock on WAL_READ_LOCK(K).  Thus, the value ofŸI** aReadMark[K] cannot changed while there is a reader is using that markŸF** since the reader will be holding a shared lock on WAL_READ_LOCK(K).¢**ŸG** The checkpointer may only transfer frames from WAL to database whereŸH** the frame numbers are less than or equal to every aReadMark[] that isŸI** in use (that is, every aReadMark[j] for which there is a correspondingŸJ** WAL_READ_LOCK(j)).  New readers (usually) pick the aReadMark[] with theŸL** largest value and will increase an unused aReadMark[] to mxFrame if thereŸH** is not already an aReadMark[] equal to mxFrame.  The exception to theŸN** previous sentence is when nBackfill equals mxFrame (meaning that everythingŸE** in the WAL has been backfilled into the database) then new readersŸH** will choose aReadMark[0] which has value 0 and hence such reader willŸH** get all their all content directly from the database file and ignore ´** the WAL.¢**ŸF** Writers normally append new frames to the end of the WAL.  However,ŸE** if nBackfill equals mxFrame (meaning that all WAL content has beenŸF** written back into the database) and if no readers are using the WALŸD** (in other words, if there are no WAL_READ_LOCK(i) where i>0) thenŸH** the writer will first "reset" the WAL back to the beginning and startŸ,** writing new content beginning at frame 1.¢**ŸG** We assume that 32-bit loads are atomic and so no locks are needed inŸ.** order to read from any aReadMark[] entries.¢*/¥struct WalCkptInfo {ŸO  u32 nBackfill;                  /* Number of WAL frames backfilled into DB */Ÿ4  u32 aReadMark[WAL_NREADER];     /* Reader marks */Ÿ@  u8 aLock[SQLITE_SHM_NLOCK];     /* Reserved space for locks */ŸP  u32 nBackfillAttempted;         /* WAL frames perhaps written, or maybe not */ŸI  u32 notUsed0;                   /* Available for future enhancements */¢};Ÿ%#define READMARK_NOT_USED  0xffffffff††Ÿ7/* A block of WALINDEX_LOCK_RESERVED bytes beginning atŸA** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systemsŸB** only support mandatory file-locks, we do not read or write dataŸ:** from the region of the file on which locks are applied.¢*/ŸP#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))ŸH#define WALINDEX_HDR_SIZE    (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))†Ÿ-/* Size of header before each frame in wal */º#define WAL_FRAME_HDRSIZE 24†Ÿ9/* Size of write ahead log header, including checksum. */∂#define WAL_HDRSIZE 32†ŸG/* WAL magic value. Either this value, or the same value with the leastŸH** significant bit also set (WAL_MAGIC | 0x00000001) is stored in 32-bitŸ8** big-endian format in the first 4 bytes of a WAL file.¢**ŸF** If the LSB is set, then the checksums for each frame within the WALŸB** file are calculated by treating all data as an array of 32-bit ŸD** big-endian words. Otherwise, they are calculated by interpreting Ÿ*** all data as 32-bit little-endian words.¢*/º#define WAL_MAGIC 0x377f0682†¢/*ŸB** Return the offset of frame iFrame in the write-ahead log file, ŸE** assuming a database page size of szPage bytes. The offset returnedŸ7** is to the start of the write-ahead log frame-header.¢*/ŸH#define walFrameOffset(iFrame, szPage) (                               \ŸH  WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)         \°)†¢/*ŸD** An open write-ahead log file is represented by an instance of the¥** following object.¢*/¨struct Wal {Ÿ?  sqlite3_vfs *pVfs;         /* The VFS used to create pDbFd */ŸD  sqlite3_file *pDbFd;       /* File handle for the database file */Ÿ;  sqlite3_file *pWalFd;      /* File handle for WAL file */ŸG  u32 iCallback;             /* Value to pass to log callback (or 0) */ŸG  i64 mxWalSize;             /* Truncate WAL to this size upon reset */Ÿ9  int nWiData;               /* Size of array apWiData */ŸJ  int szFirstBlock;          /* Size of first block written to WAL file */ŸI  volatile u32 **apWiData;   /* Pointer to wal-index content in memory */Ÿ5  u32 szPage;                /* Database page size */ŸN  i16 readLock;              /* Which read lock is being held.  -1 for none */ŸE  u8 syncFlags;              /* Flags to use to sync header writes */ŸN  u8 exclusiveMode;          /* Non-zero if connection is in exclusive mode */ŸA  u8 writeLock;              /* True if in a write transaction */ŸD  u8 ckptLock;               /* True if holding a checkpoint lock */ŸJ  u8 readOnly;               /* WAL_RDWR, WAL_RDONLY, or WAL_SHM_RDONLY */ŸF  u8 truncateOnCommit;       /* True to truncate WAL file on commit */Ÿ?  u8 syncHeader;             /* Fsync the WAL header if true */ŸJ  u8 padToSectorBoundary;    /* Pad transactions out to the next sector */ŸJ  u8 bShmUnreliable;         /* SHM content is read-only and unreliable */ŸK  WalIndexHdr hdr;           /* Wal-index header for current transaction */ŸD  u32 minFrame;              /* Ignore wal frames before this one */ŸM  u32 iReCksum;              /* On commit, recalculate checksums from here */Ÿ3  const char *zWalName;      /* Name of WAL file */ŸP  u32 nCkpt;                 /* Checkpoint sequence counter in the wal-header */≥#ifdef SQLITE_DEBUGŸG  u8 lockError;              /* True if a locking error has occurred */¶#endifΩ#ifdef SQLITE_ENABLE_SNAPSHOTŸE  WalIndexHdr *pSnapshot;    /* Start transaction here if not NULL */¶#endif¢};†¢/*Ÿ*** Candidate values for Wal.exclusiveMode.¢*/Ω#define WAL_NORMAL_MODE     0Ÿ"#define WAL_EXCLUSIVE_MODE  1     Ω#define WAL_HEAPMEMORY_MODE 2†¢/*Ÿ#** Possible values for WAL.readOnly¢*/Ÿ?#define WAL_RDWR        0    /* Normal read/write connection */Ÿ;#define WAL_RDONLY      1    /* The WAL file is readonly */Ÿ;#define WAL_SHM_RDONLY  2    /* The SHM file is readonly */†¢/*ŸF** Each page of the wal-index mapping contains a hash-table made up ofŸ>** an array of HASHTABLE_NSLOT elements of the following type.¢*/¥typedef u16 ht_slot;†¢/*ŸE** This structure is used to implement an iterator that loops throughŸI** all frames in the WAL in database page order. Where two or more framesŸF** correspond to the same database page, the iterator visits only the ŸI** frame most recently written to the WAL (in other words, the frame with∂** the largest index).¢**Ÿ8** The internals of this structure are only accessed by:¢**Ÿ/**   walIteratorInit() - Create a new iterator,Ÿ***   walIteratorNext() - Step an iterator,Ÿ***   walIteratorFree() - Free an iterator.¢**ŸK** This functionality is used by the checkpoint code (see walCheckpoint()).¢*/¥struct WalIterator {ŸN  int iPrior;                     /* Last result returned from the iterator */ŸG  int nSegment;                   /* Number of entries in aSegment[] */µ  struct WalSegment {ŸN    int iNext;                    /* Next slot in aIndex[] not yet returned */ŸP    ht_slot *aIndex;              /* i0, i1, i2... such that aPgno[iN] ascend */Ÿ>    u32 *aPgno;                   /* Array of page numbers. */ŸN    int nEntry;                   /* Nr. of entries in aPgno[] and aIndex[] */ŸM    int iZero;                    /* Frame number associated with aPgno[0] */ŸP  } aSegment[1];                  /* One for every 32KB page in the wal-index */¢};†¢/*ŸH** Define the parameters of the hash tables in the wal-index file. ThereŸF** is a hash-table following every HASHTABLE_NPAGE page numbers in the≠** wal-index.¢**ŸF** Changing any of these constants will alter the wal-index format andº** create incompatibilities.¢*/ŸJ#define HASHTABLE_NPAGE      4096                 /* Must be power of 2 */ŸG#define HASHTABLE_HASH_1     383                  /* Should be prime */ŸL#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  /* Must be a power of 2 */†£/* ŸF** The block of page numbers associated with the first hash-table in aŸG** wal-index is smaller than usual. This is so that there is a completeŸ9** hash-table on each aligned 32KB page of the wal-index.¢*/ŸP#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))†ŸF/* The wal-index is divided into pages of WALINDEX_PGSZ bytes each. */ŸC#define WALINDEX_PGSZ   (                                         \ŸC    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \°)†¢/*ŸH** Obtain a pointer to the iPage'th page of the wal-index. The wal-indexŸC** is broken into pages of WALINDEX_PGSZ bytes. Wal-index pages are∂** numbered from zero.¢**ŸF** If the wal-index is currently smaller the iPage pages then the sizeŸD** of the wal-index might be increased, but only if it is safe to doŸF** so.  It is safe to enlarge the wal-index if pWal->writeLock is trueŸ/** or pWal->exclusiveMode==WAL_HEAPMEMORY_MODE.¢**ŸG** If this call is successful, *ppPage is set to point to the wal-indexŸL** page and SQLITE_OK is returned. If an error (an OOM or VFS error) occurs,ŸA** then an SQLite error code is returned and *ppPage is set to 0.¢*/Ÿ/static SQLITE_NOINLINE int walIndexPageRealloc(Ÿ0  Wal *pWal,               /* The WAL context */Ÿ1  int iPage,               /* The page we seek */Ÿ<  volatile u32 **ppPage    /* Write the page pointer here */¢){µ  int rc = SQLITE_OK;†Ÿ6  /* Enlarge the pWal->apWiData[] array if required */Ω  if( pWal->nWiData<=iPage ){Ÿ'    int nByte = sizeof(u32*)*(iPage+1);π    volatile u32 **apNew;ŸN    apNew = (volatile u32 **)sqlite3_realloc64((void *)pWal->apWiData, nByte);±    if( !apNew ){≤      *ppPage = 0;ø      return SQLITE_NOMEM_BKPT;•    }Ÿ+    memset((void*)&apNew[pWal->nWiData], 0,Ÿ1           sizeof(u32*)*(iPage+1-pWal->nWiData));ª    pWal->apWiData = apNew;º    pWal->nWiData = iPage+1;£  }†Ÿ;  /* Request a pointer to the required page from the VFS */Ÿ%  assert( pWal->apWiData[iPage]==0 );Ÿ1  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){ŸM    pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);Ÿ8    if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;®  }else{Ÿ<    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ, ŸA        pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]¶    );ŸN    assert( pWal->apWiData[iPage]!=0 || rc!=SQLITE_OK || pWal->writeLock==0 );Ÿ:    testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );Ÿ%    if( (rc&0xff)==SQLITE_READONLY ){Ÿ'      pWal->readOnly |= WAL_SHM_RDONLY;Ÿ       if( rc==SQLITE_READONLY ){∑        rc = SQLITE_OK;ß      }•    }£  }†Ÿ"  *ppPage = pWal->apWiData[iPage];Ÿ1  assert( iPage==0 || *ppPage || rc!=SQLITE_OK );¨  return rc;°}∏static int walIndexPage(Ÿ0  Wal *pWal,               /* The WAL context */Ÿ1  int iPage,               /* The page we seek */Ÿ<  volatile u32 **ppPage    /* Write the page pointer here */¢){ŸE  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){Ÿ4    return walIndexPageRealloc(pWal, iPage, ppPage);£  }≥  return SQLITE_OK;°}†¢/*ŸB** Return a pointer to the WalCkptInfo structure in the wal-index.¢*/Ÿ4static volatile WalCkptInfo *walCkptInfo(Wal *pWal){Ÿ1  assert( pWal->nWiData>0 && pWal->apWiData[0] );ŸL  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);°}†¢/*ŸB** Return a pointer to the WalIndexHdr structure in the wal-index.¢*/Ÿ4static volatile WalIndexHdr *walIndexHdr(Wal *pWal){Ÿ1  assert( pWal->nWiData>0 && pWal->apWiData[0] );Ÿ2  return (volatile WalIndexHdr*)pWal->apWiData[0];°}†¢/*ŸE** The argument to this macro must be of type u32. On a little-endianŸH** architecture, it returns the u32 value that results from interpretingŸF** the 4 bytes as a big-endian value. On a big-endian architecture, itŸG** returns the value that would be produced by interpreting the 4 bytesŸ1** of the input value as a little-endian integer.¢*/π#define BYTESWAP32(x) ( \Ÿ5    (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8)  \Ÿ5  + (((x)&0x00FF0000)>>8)  + (((x)&0xFF000000)>>24) \°)†¢/*Ÿ>** Generate or extend an 8 byte checksum based on the data in Ÿ@** array aByte[] and the initial values of aIn[0] and aIn[1] (orŸ+** initial values of 0 and 0 if aIn==NULL).¢**Ÿ=** The checksum is written back into aOut[] before returning.¢**Ÿ*** nByte must be a positive multiple of 8.¢*/Ωstatic void walChecksumBytes(ŸI  int nativeCksum, /* True for native byte-order, false for non-native */Ÿ2  u8 *a,           /* Content to be checksummed */ŸK  int nByte,       /* Bytes of content in a[].  Must be a multiple of 8. */Ÿ5  const u32 *aIn,  /* Initial checksum value input */Ÿ9  u32 *aOut        /* OUT: Final checksum value output */¢){≠  u32 s1, s2;∏  u32 *aData = (u32 *)a;ø  u32 *aEnd = (u32 *)&a[nByte];†¨  if( aIn ){∞    s1 = aIn[0];∞    s2 = aIn[1];®  }else{∞    s1 = s2 = 0;£  }†µ  assert( nByte>=8 );Ÿ"  assert( (nByte&0x00000007)==0 );†¥  if( nativeCksum ){®    do {∫      s1 += *aData++ + s2;∫      s2 += *aData++ + s1;π    }while( aData<aEnd );®  }else{®    do {Ÿ&      s1 += BYTESWAP32(aData[0]) + s2;Ÿ&      s2 += BYTESWAP32(aData[1]) + s1;±      aData += 2;π    }while( aData<aEnd );£  }†Ø  aOut[0] = s1;Ø  aOut[1] = s2;°}†Ÿ%static void walShmBarrier(Wal *pWal){Ÿ1  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){Ÿ%    sqlite3OsShmBarrier(pWal->pDbFd);£  }°}†¢/*Ÿ@** Write the header information in pWal->hdr into the wal-index.¢**Ÿ=** The checksum on pWal->hdr is updated before it is written.¢*/Ÿ(static void walIndexWriteHdr(Wal *pWal){Ÿ1  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);Ÿ3  const int nCksum = offsetof(WalIndexHdr, aCksum);†º  assert( pWal->writeLock );∑  pWal->hdr.isInit = 1;Ÿ,  pWal->hdr.iVersion = WALINDEX_MAX_VERSION;ŸD  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);ŸH  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));∂  walShmBarrier(pWal);ŸH  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));°}†¢/*ŸH** This function encodes a single frame header and writes it to a bufferŸD** supplied by the caller. A frame-header is made up of a series of Ÿ*** 4-byte big-endian integers, as follows:¢**∂**     0: Page number.ŸF**     4: For commit records, the size of the database image in pages Ÿ8**        after the commit. For all other records, zero.Ÿ-**     8: Salt-1 (copied from the wal-header)Ÿ-**    12: Salt-2 (copied from the wal-header)µ**    16: Checksum-1.µ**    20: Checksum-2.¢*/ªstatic void walEncodeFrame(Ÿ;  Wal *pWal,                      /* The write-ahead log */ŸF  u32 iPage,                      /* Database page number for frame */ŸP  u32 nTruncate,                  /* New db size (or 0 for non-commit frames) */Ÿ<  u8 *aData,                      /* Pointer to page data */ŸE  u8 *aFrame                      /* OUT: Write encoded frame here */¢){ŸL  int nativeCksum;                /* True for native byte-order checksums */Ÿ&  u32 *aCksum = pWal->hdr.aFrameCksum;Ÿ"  assert( WAL_FRAME_HDRSIZE==24 );Ÿ%  sqlite3Put4byte(&aFrame[0], iPage);Ÿ)  sqlite3Put4byte(&aFrame[4], nTruncate);∫  if( pWal->iReCksum==0 ){Ÿ+    memcpy(&aFrame[8], pWal->hdr.aSalt, 8);†Ÿ<    nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);Ÿ=    walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);ŸG    walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);†Ÿ,    sqlite3Put4byte(&aFrame[16], aCksum[0]);Ÿ,    sqlite3Put4byte(&aFrame[20], aCksum[1]);®  }else{æ    memset(&aFrame[8], 0, 16);£  }°}†¢/*Ÿ@** Check to see if the frame with header in aFrame[] and contentŸA** in aData[] is valid.  If it is a valid frame, fill *piPage andŸB** *pnTruncate and return true.  Return if the frame is not valid.¢*/∫static int walDecodeFrame(Ÿ;  Wal *pWal,                      /* The write-ahead log */ŸK  u32 *piPage,                    /* OUT: Database page number for frame */ŸM  u32 *pnTruncate,                /* OUT: New db size (or 0 if not commit) */ŸK  u8 *aData,                      /* Pointer to page data (for checksum) */Ÿ2  u8 *aFrame                      /* Frame data */¢){ŸL  int nativeCksum;                /* True for native byte-order checksums */Ÿ&  u32 *aCksum = pWal->hdr.aFrameCksum;Ÿ@  u32 pgno;                       /* Page number of the frame */Ÿ"  assert( WAL_FRAME_HDRSIZE==24 );†ŸA  /* A frame is only valid if the salt values in the frame-headerŸ.  ** match the salt values in the wal-header. §  */Ÿ3  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){≠    return 0;£  }†ŸC  /* A frame is only valid if the page number is creater than zero.§  */Ÿ%  pgno = sqlite3Get4byte(&aFrame[0]);∞  if( pgno==0 ){≠    return 0;£  }†Ÿ;  /* A frame is only valid if a checksum of the WAL header,Ÿ?  ** all prior frams, the first 16 bytes of this frame-header, Ÿ;  ** and the frame-data matches the checksum in the last 8 Ÿ   ** bytes of this frame-header.§  */Ÿ:  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);Ÿ;  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);ŸE  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);Ÿ.  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16]) Ÿ.   || aCksum[1]!=sqlite3Get4byte(&aFrame[20]) §  ){∫    /* Checksum failed. */≠    return 0;£  }†ŸH  /* If we reach this point, the frame is valid.  Return the page numberø  ** and the new database size.§  */±  *piPage = pgno;Ÿ,  *pnTruncate = sqlite3Get4byte(&aFrame[4]);´  return 1;°}††Ÿ1#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)¢/*ŸO** Names of locks.  This routine is used to provide debugging output and is notø** a part of an ordinary build.¢*/Ÿ,static const char *walLockName(int lockIdx){Ÿ   if( lockIdx==WAL_WRITE_LOCK ){∏    return "WRITE-LOCK";Ÿ%  }else if( lockIdx==WAL_CKPT_LOCK ){∑    return "CKPT-LOCK";Ÿ(  }else if( lockIdx==WAL_RECOVER_LOCK ){∫    return "RECOVER-LOCK";®  }else{∫    static char zName[15];Ÿ;    sqlite3_snprintf(sizeof(zName), zName, "READ-LOCK[%d]",Ÿ/                     lockIdx-WAL_READ_LOCK(0));±    return zName;£  }°}Ÿ9#endif /*defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */§    †¢/*ŸJ** Set or release locks on the WAL.  Locks are either shared or exclusive.ŸL** A lock cannot be moved directly between shared and exclusive - it must goŸ$** through the unlocked state first.¢**ŸB** In locking_mode=EXCLUSIVE, all of these routines become no-ops.¢*/Ÿ1static int walLockShared(Wal *pWal, int lockIdx){©  int rc;Ÿ-  if( pWal->exclusiveMode ) return SQLITE_OK;Ÿ0  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,Ÿ=                        SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);Ÿ2  WALTRACE(("WAL%p: acquire SHARED-%s %s\n", pWal,Ÿ9            walLockName(lockIdx), rc ? "failed" : "ok"));ŸG  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && rc!=SQLITE_BUSY); )¨  return rc;°}Ÿ4static void walUnlockShared(Wal *pWal, int lockIdx){Ÿ#  if( pWal->exclusiveMode ) return;Ÿ1  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,Ÿ@                         SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);ŸG  WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx)));°}Ÿ;static int walLockExclusive(Wal *pWal, int lockIdx, int n){©  int rc;Ÿ-  if( pWal->exclusiveMode ) return SQLITE_OK;Ÿ0  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,Ÿ@                        SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);Ÿ<  WALTRACE(("WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n", pWal,Ÿ<            walLockName(lockIdx), n, rc ? "failed" : "ok"));ŸG  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && rc!=SQLITE_BUSY); )¨  return rc;°}Ÿ>static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){Ÿ#  if( pWal->exclusiveMode ) return;Ÿ1  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,ŸC                         SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);Ÿ9  WALTRACE(("WAL%p: release EXCLUSIVE-%s cnt=%d\n", pWal,Ÿ'             walLockName(lockIdx), n));°}†¢/*ŸG** Compute a hash on a page number.  The resulting hash value must landŸJ** between 0 and (HASHTABLE_NSLOT-1).  The walHashNext() function advancesŸ:** the hash to the next value in the event of a collision.¢*/æstatic int walHash(u32 iPage){¥  assert( iPage>0 );Ÿ7  assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );Ÿ8  return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT-1);°}Ÿ'static int walNextHash(int iPriorHash){Ÿ,  return (iPriorHash+1)&(HASHTABLE_NSLOT-1);°}†£/* ŸD** Return pointers to the hash table and page number array stored onŸG** page iHash of the wal-index. The wal-index is broken into 32KB pagesº** numbered starting from 0.¢**ŸF** Set output variable *paHash to point to the start of the hash tableŸA** in the wal-index file. Set *piZero to one less than the frame Ÿ=** number of the first frame indexed by this hash table. If aŸA** slot in the hash table is set to N, it refers to frame number ∫** (*piZero+N) in the log.¢**ŸD** Finally, set *paPgno so that *paPgno[1] is the page number of theŸ<** first frame indexed by the hash table, frame (*piZero+1).¢*/∂static int walHashGet(Ÿ2  Wal *pWal,                      /* WAL handle */Ÿ?  int iHash,                      /* Find the iHash'th table */ŸB  volatile ht_slot **paHash,      /* OUT: Pointer to hash index */ŸI  volatile u32 **paPgno,          /* OUT: Pointer to page number array */ŸM  u32 *piZero                     /* OUT: Frame associated with *paPgno[0] */¢){Ÿ3  int rc;                         /* Return code */∂  volatile u32 *aPgno;†Ÿ)  rc = walIndexPage(pWal, iHash, &aPgno);Ÿ%  assert( rc==SQLITE_OK || iHash>0 );†∂  if( rc==SQLITE_OK ){Æ    u32 iZero;º    volatile ht_slot *aHash;†Ÿ8    aHash = (volatile ht_slot *)&aPgno[HASHTABLE_NPAGE];≥    if( iHash==0 ){Ÿ4      aPgno = &aPgno[WALINDEX_HDR_SIZE/sizeof(u32)];∞      iZero = 0;™    }else{Ÿ>      iZero = HASHTABLE_NPAGE_ONE + (iHash-1)*HASHTABLE_NPAGE;•    }¢  π    *paPgno = &aPgno[-1];¥    *paHash = aHash;¥    *piZero = iZero;£  }¨  return rc;°}†¢/*ŸG** Return the number of the wal-index page that contains the hash-tableŸH** and page-number array that contain entries corresponding to WAL frameŸG** iFrame. The wal-index is broken up into 32KB pages. Wal-index pages Ÿ ** are numbered starting from 0.¢*/Ÿ$static int walFramePage(u32 iFrame){ŸO  int iHash = (iFrame+HASHTABLE_NPAGE-HASHTABLE_NPAGE_ONE-1) / HASHTABLE_NPAGE;Ÿ2  assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)Ÿ3       && (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE)ŸD       && (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE))ŸC       && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)ŸF       && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))§  );Ø  return iHash;°}†¢/*ŸC** Return the page number associated with frame iFrame in this WAL.¢*/Ÿ/static u32 walFramePgno(Wal *pWal, u32 iFrame){Ÿ#  int iHash = walFramePage(iFrame);±  if( iHash==0 ){ŸI    return pWal->apWiData[0][WALINDEX_HDR_SIZE/sizeof(u32) + iFrame - 1];£  }ŸO  return pWal->apWiData[iHash][(iFrame-1-HASHTABLE_NPAGE_ONE)%HASHTABLE_NPAGE];°}†¢/*ŸE** Remove entries from the hash table that point to WAL slots greater∫** than pWal->hdr.mxFrame.¢**ŸF** This function is called whenever pWal->hdr.mxFrame is decreased dueæ** to a rollback or savepoint.¢**ŸG** At most only the hash table containing pWal->hdr.mxFrame needs to beŸE** updated.  Any later hash tables will be automatically cleared whenŸF** pWal->hdr.mxFrame advances to the point where those hash tables are≥** actually needed.¢*/Ÿ&static void walCleanupHash(Wal *pWal){ŸF  volatile ht_slot *aHash = 0;    /* Pointer to hash table to clear */ŸH  volatile u32 *aPgno = 0;        /* Page number array for hash table */ŸA  u32 iZero = 0;                  /* frame == (aHash[x]+iZero) */ŸE  int iLimit = 0;                 /* Zero values greater than this */ŸJ  int nByte;                      /* Number of bytes to zero in aPgno[] */ŸG  int i;                          /* Used to iterate through aHash[] */†º  assert( pWal->writeLock );Ÿ7  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );Ÿ5  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE );Ÿ7  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE+1 );†Ÿ$  if( pWal->hdr.mxFrame==0 ) return;†ŸH  /* Obtain pointers to the hash-table and page-number array containing ŸL  ** the entry that corresponds to frame pWal->hdr.mxFrame. It is guaranteedŸI  ** that the page said hash-table and array reside on is already mapped.§  */Ÿ:  assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );Ÿ<  assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );ŸL  walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &aHash, &aPgno, &iZero);†ŸI  /* Zero all hash-table entries that correspond to frame numbers greaterº  ** than pWal->hdr.mxFrame.§  */Ÿ%  iLimit = pWal->hdr.mxFrame - iZero;µ  assert( iLimit>0 );Ÿ#  for(i=0; i<HASHTABLE_NSLOT; i++){∫    if( aHash[i]>iLimit ){≥      aHash[i] = 0;•    }£  }¢  ŸG  /* Zero the entries in the aPgno array that correspond to frames withŸ3  ** frame numbers greater than pWal->hdr.mxFrame. §  */Ÿ:  nByte = (int)((char *)aHash - (char *)&aPgno[iLimit+1]);Ÿ-  memset((void *)&aPgno[iLimit+1], 0, nByte);†Ÿ%#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERTŸI  /* Verify that the every entry in the mapping region is still reachableŸ/  ** via the hash table even after the cleanup.§  */Ø  if( iLimit ){Ÿ'    int j;           /* Loop counter */Ÿ#    int iKey;        /* Hash key */Ω    for(j=1; j<=iLimit; j++){ŸG      for(iKey=walHash(aPgno[j]); aHash[iKey]; iKey=walNextHash(iKey)){Ÿ#        if( aHash[iKey]==j ) break;ß      }ø      assert( aHash[iKey]==j );•    }£  }Ÿ+#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */°}††¢/*ŸC** Set an entry in the wal-index that will map database page numberø** pPage into WAL frame iFrame.¢*/Ÿ<static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){Ÿ3  int rc;                         /* Return code */ŸN  u32 iZero = 0;                  /* One less than frame number of aPgno[1] */Ÿ9  volatile u32 *aPgno = 0;        /* Page number array */Ÿ2  volatile ht_slot *aHash = 0;    /* Hash table */†ŸF  rc = walHashGet(pWal, walFramePage(iFrame), &aHash, &aPgno, &iZero);†ŸF  /* Assuming the wal-index file was successfully mapped, populate theŸ,  ** page number array and hash table entry.§  */∂  if( rc==SQLITE_OK ){Ÿ6    int iKey;                     /* Hash table key */ŸI    int idx;                      /* Value to write to hash-table slot */ŸA    int nCollide;                 /* Number of hash collisions */†π    idx = iFrame - iZero;Ÿ+    assert( idx <= HASHTABLE_NSLOT/2 + 1 );§    ŸJ    /* If this is the first entry to be added to this hash-table, zero theŸ>    ** entire hash table and aPgno[] array before proceeding. ¶    */±    if( idx==1 ){ŸI      int nByte = (int)((u8 *)&aHash[HASHTABLE_NSLOT] - (u8 *)&aPgno[1]);Ÿ)      memset((void*)&aPgno[1], 0, nByte);•    }†ŸG    /* If the entry in aPgno[] is already set, then the previous writerŸJ    ** must have exited unexpectedly in the middle of a transaction (afterŸF    ** writing one or more dirty pages to the WAL to free up memory). ŸH    ** Remove the remnants of that writers uncommitted transaction from Ÿ5    ** the hash-table before writing any new entries.¶    */µ    if( aPgno[idx] ){ª      walCleanupHash(pWal);º      assert( !aPgno[idx] );•    }†Ÿ@    /* Write the aPgno[] array entry and the hash-table slot. */≥    nCollide = idx;ŸB    for(iKey=walHash(iPage); aHash[iKey]; iKey=walNextHash(iKey)){Ÿ7      if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;•    }∑    aPgno[idx] = iPage;ø    aHash[iKey] = (ht_slot)idx;†Ÿ%#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERTŸI    /* Verify that the number of entries in the hash table exactly equalsŸ3    ** the number of entries in the mapping region.¶    */•    {Ÿ)      int i;           /* Loop counter */Ÿ@      int nEntry = 0;  /* Number of entries in the hash table */ŸB      for(i=0; i<HASHTABLE_NSLOT; i++){ if( aHash[i] ) nEntry++; }º      assert( nEntry==idx );•    }†ŸE    /* Verify that the every entry in the mapping region is reachableŸK    ** via the hash table.  This turns out to be a really, really expensiveŸB    ** thing to check, so only do this occasionally - not on every±    ** iteration.¶    */π    if( (idx&0x3ff)==0 ){Ÿ)      int i;           /* Loop counter */º      for(i=1; i<=idx; i++){ŸI        for(iKey=walHash(aPgno[i]); aHash[iKey]; iKey=walNextHash(iKey)){Ÿ%          if( aHash[iKey]==i ) break;©        }Ÿ!        assert( aHash[iKey]==i );ß      }•    }Ÿ+#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */£  }††¨  return rc;°}††¢/*Ÿ>** Recover the wal-index by reading the write-ahead log file. ¢**ŸA** This routine first tries to establish an exclusive lock on theŸC** wal-index to prevent other threads/processes from doing anythingŸ<** with the WAL or wal-index while recovery is running.  TheŸ@** WAL_RECOVER_LOCK is also held so that other threads will knowŸ@** that this thread is running recovery.  If unable to establishŸ9** the necessary locks, this routine returns SQLITE_BUSY.¢*/Ÿ&static int walIndexRecover(Wal *pWal){Ÿ3  int rc;                         /* Return Code */Ÿ8  i64 nSize;                      /* Size of log file */æ  u32 aFrameCksum[2] = {0, 0};ŸJ  int iLock;                      /* Lock offset to lock for checkpoint */†ŸJ  /* Obtain an exclusive lock on all byte in the locking range not alreadyŸF  ** locked by the caller. The caller is guaranteed to have locked theŸJ  ** WAL_WRITE_LOCK byte, and may have also locked the WAL_CKPT_LOCK byte.ŸK  ** If successful, the same bytes that are locked here are unlocked beforeª  ** this function returns.§  */Ÿ3  assert( pWal->ckptLock==1 || pWal->ckptLock==0 );Ÿ0  assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );Ÿ-  assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );º  assert( pWal->writeLock );Ÿ-  iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;Ÿ=  rc = walLockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);∂  if( rc==SQLITE_OK ){ŸA    rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);∏    if( rc!=SQLITE_OK ){Ÿ>      walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);•    }£  }´  if( rc ){Æ    return rc;£  }†Ÿ1  WALTRACE(("WAL%p: recovery begin...\n", pWal));†Ÿ-  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));†Ÿ/  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);∂  if( rc!=SQLITE_OK ){∏    goto recovery_error;£  }†∫  if( nSize>WAL_HDRSIZE ){ŸF    u8 aBuf[WAL_HDRSIZE];         /* Buffer to load WAL header into */ŸL    u8 *aFrame = 0;               /* Malloc'd buffer to load entire frame */ŸJ    int szFrame;                  /* Number of bytes in buffer aFrame[] */ŸM    u8 *aData;                    /* Pointer to data part of aFrame buffer */Ÿ@    int iFrame;                   /* Index of last frame read */ŸI    i64 iOffset;                  /* Next offset to read from log file */ŸF    int szPage;                   /* Page size according to the log */ŸH    u32 magic;                    /* Magic value read from WAL header */ŸH    u32 version;                  /* Magic value read from WAL header */ŸC    int isValid;                  /* True if this frame is valid */†Ÿ!    /* Read in the WAL header. */Ÿ;    rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);∏    if( rc!=SQLITE_OK ){∫      goto recovery_error;•    }†ŸJ    /* If the database page size is not a power of two, or is greater thanŸJ    ** SQLITE_MAX_PAGE_SIZE, conclude that the WAL file contains no valid ŸI    ** data. Similarly, if the 'magic' value is invalid, ignore the whole∞    ** WAL file.¶    */Ÿ&    magic = sqlite3Get4byte(&aBuf[0]);Ÿ'    szPage = sqlite3Get4byte(&aBuf[8]);Ÿ&    if( (magic&0xFFFFFFFE)!=WAL_MAGIC ∫     || szPage&(szPage-1) Ÿ$     || szPage>SQLITE_MAX_PAGE_SIZE ≥     || szPage<512 ¶    ){¥      goto finished;•    }Ÿ3    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);∫    pWal->szPage = szPage;Ÿ-    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);Ÿ+    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);†Ÿ8    /* Verify that the WAL header checksum is correct */Ÿ>    walChecksumBytes(pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN, Ÿ7        aBuf, WAL_HDRSIZE-2*4, 0, pWal->hdr.aFrameCksum¶    );Ÿ<    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])Ÿ<     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])¶    ){¥      goto finished;•    }†ŸC    /* Verify that the version number on the WAL format is one thatŸ     ** are able to understand */Ÿ(    version = sqlite3Get4byte(&aBuf[4]);Ÿ#    if( version!=WAL_MAX_VERSION ){Ÿ       rc = SQLITE_CANTOPEN_BKPT;¥      goto finished;•    }†Ÿ.    /* Malloc a buffer to read frames into. */Ÿ)    szFrame = szPage + WAL_FRAME_HDRSIZE;Ÿ-    aFrame = (u8 *)sqlite3_malloc64(szFrame);≤    if( !aFrame ){Ω      rc = SQLITE_NOMEM_BKPT;∫      goto recovery_error;•    }Ÿ'    aData = &aFrame[WAL_FRAME_HDRSIZE];†Ÿ,    /* Read all frames from the log file. */Ø    iFrame = 0;ŸI    for(iOffset=WAL_HDRSIZE; (iOffset+szFrame)<=nSize; iOffset+=szFrame){ŸF      u32 pgno;                   /* Database page number for frame */ŸF      u32 nTruncate;              /* dbsize field from frame header */†Ÿ/      /* Read and decode the next log frame. */Ø      iFrame++;ŸA      rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);Ÿ       if( rc!=SQLITE_OK ) break;ŸG      isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);ª      if( !isValid ) break;Ÿ.      rc = walIndexAppend(pWal, iFrame, pgno);Ÿ       if( rc!=SQLITE_OK ) break;†Ÿ>      /* If nTruncate is non-zero, this is a commit record. */∂      if( nTruncate ){Ÿ#        pWal->hdr.mxFrame = iFrame;Ÿ$        pWal->hdr.nPage = nTruncate;ŸA        pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));Ÿ"        testcase( szPage<=32768 );Ÿ"        testcase( szPage>=65536 );Ÿ2        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];Ÿ2        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];ß      }•    }†π    sqlite3_free(aFrame);£  }†©finished:∂  if( rc==SQLITE_OK ){Ÿ     volatile WalCkptInfo *pInfo;™    int i;Ÿ.    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];Ÿ.    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];ª    walIndexWriteHdr(pWal);†ŸH    /* Reset the checkpoint-header. This is safe because this thread is ŸJ    ** currently holding locks that exclude all other readers, writers andµ    ** checkpointers.¶    */æ    pInfo = walCkptInfo(pWal);π    pInfo->nBackfill = 0;Ÿ2    pInfo->nBackfillAttempted = pWal->hdr.mxFrame;º    pInfo->aReadMark[0] = 0;ŸI    for(i=1; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;ŸD    if( pWal->hdr.mxFrame ) pInfo->aReadMark[1] = pWal->hdr.mxFrame;†ŸH    /* If more than one frame was recovered from the log file, report anŸL    ** event via sqlite3_log(). This is to help with identifying performanceŸF    ** problems caused by applications routinely shutting down withoutŸ"    ** checkpointing the log file.¶    */∫    if( pWal->hdr.nPage ){Ÿ,      sqlite3_log(SQLITE_NOTICE_RECOVER_WAL,Ÿ1          "recovered %d frames from WAL file %s",Ÿ+          pWal->hdr.mxFrame, pWal->zWalName®      );•    }£  }†Ørecovery_error:ŸA  WALTRACE(("WAL%p: recovery %s\n", pWal, rc ? "failed" : "ok"));Ÿ:  walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);Ÿ<  walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);¨  return rc;°}†¢/*ª** Close an open wal-index.¢*/Ÿ3static void walIndexClose(Wal *pWal, int isDelete){ŸI  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE || pWal->bShmUnreliable ){™    int i;Ÿ#    for(i=0; i<pWal->nWiData; i++){Ÿ.      sqlite3_free((void *)pWal->apWiData[i]);º      pWal->apWiData[i] = 0;•    }£  }Ÿ1  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){Ÿ-    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);£  }°}†£/* ŸF** Open a connection to the WAL file zWalName. The database file must ŸI** already be opened on connection pDbFd. The buffer that zWalName pointsŸE** to must remain valid for the lifetime of the returned Wal* handle.¢**ŸG** A SHARED lock should be held on the database file when this functionŸE** is called. The purpose of this SHARED lock is to prevent any otherŸF** client from unlinking the WAL or wal-index file. If another processŸH** were to do this just after this client opened one of these files, theŸ ** system would be badly broken.¢**ŸE** If the log file is successfully opened, SQLITE_OK is returned and ŸB** *ppWal is set to point to a new WAL handle. If an error occurs,ŸB** an SQLite error code is returned and *ppWal is left unmodified.¢*/Ÿ"SQLITE_PRIVATE int sqlite3WalOpen(ŸL  sqlite3_vfs *pVfs,              /* vfs module to open wal and wal-index */Ÿ>  sqlite3_file *pDbFd,            /* The open database file */Ÿ<  const char *zWalName,           /* Name of the WAL file */ŸG  int bNoShm,                     /* True to run in heap-memory mode */ŸJ  i64 mxWalSize,                  /* Truncate WAL to this size on reset */ŸA  Wal **ppWal                     /* OUT: Allocated Wal handle */¢){Ÿ3  int rc;                         /* Return Code */ŸE  Wal *pRet;                      /* Object to allocate and return */Ÿ@  int flags;                      /* Flags passed to OsOpen() */†Ÿ$  assert( zWalName && zWalName[0] );≤  assert( pDbFd );†ŸM  /* In the amalgamation, the os_unix.c and os_win.c source files come beforeŸL  ** this source file.  Verify that the #defines of the locking byte offsetsŸI  ** in os_unix.c and os_win.c agree with the WALINDEX_LOCK_OFFSET value.ŸM  ** For that matter, if the lock offset ever changes from its initial designŸL  ** value of 120, we need to know that so there is an assert() to check it.§  */Ÿ&  assert( 120==WALINDEX_LOCK_OFFSET );Ÿ#  assert( 136==WALINDEX_HDR_SIZE );≥#ifdef WIN_SHM_BASEŸ/  assert( WIN_SHM_BASE==WALINDEX_LOCK_OFFSET );¶#endif¥#ifdef UNIX_SHM_BASEŸ0  assert( UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET );¶#endif††Ÿ5  /* Allocate an instance of struct Wal to return. */≠  *ppWal = 0;Ÿ?  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);Æ  if( !pRet ){Ω    return SQLITE_NOMEM_BKPT;£  }†¥  pRet->pVfs = pVfs;Ÿ*  pRet->pWalFd = (sqlite3_file *)&pRet[1];∂  pRet->pDbFd = pDbFd;∂  pRet->readLock = -1;æ  pRet->mxWalSize = mxWalSize;º  pRet->zWalName = zWalName;∑  pRet->syncHeader = 1;Ÿ   pRet->padToSectorBoundary = 1;ŸH  pRet->exclusiveMode = (bNoShm ? WAL_HEAPMEMORY_MODE: WAL_NORMAL_MODE);†Ÿ5  /* Open file handle on the write-ahead log file. */ŸE  flags = (SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_WAL);ŸB  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);Ÿ4  if( rc==SQLITE_OK && flags&SQLITE_OPEN_READONLY ){Ÿ     pRet->readOnly = WAL_RDONLY;£  }†∂  if( rc!=SQLITE_OK ){ª    walIndexClose(pRet, 0);Ÿ!    sqlite3OsClose(pRet->pWalFd);∑    sqlite3_free(pRet);®  }else{Ÿ4    int iDC = sqlite3OsDeviceCharacteristics(pDbFd);Ÿ@    if( iDC & SQLITE_IOCAP_SEQUENTIAL ){ pRet->syncHeader = 0; }Ÿ1    if( iDC & SQLITE_IOCAP_POWERSAFE_OVERWRITE ){Ÿ$      pRet->padToSectorBoundary = 0;•    }≤    *ppWal = pRet;Ÿ(    WALTRACE(("WAL%d: opened\n", pRet));£  }¨  return rc;°}†¢/*ŸC** Change the size to which the WAL file is trucated on each reset.¢*/Ÿ;SQLITE_PRIVATE void sqlite3WalLimit(Wal *pWal, i64 iLimit){Ÿ&  if( pWal ) pWal->mxWalSize = iLimit;°}†¢/*ŸF** Find the smallest page number out of all pages held in the WAL thatŸF** has not been returned by any prior invocation of this method on theŸG** same WalIterator object.   Write into *piFrame the frame index whereŸH** that page was last written into the WAL.  Write into *piPage the page™** number.¢**ŸE** Return 0 on success.  If there are no pages in the WAL with a pageŸ-** number larger than *piPage, then return 1.¢*/ªstatic int walIteratorNext(Ÿ.  WalIterator *p,               /* Iterator */ŸK  u32 *piPage,                  /* OUT: The page number of the next page */ŸG  u32 *piFrame                  /* OUT: Wal frame index of next page */¢){ŸK  u32 iMin;                     /* Result pgno must be greater than iMin */ŸM  u32 iRet = 0xFFFFFFFF;        /* 0xffffffff is never a valid page number */ŸB  int i;                        /* For looping through segments */†≥  iMin = p->iPrior;º  assert( iMin<0xffffffff );Ÿ"  for(i=p->nSegment-1; i>=0; i--){Ÿ2    struct WalSegment *pSegment = &p->aSegment[i];Ÿ.    while( pSegment->iNext<pSegment->nEntry ){ŸC      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];µ      if( iPg>iMin ){∑        if( iPg<iRet ){µ          iRet = iPg;ŸI          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];©        }Æ        break;ß      }∏      pSegment->iNext++;•    }£  }†Ω  *piPage = p->iPrior = iRet;º  return (iRet==0xFFFFFFFF);°}†¢/*ŸC** This function merges two sorted lists into a single sorted list.¢**Ÿ?** aLeft[] and aRight[] are arrays of indices.  The sort key isŸG** aContent[aLeft[]] and aContent[aRight[]].  Upon entry, the followingΩ** is guaranteed for all J<K:¢**Ÿ1**        aContent[aLeft[J]] < aContent[aLeft[K]]Ÿ3**        aContent[aRight[J]] < aContent[aRight[K]]¢**ŸI** This routine overwrites aRight[] with a new (probably longer) sequenceŸI** of indices such that the aRight[] contains every index that appears inŸH** either aLeft[] or the old aRight[] and such that the second condition∂** above is still met.¢**ŸC** The aContent[aLeft[X]] values will be unique for all X.  And theŸE** aContent[aRight[X]] values will be unique too.  But there might beŸ0** one or more combinations of X and Y such that¢**ŸJ**      aLeft[X]!=aRight[Y]  &&  aContent[aLeft[X]] == aContent[aRight[Y]]¢**ŸD** When that happens, omit the aLeft[X] and use the aRight[Y] index.¢*/µstatic void walMerge(ŸH  const u32 *aContent,            /* Pages in wal - keys for the sort */Ÿ@  ht_slot *aLeft,                 /* IN: Left hand input list */ŸE  int nLeft,                      /* IN: Elements in array *paLeft */ŸE  ht_slot **paRight,              /* IN/OUT: Right hand input list */ŸD  int *pnRight,                   /* IN/OUT: Elements in *paRight */Ÿ8  ht_slot *aTmp                   /* Temporary buffer */¢){Ÿ>  int iLeft = 0;                  /* Current index in aLeft */Ÿ?  int iRight = 0;                 /* Current index in aRight */ŸF  int iOut = 0;                   /* Current index in output buffer */∏  int nRight = *pnRight;Ω  ht_slot *aRight = *paRight;†Ÿ   assert( nLeft>0 && nRight>0 );Ÿ(  while( iRight<nRight || iLeft<nLeft ){¥    ht_slot logpage;∞    Pgno dbpage;†∂    if( (iLeft<nLeft) ŸK     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])¶    ){ø      logpage = aLeft[iLeft++];™    }else{Ÿ!      logpage = aRight[iRight++];•    }ø    dbpage = aContent[logpage];†ª    aTmp[iOut++] = logpage;Ÿ@    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;†Ÿ<    assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );Ÿ@    assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );£  }†≥  *paRight = aLeft;≤  *pnRight = iOut;Ÿ,  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);°}†¢/*ŸD** Sort the elements in list aList using aContent[] as the sort key.Ÿ>** Remove elements with duplicate keys, preferring to keep theπ** larger aList[] values.¢**ŸB** The aList[] entries are indices into aContent[].  The values inŸ0** aList[] are to be sorted so that for all J<K:¢**Ÿ/**      aContent[aList[J]] < aContent[aList[K]]¢**º** For any X and Y such that¢**Ÿ0**      aContent[aList[X]] == aContent[aList[Y]]¢**ŸF** Keep the larger of the two values aList[X] and aList[Y] and discardØ** the smaller.¢*/πstatic void walMergesort(Ÿ4  const u32 *aContent,            /* Pages in wal */ŸO  ht_slot *aBuffer,               /* Buffer of at least *pnList items to use */Ÿ<  ht_slot *aList,                 /* IN/OUT: List to sort */ŸM  int *pnList                     /* IN/OUT: Number of elements in aList[] */¢){≤  struct Sublist {ŸC    int nList;                    /* Number of elements in aList */ŸC    ht_slot *aList;               /* Pointer to sub-list content */§  };†Ÿ:  const int nList = *pnList;      /* Size of input list */ŸI  int nMerge = 0;                 /* Number of elements in list aMerge */Ÿ9  ht_slot *aMerge = 0;            /* List to be merged */Ÿ=  int iList;                      /* Index into input list */Ÿ=  u32 iSub = 0;                   /* Index into aSub array */Ÿ:  struct Sublist aSub[13];        /* Array of sub-lists */†Ÿ   memset(aSub, 0, sizeof(aSub));Ÿ.  assert( nList<=HASHTABLE_NPAGE && nList>0 );Ÿ6  assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) );†Ÿ%  for(iList=0; iList<nList; iList++){Ø    nMerge = 1;ª    aMerge = &aList[iList];Ÿ+    for(iSub=0; iList & (1<<iSub); iSub++){∏      struct Sublist *p;Ÿ%      assert( iSub<ArraySize(aSub) );∂      p = &aSub[iSub];Ÿ0      assert( p->aList && p->nList<=(1<<iSub) );Ÿ7      assert( p->aList==&aList[iList&~((2<<iSub)-1)] );ŸH      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);•    }æ    aSub[iSub].aList = aMerge;æ    aSub[iSub].nList = nMerge;£  }†Ÿ,  for(iSub++; iSub<ArraySize(aSub); iSub++){º    if( nList & (1<<iSub) ){∏      struct Sublist *p;Ÿ%      assert( iSub<ArraySize(aSub) );∂      p = &aSub[iSub];Ÿ$      assert( p->nList<=(1<<iSub) );Ÿ7      assert( p->aList==&aList[nList&~((2<<iSub)-1)] );ŸH      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);•    }£  }∫  assert( aMerge==aList );≥  *pnList = nMerge;†≥#ifdef SQLITE_DEBUG£  {™    int i;Ω    for(i=1; i<*pnList; i++){Ÿ:      assert( aContent[aList[i]] > aContent[aList[i-1]] );•    }£  }¶#endif°}†£/* Ÿ3** Free an iterator allocated by walIteratorInit().¢*/Ÿ,static void walIteratorFree(WalIterator *p){≤  sqlite3_free(p);°}†¢/*ŸE** Construct a WalInterator object that can be used to loop over all ŸH** pages in the WAL following frame nBackfill in ascending order. FramesŸK** nBackfill or earlier may be included - excluding them is an optimizationŸ2** only. The caller must hold the checkpoint lock.¢**ŸH** On success, make *pp point to the newly allocated WalInterator objectŸE** return SQLITE_OK. Otherwise, return an error code. If this routineŸ3** returns an error, the value of *pp is undefined.¢**ŸE** The calling routine should invoke walIteratorFree() to destroy theŸ3** WalIterator object when it has finished with it.¢*/ŸGstatic int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){Ÿ4  WalIterator *p;                 /* Return value */ŸC  int nSegment;                   /* Number of segments to merge */Ÿ9  u32 iLast;                      /* Last frame in log */ŸC  int nByte;                      /* Number of bytes to allocate */Ÿ9  int i;                          /* Iterator variable */ŸE  ht_slot *aTmp;                  /* Temp space used by merge-sort */Ÿ3  int rc = SQLITE_OK;             /* Return Code */†ŸB  /* This routine only runs while holding the checkpoint lock. AndŸF  ** it only runs if there is actually content in the log (mxFrame>0).§  */Ÿ2  assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );º  iLast = pWal->hdr.mxFrame;†Ÿ2  /* Allocate space for the WalIterator object. */Ÿ%  nSegment = walFramePage(iLast) + 1;æ  nByte = sizeof(WalIterator) Ÿ0        + (nSegment-1)*sizeof(struct WalSegment)Ÿ         + iLast*sizeof(ht_slot);Ÿ-  p = (WalIterator *)sqlite3_malloc64(nByte);´  if( !p ){Ω    return SQLITE_NOMEM_BKPT;£  }∂  memset(p, 0, nByte);π  p->nSegment = nSegment;†ŸH  /* Allocate temporary space used by the merge-sort routine. This blockŸ:  ** of memory will be freed before this function returns.§  */Ÿ%  aTmp = (ht_slot *)sqlite3_malloc64(ŸE      sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)§  );Æ  if( !aTmp ){ª    rc = SQLITE_NOMEM_BKPT;£  }†ŸE  for(i=walFramePage(nBackfill+1); rc==SQLITE_OK && i<nSegment; i++){º    volatile ht_slot *aHash;Æ    u32 iZero;∏    volatile u32 *aPgno;†Ÿ5    rc = walHashGet(pWal, i, &aHash, &aPgno, &iZero);∏    if( rc==SQLITE_OK ){Ÿ8      int j;                      /* Counter variable */ŸI      int nEntry;                 /* Number of entries in this segment */ŸE      ht_slot *aIndex;            /* Sorted index for this segment */†Æ      aPgno++;º      if( (i+1)==nSegment ){Ÿ&        nEntry = (int)(iLast - iZero);¨      }else{Ÿ2        nEntry = (int)((u32*)aHash - (u32*)aPgno);ß      }Ÿ>      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[iZero];Æ      iZero++;¢  æ      for(j=0; j<nEntry; j++){ø        aIndex[j] = (ht_slot)j;ß      }Ÿ8      walMergesort((u32 *)aPgno, aTmp, aIndex, &nEntry);Ÿ#      p->aSegment[i].iZero = iZero;Ÿ%      p->aSegment[i].nEntry = nEntry;Ÿ%      p->aSegment[i].aIndex = aIndex;Ÿ*      p->aSegment[i].aPgno = (u32 *)aPgno;•    }£  }µ  sqlite3_free(aTmp);†∂  if( rc!=SQLITE_OK ){∑    walIteratorFree(p);™    p = 0;£  }™  *pp = p;¨  return rc;°}†¢/*ŸM** Attempt to obtain the exclusive WAL lock defined by parameters lockIdx andŸH** n. If the attempt fails and parameter xBusy is not NULL, then it is aŸG** busy-handler function. Invoke it and retry the lock until either theŸ?** lock is successfully obtained or the busy-handler returns 0.¢*/∑static int walBusyLock(Ÿ6  Wal *pWal,                      /* WAL connection */ŸB  int (*xBusy)(void*),            /* Function to call when busy */ŸI  void *pBusyArg,                 /* Context argument for xBusyHandler */ŸD  int lockIdx,                    /* Offset of first byte to lock */Ÿ?  int n                           /* Number of bytes to lock */¢){©  int rc;¶  do {Ÿ,    rc = walLockExclusive(pWal, lockIdx, n);Ÿ8  }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );¨  return rc;°}†¢/*ŸI** The cache of the wal-index header must be valid to call this function.Ÿ6** Return the page-size in bytes used by the database.¢*/Ÿ"static int walPagesize(Wal *pWal){ŸE  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);°}†¢/*Ÿ<** The following is guaranteed when this function is called:¢**Ÿ **   a) the WRITER lock is held,Ÿ6**   b) the entire log file has been checkpointed, andŸF**   c) any existing readers are reading exclusively from the databaseŸI**      file - there are no readers that may attempt to read a frame fromµ**      the log file.¢**ŸF** This function updates the shared-memory structures so that the nextŸE** client to write to the database (which may be this one) does so byŸ1** writing frames into the start of the log file.¢**ŸE** The value of parameter salt1 is used as the aSalt[1] value in the ŸI** new wal-index header. It should be passed a pseudo-random value (i.e. Ÿ+** one obtained from sqlite3_randomness()).¢*/Ÿ0static void walRestartHdr(Wal *pWal, u32 salt1){Ÿ2  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);Ÿ4  int i;                          /* Loop counter */Ÿ>  u32 *aSalt = pWal->hdr.aSalt;   /* Big-endian salt values */∞  pWal->nCkpt++;∏  pWal->hdr.mxFrame = 0;ŸG  sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));Ÿ)  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);π  walIndexWriteHdr(pWal);∑  pInfo->nBackfill = 0;Ÿ   pInfo->nBackfillAttempted = 0;∫  pInfo->aReadMark[1] = 0;ŸG  for(i=2; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;Ÿ#  assert( pInfo->aReadMark[0]==0 );°}†¢/*ŸJ** Copy as much content as we can from the WAL back into the database fileŸH** in response to an sqlite3_wal_checkpoint() request or the equivalent.¢**ŸI** The amount of information copies from WAL to database might be limitedŸH** by active readers.  This routine will never overwrite a database pageŸ+** that a concurrent reader might be using.¢**ŸG** All I/O barrier operations (a.k.a fsyncs) occur in this routine whenŸD** SQLite is in WAL-mode in synchronous=NORMAL.  That means that if ŸC** checkpoints are always run by a background thread or background ŸH** process, foreground threads will never block on a lengthy fsync call.¢**ŸG** Fsync is called on the WAL before writing content out of the WAL andŸI** into the database.  This ensures that if the new content is persistentŸH** in the WAL and can be recovered following a power-loss or hard reset.¢**ŸH** Fsync is also called on the database file if (and only if) the entireŸI** WAL content is copied into the database file.  This second fsync makesŸF** it safe to delete the WAL since the new content will persist in the±** database file.¢**ŸM** This routine uses and updates the nBackfill field of the wal-index header.ŸH** This is the only routine that will increase the value of nBackfill.  ŸK** (A WAL reset or recovery will revert nBackfill to zero, but not increaseÆ** its value.)¢**ŸF** The caller must be holding sufficient locks to ensure that no otherŸE** checkpoint is running (in any other thread or process) at the same®** time.¢*/πstatic int walCheckpoint(Ÿ6  Wal *pWal,                      /* Wal connection */ŸK  sqlite3 *db,                    /* Check for interrupts on this handle */ŸG  int eMode,                      /* One of PASSIVE, FULL or RESTART */ŸB  int (*xBusy)(void*),            /* Function to call when busy */ŸI  void *pBusyArg,                 /* Context argument for xBusyHandler */ŸA  int sync_flags,                 /* Flags for OsSync() (or 0) */Ÿ?  u8 *zBuf                        /* Temporary buffer to use */¢){Ÿ3  int rc = SQLITE_OK;             /* Return code */Ÿ:  int szPage;                     /* Database page-size */Ÿ<  WalIterator *pIter = 0;         /* Wal iterator context */ŸC  u32 iDbpage = 0;                /* Next database page to write */ŸM  u32 iFrame = 0;                 /* Wal frame containing data for iDbpage */ŸH  u32 mxSafeFrame;                /* Max frame that can be backfilled */ŸB  u32 mxPage;                     /* Max database page to write */Ÿ4  int i;                          /* Loop counter */ŸI  volatile WalCkptInfo *pInfo;    /* The checkpoint status information */†Ω  szPage = walPagesize(pWal);º  testcase( szPage<=32768 );º  testcase( szPage>=65536 );º  pInfo = walCkptInfo(pWal);Ÿ+  if( pInfo->nBackfill<pWal->hdr.mxFrame ){†ŸL    /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invokedŸ0    ** in the SQLITE_CHECKPOINT_PASSIVE mode. */Ÿ;    assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );†ŸL    /* Compute in mxSafeFrame the index of the last frame of the WAL that isŸH    ** safe to write into the database.  Frames beyond mxSafeFrame mightŸJ    ** overwrite database pages that are in use by active readers and thusŸ)    ** cannot be backfilled from the WAL.¶    */Ÿ$    mxSafeFrame = pWal->hdr.mxFrame;Ω    mxPage = pWal->hdr.nPage;Ÿ!    for(i=1; i<WAL_NREADER; i++){ŸG      /* Thread-sanitizer reports that the following is an unsafe read,ŸI      ** as some other thread may be in the process of updating the valueŸH      ** of the aReadMark[] slot. The assumption here is that if that isŸF      ** happening, the other client may only be increasing the value,ŸG      ** not decreasing it. So assuming either that either the "old" orŸI      ** "new" version of the value is read, and not some arbitrary valueŸH      ** that would never be written by a real client, things are still ≤      ** safe.  */Ÿ"      u32 y = pInfo->aReadMark[i];∫      if( mxSafeFrame>y ){Ÿ'        assert( y<=pWal->hdr.mxFrame );ŸE        rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);º        if( rc==SQLITE_OK ){ŸI          pInfo->aReadMark[i] = (i==1 ? mxSafeFrame : READMARK_NOT_USED);Ÿ8          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);Ÿ$        }else if( rc==SQLITE_BUSY ){∫          mxSafeFrame = y;¥          xBusy = 0;Æ        }else{Ÿ!          goto walcheckpoint_out;©        }ß      }•    }†ø    /* Allocate the iterator */Ÿ'    if( pInfo->nBackfill<mxSafeFrame ){Ÿ;      rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);Ÿ*      assert( rc==SQLITE_OK || pIter==0 );•    }†≠    if( pIterŸP     && (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0),1))==SQLITE_OK¶    ){ŸG      i64 nSize;                    /* Current size of database file */Ÿ'      u32 nBackfill = pInfo->nBackfill;†Ÿ.      pInfo->nBackfillAttempted = mxSafeFrame;†Ÿ       /* Sync the WAL to disk */ŸD      rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));†ŸF      /* If the database may grow as a result of this checkpoint, hintŸA      ** about the eventual size of the db file to the VFS layer.®      */∫      if( rc==SQLITE_OK ){Ÿ*        i64 nReq = ((i64)mxPage * szPage);Ÿ4        rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);Ÿ*        if( rc==SQLITE_OK && nSize<nReq ){ŸO          sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);©        }ß      }††ŸP      /* Iterate through the contents of the WAL, copying data to the db file */ŸM      while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){¥        i64 iOffset;Ÿ6        assert( walFramePgno(pWal, iFrame)==iDbpage );Ÿ#        if( db->u1.isInterrupted ){ŸG          rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;∞          break;©        }ŸH        if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){≥          continue;©        }ŸE        iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;ŸJ        /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */Ÿ@        rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);Ÿ"        if( rc!=SQLITE_OK ) break;Ÿ*        iOffset = (iDbpage-1)*(i64)szPage;Ÿ(        testcase( IS_BIG_INT(iOffset) );Ÿ@        rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);Ÿ"        if( rc!=SQLITE_OK ) break;ß      }†Ÿ0      /* If work was actually accomplished... */∫      if( rc==SQLITE_OK ){Ÿ6        if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){Ÿ1          i64 szDb = pWal->hdr.nPage*(i64)szPage;Ÿ'          testcase( IS_BIG_INT(szDb) );Ÿ4          rc = sqlite3OsTruncate(pWal->pDbFd, szDb);æ          if( rc==SQLITE_OK ){ŸI            rc = sqlite3OsSync(pWal->pDbFd, CKPT_SYNC_FLAGS(sync_flags));´          }©        }º        if( rc==SQLITE_OK ){Ÿ)          pInfo->nBackfill = mxSafeFrame;©        }ß      }†Ÿ:      /* Release the reader lock held while backfilling */Ÿ4      walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);•    }†∫    if( rc==SQLITE_BUSY ){ŸG      /* Reset the return code so as not to report a checkpoint failureŸ3      ** just because there are active readers.  */µ      rc = SQLITE_OK;•    }£  }†ŸK  /* If this is an SQLITE_CHECKPOINT_RESTART or TRUNCATE operation, and theŸH  ** entire wal file has been copied into the database file, then block ŸK  ** until all readers have finished using the wal file. This ensures that ŸE  ** the next process to write to the database restarts the wal file.§  */Ÿ:  if( rc==SQLITE_OK && eMode!=SQLITE_CHECKPOINT_PASSIVE ){æ    assert( pWal->writeLock );Ÿ-    if( pInfo->nBackfill<pWal->hdr.mxFrame ){∑      rc = SQLITE_BUSY;Ÿ1    }else if( eMode>=SQLITE_CHECKPOINT_RESTART ){∞      u32 salt1;Ÿ$      sqlite3_randomness(4, &salt1);Ÿ4      assert( pInfo->nBackfill==pWal->hdr.mxFrame );ŸO      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);∫      if( rc==SQLITE_OK ){Ÿ0        if( eMode==SQLITE_CHECKPOINT_TRUNCATE ){ŸM          /* IMPLEMENTATION-OF: R-44699-57140 This mode works the same way asŸE          ** SQLITE_CHECKPOINT_RESTART with the addition that it alsoŸA          ** truncates the log file to zero bytes just prior to aø          ** successful return.¨          **ŸH          ** In theory, it might be safe to do this without updating theŸK          ** wal-index header in shared memory, as all subsequent reader orŸH          ** writer clients should see that the entire log file has beenŸK          ** checkpointed and behave accordingly. This seems unsafe though,ŸJ          ** as it would leave the system in a state where the contents ofŸC          ** the wal-index header do not match the contents of the ŸG          ** file-system. To avoid this, update the wal-index header toŸG          ** indicate that the log file contains zero valid frames.  */Ÿ%          walRestartHdr(pWal, salt1);Ÿ2          rc = sqlite3OsTruncate(pWal->pWalFd, 0);©        }ŸB        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);ß      }•    }£  }†≥ walcheckpoint_out:π  walIteratorFree(pIter);¨  return rc;°}†¢/*ŸH** If the WAL file is currently larger than nMax bytes in size, truncateŸJ** it to exactly nMax bytes. If an error occurs while doing so, ignore it.¢*/Ÿ.static void walLimitSize(Wal *pWal, i64 nMax){©  i64 sz;©  int rx;Ω  sqlite3BeginBenignMalloc();Ÿ,  rx = sqlite3OsFileSize(pWal->pWalFd, &sz);Ÿ&  if( rx==SQLITE_OK && (sz > nMax ) ){Ÿ/    rx = sqlite3OsTruncate(pWal->pWalFd, nMax);£  }ª  sqlite3EndBenignMalloc();´  if( rx ){ŸA    sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);£  }°}†¢/*Ÿ$** Close a connection to a log file.¢*/Ÿ#SQLITE_PRIVATE int sqlite3WalClose(Ÿ4  Wal *pWal,                      /* Wal to close */Ÿ:  sqlite3 *db,                    /* For interrupt flag */ŸH  int sync_flags,                 /* Flags to pass to OsSync() (or 0) */´  int nBuf,ŸE  u8 *zBuf                        /* Buffer of at least nBuf bytes */¢){µ  int rc = SQLITE_OK;≠  if( pWal ){ŸN    int isDelete = 0;             /* True to unlink wal and wal-index files */†ŸK    /* If an EXCLUSIVE lock can be obtained on the database file (using theŸH    ** ordinary, rollback-mode locking methods, this guarantees that theŸI    ** connection associated with this log file is the only connection toŸI    ** the database. In this case checkpoint the database and unlink bothŸ#    ** the wal and wal-index files.¶    **Ÿ;    ** The EXCLUSIVE lock is not released before returning.¶    */Ø    if( zBuf!=0ŸK     && SQLITE_OK==(rc = sqlite3OsLock(pWal->pDbFd, SQLITE_LOCK_EXCLUSIVE))¶    ){Ÿ1      if( pWal->exclusiveMode==WAL_NORMAL_MODE ){Ÿ1        pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;ß      }Ÿ*      rc = sqlite3WalCheckpoint(pWal, db, ŸG          SQLITE_CHECKPOINT_PASSIVE, 0, 0, sync_flags, nBuf, zBuf, 0, 0®      );∫      if( rc==SQLITE_OK ){∫        int bPersist = -1;Ÿ!        sqlite3OsFileControlHint(Ÿ<            pWal->pDbFd, SQLITE_FCNTL_PERSIST_WAL, &bPersist™        );∫        if( bPersist!=1 ){ŸG          /* Try to delete the WAL file if the checkpoint completed andŸG          ** fsyned (rc==SQLITE_OK) and if we are not in persistent-walŸ           ** mode (!bPersist) */∑          isDelete = 1;Ÿ'        }else if( pWal->mxWalSize>=0 ){ŸI          /* Try to truncate the WAL file to zero bytes if the checkpointŸK          ** completed and fsynced (rc==SQLITE_OK) and we are in persistentŸJ          ** WAL mode (bPersist) and if the PRAGMA journal_size_limit is aŸL          ** non-negative value (pWal->mxWalSize>=0).  Note that we truncateŸH          ** to zero bytes as truncating to the journal_size_limit mightŸ1          ** leave a corrupt WAL file on disk. */Ÿ           walLimitSize(pWal, 0);©        }ß      }•    }†Ÿ"    walIndexClose(pWal, isDelete);Ÿ!    sqlite3OsClose(pWal->pWalFd);≥    if( isDelete ){Ÿ!      sqlite3BeginBenignMalloc();Ÿ5      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);ø      sqlite3EndBenignMalloc();•    }Ÿ(    WALTRACE(("WAL%p: closed\n", pWal));Ÿ)    sqlite3_free((void *)pWal->apWiData);∑    sqlite3_free(pWal);£  }¨  return rc;°}†¢/*ŸB** Try to read the wal-index header.  Return 0 on success and 1 if∂** there is a problem.¢**ŸF** The wal-index is in shared memory.  Another thread or process mightŸE** be writing the header at the same time this procedure is trying toŸJ** read it, which might result in inconsistency.  A dirty read is detectedŸG** by verifying that both copies of the header are the same and also byº** a checksum on the header.¢**ŸI** If and only if the read is consistent and the header is different fromŸH** pWal->hdr, then pWal->hdr is updated to the content of the new headerΩ** and *pChanged is set to 1.¢**ŸD** If the checksum cannot be verified return non-zero. If the headerŸ?** is read successfully and the checksum verified, return zero.¢*/Ÿ4static int walIndexTryHdr(Wal *pWal, int *pChanged){ŸF  u32 aCksum[2];                  /* Checksum on the header content */ŸH  WalIndexHdr h1, h2;             /* Two copies of the header content */Ÿ?  WalIndexHdr volatile *aHdr;     /* Header in shared memory */†ŸE  /* The first page of the wal-index must be mapped at this point. */Ÿ1  assert( pWal->nWiData>0 && pWal->apWiData[0] );†ŸH  /* Read the header. This might happen concurrently with a write to theŸ<  ** same area of shared memory on a different CPU in a SMP,ŸA  ** meaning it is possible that an inconsistent snapshot is readŸ5  ** from the file. If this happens, return non-zero.§  **ŸJ  ** There are two copies of the header at the beginning of the wal-index.ŸM  ** When reading, read [0] first then [1].  Writes are in the reverse order.ŸJ  ** Memory barriers are used to prevent the compiler or the hardware fromŸ%  ** reordering the reads and writes.§  */ª  aHdr = walIndexHdr(pWal);Ÿ,  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));∂  walShmBarrier(pWal);Ÿ,  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));†Ÿ(  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){Ÿ     return 1;   /* Dirty read */•  }  µ  if( h1.isInit==0 ){Ÿ;    return 1;   /* Malformed header - probably all zeros */£  }ŸI  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);Ÿ;  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){Ÿ-    return 1;   /* Checksum does not match */£  }†Ÿ5  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){≤    *pChanged = 1;Ÿ1    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));ŸO    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);Ÿ$    testcase( pWal->szPage<=32768 );Ÿ$    testcase( pWal->szPage>=65536 );£  }†Ÿ6  /* The header was successfully read. Return zero. */´  return 0;°}†¢/*ŸB** This is the value that walTryBeginRead returns when it needs toÆ** be retried.¢*/∑#define WAL_RETRY  (-1)†¢/*ŸC** Read the wal-index header from the wal-index and into pWal->hdr.ŸB** If the wal-header appears to be corrupt, try to reconstruct theŸ+** wal-index from the WAL before returning.¢**ŸC** Set *pChanged to 1 if the wal-index header value in pWal->hdr isŸG** changed by this operation.  If pWal->hdr is unchanged, set *pChanged®** to 0.¢**ŸC** If the wal-index header is successfully read, return SQLITE_OK. Ÿ"** Otherwise an SQLite error code.¢*/Ÿ5static int walIndexReadHdr(Wal *pWal, int *pChanged){Ÿ3  int rc;                         /* Return code */ŸD  int badHdr;                     /* True if a header read failed */ŸL  volatile u32 *page0;            /* Chunk of wal-index containing header */†ŸE  /* Ensure that page 0 of the wal-index (the page that contains the ŸG  ** wal-index header) is mapped. Return early if an error occurs here.§  */µ  assert( pChanged );Ÿ%  rc = walIndexPage(pWal, 0, &page0);∂  if( rc!=SQLITE_OK ){ŸO    assert( rc!=SQLITE_READONLY ); /* READONLY changed to OK in walIndexPage */Ÿ'    if( rc==SQLITE_READONLY_CANTINIT ){ŸI      /* The SQLITE_READONLY_CANTINIT return means that the shared-memoryŸG      ** was openable but is not writable, and this thread is unable toŸL      ** confirm that another write-capable connection has the shared-memoryŸH      ** open, and hence the content of the shared-memory is unreliable,ŸH      ** since the shared-memory might be inconsistent with the WAL fileŸ5      ** and there is no writer on hand to fix it. */π      assert( page0==0 );Ÿ#      assert( pWal->writeLock==0 );Ÿ0      assert( pWal->readOnly & WAL_SHM_RDONLY );ø      pWal->bShmUnreliable = 1;Ÿ0      pWal->exclusiveMode = WAL_HEAPMEMORY_MODE;¥      *pChanged = 1;™    }else{Ÿ?      return rc; /* Any other non-OK return is just an error */•    }®  }else{ŸM    /* page0 can be NULL if the SHM is zero bytes in size and pWal->writeLockŸ6    ** is zero, which prevents the SHM from growing */π    testcase( page0!=0 );£  }Ÿ+  assert( page0!=0 || pWal->writeLock==0 );†ŸH  /* If the first page of the wal-index has been mapped, try to read theŸI  ** wal-index header immediately, without holding any lock. This usuallyŸI  ** works, but may fail if the wal-index header is corrupt or currently Ÿ1  ** being modified by another thread or process.§  */Ÿ8  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);†ŸB  /* If the first attempt failed, it might have been due to a raceŸ7  ** with a writer.  So get a WRITE lock and try again.§  */Ÿ,  assert( badHdr==0 || pWal->writeLock==0 );Ø  if( badHdr ){ŸG    if( pWal->bShmUnreliable==0 && (pWal->readOnly & WAL_SHM_RDONLY) ){ŸB      if( SQLITE_OK==(rc = walLockShared(pWal, WAL_WRITE_LOCK)) ){Ÿ.        walUnlockShared(pWal, WAL_WRITE_LOCK);Ÿ&        rc = SQLITE_READONLY_RECOVERY;ß      }ŸL    }else if( SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1)) ){∫      pWal->writeLock = 1;Ÿ<      if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){Ÿ0        badHdr = walIndexTryHdr(pWal, pChanged);µ        if( badHdr ){ŸJ          /* If the wal-index header is still malformed even while holdingŸL          ** a WRITE lock, it can only mean that the header is corrupted andŸL          ** needs to be reconstructed.  So run recovery to do exactly that.¨          */Ÿ%          rc = walIndexRecover(pWal);∏          *pChanged = 1;©        }ß      }∫      pWal->writeLock = 0;Ÿ2      walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);•    }£  }†ŸI  /* If the header is read successfully, check the version number to makeŸH  ** sure the wal-index was not constructed with some future format thatŸ.  ** this version of SQLite cannot understand.§  */Ÿ>  if( badHdr==0 && pWal->hdr.iVersion!=WALINDEX_MAX_VERSION ){æ    rc = SQLITE_CANTOPEN_BKPT;£  }Ω  if( pWal->bShmUnreliable ){∏    if( rc!=SQLITE_OK ){Ω      walIndexClose(pWal, 0);ø      pWal->bShmUnreliable = 0;Ÿ8      assert( pWal->nWiData>0 && pWal->apWiData[0]==0 );ŸI      /* walIndexRecover() might have returned SHORT_READ if a concurrentŸI      ** writer truncated the WAL out from under it.  If that happens, itŸK      ** indicates that a writer has fixed the SHM file for us, so retry */Ÿ7      if( rc==SQLITE_IOERR_SHORT_READ ) rc = WAL_RETRY;•    }Ÿ*    pWal->exclusiveMode = WAL_NORMAL_MODE;£  }†¨  return rc;°}†¢/*ŸJ** Open a transaction in a connection where the shared-memory is read-onlyŸO** and where we cannot verify that there is a separate write-capable connectionŸB** on hand to keep the shared-memory up-to-date with the WAL file.¢**ŸI** This can happen, for example, when the shared-memory is implemented byŸF** memory-mapping a *-shm file, where a prior writer has shut down andŸH** left the *-shm file on disk, and now the present connection is tryingŸE** to use that database but lacks write permission on the *-shm file.ŸJ** Other scenarios are also possible, depending on the VFS implementation.¢**∞** Precondition:¢**ŸH**    The *-wal file has been read and an appropriate wal-index has beenŸI**    constructed in pWal->apWiData[] using heap memory instead of sharedÆ**    memory. ¢**ŸD** If this function returns SQLITE_OK, then the read transaction hasŸF** been successfully opened. In this case output variable (*pChanged) ŸC** is set to true before returning if the caller should discard theŸC** contents of the page cache before proceeding. Or, if it returns ŸD** WAL_RETRY, then the heap memory wal-index has been discarded and ŸA** the caller should retry opening the read transaction from the Ÿ;** beginning (including attempting to map the *-shm file). ¢**Ÿ8** If an error occurs, an SQLite error code is returned.¢*/Ÿ;static int walBeginShmUnreliable(Wal *pWal, int *pChanged){ŸI  i64 szWal;                      /* Size of wal file on disk in bytes */ŸL  i64 iOffset;                    /* Current offset when reading wal file */ŸF  u8 aBuf[WAL_HDRSIZE];           /* Buffer to load WAL header into */ŸL  u8 *aFrame = 0;                 /* Malloc'd buffer to load entire frame */ŸJ  int szFrame;                    /* Number of bytes in buffer aFrame[] */ŸM  u8 *aData;                      /* Pointer to data part of aFrame buffer */ŸB  volatile void *pDummy;          /* Dummy argument for xShmMap */Ÿ3  int rc;                         /* Return code */ŸK  u32 aSaveCksum[2];              /* Saved copy of pWal->hdr.aFrameCksum */†Ÿ!  assert( pWal->bShmUnreliable );Ÿ,  assert( pWal->readOnly & WAL_SHM_RDONLY );Ÿ1  assert( pWal->nWiData>0 && pWal->apWiData[0] );†ŸA  /* Take WAL_READ_LOCK(0). This has the effect of preventing anyŸ>  ** writers from running a checkpoint, but does not stop themø  ** from running recovery.  */Ÿ-  rc = walLockShared(pWal, WAL_READ_LOCK(0));∂  if( rc!=SQLITE_OK ){Ÿ)    if( rc==SQLITE_BUSY ) rc = WAL_RETRY;Ÿ"    goto begin_unreliable_shm_out;£  }µ  pWal->readLock = 0;†ŸN  /* Check to see if a separate writer has attached to the shared-memory area,ŸI  ** thus making the shared-memory "reliable" again.  Do this by invokingŸF  ** the xShmMap() routine of the VFS and looking to see if the returnŸ<  ** is SQLITE_READONLY instead of SQLITE_READONLY_CANTINIT.§  **ŸH  ** If the shared-memory is now "reliable" return WAL_RETRY, which willŸC  ** cause the heap-memory WAL-index to be discarded and the actualŸ+  ** shared memory to be used in its place.§  **ŸK  ** This step is important because, even though this connection is holdingŸE  ** the WAL_READ_LOCK(0) which prevents a checkpoint, a writer mightŸB  ** have already checkpointed the WAL file and, while the currentŸC  ** is active, wrap the WAL and start overwriting frames that this∫  ** process wants to use.§  **ŸG  ** Once sqlite3OsShmMap() has been called for an sqlite3_file and hasŸL  ** returned any SQLITE_READONLY value, it must return only SQLITE_READONLYŸN  ** or SQLITE_READONLY_CANTINIT or some error for all subsequent invocations,ŸI  ** even if some external agent does a "chmod" to make the shared-memoryŸ?  ** writable by us, until sqlite3OsShmUnmap() has been called.Ÿ5  ** This is a requirement on the VFS implementation.•   */ŸB  rc = sqlite3OsShmMap(pWal->pDbFd, 0, WALINDEX_PGSZ, 0, &pDummy);ŸP  assert( rc!=SQLITE_OK ); /* SQLITE_OK not possible for read-only connection */Ÿ%  if( rc!=SQLITE_READONLY_CANTINIT ){Ÿ0    rc = (rc==SQLITE_READONLY ? WAL_RETRY : rc);Ÿ"    goto begin_unreliable_shm_out;£  }†ŸL  /* We reach this point only if the real shared-memory is still unreliable.ŸE  ** Assume the in-memory WAL-index substitute is correct and load it¥  ** into pWal->hdr.§  */ŸD  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));†ŸF  /* Make sure some writer hasn't come in and changed the WAL file outŸA  ** from under us, then disconnected, while we were not looking.§  */Ÿ/  rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);∂  if( rc!=SQLITE_OK ){Ÿ"    goto begin_unreliable_shm_out;£  }∫  if( szWal<WAL_HDRSIZE ){ŸC    /* If the wal file is too small to contain a wal-header and theŸG    ** wal-index header has mxFrame==0, then it must be safe to proceedŸE    ** reading the database file only. However, the page cache cannotŸI    ** be trusted, as a read/write connection may have connected, writtenŸH    ** the db, run a checkpoint, truncated the wal file and disconnectedŸ5    ** since this client's last read transaction.  */≤    *pChanged = 1;Ÿ8    rc = (pWal->hdr.mxFrame==0 ? SQLITE_OK : WAL_RETRY);Ÿ"    goto begin_unreliable_shm_out;£  }†ŸE  /* Check the salt keys at the start of the wal file still match. */Ÿ9  rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);∂  if( rc!=SQLITE_OK ){Ÿ"    goto begin_unreliable_shm_out;£  }Ÿ/  if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){ŸF    /* Some writer has wrapped the WAL file while we were not looking.ŸF    ** Return WAL_RETRY which will cause the in-memory WAL-index to be≤    ** rebuilt. */≥    rc = WAL_RETRY;Ÿ"    goto begin_unreliable_shm_out;£  }†Ÿ-  /* Allocate a buffer to read frames into */Ÿ1  szFrame = pWal->hdr.szPage + WAL_FRAME_HDRSIZE;Ÿ+  aFrame = (u8 *)sqlite3_malloc64(szFrame);≤  if( aFrame==0 ){ª    rc = SQLITE_NOMEM_BKPT;Ÿ"    goto begin_unreliable_shm_out;£  }Ÿ%  aData = &aFrame[WAL_FRAME_HDRSIZE];†ŸD  /* Check to see if a complete transaction has been appended to theŸE  ** wal file since the heap-memory wal-index was created. If so, theŸA  ** heap-memory wal-index is discarded and WAL_RETRY returned to¥  ** the caller.  */Ÿ+  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];Ÿ+  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];ŸE  for(iOffset=walFrameOffset(pWal->hdr.mxFrame+1, pWal->hdr.szPage); æ      iOffset+szFrame<=szWal; ∂      iOffset+=szFrame§  ){ŸD    u32 pgno;                   /* Database page number for frame */ŸD    u32 nTruncate;              /* dbsize field from frame header */†Ÿ-    /* Read and decode the next log frame. */Ÿ?    rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);æ    if( rc!=SQLITE_OK ) break;ŸH    if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break;†ŸE    /* If nTruncate is non-zero, then a complete transaction has beenŸF    ** appended to this wal file. Set rc to WAL_RETRY and break out of¥    ** the loop.  */¥    if( nTruncate ){µ      rc = WAL_RETRY;¨      break;•    }£  }Ÿ+  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];Ÿ+  pWal->hdr.aFrameCksum[1] = aSaveCksum[1];†∫ begin_unreliable_shm_out:∑  sqlite3_free(aFrame);∂  if( rc!=SQLITE_OK ){™    int i;Ÿ#    for(i=0; i<pWal->nWiData; i++){Ÿ-      sqlite3_free((void*)pWal->apWiData[i]);º      pWal->apWiData[i] = 0;•    }Ω    pWal->bShmUnreliable = 0;Ÿ'    sqlite3WalEndReadTransaction(pWal);≤    *pChanged = 1;£  }¨  return rc;°}†¢/*ŸI** Attempt to start a read transaction.  This might fail due to a race orŸI** other transient condition.  When that happens, it returns WAL_RETRY toŸ?** indicate to the caller that it is safe to retry immediately.¢**Ÿ@** On success return SQLITE_OK.  On a permanent failure (such anŸA** I/O error or an SQLITE_BUSY because another process is runningŸ*** recovery) return a positive error code.¢**ŸG** The useWal parameter is true to force the use of the WAL and disableŸD** the case where the WAL is bypassed because it has been completelyŸI** checkpointed.  If useWal==0 then this routine calls walIndexReadHdr() ŸB** to make a copy of the wal-index header into pWal->hdr.  If the ŸI** wal-index header has changed, *pChanged is set to 1 (as an indication ŸG** to the caller that the local page cache is obsolete and needs to be ŸH** flushed.)  When useWal==1, the wal-index header is assumed to alreadyŸ2** be loaded and the pChanged parameter is unused.¢**ŸH** The caller must set the cnt parameter to the number of prior calls toŸH** this routine during the current read attempt that returned WAL_RETRY.ŸG** This routine will start taking more aggressive measures to clear theŸK** race conditions after multiple WAL_RETRY returns, and after an excessiveŸ@** number of errors will ultimately return SQLITE_PROTOCOL.  TheŸJ** SQLITE_PROTOCOL return indicates that some other process has gone rogueŸJ** and is not honoring the locking protocol.  There is a vanishingly smallŸK** chance that SQLITE_PROTOCOL could be returned because of a run of reallyŸH** bad luck when there is lots of contention for the wal-index, but thatŸG** possibility is so small that it can be safely neglected, we believe.¢**Ÿ3** On success, this routine obtains a read lock on Ÿ@** WAL_READ_LOCK(pWal->readLock).  The pWal->readLock integer isŸK** in the range 0 <= pWal->readLock < WAL_NREADER.  If pWal->readLock==(-1)ŸG** that means the Wal does not hold any read lock.  The reader must notŸE** access any database page that is modified by a WAL frame up to andŸE** including frame number aReadMark[pWal->readLock].  The reader willŸK** use WAL frames up to and including pWal->hdr.mxFrame if pWal->readLock>0Ÿ?** Or if pWal->readLock==0, then the reader will ignore the WALŸB** completely and get all content directly from the database file.ŸF** If the useWal parameter is 1 then the WAL will never be ignored andŸ<** this routine will always set pWal->readLock>0 on success.ŸF** When the read transaction is completed, the caller must release theŸF** lock on WAL_READ_LOCK(pWal->readLock) and set pWal->readLock to -1.¢**ŸG** This routine uses the nBackfill and aReadMark[] fields of the headerŸA** to select a particular WAL_READ_LOCK() that strives to let theŸF** checkpoint process do as much work as possible.  This routine mightŸG** update values of the aReadMark[] array in the header, but if it doesŸB** so it takes care to hold an exclusive lock on the correspondingŸ)** WAL_READ_LOCK() while changing values.¢*/ŸJstatic int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){ŸK  volatile WalCkptInfo *pInfo;    /* Checkpoint information in wal-index */ŸA  u32 mxReadMark;                 /* Largest aReadMark[] value */ŸJ  int mxI;                        /* Index of largest aReadMark[] value */Ÿ4  int i;                          /* Loop counter */Ÿ4  int rc = SQLITE_OK;             /* Return code  */Ÿ<  u32 mxFrame;                    /* Wal frame to lock to */†Ÿ<  assert( pWal->readLock<0 );     /* Not currently locked */†Ÿ9  /* useWal may only be set for read/write connections */Ÿ>  assert( (pWal->readOnly & WAL_SHM_RDONLY)==0 || useWal==0 );†ŸG  /* Take steps to avoid spinning forever if there is a protocol error.§  **ŸG  ** Circumstances that cause a RETRY should only last for the briefestŸH  ** instances of time.  No I/O or other system calls are done while theŸH  ** locks are held, so the locks should not be held for very long. But ŸH  ** if we are unlucky, another process that is holding a lock might getŸG  ** paged out or take a page-fault that is time-consuming to resolve, ŸK  ** during the few nanoseconds that it is holding the lock.  In that case,Ÿ;  ** it might take longer than normal for the lock to free.§  **ŸF  ** After 5 RETRYs, we begin calling sqlite3OsSleep().  The first fewŸJ  ** calls to sqlite3OsSleep() have a delay of 1 microsecond.  Really thisŸH  ** is more of a scheduler yield than an actual delay.  But on the 10thŸI  ** an subsequent retries, the delays start becoming longer and longer, ŸI  ** so that on the 100th (and last) RETRY we delay for 323 milliseconds.ŸC  ** The total delay time before giving up is less than 10 seconds.§  */Æ  if( cnt>5 ){ŸI    int nDelay = 1;                      /* Pause time in microseconds */≤    if( cnt>100 ){Ÿ&      VVA_ONLY( pWal->lockError = 1; )Ω      return SQLITE_PROTOCOL;•    }Ÿ.    if( cnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;Ÿ'    sqlite3OsSleep(pWal->pVfs, nDelay);£  }†∞  if( !useWal ){º    assert( rc==SQLITE_OK );Ÿ"    if( pWal->bShmUnreliable==0 ){Ÿ+      rc = walIndexReadHdr(pWal, pChanged);•    }∫    if( rc==SQLITE_BUSY ){ŸH      /* If there is not a recovery running in another thread or processŸH      ** then convert BUSY errors to WAL_RETRY.  If recovery is known toŸI      ** be running, convert BUSY to BUSY_RECOVERY.  There is a race hereŸI      ** which might cause WAL_RETRY to be returned even if BUSY_RECOVERYŸI      ** would be technically correct.  But the race is benign since withŸI      ** WAL_RETRY this routine will be called again and will probably beŸ'      ** right on the second iteration.®      */Ÿ!      if( pWal->apWiData[0]==0 ){ŸN        /* This branch is taken when the xShmMap() method returns SQLITE_BUSY.ŸL        ** We assume this is a transient condition, so return WAL_RETRY. TheŸK        ** xShmMap() implementation used by the default unix and win32 VFS ŸI        ** modules may return SQLITE_BUSY due to a race condition in the ŸH        ** code that determines whether or not the shared-memory region Ÿ@        ** must be zeroed before the requested page is returned.™        */∑        rc = WAL_RETRY;ŸJ      }else if( SQLITE_OK==(rc = walLockShared(pWal, WAL_RECOVER_LOCK)) ){Ÿ0        walUnlockShared(pWal, WAL_RECOVER_LOCK);∑        rc = WAL_RETRY;Ÿ"      }else if( rc==SQLITE_BUSY ){Ÿ"        rc = SQLITE_BUSY_RECOVERY;ß      }•    }∏    if( rc!=SQLITE_OK ){∞      return rc;•    }Ÿ$    else if( pWal->bShmUnreliable ){Ÿ3      return walBeginShmUnreliable(pWal, pChanged);•    }£  }†º  assert( pWal->nWiData>0 );Ÿ!  assert( pWal->apWiData[0]!=0 );º  pInfo = walCkptInfo(pWal);Ÿ4  if( !useWal && pInfo->nBackfill==pWal->hdr.mxFrameΩ#ifdef SQLITE_ENABLE_SNAPSHOTŸ2   && (pWal->pSnapshot==0 || pWal->hdr.mxFrame==0)¶#endif§  ){Ÿ?    /* The WAL has been completely backfilled (or it is empty).Ÿ!    ** and can be safely ignored.¶    */Ÿ/    rc = walLockShared(pWal, WAL_READ_LOCK(0));∏    walShmBarrier(pWal);∏    if( rc==SQLITE_OK ){ŸO      if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){ŸH        /* It is not safe to allow the reader to continue here if framesŸN        ** may have been appended to the log before READ_LOCK(0) was obtained.ŸM        ** When holding READ_LOCK(0), the reader ignores the entire log file,ŸF        ** which implies that the database file contains a trustworthyŸJ        ** snapshot. Since holding READ_LOCK(0) prevents a checkpoint fromŸ.        ** happening, this is usually correct.™        **ŸK        ** However, if frames have been appended to the log (or if the log ŸJ        ** is wrapped and written for that matter) before the READ_LOCK(0)ŸH        ** is obtained, that is not necessarily true. A checkpointer mayŸJ        ** have started to backfill the appended frames but crashed beforeŸE        ** it finished. Leaving a corrupt image in the database file.™        */Ÿ0        walUnlockShared(pWal, WAL_READ_LOCK(0));π        return WAL_RETRY;ß      }π      pWal->readLock = 0;∑      return SQLITE_OK;Ÿ     }else if( rc!=SQLITE_BUSY ){∞      return rc;•    }£  }†ŸB  /* If we get this far, it means that the reader will want to useŸC  ** the WAL to get at content from recent commits.  The job now isŸ@  ** to select one of the aReadMark[] entries that is closest toŸ=  ** but not exceeding pWal->hdr.mxFrame and lock that entry.§  */±  mxReadMark = 0;™  mxI = 0;æ  mxFrame = pWal->hdr.mxFrame;Ω#ifdef SQLITE_ENABLE_SNAPSHOTŸ<  if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){Ÿ'    mxFrame = pWal->pSnapshot->mxFrame;£  }¶#endifø  for(i=1; i<WAL_NREADER; i++){Ÿ'    u32 thisMark = pInfo->aReadMark[i];Ÿ4    if( mxReadMark<=thisMark && thisMark<=mxFrame ){Ÿ,      assert( thisMark!=READMARK_NOT_USED );º      mxReadMark = thisMark;Æ      mxI = i;•    }£  }Ÿ*  if( (pWal->readOnly & WAL_SHM_RDONLY)==0Ÿ$   && (mxReadMark<mxFrame || mxI==0)§  ){Ÿ!    for(i=1; i<WAL_NREADER; i++){Ÿ7      rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);∫      if( rc==SQLITE_OK ){Ÿ3        mxReadMark = pInfo->aReadMark[i] = mxFrame;∞        mxI = i;Ÿ6        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);Æ        break;Ÿ"      }else if( rc!=SQLITE_BUSY ){≤        return rc;ß      }•    }£  }Ø  if( mxI==0 ){ŸF    assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );ŸB    return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;£  }†Ÿ/  rc = walLockShared(pWal, WAL_READ_LOCK(mxI));´  if( rc ){Ÿ,    return rc==SQLITE_BUSY ? WAL_RETRY : rc;£  }ŸE  /* Now that the read-lock has been obtained, check that neither theŸD  ** value in the aReadMark[] array or the contents of the wal-indexπ  ** header have changed.§  **ŸF  ** It is necessary to check that the wal-index header did not changeŸG  ** between the time it was read and when the shared-lock was obtainedŸF  ** on WAL_READ_LOCK(mxI) was obtained to account for the possibilityŸH  ** that the log file may have been wrapped by a writer, or that framesŸE  ** that occur later in the log than pWal->hdr.mxFrame may have beenŸJ  ** copied into the database by a checkpointer. If either of these thingsŸB  ** happened, then reading the database with the current value ofŸD  ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry≠  ** instead.§  **ŸC  ** Before checking that the live wal-index header has not changedŸF  ** since it was read, set Wal.minFrame to the first frame in the walŸG  ** file that has not yet been checkpointed. This client will not needŸF  ** to read any frames earlier than minFrame from the wal file - theyŸ8  ** can be safely read directly from the database file.§  **ŸD  ** Because a ShmBarrier() call is made between taking the copy of ŸF  ** nBackfill and checking that the wal-header in shared-memory stillŸD  ** matches the one cached in pWal->hdr, it is guaranteed that the ŸE  ** checkpointer that set nBackfill was not working with a wal-indexŸG  ** header newer than that cached in pWal->hdr. If it were, that couldŸ?  ** cause a problem. The checkpointer could omit to checkpointŸK  ** a version of page X that lies before pWal->minFrame (call that versionŸJ  ** A) on the basis that there is a newer version (version B) of the sameŸF  ** page later in the wal file. But if version B happens to like pastŸG  ** frame pWal->hdr.mxFrame - then the client would incorrectly assumeŸF  ** that it can read version A from the database file. However, sinceŸH  ** we can guarantee that the checkpointer that set nBackfill could notŸI  ** see any pages past pWal->hdr.mxFrame, this problem does not come up.§  */Ÿ&  pWal->minFrame = pInfo->nBackfill+1;∂  walShmBarrier(pWal);Ÿ'  if( pInfo->aReadMark[mxI]!=mxReadMarkŸH   || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))§  ){Ÿ.    walUnlockShared(pWal, WAL_READ_LOCK(mxI));µ    return WAL_RETRY;®  }else{Ÿ,    assert( mxReadMark<=pWal->hdr.mxFrame );æ    pWal->readLock = (i16)mxI;£  }¨  return rc;°}†Ω#ifdef SQLITE_ENABLE_SNAPSHOT¢/*ŸE** Attempt to reduce the value of the WalCkptInfo.nBackfillAttempted ŸE** variable so that older snapshots can be accessed. To do this, loopŸD** through all wal frames from nBackfillAttempted to (nBackfill+1), ŸF** comparing their content to the corresponding page with the databaseŸB** file, if any. Set nBackfillAttempted to the frame number of theŸB** first frame for which the wal file content matches the db file.¢**ŸE** This is only really safe if the file-system is such that any page ŸF** writes made by earlier checkpointers were atomic operations, which ŸB** is not always true. It is also possible that nBackfillAttemptedŸB** may be left set to a value larger than expected, if a wal frameŸD** contains content that duplicate of an earlier version of the same®** page.¢**ŸE** SQLITE_OK is returned if successful, or an SQLite error code if anŸC** error occurs. It is not an error if nBackfillAttempted cannot be¥** decreased at all.¢*/Ÿ8SQLITE_PRIVATE int sqlite3WalSnapshotRecover(Wal *pWal){©  int rc;†æ  assert( pWal->readLock>=0 );Ÿ0  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);∂  if( rc==SQLITE_OK ){Ÿ4    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);Ÿ#    int szPage = (int)pWal->szPage;Ÿ>    i64 szDb;                   /* Size of db file in bytes */†Ÿ/    rc = sqlite3OsFileSize(pWal->pDbFd, &szDb);∏    if( rc==SQLITE_OK ){Ÿ+      void *pBuf1 = sqlite3_malloc(szPage);Ÿ+      void *pBuf2 = sqlite3_malloc(szPage);Ÿ!      if( pBuf1==0 || pBuf2==0 ){∫        rc = SQLITE_NOMEM;¨      }else{Ÿ*        u32 i = pInfo->nBackfillAttempted;ŸB        for(i=pInfo->nBackfillAttempted; i>pInfo->nBackfill; i--){Ÿ"          volatile ht_slot *dummy;Ÿ?          volatile u32 *aPgno;      /* Array of page numbers */ŸI          u32 iZero;                /* Frame corresponding to aPgno[0] */Ÿ@          u32 pgno;                 /* Page number in db file */ŸA          i64 iDbOff;               /* Offset of db file entry */ŸB          i64 iWalOff;              /* Offset of wal file entry */†ŸI          rc = walHashGet(pWal, walFramePage(i), &dummy, &aPgno, &iZero);Ÿ$          if( rc!=SQLITE_OK ) break;Ÿ           pgno = aPgno[i-iZero];Ÿ*          iDbOff = (i64)(pgno-1) * szPage;†Ÿ$          if( iDbOff+szPage<=szDb ){ŸD            iWalOff = walFrameOffset(i, szPage) + WAL_FRAME_HDRSIZE;ŸE            rc = sqlite3OsRead(pWal->pWalFd, pBuf1, szPage, iWalOff);†Ÿ             if( rc==SQLITE_OK ){ŸE              rc = sqlite3OsRead(pWal->pDbFd, pBuf2, szPage, iDbOff);≠            }†ŸC            if( rc!=SQLITE_OK || 0==memcmp(pBuf1, pBuf2, szPage) ){¥              break;≠            }´          }†Ÿ*          pInfo->nBackfillAttempted = i-1;©        }ß      }†∫      sqlite3_free(pBuf1);∫      sqlite3_free(pBuf2);•    }Ÿ/    walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);£  }†¨  return rc;°}Ÿ##endif /* SQLITE_ENABLE_SNAPSHOT */†¢/*Ÿ,** Begin a read transaction on the database.¢**ŸM** This routine used to be called sqlite3OpenSnapshot() and with good reason:ŸL** it takes a snapshot of the state of the WAL and wal-index for the currentŸK** instant in time.  The current thread will continue to use this snapshot.ŸF** Other threads might append new content to the WAL and wal-index butŸ7** that extra content is ignored by the current thread.¢**Ÿ@** If the database contents have changes since the previous readŸA** transaction, then *pChanged is set to 1 before returning.  TheŸ?** Pager layer will use this to know that is cache is stale and∑** needs to be flushed.¢*/ŸLSQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){Ÿ3  int rc;                         /* Return code */ŸG  int cnt = 0;                    /* Number of TryBeginRead attempts */†Ω#ifdef SQLITE_ENABLE_SNAPSHOT≥  int bChanged = 0;Ÿ+  WalIndexHdr *pSnapshot = pWal->pSnapshot;ŸK  if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){±    bChanged = 1;£  }¶#endif†•  do{Ÿ3    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);∫  }while( rc==WAL_RETRY );Ÿ%  testcase( (rc&0xff)==SQLITE_BUSY );Ÿ&  testcase( (rc&0xff)==SQLITE_IOERR );Ÿ"  testcase( rc==SQLITE_PROTOCOL );º  testcase( rc==SQLITE_OK );†Ω#ifdef SQLITE_ENABLE_SNAPSHOT∂  if( rc==SQLITE_OK ){ŸM    if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){ŸK      /* At this point the client has a lock on an aReadMark[] slot holdingŸK      ** a value equal to or smaller than pSnapshot->mxFrame, but pWal->hdrŸI      ** is populated with the wal-index header corresponding to the headŸE      ** of the wal file. Verify that pSnapshot is still valid beforeŸE      ** continuing.  Reasons why pSnapshot might no longer be valid:®      **ŸJ      **    (1)  The WAL file has been reset since the snapshot was taken.Ÿ:      **         In this case, the salt will have changed.®      **ŸF      **    (2)  A checkpoint as been attempted that wrote frames pastŸJ      **         pSnapshot->mxFrame into the database file.  Note that theŸO      **         checkpoint need not have completed for this to cause problems.®      */Ÿ6      volatile WalCkptInfo *pInfo = walCkptInfo(pWal);†Ÿ9      assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );ŸE      assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame );†ŸD      /* It is possible that there is a checkpointer thread running ŸK      ** concurrent with this code. If this is the case, it may be that theŸE      ** checkpointer has already determined that it will checkpoint ŸJ      ** snapshot X, where X is later in the wal file than pSnapshot, but ŸL      ** has not yet set the pInfo->nBackfillAttempted variable to indicate ŸK      ** its intent. To avoid the race condition this leads to, ensure thatŸG      ** there is no checkpointer process by taking a shared CKPT lock Ÿ5      ** before checking pInfo->nBackfillAttempted.  ®      **ŸJ      ** TODO: Does the aReadMark[] lock prevent a checkpointer from doingº      **       this already?®      */Ÿ.      rc = walLockShared(pWal, WAL_CKPT_LOCK);†∫      if( rc==SQLITE_OK ){ŸM        /* Check that the wal file has not been wrapped. Assuming that it hasŸO        ** not, also check that no checkpointer has attempted to checkpoint anyŸN        ** frames beyond pSnapshot->mxFrame. If either of these conditions areŸL        ** true, return SQLITE_BUSY_SNAPSHOT. Otherwise, overwrite pWal->hdrŸK        ** with *pSnapshot and set *pChanged as appropriate for opening the∏        ** snapshot.  */ŸO        if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))Ÿ9         && pSnapshot->mxFrame>=pInfo->nBackfillAttempted™        ){Ÿ%          assert( pWal->readLock>0 );Ÿ=          memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));ø          *pChanged = bChanged;Æ        }else{Ÿ$          rc = SQLITE_BUSY_SNAPSHOT;©        }†Ÿ:        /* Release the shared CKPT lock obtained above. */Ÿ-        walUnlockShared(pWal, WAL_CKPT_LOCK);ß      }††∫      if( rc!=SQLITE_OK ){Ÿ+        sqlite3WalEndReadTransaction(pWal);ß      }•    }£  }¶#endif¨  return rc;°}†¢/*Ÿ@** Finish with a read transaction.  All this does is release the≠** read-lock.¢*/Ÿ<SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal){Ÿ&  sqlite3WalEndWriteTransaction(pWal);∫  if( pWal->readLock>=0 ){Ÿ9    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));∏    pWal->readLock = -1;£  }°}†¢/*ŸM** Search the wal file for page pgno. If found, set *piRead to the frame thatŸL** contains the page. Otherwise, if pgno is not in the wal file, set *piRead´** to zero.¢**ŸM** Return SQLITE_OK if successful, or an error code if an error occurs. If anŸ=** error does occur, the final value of *piRead is undefined.¢*/Ÿ'SQLITE_PRIVATE int sqlite3WalFindFrame(Ÿ2  Wal *pWal,                      /* WAL handle */ŸM  Pgno pgno,                      /* Database page number to read data for */ŸC  u32 *piRead                     /* OUT: Frame number (or zero) */¢){ŸM  u32 iRead = 0;                  /* If !=0, WAL frame to return data from */ŸH  u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */ŸJ  int iHash;                      /* Used to loop through N hash tables */Ø  int iMinHash;†ŸF  /* This routine is only be called from within a read transaction. */Ÿ1  assert( pWal->readLock>=0 || pWal->lockError );†ŸI  /* If the "last page" field of the wal-index header snapshot is 0, thenŸL  ** no data will be read from the wal under any circumstances. Return earlyŸG  ** in this case as an optimization.  Likewise, if pWal->readLock==0, ŸF  ** then the WAL is ignored by the reader so return early, as if the ¥  ** WAL were empty.§  */ŸC  if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){∞    *piRead = 0;µ    return SQLITE_OK;£  }†ŸF  /* Search the hash table or tables for an entry matching page numberŸB  ** pgno. Each iteration of the following for() loop searches oneŸG  ** hash table (each hash table indexes up to HASHTABLE_NPAGE frames).§  **ŸE  ** This code might run concurrently to the code in walIndexAppend()ŸC  ** that adds entries to the wal-index (and possibly to this hash Ÿ:  ** table). This means the value just read from the hash Ÿ@  ** slot (aHash[iKey]) may have been added before or after the Ÿ@  ** current read transaction was opened. Values added after theŸD  ** read transaction was opened may have been written incorrectly -ŸB  ** i.e. these slots may contain garbage data. However, we assumeŸC  ** that any slots written before the current read transaction wasæ  ** opened remain unmodified.§  **ŸG  ** For the reasons above, the if(...) condition featured in the innerŸJ  ** loop of the following block is more stringent that would be required Ÿ2  ** if we had exclusive access to the hash-table:§  **æ  **   (aPgno[iFrame]==pgno): ŸA  **     This condition filters out normal hash-table collisions.§  **∏  **   (iFrame<=iLast): ŸG  **     This condition filters out entries that were added to the hashŸ>  **     table after the current read-transaction had started.§  */Ÿ*  iMinHash = walFramePage(pWal->minFrame);Ÿ;  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){Ÿ=    volatile ht_slot *aHash;      /* Pointer to hash table */ŸH    volatile u32 *aPgno;          /* Pointer to array of page numbers */ŸN    u32 iZero;                    /* Frame number corresponding to aPgno[0] */Ÿ7    int iKey;                     /* Hash slot index */ŸK    int nCollide;                 /* Number of hash collisions remaining */Ÿ2    int rc;                       /* Error code */†Ÿ9    rc = walHashGet(pWal, iHash, &aHash, &aPgno, &iZero);∏    if( rc!=SQLITE_OK ){∞      return rc;•    }ø    nCollide = HASHTABLE_NSLOT;ŸA    for(iKey=walHash(pgno); aHash[iKey]; iKey=walNextHash(iKey)){Ÿ'      u32 iFrame = aHash[iKey] + iZero;ŸP      if( iFrame<=iLast && iFrame>=pWal->minFrame && aPgno[aHash[iKey]]==pgno ){Ÿ-        assert( iFrame>iRead || CORRUPT_DB );∑        iRead = iFrame;ß      }º      if( (nCollide--)==0 ){Ÿ#        return SQLITE_CORRUPT_BKPT;ß      }•    }∂    if( iRead ) break;£  }†Ÿ%#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERTŸG  /* If expensive assert() statements are available, do a linear searchŸH  ** of the wal-index file content. Make sure the results agree with theŸ6  ** result obtained using the hash indexes above.  */£  {≥    u32 iRead2 = 0;Æ    u32 iTest;Ÿ7    assert( pWal->bShmUnreliable || pWal->minFrame>0 );Ÿ@    for(iTest=iLast; iTest>=pWal->minFrame && iTest>0; iTest--){Ÿ,      if( walFramePgno(pWal, iTest)==pgno ){∑        iRead2 = iTest;Æ        break;ß      }•    }º    assert( iRead==iRead2 );£  }¶#endif†≤  *piRead = iRead;≥  return SQLITE_OK;°}†¢/*ŸF** Read the contents of frame iRead from the wal file into buffer pOutŸG** (which is nOut bytes in size). Return SQLITE_OK if successful, or an∏** error code otherwise.¢*/Ÿ'SQLITE_PRIVATE int sqlite3WalReadFrame(Ÿ2  Wal *pWal,                      /* WAL handle */Ÿ5  u32 iRead,                      /* Frame to read */ŸD  int nOut,                       /* Size of buffer pOut in bytes */ŸD  u8 *pOut                        /* Buffer to write page data to */¢){©  int sz;Æ  i64 iOffset;∏  sz = pWal->hdr.szPage;Ÿ'  sz = (sz&0xfe00) + ((sz&0x0001)<<16);∏  testcase( sz<=32768 );∏  testcase( sz>=65536 );Ÿ:  iOffset = walFrameOffset(iRead, sz) + WAL_FRAME_HDRSIZE;Ÿ?  /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */ŸK  return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset);°}†£/* ŸB** Return the size of the database in pages (or zero, if unknown).¢*/Ÿ0SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal){Ÿ*  if( pWal && ALWAYS(pWal->readLock>=0) ){ª    return pWal->hdr.nPage;£  }´  return 0;°}††£/* Ÿ7** This function starts a write transaction on the WAL.¢**ŸD** A read transaction must have already been started by a prior callŸ'** to sqlite3WalBeginReadTransaction().¢**ŸC** If another thread or process has written into the database sinceŸE** the read transaction was started, then it is not possible for thisŸC** thread to write as doing so would cause a fork.  So this routineŸH** returns SQLITE_BUSY in that case and no write transaction is started.¢**Ÿ6** There can only be a single writer active at a time.¢*/Ÿ>SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){©  int rc;†ŸB  /* Cannot start a write transaction without first holding a read¥  ** transaction. */æ  assert( pWal->readLock>=0 );Ÿ4  assert( pWal->writeLock==0 && pWal->iReCksum==0 );†∑  if( pWal->readOnly ){ª    return SQLITE_READONLY;£  }†ŸD  /* Only one writer allowed at a time.  Get the write lock.  Returnª  ** SQLITE_BUSY if unable.§  */Ÿ1  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);´  if( rc ){Æ    return rc;£  }∂  pWal->writeLock = 1;†ŸE  /* If another connection has written to the database file since theŸC  ** time the read transaction on this connection was started, thenΩ  ** the write is disallowed.§  */ŸN  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){Ÿ0    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);∏    pWal->writeLock = 0;æ    rc = SQLITE_BUSY_SNAPSHOT;£  }†¨  return rc;°}†¢/*ŸD** End a write transaction.  The commit has already been done.  ThisŸ$** routine merely releases the lock.¢*/Ÿ<SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal){∏  if( pWal->writeLock ){Ÿ0    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);∏    pWal->writeLock = 0;∑    pWal->iReCksum = 0;ø    pWal->truncateOnCommit = 0;£  }≥  return SQLITE_OK;°}†¢/*ŸI** If any data has been written (but not committed) to the log file, thisŸI** function moves the write-pointer back to the start of the transaction.¢**ŸH** Additionally, the callback function is invoked for each frame writtenŸI** to the WAL since the start of the transaction. If the callback returnsŸF** other than SQLITE_OK, it is not invoked again and the error code is∫** returned to the caller.¢**ŸE** Otherwise, if the callback function does not return an error, thisæ** function returns SQLITE_OK.¢*/ŸYSQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){µ  int rc = SQLITE_OK;Ÿ   if( ALWAYS(pWal->writeLock) ){Ÿ"    Pgno iMax = pWal->hdr.mxFrame;∞    Pgno iFrame;¢  ŸH    /* Restore the clients cache of the wal-index header to the state itŸ?    ** was in before the client began writing to the database. ¶    */ŸG    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));†Ÿ$    for(iFrame=pWal->hdr.mxFrame+1; Ÿ/        ALWAYS(rc==SQLITE_OK) && iFrame<=iMax; ∞        iFrame++¶    ){ŸI      /* This call cannot fail. Unless the page for which the page numberŸB      ** is passed as the second argument is (a) in the cache and ŸG      ** (b) has an outstanding reference, then xUndo is either a no-opŸK      ** (if (a) is false) or simply expels the page from the cache (if (b)≥      ** is false).®      **ŸL      ** If the upper layer is doing a rollback, it is guaranteed that thereŸI      ** are no outstanding references to any page other than page 1. AndŸD      ** page 1 is never written to the log until the transaction isŸ@      ** committed. As a result, the call to xUndo may not fail.®      */Ÿ.      assert( walFramePgno(pWal, iFrame)!=1 );Ÿ7      rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));•    }Ÿ7    if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);£  }¨  return rc;°}†£/* ŸG** Argument aWalData must point to an array of WAL_SAVEPOINT_NDATA u32 ŸE** values. This function populates the array with values required to ŸG** "rollback" the write position of the WAL handle back to the current ŸG** point in the event of a savepoint rollback (via WalSavepointUndo()).¢*/ŸBSQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){º  assert( pWal->writeLock );Ÿ"  aWalData[0] = pWal->hdr.mxFrame;Ÿ)  aWalData[1] = pWal->hdr.aFrameCksum[0];Ÿ)  aWalData[2] = pWal->hdr.aFrameCksum[1];º  aWalData[3] = pWal->nCkpt;°}†£/* ŸE** Move the write position of the WAL back to the point identified byŸF** the values in the aWalData[] array. aWalData must point to an arrayŸG** of WAL_SAVEPOINT_NDATA u32 values that has been previously populatedø** by a call to WalSavepoint().¢*/ŸESQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){µ  int rc = SQLITE_OK;†º  assert( pWal->writeLock );ŸG  assert( aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame );†Ÿ!  if( aWalData[3]!=pWal->nCkpt ){ŸH    /* This savepoint was opened immediately after the write-transactionŸG    ** was started. Right after that, the writer decided to wrap aroundŸE    ** to the start of the log. Update the savepoint values to match.¶    */¥    aWalData[0] = 0;æ    aWalData[3] = pWal->nCkpt;£  }†Ÿ&  if( aWalData[0]<pWal->hdr.mxFrame ){Ÿ$    pWal->hdr.mxFrame = aWalData[0];Ÿ+    pWal->hdr.aFrameCksum[0] = aWalData[1];Ÿ+    pWal->hdr.aFrameCksum[1] = aWalData[2];π    walCleanupHash(pWal);£  }†¨  return rc;°}†¢/*ŸI** This function is called just before writing a set of frames to the logŸK** file (see sqlite3WalFrames()). It checks to see if, instead of appendingŸH** to the current log file, it is possible to overwrite the start of theŸG** existing log file with the new frames (i.e. "reset" the log). If so,ŸG** it sets pWal->hdr.mxFrame to 0. Otherwise, pWal->hdr.mxFrame is left≠** unchanged.¢**ŸJ** SQLITE_OK is returned if no error is encountered (regardless of whetherŸJ** or not pWal->hdr.mxFrame is modified). An SQLite error code is returned∂** if an error occurs.¢*/Ÿ$static int walRestartLog(Wal *pWal){µ  int rc = SQLITE_OK;™  int cnt;†∫  if( pWal->readLock==0 ){Ÿ4    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);Ÿ2    assert( pInfo->nBackfill==pWal->hdr.mxFrame );Ω    if( pInfo->nBackfill>0 ){∞      u32 salt1;Ÿ$      sqlite3_randomness(4, &salt1);ŸC      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);∫      if( rc==SQLITE_OK ){ŸJ        /* If all readers are using WAL_READ_LOCK(0) (in other words if noŸF        ** readers are currently using the WAL), then the transactionsŸJ        ** frames will overwrite the start of the existing log. Update theŸ,        ** wal-index header to reflect this.™        **ŸJ        ** In theory it would be Ok to update the cache of the header onlyŸJ        ** at this point. But updating the actual wal-index header is alsoŸG        ** safe and means there is no special case for sqlite3WalUndo()Ÿ<        ** to handle if this transaction is rolled back.  */Ÿ#        walRestartHdr(pWal, salt1);ŸB        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);Ÿ"      }else if( rc!=SQLITE_BUSY ){≤        return rc;ß      }•    }Ÿ,    walUnlockShared(pWal, WAL_READ_LOCK(0));∏    pWal->readLock = -1;¨    cnt = 0;ß    do{≤      int notUsed;Ÿ5      rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);º    }while( rc==WAL_RETRY );ŸL    assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */Ÿ(    testcase( (rc&0xff)==SQLITE_IOERR );Ÿ$    testcase( rc==SQLITE_PROTOCOL );æ    testcase( rc==SQLITE_OK );£  }¨  return rc;°}†¢/*Ÿ@** Information about the current state of the WAL file and whereŸD** the next fsync should occur - passed from sqlite3WalFrames() into≥** walWriteToLog().¢*/∫typedef struct WalWriter {ŸA  Wal *pWal;                   /* The complete WAL information */ŸC  sqlite3_file *pFd;           /* The WAL file to which we write */Ÿ9  sqlite3_int64 iSyncPoint;    /* Fsync at this offset */Ÿ8  int syncFlags;               /* Flags for the fsync */Ÿ5  int szPage;                  /* Size of one page */¨} WalWriter;†¢/*ŸF** Write iAmt bytes of content into the WAL file beginning at iOffset.Ÿ6** Do a sync when crossing the p->iSyncPoint boundary.¢**ŸH** In other words, if iSyncPoint is in between iOffset and iOffset+iAmt,ŸD** first write the part before iSyncPoint, then sync, then write the®** rest.¢*/πstatic int walWriteToLog(Ÿ2  WalWriter *p,              /* WAL to write to */Ÿ8  void *pContent,            /* Content to be written */Ÿ;  int iAmt,                  /* Number of bytes to write */Ÿ?  sqlite3_int64 iOffset      /* Start writing at this offset */¢){©  int rc;Ÿ=  if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){Ÿ3    int iFirstAmt = (int)(p->iSyncPoint - iOffset);Ÿ>    rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);∑    if( rc ) return rc;π    iOffset += iFirstAmt;∂    iAmt -= iFirstAmt;Ÿ4    pContent = (void*)(iFirstAmt + (char*)pContent);Ÿ.    assert( WAL_SYNC_FLAGS(p->syncFlags)!=0 );Ÿ=    rc = sqlite3OsSync(p->pFd, WAL_SYNC_FLAGS(p->syncFlags));Ÿ"    if( iAmt==0 || rc ) return rc;£  }Ÿ7  rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);¨  return rc;°}†¢/*Ÿ&** Write out a single frame of the WAL†