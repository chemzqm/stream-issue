Üê` ¶#ifndef USE_LIBSQLITE3ÙO/******************************************************************************ÙK** This file is an amalgamation of many separate C source files from SQLiteÙJ** version 3.23.1.  By combining all the individual C code files into thisÙM** single large file, the entire code can be compiled as a single translationÙJ** unit.  This allows many compilers to do optimizations that would not beÙL** possible if the files were compiled separately.  Performance improvementsÙF** of 5% or more are commonly seen when SQLite is compiled as a single´** translation unit.¢**ÙG** This file is all you need to compile SQLite.  To use SQLite in otherÙL** programs, you need this file and the "sqlite3.h" header file that definesÙH** the programming interface to the SQLite library.  (If you do not haveÙL** the "sqlite3.h" header file at hand, you will find a copy embedded withinÙN** the text of this file.  Search for "Begin file sqlite3.h" to find the startÙN** of the embedded sqlite3.h header file.) Additional code files may be neededÙL** if you want a wrapper to interface SQLite with your choice of programmingÙG** language. The code for the "sqlite3" command-line shell is also in aÙK** separate file. This file contains only code for the core SQLite library.¢*/µ#define SQLITE_CORE 1½#define SQLITE_AMALGAMATION 1¶#ifndef SQLITE_PRIVATE¾# define SQLITE_PRIVATE static¦#endifÙO/************** Begin file ctime.c *******************************************/¢/*³** 2010 February 23¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙI** This file implements routines used to report what compile-time options¹** SQLite was built with.¢*/ Ù'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS ¢/*ÙL** Include the configuration header output by 'configure' if we're using the·** autoconf-based build¢*/Ù>#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)³#include "config.h"¸#define SQLITECONFIG_H 1¦#endif ÙC/* These macros are provided to "stringify" the value of the defineÙ9** for those options in which the value is meaningful. */¿#define CTIMEOPT_VAL_(opt) #optÙ,#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt) ¢/*ÙE** An array of names of all compile-time options.  This array should ±** be sorted A-Z.¢**ÙF** This array looks large, but in a typical installation actually usesÙN** only a handful of compile-time options, so most times this array is usuallyÙ-** rather short and uses little memory space.¢*/Ù3static const char * const sqlite3azCompileOpt[] = { £/* Ù,** BEGIN CODE GENERATED BY tool/mkctime.tcl ¢*/¶#if SQLITE_32BIT_ROWID°  "32BIT_ROWID",¦#endifÙ #if SQLITE_4_BYTE_ALIGNED_MALLOCº  "4_BYTE_ALIGNED_MALLOC",¦#endif¶#if SQLITE_64BIT_STATS°  "64BIT_STATS",¦#endifÙ$#if SQLITE_ALLOW_COVERING_INDEX_SCAN¾  "ALLOW_COVERING_INDEX_SCAN",¦#endif¾#if SQLITE_ALLOW_URI_AUTHORITY¸  "ALLOW_URI_AUTHORITY",¦#endifº#ifdef SQLITE_BITMASK_TYPEÙ4  "BITMASK_TYPE=" CTIMEOPT_VAL(SQLITE_BITMASK_TYPE),¦#endifÙ"#if SQLITE_BUG_COMPATIBLE_20160819¼  "BUG_COMPATIBLE_20160819",¦#endif¾#if SQLITE_CASE_SENSITIVE_LIKE¸  "CASE_SENSITIVE_LIKE",¦#endif¶#if SQLITE_CHECK_PAGES°  "CHECK_PAGES",¦#endifÙ2#if defined(__clang__) && defined(__clang_major__)Ù5  "COMPILER=clang-" CTIMEOPT_VAL(__clang_major__) "."Ù5                    CTIMEOPT_VAL(__clang_minor__) "."Ù7                    CTIMEOPT_VAL(__clang_patchlevel__),·#elif defined(_MSC_VER)Ù*  "COMPILER=msvc-" CTIMEOPT_VAL(_MSC_VER),Ù/#elif defined(__GNUC__) && defined(__VERSION__)¾  "COMPILER=gcc-" __VERSION__,¦#endif¸#if SQLITE_COVERAGE_TEST²  "COVERAGE_TEST",¦#endif°#if SQLITE_DEBUGª  "DEBUG",¦#endifÙ"#if SQLITE_DEFAULT_AUTOMATIC_INDEX¼  "DEFAULT_AUTOMATIC_INDEX",¦#endif½#if SQLITE_DEFAULT_AUTOVACUUM·  "DEFAULT_AUTOVACUUM",¦#endifÙ #ifdef SQLITE_DEFAULT_CACHE_SIZEÙ@  "DEFAULT_CACHE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_CACHE_SIZE),¦#endifÙ #if SQLITE_DEFAULT_CKPTFULLFSYNCº  "DEFAULT_CKPTFULLFSYNC",¦#endifÙ!#ifdef SQLITE_DEFAULT_FILE_FORMATÙB  "DEFAULT_FILE_FORMAT=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_FORMAT),¦#endifÙ&#ifdef SQLITE_DEFAULT_FILE_PERMISSIONSÙL  "DEFAULT_FILE_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_PERMISSIONS),¦#endif¿#if SQLITE_DEFAULT_FOREIGN_KEYS¹  "DEFAULT_FOREIGN_KEYS",¦#endifÙ(#ifdef SQLITE_DEFAULT_JOURNAL_SIZE_LIMITÙP  "DEFAULT_JOURNAL_SIZE_LIMIT=" CTIMEOPT_VAL(SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT),¦#endifÙ"#ifdef SQLITE_DEFAULT_LOCKING_MODEÙD  "DEFAULT_LOCKING_MODE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),¦#endif¿#ifdef SQLITE_DEFAULT_LOOKASIDEÙ>  "DEFAULT_LOOKASIDE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOOKASIDE),¦#endif¼#if SQLITE_DEFAULT_MEMSTATUS¶  "DEFAULT_MEMSTATUS",¦#endif¿#ifdef SQLITE_DEFAULT_MMAP_SIZEÙ>  "DEFAULT_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),¦#endif¿#ifdef SQLITE_DEFAULT_PAGE_SIZEÙ>  "DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_PAGE_SIZE),¦#endifÙ##ifdef SQLITE_DEFAULT_PCACHE_INITSZÙF  "DEFAULT_PCACHE_INITSZ=" CTIMEOPT_VAL(SQLITE_DEFAULT_PCACHE_INITSZ),¦#endifÙ*#ifdef SQLITE_DEFAULT_PROXYDIR_PERMISSIONSÙT  "DEFAULT_PROXYDIR_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_PROXYDIR_PERMISSIONS),¦#endifÙ%#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS¿  "DEFAULT_RECURSIVE_TRIGGERS",¦#endif¼#ifdef SQLITE_DEFAULT_ROWESTÙ8  "DEFAULT_ROWEST=" CTIMEOPT_VAL(SQLITE_DEFAULT_ROWEST),¦#endifÙ!#ifdef SQLITE_DEFAULT_SECTOR_SIZEÙB  "DEFAULT_SECTOR_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_SECTOR_SIZE),¦#endifÙ!#ifdef SQLITE_DEFAULT_SYNCHRONOUSÙB  "DEFAULT_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),¦#endifÙ(#ifdef SQLITE_DEFAULT_WAL_AUTOCHECKPOINTÙP  "DEFAULT_WAL_AUTOCHECKPOINT=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_AUTOCHECKPOINT),¦#endifÙ%#ifdef SQLITE_DEFAULT_WAL_SYNCHRONOUSÙJ  "DEFAULT_WAL_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),¦#endifÙ$#ifdef SQLITE_DEFAULT_WORKER_THREADSÙH  "DEFAULT_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WORKER_THREADS),¦#endif¿#if SQLITE_DIRECT_OVERFLOW_READ¹  "DIRECT_OVERFLOW_READ",¦#endifº#if SQLITE_DISABLE_DIRSYNC´  "DISABLE_DIRSYNC",¦#endif¿#if SQLITE_DISABLE_FTS3_UNICODE¹  "DISABLE_FTS3_UNICODE",¦#endifÙ #if SQLITE_DISABLE_FTS4_DEFERREDº  "DISABLE_FTS4_DEFERRED",¦#endif¼#if SQLITE_DISABLE_INTRINSIC¶  "DISABLE_INTRINSIC",¦#endif¶#if SQLITE_DISABLE_LFS°  "DISABLE_LFS",¦#endifÙ+#if SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATSÙ%  "DISABLE_PAGECACHE_OVERFLOW_STATS",¦#endifÙ%#if SQLITE_DISABLE_SKIPAHEAD_DISTINCT¿  "DISABLE_SKIPAHEAD_DISTINCT",¦#endif¾#ifdef SQLITE_ENABLE_8_3_NAMESÙ<  "ENABLE_8_3_NAMES=" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),¦#endif»#if SQLITE_ENABLE_API_ARMORµ  "ENABLE_API_ARMOR",¦#endif¾#if SQLITE_ENABLE_ATOMIC_WRITE¸  "ENABLE_ATOMIC_WRITE",¦#endifÙ$#if SQLITE_ENABLE_BATCH_ATOMIC_WRITE¾  "ENABLE_BATCH_ATOMIC_WRITE",¦#endif·#if SQLITE_ENABLE_CERODÙ4  "ENABLE_CEROD=" CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),¦#endifÙ!#if SQLITE_ENABLE_COLUMN_METADATA»  "ENABLE_COLUMN_METADATA",¦#endifÙ"#if SQLITE_ENABLE_COLUMN_USED_MASK¼  "ENABLE_COLUMN_USED_MASK",¦#endifº#if SQLITE_ENABLE_COSTMULT´  "ENABLE_COSTMULT",¦#endif¾#if SQLITE_ENABLE_CURSOR_HINTS¸  "ENABLE_CURSOR_HINTS",¦#endif½#if SQLITE_ENABLE_DBSTAT_VTAB·  "ENABLE_DBSTAT_VTAB",¦#endifÙ"#if SQLITE_ENABLE_EXPENSIVE_ASSERT¼  "ENABLE_EXPENSIVE_ASSERT",¦#endif¶#if SQLITE_ENABLE_FTS1°  "ENABLE_FTS1",¦#endif¶#if SQLITE_ENABLE_FTS2°  "ENABLE_FTS2",¦#endif¶#if SQLITE_ENABLE_FTS3°  "ENABLE_FTS3",¦#endifÙ"#if SQLITE_ENABLE_FTS3_PARENTHESIS¼  "ENABLE_FTS3_PARENTHESIS",¦#endifÙ #if SQLITE_ENABLE_FTS3_TOKENIZERº  "ENABLE_FTS3_TOKENIZER",¦#endif¶#if SQLITE_ENABLE_FTS4°  "ENABLE_FTS4",¦#endif¶#if SQLITE_ENABLE_FTS5°  "ENABLE_FTS5",¦#endifÙ #if SQLITE_ENABLE_HIDDEN_COLUMNSº  "ENABLE_HIDDEN_COLUMNS",¦#endifµ#if SQLITE_ENABLE_ICU¯  "ENABLE_ICU",¦#endif¹#if SQLITE_ENABLE_IOTRACE³  "ENABLE_IOTRACE",¦#endif·#if SQLITE_ENABLE_JSON1±  "ENABLE_JSON1",¦#endifÙ #if SQLITE_ENABLE_LOAD_EXTENSIONº  "ENABLE_LOAD_EXTENSION",¦#endifÙ"#ifdef SQLITE_ENABLE_LOCKING_STYLEÙD  "ENABLE_LOCKING_STYLE=" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),¦#endifÙ##if SQLITE_ENABLE_MEMORY_MANAGEMENT½  "ENABLE_MEMORY_MANAGEMENT",¦#endif¹#if SQLITE_ENABLE_MEMSYS3³  "ENABLE_MEMSYS3",¦#endif¹#if SQLITE_ENABLE_MEMSYS5³  "ENABLE_MEMSYS5",¦#endif»#if SQLITE_ENABLE_MULTIPLEXµ  "ENABLE_MULTIPLEX",¦#endif»#if SQLITE_ENABLE_NULL_TRIMµ  "ENABLE_NULL_TRIM",¦#endifÙ%#if SQLITE_ENABLE_OVERSIZE_CELL_CHECK¿  "ENABLE_OVERSIZE_CELL_CHECK",¦#endifÙ #if SQLITE_ENABLE_PREUPDATE_HOOKº  "ENABLE_PREUPDATE_HOOK",¦#endif¶#if SQLITE_ENABLE_QPSG°  "ENABLE_QPSG",¦#endifµ#if SQLITE_ENABLE_RBU¯  "ENABLE_RBU",¦#endif·#if SQLITE_ENABLE_RTREE±  "ENABLE_RTREE",¦#endif½#if SQLITE_ENABLE_SELECTTRACE·  "ENABLE_SELECTTRACE",¦#endif¹#if SQLITE_ENABLE_SESSION³  "ENABLE_SESSION",¦#endifº#if SQLITE_ENABLE_SNAPSHOT´  "ENABLE_SNAPSHOT",¦#endif¸#if SQLITE_ENABLE_SQLLOG²  "ENABLE_SQLLOG",¦#endifÙ #if defined(SQLITE_ENABLE_STAT4)±  "ENABLE_STAT4",Ù"#elif defined(SQLITE_ENABLE_STAT3)±  "ENABLE_STAT3",¦#endifº#if SQLITE_ENABLE_STMTVTAB´  "ENABLE_STMTVTAB",¦#endifÙ!#if SQLITE_ENABLE_STMT_SCANSTATUS»  "ENABLE_STMT_SCANSTATUS",¦#endifÙ&#if SQLITE_ENABLE_UNKNOWN_SQL_FUNCTIONÙ   "ENABLE_UNKNOWN_SQL_FUNCTION",¦#endif¿#if SQLITE_ENABLE_UNLOCK_NOTIFY¹  "ENABLE_UNLOCK_NOTIFY",¦#endifÙ%#if SQLITE_ENABLE_UPDATE_DELETE_LIMIT¿  "ENABLE_UPDATE_DELETE_LIMIT",¦#endif¾#if SQLITE_ENABLE_URI_00_ERROR¸  "ENABLE_URI_00_ERROR",¦#endifº#if SQLITE_ENABLE_VFSTRACE´  "ENABLE_VFSTRACE",¦#endif¼#if SQLITE_ENABLE_WHERETRACE¶  "ENABLE_WHERETRACE",¦#endif¸#if SQLITE_ENABLE_ZIPVFS²  "ENABLE_ZIPVFS",¦#endifÙ!#if SQLITE_EXPLAIN_ESTIMATED_ROWS»  "EXPLAIN_ESTIMATED_ROWS",¦#endifº#if SQLITE_EXTRA_IFNULLROW´  "EXTRA_IFNULLROW",¦#endif¸#ifdef SQLITE_EXTRA_INITÙ0  "EXTRA_INIT=" CTIMEOPT_VAL(SQLITE_EXTRA_INIT),¦#endif¼#ifdef SQLITE_EXTRA_SHUTDOWNÙ8  "EXTRA_SHUTDOWN=" CTIMEOPT_VAL(SQLITE_EXTRA_SHUTDOWN),¦#endifÙ!#ifdef SQLITE_FTS3_MAX_EXPR_DEPTHÙB  "FTS3_MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_FTS3_MAX_EXPR_DEPTH),¦#endif¾#if SQLITE_FTS5_ENABLE_TEST_MI¸  "FTS5_ENABLE_TEST_MI",¦#endifÙ #if SQLITE_FTS5_NO_WITHOUT_ROWIDº  "FTS5_NO_WITHOUT_ROWID",¦#endif´#if SQLITE_HAS_CODEC®  "HAS_CODEC",¦#endifÙ##if HAVE_ISNAN || SQLITE_HAVE_ISNAN¯  "HAVE_ISNAN",¦#endifÙ$#if SQLITE_HOMEGROWN_RECURSIVE_MUTEX¾  "HOMEGROWN_RECURSIVE_MUTEX",¦#endifÙ!#if SQLITE_IGNORE_AFP_LOCK_ERRORS»  "IGNORE_AFP_LOCK_ERRORS",¦#endifÙ##if SQLITE_IGNORE_FLOCK_LOCK_ERRORS½  "IGNORE_FLOCK_LOCK_ERRORS",¦#endif¸#if SQLITE_INLINE_MEMCPY²  "INLINE_MEMCPY",¦#endifµ#if SQLITE_INT64_TYPE¯  "INT64_TYPE",¦#endifÙ'#ifdef SQLITE_INTEGRITY_CHECK_ERROR_MAXÙN  "INTEGRITY_CHECK_ERROR_MAX=" CTIMEOPT_VAL(SQLITE_INTEGRITY_CHECK_ERROR_MAX),¦#endifÙ"#if SQLITE_LIKE_DOESNT_MATCH_BLOBS¼  "LIKE_DOESNT_MATCH_BLOBS",¦#endifµ#if SQLITE_LOCK_TRACE¯  "LOCK_TRACE",¦#endifº#if SQLITE_LOG_CACHE_SPILL´  "LOG_CACHE_SPILL",¦#endif¿#ifdef SQLITE_MALLOC_SOFT_LIMITÙ>  "MALLOC_SOFT_LIMIT=" CTIMEOPT_VAL(SQLITE_MALLOC_SOFT_LIMIT),¦#endifº#ifdef SQLITE_MAX_ATTACHEDÙ4  "MAX_ATTACHED=" CTIMEOPT_VAL(SQLITE_MAX_ATTACHED),¦#endif¸#ifdef SQLITE_MAX_COLUMNÙ0  "MAX_COLUMN=" CTIMEOPT_VAL(SQLITE_MAX_COLUMN),¦#endifÙ!#ifdef SQLITE_MAX_COMPOUND_SELECTÙB  "MAX_COMPOUND_SELECT=" CTIMEOPT_VAL(SQLITE_MAX_COMPOUND_SELECT),¦#endifÙ##ifdef SQLITE_MAX_DEFAULT_PAGE_SIZEÙF  "MAX_DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_DEFAULT_PAGE_SIZE),¦#endif¼#ifdef SQLITE_MAX_EXPR_DEPTHÙ8  "MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_EXPR_DEPTH),¦#endif¾#ifdef SQLITE_MAX_FUNCTION_ARGÙ<  "MAX_FUNCTION_ARG=" CTIMEOPT_VAL(SQLITE_MAX_FUNCTION_ARG),¦#endif¸#ifdef SQLITE_MAX_LENGTHÙ0  "MAX_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LENGTH),¦#endifÙ%#ifdef SQLITE_MAX_LIKE_PATTERN_LENGTHÙJ  "MAX_LIKE_PATTERN_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LIKE_PATTERN_LENGTH),¦#endif¸#ifdef SQLITE_MAX_MEMORYÙ0  "MAX_MEMORY=" CTIMEOPT_VAL(SQLITE_MAX_MEMORY),¦#endif»#ifdef SQLITE_MAX_MMAP_SIZEÙ6  "MAX_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),¦#endif¼#ifdef SQLITE_MAX_MMAP_SIZE_Ù8  "MAX_MMAP_SIZE_=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE_),¦#endif¼#ifdef SQLITE_MAX_PAGE_COUNTÙ8  "MAX_PAGE_COUNT=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_COUNT),¦#endif»#ifdef SQLITE_MAX_PAGE_SIZEÙ6  "MAX_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_SIZE),¦#endif¾#ifdef SQLITE_MAX_SCHEMA_RETRYÙ<  "MAX_SCHEMA_RETRY=" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),¦#endif¼#ifdef SQLITE_MAX_SQL_LENGTHÙ8  "MAX_SQL_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_SQL_LENGTH),¦#endif¿#ifdef SQLITE_MAX_TRIGGER_DEPTHÙ>  "MAX_TRIGGER_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_TRIGGER_DEPTH),¦#endifÙ!#ifdef SQLITE_MAX_VARIABLE_NUMBERÙB  "MAX_VARIABLE_NUMBER=" CTIMEOPT_VAL(SQLITE_MAX_VARIABLE_NUMBER),¦#endif¹#ifdef SQLITE_MAX_VDBE_OPÙ2  "MAX_VDBE_OP=" CTIMEOPT_VAL(SQLITE_MAX_VDBE_OP),¦#endifÙ #ifdef SQLITE_MAX_WORKER_THREADSÙ@  "MAX_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_MAX_WORKER_THREADS),¦#endif³#if SQLITE_MEMDEBUG­  "MEMDEBUG",¦#endifÙ##if SQLITE_MIXED_ENDIAN_64BIT_FLOAT½  "MIXED_ENDIAN_64BIT_FLOAT",¦#endif¹#if SQLITE_MMAP_READWRITE³  "MMAP_READWRITE",¦#endifµ#if SQLITE_MUTEX_NOOP¯  "MUTEX_NOOP",¦#endifµ#if SQLITE_MUTEX_NREF¯  "MUTEX_NREF",¦#endifµ#if SQLITE_MUTEX_OMIT¯  "MUTEX_OMIT",¦#endif¹#if SQLITE_MUTEX_PTHREADS³  "MUTEX_PTHREADS",¦#endif´#if SQLITE_MUTEX_W32®  "MUTEX_W32",¦#endif¸#if SQLITE_NEED_ERR_NAME²  "NEED_ERR_NAME",¦#endif³#if SQLITE_NOINLINE­  "NOINLINE",¦#endif²#if SQLITE_NO_SYNC¬  "NO_SYNC",¦#endifº#if SQLITE_OMIT_ALTERTABLE´  "OMIT_ALTERTABLE",¦#endif·#if SQLITE_OMIT_ANALYZE±  "OMIT_ANALYZE",¦#endif¶#if SQLITE_OMIT_ATTACH°  "OMIT_ATTACH",¦#endif½#if SQLITE_OMIT_AUTHORIZATION·  "OMIT_AUTHORIZATION",¦#endif½#if SQLITE_OMIT_AUTOINCREMENT·  "OMIT_AUTOINCREMENT",¦#endif¸#if SQLITE_OMIT_AUTOINIT²  "OMIT_AUTOINIT",¦#endif¿#if SQLITE_OMIT_AUTOMATIC_INDEX¹  "OMIT_AUTOMATIC_INDEX",¦#endif¹#if SQLITE_OMIT_AUTORESET³  "OMIT_AUTORESET",¦#endifº#if SQLITE_OMIT_AUTOVACUUM´  "OMIT_AUTOVACUUM",¦#endifÙ$#if SQLITE_OMIT_BETWEEN_OPTIMIZATION¾  "OMIT_BETWEEN_OPTIMIZATION",¦#endif¼#if SQLITE_OMIT_BLOB_LITERAL¶  "OMIT_BLOB_LITERAL",¦#endifº#if SQLITE_OMIT_BTREECOUNT´  "OMIT_BTREECOUNT",¦#endif´#if SQLITE_OMIT_CAST®  "OMIT_CAST",¦#endifµ#if SQLITE_OMIT_CHECK¯  "OMIT_CHECK",¦#endif¸#if SQLITE_OMIT_COMPLETE²  "OMIT_COMPLETE",¦#endif¿#if SQLITE_OMIT_COMPOUND_SELECT¹  "OMIT_COMPOUND_SELECT",¦#endif¿#if SQLITE_OMIT_CONFLICT_CLAUSE¹  "OMIT_CONFLICT_CLAUSE",¦#endif³#if SQLITE_OMIT_CTE­  "OMIT_CTE",¦#endif¾#if SQLITE_OMIT_DATETIME_FUNCS¸  "OMIT_DATETIME_FUNCS",¦#endif¸#if SQLITE_OMIT_DECLTYPE²  "OMIT_DECLTYPE",¦#endifº#if SQLITE_OMIT_DEPRECATED´  "OMIT_DEPRECATED",¦#endif¶#if SQLITE_OMIT_DISKIO°  "OMIT_DISKIO",¦#endif·#if SQLITE_OMIT_EXPLAIN±  "OMIT_EXPLAIN",¦#endif¼#if SQLITE_OMIT_FLAG_PRAGMAS¶  "OMIT_FLAG_PRAGMAS",¦#endif¾#if SQLITE_OMIT_FLOATING_POINT¸  "OMIT_FLOATING_POINT",¦#endif»#if SQLITE_OMIT_FOREIGN_KEYµ  "OMIT_FOREIGN_KEY",¦#endif¹#if SQLITE_OMIT_GET_TABLE³  "OMIT_GET_TABLE",¦#endif»#if SQLITE_OMIT_HEX_INTEGERµ  "OMIT_HEX_INTEGER",¦#endif¸#if SQLITE_OMIT_INCRBLOB²  "OMIT_INCRBLOB",¦#endif¿#if SQLITE_OMIT_INTEGRITY_CHECK¹  "OMIT_INTEGRITY_CHECK",¦#endifÙ!#if SQLITE_OMIT_LIKE_OPTIMIZATION»  "OMIT_LIKE_OPTIMIZATION",¦#endif¾#if SQLITE_OMIT_LOAD_EXTENSION¸  "OMIT_LOAD_EXTENSION",¦#endif¹#if SQLITE_OMIT_LOCALTIME³  "OMIT_LOCALTIME",¦#endif¹#if SQLITE_OMIT_LOOKASIDE³  "OMIT_LOOKASIDE",¦#endif¸#if SQLITE_OMIT_MEMORYDB²  "OMIT_MEMORYDB",¦#endif¿#if SQLITE_OMIT_OR_OPTIMIZATION¹  "OMIT_OR_OPTIMIZATION",¦#endif½#if SQLITE_OMIT_PAGER_PRAGMAS·  "OMIT_PAGER_PRAGMAS",¦#endif¼#if SQLITE_OMIT_PARSER_TRACE¶  "OMIT_PARSER_TRACE",¦#endifµ#if SQLITE_OMIT_POPEN¯  "OMIT_POPEN",¦#endif¶#if SQLITE_OMIT_PRAGMA°  "OMIT_PRAGMA",¦#endifÙ!#if SQLITE_OMIT_PROGRESS_CALLBACK»  "OMIT_PROGRESS_CALLBACK",¦#endif¼#if SQLITE_OMIT_QUICKBALANCE¶  "OMIT_QUICKBALANCE",¦#endif·#if SQLITE_OMIT_REINDEX±  "OMIT_REINDEX",¦#endif¾#if SQLITE_OMIT_SCHEMA_PRAGMAS¸  "OMIT_SCHEMA_PRAGMAS",¦#endifÙ&#if SQLITE_OMIT_SCHEMA_VERSION_PRAGMASÙ   "OMIT_SCHEMA_VERSION_PRAGMAS",¦#endif¼#if SQLITE_OMIT_SHARED_CACHE¶  "OMIT_SHARED_CACHE",¦#endifÙ$#if SQLITE_OMIT_SHUTDOWN_DIRECTORIES¾  "OMIT_SHUTDOWN_DIRECTORIES",¦#endif¸#if SQLITE_OMIT_SUBQUERY²  "OMIT_SUBQUERY",¦#endif¼#if SQLITE_OMIT_TCL_VARIABLE¶  "OMIT_TCL_VARIABLE",¦#endif¶#if SQLITE_OMIT_TEMPDB°  "OMIT_TEMPDB",¦#endif¼#if SQLITE_OMIT_TEST_CONTROL¶  "OMIT_TEST_CONTROL",¦#endifµ#if SQLITE_OMIT_TRACE¯  "OMIT_TRACE",¦#endif·#if SQLITE_OMIT_TRIGGER±  "OMIT_TRIGGER",¦#endifÙ%#if SQLITE_OMIT_TRUNCATE_OPTIMIZATION¿  "OMIT_TRUNCATE_OPTIMIZATION",¦#endifµ#if SQLITE_OMIT_UTF16¯  "OMIT_UTF16",¦#endif¶#if SQLITE_OMIT_VACUUM°  "OMIT_VACUUM",¦#endif´#if SQLITE_OMIT_VIEW®  "OMIT_VIEW",¦#endif¼#if SQLITE_OMIT_VIRTUALTABLE¶  "OMIT_VIRTUALTABLE",¦#endif³#if SQLITE_OMIT_WAL­  "OMIT_WAL",¦#endif³#if SQLITE_OMIT_WSD­  "OMIT_WSD",¦#endif¸#if SQLITE_OMIT_XFER_OPT²  "OMIT_XFER_OPT",¦#endifÙ!#if SQLITE_PCACHE_SEPARATE_HEADER»  "PCACHE_SEPARATE_HEADER",¦#endif¼#if SQLITE_PERFORMANCE_TRACE¶  "PERFORMANCE_TRACE",¦#endif¾#if SQLITE_POWERSAFE_OVERWRITE¸  "POWERSAFE_OVERWRITE",¦#endif¿#if SQLITE_PREFER_PROXY_LOCKING¹  "PREFER_PROXY_LOCKING",¦#endif¶#if SQLITE_PROXY_DEBUG°  "PROXY_DEBUG",¦#endifÙ$#if SQLITE_REVERSE_UNORDERED_SELECTS¾  "REVERSE_UNORDERED_SELECTS",¦#endif¹#if SQLITE_RTREE_INT_ONLY³  "RTREE_INT_ONLY",¦#endif¸#if SQLITE_SECURE_DELETE²  "SECURE_DELETE",¦#endif¶#if SQLITE_SMALL_STACK°  "SMALL_STACK",¦#endifº#ifdef SQLITE_SORTER_PMASZÙ4  "SORTER_PMASZ=" CTIMEOPT_VAL(SQLITE_SORTER_PMASZ),¦#endif²#if SQLITE_SOUNDEX¬  "SOUNDEX",¦#endif»#ifdef SQLITE_STAT4_SAMPLESÙ6  "STAT4_SAMPLES=" CTIMEOPT_VAL(SQLITE_STAT4_SAMPLES),¦#endif¼#ifdef SQLITE_STMTJRNL_SPILLÙ8  "STMTJRNL_SPILL=" CTIMEOPT_VAL(SQLITE_STMTJRNL_SPILL),¦#endif¿#if SQLITE_SUBSTR_COMPATIBILITY¹  "SUBSTR_COMPATIBILITY",¦#endif¸#if SQLITE_SYSTEM_MALLOC²  "SYSTEM_MALLOC",¦#endif®#if SQLITE_TCL¨  "TCL",¦#endif¸#ifdef SQLITE_TEMP_STOREÙ0  "TEMP_STORE=" CTIMEOPT_VAL(SQLITE_TEMP_STORE),¦#endif¯#if SQLITE_TEST©  "TEST",¦#endif¾#if defined(SQLITE_THREADSAFE)Ù0  "THREADSAFE=" CTIMEOPT_VAL(SQLITE_THREADSAFE),¹#elif defined(THREADSAFE)Ù)  "THREADSAFE=" CTIMEOPT_VAL(THREADSAFE),¥#else±  "THREADSAFE=1",¦#endif½#if SQLITE_UNLINK_AFTER_CLOSE·  "UNLINK_AFTER_CLOSE",¦#endifµ#if SQLITE_UNTESTABLE¯  "UNTESTABLE",¦#endif¾#if SQLITE_USER_AUTHENTICATION¸  "USER_AUTHENTICATION",¦#endifµ#if SQLITE_USE_ALLOCA¯  "USE_ALLOCA",¦#endifº#if SQLITE_USE_FCNTL_TRACE´  "USE_FCNTL_TRACE",¦#endif²#if SQLITE_USE_URI¬  "USE_URI",¦#endif¸#if SQLITE_VDBE_COVERAGE²  "VDBE_COVERAGE",¦#endif·#if SQLITE_WIN32_MALLOC±  "WIN32_MALLOC",¦#endif¶#if SQLITE_ZERO_MALLOC°  "ZERO_MALLOC",¦#endif£/* Ù*** END CODE GENERATED BY tool/mkctime.tcl ¢*/¢}; Ù>SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt){ÙH  *pnOpt = sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]);Ù+  return (const char**)sqlite3azCompileOpt;¡} Ù,#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */ ÙO/************** End of ctime.c ***********************************************/ÙO/************** Begin file sqliteInt.h ***************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù-** Internal interface definitions for SQLite.¢**¢*/³#ifndef SQLITEINT_H³#define SQLITEINT_H ´/* Special Comments:¢**ÙD** Some comments have special meaning to the tools that measure test¬** coverage:¢**ÙE**    NO_TEST                     - The branches on this line are notÙI**                                  measured by branch coverage.  This isÙG**                                  used on lines of code that actuallyÙH**                                  implement parts of coverage testing.¢**ÙL**    OPTIMIZATION-IF-TRUE        - This branch is allowed to alway be falseÙM**                                  and the correct answer is still obtained,Ù?**                                  though perhaps more slowly.¢**ÙK**    OPTIMIZATION-IF-FALSE       - This branch is allowed to alway be trueÙM**                                  and the correct answer is still obtained,Ù?**                                  though perhaps more slowly.¢**ÙJ**    PREVENTS-HARMLESS-OVERREAD  - This branch prevents a buffer overreadÙK**                                  that would be harmless and undetectableÙ6**                                  if it did occur.  ¢**ÙB** In all cases, the special comment must be enclosed in the usualÙM** slash-asterisk...asterisk-slash comment marks, with no spaces between the Ù"** asterisks and the comment text.¢*/ ¢/*ÙH** Make sure the Tcl calling convention macro is defined.  This macro isÙ3** only used by test code and Tcl integration code.¢*/µ#ifndef SQLITE_TCLAPI·#  define SQLITE_TCLAPI¦#endif ¢/*ÙK** Include the header file used to customize the compiler options for MSVC.ÙI** This should be done first so that it can successfully prevent spuriousÙK** compiler warnings due to subsequent content in this file and other filesÙ"** that are included by this file.¢*/ÙO/************** Include msvc.h in the middle of sqliteInt.h ******************/ÙO/************** Begin file msvc.h ********************************************/¢/*²** 2015 January 12¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**Ù4** This file contains code that is specific to MSVC.¢*/µ#ifndef SQLITE_MSVC_Hµ#define SQLITE_MSVC_H µ#if defined(_MSC_VER)¿#pragma warning(disable : 4054)¿#pragma warning(disable : 4055)¿#pragma warning(disable : 4100)¿#pragma warning(disable : 4127)¿#pragma warning(disable : 4130)¿#pragma warning(disable : 4152)¿#pragma warning(disable : 4189)¿#pragma warning(disable : 4206)¿#pragma warning(disable : 4210)¿#pragma warning(disable : 4232)¿#pragma warning(disable : 4244)¿#pragma warning(disable : 4305)¿#pragma warning(disable : 4306)¿#pragma warning(disable : 4702)¿#pragma warning(disable : 4706)¾#endif /* defined(_MSC_VER) */ º#endif /* SQLITE_MSVC_H */ ÙO/************** End of msvc.h ************************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ ¢/*¼** Special setup for VxWorks¢*/ÙO/************** Include vxworks.h in the middle of sqliteInt.h ***************/ÙO/************** Begin file vxworks.h *****************************************/¢/*­** 2015-03-02¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙC** This file contains code that is specific to Wind River's VxWorks¢*/Ù,#if defined(__RTP__) || defined(_WRS_KERNEL)Ù8/* This is VxWorks.  Set up things specially for that OS¢*/´#include <vxWorks.h>Ù2#include <pthread.h>  /* amalgamator: dontcache */´#define OS_VXWORKS 1¹#define SQLITE_OS_OTHER 0Ù*#define SQLITE_HOMEGROWN_RECURSIVE_MUTEX 1Ù$#define SQLITE_OMIT_LOAD_EXTENSION 1Ù%#define SQLITE_ENABLE_LOCKING_STYLE 0´#define HAVE_UTIME 1¥#elseº/* This is not VxWorks. */´#define OS_VXWORKS 0µ#define HAVE_FCHOWN 1·#define HAVE_READLINK 1´#define HAVE_LSTAT 1Ù!#endif /* defined(_WRS_KERNEL) */ ÙO/************** End of vxworks.h *********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ ¢/*ÙA** These #defines should enable >2GB file support on POSIX if theÙ<** underlying operating system supports it.  If the OS lacksÙG** large file support, or if the OS is windows, these should be no-ops.¢**ÙD** Ticket #2739:  The _LARGEFILE_SOURCE macro must appear before anyÙF** system #includes.  Hence, this block of code must be the very first¼** code in all source files.¢**ÙK** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switchÙH** on the compiler command line.  This is necessary if you are compilingÙG** on a recent machine (ex: Red Hat 7.2) but you want your code to workÙH** on an older machine (ex: Red Hat 6.0).  If you compile on Red Hat 7.2ÙL** without this option, LFS is enable.  But LFS does not exist in the kernelÙE** in Red Hat 6.0, so the code won't work.  Hence, for maximum binaryÙ#** portability you should omit LFS.¢**ÙJ** The previous paragraph was written in 2005.  (This paragraph is writtenÙH** on 2008-11-28.) These days, all Linux kernels support large files, soÙL** you should probably leave LFS enabled.  But some embedded platforms mightÙM** lack LFS in which case the SQLITE_DISABLE_LFS macro might still be useful.¢**ÙP** Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.¢*/º#ifndef SQLITE_DISABLE_LFS¼# define _LARGE_FILE       1º# ifndef _FILE_OFFSET_BITS¿#   define _FILE_OFFSET_BITS 64§# endif¼# define _LARGEFILE_SOURCE 1¦#endif Ù6/* The GCC_VERSION and MSVC_VERSION macros are used toÙF** conditionally include optimizations for each of these compilers.  AÙ9** value of 0 means that compiler is not being used.  TheÙH** SQLITE_DISABLE_INTRINSIC macro means do not use any compiler-specificÙ8** optimizations, and hence set all compiler macros to 0¢**ÙI** There was once also a CLANG_VERSION macro.  However, we learn that theÙI** version numbers in clang are for "marketing" only and are inconsistentÙI** and unreliable.  Fortunately, all versions of clang also recognize theÙL** gcc version numbers and have reasonable settings for gcc version numbers,ÙH** so the GCC_VERSION macro will be set to a correct non-zero value even½** when compiling with clang.¢*/Ù;#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)ÙO# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)¥#else¶# define GCC_VERSION 0¦#endifÙ;#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)¾# define MSVC_VERSION _MSC_VER¥#else·# define MSVC_VERSION 0¦#endif Ù'/* Needed for various definitions... */Ù.#if defined(__GNUC__) && !defined(_GNU_SOURCE)´# define _GNU_SOURCE¦#endif Ù1#if defined(__OpenBSD__) && !defined(_BSD_SOURCE)´# define _BSD_SOURCE¦#endif ¢/*ÙK** For MinGW, check to see if we can include the header file containing itsÙJ** version information, among other things.  Normally, this internal MinGWÙK** header file would [only] be included automatically by other MinGW headerÙL** files; however, the contained version information is now required by thisÙI** header file to work around binary compatibility issues (see below) andÙK** this is the only known way to reliably obtain it.  This entire #if blockÙJ** would be completely unnecessary if there was any other way of detectingÙL** MinGW via their preprocessor (e.g. if they customized their GCC to defineÙE** some MinGW-specific macros).  When compiling for MinGW, either theÙL** _HAVE_MINGW_H or _HAVE__MINGW_H (note the extra underscore) macro must beÙH** defined; otherwise, detection of conditions specific to MinGW will be¬** disabled.¢*/º#if defined(_HAVE_MINGW_H)³# include "mingw.h"½#elif defined(_HAVE__MINGW_H)´# include "_mingw.h"¦#endif ¢/*ÙL** For MinGW version 4.x (and higher), check to see if the _USE_32BIT_TIME_TÙL** define is required to maintain binary compatibility with the MSVC runtimeÙ(** library in use (e.g. for Windows XP).¢*/ÙC#if !defined(_USE_32BIT_TIME_T) && !defined(_USE_64BIT_TIME_T) && \Ù,    defined(_WIN32) && !defined(_WIN64) && \ÙE    defined(__MINGW_MAJOR_VERSION) && __MINGW_MAJOR_VERSION >= 4 && \·    defined(__MSVCRT__)º# define _USE_32BIT_TIME_T¦#endif ÙH/* The public SQLite interface.  The _FILE_OFFSET_BITS macro must appearÙI** first in QNX.  Also, the _USE_32BIT_TIME_T macro must appear first for©** MinGW.¢*/ÙO/************** Include sqlite3.h in the middle of sqliteInt.h ***************/ÙO/************** Begin file sqlite3.h *****************************************/¢/*­** 2001-09-15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙA** This header file defines the interface that the SQLite libraryÙF** presents to client programs.  If a C-function, structure, datatype,ÙB** or constant definition does not appear in this file, then it isÙ>** not a published API of SQLite, is subject to change withoutÙD** notice, and should not be referenced by programs that use SQLite.¢**Ù>** Some of the definitions that are in this file are marked asÙ<** "experimental".  Experimental interfaces are normally newÙC** features recently added to SQLite.  We do not anticipate changesÙI** to experimental interfaces but reserve the right to make minor changesÙI** if experience from use "in the wild" suggest such changes are prudent.¢**ÙB** The official C-language API documentation for SQLite is derivedÙE** from comments in this file.  This file is the authoritative sourceÙ4** on how SQLite interfaces are supposed to operate.¢**ÙI** The name of this file under configuration management is "sqlite.h.in".ÙH** The makefile makes some minor changes to this file (such as insertingÙ=** the version number) and changes its name to "sqlite3.h" as½** part of the build process.¢*/±#ifndef SQLITE3_H±#define SQLITE3_HÙB#include <stdarg.h>     /* Needed for the definition of va_list */ ¢/*Ù-** Make sure we can call this stuff from C++.¢*/¥#if 0¬extern "C" {¦#endif  ¢/*ÙE** Provide the ability to override linkage features of the interface.¢*/µ#ifndef SQLITE_EXTERN½# define SQLITE_EXTERN extern¦#endif²#ifndef SQLITE_API³# define SQLITE_API¦#endif´#ifndef SQLITE_CDECLµ# define SQLITE_CDECL¦#endif¶#ifndef SQLITE_APICALL·# define SQLITE_APICALL¦#endif¶#ifndef SQLITE_STDCALLÙ&# define SQLITE_STDCALL SQLITE_APICALL¦#endif·#ifndef SQLITE_CALLBACK¸# define SQLITE_CALLBACK¦#endifµ#ifndef SQLITE_SYSAPI¶# define SQLITE_SYSAPI¦#endif ¢/*ÙC** These no-op macros are used in front of interfaces to mark thoseÙE** interfaces as either deprecated or experimental.  New applicationsÙJ** should not use deprecated interfaces - they are supported for backwardsÙ@** compatibility only.  Application writers should be aware thatÙC** experimental interfaces are subject to change in point releases.¢**ÙG** These macros used to resolve to various kinds of compiler magic thatÙA** would generate warning messages when they were used.  But thatÙB** compiler magic ended up generating such a flurry of bug reportsÙ>** that we have taken it all out and gone back to using simple¯** noop macros.¢*/¹#define SQLITE_DEPRECATED»#define SQLITE_EXPERIMENTAL ¢/*ÙF** Ensure these symbols were not defined by some previous header file.¢*/µ#ifdef SQLITE_VERSION¶# undef SQLITE_VERSION¦#endif¼#ifdef SQLITE_VERSION_NUMBER½# undef SQLITE_VERSION_NUMBER¦#endif ¢/*Ù1** CAPI3REF: Compile-Time Library Version Numbers¢**ÙF** ^(The [SQLITE_VERSION] C preprocessor macro in the sqlite3.h headerÙB** evaluates to a string literal that is the SQLite version in theÙC** format "X.Y.Z" where X is the major version number (always 3 forÙL** SQLite3) and Y is the minor version number and Z is the release number.)^ÙL** ^(The [SQLITE_VERSION_NUMBER] C preprocessor macro resolves to an integerÙI** with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the sameÙ&** numbers used in [SQLITE_VERSION].)^ÙF** The SQLITE_VERSION_NUMBER for any given release of SQLite will alsoÙF** be larger than the release from which it is derived.  Either Y willÙK** be held constant and Z will be incremented or else Y will be incremented¿** and Z will be reset to zero.¢**Ù-** Since [version 3.6.18] ([dateof:3.6.18]), Ù,** SQLite source code has been stored in theÙG** <a href="http://www.fossil-scm.org/">Fossil configuration managementÙ8** system</a>.  ^The SQLITE_SOURCE_ID macro evaluates toÙ<** a string which identifies a particular check-in of SQLiteÙE** within its configuration management system.  ^The SQLITE_SOURCE_IDÙE** string contains the date and time of the check-in (UTC) and a SHA1ÙF** or SHA3-256 hash of the entire source tree.  If the source code hasÙE** been edited in any way since it was last checked in, then the lastÙ7** four hexadecimal digits of the hash may be modified.¢**Ù$** See also: [sqlite3_libversion()],Ù7** [sqlite3_libversion_number()], [sqlite3_sourceid()],Ù/** [sqlite_version()] and [sqlite_source_id()].¢*/Ù&#define SQLITE_VERSION        "3.23.1"Ù%#define SQLITE_VERSION_NUMBER 3023001Ùt#define SQLITE_SOURCE_ID      "2018-04-10 17:39:29 4bb2294022060e61de7da5c227a69ccd846ba330e31626ebcd59a94efd148b3b" ¢/*Ù-** CAPI3REF: Run-Time Library Version NumbersÙ-** KEYWORDS: sqlite3_version sqlite3_sourceid¢**ÙI** These interfaces provide the same information as the [SQLITE_VERSION],ÙH** [SQLITE_VERSION_NUMBER], and [SQLITE_SOURCE_ID] C preprocessor macrosÙN** but are associated with the library instead of the header file.  ^(CautiousÙH** programmers might include assert() statements in their application toÙF** verify that values returned by these interfaces match the macros inÙ6** the header, and thus ensure that the application isÙ3** compiled with matching library and header files.¢**´** <blockquote><pre>Ù@** assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER );Ù@** assert( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,80)==0 );Ù<** assert( strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );¸** </pre></blockquote>)^¢**ÙO** ^The sqlite3_version[] string constant contains the text of [SQLITE_VERSION]ÙF** macro.  ^The sqlite3_libversion() function returns a pointer to theÙF** to the sqlite3_version[] string constant.  The sqlite3_libversion()ÙK** function is provided for use in DLLs since DLL users usually do not haveÙ:** direct access to string constants within the DLL.  ^TheÙC** sqlite3_libversion_number() function returns an integer equal toÙG** [SQLITE_VERSION_NUMBER].  ^(The sqlite3_sourceid() function returns ÙA** a pointer to a string constant whose value is the same as the ÙF** [SQLITE_SOURCE_ID] C preprocessor macro.  Except if SQLite is builtÙL** using an edited copy of [the amalgamation], then the last four charactersÙ<** of the hash might be different from [SQLITE_SOURCE_ID].)^¢**Ù9** See also: [sqlite_version()] and [sqlite_source_id()].¢*/Ù9SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;Ù0SQLITE_API const char *sqlite3_libversion(void);Ù.SQLITE_API const char *sqlite3_sourceid(void);Ù/SQLITE_API int sqlite3_libversion_number(void); ¢/*Ù=** CAPI3REF: Run-Time Library Compilation Options Diagnostics¢**Ù=** ^The sqlite3_compileoption_used() function returns 0 or 1 Ù:** indicating whether the specified option was defined at Ù>** compile time.  ^The SQLITE_ prefix may be omitted from the Ù8** option name passed to sqlite3_compileoption_used().  ¢**Ù=** ^The sqlite3_compileoption_get() function allows iteratingÙ@** over the list of options that were defined at compile time byÙI** returning the N-th compile time option string.  ^If N is out of range,ÙE** sqlite3_compileoption_get() returns a NULL pointer.  ^The SQLITE_ Ù2** prefix is omitted from any strings returned by ¿** sqlite3_compileoption_get().¢**ÙE** ^Support for the diagnostic functions sqlite3_compileoption_used()ÙD** and sqlite3_compileoption_get() may be omitted by specifying the Ù<** [SQLITE_OMIT_COMPILEOPTION_DIAGS] option at compile time.¢**Ù<** See also: SQL functions [sqlite_compileoption_used()] andÙA** [sqlite_compileoption_get()] and the [compile_options pragma].¢*/Ù'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSÙ@SQLITE_API int sqlite3_compileoption_used(const char *zOptName);Ù8SQLITE_API const char *sqlite3_compileoption_get(int N);¦#endif ¢/*Ù5** CAPI3REF: Test To See If The Library Is Threadsafe¢**ÙA** ^The sqlite3_threadsafe() function returns zero if and only ifÙ<** SQLite was compiled with mutexing code omitted due to theÙ:** [SQLITE_THREADSAFE] compile-time option being set to 0.¢**Ù8** SQLite can be compiled with or without mutexes.  WhenÙB** the [SQLITE_THREADSAFE] C preprocessor macro is 1 or 2, mutexesÙ2** are enabled and SQLite is threadsafe.  When theÙ#** [SQLITE_THREADSAFE] macro is 0, Ù@** the mutexes are omitted.  Without the mutexes, it is not safeÙ8** to use SQLite concurrently from more than one thread.¢**Ù<** Enabling mutexes incurs a measurable performance penalty.ÙA** So if speed is of utmost importance, it makes sense to disableÙC** the mutexes.  But for maximum safety, mutexes should be enabled.Ù6** ^The default behavior is for mutexes to be enabled.¢**ÙE** This interface can be used by an application to make sure that theÙA** version of SQLite that it is linking against was compiled withÙ8** the desired setting of the [SQLITE_THREADSAFE] macro.¢**Ù@** This interface only reports on the compile-time mutex settingÙ?** of the [SQLITE_THREADSAFE] flag.  If SQLite is compiled withÙD** SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default butÙH** can be fully or partially disabled using a call to [sqlite3_config()]ÙL** with the verbs [SQLITE_CONFIG_SINGLETHREAD], [SQLITE_CONFIG_MULTITHREAD],Ù<** or [SQLITE_CONFIG_SERIALIZED].  ^(The return value of theÙG** sqlite3_threadsafe() function shows only the compile-time setting ofÙB** thread safety, not any run-time changes to that setting made byÙO** sqlite3_config(). In other words, the return value from sqlite3_threadsafe()Ù/** is unchanged by calls to sqlite3_config().)^¢**ÙE** See the [threading mode] documentation for additional information.¢*/Ù(SQLITE_API int sqlite3_threadsafe(void); ¢/*Ù'** CAPI3REF: Database Connection HandleÙ9** KEYWORDS: {database connection} {database connections}¢**ÙJ** Each open SQLite database is represented by a pointer to an instance ofÙM** the opaque structure named "sqlite3".  It is useful to think of an sqlite3ÙG** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], andÙM** [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]ÙF** and [sqlite3_close_v2()] are its destructors.  There are many other¶** interfaces (such asÙ;** [sqlite3_prepare_v2()], [sqlite3_create_function()], andÙE** [sqlite3_busy_timeout()] to name but three) that are methods on an²** sqlite3 object.¢*/¿typedef struct sqlite3 sqlite3; ¢/*Ù!** CAPI3REF: 64-Bit Integer TypesÙ'** KEYWORDS: sqlite_int64 sqlite_uint64¢**ÙI** Because there is no cross-platform way to specify 64-bit integer typesÙD** SQLite includes typedefs for 64-bit signed and unsigned integers.¢**ÙK** The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.ÙG** The sqlite_int64 and sqlite_uint64 types are supported for backwards¶** compatibility only.¢**ÙE** ^The sqlite3_int64 and sqlite_int64 types can store integer valuesÙI** between -9223372036854775808 and +9223372036854775807 inclusive.  ^TheÙC** sqlite3_uint64 and sqlite_uint64 types can store integer values Ù1** between 0 and +18446744073709551615 inclusive.¢*/¸#ifdef SQLITE_INT64_TYPEÙ)  typedef SQLITE_INT64_TYPE sqlite_int64;º# ifdef SQLITE_UINT64_TYPEÙ-    typedef SQLITE_UINT64_TYPE sqlite_uint64;¨# else  Ù5    typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;§# endifÙ0#elif defined(_MSC_VER) || defined(__BORLANDC__)¿  typedef __int64 sqlite_int64;Ù)  typedef unsigned __int64 sqlite_uint64;¥#elseÙ%  typedef long long int sqlite_int64;Ù/  typedef unsigned long long int sqlite_uint64;¦#endifÙ#typedef sqlite_int64 sqlite3_int64;Ù%typedef sqlite_uint64 sqlite3_uint64; ¢/*ÙB** If compiling for a processor that lacks floating point support,Ù)** substitute integer for floating-point.¢*/Ù!#ifdef SQLITE_OMIT_FLOATING_POINT½# define double sqlite3_int64¦#endif ¢/*Ù*** CAPI3REF: Closing A Database Connection¶** DESTRUCTOR: sqlite3¢**ÙG** ^The sqlite3_close() and sqlite3_close_v2() routines are destructors¼** for the [sqlite3] object.ÙI** ^Calls to sqlite3_close() and sqlite3_close_v2() return [SQLITE_OK] ifÙD** the [sqlite3] object is successfully destroyed and all associated½** resources are deallocated.¢**ÙF** ^If the database connection is associated with unfinalized preparedÙG** statements or unfinished sqlite3_backup objects then sqlite3_close()ÙD** will leave the database connection open and return [SQLITE_BUSY].ÙH** ^If sqlite3_close_v2() is called with unfinalized prepared statementsÙJ** and/or unfinished sqlite3_backups, then the database connection becomesÙH** an unusable "zombie" which will automatically be deallocated when theÙE** last prepared statement is finalized or the last sqlite3_backup isÙG** finished.  The sqlite3_close_v2() interface is intended for use withÙJ** host languages that are garbage collected, and where the order in whichÙ'** destructors are called is arbitrary.¢**ÙO** Applications should [sqlite3_finalize | finalize] all [prepared statements],Ù8** [sqlite3_blob_close | close] all [BLOB handles], and ÙK** [sqlite3_backup_finish | finish] all [sqlite3_backup] objects associatedÙJ** with the [sqlite3] object prior to attempting to close the object.  ^IfÙI** sqlite3_close_v2() is called on a [database connection] that still hasÙ<** outstanding [prepared statements], [BLOB handles], and/orÙL** [sqlite3_backup] objects then it returns [SQLITE_OK] and the deallocationÙL** of resources is deferred until all [prepared statements], [BLOB handles],Ù3** and [sqlite3_backup] objects are also destroyed.¢**ÙD** ^If an [sqlite3] object is destroyed while a transaction is open,Ù0** the transaction is automatically rolled back.¢**ÙB** The C parameter to [sqlite3_close(C)] and [sqlite3_close_v2(C)]¸** must be either a NULLÙ2** pointer or an [sqlite3] object pointer obtainedÙ0** from [sqlite3_open()], [sqlite3_open16()], orÙ2** [sqlite3_open_v2()], and not previously closed.ÙE** ^Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointerÙ ** argument is a harmless no-op.¢*/Ù'SQLITE_API int sqlite3_close(sqlite3*);Ù*SQLITE_API int sqlite3_close_v2(sqlite3*); ¢/*Ù$** The type for a callback function.Ù@** This is legacy and deprecated.  It is included for historicalÙ'** compatibility and is not documented.¢*/Ù:typedef int (*sqlite3_callback)(void*,int,char**, char**); ¢/*Ù/** CAPI3REF: One-Step Query Execution Interface²** METHOD: sqlite3¢**Ù?** The sqlite3_exec() interface is a convenience wrapper aroundÙF** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],Ù?** that allows an application to run multiple statements of SQLÙ*** without having to use a lot of C code. ¢**ÙA** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,ÙB** semicolon-separate SQL statements passed into its 2nd argument,ÙC** in the context of the [database connection] passed in as its 1stÙ>** argument.  ^If the callback function of the 3rd argument toÙE** sqlite3_exec() is not NULL, then it is invoked for each result rowÙD** coming out of the evaluated SQL statements.  ^The 4th argument toÙ@** sqlite3_exec() is relayed through to the 1st argument of eachÙC** callback invocation.  ^If the callback pointer to sqlite3_exec()Ù@** is NULL, then no callback is ever invoked and result rows are«** ignored.¢**ÙF** ^If an error occurs while evaluating the SQL statements passed intoÙD** sqlite3_exec(), then execution of the current statement stops andÙN** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()ÙE** is not NULL then any error message is written into memory obtainedÙE** from [sqlite3_malloc()] and passed back through the 5th parameter.ÙH** To avoid memory leaks, the application should invoke [sqlite3_free()]ÙA** on error message strings returned through the 5th parameter ofÙE** sqlite3_exec() after the error message string is no longer needed.ÙD** ^If the 5th parameter to sqlite3_exec() is not NULL and no errorsÙF** occur, then sqlite3_exec() sets the pointer in its 5th parameter to¹** NULL before returning.¢**ÙF** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()ÙG** routine returns SQLITE_ABORT without invoking the callback again andÙ1** without running any subsequent SQL statements.¢**ÙC** ^The 2nd argument to the sqlite3_exec() callback function is theÙL** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()ÙB** callback is an array of pointers to strings obtained as if fromÙE** [sqlite3_column_text()], one for each column.  ^If an element of aÙC** result row is NULL then the corresponding string pointer for theÙG** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to theÙH** sqlite3_exec() callback is an array of pointers to strings where eachÙG** entry represents the name of corresponding result column as obtainedÙ ** from [sqlite3_column_name()].¢**ÙG** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointerÙI** to an empty string, or a pointer that contains only whitespace and/or ÙF** SQL comments, then no SQL statements are evaluated and the database²** is not changed.¢**°** Restrictions:¢**§** <ul>ÙL** <li> The application must ensure that the 1st parameter to sqlite3_exec()Ù2**      is a valid and open [database connection].ÙM** <li> The application must not close the [database connection] specified byÙL**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.ÙJ** <li> The application must not modify the SQL statement text passed intoÙL**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.¨** </ul>¢*/¼SQLITE_API int sqlite3_exec(ÙC  sqlite3*,                                  /* An open database */ÙF  const char *sql,                           /* SQL to be evaluated */ÙD  int (*callback)(void*,int,char**,char**),  /* Callback function */ÙK  void *,                                    /* 1st argument to callback */ÙI  char **errmsg                              /* Error msg written here */¢); ¢/*¹** CAPI3REF: Result CodesÙ&** KEYWORDS: {result code definitions}¢**ÙI** Many SQLite functions return an integer result code from the set shownÙ0** here in order to indicate success or failure.¢**Ù=** New error codes may be added in future versions of SQLite.¢**Ù/** See also: [extended result code definitions]¢*/Ù7#define SQLITE_OK           0   /* Successful result */¾/* beginning-of-error-codes */Ù3#define SQLITE_ERROR        1   /* Generic error */ÙD#define SQLITE_INTERNAL     2   /* Internal logic error in SQLite */Ù>#define SQLITE_PERM         3   /* Access permission denied */ÙI#define SQLITE_ABORT        4   /* Callback routine requested an abort */ÙA#define SQLITE_BUSY         5   /* The database file is locked */ÙG#define SQLITE_LOCKED       6   /* A table in the database is locked */Ù7#define SQLITE_NOMEM        7   /* A malloc() failed */ÙJ#define SQLITE_READONLY     8   /* Attempt to write a readonly database */ÙP#define SQLITE_INTERRUPT    9   /* Operation terminated by sqlite3_interrupt()*/ÙJ#define SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */ÙJ#define SQLITE_CORRUPT     11   /* The database disk image is malformed */ÙN#define SQLITE_NOTFOUND    12   /* Unknown opcode in sqlite3_file_control() */ÙO#define SQLITE_FULL        13   /* Insertion failed because database is full */ÙF#define SQLITE_CANTOPEN    14   /* Unable to open the database file */ÙB#define SQLITE_PROTOCOL    15   /* Database lock protocol error */Ù7#define SQLITE_EMPTY       16   /* Internal use only */ÙA#define SQLITE_SCHEMA      17   /* The database schema changed */ÙG#define SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */ÙG#define SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */Ù8#define SQLITE_MISMATCH    20   /* Data type mismatch */Ù>#define SQLITE_MISUSE      21   /* Library used incorrectly */ÙL#define SQLITE_NOLFS       22   /* Uses OS features not supported on host */Ù:#define SQLITE_AUTH        23   /* Authorization denied */Ù.#define SQLITE_FORMAT      24   /* Not used */ÙP#define SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */ÙM#define SQLITE_NOTADB      26   /* File opened that is not a database file */ÙF#define SQLITE_NOTICE      27   /* Notifications from sqlite3_log() */ÙA#define SQLITE_WARNING     28   /* Warnings from sqlite3_log() */ÙJ#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */ÙK#define SQLITE_DONE        101  /* sqlite3_step() has finished executing */¸/* end-of-error-codes */ ¢/*Ù"** CAPI3REF: Extended Result CodesÙ/** KEYWORDS: {extended result code definitions}¢**ÙM** In its default configuration, SQLite API routines return one of 30 integerÙ>** [result codes].  However, experience has shown that many ofÙE** these result codes are too coarse-grained.  They do not provide asÙN** much information about problems as programmers might like.  In an effort toÙG** address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]µ** and later) includeÙM** support for additional result codes that provide more detailed informationÙF** about errors. These [extended result codes] are enabled or disabledÙ/** on a per database connection basis using theÙD** [sqlite3_extended_result_codes()] API.  Or, the extended code forÙ.** the most recent error can be obtained usingÙ ** [sqlite3_extended_errcode()].¢*/Ù>#define SQLITE_ERROR_MISSING_COLLSEQ   (SQLITE_ERROR | (1<<8))Ù>#define SQLITE_ERROR_RETRY             (SQLITE_ERROR | (2<<8))Ù>#define SQLITE_IOERR_READ              (SQLITE_IOERR | (1<<8))Ù>#define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR | (2<<8))Ù>#define SQLITE_IOERR_WRITE             (SQLITE_IOERR | (3<<8))Ù>#define SQLITE_IOERR_FSYNC             (SQLITE_IOERR | (4<<8))Ù>#define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR | (5<<8))Ù>#define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR | (6<<8))Ù>#define SQLITE_IOERR_FSTAT             (SQLITE_IOERR | (7<<8))Ù>#define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR | (8<<8))Ù>#define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR | (9<<8))Ù?#define SQLITE_IOERR_DELETE            (SQLITE_IOERR | (10<<8))Ù?#define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR | (11<<8))Ù?#define SQLITE_IOERR_NOMEM             (SQLITE_IOERR | (12<<8))Ù?#define SQLITE_IOERR_ACCESS            (SQLITE_IOERR | (13<<8))Ù?#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))Ù?#define SQLITE_IOERR_LOCK              (SQLITE_IOERR | (15<<8))Ù?#define SQLITE_IOERR_CLOSE             (SQLITE_IOERR | (16<<8))Ù?#define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR | (17<<8))Ù?#define SQLITE_IOERR_SHMOPEN           (SQLITE_IOERR | (18<<8))Ù?#define SQLITE_IOERR_SHMSIZE           (SQLITE_IOERR | (19<<8))Ù?#define SQLITE_IOERR_SHMLOCK           (SQLITE_IOERR | (20<<8))Ù?#define SQLITE_IOERR_SHMMAP            (SQLITE_IOERR | (21<<8))Ù?#define SQLITE_IOERR_SEEK              (SQLITE_IOERR | (22<<8))Ù?#define SQLITE_IOERR_DELETE_NOENT      (SQLITE_IOERR | (23<<8))Ù?#define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))Ù?#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))Ù?#define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))Ù?#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))Ù?#define SQLITE_IOERR_AUTH              (SQLITE_IOERR | (28<<8))Ù?#define SQLITE_IOERR_BEGIN_ATOMIC      (SQLITE_IOERR | (29<<8))Ù?#define SQLITE_IOERR_COMMIT_ATOMIC     (SQLITE_IOERR | (30<<8))Ù?#define SQLITE_IOERR_ROLLBACK_ATOMIC   (SQLITE_IOERR | (31<<8))Ù@#define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))Ù@#define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))Ù@#define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))ÙA#define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1<<8))ÙA#define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2<<8))ÙA#define SQLITE_CANTOPEN_FULLPATH       (SQLITE_CANTOPEN | (3<<8))ÙA#define SQLITE_CANTOPEN_CONVPATH       (SQLITE_CANTOPEN | (4<<8))Ù@#define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1<<8))ÙA#define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1<<8))ÙA#define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2<<8))ÙA#define SQLITE_READONLY_ROLLBACK       (SQLITE_READONLY | (3<<8))ÙA#define SQLITE_READONLY_DBMOVED        (SQLITE_READONLY | (4<<8))ÙA#define SQLITE_READONLY_CANTINIT       (SQLITE_READONLY | (5<<8))ÙA#define SQLITE_READONLY_DIRECTORY      (SQLITE_READONLY | (6<<8))Ù>#define SQLITE_ABORT_ROLLBACK          (SQLITE_ABORT | (2<<8))ÙC#define SQLITE_CONSTRAINT_CHECK        (SQLITE_CONSTRAINT | (1<<8))ÙC#define SQLITE_CONSTRAINT_COMMITHOOK   (SQLITE_CONSTRAINT | (2<<8))ÙC#define SQLITE_CONSTRAINT_FOREIGNKEY   (SQLITE_CONSTRAINT | (3<<8))ÙC#define SQLITE_CONSTRAINT_FUNCTION     (SQLITE_CONSTRAINT | (4<<8))ÙC#define SQLITE_CONSTRAINT_NOTNULL      (SQLITE_CONSTRAINT | (5<<8))ÙC#define SQLITE_CONSTRAINT_PRIMARYKEY   (SQLITE_CONSTRAINT | (6<<8))ÙC#define SQLITE_CONSTRAINT_TRIGGER      (SQLITE_CONSTRAINT | (7<<8))ÙC#define SQLITE_CONSTRAINT_UNIQUE       (SQLITE_CONSTRAINT | (8<<8))ÙC#define SQLITE_CONSTRAINT_VTAB         (SQLITE_CONSTRAINT | (9<<8))ÙC#define SQLITE_CONSTRAINT_ROWID        (SQLITE_CONSTRAINT |(10<<8))Ù?#define SQLITE_NOTICE_RECOVER_WAL      (SQLITE_NOTICE | (1<<8))Ù?#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))Ù@#define SQLITE_WARNING_AUTOINDEX       (SQLITE_WARNING | (1<<8))Ù=#define SQLITE_AUTH_USER               (SQLITE_AUTH | (1<<8))Ù;#define SQLITE_OK_LOAD_PERMANENTLY     (SQLITE_OK | (1<<8)) ¢/*Ù+** CAPI3REF: Flags For File Open Operations¢**Ù/** These bit values are intended for use in theÙ9** 3rd parameter to the [sqlite3_open_v2()] interface andÙ:** in the 4th parameter to the [sqlite3_vfs.xOpen] method.¢*/ÙO#define SQLITE_OPEN_READONLY         0x00000001  /* Ok for sqlite3_open_v2() */ÙO#define SQLITE_OPEN_READWRITE        0x00000002  /* Ok for sqlite3_open_v2() */ÙO#define SQLITE_OPEN_CREATE           0x00000004  /* Ok for sqlite3_open_v2() */Ù?#define SQLITE_OPEN_DELETEONCLOSE    0x00000008  /* VFS only */Ù?#define SQLITE_OPEN_EXCLUSIVE        0x00000010  /* VFS only */Ù?#define SQLITE_OPEN_AUTOPROXY        0x00000020  /* VFS only */ÙO#define SQLITE_OPEN_URI              0x00000040  /* Ok for sqlite3_open_v2() */ÙO#define SQLITE_OPEN_MEMORY           0x00000080  /* Ok for sqlite3_open_v2() */Ù?#define SQLITE_OPEN_MAIN_DB          0x00000100  /* VFS only */Ù?#define SQLITE_OPEN_TEMP_DB          0x00000200  /* VFS only */Ù?#define SQLITE_OPEN_TRANSIENT_DB     0x00000400  /* VFS only */Ù?#define SQLITE_OPEN_MAIN_JOURNAL     0x00000800  /* VFS only */Ù?#define SQLITE_OPEN_TEMP_JOURNAL     0x00001000  /* VFS only */Ù?#define SQLITE_OPEN_SUBJOURNAL       0x00002000  /* VFS only */Ù?#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  /* VFS only */ÙO#define SQLITE_OPEN_NOMUTEX          0x00008000  /* Ok for sqlite3_open_v2() */ÙO#define SQLITE_OPEN_FULLMUTEX        0x00010000  /* Ok for sqlite3_open_v2() */ÙO#define SQLITE_OPEN_SHAREDCACHE      0x00020000  /* Ok for sqlite3_open_v2() */ÙO#define SQLITE_OPEN_PRIVATECACHE     0x00040000  /* Ok for sqlite3_open_v2() */Ù?#define SQLITE_OPEN_WAL              0x00080000  /* VFS only */ Ù2/* Reserved:                         0x00F00000 */ ¢/*Ù#** CAPI3REF: Device Characteristics¢**Ù@** The xDeviceCharacteristics method of the [sqlite3_io_methods]Ù7** object returns an integer which is a vector of theseÙ@** bit values expressing I/O characteristics of the mass storageÙ;** device that holds the file that the [sqlite3_io_methods]­** refers to.¢**Ù<** The SQLITE_IOCAP_ATOMIC property means that all writes ofÙ:** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn valuesÙ<** mean that writes of blocks that are nnn bytes in size andÙ<** are aligned to an address which is an integer multiple ofÙ<** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value meansÙ=** that when data is appended to a file, the data is appendedÙ?** first then the size of the file is extended, never the otherÙ?** way around.  The SQLITE_IOCAP_SEQUENTIAL property means thatÙ<** information is written to disk in the same order as callsÙI** to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means thatÙD** after reboot following a crash or power loss, the only bytes in aÙE** file that were written at the application level might have changedÙA** and that adjacent bytes, even bytes within the same sector areÙF** guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPENÙ?** flag indicates that a file cannot be deleted when open.  TheÙ<** SQLITE_IOCAP_IMMUTABLE flag indicates that the file is onÙ?** read-only media and cannot be changed even by processes with·** elevated privileges.¢**ÙC** The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlyingÙL** filesystem supports doing multiple write operations atomically when thoseÙJ** write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] andÙ&** [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].¢*/Ù6#define SQLITE_IOCAP_ATOMIC                 0x00000001Ù6#define SQLITE_IOCAP_ATOMIC512              0x00000002Ù6#define SQLITE_IOCAP_ATOMIC1K               0x00000004Ù6#define SQLITE_IOCAP_ATOMIC2K               0x00000008Ù6#define SQLITE_IOCAP_ATOMIC4K               0x00000010Ù6#define SQLITE_IOCAP_ATOMIC8K               0x00000020Ù6#define SQLITE_IOCAP_ATOMIC16K              0x00000040Ù6#define SQLITE_IOCAP_ATOMIC32K              0x00000080Ù6#define SQLITE_IOCAP_ATOMIC64K              0x00000100Ù6#define SQLITE_IOCAP_SAFE_APPEND            0x00000200Ù6#define SQLITE_IOCAP_SEQUENTIAL             0x00000400Ù6#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  0x00000800Ù6#define SQLITE_IOCAP_POWERSAFE_OVERWRITE    0x00001000Ù6#define SQLITE_IOCAP_IMMUTABLE              0x00002000Ù6#define SQLITE_IOCAP_BATCH_ATOMIC           0x00004000 ¢/*Ù ** CAPI3REF: File Locking Levels¢**Ù8** SQLite uses one of these integer values as the secondÙB** argument to calls it makes to the xLock() and xUnlock() methodsÙ%** of an [sqlite3_io_methods] object.¢*/Ù##define SQLITE_LOCK_NONE          0Ù##define SQLITE_LOCK_SHARED        1Ù##define SQLITE_LOCK_RESERVED      2Ù##define SQLITE_LOCK_PENDING       3Ù##define SQLITE_LOCK_EXCLUSIVE     4 ¢/*Ù'** CAPI3REF: Synchronization Type Flags¢**Ù/** When SQLite invokes the xSync() method of anÙ7** [sqlite3_io_methods] object it uses a combination ofÙ/** these integer values as the second argument.¢**Ù@** When the SQLITE_SYNC_DATAONLY flag is used, it means that theÙB** sync operation only needs to flush data to mass storage.  InodeÙF** information need not be flushed. If the lower four bits of the flagÙH** equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.Ù<** If the lower four bits equal SQLITE_SYNC_FULL, that meansÙ5** to use Mac OS X style fullsync instead of fsync().¢**ÙC** Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flagsÙE** with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULLÙC** settings.  The [synchronous pragma] determines when calls to theÙE** xSync VFS method occur and applies uniformly across all platforms.ÙB** The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine howÙ@** energetic or rigorous or forceful the sync operations are andÙA** only make a difference on Mac OSX for the default SQLite code.ÙC** (Third-party VFS implementations might also make the distinctionÙA** between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among theÙ?** operating systems natively supported by SQLite, only Mac OSX¿** cares about the difference.)¢*/Ù)#define SQLITE_SYNC_NORMAL        0x00002Ù)#define SQLITE_SYNC_FULL          0x00003Ù)#define SQLITE_SYNC_DATAONLY      0x00010 ¢/*Ù*** CAPI3REF: OS Interface Open File Handle¢**Ù;** An [sqlite3_file] object represents an open file in the Ù?** [sqlite3_vfs | OS interface layer].  Individual OS interface·** implementations willÙ>** want to subclass this object by appending additional fieldsÙ<** for their own use.  The pMethods entry is a pointer to anÙB** [sqlite3_io_methods] object that defines methods for performingÙ#** I/O operations on the open file.¢*/Ù)typedef struct sqlite3_file sqlite3_file;µstruct sqlite3_file {ÙL  const struct sqlite3_io_methods *pMethods;  /* Methods for an open file */¢}; ¢/*Ù5** CAPI3REF: OS Interface File Virtual Methods Object¢**ÙC** Every file opened by the [sqlite3_vfs.xOpen] method populates anÙ>** [sqlite3_file] object (or, more commonly, a subclass of theÙG** [sqlite3_file] object) with a pointer to an instance of this object.ÙE** This object defines the methods used to perform various operationsÙB** against the open file represented by the [sqlite3_file] object.¢**ÙL** If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element ÙC** to a non-NULL pointer, then the sqlite3_io_methods.xClose methodÙO** may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  TheÙN** only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]ÙJ** is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element«** to NULL.¢**ÙD** The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] orÙ?** [SQLITE_SYNC_FULL].  The first choice is the normal fsync().ÙN** The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]ÙA** flag may be ORed in to indicate that only the data of the fileÙ(** and not its inode needs to be synced.¢**Ù9** The integer values to xLock() and xUnlock() are one of§** <ul>»** <li> [SQLITE_LOCK_NONE],½** <li> [SQLITE_LOCK_SHARED],¿** <li> [SQLITE_LOCK_RESERVED],Ù!** <li> [SQLITE_LOCK_PENDING], orÙ ** <li> [SQLITE_LOCK_EXCLUSIVE].¨** </ul>Ù<** xLock() increases the lock. xUnlock() decreases the lock.ÙJ** The xCheckReservedLock() method checks whether any database connection,ÙJ** either in this process or in some other process, is holding a RESERVED,Ù;** PENDING, or EXCLUSIVE lock on the file.  It returns trueÙ-** if such a lock exists and false otherwise.¢**ÙF** The xFileControl() method is a generic interface that allows customÙA** VFS implementations to directly control an open file using theÙF** [sqlite3_file_control()] interface.  The second "op" argument is anÙG** integer opcode.  The third argument is a generic pointer intended toÙG** point to a structure that may contain arguments or space in which toÙC** write return values.  Potential uses for xFileControl() might beÙB** functions to enable blocking locks with timeouts, to change theÙC** locking strategy (for example to use dot-file locks), to inquireÙC** about the status of a lock, or to break stale locks.  The SQLiteÙ;** core reserves all opcodes less than 100 for its own use.ÙI** A [file control opcodes | list of opcodes] less than 100 is available.ÙK** Applications that define a custom xFileControl method should use opcodesÙC** greater than 100 to avoid conflicts.  VFS implementations shouldÙE** return [SQLITE_NOTFOUND] for file control opcodes that they do not­** recognize.¢**Ù:** The xSectorSize() method returns the sector size of theÙ:** device that underlies the file.  The sector size is theÙ9** minimum write that can be performed without disturbingÙ9** other bytes in the file.  The xDeviceCharacteristics()Ù:** method returns a bit vector describing behaviors of theµ** underlying device:¢**§** <ul>½** <li> [SQLITE_IOCAP_ATOMIC]Ù ** <li> [SQLITE_IOCAP_ATOMIC512]¿** <li> [SQLITE_IOCAP_ATOMIC1K]¿** <li> [SQLITE_IOCAP_ATOMIC2K]¿** <li> [SQLITE_IOCAP_ATOMIC4K]¿** <li> [SQLITE_IOCAP_ATOMIC8K]Ù ** <li> [SQLITE_IOCAP_ATOMIC16K]Ù ** <li> [SQLITE_IOCAP_ATOMIC32K]Ù ** <li> [SQLITE_IOCAP_ATOMIC64K]Ù"** <li> [SQLITE_IOCAP_SAFE_APPEND]Ù!** <li> [SQLITE_IOCAP_SEQUENTIAL]Ù,** <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]Ù*** <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]Ù ** <li> [SQLITE_IOCAP_IMMUTABLE]Ù#** <li> [SQLITE_IOCAP_BATCH_ATOMIC]¨** </ul>¢**Ù<** The SQLITE_IOCAP_ATOMIC property means that all writes ofÙ:** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn valuesÙ<** mean that writes of blocks that are nnn bytes in size andÙ<** are aligned to an address which is an integer multiple ofÙ<** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value meansÙ=** that when data is appended to a file, the data is appendedÙ?** first then the size of the file is extended, never the otherÙ?** way around.  The SQLITE_IOCAP_SEQUENTIAL property means thatÙ<** information is written to disk in the same order as calls¯** to xWrite().¢**Ù?** If xRead() returns SQLITE_IOERR_SHORT_READ it must also fillÙ?** in the unread portions of the buffer with zeros.  A VFS thatÙ?** fails to zero-fill short reads might seem to work.  However,Ù;** failure to zero-fill short reads will eventually lead to·** database corruption.¢*/Ù5typedef struct sqlite3_io_methods sqlite3_io_methods;»struct sqlite3_io_methods {¯  int iVersion;¿  int (*xClose)(sqlite3_file*);ÙD  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);ÙK  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);Ù6  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);Ù)  int (*xSync)(sqlite3_file*, int flags);Ù8  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);Ù#  int (*xLock)(sqlite3_file*, int);Ù%  int (*xUnlock)(sqlite3_file*, int);Ù9  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);Ù9  int (*xFileControl)(sqlite3_file*, int op, void *pArg);Ù$  int (*xSectorSize)(sqlite3_file*);Ù/  int (*xDeviceCharacteristics)(sqlite3_file*);Ù-  /* Methods above are valid for version 1 */ÙI  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);Ù?  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);Ù%  void (*xShmBarrier)(sqlite3_file*);Ù2  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);Ù-  /* Methods above are valid for version 2 */ÙI  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);Ù?  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);Ù-  /* Methods above are valid for version 3 */Ù:  /* Additional methods may be added in future releases */¢}; ¢/*Ù*** CAPI3REF: Standard File Control OpcodesÙ9** KEYWORDS: {file control opcodes} {file control opcode}¢**ÙB** These integer constants are opcodes for the xFileControl methodÙJ** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]­** interface.¢**§** <ul>Ù!** <li>[[SQLITE_FCNTL_LOCKSTATE]]ÙC** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  ThisÙF** opcode causes the xFileControl method to write the current state ofÙ=** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],ÙM** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])ÙD** into an integer that the pArg argument points to. This capabilityÙD** is used during testing and is only available when the SQLITE_TEST¿** compile-time option is used.¢**Ù!** <li>[[SQLITE_FCNTL_SIZE_HINT]]ÙH** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFSÙI** layer a hint of how large the database file will grow to be during theÙJ** current transaction.  This hint is not guaranteed to be accurate but itÙK** is often close.  The underlying VFS might choose to preallocate databaseÙH** file space based on this hint in order to help writes to the database³** file run faster.¢**Ù"** <li>[[SQLITE_FCNTL_CHUNK_SIZE]]ÙG** The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFSÙH** extends and truncates the database file in chunks of a size specifiedÙG** by the user. The fourth argument to [sqlite3_file_control()] should ÙF** point to an integer (type int) containing the new chunk-size to useÙF** for the nominated database. Allocating database file space in largeÙG** chunks (say 1MB at a time), may reduce file-system fragmentation andÙ'** improve performance on some systems.¢**Ù$** <li>[[SQLITE_FCNTL_FILE_POINTER]]ÙE** The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointerÙE** to the [sqlite3_file] object associated with a particular databaseÙ8** connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].¢**Ù'** <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]ÙH** The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointerÙH** to the [sqlite3_file] object associated with the journal file (eitherÙM** the [rollback journal] or the [write-ahead log]) for a particular databaseÙ5** connection.  See also [SQLITE_FCNTL_FILE_POINTER].¢**Ù$** <li>[[SQLITE_FCNTL_SYNC_OMITTED]]´** No longer in use.¢**¼** <li>[[SQLITE_FCNTL_SYNC]]ÙG** The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite andÙF** sent to the VFS immediately before the xSync method is invoked on aÙD** database file descriptor. Or, if the xSync method is not invoked Ù/** because the user has configured SQLite with ÙH** [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place ÙG** of the xSync method. In most cases, the pointer argument passed withÙK** this file-control is NULL. However, if the database file is being syncedÙN** as part of a multi-database commit, the argument points to a nul-terminatedÙK** string containing the transactions master-journal file name. VFSes that ÙL** do not need this signal should silently ignore this opcode. Applications ÙM** should not call [sqlite3_file_control()] with this opcode as doing so may ÙG** disrupt the operation of the specialized VFSes that do require it.  ¢**Ù'** <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]ÙN** The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLiteÙI** and sent to the VFS after a transaction has been committed immediatelyÙJ** but before the database is unlocked. VFSes that do not need this signalÙC** should silently ignore this opcode. Applications should not callÙI** [sqlite3_file_control()] with this opcode as doing so may disrupt the Ù;** operation of the specialized VFSes that do require it.  ¢**Ù&** <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]ÙK** ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automaticÙE** retry counts and intervals for certain disk I/O operations for theÙB** windows [VFS] in order to provide robustness in the presence ofÙJ** anti-virus programs.  By default, the windows VFS will retry file read,ÙF** file write, and file delete operations up to 10 times, with a delayÙJ** of 25 milliseconds before the first retry and with the delay increasingÙE** by an additional 25 milliseconds with each subsequent retry.  ThisÙK** opcode allows these two values (10 retries and 25 milliseconds of delay)ÙG** to be adjusted.  The values are changed for all database connectionsÙI** within the same process.  The argument is a pointer to an array of twoÙI** integers where the first integer is the new retry count and the secondÙI** integer is the delay.  If either integer is negative, then the settingÙH** is not changed but instead the prior value of that setting is writtenÙB** into the array entry, allowing the current retry settings to beÙ3** interrogated.  The zDbName parameter is ignored.¢**Ù#** <li>[[SQLITE_FCNTL_PERSIST_WAL]]ÙE** ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query theÙI** persistent [WAL | Write Ahead Log] setting.  By default, the auxiliaryÙG** write ahead log and shared memory files used for transaction controlÙG** are automatically deleted when the latest connection to the databaseÙK** closes.  Setting persistent WAL mode causes those files to persist afterÙJ** close.  Persisting the files is useful when other processes that do notÙK** have write permission on the directory containing the database file wantÙK** to read the database file, as the WAL and shared memory files must existÙE** in order for the database to be readable.  The fourth parameter toÙN** [sqlite3_file_control()] for this opcode should be a pointer to an integer.ÙM** That integer is 0 to disable persistent WAL mode or 1 to enable persistentÙK** WAL mode.  If the integer is -1, then it is overwritten with the current»** WAL persistence setting.¢**Ù+** <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]ÙM** ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query theÙH** persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW settingÙ?** determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of theÙ:** xDeviceCharacteristics methods. The fourth parameter toÙN** [sqlite3_file_control()] for this opcode should be a pointer to an integer.ÙK** That integer is 0 to disable zero-damage mode or 1 to enable zero-damageÙG** mode.  If the integer is -1, then it is overwritten with the current¼** zero-damage mode setting.¢**Ù!** <li>[[SQLITE_FCNTL_OVERWRITE]]ÙJ** ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after openingÙJ** a write transaction to indicate that, unless it is rolled back for someÙG** reason, the entire database file will be overwritten by the current Ù2** transaction. This is used by VACUUM operations.¢**¿** <li>[[SQLITE_FCNTL_VFSNAME]]ÙH** ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names ofÙH** all [VFSes] in the VFS stack.  The names are of all VFS shims and theÙ@** final bottom-level VFS are written into memory obtained from ÙD** [sqlite3_malloc()] and the result is stored in the char* variableÙC** that the fourth parameter of [sqlite3_file_control()] points to.ÙG** The caller is responsible for freeing the memory when done.  As withÙJ** all file-control actions, there is no guarantee that this will actuallyÙG** do anything.  Callers should initialize the char* variable to a NULLÙK** pointer in case this file-control is not implemented.  This file-controlÙ'** is intended for diagnostic use only.¢**Ù#** <li>[[SQLITE_FCNTL_VFS_POINTER]]ÙJ** ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-levelÙ1** [VFSes] currently in use.  ^(The argument X inÙ>** sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must beÙ8** of type "[sqlite3_vfs] **".  This opcodes will set *XÙ'** to a pointer to the top-level VFS.)^ÙI** ^When there are multiple VFS shims in the stack, this opcode finds the¸** upper-most shim only.¢**¾** <li>[[SQLITE_FCNTL_PRAGMA]]ÙF** ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA] ÙG** file control is sent to the open [sqlite3_file] object correspondingÙK** to the database file to which the pragma statement refers. ^The argumentÙ;** to the [SQLITE_FCNTL_PRAGMA] file control is an array ofÙH** pointers to strings (char**) in which the second element of the arrayÙI** is the name of the pragma and the third element is the argument to theÙE** pragma or NULL if the pragma has no argument.  ^The handler for anÙK** [SQLITE_FCNTL_PRAGMA] file control can optionally make the first elementÙM** of the char** argument point to a string obtained from [sqlite3_mprintf()]ÙL** or the equivalent and that string will become the result of the pragma orÙ1** the error message if the pragma fails. ^If theÙM** [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal Ù@** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]ÙE** file control returns [SQLITE_OK], then the parser assumes that theÙE** VFS has handled the PRAGMA itself and the parser generates a no-opÙF** prepared statement if result string is NULL, or that returns a copyÙ2** of the result string if the string is non-NULL.Ù5** ^If the [SQLITE_FCNTL_PRAGMA] file control returnsÙJ** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that meansÙH** that the VFS encountered an error while handling the [PRAGMA] and theÙM** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]ÙK** file control occurs at the beginning of pragma statement analysis and soÙ7** it is able to override built-in [PRAGMA] statements.¢**Ù#** <li>[[SQLITE_FCNTL_BUSYHANDLER]]Ù"** ^The [SQLITE_FCNTL_BUSYHANDLER]ÙD** file-control may be invoked by SQLite on the database file handleÙJ** shortly after it is opened in order to provide a custom VFS with accessÙN** to the connections busy-handler callback. The argument is of type (void **)ÙH** - an array of two (void *) values. The first (void *) actually pointsÙN** to a function of type (int (*)(void *)). In order to invoke the connectionsÙL** busy-handler, this function should be invoked with the second (void *) inÙM** the array as the only argument. If it returns non-zero, then the operationÙK** should be retried. If it returns zero, the custom VFS should abandon theµ** current operation.¢**Ù$** <li>[[SQLITE_FCNTL_TEMPFILENAME]]ÙG** ^Application can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control¼** to have SQLite generate aÙK** temporary filename using the same algorithm that is followed to generateÙD** temporary filenames for TEMP tables and other internal uses.  TheÙE** argument should be a char** which will be filled with the filenameÙK** written into memory obtained from [sqlite3_malloc()].  The caller shouldÙ@** invoke [sqlite3_free()] on the result to avoid a memory leak.¢**Ù!** <li>[[SQLITE_FCNTL_MMAP_SIZE]]ÙH** The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set theÙC** maximum number of bytes that will be used for memory-mapped I/O.ÙB** The argument is a pointer to a value of type sqlite3_int64 thatÙI** is an advisory maximum number of bytes in the file to memory map.  TheÙJ** pointer is overwritten with the old value.  The limit is not changed ifÙI** the value originally pointed to is negative, and so the current limit ÙE** can be queried by passing in a pointer to a negative number.  ThisÙC** file-control is used internally to implement [PRAGMA mmap_size].¢**½** <li>[[SQLITE_FCNTL_TRACE]]ÙF** The [SQLITE_FCNTL_TRACE] file control provides advisory informationÙI** to the VFS about what the higher layers of the SQLite stack are doing.ÙB** This file control is used by some VFS activity tracing [shims].ÙB** The argument is a zero-terminated string.  Higher layers in theÙ>** SQLite stack may generate instances of this file control ifÙ?** the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.¢**Ù!** <li>[[SQLITE_FCNTL_HAS_MOVED]]ÙI** The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as aÙL** pointer to an integer and it writes a boolean into that integer dependingÙJ** on whether or not the file has been renamed, moved, or deleted since it´** was first opened.¢**Ù(** <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]ÙG** The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain theÙJ** underlying native file handle associated with a file handle.  This fileÙK** control interprets its argument as a pointer to a native file handle andÙ$** writes the resulting value there.¢**Ù(** <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]ÙJ** The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  ThisÙM** opcode causes the xFileControl method to swap the file handle with the oneÙK** pointed to by the pArg argument.  This capability is used during testingÙ>** and only needs to be supported when SQLITE_TEST is defined.¢**Ù!** <li>[[SQLITE_FCNTL_WAL_BLOCK]]ÙJ** The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it mightÙO** be advantageous to block on the next WAL lock if the lock is not immediatelyÙ?** available.  The WAL subsystem issues this signal during rareÙC** circumstances in order to fix a problem with priority inversion.Ù:** Applications should <em>not</em> use this file-control.¢**¾** <li>[[SQLITE_FCNTL_ZIPVFS]]ÙL** The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All otherÙ5** VFS should return SQLITE_NOTFOUND for this opcode.¢**»** <li>[[SQLITE_FCNTL_RBU]]ÙJ** The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used byÙK** the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for±** this opcode.  ¢**Ù*** <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]ÙJ** If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, thenÙ=** the file descriptor is placed in "batch write mode", whichÙB** means all subsequent write operations will be deferred and doneÙF** atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  SystemsÙG** that do not support batch atomic writes will return SQLITE_NOTFOUND.ÙG** ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior toÙ4** the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] orÙ9** [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will makeÙD** no VFS interface calls on the same [sqlite3_file] file descriptorÙD** except for calls to the xWrite method and the xFileControl methodÙ!** with [SQLITE_FCNTL_SIZE_HINT].¢**Ù+** <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]ÙA** The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all writeÙ4** operations since the previous successful call to Ù@** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.ÙG** This file control returns [SQLITE_OK] if and only if the writes wereÙL** all performed successfully and have been committed to persistent storage.ÙJ** ^Regardless of whether or not it is successful, this file control takesÙE** the file descriptor out of batch write mode so that all subsequentÙ$** write operations are independent.ÙE** ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE withoutÙ@** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].¢**Ù-** <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]ÙC** The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all writeÙ4** operations since the previous successful call to Ù7** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.ÙG** ^This file control takes the file descriptor out of batch write modeÙ;** so that all subsequent write operations are independent.ÙG** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE withoutÙ@** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].¢**Ù$** <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]ÙC** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode causes attempts to obtainÙE** a file lock using the xLock or xShmLock methods of the VFS to waitÙB** for up to M milliseconds before failing, where M is the single ¾** unsigned integer parameter.¨** </ul>¢*/Ù.#define SQLITE_FCNTL_LOCKSTATE               1Ù.#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2Ù.#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3Ù.#define SQLITE_FCNTL_LAST_ERRNO              4Ù.#define SQLITE_FCNTL_SIZE_HINT               5Ù.#define SQLITE_FCNTL_CHUNK_SIZE              6Ù.#define SQLITE_FCNTL_FILE_POINTER            7Ù.#define SQLITE_FCNTL_SYNC_OMITTED            8Ù.#define SQLITE_FCNTL_WIN32_AV_RETRY          9Ù.#define SQLITE_FCNTL_PERSIST_WAL            10Ù.#define SQLITE_FCNTL_OVERWRITE              11Ù.#define SQLITE_FCNTL_VFSNAME                12Ù.#define SQLITE_FCNTL_POWERSAFE_OVERWRITE    13Ù.#define SQLITE_FCNTL_PRAGMA                 14Ù.#define SQLITE_FCNTL_BUSYHANDLER            15Ù.#define SQLITE_FCNTL_TEMPFILENAME           16Ù.#define SQLITE_FCNTL_MMAP_SIZE              18Ù.#define SQLITE_FCNTL_TRACE                  19Ù.#define SQLITE_FCNTL_HAS_MOVED              20Ù.#define SQLITE_FCNTL_SYNC                   21Ù.#define SQLITE_FCNTL_COMMIT_PHASETWO        22Ù.#define SQLITE_FCNTL_WIN32_SET_HANDLE       23Ù.#define SQLITE_FCNTL_WAL_BLOCK              24Ù.#define SQLITE_FCNTL_ZIPVFS                 25Ù.#define SQLITE_FCNTL_RBU                    26Ù.#define SQLITE_FCNTL_VFS_POINTER            27Ù.#define SQLITE_FCNTL_JOURNAL_POINTER        28Ù.#define SQLITE_FCNTL_WIN32_GET_HANDLE       29Ù.#define SQLITE_FCNTL_PDB                    30Ù.#define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE     31Ù.#define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE    32Ù.#define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33Ù.#define SQLITE_FCNTL_LOCK_TIMEOUT           34 ¶/* deprecated names */ÙD#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILEÙD#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILEÙ=#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO  ¢/*¹** CAPI3REF: Mutex Handle¢**ÙB** The mutex module within SQLite defines [sqlite3_mutex] to be anÙA** abstract type for a mutex object.  The SQLite core never looksÙA** at the internal representation of an [sqlite3_mutex].  It onlyÙ5** deals with pointers to the [sqlite3_mutex] object.¢**Ù5** Mutexes are created using [sqlite3_mutex_alloc()].¢*/Ù+typedef struct sqlite3_mutex sqlite3_mutex; ¢/*Ù%** CAPI3REF: Loadable Extension Thunk¢**ÙF** A pointer to the opaque sqlite3_api_routines structure is passed asÙF** the third parameter to entry points of [loadable extensions].  ThisÙH** structure must be typedefed in order to work around compiler warningsµ** on some platforms.¢*/Ù9typedef struct sqlite3_api_routines sqlite3_api_routines; ¢/*Ù ** CAPI3REF: OS Interface Object¢**ÙF** An instance of the sqlite3_vfs object defines the interface betweenÙB** the SQLite core and the underlying operating system.  The "vfs"ÙC** in the name of the object stands for "virtual file system".  SeeÙ9** the [VFS | VFS documentation] for further information.¢**ÙE** The VFS interface is sometimes extended by adding new methods ontoÙC** the end.  Each time such an extension occurs, the iVersion fieldÙ:** is incremented.  The iVersion value started out as 1 inÙ@** SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2ÙD** with SQLite [version 3.7.0] on [dateof:3.7.0], and then increasedÙI** to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fieldsÙC** may be appended to the sqlite3_vfs object and the iVersion valueÙ3** may increase again in future versions of SQLite.º** Note that the structureÙ;** of the sqlite3_vfs object changes in the transition fromÙ>** SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]Ù/** and yet the iVersion field was not modified.¢**ÙB** The szOsFile field is the size of the subclassed [sqlite3_file]ÙC** structure used by this VFS.  mxPathname is the maximum length ofº** a pathname in this VFS.¢**ÙE** Registered sqlite3_vfs objects are kept on a linked list formed byÙ3** the pNext pointer.  The [sqlite3_vfs_register()]Ù=** and [sqlite3_vfs_unregister()] interfaces manage this listÙ<** in a thread-safe way.  The [sqlite3_vfs_find()] interfaceÙ?** searches the list.  Neither the application code nor the VFSÙ/** implementation should use the pNext pointer.¢**Ù7** The pNext field is the only field in the sqlite3_vfsÙC** structure that SQLite will ever modify.  SQLite will only accessÙ@** or modify this field while holding a particular static mutex.ÙF** The application should never modify anything within the sqlite3_vfsÙ.** object once the object has been registered.¢**ÙC** The zName field holds the name of the VFS module.  The name mustÙ$** be unique across all VFS modules.¢**¸** [[sqlite3_vfs.xOpen]]Ù;** ^SQLite guarantees that the zFilename parameter to xOpenÙ.** is either a NULL pointer or string obtainedÙ6** from xFullPathname() with an optional suffix added.Ù<** ^If a suffix is added to the zFilename parameter, it willÙ=** consist of a single "-" character followed by no more thanÙ)** 11 alphanumeric and/or "-" characters.Ù"** ^SQLite further guarantees thatÙ;** the string will be valid and unchanged until xClose() isÙ,** called. Because of the previous sentence,Ù7** the [sqlite3_file] can safely store a pointer to theÙA** filename if it needs to remember the filename for some reason.ÙC** If the zFilename parameter to xOpen is a NULL pointer then xOpenÙC** must invent its own temporary name for the file.  ^Whenever the Ù@** xFilename parameter is NULL it will also be the case that theÙ<** flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].¢**Ù9** The flags argument to xOpen() includes all bits set inÙE** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]Ù>** or [sqlite3_open16()] is used, then flags includes at leastÙ3** [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]. Ù?** If xOpen() opens a file read-only then it sets *pOutFlags toÙH** include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.¢**ÙC** ^(SQLite will also add one of the following flags to the xOpen()Ù.** call, depending on the object being opened:¢**§** <ul>¾** <li>  [SQLITE_OPEN_MAIN_DB]Ù#** <li>  [SQLITE_OPEN_MAIN_JOURNAL]¾** <li>  [SQLITE_OPEN_TEMP_DB]Ù#** <li>  [SQLITE_OPEN_TEMP_JOURNAL]Ù#** <li>  [SQLITE_OPEN_TRANSIENT_DB]Ù!** <li>  [SQLITE_OPEN_SUBJOURNAL]Ù%** <li>  [SQLITE_OPEN_MASTER_JOURNAL]º** <li>  [SQLITE_OPEN_WAL]ª** </ul>)^¢**Ù?** The file I/O implementation can use the object type flags toÙC** change the way it deals with files.  For example, an applicationÙA** that does not care about crash recovery or rollback might makeÙD** the open of a journal file a no-op.  Writes to this journal wouldÙC** also be no-ops, and any attempt to read the journal would returnÙG** SQLITE_IOERR.  Or the implementation might recognize that a databaseÙF** file will be doing page-aligned sector reads and writes in a randomÙ2** order and set up its I/O subsystem accordingly.¢**ÙH** SQLite might also add one of the following flags to the xOpen method:¢**§** <ul>Ù#** <li> [SQLITE_OPEN_DELETEONCLOSE]¿** <li> [SQLITE_OPEN_EXCLUSIVE]¨** </ul>¢**Ù@** The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should beÙ?** deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]Ù?** will be set for TEMP databases and their journals, transient¾** databases, and subjournals.¢**ÙB** ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunctionÙ>** with the [SQLITE_OPEN_CREATE] flag, which are both directlyÙ@** analogous to the O_EXCL and O_CREAT flags of the POSIX open()Ù>** API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the ÙB** SQLITE_OPEN_CREATE, is used to indicate that file should alwaysÙ<** be created, and that it is an error if it already exists.Ù?** It is <i>not</i> used to indicate the file should be opened ¸** for exclusive access.¢**Ù=** ^At least szOsFile bytes of memory are allocated by SQLiteÙ<** to hold the  [sqlite3_file] structure passed as the thirdÙ8** argument to xOpen.  The xOpen method does not have toÙ@** allocate the structure; it should just fill it in.  Note thatÙ@** the xOpen method must set the sqlite3_file.pMethods to eitherÙA** a valid [sqlite3_io_methods] object or to NULL.  xOpen must doÙN** this even if the open fails.  SQLite expects that the sqlite3_file.pMethodsÙF** element will be valid after xOpen returns regardless of the successÙ ** or failure of the xOpen call.¢**º** [[sqlite3_vfs.xAccess]]ÙA** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]ÙG** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] toÙH** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]ÙC** to test whether a file is at least readable.   The file can be a­** directory.¢**ÙC** ^SQLite will always allocate at least mxPathname+1 bytes for theÙD** output buffer xFullPathname.  The exact size of the output bufferÙG** is also passed as a parameter to both  methods. If the output bufferÙK** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this isÙJ** handled as a fatal error by SQLite, vfs implementations should endeavorÙG** to prevent this by setting mxPathname to a sufficiently large value.¢**ÙG** The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()ÙE** interfaces are not strictly a part of the filesystem, but they areÙ2** included in the VFS structure for completeness.Ù=** The xRandomness() function attempts to return nBytes bytesÙ=** of good-quality randomness into zOut.  The return value isÙ5** the actual number of bytes of randomness obtained.Ù@** The xSleep() method causes the calling thread to sleep for atÙ?** least the number of microseconds given.  ^The xCurrentTime()ÙF** method returns a Julian Day Number for the current date and time asº** a floating point value.ÙE** ^The xCurrentTimeInt64() method returns, as an integer, the JulianÙD** Day Number multiplied by 86400000 (the number of milliseconds in ´** a 24-hour day).  ÙE** ^SQLite will use the xCurrentTimeInt64() method to get the currentÙB** date and time if that method is available (if iVersion is 2 or ÙC** greater and the function pointer is not NULL) and will fall backÙ;** to xCurrentTime() if xCurrentTimeInt64() is unavailable.¢**ÙL** ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfacesÙK** are not used by the SQLite core.  These optional interfaces are providedÙF** by some VFSes to facilitate testing of the VFS code. By overriding ÙD** system calls with functions under its control, a test program canÙI** simulate faults and error conditions that would otherwise be difficultÙK** or impossible to induce.  The set of system calls that can be overriddenÙN** varies from one VFS to another, and from one version of the same VFS to theÙI** next.  Applications that use these interfaces must be prepared for anyÙH** or all of these interfaces to be NULL or for their behavior to changeÙI** from one release to the next.  Applications must not attempt to accessÙB** any of these methods if the iVersion of the VFS is less than 3.¢*/Ù'typedef struct sqlite3_vfs sqlite3_vfs;Ù*typedef void (*sqlite3_syscall_ptr)(void);´struct sqlite3_vfs {ÙG  int iVersion;            /* Structure version number (currently 3) */Ù@  int szOsFile;            /* Size of subclassed sqlite3_file */Ù=  int mxPathname;          /* Maximum file pathname length */Ù4  sqlite3_vfs *pNext;      /* Next registered VFS */ÙA  const char *zName;       /* Name of this virtual file system */ÙE  void *pAppData;          /* Pointer to application-specific data */Ù>  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,Ù*               int flags, int *pOutFlags);Ù?  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);ÙK  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);ÙN  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);Ù8  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);Ù;  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);ÙC  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);Ù(  void (*xDlClose)(sqlite3_vfs*, void*);Ù:  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);Ù0  int (*xSleep)(sqlite3_vfs*, int microseconds);Ù-  int (*xCurrentTime)(sqlite3_vfs*, double*);Ù2  int (*xGetLastError)(sqlite3_vfs*, int, char *);¤  /*Ù@  ** The methods above are in version 1 of the sqlite_vfs objectÙC  ** definition.  Those that follow are added in version 2 or later¤  */Ù9  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);¤  /*ÙH  ** The methods above are in versions 1 and 2 of the sqlite_vfs object.Ù/  ** Those below are for version 3 and greater.¤  */ÙN  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);ÙI  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);ÙB  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);¤  /*ÙL  ** The methods above are in versions 1 through 3 of the sqlite_vfs object.ÙA  ** New fields may be appended in future versions.  The iVersionÙ1  ** value will increment whenever this happens. ¤  */¢}; ¢/*Ù-** CAPI3REF: Flags for the xAccess VFS method¢**Ù@** These integer constants can be used as the third parameter toÙA** the xAccess method of an [sqlite3_vfs] object.  They determineÙ>** what kind of permissions the xAccess method is looking for.Ù0** With SQLITE_ACCESS_EXISTS, the xAccess methodÙ)** simply checks whether the file exists.Ù3** With SQLITE_ACCESS_READWRITE, the xAccess methodÙC** checks whether the named directory is both readable and writableÙF** (in other words, if files can be added, removed, and renamed within²** the directory).ÙE** The SQLITE_ACCESS_READWRITE constant is currently used only by theÙF** [temp_store_directory pragma], though this could change in a futureµ** release of SQLite.Ù.** With SQLITE_ACCESS_READ, the xAccess methodÙK** checks whether the file is readable.  The SQLITE_ACCESS_READ constant isÙC** currently unused, though it might be used in a future release ofª** SQLite.¢*/Ù!#define SQLITE_ACCESS_EXISTS    0ÙM#define SQLITE_ACCESS_READWRITE 1   /* Used by PRAGMA temp_store_directory */Ù0#define SQLITE_ACCESS_READ      2   /* Unused */ ¢/*Ù.** CAPI3REF: Flags for the xShmLock VFS method¢**Ù@** These integer constants define the various locking operationsÙ?** allowed by the xShmLock method of [sqlite3_io_methods].  TheÙ<** following are the only legal combinations of flags to the³** xShmLock method:¢**§** <ul>Ù,** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_SHAREDÙ/** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVEÙ.** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_SHAREDÙ1** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE¨** </ul>¢**ÙH** When unlocking, the same SHARED or EXCLUSIVE flag must be supplied asÙ)** was given on the corresponding lock.  ¢**ÙD** The xShmLock method can transition between unlocked and SHARED orÙG** between unlocked and EXCLUSIVE.  It cannot transition between SHARED±** and EXCLUSIVE.¢*/Ù!#define SQLITE_SHM_UNLOCK       1Ù!#define SQLITE_SHM_LOCK         2Ù!#define SQLITE_SHM_SHARED       4Ù!#define SQLITE_SHM_EXCLUSIVE    8 ¢/*Ù#** CAPI3REF: Maximum xShmLock index¢**Ù=** The xShmLock method on [sqlite3_io_methods] may use valuesÙ;** between 0 and this upper bound as its "offset" argument.Ù=** The SQLite core will never attempt to acquire or release a½** lock outside of this range¢*/Ù!#define SQLITE_SHM_NLOCK        8  ¢/*Ù*** CAPI3REF: Initialize The SQLite Library¢**Ù4** ^The sqlite3_initialize() routine initializes theÙ3** SQLite library.  ^The sqlite3_shutdown() routineÙI** deallocates any resources that were allocated by sqlite3_initialize().ÙC** These routines are designed to aid in process initialization andÙ@** shutdown on embedded systems.  Workstation applications usingÙB** SQLite normally do not need to invoke either of these routines.¢**ÙA** A call to sqlite3_initialize() is an "effective" call if it isÙH** the first time sqlite3_initialize() is invoked during the lifetime ofÙJ** the process, or if it is the first time sqlite3_initialize() is invokedÙD** following a call to sqlite3_shutdown().  ^(Only an effective callÙD** of sqlite3_initialize() does any initialization.  All other calls¹** are harmless no-ops.)^¢**ÙI** A call to sqlite3_shutdown() is an "effective" call if it is the firstÙJ** call to sqlite3_shutdown() since the last sqlite3_initialize().  ^(OnlyÙE** an effective call to sqlite3_shutdown() does any deinitialization.ÙE** All other valid calls to sqlite3_shutdown() are harmless no-ops.)^¢**ÙK** The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown()ÙG** is not.  The sqlite3_shutdown() interface must only be called from aÙI** single thread.  All open [database connections] must be closed and allÙ?** other SQLite resources must be deallocated prior to invoking¶** sqlite3_shutdown().¢**Ù8** Among other things, ^sqlite3_initialize() will invokeÙ5** sqlite3_os_init().  Similarly, ^sqlite3_shutdown()Ù ** will invoke sqlite3_os_end().¢**ÙD** ^The sqlite3_initialize() routine returns [SQLITE_OK] on success.ÙD** ^If for some reason, sqlite3_initialize() is unable to initializeÙG** the library (perhaps it is unable to allocate a needed resource suchÙA** as a mutex) it returns an [error code] other than [SQLITE_OK].¢**ÙG** ^The sqlite3_initialize() routine is called internally by many otherÙD** SQLite interfaces so that an application usually does not need toÙG** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]ÙI** calls sqlite3_initialize() so the SQLite library will be automaticallyÙK** initialized when [sqlite3_open()] is called if it has not be initializedÙL** already.  ^However, if SQLite is compiled with the [SQLITE_OMIT_AUTOINIT]ÙH** compile-time option, then the automatic calls to sqlite3_initialize()ÙJ** are omitted and the application must call sqlite3_initialize() directlyÙG** prior to using any other SQLite interface.  For maximum portability,ÙI** it is recommended that applications always invoke sqlite3_initialize()ÙG** directly prior to using any other SQLite interface.  Future releasesÙF** of SQLite may require this.  In other words, the behavior exhibitedÙG** when SQLite is compiled with [SQLITE_OMIT_AUTOINIT] might become theÙ5** default behavior in some future release of SQLite.¢**Ù?** The sqlite3_os_init() routine does operating-system specificÙ>** initialization of the SQLite library.  The sqlite3_os_end()ÙA** routine undoes the effect of sqlite3_os_init().  Typical tasksÙA** performed by these routines include allocation or deallocationÙ;** of static resources, initialization of global variables,Ù;** setting up a default [sqlite3_vfs] module, or setting upÙ4** a default configuration using [sqlite3_config()].¢**Ù?** The application should never invoke either sqlite3_os_init()ÙD** or sqlite3_os_end() directly.  The application should only invokeÙF** sqlite3_initialize() and sqlite3_shutdown().  The sqlite3_os_init()Ù@** interface is called automatically by sqlite3_initialize() andÙA** sqlite3_os_end() is called by sqlite3_shutdown().  AppropriateÙ=** implementations for sqlite3_os_init() and sqlite3_os_end()ÙH** are built into SQLite when it is compiled for Unix, Windows, or OS/2.Ù3** When [custom builds | built for other platforms]Ù.** (using the [SQLITE_OS_OTHER=1] compile-timeÙD** option) the application must supply a suitable implementation forÙC** sqlite3_os_init() and sqlite3_os_end().  An application-suppliedÙ:** implementation of sqlite3_os_init() or sqlite3_os_end()ÙF** must return [SQLITE_OK] on success and some other [error code] upon«** failure.¢*/Ù(SQLITE_API int sqlite3_initialize(void);Ù&SQLITE_API int sqlite3_shutdown(void);Ù%SQLITE_API int sqlite3_os_init(void);Ù$SQLITE_API int sqlite3_os_end(void); ¢/*Ù+** CAPI3REF: Configuring The SQLite Library¢**ÙF** The sqlite3_config() interface is used to make global configurationÙE** changes to SQLite in order to tune SQLite to the specific needs ofÙF** the application.  The default configuration is recommended for mostÙD** applications and so this routine is usually not necessary.  It isÙ<** provided to support rare applications with unusual needs.¢**ÙG** <b>The sqlite3_config() interface is not threadsafe. The applicationÙC** must ensure that no other SQLite interfaces are invoked by otherÙ1** threads while sqlite3_config() is running.</b>¢**Ù!** The sqlite3_config() interfaceÙ<** may only be invoked prior to library initialization usingÙD** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].ÙI** ^If sqlite3_config() is called after [sqlite3_initialize()] and beforeÙ:** [sqlite3_shutdown()] then it will return SQLITE_MISUSE.ÙE** Note, however, that ^sqlite3_config() can be called as part of theÙ@** implementation of an application-defined [sqlite3_os_init()].¢**Ù7** The first argument to sqlite3_config() is an integerÙ)** [configuration option] that determinesÙE** what property of SQLite is to be configured.  Subsequent argumentsÙ/** vary depending on the [configuration option]¹** in the first argument.¢**ÙM** ^When a configuration option is set, sqlite3_config() returns [SQLITE_OK].ÙB** ^If the option is unknown or SQLite is unable to set the optionÙ5** then this routine returns a non-zero [error code].¢*/Ù(SQLITE_API int sqlite3_config(int, ...); ¢/*Ù+** CAPI3REF: Configure database connections²** METHOD: sqlite3¢**ÙB** The sqlite3_db_config() interface is used to make configurationÙC** changes to a [database connection].  The interface is similar toÙ?** [sqlite3_config()] except that the changes apply to a singleÙ;** [database connection] (specified in the first argument).¢**Ù<** The second argument to sqlite3_db_config(D,V,...)  is theÙF** [SQLITE_DBCONFIG_LOOKASIDE | configuration verb] - an integer code ÙO** that indicates what aspect of the [database connection] is being configured.ÙA** Subsequent arguments vary depending on the configuration verb.¢**Ù@** ^Calls to sqlite3_db_config() return SQLITE_OK if and only ifÙ%** the call is considered successful.¢*/Ù8SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...); ¢/*Ù'** CAPI3REF: Memory Allocation Routines¢**ÙB** An instance of this object defines the interface between SQLiteÙ,** and low-level memory allocation routines.¢**ÙA** This object is used in only one place in the SQLite interface.Ù=** A pointer to an instance of this object is the argument toÙ6** [sqlite3_config()] when the configuration option isÙ9** [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].  Ù)** By creating an instance of this objectÙ=** and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])ÙB** during configuration, an application can specify an alternativeÙ?** memory allocation subsystem for SQLite to use for all of its¸** dynamic memory needs.¢**ÙC** Note that SQLite comes with several [built-in memory allocators]ÙL** that are perfectly adequate for the overwhelming majority of applicationsÙI** and that this object is only useful to a tiny minority of applicationsÙC** with specialized memory allocation requirements.  This object isÙH** also used during testing of SQLite in order to specify an alternativeÙE** memory allocator that simulates memory out-of-memory conditions inÙ<** order to verify that SQLite recovers gracefully from such®** conditions.¢**Ù>** The xMalloc, xRealloc, and xFree methods must work like theÙH** malloc(), realloc() and free() functions from the standard C library.Ù1** ^SQLite guarantees that the second argument toÙC** xRealloc is always a value returned by a prior call to xRoundup.¢**Ù@** xSize should return the allocated size of a memory allocationÙD** previously obtained from xMalloc or xRealloc.  The allocated sizeÙE** is always at least as big as the requested size but may be larger.¢**ÙB** The xRoundup method returns what would be the allocated size ofÙF** a memory allocation given a particular requested size.  Most memoryÙG** allocators round up memory allocations at least to the next multipleÙK** of 8.  Some allocators round up to a larger multiple or to a power of 2.ÙG** Every memory allocation request coming in through [sqlite3_malloc()]ÙH** or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0, Ù;** that causes the corresponding memory allocation to fail.¢**ÙC** The xInit method initializes the memory allocator.  For example,ÙD** it might allocate any require mutexes or initialize internal dataÙ?** structures.  The xShutdown method is invoked (indirectly) byÙD** [sqlite3_shutdown()] and should deallocate any resources acquiredÙC** by xInit.  The pAppData pointer is used as the only parameter to·** xInit and xShutdown.¢**ÙF** SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokesÙE** the xInit method, so the xInit method need not be threadsafe.  TheÙG** xShutdown method is only called from [sqlite3_shutdown()] so it doesÙC** not need to be threadsafe either.  For all other methods, SQLiteÙ;** holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as theÙE** [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (whichÙE** it is by default) and so the methods are automatically serialized.ÙD** However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the otherÙE** methods must be threadsafe or else make their own arrangements for±** serialization.¢**ÙI** SQLite will never invoke xInit() more than once without an intervening·** call to xShutdown().¢*/Ù7typedef struct sqlite3_mem_methods sqlite3_mem_methods;¼struct sqlite3_mem_methods {ÙA  void *(*xMalloc)(int);         /* Memory allocation function */Ù>  void (*xFree)(void*);          /* Free a prior allocation */Ù;  void *(*xRealloc)(void*,int);  /* Resize an allocation */ÙG  int (*xSize)(void*);           /* Return the size of an allocation */ÙO  int (*xRoundup)(int);          /* Round up request size to allocation size */ÙF  int (*xInit)(void*);           /* Initialize the memory allocator */ÙH  void (*xShutdown)(void*);      /* Deinitialize the memory allocator */ÙJ  void *pAppData;                /* Argument to xInit() and xShutdown() */¢}; ¢/*Ù"** CAPI3REF: Configuration OptionsÙ#** KEYWORDS: {configuration option}¢**ÙG** These constants are the available integer configuration options thatÙK** can be passed as the first argument to the [sqlite3_config()] interface.¢**ÙG** New configuration options may be added in future releases of SQLite.ÙF** Existing configuration options might be discontinued.  ApplicationsÙI** should check the return code from [sqlite3_config()] to make sure thatÙC** the call worked.  The [sqlite3_config()] interface will return aÙN** non-zero [error code] if a discontinued or unsupported configuration option®** is invoked.¢**§** <dl>ÙE** [[SQLITE_CONFIG_SINGLETHREAD]] <dt>SQLITE_CONFIG_SINGLETHREAD</dt>ÙD** <dd>There are no arguments to this option.  ^This option sets theÙB** [threading mode] to Single-thread.  In other words, it disablesÙE** all mutexing and puts SQLite into a mode where it can only be usedÙ4** by a single thread.   ^If SQLite is compiled withÙI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenÙE** it is not possible to change the [threading mode] from its defaultÙ@** value of Single-thread and so [sqlite3_config()] will return Ù?** [SQLITE_ERROR] if called with the SQLITE_CONFIG_SINGLETHREAD½** configuration option.</dd>¢**ÙC** [[SQLITE_CONFIG_MULTITHREAD]] <dt>SQLITE_CONFIG_MULTITHREAD</dt>ÙD** <dd>There are no arguments to this option.  ^This option sets theÙA** [threading mode] to Multi-thread.  In other words, it disablesÙF** mutexing on [database connection] and [prepared statement] objects.Ù;** The application is responsible for serializing access toÙG** [database connections] and [prepared statements].  But other mutexesÙE** are enabled so that SQLite will be safe to use in a multi-threadedÙ@** environment as long as no two threads attempt to use the sameÙG** [database connection] at the same time.  ^If SQLite is compiled withÙI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenÙB** it is not possible to set the Multi-thread [threading mode] andÙC** [sqlite3_config()] will return [SQLITE_ERROR] if called with theÙ7** SQLITE_CONFIG_MULTITHREAD configuration option.</dd>¢**ÙA** [[SQLITE_CONFIG_SERIALIZED]] <dt>SQLITE_CONFIG_SERIALIZED</dt>ÙD** <dd>There are no arguments to this option.  ^This option sets theÙF** [threading mode] to Serialized. In other words, this option enablesÙ&** all mutexes including the recursiveÙE** mutexes on [database connection] and [prepared statement] objects.ÙB** In this mode (which is the default when SQLite is compiled withÙI** [SQLITE_THREADSAFE=1]) the SQLite library will itself serialize accessÙB** to [database connections] and [prepared statements] so that theÙC** application is free to use the same [database connection] or theÙC** same [prepared statement] in different threads at the same time.¾** ^If SQLite is compiled withÙI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenÙ@** it is not possible to set the Serialized [threading mode] andÙC** [sqlite3_config()] will return [SQLITE_ERROR] if called with theÙ6** SQLITE_CONFIG_SERIALIZED configuration option.</dd>¢**Ù9** [[SQLITE_CONFIG_MALLOC]] <dt>SQLITE_CONFIG_MALLOC</dt>ÙK** <dd> ^(The SQLITE_CONFIG_MALLOC option takes a single argument which is ÙC** a pointer to an instance of the [sqlite3_mem_methods] structure.¹** The argument specifiesÙJ** alternative low-level memory allocation routines to be used in place ofÙD** the memory allocation routines built into SQLite.)^ ^SQLite makesÙM** its own private copy of the content of the [sqlite3_mem_methods] structureÙ3** before the [sqlite3_config()] call returns.</dd>¢**Ù?** [[SQLITE_CONFIG_GETMALLOC]] <dt>SQLITE_CONFIG_GETMALLOC</dt>ÙJ** <dd> ^(The SQLITE_CONFIG_GETMALLOC option takes a single argument whichÙF** is a pointer to an instance of the [sqlite3_mem_methods] structure.¼** The [sqlite3_mem_methods]ÙO** structure is filled with the currently defined memory allocation routines.)^ÙD** This option can be used to overload the default memory allocationÙH** routines with a wrapper that simulations memory allocation failure orÙ*** tracks memory usage, for example. </dd>¢**ÙE** [[SQLITE_CONFIG_SMALL_MALLOC]] <dt>SQLITE_CONFIG_SMALL_MALLOC</dt>ÙG** <dd> ^The SQLITE_CONFIG_SMALL_MALLOC option takes single argument ofÙG** type int, interpreted as a boolean, which if true provides a hint toÙD** SQLite that it should avoid large memory allocations if possible.ÙI** SQLite will run faster if it is free to make large memory allocations,ÙB** but some application might prefer to run slower in exchange forÙC** guarantees about memory fragmentation that are possible if largeÙ7** allocations are avoided.  This hint is normally off.¨** </dd>¢**Ù?** [[SQLITE_CONFIG_MEMSTATUS]] <dt>SQLITE_CONFIG_MEMSTATUS</dt>ÙN** <dd> ^The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int,ÙH** interpreted as a boolean, which enables or disables the collection ofÙH** memory allocation statistics. ^(When memory allocation statistics areÙD** disabled, the following SQLite interfaces become non-operational:©**   <ul>Ù!**   <li> [sqlite3_memory_used()]Ù&**   <li> [sqlite3_memory_highwater()]Ù'**   <li> [sqlite3_soft_heap_limit64()]¾**   <li> [sqlite3_status64()]¬**   </ul>)^ÙH** ^Memory allocation statistics are enabled by default unless SQLite isÙB** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memoryÙ1** allocation statistics are disabled by default.¨** </dd>¢**Ù;** [[SQLITE_CONFIG_SCRATCH]] <dt>SQLITE_CONFIG_SCRATCH</dt>Ù;** <dd> The SQLITE_CONFIG_SCRATCH option is no longer used.¨** </dd>¢**Ù?** [[SQLITE_CONFIG_PAGECACHE]] <dt>SQLITE_CONFIG_PAGECACHE</dt>ÙC** <dd> ^The SQLITE_CONFIG_PAGECACHE option specifies a memory poolÙH** that SQLite can use for the database page cache with the default pageº** cache implementation.  ÙE** This configuration option is a no-op if an application-define pageÙD** cache implementation is loaded using the [SQLITE_CONFIG_PCACHE2].ÙF** ^There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer toÙG** 8-byte aligned memory (pMem), the size of each page cache line (sz),Ù%** and the number of cache lines (N).ÙB** The sz argument should be the size of the largest database pageÙH** (a power of two between 512 and 65536) plus some extra bytes for eachÙE** page header.  ^The number of extra bytes needed by the page headerÙ8** can be determined using [SQLITE_CONFIG_PCACHE_HDRSZ].Ù1** ^It is harmless, apart from the wasted memory,Ù>** for the sz parameter to be larger than necessary.  The pMemÙC** argument must be either a NULL pointer or a pointer to an 8-byteÙ<** aligned block of memory of at least sz*N bytes, otherwiseÙ$** subsequent behavior is undefined.ÙH** ^When pMem is not NULL, SQLite will strive to use the memory providedÙE** to satisfy page cache needs, falling back to [sqlite3_malloc()] ifÙI** a page cache line is larger than sz bytes or if all of the pMem buffer°** is exhausted.ÙD** ^If pMem is NULL and N is non-zero, then each database connectionÙ8** does an initial bulk allocation for page cache memoryÙK** from [sqlite3_malloc()] sufficient for N cache lines if N is positive orÙ6** of -1024*N bytes if N is negative, . ^If additionalÙE** page cache memory is needed beyond what is provided by the initialÙI** allocation, then SQLite goes to [sqlite3_malloc()] separately for each¿** additional cache line. </dd>¢**Ù5** [[SQLITE_CONFIG_HEAP]] <dt>SQLITE_CONFIG_HEAP</dt>ÙH** <dd> ^The SQLITE_CONFIG_HEAP option specifies a static memory buffer ÙF** that SQLite will use for all of its dynamic memory allocation needsÙ:** beyond those provided for by [SQLITE_CONFIG_PAGECACHE].ÙI** ^The SQLITE_CONFIG_HEAP option is only available if SQLite is compiledÙM** with either [SQLITE_ENABLE_MEMSYS3] or [SQLITE_ENABLE_MEMSYS5] and returnsÙ'** [SQLITE_ERROR] if invoked otherwise.Ù4** ^There are three arguments to SQLITE_CONFIG_HEAP:Ù+** An 8-byte aligned pointer to the memory,ÙM** the number of bytes in the memory buffer, and the minimum allocation size.ÙJ** ^If the first pointer (the memory pointer) is NULL, then SQLite revertsÙN** to using its default memory allocator (the system malloc() implementation),ÙC** undoing any prior invocation of [SQLITE_CONFIG_MALLOC].  ^If theÙ9** memory pointer is not NULL then the alternative memoryÙI** allocator is engaged to handle all of SQLites memory allocation needs.ÙF** The first pointer (the memory pointer) must be aligned to an 8-byteÙ?** boundary or subsequent behavior of SQLite will be undefined.ÙD** The minimum allocation size is capped at 2**12. Reasonable valuesÙ>** for the minimum allocation size are 2**5 through 2**8.</dd>¢**Ù7** [[SQLITE_CONFIG_MUTEX]] <dt>SQLITE_CONFIG_MUTEX</dt>ÙK** <dd> ^(The SQLITE_CONFIG_MUTEX option takes a single argument which is aÙC** pointer to an instance of the [sqlite3_mutex_methods] structure.ÙI** The argument specifies alternative low-level mutex routines to be usedÙL** in place the mutex routines built into SQLite.)^  ^SQLite makes a copy ofÙJ** the content of the [sqlite3_mutex_methods] structure before the call toÙ:** [sqlite3_config()] returns. ^If SQLite is compiled withÙI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenÙM** the entire mutexing subsystem is omitted from the build and hence calls toÙL** [sqlite3_config()] with the SQLITE_CONFIG_MUTEX configuration option will¾** return [SQLITE_ERROR].</dd>¢**Ù=** [[SQLITE_CONFIG_GETMUTEX]] <dt>SQLITE_CONFIG_GETMUTEX</dt>ÙI** <dd> ^(The SQLITE_CONFIG_GETMUTEX option takes a single argument whichÙM** is a pointer to an instance of the [sqlite3_mutex_methods] structure.  Theº** [sqlite3_mutex_methods]ÙC** structure is filled with the currently defined mutex routines.)^ÙC** This option can be used to overload the default mutex allocationÙD** routines with a wrapper used to track mutex usage for performanceÙC** profiling or testing, for example.   ^If SQLite is compiled withÙI** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option thenÙM** the entire mutexing subsystem is omitted from the build and hence calls toÙO** [sqlite3_config()] with the SQLITE_CONFIG_GETMUTEX configuration option will¾** return [SQLITE_ERROR].</dd>¢**Ù?** [[SQLITE_CONFIG_LOOKASIDE]] <dt>SQLITE_CONFIG_LOOKASIDE</dt>ÙO** <dd> ^(The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determineÙF** the default size of lookaside memory on each [database connection].¼** The first argument is theÙE** size of each lookaside buffer slot and the second is the number ofÙL** slots allocated to each database connection.)^  ^(SQLITE_CONFIG_LOOKASIDEÙJ** sets the <i>default</i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]ÙF** option to [sqlite3_db_config()] can be used to change the lookasideÙ3** configuration on individual connections.)^ </dd>¢**Ù;** [[SQLITE_CONFIG_PCACHE2]] <dt>SQLITE_CONFIG_PCACHE2</dt>ÙL** <dd> ^(The SQLITE_CONFIG_PCACHE2 option takes a single argument which is ÙK** a pointer to an [sqlite3_pcache_methods2] object.  This object specifiesÙ9** the interface to a custom page cache implementation.)^ÙE** ^SQLite makes a copy of the [sqlite3_pcache_methods2] object.</dd>¢**ÙA** [[SQLITE_CONFIG_GETPCACHE2]] <dt>SQLITE_CONFIG_GETPCACHE2</dt>ÙK** <dd> ^(The SQLITE_CONFIG_GETPCACHE2 option takes a single argument whichÙI** is a pointer to an [sqlite3_pcache_methods2] object.  SQLite copies ofÙB** the current page cache implementation into that object.)^ </dd>¢**Ù3** [[SQLITE_CONFIG_LOG]] <dt>SQLITE_CONFIG_LOG</dt>ÙD** <dd> The SQLITE_CONFIG_LOG option is used to configure the SQLite¶** global [error log].ÙE** (^The SQLITE_CONFIG_LOG option takes two arguments: a pointer to aÙE** function with a call signature of void(*)(void*,int,const char*), ÙE** and a pointer to void. ^If the function pointer is not NULL, it isÙE** invoked by [sqlite3_log()] to process each logging event.  ^If theÙK** function pointer is NULL, the [sqlite3_log()] interface becomes a no-op.ÙH** ^The void pointer that is the second argument to SQLITE_CONFIG_LOG isÙJ** passed through as the first parameter to the application-defined loggerÙH** function whenever that function is invoked.  ^The second parameter toÙL** the logger function is a copy of the first parameter to the correspondingÙC** [sqlite3_log()] call and is intended to be a [result code] or anÙH** [extended result code].  ^The third parameter passed to the logger isÙ9** log message after formatting via [sqlite3_snprintf()].ÙE** The SQLite logging interface is not reentrant; the logger functionÙD** supplied by the application must not invoke any SQLite interface.ÙB** In a multi-threaded application, the application-defined loggerÙ%** function must be threadsafe. </dd>¢**Ù.** [[SQLITE_CONFIG_URI]] <dt>SQLITE_CONFIG_URIÙJ** <dd>^(The SQLITE_CONFIG_URI option takes a single argument of type int.ÙP** If non-zero, then URI handling is globally enabled. If the parameter is zero,ÙI** then URI handling is globally disabled.)^ ^If URI handling is globallyÙJ** enabled, all filenames passed to [sqlite3_open()], [sqlite3_open_v2()],¸** [sqlite3_open16()] orÙM** specified as part of [ATTACH] commands are interpreted as URIs, regardlessÙH** of whether or not the [SQLITE_OPEN_URI] flag is set when the databaseÙC** connection is opened. ^If it is globally disabled, filenames areÙG** only interpreted as URIs if the SQLITE_OPEN_URI flag is set when theÙH** database connection is opened. ^(By default, URI handling is globallyÙC** disabled. The default value may be changed by compiling with theÙ%** [SQLITE_USE_URI] symbol defined.)^¢**ÙN** [[SQLITE_CONFIG_COVERING_INDEX_SCAN]] <dt>SQLITE_CONFIG_COVERING_INDEX_SCANÙK** <dd>^The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integerÙK** argument which is interpreted as a boolean in order to enable or disableÙK** the use of covering indices for full table scans in the query optimizer.Ù%** ^The default setting is determinedÙL** by the [SQLITE_ALLOW_COVERING_INDEX_SCAN] compile-time option, or is "on"Ù*** if that compile-time option is omitted.ÙJ** The ability to disable the use of covering indices for full table scansÙJ** is because some incorrectly coded legacy applications might malfunctionÙ>** when the optimization is enabled.  Providing the ability toÙL** disable the optimization allows the older, buggy application code to workÙ5** without change even with newer versions of SQLite.¢**Ù7** [[SQLITE_CONFIG_PCACHE]] [[SQLITE_CONFIG_GETPCACHE]]Ù7** <dt>SQLITE_CONFIG_PCACHE and SQLITE_CONFIG_GETPCACHEÙF** <dd> These options are obsolete and should not be used by new code.ÙD** They are retained for backwards compatibility but are now no-ops.¨** </dd>¢**»** [[SQLITE_CONFIG_SQLLOG]]»** <dt>SQLITE_CONFIG_SQLLOGÙC** <dd>This option is only available if sqlite is compiled with theÙP** [SQLITE_ENABLE_SQLLOG] pre-processor macro defined. The first argument shouldÙO** be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int).ÙO** The second should be of type (void*). The callback is invoked by the libraryÙI** in three separate circumstances, identified by the value passed as theÙO** fourth parameter. If the fourth parameter is 0, then the database connectionÙI** passed as the second argument has just been opened. The third argumentÙK** points to a buffer containing the name of the main database file. If theÙI** fourth parameter is 1, then the SQL statement that the third parameterÙK** points to has just been executed. Or, if the fourth parameter is 2, thenÙK** the connection being passed as the second parameter is being closed. TheÙI** third parameter is passed NULL In this case.  An example of using thisÙI** configuration option can be seen in the "test_sqllog.c" source file inÙ)** the canonical SQLite source tree.</dd>¢**¾** [[SQLITE_CONFIG_MMAP_SIZE]]¾** <dt>SQLITE_CONFIG_MMAP_SIZEÙO** <dd>^SQLITE_CONFIG_MMAP_SIZE takes two 64-bit integer (sqlite3_int64) valuesÙ@** that are the default mmap size limit (the default setting forÙ?** [PRAGMA mmap_size]) and the maximum allowed mmap size limit.ÙK** ^The default setting can be overridden by each database connection usingÙ9** either the [PRAGMA mmap_size] command, or by using theÙJ** [SQLITE_FCNTL_MMAP_SIZE] file control.  ^(The maximum allowed mmap sizeÙI** will be silently truncated if necessary so that it does not exceed theÙ,** compile-time maximum mmap size set by theÙ0** [SQLITE_MAX_MMAP_SIZE] compile-time option.)^ÙH** ^If either argument to this option is negative, then that argument isÙ'** changed to its compile-time default.¢**Ù#** [[SQLITE_CONFIG_WIN32_HEAPSIZE]]Ù#** <dt>SQLITE_CONFIG_WIN32_HEAPSIZEÙN** <dd>^The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite isÙJ** compiled for Windows with the [SQLITE_WIN32_MALLOC] pre-processor macroÙO** defined. ^SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer valueÙ7** that specifies the maximum size of the created heap.¢**Ù!** [[SQLITE_CONFIG_PCACHE_HDRSZ]]Ù!** <dt>SQLITE_CONFIG_PCACHE_HDRSZÙL** <dd>^The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter whichÙN** is a pointer to an integer and writes into that integer the number of extraÙF** bytes per page required for each page in [SQLITE_CONFIG_PAGECACHE].ÙK** The amount of extra space required can change depending on the compiler,Ù'** target platform, and SQLite version.¢**º** [[SQLITE_CONFIG_PMASZ]]º** <dt>SQLITE_CONFIG_PMASZÙE** <dd>^The SQLITE_CONFIG_PMASZ option takes a single parameter whichÙO** is an unsigned integer and sets the "Minimum PMA Size" for the multithreadedÙF** sorter to that integer.  The default minimum PMA Size is set by theÙG** [SQLITE_SORTER_PMASZ] compile-time option.  New threads are launchedÙ:** to help with sort operations when multithreaded sortingÙL** is enabled (using the [PRAGMA threads] command) and the amount of contentÙ>** to be sorted exceeds the page size times the minimum of theÙ.** [PRAGMA cache_size] setting and this value.¢**Ù#** [[SQLITE_CONFIG_STMTJRNL_SPILL]]Ù#** <dt>SQLITE_CONFIG_STMTJRNL_SPILLÙN** <dd>^The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter whichÙ=** becomes the [statement journal] spill-to-disk threshold.  ÙF** [Statement journals] are held in memory until their size (in bytes)ÙC** exceeds this threshold, at which point they are written to disk.Ù@** Or if the threshold is -1, statement journals are always held¹** exclusively in memory.ÙF** Since many statement journals never become large, setting the spillÙF** threshold to a value such as 64KiB can greatly reduce the amount ofÙ.** I/O required to support statement rollback.Ù:** The default value for this setting is controlled by theÙ/** [SQLITE_STMTJRNL_SPILL] compile-time option.¨** </dl>¢*/Ù0#define SQLITE_CONFIG_SINGLETHREAD  1  /* nil */Ù0#define SQLITE_CONFIG_MULTITHREAD   2  /* nil */Ù0#define SQLITE_CONFIG_SERIALIZED    3  /* nil */ÙA#define SQLITE_CONFIG_MALLOC        4  /* sqlite3_mem_methods* */ÙA#define SQLITE_CONFIG_GETMALLOC     5  /* sqlite3_mem_methods* */Ù;#define SQLITE_CONFIG_SCRATCH       6  /* No longer used */ÙA#define SQLITE_CONFIG_PAGECACHE     7  /* void*, int sz, int N */ÙF#define SQLITE_CONFIG_HEAP          8  /* void*, int nByte, int min */Ù4#define SQLITE_CONFIG_MEMSTATUS     9  /* boolean */ÙC#define SQLITE_CONFIG_MUTEX        10  /* sqlite3_mutex_methods* */ÙC#define SQLITE_CONFIG_GETMUTEX     11  /* sqlite3_mutex_methods* */ÙB/* previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. */ Ù4#define SQLITE_CONFIG_LOOKASIDE    13  /* int int */Ù2#define SQLITE_CONFIG_PCACHE       14  /* no-op */Ù2#define SQLITE_CONFIG_GETPCACHE    15  /* no-op */Ù9#define SQLITE_CONFIG_LOG          16  /* xFunc, void* */Ù0#define SQLITE_CONFIG_URI          17  /* int */ÙE#define SQLITE_CONFIG_PCACHE2      18  /* sqlite3_pcache_methods2* */ÙE#define SQLITE_CONFIG_GETPCACHE2   19  /* sqlite3_pcache_methods2* */Ù7#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20  /* int */Ù;#define SQLITE_CONFIG_SQLLOG       21  /* xSqllog, void* */ÙI#define SQLITE_CONFIG_MMAP_SIZE    22  /* sqlite3_int64, sqlite3_int64 */Ù=#define SQLITE_CONFIG_WIN32_HEAPSIZE      23  /* int nByte */Ù<#define SQLITE_CONFIG_PCACHE_HDRSZ        24  /* int *psz */ÙF#define SQLITE_CONFIG_PMASZ               25  /* unsigned int szPma */Ù=#define SQLITE_CONFIG_STMTJRNL_SPILL      26  /* int nByte */Ù;#define SQLITE_CONFIG_SMALL_MALLOC        27  /* boolean */ ¢/*Ù6** CAPI3REF: Database Connection Configuration Options¢**ÙG** These constants are the available integer configuration options thatÙO** can be passed as the second argument to the [sqlite3_db_config()] interface.¢**ÙG** New configuration options may be added in future releases of SQLite.ÙF** Existing configuration options might be discontinued.  ApplicationsÙL** should check the return code from [sqlite3_db_config()] to make sure thatÙG** the call worked.  ^The [sqlite3_db_config()] interface will return aÙN** non-zero [error code] if a discontinued or unsupported configuration option®** is invoked.¢**§** <dl>Ù%** <dt>SQLITE_DBCONFIG_LOOKASIDE</dt>ÙI** <dd> ^This option takes three additional arguments that determine the ÙL** [lookaside memory allocator] configuration for the [database connection].ÙI** ^The first argument (the third parameter to [sqlite3_db_config()] is aÙ:** pointer to a memory buffer to use for lookaside memory.Ù?** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verbÙ5** may be NULL in which case SQLite will allocate theÙP** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is theÙL** size of each lookaside buffer slot.  ^The third argument is the number ofÙL** slots.  The size of the buffer in the first argument must be greater thanÙI** or equal to the product of the second and third arguments.  The bufferÙE** must be aligned to an 8-byte boundary.  ^If the second argument toÙE** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internallyÙJ** rounded down to the next smaller multiple of 8.  ^(The lookaside memoryÙH** configuration for a database connection can only be changed when thatÙH** connection is not currently using lookaside memory, or in other wordsÙ'** when the "current value" returned byÙ@** [sqlite3_db_status](D,[SQLITE_CONFIG_LOOKASIDE],...) is zero.ÙJ** Any attempt to change the lookaside memory configuration when lookasideÙC** memory is in use leaves the configuration unchanged and returns ¸** [SQLITE_BUSY].)^</dd>¢**Ù'** <dt>SQLITE_DBCONFIG_ENABLE_FKEY</dt>ÙD** <dd> ^This option is used to enable or disable the enforcement ofÙH** [foreign key constraints].  There should be two additional arguments.ÙI** The first argument is an integer which is 0 to disable FK enforcement,ÙH** positive to enable FK enforcement or negative to leave FK enforcementÙI** unchanged.  The second parameter is a pointer to an integer into whichÙD** is written 0 or 1 to indicate whether FK enforcement is off or onÙG** following this call.  The second parameter may be a NULL pointer, inÙD** which case the FK enforcement setting is not reported back. </dd>¢**Ù*** <dt>SQLITE_DBCONFIG_ENABLE_TRIGGER</dt>ÙN** <dd> ^This option is used to enable or disable [CREATE TRIGGER | triggers].Ù,** There should be two additional arguments.ÙC** The first argument is an integer which is 0 to disable triggers,ÙJ** positive to enable triggers or negative to leave the setting unchanged.Ù=** The second parameter is a pointer to an integer into whichÙI** is written 0 or 1 to indicate whether triggers are disabled or enabledÙG** following this call.  The second parameter may be a NULL pointer, inÙ=** which case the trigger setting is not reported back. </dd>¢**Ù1** <dt>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</dt>ÙB** <dd> ^This option is used to enable or disable the two-argumentÙB** version of the [fts3_tokenizer()] function which is part of theÙ,** [FTS3] full-text search engine extension.Ù,** There should be two additional arguments.ÙM** The first argument is an integer which is 0 to disable fts3_tokenizer() orÙG** positive to enable fts3_tokenizer() or negative to leave the setting­** unchanged.Ù=** The second parameter is a pointer to an integer into whichÙN** is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabledÙG** following this call.  The second parameter may be a NULL pointer, inÙ9** which case the new setting is not reported back. </dd>¢**Ù1** <dt>SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</dt>ÙP** <dd> ^This option is used to enable or disable the [sqlite3_load_extension()]ÙB** interface independently of the [load_extension()] SQL function.ÙI** The [sqlite3_enable_load_extension()] API enables or disables both theÙL** C-API [sqlite3_load_extension()] and the SQL function [load_extension()].Ù,** There should be two additional arguments.ÙI** When the first argument to this interface is 1, then only the C-API isÙK** enabled and the SQL function remains disabled.  If the first argument toÙN** this interface is 0, then both the C-API and the SQL function are disabled.ÙO** If the first argument is -1, then no changes are made to state of either the½** C-API or the SQL function.Ù=** The second parameter is a pointer to an integer into whichÙM** is written 0 or 1 to indicate whether [sqlite3_load_extension()] interfaceÙH** is disabled or enabled following this call.  The second parameter mayÙI** be a NULL pointer, in which case the new setting is not reported back.¨** </dd>¢**Ù&** <dt>SQLITE_DBCONFIG_MAINDBNAME</dt>ÙF** <dd> ^This option is used to change the name of the "main" databaseÙE** schema.  ^The sole argument is a pointer to a constant UTF8 stringÙE** which will become the new schema name in place of "main".  ^SQLiteÙN** does not make a copy of the new main schema name string, so the applicationÙN** must ensure that the argument passed into this DBCONFIG option is unchangedÙ.** until after the database connection closes.¨** </dd>¢**Ù,** <dt>SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</dt>ÙJ** <dd> Usually, when a database in wal mode is closed or detached from a ÙJ** database handle, SQLite checks if this will mean that there are now no ÙG** connections at all to the database. If so, it performs a checkpoint ÙF** operation before closing the connection. This option may be used toÙH** override this behaviour. The first parameter passed to this operationÙI** is an integer - positive to disable checkpoints-on-close, or zero (theÙH** default) to enable them, and negative to leave the setting unchanged.Ù2** The second parameter is a pointer to an integerÙH** into which is written 0 or 1 to indicate whether checkpoints-on-closeÙB** have been disabled - 0 if they are not disabled, 1 if they are.¨** </dd>¢**Ù'** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>ÙH** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivatesÙL** the [query planner stability guarantee] (QPSG).  When the QPSG is active,ÙM** a single SQL query statement will always use the same algorithm regardlessÙP** of values of [bound parameters].)^ The QPSG disables some query optimizationsÙK** that look at the values of bound parameters, which can make some queriesÙN** slower.  But the QPSG has the advantage of more predictable behavior.  WithÙN** the QPSG active, SQLite will always use the same query plan in the field asÙ&** was used during testing in the lab.ÙJ** The first argument to this setting is an integer which is 0 to disable ÙF** the QPSG, positive to enable QPSG, or negative to leave the settingÙH** unchanged. The second parameter is a pointer to an integer into whichÙH** is written 0 or 1 to indicate whether the QPSG is disabled or enabled·** following this call.¨** </dd>¢**Ù'** <dt>SQLITE_DBCONFIG_TRIGGER_EQP</dt>ÙG** <dd> By default, the output of EXPLAIN QUERY PLAN commands does not ÙH** include output for any operations performed by trigger programs. ThisÙH** option is used to set or clear (the default) a flag that governs thisÙI** behavior. The first parameter passed to this operation is an integer -ÙI** positive to enable output for trigger programs, or zero to disable it,Ù.** or negative to leave the setting unchanged.ÙI** The second parameter is a pointer to an integer into which is written ÙK** 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if Ù$** it is not disabled, 1 if it is.  ¨** </dd>¨** </dl>¢*/ÙD#define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */ÙF#define SQLITE_DBCONFIG_LOOKASIDE             1001 /* void* int int */ÙA#define SQLITE_DBCONFIG_ENABLE_FKEY           1002 /* int int* */ÙA#define SQLITE_DBCONFIG_ENABLE_TRIGGER        1003 /* int int* */ÙA#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004 /* int int* */ÙA#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005 /* int int* */ÙA#define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      1006 /* int int* */ÙA#define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */ÙA#define SQLITE_DBCONFIG_TRIGGER_EQP           1008 /* int int* */ÙI#define SQLITE_DBCONFIG_MAX                   1008 /* Largest DBCONFIG */ ¢/*Ù4** CAPI3REF: Enable Or Disable Extended Result Codes²** METHOD: sqlite3¢**ÙG** ^The sqlite3_extended_result_codes() routine enables or disables theÙB** [extended result codes] feature of SQLite. ^The extended resultÙ>** codes are disabled by default for historical compatibility.¢*/ÙBSQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff); ¢/*¾** CAPI3REF: Last Insert Rowid²** METHOD: sqlite3¢**ÙH** ^Each entry in most SQLite tables (except for [WITHOUT ROWID] tables)½** has a unique 64-bit signedÙK** integer key called the [ROWID | "rowid"]. ^The rowid is always availableÙH** as an undeclared column named ROWID, OID, or _ROWID_ as long as thoseÙ>** names are not also used by explicitly declared columns. ^IfÙH** the table has a column of type [INTEGER PRIMARY KEY] then that columnÙ"** is another alias for the rowid.¢**ÙM** ^The sqlite3_last_insert_rowid(D) interface usually returns the [rowid] ofÙL** the most recent successful [INSERT] into a rowid table or [virtual table]ÙI** on database connection D. ^Inserts into [WITHOUT ROWID] tables are notÙN** recorded. ^If no successful [INSERT]s into rowid tables have ever occurred ÙK** on the database connection D, then sqlite3_last_insert_rowid(D) returns ¨** zero.¢**ÙH** As well as being set automatically as rows are inserted into databaseÙG** tables, the value returned by this function may be set explicitly byÙ$** [sqlite3_set_last_insert_rowid()]¢**ÙJ** Some virtual table implementations may INSERT rows into rowid tables asÙM** part of committing a transaction (e.g. to flush data accumulated in memoryÙL** to disk). In this case subsequent calls to this function return the rowidÙD** associated with these internal INSERT operations, which leads to ÙL** unintuitive results. Virtual table implementations that do write to rowidÙG** tables in this way can avoid this problem by restoring the original ÙH** rowid value using [sqlite3_set_last_insert_rowid()] before returning ·** control to the user.¢**ÙC** ^(If an [INSERT] occurs within a trigger then this routine will ÙD** return the [rowid] of the inserted row as long as the trigger is Ù>** running. Once the trigger program ends, the value returned ÙI** by this routine reverts to what it was before the trigger was fired.)^¢**ÙA** ^An [INSERT] that fails due to a constraint violation is not aÙE** successful [INSERT] and does not change the value returned by thisÙH** routine.  ^Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK,ÙB** and INSERT OR ABORT make no changes to the return value of thisÙ@** routine when their insertion fails.  ^(When INSERT OR REPLACEÙ<** encounters a constraint violation, it does not fail.  TheÙA** INSERT continues to completion after deleting rows that causedÙA** the constraint problem so INSERT OR REPLACE will always changeÙ(** the return value of this interface.)^¢**ÙB** ^For the purposes of this routine, an [INSERT] is considered toÙ8** be successful even if it is subsequently rolled back.¢**Ù8** This function is accessible to SQL statements via theÙ&** [last_insert_rowid() SQL function].¢**Ù;** If a separate thread performs a new [INSERT] on the sameÙ>** database connection while the [sqlite3_last_insert_rowid()]Ù@** function is running and thus changes the last insert [rowid],Ù>** then the value returned by [sqlite3_last_insert_rowid()] isÙ>** unpredictable and might not equal either the old or the new·** last insert [rowid].¢*/Ù=SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*); ¢/*Ù-** CAPI3REF: Set the Last Insert Rowid value.²** METHOD: sqlite3¢**ÙK** The sqlite3_set_last_insert_rowid(D, R) method allows the application toÙG** set the value returned by calling sqlite3_last_insert_rowid(D) to R Ù-** without inserting a row into the database.¢*/ÙFSQLITE_API void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64); ¢/*Ù.** CAPI3REF: Count The Number Of Rows Modified²** METHOD: sqlite3¢**ÙB** ^This function returns the number of rows modified, inserted orÙB** deleted by the most recently completed INSERT, UPDATE or DELETEÙH** statement on the database connection specified by the only parameter.ÙG** ^Executing any other type of SQL statement does not modify the value½** returned by this function.¢**ÙL** ^Only changes made directly by the INSERT, UPDATE or DELETE statement areÙI** considered - auxiliary changes caused by [CREATE TRIGGER | triggers], ÙL** [foreign key actions] or [REPLACE] constraint resolution are not counted.£** Ù-** Changes to a view that are intercepted by ÙJ** [INSTEAD OF trigger | INSTEAD OF triggers] are not counted. ^The value ÙH** returned by sqlite3_changes() immediately after an INSERT, UPDATE or ÙL** DELETE statement run on a view is always zero. Only changes made to real ¶** tables are counted.¢**ÙC** Things are more complicated if the sqlite3_changes() function isÙF** executed while a trigger program is running. This may happen if theÙG** program uses the [changes() SQL function], or if some other callbackÙ<** function invokes sqlite3_changes() directly. Essentially:£** §** <ul>ÙC**   <li> ^(Before entering a trigger program the value returned byÙI**        sqlite3_changes() function is saved. After the trigger program Ù9**        has finished, the original value is restored.)^£** ÙD**   <li> ^(Within a trigger program each INSERT, UPDATE and DELETE ÙA**        statement sets the value returned by sqlite3_changes() ÙL**        upon completion as normal. Of course, this value will not include ÙJ**        any changes performed by sub-triggers, as the sqlite3_changes() ÙL**        value will be saved and restored after each sub-trigger has run.)^¨** </ul>£** ÙF** ^This means that if the changes() SQL function (or similar) is usedÙH** by the first INSERT, UPDATE or DELETE statement within a trigger, it ÙG** returns the value as set when the calling statement began executing.ÙN** ^If it is used by the second or subsequent such statement within a trigger ÙK** program, the value returned reflects the number of rows modified by the ÙG** previous INSERT, UPDATE or DELETE statement within the same trigger.¢**Ù8** See also the [sqlite3_total_changes()] interface, theÙ<** [count_changes pragma], and the [changes() SQL function].¢**ÙE** If a separate thread makes changes on the same database connectionÙ?** while [sqlite3_changes()] is running then the value returnedÙ'** is unpredictable and not meaningful.¢*/Ù)SQLITE_API int sqlite3_changes(sqlite3*); ¢/*Ù*** CAPI3REF: Total Number Of Rows Modified²** METHOD: sqlite3¢**ÙH** ^This function returns the total number of rows inserted, modified orÙE** deleted by all [INSERT], [UPDATE] or [DELETE] statements completedÙH** since the database connection was opened, including those executed asÙG** part of trigger programs. ^Executing any other type of SQL statementÙA** does not affect the value returned by sqlite3_total_changes().£** ÙE** ^Changes made as part of [foreign key actions] are included in theÙE** count, but those made as part of REPLACE constraint resolution areÙG** not. ^Changes to a view that are intercepted by INSTEAD OF triggers ³** are not counted.£** Ù2** See also the [sqlite3_changes()] interface, theÙB** [count_changes pragma], and the [total_changes() SQL function].¢**ÙE** If a separate thread makes changes on the same database connectionÙ<** while [sqlite3_total_changes()] is running then the valueÙ0** returned is unpredictable and not meaningful.¢*/Ù/SQLITE_API int sqlite3_total_changes(sqlite3*); ¢/*Ù+** CAPI3REF: Interrupt A Long-Running Query²** METHOD: sqlite3¢**ÙD** ^This function causes any pending database operation to abort andÙ@** return at its earliest opportunity. This routine is typicallyÙ@** called in response to a user action such as pressing "Cancel"Ù@** or Ctrl-C where the user wants a long query operation to halt¯** immediately.¢**ÙD** ^It is safe to call this routine from a thread different from theÙC** thread that is currently running the database operation.  But itÙE** is not safe to call this routine with a [database connection] thatÙ?** is closed or might close before sqlite3_interrupt() returns.¢**Ù@** ^If an SQL operation is very nearly finished at the time whenÙG** sqlite3_interrupt() is called, then it might not have an opportunityÙ6** to be interrupted and might continue to completion.¢**ÙH** ^An SQL operation that is interrupted will return [SQLITE_INTERRUPT].ÙD** ^If the interrupted SQL operation is an INSERT, UPDATE, or DELETEÙF** that is inside an explicit transaction, then the entire transactionÙ%** will be rolled back automatically.¢**ÙJ** ^The sqlite3_interrupt(D) call is in effect until all currently runningÙO** SQL statements on [database connection] D complete.  ^Any new SQL statementsÙF** that are started after the sqlite3_interrupt() call and before the ÙF** running statements reaches zero are interrupted as if they had beenÙF** running prior to the sqlite3_interrupt() call.  ^New SQL statementsÙF** that are started after the running statement count reaches zero areÙ+** not effected by the sqlite3_interrupt().ÙH** ^A call to sqlite3_interrupt(D) that occurs when there are no runningÙ@** SQL statements is a no-op and has no effect on SQL statementsÙ?** that are started after the sqlite3_interrupt() call returns.¢*/Ù,SQLITE_API void sqlite3_interrupt(sqlite3*); ¢/*Ù6** CAPI3REF: Determine If An SQL Statement Is Complete¢**ÙJ** These routines are useful during command-line input to determine if theÙC** currently entered text seems to form a complete SQL statement orÙ=** if additional input is needed before sending the text intoÙD** SQLite for parsing.  ^These routines return 1 if the input stringÙH** appears to be a complete SQL statement.  ^A statement is judged to beÙF** complete if it ends with a semicolon token and is not a prefix of aÙN** well-formed CREATE TRIGGER statement.  ^Semicolons that are embedded withinÙA** string literals or quoted identifier names or comments are notÙC** independent tokens (they are part of the token in which they areÙJ** embedded) and thus do not count as a statement terminator.  ^WhitespaceÙ<** and comments that follow the final semicolon are ignored.¢**ÙB** ^These routines return 0 if the statement is incomplete.  ^If aÙ:** memory allocation fails, then SQLITE_NOMEM is returned.¢**Ù7** ^These routines do not parse the SQL statements thusÙ/** will not detect syntactically incorrect SQL.¢**ÙK** ^(If SQLite has not been initialized using [sqlite3_initialize()] prior ÙH** to invoking sqlite3_complete16() then sqlite3_initialize() is invokedÙH** automatically by sqlite3_complete16().  If that initialization fails,ÙC** then the return value from sqlite3_complete16() will be non-zeroÙ<** regardless of whether or not the input SQL is complete.)^¢**Ù>** The input to [sqlite3_complete()] must be a zero-terminated°** UTF-8 string.¢**Ù@** The input to [sqlite3_complete16()] must be a zero-terminatedÙ&** UTF-16 string in native byte order.¢*/Ù1SQLITE_API int sqlite3_complete(const char *sql);Ù3SQLITE_API int sqlite3_complete16(const void *sql); ¢/*Ù=** CAPI3REF: Register A Callback To Handle SQLITE_BUSY ErrorsÙ3** KEYWORDS: {busy-handler callback} {busy handler}²** METHOD: sqlite3¢**ÙF** ^The sqlite3_busy_handler(D,X,P) routine sets a callback function XÙ1** that might be invoked with argument P wheneverÙ@** an attempt is made to access a database table associated withÙ.** [database connection] D when another threadÙ#** or process has the table locked.Ù<** The sqlite3_busy_handler() interface is used to implementÙ6** [sqlite3_busy_timeout()] and [PRAGMA busy_timeout].¢**Ù4** ^If the busy callback is NULL, then [SQLITE_BUSY]ÙM** is returned immediately upon encountering the lock.  ^If the busy callbackÙF** is not NULL, then the callback might be invoked with two arguments.¢**ÙO** ^The first argument to the busy handler is a copy of the void* pointer whichÙL** is the third argument to sqlite3_busy_handler().  ^The second argument toÙM** the busy handler callback is the number of times that the busy handler hasÙ?** been invoked previously for the same locking event.  ^If theÙC** busy callback returns 0, then no additional attempts are made toÙ4** access the database and [SQLITE_BUSY] is returned¶** to the application.Ù:** ^If the callback returns non-zero, then another attemptÙ8** is made to access the database and the cycle repeats.¢**ÙL** The presence of a busy handler does not guarantee that it will be invokedÙN** when there is lock contention. ^If SQLite determines that invoking the busyÙP** handler could result in a deadlock, it will go ahead and return [SQLITE_BUSY]Ù.** to the application instead of invoking the °** busy handler.ÙD** Consider a scenario where one process is holding a read lock thatÙ1** it is trying to promote to a reserved lock andÙ@** a second process is holding a reserved lock that it is tryingÙE** to promote to an exclusive lock.  The first process cannot proceedÙD** because it is blocked by the second and the second process cannotÙA** proceed because it is blocked by the first.  If both processesÙH** invoke the busy handlers, neither will make any progress.  Therefore,ÙG** SQLite returns [SQLITE_BUSY] for the first process, hoping that thisÙC** will induce the first process to release its read lock and allowÙ!** the second process to proceed.¢**Ù&** ^The default busy callback is NULL.¢**Ù=** ^(There can only be a single busy handler defined for eachÙ@** [database connection].  Setting a new busy handler clears anyÙI** previously set handler.)^  ^Note that calling [sqlite3_busy_timeout()]Ù8** or evaluating [PRAGMA busy_timeout=N] will change theÙ?** busy handler and thus clear any previously set busy handler.¢**ÙA** The busy callback should not take any actions which modify theÙF** database connection that invoked the busy handler.  In other words,Ù7** the busy handler is not reentrant.  Any such actionsÙ ** result in undefined behavior.£** Ù8** A busy handler must not close the database connectionÙ9** or [prepared statement] that invoked the busy handler.¢*/ÙFSQLITE_API int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*); ¢/*¿** CAPI3REF: Set A Busy Timeout²** METHOD: sqlite3¢**ÙI** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleepsÙG** for a specified amount of time when a table is locked.  ^The handlerÙI** will sleep multiple times until at least "ms" milliseconds of sleepingÙD** have accumulated.  ^After at least "ms" milliseconds of sleeping,Ù@** the handler returns 0 which causes [sqlite3_step()] to return±** [SQLITE_BUSY].¢**ÙD** ^Calling this routine with an argument less than or equal to zero¿** turns off all busy handlers.¢**Ù=** ^(There can only be a single busy handler for a particularÙF** [database connection] at any given moment.  If another busy handlerÙA** was defined  (using [sqlite3_busy_handler()]) prior to callingÙ6** this routine, that other busy handler is cleared.)^¢**Ù#** See also:  [PRAGMA busy_timeout]¢*/Ù6SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms); ¢/*Ù5** CAPI3REF: Convenience Routines For Running Queries²** METHOD: sqlite3¢**ÙL** This is a legacy interface that is preserved for backwards compatibility.Ù,** Use of this interface is not recommended.¢**ÙL** Definition: A <b>result table</b> is memory data structure created by theÙ?** [sqlite3_get_table()] interface.  A result table records theÙ3** complete query results from one or more queries.¢**Ù@** The table conceptually has a number of rows and columns.  ButÙ@** these numbers are not part of the result table itself.  TheseÙ@** numbers are obtained separately.  Let N be the number of rowsÙ"** and M be the number of columns.¢**ÙK** A result table is an array of pointers to zero-terminated UTF-8 strings.ÙG** There are (N+1)*M elements in the array.  The first M pointers pointÙE** to zero-terminated strings that  contain the names of the columns.ÙH** The remaining entries all point to query results.  NULL values resultÙI** in NULL pointers.  All other values are in their UTF-8 zero-terminatedÙ@** string representation as returned by [sqlite3_column_text()].¢**ÙB** A result table might consist of one or more memory allocations.ÙF** It is not safe to pass a result table directly to [sqlite3_free()].ÙE** A result table should be deallocated using [sqlite3_free_table()].¢**ÙE** ^(As an example of the result table format, suppose a query result±** is as follows:¢**´** <blockquote><pre>»**        Name        | AgeÙ!**        -----------------------º**        Alice       | 43º**        Bob         | 28º**        Cindy       | 21¶** </pre></blockquote>¢**Ù?** There are two column (M==2) and three rows (N==3).  Thus theÙB** result table has 8 entries.  Suppose the result table is storedÙA** in an array names azResult.  Then azResult holds this content:¢**´** <blockquote><pre>Ù#**        azResult&#91;0] = "Name";Ù"**        azResult&#91;1] = "Age";Ù$**        azResult&#91;2] = "Alice";Ù!**        azResult&#91;3] = "43";Ù"**        azResult&#91;4] = "Bob";Ù!**        azResult&#91;5] = "28";Ù$**        azResult&#91;6] = "Cindy";Ù!**        azResult&#91;7] = "21";¸** </pre></blockquote>)^¢**Ù:** ^The sqlite3_get_table() function evaluates one or moreÙB** semicolon-separated SQL statements in the zero-terminated UTF-8Ù@** string of its 2nd parameter and returns a result table to theÙ&** pointer given in its 3rd parameter.¢**ÙO** After the application has finished with the result from sqlite3_get_table(),ÙL** it must pass the result table pointer to sqlite3_free_table() in order toÙ@** release the memory that was malloced.  Because of the way theÙE** [sqlite3_malloc()] happens within sqlite3_get_table(), the callingÙA** function must not try to call [sqlite3_free()] directly.  OnlyÙL** [sqlite3_free_table()] is able to release the memory properly and safely.¢**ÙG** The sqlite3_get_table() interface is implemented as a wrapper aroundÙJ** [sqlite3_exec()].  The sqlite3_get_table() routine does not have accessÙF** to any internal data structures of SQLite.  It uses only the publicÙF** interface defined here.  As a consequence, errors that occur in theÙF** wrapper layer outside of the internal [sqlite3_exec()] call are notÙ:** reflected in subsequent calls to [sqlite3_errcode()] or¶** [sqlite3_errmsg()].¢*/Ù!SQLITE_API int sqlite3_get_table(Ù.  sqlite3 *db,          /* An open database */Ù1  const char *zSql,     /* SQL to be evaluated */Ù2  char ***pazResult,    /* Results of the query */Ù@  int *pnRow,           /* Number of result rows written here */ÙC  int *pnColumn,        /* Number of result columns written here */Ù4  char **pzErrmsg       /* Error msg written here */¢);Ù2SQLITE_API void sqlite3_free_table(char **result); ¢/*Ù0** CAPI3REF: Formatted String Printing Functions¢**ÙG** These routines are work-alikes of the "printf()" family of functions¿** from the standard C library.ÙG** These routines understand most of the common formatting options fromÙ!** the standard library printf() ÙJ** plus some additional non-standard formats ([%q], [%Q], [%w], and [%z]).Ù9** See the [built-in printf()] documentation for details.¢**ÙE** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write theirÙ:** results into memory obtained from [sqlite3_malloc64()].Ù7** The strings returned by these two routines should beÙ9** released by [sqlite3_free()].  ^Both routines return aÙD** NULL pointer if [sqlite3_malloc64()] is unable to allocate enoughÙ'** memory to hold the resulting string.¢**ÙC** ^(The sqlite3_snprintf() routine is similar to "snprintf()" fromÙ:** the standard C library.  The result is written into theÙA** buffer supplied as the second parameter whose size is given byÙ2** the first parameter. Note that the order of theÙB** first two parameters is reversed from snprintf().)^  This is anÙ<** historical accident that cannot be fixed without breakingÙ@** backwards compatibility.  ^(Note also that sqlite3_snprintf()Ù;** returns a pointer to its buffer instead of the number ofÙ@** characters actually written into the buffer.)^  We admit thatÙA** the number of characters written would be a more useful returnÙF** value but we cannot change the implementation of sqlite3_snprintf()Ù&** now without breaking compatibility.¢**ÙG** ^As long as the buffer size is greater than zero, sqlite3_snprintf()ÙD** guarantees that the buffer is always zero-terminated.  ^The firstÙE** parameter "n" is the total size of the buffer, including space forÙE** the zero terminator.  So the longest string that can be completelyÙ"** written will be n-1 characters.¢**ÙO** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().¢**Ù:** See also:  [built-in printf()], [printf() SQL function]¢*/Ù2SQLITE_API char *sqlite3_mprintf(const char*,...);Ù8SQLITE_API char *sqlite3_vmprintf(const char*, va_list);Ù>SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);ÙCSQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list); ¢/*Ù(** CAPI3REF: Memory Allocation Subsystem¢**Ù?** The SQLite core uses these three routines for all of its ownÙD** internal memory allocation needs. "Core" in the previous sentenceÙF** does not include operating-system specific VFS implementation.  TheÙC** Windows VFS uses native malloc() and free() for some operations.¢**Ù=** ^The sqlite3_malloc() routine returns a pointer to a blockÙB** of memory at least N bytes in length, where N is the parameter.Ù;** ^If sqlite3_malloc() is unable to obtain sufficient freeÙ=** memory, it returns a NULL pointer.  ^If the parameter N toÙE** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns²** a NULL pointer.¢**Ù3** ^The sqlite3_malloc64(N) routine works just likeÙH** sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead¾** of a signed 32-bit integer.¢**Ù=** ^Calling sqlite3_free() with a pointer previously returnedÙC** by sqlite3_malloc() or sqlite3_realloc() releases that memory soÙ;** that it might be reused.  ^The sqlite3_free() routine isÙD** a no-op if is called with a NULL pointer.  Passing a NULL pointerÙ<** to sqlite3_free() is harmless.  After being freed, memoryÙE** should neither be read nor written.  Even reading previously freedÙE** memory might result in a segmentation fault or other severe error.ÙA** Memory corruption, a segmentation fault, or other severe errorÙH** might result if sqlite3_free() is called with a non-NULL pointer thatÙ?** was not obtained from sqlite3_malloc() or sqlite3_realloc().¢**Ù;** ^The sqlite3_realloc(X,N) interface attempts to resize aÙ4** prior memory allocation X to be at least N bytes.Ù.** ^If the X parameter to sqlite3_realloc(X,N)Ù>** is a NULL pointer then its behavior is identical to callingµ** sqlite3_malloc(N).Ù9** ^If the N parameter to sqlite3_realloc(X,N) is zero orÙ<** negative then the behavior is exactly the same as calling³** sqlite3_free(X).ÙA** ^sqlite3_realloc(X,N) returns a pointer to a memory allocationÙK** of at least N bytes in size or NULL if insufficient memory is available.ÙA** ^If M is the size of the prior allocation, then min(N,M) bytesÙK** of the prior allocation are copied into the beginning of buffer returnedÙ=** by sqlite3_realloc(X,N) and the prior allocation is freed.ÙD** ^If sqlite3_realloc(X,N) returns NULL and N is positive, then theÙ!** prior allocation is not freed.¢**Ù;** ^The sqlite3_realloc64(X,N) interfaces works the same asÙJ** sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead¾** of a 32-bit signed integer.¢**ÙJ** ^If X is a memory allocation previously obtained from sqlite3_malloc(),ÙF** sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), thenÙH** sqlite3_msize(X) returns the size of that memory allocation in bytes.ÙJ** ^The value returned by sqlite3_msize(X) might be larger than the numberÙI** of bytes requested when X was allocated.  ^If X is a NULL pointer thenÙG** sqlite3_msize(X) returns zero.  If X points to something that is notÙD** the beginning of memory allocation, or if it points to a formerlyÙE** valid memory allocation that has now been freed, then the behaviorÙ9** of sqlite3_msize(X) is undefined and possibly harmful.¢**Ù?** ^The memory returned by sqlite3_malloc(), sqlite3_realloc(),Ù.** sqlite3_malloc64(), and sqlite3_realloc64()Ù<** is always aligned to at least an 8 byte boundary, or to aÙE** 4 byte boundary if the [SQLITE_4_BYTE_ALIGNED_MALLOC] compile-time²** option is used.¢**Ù?** In SQLite version 3.5.0 and 3.5.1, it was possible to defineÙC** the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-inÙC** implementation of these routines to be omitted.  That capabilityÙG** is no longer provided.  Only built-in memory allocators can be used.¢**ÙH** Prior to SQLite version 3.7.10, the Windows OS interface layer calledÙ:** the system malloc() and free() directly when convertingÙ6** filenames between the UTF-8 encoding used by SQLiteÙC** and whatever filename encoding is used by the particular WindowsÙ=** installation.  Memory allocation errors were detected, butÙ2** they were reported back as [SQLITE_CANTOPEN] orÙ-** [SQLITE_IOERR] rather than [SQLITE_NOMEM].¢**ÙD** The pointer arguments to [sqlite3_free()] and [sqlite3_realloc()]Ù=** must be either NULL or else pointers obtained from a priorÙD** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have¹** not yet been released.¢**Ù5** The application must not read or write any part ofÙ5** a block of memory after it has been released usingÙ+** [sqlite3_free()] or [sqlite3_realloc()].¢*/Ù%SQLITE_API void *sqlite3_malloc(int);Ù2SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);Ù-SQLITE_API void *sqlite3_realloc(void*, int);Ù:SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);Ù$SQLITE_API void sqlite3_free(void*);Ù/SQLITE_API sqlite3_uint64 sqlite3_msize(void*); ¢/*Ù(** CAPI3REF: Memory Allocator Statistics¢**ÙC** SQLite provides these two interfaces for reporting on the statusÙG** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]ÙA** routines, which form the built-in memory allocation subsystem.¢**ÙC** ^The [sqlite3_memory_used()] routine returns the number of bytesÙ<** of memory currently outstanding (malloced but not freed).Ù@** ^The [sqlite3_memory_highwater()] routine returns the maximumÙ=** value of [sqlite3_memory_used()] since the high-water markÙG** was last reset.  ^The values returned by [sqlite3_memory_used()] andÙ4** [sqlite3_memory_highwater()] include any overheadÙ?** added by SQLite in its implementation of [sqlite3_malloc()],Ù>** but not overhead added by the any underlying system libraryÙ-** routines that [sqlite3_malloc()] may call.¢**Ù?** ^The memory high-water mark is reset to the current value ofÙ:** [sqlite3_memory_used()] if and only if the parameter toÙ=** [sqlite3_memory_highwater()] is true.  ^The value returnedÙ:** by [sqlite3_memory_highwater(1)] is the high-water mark¶** prior to the reset.¢*/Ù3SQLITE_API sqlite3_int64 sqlite3_memory_used(void);ÙASQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag); ¢/*Ù+** CAPI3REF: Pseudo-Random Number Generator¢**ÙO** SQLite contains a high-quality pseudo-random number generator (PRNG) used toÙN** select random [ROWID | ROWIDs] when inserting new records into a table thatÙH** already uses the largest possible [ROWID].  The PRNG is also used forÙO** the build-in random() and randomblob() SQL functions.  This interface allowsÙ;** applications to access the same PRNG for other purposes.¢**ÙF** ^A call to this routine stores N bytes of randomness into buffer P.Ù*** ^The P parameter can be a NULL pointer.¢**ÙE** ^If this routine has not been previously called or if the previousÙE** call had N less than one or a NULL pointer for P, then the PRNG isÙB** seeded using randomness obtained from the xRandomness method ofÙ$** the default [sqlite3_vfs] object.ÙD** ^If the previous call to this routine had an N of 1 or more and aÙ5** non-NULL P then the pseudo-randomness is generatedÙC** internally and without recourse to the [sqlite3_vfs] xRandomnessª** method.¢*/Ù3SQLITE_API void sqlite3_randomness(int N, void *P); ¢/*Ù1** CAPI3REF: Compile-Time Authorization Callbacks²** METHOD: sqlite3Ù"** KEYWORDS: {authorizer callback}¢**ÙC** ^This routine registers an authorizer callback with a particularÙ9** [database connection], supplied in the first argument.ÙK** ^The authorizer callback is invoked as SQL statements are being compiledÙA** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],ÙK** [sqlite3_prepare_v3()], [sqlite3_prepare16()], [sqlite3_prepare16_v2()],Ù-** and [sqlite3_prepare16_v3()].  ^At variousÙC** points during the compilation process, as logic is being createdÙD** to perform various actions, the authorizer callback is invoked toÙE** see if those actions are allowed.  ^The authorizer callback shouldÙJ** return [SQLITE_OK] to allow the action, [SQLITE_IGNORE] to disallow theÙ@** specific action but allow the SQL statement to continue to beÙE** compiled, or [SQLITE_DENY] to cause the entire SQL statement to beÙ?** rejected with an error.  ^If the authorizer callback returnsÙF** any value other than [SQLITE_IGNORE], [SQLITE_OK], or [SQLITE_DENY]ÙD** then the [sqlite3_prepare_v2()] or equivalent call that triggeredÙ2** the authorizer will fail with an error message.¢**ÙB** When the callback returns [SQLITE_OK], that means the operationÙB** requested is ok.  ^When the callback returns [SQLITE_DENY], theÙ?** [sqlite3_prepare_v2()] or equivalent call that triggered theÙ=** authorizer will fail with an error message explaining thatµ** access is denied. ¢**ÙI** ^The first parameter to the authorizer callback is a copy of the thirdÙM** parameter to the sqlite3_set_authorizer() interface. ^The second parameterÙK** to the callback is an integer [SQLITE_COPY | action code] that specifiesÙN** the particular action to be authorized. ^The third through sixth parametersÙF** to the callback are either NULL pointers or zero-terminated stringsÙE** that contain additional details about the action to be authorized.ÙJ** Applications must always be prepared to encounter a NULL pointer in anyÙK** of the third through the sixth parameters of the authorization callback.¢**Ù'** ^If the action code is [SQLITE_READ]Ù4** and the callback returns [SQLITE_IGNORE] then theÙ>** [prepared statement] statement is constructed to substituteÙ<** a NULL value in place of the table column that would haveÙC** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]ÙD** return can be used to deny an untrusted user access to individual¶** columns of a table.ÙE** ^When a table is referenced by a [SELECT] but no column values areÙ9** extracted from that table (for example in a query likeÙI** "SELECT count(*) FROM tab") then the [SQLITE_READ] authorizer callbackÙM** is invoked once for that table with a column name that is an empty string.ÙB** ^If the action code is [SQLITE_DELETE] and the callback returnsÙ?** [SQLITE_IGNORE] then the [DELETE] operation proceeds but theÙM** [truncate optimization] is disabled and all rows are deleted individually.¢**Ù;** An authorizer is used when [sqlite3_prepare | preparing]ÙM** SQL statements from an untrusted source, to ensure that the SQL statementsÙM** do not try to access data they are not allowed to see, or that they do notÙE** try to execute malicious statements that damage the database.  ForÙ>** example, an application may allow a user to enter arbitraryÙF** SQL queries for evaluation by a database.  But the application doesÙ@** not want the user to be able to make arbitrary changes to theÙ@** database.  An authorizer could then be put in place while theÙ>** user-entered SQL is being [sqlite3_prepare | prepared] thatÙ3** disallows everything except [SELECT] statements.¢**Ù?** Applications that need to process SQL from untrusted sourcesÙG** might also consider lowering resource limits using [sqlite3_limit()]ÙA** and limiting database size using the [max_page_count] [PRAGMA]Ù&** in addition to using an authorizer.¢**ÙF** ^(Only a single authorizer can be in place on a database connectionÙ@** at a time.  Each call to sqlite3_set_authorizer overrides theÙK** previous call.)^  ^Disable the authorizer by installing a NULL callback.Ù)** The authorizer is disabled by default.¢**Ù@** The authorizer callback must not do anything that will modifyÙ@** the database connection that invoked the authorizer callback.ÙJ** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify theirÙF** database connections for the meaning of "modify" in this paragraph.¢**ÙC** ^When [sqlite3_prepare_v2()] is used to prepare a statement, theÙC** statement might be re-prepared during [sqlite3_step()] due to a Ù@** schema change.  Hence, the application should ensure that theÙL** correct authorizer callback remains in place during the [sqlite3_step()].¢**Ù<** ^Note that the authorizer callback is invoked only duringÙ=** [sqlite3_prepare()] or its variants.  Authorization is notÙD** performed during statement evaluation in [sqlite3_step()], unlessÙ>** as stated in the previous paragraph, sqlite3_step() invokesÙG** sqlite3_prepare_v2() to reprepare a statement after a schema change.¢*/Ù&SQLITE_API int sqlite3_set_authorizer(«  sqlite3*,ÙJ  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),±  void *pUserData¢); ¢/*Ù$** CAPI3REF: Authorizer Return Codes¢**ÙC** The [sqlite3_set_authorizer | authorizer callback function] mustÙC** return either [SQLITE_OK] or one of these two constants in orderÙD** to signal SQLite whether or not the action is permitted.  See theÙE** [sqlite3_set_authorizer | authorizer documentation] for additional¯** information.¢**ÙG** Note that SQLITE_IGNORE is also used as a [conflict resolution mode]Ù<** returned from the [sqlite3_vtab_on_conflict()] interface.¢*/ÙE#define SQLITE_DENY   1   /* Abort the SQL statement with an error */ÙO#define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */ ¢/*Ù$** CAPI3REF: Authorizer Action Codes¢**ÙI** The [sqlite3_set_authorizer()] interface registers a callback functionÙC** that is invoked to authorize certain SQL statement actions.  TheÙE** second parameter to the callback is an integer code that specifiesÙL** what action is being authorized.  These are the integer action codes thatÙ)** the authorizer callback may be passed.¢**ÙC** These action code values signify what kind of operation is to beÙ?** authorized.  The 3rd and 4th parameters to the authorizationÙK** callback function will be parameters or NULL depending on which of theseÙE** codes is used as the second parameter.  ^(The 5th parameter to theÙC** authorizer callback is the name of the database ("main", "temp",ÙH** etc.) if applicable.)^  ^The 6th parameter to the authorizer callbackÙH** is the name of the inner-most trigger or view that is responsible forÙE** the access attempt or NULL if this access attempt is directly from¶** top-level SQL code.¢*/ÙN/******************************************* 3rd ************ 4th ***********/ÙN#define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */ÙN#define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */ÙN#define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */ÙN#define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */ÙN#define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */ÙN#define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */ÙN#define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */ÙN#define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */ÙN#define SQLITE_DELETE                9   /* Table Name      NULL            */ÙN#define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */ÙN#define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */ÙN#define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */ÙN#define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */ÙN#define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */ÙN#define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */ÙN#define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */ÙN#define SQLITE_DROP_VIEW            17   /* View Name       NULL            */ÙN#define SQLITE_INSERT               18   /* Table Name      NULL            */ÙN#define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */ÙN#define SQLITE_READ                 20   /* Table Name      Column Name     */ÙN#define SQLITE_SELECT               21   /* NULL            NULL            */ÙN#define SQLITE_TRANSACTION          22   /* Operation       NULL            */ÙN#define SQLITE_UPDATE               23   /* Table Name      Column Name     */ÙN#define SQLITE_ATTACH               24   /* Filename        NULL            */ÙN#define SQLITE_DETACH               25   /* Database Name   NULL            */ÙN#define SQLITE_ALTER_TABLE          26   /* Database Name   Table Name      */ÙN#define SQLITE_REINDEX              27   /* Index Name      NULL            */ÙN#define SQLITE_ANALYZE              28   /* Table Name      NULL            */ÙN#define SQLITE_CREATE_VTABLE        29   /* Table Name      Module Name     */ÙN#define SQLITE_DROP_VTABLE          30   /* Table Name      Module Name     */ÙN#define SQLITE_FUNCTION             31   /* NULL            Function Name   */ÙN#define SQLITE_SAVEPOINT            32   /* Operation       Savepoint Name  */Ù=#define SQLITE_COPY                  0   /* No longer used */ÙN#define SQLITE_RECURSIVE            33   /* NULL            NULL            */ ¢/*Ù,** CAPI3REF: Tracing And Profiling Functions²** METHOD: sqlite3¢**ÙH** These routines are deprecated. Use the [sqlite3_trace_v2()] interfaceÙ*** instead of the routines described here.¢**ÙB** These routines register callback functions that can be used forÙ9** tracing and profiling the execution of SQL statements.¢**ÙE** ^The callback function registered by sqlite3_trace() is invoked atÙH** various times when an SQL statement is being run by [sqlite3_step()].ÙI** ^The sqlite3_trace() callback is invoked with a UTF-8 rendering of theÙ>** SQL statement text as the statement first begins executing.Ù5** ^(Additional sqlite3_trace() callbacks might occurÙG** as each triggered subprogram is entered.  The callbacks for triggersÙ=** contain a UTF-8 SQL comment that identifies the trigger.)^¢**ÙI** The [SQLITE_TRACE_SIZE_LIMIT] compile-time option can be used to limitÙN** the length of [bound parameter] expansion in the output of sqlite3_trace().¢**ÙD** ^The callback function registered by sqlite3_profile() is invokedÙB** as each SQL statement finishes.  ^The profile callback containsÙA** the original statement text and an estimate of wall-clock timeÙA** of how long that statement took to run.  ^The profile callbackÙF** time is in units of nanoseconds, however the current implementationÙI** is only capable of millisecond resolution so the six least significantÙA** digits in the time are meaningless.  Future versions of SQLiteÙB** might provide greater resolution on the profiler callback.  TheÙ?** sqlite3_profile() function is considered experimental and isÙ2** subject to change in future versions of SQLite.¢*/Ù:SQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3*,Ù,   void(*xTrace)(void*,const char*), void*);Ù<SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*,Ù=   void(*xProfile)(void*,const char*,sqlite3_uint64), void*); ¢/*Ù"** CAPI3REF: SQL Trace Event Codes¹** KEYWORDS: SQLITE_TRACE¢**ÙC** These constants identify classes of events that can be monitoredÙ@** using the [sqlite3_trace_v2()] tracing logic.  The M argumentÙK** to [sqlite3_trace_v2(D,M,X,P)] is an OR-ed combination of one or more ofÙF** the following constants.  ^The first argument to the trace callbackÙ%** is one of the following constants.¢**Ù9** New tracing constants may be added in future releases.¢**Ù<** ^A trace callback has four arguments: xCallback(T,C,P,X).Ù:** ^The T argument is one of the integer type codes above.ÙD** ^The C argument is a copy of the context pointer passed in as theÙ+** fourth argument to [sqlite3_trace_v2()].ÙA** The P and X arguments are pointers whose meanings depend on T.¢**§** <dl>Ù3** [[SQLITE_TRACE_STMT]] <dt>SQLITE_TRACE_STMT</dt>ÙJ** <dd>^An SQLITE_TRACE_STMT callback is invoked when a prepared statementÙ>** first begins running and possibly at other times during theÙD** execution of the prepared statement, such as at the start of eachÙ:** trigger subprogram. ^The P argument is a pointer to theÙG** [prepared statement]. ^The X argument is a pointer to a string whichÙJ** is the unexpanded SQL text of the prepared statement or an SQL comment ÙI** that indicates the invocation of a trigger.  ^The callback can computeÙN** the same text that would have been returned by the legacy [sqlite3_trace()]ÙI** interface by using the X argument when X begins with "--" and invokingÙ'** [sqlite3_expanded_sql(P)] otherwise.¢**Ù9** [[SQLITE_TRACE_PROFILE]] <dt>SQLITE_TRACE_PROFILE</dt>ÙH** <dd>^An SQLITE_TRACE_PROFILE callback provides approximately the sameÙB** information as is provided by the [sqlite3_profile()] callback.ÙC** ^The P argument is a pointer to the [prepared statement] and theÙB** X argument points to a 64-bit integer which is the estimated ofÙD** the number of nanosecond that the prepared statement took to run.ÙM** ^The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.¢**Ù1** [[SQLITE_TRACE_ROW]] <dt>SQLITE_TRACE_ROW</dt>ÙC** <dd>^An SQLITE_TRACE_ROW callback is invoked whenever a preparedÙ0** statement generates a single row of result.  ÙC** ^The P argument is a pointer to the [prepared statement] and the¸** X argument is unused.¢**Ù5** [[SQLITE_TRACE_CLOSE]] <dt>SQLITE_TRACE_CLOSE</dt>ÙA** <dd>^An SQLITE_TRACE_CLOSE callback is invoked when a databaseµ** connection closes.ÙC** ^The P argument is a pointer to the [database connection] objectÙ ** and the X argument is unused.¨** </dl>¢*/Ù$#define SQLITE_TRACE_STMT       0x01Ù$#define SQLITE_TRACE_PROFILE    0x02Ù$#define SQLITE_TRACE_ROW        0x04Ù$#define SQLITE_TRACE_CLOSE      0x08 ¢/*»** CAPI3REF: SQL Trace Hook²** METHOD: sqlite3¢**ÙF** ^The sqlite3_trace_v2(D,M,X,P) interface registers a trace callbackÙD** function X against [database connection] D, using property mask MÙ0** and context pointer P.  ^If the X callback isÙ@** NULL or if the M mask is zero, then tracing is disabled.  TheÙ8** M argument should be the bitwise OR-ed combination ofÙ)** zero or more [SQLITE_TRACE] constants.¢**ÙH** ^Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides ÙF** (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().¢**ÙG** ^The X callback is invoked whenever any of the events identified by ÙJ** mask M occur.  ^The integer return value from the callback is currentlyÙ@** ignored, though this may change in future releases.  CallbackÙE** implementations should return zero to ensure future compatibility.¢**ÙG** ^A trace callback is invoked with four arguments: callback(T,C,P,X).Ù/** ^The T argument is one of the [SQLITE_TRACE]Ù6** constants to indicate why the callback was invoked.Ù4** ^The C argument is a copy of the context pointer.ÙA** The P and X arguments are pointers whose meanings depend on T.¢**ÙE** The sqlite3_trace_v2() interface is intended to replace the legacyÙF** interfaces [sqlite3_trace()] and [sqlite3_profile()], both of which²** are deprecated.¢*/Ù SQLITE_API int sqlite3_trace_v2(«  sqlite3*,±  unsigned uMask,Ù.  int(*xCallback)(unsigned,void*,void*,void*),¬  void *pCtx¢); ¢/*Ù%** CAPI3REF: Query Progress Callbacks²** METHOD: sqlite3¢**ÙG** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callbackÙE** function X to be invoked periodically during long running calls toÙC** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] forÙ2** database connection D.  An example use for thisÙ;** interface is to keep a GUI updated during a large query.¢**ÙC** ^The parameter P is passed through as the only parameter to the ÙG** callback function X.  ^The parameter N is the approximate number of ÙG** [virtual machine instructions] that are evaluated between successiveÙK** invocations of the callback X.  ^If N is less than one then the progress·** handler is disabled.¢**ÙA** ^Only a single progress handler may be defined at one time perÙD** [database connection]; setting a new progress handler cancels theÙH** old one.  ^Setting parameter X to NULL disables the progress handler.ÙF** ^The progress handler is also disabled by setting N to a value lessª** than 1.¢**Ù?** ^If the progress callback returns non-zero, the operation isÙ8** interrupted.  This feature can be used to implement aÙ0** "Cancel" button on a GUI progress dialog box.¢**ÙF** The progress handler callback must not do anything that will modifyÙ=** the database connection that invoked the progress handler.ÙJ** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify theirÙF** database connections for the meaning of "modify" in this paragraph.¢**¢*/ÙNSQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*); ¢/*Ù.** CAPI3REF: Opening A New Database Connection·** CONSTRUCTOR: sqlite3¢**ÙD** ^These routines open an SQLite database file as specified by the ÙH** filename argument. ^The filename argument is interpreted as UTF-8 forÙH** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byteÙJ** order for sqlite3_open16(). ^(A [database connection] handle is usuallyÙJ** returned in *ppDb, even if an error occurs.  The only exception is thatÙG** if SQLite is unable to allocate memory to hold the [sqlite3] object,ÙJ** a NULL will be written into *ppDb instead of a pointer to the [sqlite3]ÙL** object.)^ ^(If the database is opened (and/or created) successfully, thenÙJ** [SQLITE_OK] is returned.  Otherwise an [error code] is returned.)^ ^TheÙL** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtainÙJ** an English language description of the error following a failure of anyÙ"** of the sqlite3_open() routines.¢**ÙB** ^The default encoding will be UTF-8 for databases created usingÙL** sqlite3_open() or sqlite3_open_v2().  ^The default encoding for databasesÙJ** created using sqlite3_open16() will be UTF-16 in the native byte order.¢**Ù>** Whether or not an error occurs when it is opened, resourcesÙI** associated with the [database connection] handle should be released byÙA** passing it to [sqlite3_close()] when it is no longer required.¢**Ù<** The sqlite3_open_v2() interface works like sqlite3_open()ÙJ** except that it accepts two additional parameters for additional controlÙ>** over the new database connection.  ^(The flags parameter toÙ$** sqlite3_open_v2() can take one ofÙ<** the following three values, optionally combined with the ÙM** [SQLITE_OPEN_NOMUTEX], [SQLITE_OPEN_FULLMUTEX], [SQLITE_OPEN_SHAREDCACHE],Ù@** [SQLITE_OPEN_PRIVATECACHE], and/or [SQLITE_OPEN_URI] flags:)^¢**§** <dl>Ù$** ^(<dt>[SQLITE_OPEN_READONLY]</dt>ÙJ** <dd>The database is opened in read-only mode.  If the database does notÙ.** already exist, an error is returned.</dd>)^¢**Ù%** ^(<dt>[SQLITE_OPEN_READWRITE]</dt>ÙM** <dd>The database is opened for reading and writing if possible, or readingÙJ** only if the file is write protected by the operating system.  In eitherÙO** case the database must already exist, otherwise an error is returned.</dd>)^¢**Ù<** ^(<dt>[SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]</dt>ÙH** <dd>The database is opened for reading and writing, and is created ifÙJ** it does not already exist. This is the behavior that is always used forÙ.** sqlite3_open() and sqlite3_open16().</dd>)^¨** </dl>¢**Ù>** If the 3rd parameter to sqlite3_open_v2() is not one of theÙ:** combinations shown above optionally combined with otherÙ.** [SQLITE_OPEN_READONLY | SQLITE_OPEN_* bits]Ù"** then the behavior is undefined.¢**ÙJ** ^If the [SQLITE_OPEN_NOMUTEX] flag is set, then the database connectionÙJ** opens in the multi-thread [threading mode] as long as the single-threadÙ@** mode has not been set at compile-time or start-time.  ^If theÙI** [SQLITE_OPEN_FULLMUTEX] flag is set then the database connection opensÙ>** in the serialized [threading mode] unless single-thread wasÙ5** previously selected at compile-time or start-time.ÙK** ^The [SQLITE_OPEN_SHAREDCACHE] flag causes the database connection to beÙK** eligible to use [shared cache mode], regardless of whether or not sharedÙ@** cache is enabled using [sqlite3_enable_shared_cache()].  ^TheÙH** [SQLITE_OPEN_PRIVATECACHE] flag causes the database connection to notÙ<** participate in [shared cache mode] even if it is enabled.¢**Ù@** ^The fourth parameter to sqlite3_open_v2() is the name of theÙH** [sqlite3_vfs] object that defines the operating system interface thatÙG** the new database connection should use.  ^If the fourth parameter isÙ@** a NULL pointer then the default [sqlite3_vfs] object is used.¢**ÙO** ^If the filename is ":memory:", then a private, temporary in-memory databaseÙL** is created for the connection.  ^This in-memory database will vanish whenÙF** the database connection is closed.  Future versions of SQLite mightÙN** make use of additional special filenames that begin with the ":" character.ÙK** It is recommended that when a database filename actually does begin withÙI** a ":" character you should prefix the filename with a pathname such as»** "./" to avoid ambiguity.¢**ÙA** ^If the filename is an empty string, then a private, temporaryÙD** on-disk database will be created.  ^This private database will beÙF** automatically deleted as soon as the database connection is closed.¢**Ù=** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>¢**ÙJ** ^If [URI filename] interpretation is enabled, and the filename argumentÙG** begins with "file:", then the filename is interpreted as a URI. ^URIÙF** filename interpretation is enabled if the [SQLITE_OPEN_URI] flag isÙ?** set in the third argument to sqlite3_open_v2(), or if it hasÙF** been enabled globally using the [SQLITE_CONFIG_URI] option with theÙL** [sqlite3_config()] method or by the [SQLITE_USE_URI] compile-time option.Ù,** URI filename interpretation is turned offÙF** by default, but future releases of SQLite might enable URI filenameÙC** interpretation by default.  See "[URI filenames]" for additional¯** information.¢**ÙJ** URI filenames are parsed according to RFC 3986. ^If the URI contains anÙC** authority, then it must be either an empty string or the string ÙL** "localhost". ^If the authority is not an empty string or "localhost", an ÙI** error is returned to the caller. ^The fragment component of a URI, if ·** present, is ignored.¢**ÙJ** ^SQLite uses the path component of the URI as the name of the disk fileÙJ** which contains the database. ^If the path begins with a '/' character, ÙK** then it is interpreted as an absolute path. ^If the path does not begin ÙJ** with a '/' (meaning that the authority section is omitted from the URI)Ù4** then the path is interpreted as a relative path. Ù9** ^(On windows, the first component of an absolute path Ù*** is a drive specification (e.g. "C:").)^¢**Ù ** [[core URI query parameters]]ÙK** The query component of a URI may contain parameters that are interpretedÙF** either by SQLite itself, or by a [VFS | custom VFS implementation].Ù0** SQLite and its built-in [VFSes] interpret the¾** following query parameters:¢**§** <ul>ÙM**   <li> <b>vfs</b>: ^The "vfs" parameter may be used to specify the name ofÙL**     a VFS object that provides the operating system interface that shouldÙM**     be used to access the database file on disk. ^If this option is set toÙM**     an empty string the default VFS object is used. ^Specifying an unknownÙK**     VFS is an error. ^If sqlite3_open_v2() is used and the vfs option isÙJ**     present, then the VFS specified by the option takes precedence overÙE**     the value passed as the fourth parameter to sqlite3_open_v2().¢**ÙL**   <li> <b>mode</b>: ^(The mode parameter may be set to either "ro", "rw",ÙE**     "rwc", or "memory". Attempting to set it to any other value is³**     an error)^. ÙH**     ^If "ro" is specified, then the database is opened for read-only ÙN**     access, just as if the [SQLITE_OPEN_READONLY] flag had been set in the ÙJ**     third argument to sqlite3_open_v2(). ^If the mode option is set to ÙI**     "rw", then the database is opened for read-write (but not create) ÙL**     access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had Ù<**     been set. ^Value "rwc" is equivalent to setting both ÙL**     SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.  ^If the mode option isÙH**     set to "memory" then a pure [in-memory database] that never readsÙJ**     or writes from disk is used. ^It is an error to specify a value forÙI**     the mode parameter that is less restrictive than that specified byÙD**     the flags passed in the third parameter to sqlite3_open_v2().¢**ÙM**   <li> <b>cache</b>: ^The cache parameter may be set to either "shared" orÙF**     "private". ^Setting it to "shared" is equivalent to setting theÙB**     SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed toÙG**     sqlite3_open_v2(). ^Setting the cache parameter to "private" is Ù>**     equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit.ÙL**     ^If sqlite3_open_v2() is used and the "cache" parameter is present inÙL**     a URI filename, its value overrides any behavior requested by settingÙ@**     SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.¢**ÙF**  <li> <b>psow</b>: ^The psow parameter indicates whether or not theÙC**     [powersafe overwrite] property does or does not apply to theÙ8**     storage media on which the database file resides.¢**ÙJ**  <li> <b>nolock</b>: ^The nolock parameter is a boolean query parameterÙJ**     which if set disables file locking in rollback journal modes.  ThisÙG**     is useful for accessing a database on a filesystem that does notÙJ**     support locking.  Caution:  Database corruption might result if twoÙH**     or more processes write to the same database and any one of those¿**     processes uses nolock=1.¢**ÙF**  <li> <b>immutable</b>: ^The immutable parameter is a boolean queryÙC**     parameter that indicates that the database file is stored onÙH**     read-only media.  ^When immutable is set, SQLite assumes that theÙE**     database file cannot be changed, even by a process with higherÙI**     privilege, and so the database is opened read-only and all lockingÙH**     and change detection is disabled.  Caution: Setting the immutableÙF**     property on a database file that does in fact change can resultÙA**     in incorrect query results and/or [SQLITE_CORRUPT] errors.Ù***     See also: [SQLITE_IOCAP_IMMUTABLE].©**       ¨** </ul>¢**ÙM** ^Specifying an unknown parameter in the query component of a URI is not anÙF** error.  Future versions of SQLite might understand additional queryÙK** parameters.  See "[query parameters with special meaning to SQLite]" forº** additional information.¢**Ù;** [[URI filename examples]] <h3>URI filename examples</h3>¢**Ù0** <table border="1" align=center cellpadding=5>Ù&** <tr><th> URI filenames <th> Results¾** <tr><td> file:data.db <td> Ù=**          Open the file "data.db" in the current directory.Ù'** <tr><td> file:/home/fred/data.db<br>Ù+**          file:///home/fred/data.db <br> Ù9**          file://localhost/home/fred/data.db <br> <td> Ù8**          Open the database file "/home/fred/data.db".Ù3** <tr><td> file://darkstar/home/fred/data.db <td> Ù?**          An error. "darkstar" is not a recognized authority.Ù'** <tr><td style="white-space:nowrap"> ÙF**          file:///C:/Documents%20and%20Settings/fred/Desktop/data.dbÙL**     <td> Windows only: Open the file "data.db" on fred's desktop on driveÙK**          C:. Note that the %20 escaping in this example is not strictly Ù>**          necessary - space characters can be used literally½**          in URI filenames.Ù4** <tr><td> file:data.db?mode=ro&cache=private <td> ÙN**          Open file "data.db" in the current directory for read-only access.ÙH**          Regardless of whether or not shared-cache mode is enabled byÙ)**          default, use a private cache.Ù9** <tr><td> file:/home/fred/data.db?vfs=unix-dotfile <td>ÙN**          Open file "/home/fred/data.db". Use the special VFS "unix-dotfile"ÙC**          that uses dot-files in place of posix advisory locking.Ù,** <tr><td> file:data.db?mode=readonly <td> ÙP**          An error. "readonly" is not a valid option for the "mode" parameter.«** </table>¢**ÙL** ^URI hexadecimal escape sequences (%HH) are supported within the path andÙI** query components of a URI. A hexadecimal escape sequence consists of aÙC** percent sign - "%" - followed by exactly two hexadecimal digits ÙG** specifying an octet value. ^Before the path or query components of aÙF** URI filename are interpreted, they are encoded using UTF-8 and all ÙH** hexadecimal escape sequences replaced by a single byte containing theÙL** corresponding octet. If this process generates an invalid UTF-8 encoding,½** the results are undefined.¢**ÙM** <b>Note to Windows users:</b>  The encoding used for the filename argumentÙF** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whateverÙE** codepage is currently defined.  Filenames containing internationalÙC** characters must be converted to UTF-8 prior to passing them intoÙ'** sqlite3_open() or sqlite3_open_v2().¢**ÙM** <b>Note to Windows Runtime users:</b>  The temporary directory must be setÙL** prior to calling sqlite3_open() or sqlite3_open_v2().  Otherwise, variousÙ=** features that require the use of temporary files may fail.¢**Ù%** See also: [sqlite3_temp_directory]¢*/¼SQLITE_API int sqlite3_open(Ù9  const char *filename,   /* Database filename (UTF-8) */Ù5  sqlite3 **ppDb          /* OUT: SQLite db handle */¢);¾SQLITE_API int sqlite3_open16(Ù:  const void *filename,   /* Database filename (UTF-16) */Ù5  sqlite3 **ppDb          /* OUT: SQLite db handle */¢);¿SQLITE_API int sqlite3_open_v2(Ù9  const char *filename,   /* Database filename (UTF-8) */Ù5  sqlite3 **ppDb,         /* OUT: SQLite db handle */Ù%  int flags,              /* Flags */Ù9  const char *zVfs        /* Name of VFS module to use */¢); ¢/*Ù-** CAPI3REF: Obtain Values For URI Parameters¢**ÙH** These are utility routines, useful to VFS implementations, that checkÙG** to see if a database file was a URI that contained a specific query ÙB** parameter, and if so obtains the value of that query parameter.¢**ÙK** If F is the database filename pointer passed into the xOpen() method of ÙG** a VFS implementation when the flags parameter to xOpen() has one or ÙF** more of the [SQLITE_OPEN_URI] or [SQLITE_OPEN_MAIN_DB] bits set andÙ-** P is the name of the query parameter, thenÙ8** sqlite3_uri_parameter(F,P) returns the value of the PÙF** parameter if it exists or a NULL pointer if P does not appear as a Ù8** query parameter on F.  If P is a query parameter of FÙA** has no explicit value, then sqlite3_uri_parameter(F,P) returnsÙ ** a pointer to an empty string.¢**ÙE** The sqlite3_uri_boolean(F,P,B) routine assumes that P is a booleanÙE** parameter and returns true (1) or false (0) according to the valueÙH** of P.  The sqlite3_uri_boolean(F,P,B) routine returns true (1) if theÙE** value of query parameter P is one of "yes", "true", or "on" in anyÙ<** case or if the value begins with a non-zero number.  The ÙH** sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value ofÙE** query parameter P is one of "no", "false", or "off" in any case orÙ@** if the value begins with a numeric zero.  If P is not a queryÙC** parameter on F or if the value of P is does not match any of theÙ9** above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).¢**ÙF** The sqlite3_uri_int64(F,P,D) routine converts the value of P into aÙE** 64-bit signed integer and returns that integer, or D if P does notÙE** exist.  If the value of P is something other than an integer, then´** zero is returned.£** ÙK** If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL andÙH** sqlite3_uri_boolean(F,P,B) returns B.  If F is not a NULL pointer andÙL** is not a database file pathname pointer that SQLite passed into the xOpenÙJ** VFS method, then the behavior of this routine is undefined and probably¯** undesirable.¢*/ÙXSQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);ÙXSQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);ÙTSQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);  ¢/*Ù%** CAPI3REF: Error Codes And Messages²** METHOD: sqlite3¢**Ù:** ^If the most recent sqlite3_* API call associated with ÙH** [database connection] D failed, then the sqlite3_errcode(D) interfaceÙG** returns the numeric [result code] or [extended result code] for that¬** API call.Ù.** If the most recent API call was successful,Ù=** then the return value from sqlite3_errcode() is undefined.Ù"** ^The sqlite3_extended_errcode()Ù;** interface is the same except that it always returns the Ù=** [extended result code] even when extended result codes are¬** disabled.¢**ÙG** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-languageÙI** text that describes the error, as either UTF-8 or UTF-16 respectively.ÙC** ^(Memory to hold the error message string is managed internally.ÙC** The application does not need to worry about freeing the result.ÙC** However, the error string might be overwritten or deallocated byÙ:** subsequent calls to other SQLite interface functions.)^¢**ÙD** ^The sqlite3_errstr() interface returns the English-language textÙ.** that describes the [result code], as UTF-8.ÙB** ^(Memory to hold the error message string is managed internallyÙ.** and must not be freed by the application)^.¢**ÙB** When the serialized [threading mode] is in use, it might be theÙB** case that a second error occurs on a separate thread in betweenÙ@** the time of the first error and the call to these interfaces.ÙC** When that happens, the second error will be reported since theseÙ=** interfaces always report the most recent result.  To avoidÙL** this, each thread can obtain exclusive use of the [database connection] DÙL** by invoking [sqlite3_mutex_enter]([sqlite3_db_mutex](D)) before beginningÙK** to use D and invoking [sqlite3_mutex_leave]([sqlite3_db_mutex](D)) afterÙ9** all calls to the interfaces listed here are completed.¢**ÙE** If an interface fails with SQLITE_MISUSE, that means the interfaceÙA** was invoked incorrectly by the application.  In that case, theÙ0** error code and message may or may not be set.¢*/Ù,SQLITE_API int sqlite3_errcode(sqlite3 *db);Ù5SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);Ù0SQLITE_API const char *sqlite3_errmsg(sqlite3*);Ù2SQLITE_API const void *sqlite3_errmsg16(sqlite3*);Ù+SQLITE_API const char *sqlite3_errstr(int); ¢/*Ù&** CAPI3REF: Prepared Statement ObjectÙ7** KEYWORDS: {prepared statement} {prepared statements}¢**ÙD** An instance of this object represents a single SQL statement thatÙC** has been compiled into binary form and is ready to be evaluated.¢**ÙC** Think of each SQL statement as a separate computer program.  TheÙB** original SQL text is source code.  A prepared statement object ÙA** is the compiled object code.  All SQL must be converted into aÙ+** prepared statement before it can be run.¢**ÙH** The life-cycle of a prepared statement object usually goes like this:¢**§** <ol>ÙJ** <li> Create the prepared statement object using [sqlite3_prepare_v2()].Ù>** <li> Bind values to [parameters] using the sqlite3_bind_*()³**      interfaces.ÙB** <li> Run the SQL by calling [sqlite3_step()] one or more times.ÙI** <li> Reset the prepared statement using [sqlite3_reset()] then go backÙ/**      to step 2.  Do this zero or more times.Ù6** <li> Destroy the object using [sqlite3_finalize()].¨** </ol>¢*/Ù)typedef struct sqlite3_stmt sqlite3_stmt; ¢/*¼** CAPI3REF: Run-time Limits²** METHOD: sqlite3¢**ÙG** ^(This interface allows the size of various constructs to be limitedÙC** on a connection by connection basis.  The first parameter is theÙB** [database connection] whose limit is to be set or queried.  TheÙB** second parameter is one of the [limit categories] that define aÙF** class of constructs to be size limited.  The third parameter is theÙ"** new limit for that construct.)^¢**ÙB** ^If the new limit is a negative number, the limit is unchanged.ÙA** ^(For each limit category SQLITE_LIMIT_<i>NAME</i> there is a ¾** [limits | hard upper bound]Ù7** set at compile-time by a C preprocessor macro calledÙ%** [limits | SQLITE_MAX_<i>NAME</i>].Ù7** (The "_LIMIT_" in the name is changed to "_MAX_".))^Ù?** ^Attempts to increase a limit above its hard upper bound areÙ.** silently truncated to the hard upper bound.¢**Ù<** ^Regardless of whether or not the limit was changed, the ÙD** [sqlite3_limit()] interface returns the prior value of the limit.ÙD** ^Hence, to find the current value of a limit without changing it,ÙC** simply invoke this interface with the third parameter set to -1.¢**ÙC** Run-time limits are intended for use in applications that manageÙJ** both their own internal database and also databases that are controlledÙD** by untrusted external sources.  An example application might be aÙA** web browser that has its own databases for storing history andÙF** separate databases controlled by JavaScript applications downloadedÙ=** off the Internet.  The internal databases can be given theÙD** large, default limits.  Databases managed by external sources canÙG** be given much smaller limits designed to prevent a denial of serviceÙL** attack.  Developers might also want to use the [sqlite3_set_authorizer()]ÙH** interface to further control untrusted SQL.  The size of the databaseÙ<** created by an untrusted script can be contained using the½** [max_page_count] [PRAGMA].¢**ÙA** New run-time limit categories may be added in future releases.¢*/Ù;SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal); ¢/*Ù&** CAPI3REF: Run-Time Limit CategoriesÙ1** KEYWORDS: {limit category} {*limit categories}¢**Ù4** These constants define various performance limitsÙ;** that can be lowered at run-time using [sqlite3_limit()].ÙE** The synopsis of the meanings of the various limits is shown below.ÙF** Additional information is available at [limits | Limits in SQLite].¢**§** <dl>Ù9** [[SQLITE_LIMIT_LENGTH]] ^(<dt>SQLITE_LIMIT_LENGTH</dt>ÙK** <dd>The maximum size of any string or BLOB or table row, in bytes.<dd>)^¢**ÙA** [[SQLITE_LIMIT_SQL_LENGTH]] ^(<dt>SQLITE_LIMIT_SQL_LENGTH</dt>Ù?** <dd>The maximum length of an SQL statement, in bytes.</dd>)^¢**Ù9** [[SQLITE_LIMIT_COLUMN]] ^(<dt>SQLITE_LIMIT_COLUMN</dt>ÙD** <dd>The maximum number of columns in a table definition or in theÙH** result set of a [SELECT] or the maximum number of columns in an indexÙ/** or in an ORDER BY or GROUP BY clause.</dd>)^¢**ÙA** [[SQLITE_LIMIT_EXPR_DEPTH]] ^(<dt>SQLITE_LIMIT_EXPR_DEPTH</dt>ÙD** <dd>The maximum depth of the parse tree on any expression.</dd>)^¢**ÙK** [[SQLITE_LIMIT_COMPOUND_SELECT]] ^(<dt>SQLITE_LIMIT_COMPOUND_SELECT</dt>ÙI** <dd>The maximum number of terms in a compound SELECT statement.</dd>)^¢**Ù;** [[SQLITE_LIMIT_VDBE_OP]] ^(<dt>SQLITE_LIMIT_VDBE_OP</dt>ÙF** <dd>The maximum number of instructions in a virtual machine programÙD** used to implement an SQL statement.  If [sqlite3_prepare_v2()] orÙI** the equivalent tries to allocate space for more than this many opcodesÙL** in a single prepared statement, an SQLITE_NOMEM error is returned.</dd>)^¢**ÙE** [[SQLITE_LIMIT_FUNCTION_ARG]] ^(<dt>SQLITE_LIMIT_FUNCTION_ARG</dt>Ù<** <dd>The maximum number of arguments on a function.</dd>)^¢**Ù=** [[SQLITE_LIMIT_ATTACHED]] ^(<dt>SQLITE_LIMIT_ATTACHED</dt>ÙB** <dd>The maximum number of [ATTACH | attached databases].)^</dd>¢**Ù'** [[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]]Ù.** ^(<dt>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</dt>ÙB** <dd>The maximum length of the pattern argument to the [LIKE] or»** [GLOB] operators.</dd>)^¢**Ù#** [[SQLITE_LIMIT_VARIABLE_NUMBER]]Ù*** ^(<dt>SQLITE_LIMIT_VARIABLE_NUMBER</dt>ÙI** <dd>The maximum index number of any [parameter] in an SQL statement.)^¢**ÙG** [[SQLITE_LIMIT_TRIGGER_DEPTH]] ^(<dt>SQLITE_LIMIT_TRIGGER_DEPTH</dt>Ù:** <dd>The maximum depth of recursion for triggers.</dd>)^¢**ÙI** [[SQLITE_LIMIT_WORKER_THREADS]] ^(<dt>SQLITE_LIMIT_WORKER_THREADS</dt>ÙC** <dd>The maximum number of auxiliary worker threads that a singleÙ)** [prepared statement] may start.</dd>)^¨** </dl>¢*/Ù0#define SQLITE_LIMIT_LENGTH                    0Ù0#define SQLITE_LIMIT_SQL_LENGTH                1Ù0#define SQLITE_LIMIT_COLUMN                    2Ù0#define SQLITE_LIMIT_EXPR_DEPTH                3Ù0#define SQLITE_LIMIT_COMPOUND_SELECT           4Ù0#define SQLITE_LIMIT_VDBE_OP                   5Ù0#define SQLITE_LIMIT_FUNCTION_ARG              6Ù0#define SQLITE_LIMIT_ATTACHED                  7Ù0#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8Ù0#define SQLITE_LIMIT_VARIABLE_NUMBER           9Ù0#define SQLITE_LIMIT_TRIGGER_DEPTH            10Ù0#define SQLITE_LIMIT_WORKER_THREADS           11 ¢/*º** CAPI3REF: Prepare Flags¢**Ù?** These constants define various flags that can be passed intoÙ:** "prepFlags" parameter of the [sqlite3_prepare_v3()] andÙ'** [sqlite3_prepare16_v3()] interfaces.¢**Ù7** New flags may be added in future releases of SQLite.¢**§** <dl>ÙE** [[SQLITE_PREPARE_PERSISTENT]] ^(<dt>SQLITE_PREPARE_PERSISTENT</dt>ÙH** <dd>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query plannerÙC** that the prepared statement will be retained for a long time andÙK** probably reused many times.)^ ^Without this flag, [sqlite3_prepare_v3()]ÙH** and [sqlite3_prepare16_v3()] assume that the prepared statement will ÙD** be used just once or at most a few times and then destroyed usingÙH** [sqlite3_finalize()] relatively soon. The current implementation actsÙF** on this hint by avoiding the use of [lookaside memory] so as not toÙD** deplete the limited store of lookaside memory. Future versions ofÙ+** SQLite may act on this hint differently.¨** </dl>¢*/Ù3#define SQLITE_PREPARE_PERSISTENT              0x01 ¢/*Ù'** CAPI3REF: Compiling An SQL StatementÙ%** KEYWORDS: {SQL statement compiler}²** METHOD: sqlite3¼** CONSTRUCTOR: sqlite3_stmt¢**ÙJ** To execute an SQL statement, it must first be compiled into a byte-codeÙK** program using one of these routines.  Or, in other words, these routinesÙ8** are constructors for the [prepared statement] object.¢**Ù?** The preferred routine to use is [sqlite3_prepare_v2()].  TheÙA** [sqlite3_prepare()] interface is legacy and should be avoided.ÙF** [sqlite3_prepare_v3()] has an extra "prepFlags" option that is used¸** for special purposes.¢**ÙD** The use of the UTF-8 interfaces is preferred, as SQLite currentlyÙD** does all parsing using UTF-8.  The UTF-16 interfaces are providedÙB** as a convenience.  The UTF-16 interfaces work by converting theÙJ** input text into UTF-8, then invoking the corresponding UTF-8 interface.¢**ÙG** The first argument, "db", is a [database connection] obtained from aÙD** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] orÙJ** [sqlite3_open16()].  The database connection must not have been closed.¢**ÙH** The second argument, "zSql", is the statement to be compiled, encodedÙK** as either UTF-8 or UTF-16.  The sqlite3_prepare(), sqlite3_prepare_v2(),»** and sqlite3_prepare_v3()ÙI** interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(),Ù)** and sqlite3_prepare16_v3() use UTF-16.¢**ÙB** ^If the nByte argument is negative, then zSql is read up to theÙ?** first zero terminator. ^If nByte is positive, then it is theÙG** number of bytes read from zSql.  ^If nByte is zero, then no preparedº** statement is generated.ÙG** If the caller knows that the supplied string is nul-terminated, thenÙL** there is a small performance advantage to passing an nByte parameter thatÙ>** is the number of bytes in the input string <i>including</i>¶** the nul-terminator.¢**ÙI** ^If pzTail is not NULL then *pzTail is made to point to the first byteÙH** past the end of the first SQL statement in zSql.  These routines onlyÙF** compile the first statement in zSql, so *pzTail is left pointing to»** what remains uncompiled.¢**ÙK** ^*ppStmt is left pointing to a compiled [prepared statement] that can beÙJ** executed using [sqlite3_step()].  ^If there is an error, *ppStmt is setÙI** to NULL.  ^If the input text contains no SQL (if the input is an emptyÙ4** string or a comment) then *ppStmt is set to NULL.ÙA** The calling procedure is responsible for deleting the compiledÙJ** SQL statement using [sqlite3_finalize()] after it has finished with it.º** ppStmt may not be NULL.¢**ÙL** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];Ù)** otherwise an [error code] is returned.¢**ÙJ** The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(),ÙN** and sqlite3_prepare16_v3() interfaces are recommended for all new programs.ÙC** The older interfaces (sqlite3_prepare() and sqlite3_prepare16())ÙJ** are retained for backwards compatibility, but their use is discouraged.Ù2** ^In the "vX" interfaces, the prepared statementÙF** that is returned (the [sqlite3_stmt] object) contains a copy of theÙC** original SQL text. This causes the [sqlite3_step()] interface toÙ$** behave differently in three ways:¢**§** <ol>§** <li>ÙN** ^If the database schema changes, instead of returning [SQLITE_SCHEMA] as itÙK** always used to do, [sqlite3_step()] will automatically recompile the SQLÙJ** statement and try to run it again. As many as [SQLITE_MAX_SCHEMA_RETRY]ÙJ** retries will occur before sqlite3_step() gives up and returns an error.¨** </li>¢**§** <li>ÙJ** ^When an error occurs, [sqlite3_step()] will return one of the detailedÙJ** [error codes] or [extended error codes].  ^The legacy behavior was thatÙJ** [sqlite3_step()] would only return a generic [SQLITE_ERROR] result codeÙL** and the application would have to make a second call to [sqlite3_reset()]ÙN** in order to find the underlying cause of the problem. With the "v2" prepareÙK** interfaces, the underlying reason for the error is returned immediately.¨** </li>¢**§** <li>ÙG** ^If the specific value bound to [parameter | host parameter] in the ÙI** WHERE clause might influence the choice of query plan for a statement,ÙM** then the statement will be automatically recompiled, as if there had been ÙL** a schema change, on the first  [sqlite3_step()] call following any changeÙ>** to the [sqlite3_bind_text | bindings] of that [parameter]. ÙG** ^The specific value of WHERE-clause [parameter] might influence the ÙJ** choice of query plan if the parameter is the left-hand side of a [LIKE]ÙJ** or [GLOB] operator or if the parameter is compared to an indexed columnÙ@** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.¨** </li>¨** </ol>¢**ÙL** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in havingÙL** the extra prepFlags parameter, which is a bit array consisting of zero orÙH** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^TheÙ;** sqlite3_prepare_v2() interface works exactly the same asÙ8** sqlite3_prepare_v3() with a zero prepFlags parameter.¢*/¿SQLITE_API int sqlite3_prepare(Ù/  sqlite3 *db,            /* Database handle */Ù<  const char *zSql,       /* SQL statement, UTF-8 encoded */Ù@  int nByte,              /* Maximum length of zSql in bytes. */Ù5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ÙF  const char **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ù"SQLITE_API int sqlite3_prepare_v2(Ù/  sqlite3 *db,            /* Database handle */Ù<  const char *zSql,       /* SQL statement, UTF-8 encoded */Ù@  int nByte,              /* Maximum length of zSql in bytes. */Ù5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ÙF  const char **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ù"SQLITE_API int sqlite3_prepare_v3(Ù/  sqlite3 *db,            /* Database handle */Ù<  const char *zSql,       /* SQL statement, UTF-8 encoded */Ù@  int nByte,              /* Maximum length of zSql in bytes. */ÙB  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */Ù5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ÙF  const char **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ù!SQLITE_API int sqlite3_prepare16(Ù/  sqlite3 *db,            /* Database handle */Ù=  const void *zSql,       /* SQL statement, UTF-16 encoded */Ù@  int nByte,              /* Maximum length of zSql in bytes. */Ù5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ÙF  const void **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ù$SQLITE_API int sqlite3_prepare16_v2(Ù/  sqlite3 *db,            /* Database handle */Ù=  const void *zSql,       /* SQL statement, UTF-16 encoded */Ù@  int nByte,              /* Maximum length of zSql in bytes. */Ù5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ÙF  const void **pzTail     /* OUT: Pointer to unused portion of zSql */¢);Ù$SQLITE_API int sqlite3_prepare16_v3(Ù/  sqlite3 *db,            /* Database handle */Ù=  const void *zSql,       /* SQL statement, UTF-16 encoded */Ù@  int nByte,              /* Maximum length of zSql in bytes. */ÙB  unsigned int prepFlags, /* Zero or more SQLITE_PREPARE_ flags */Ù5  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */ÙF  const void **pzTail     /* OUT: Pointer to unused portion of zSql */¢); ¢/*Ù%** CAPI3REF: Retrieving Statement SQL·** METHOD: sqlite3_stmt¢**ÙI** ^The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8Ù:** SQL text used to create [prepared statement] P if P wasÙ=** created by [sqlite3_prepare_v2()], [sqlite3_prepare_v3()],Ù9** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].ÙF** ^The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8Ù>** string containing the SQL text of prepared statement P with¿** [bound parameters] expanded.¢**ÙB** ^(For example, if a prepared statement is created using the SQLÙI** text "SELECT $abc,:xyz" and if parameter $abc is bound to integer 2345Ù@** and parameter :xyz is unbound, then sqlite3_sql() will returnÙE** the original string, "SELECT $abc,:xyz" but sqlite3_expanded_sql()Ù$** will return "SELECT 2345,NULL".)^¢**ÙL** ^The sqlite3_expanded_sql() interface returns NULL if insufficient memoryÙE** is available to hold the result, or if the result would exceed theÙE** the maximum string length determined by the [SQLITE_LIMIT_LENGTH].¢**ÙH** ^The [SQLITE_TRACE_SIZE_LIMIT] compile-time option limits the size ofÙE** bound parameter expansions.  ^The [SQLITE_OMIT_TRACE] compile-timeÙ>** option causes sqlite3_expanded_sql() to always return NULL.¢**ÙE** ^The string returned by sqlite3_sql(P) is managed by SQLite and isÙ@** automatically freed when the prepared statement is finalized.ÙF** ^The string returned by sqlite3_expanded_sql(P), on the other hand,ÙJ** is obtained from [sqlite3_malloc()] and must be free by the applicationÙ%** by passing it to [sqlite3_free()].¢*/Ù8SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);Ù;SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt); ¢/*Ù>** CAPI3REF: Determine If An SQL Statement Writes The Database·** METHOD: sqlite3_stmt¢**ÙE** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) ifÙD** and only if the [prepared statement] X makes no direct changes toÙ$** the content of the database file.¢**Ù3** Note that [application-defined SQL functions] orÙL** [virtual tables] might change the database indirectly as a side effect.  ÙE** ^(For example, if an application defines a function "eval()" that ÙA** calls [sqlite3_exec()], then the following SQL statement wouldÙ1** change the database file through side-effects:¢**´** <blockquote><pre>Ù,**    SELECT eval('DELETE FROM t1') FROM t2;¶** </pre></blockquote>¢**ÙG** But because the [SELECT] statement does not change the database fileÙ?** directly, sqlite3_stmt_readonly() would still return true.)^¢**ÙI** ^Transaction control statements such as [BEGIN], [COMMIT], [ROLLBACK],ÙK** [SAVEPOINT], and [RELEASE] cause sqlite3_stmt_readonly() to return true,ÙJ** since the statements themselves do not actually modify the database butÙF** rather they control the timing of when other statements modify the Ù>** database.  ^The [ATTACH] and [DETACH] statements also causeÙG** sqlite3_stmt_readonly() to return true since, while those statementsÙG** change the configuration of a database connection, they do not make Ù8** changes to the content of the database files on disk.ÙH** ^The sqlite3_stmt_readonly() interface returns true for [BEGIN] sinceÙJ** [BEGIN] merely sets internal flags, but the [BEGIN|BEGIN IMMEDIATE] andÙ@** [BEGIN|BEGIN EXCLUSIVE] commands do touch the database and soÙ<** sqlite3_stmt_readonly() returns false for those commands.¢*/Ù:SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt); ¢/*Ù=** CAPI3REF: Determine If A Prepared Statement Has Been Reset·** METHOD: sqlite3_stmt¢**ÙE** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if theÙ?** [prepared statement] S has been stepped at least once using Ù@** [sqlite3_step(S)] but has neither run to completion (returnedÙ,** [SQLITE_DONE] from [sqlite3_step(S)]) norÙB** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)ÙB** interface returns false if S is a NULL pointer.  If S is not a ÙD** NULL pointer and is not a pointer to a valid [prepared statement]ÙC** object, then the behavior is undefined and probably undesirable.¢**ÙB** This interface can be used in combination [sqlite3_next_stmt()]Ù@** to locate all prepared statements associated with a database ÙA** connection that are in need of being reset.  This can be used,Ù>** for example, in diagnostic routines to search for prepared Ù2** statements that are holding a transaction open.¢*/Ù0SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*); ¢/*Ù+** CAPI3REF: Dynamically Typed Value ObjectÙB** KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}¢**Ù?** SQLite uses the sqlite3_value object to represent all valuesÙE** that can be stored in a database table. SQLite uses dynamic typingÙE** for the values it stores.  ^Values stored in sqlite3_value objectsÙC** can be integers, floating point values, strings, BLOBs, or NULL.¢**ÙF** An sqlite3_value object may be either "protected" or "unprotected".ÙG** Some interfaces require a protected sqlite3_value.  Other interfacesÙB** will accept either a protected or an unprotected sqlite3_value.ÙA** Every interface that accepts sqlite3_value arguments specifiesÙ=** whether or not it requires a protected sqlite3_value.  TheÙB** [sqlite3_value_dup()] interface can be used to construct a new Ù=** protected sqlite3_value from an unprotected sqlite3_value.¢**ÙB** The terms "protected" and "unprotected" refer to whether or notÙ>** a mutex is held.  An internal mutex is held for a protectedÙ?** sqlite3_value object but no mutex is held for an unprotectedÙE** sqlite3_value object.  If SQLite is compiled to be single-threadedÙK** (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)Ù5** or if SQLite is run in one of reduced mutex modes Ù>** [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]ÙA** then there is no distinction between protected and unprotectedÙH** sqlite3_value objects and they can be used interchangeably.  However,ÙC** for maximum code portability it is recommended that applicationsÙ?** still make the distinction between protected and unprotectedÙ9** sqlite3_value objects even when not strictly required.¢**ÙD** ^The sqlite3_value objects that are passed as parameters into theÙG** implementation of [application-defined SQL functions] are protected.Ù(** ^The sqlite3_value object returned byÙ+** [sqlite3_column_value()] is unprotected.ÙB** Unprotected sqlite3_value objects may only be used as argumentsÙ;** to [sqlite3_result_value()], [sqlite3_bind_value()], and¹** [sqlite3_value_dup()].Ù<** The [sqlite3_value_blob | sqlite3_value_type()] family ofÙ6** interfaces require protected sqlite3_value objects.¢*/Ù+typedef struct sqlite3_value sqlite3_value; ¢/*Ù(** CAPI3REF: SQL Function Context Object¢**Ù@** The context in which an SQL function executes is stored in anÙC** sqlite3_context object.  ^A pointer to an sqlite3_context objectÙD** is always first parameter to [application-defined SQL functions].ÙE** The application-defined SQL function implementation will pass thisÙI** pointer through into calls to [sqlite3_result_int | sqlite3_result()],Ù8** [sqlite3_aggregate_context()], [sqlite3_user_data()],Ù:** [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],Ù"** and/or [sqlite3_set_auxdata()].¢*/Ù/typedef struct sqlite3_context sqlite3_context; ¢/*Ù2** CAPI3REF: Binding Values To Prepared StatementsÙE** KEYWORDS: {host parameter} {host parameters} {host parameter name}ÙA** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}·** METHOD: sqlite3_stmt¢**ÙP** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,ÙJ** literals may be replaced by a [parameter] that matches one of following­** templates:¢**§** <ul>ª** <li>  ?­** <li>  ?NNN­** <li>  :VVV­** <li>  @VVV­** <li>  $VVV¨** </ul>¢**Ù=** In the templates above, NNN represents an integer literal,ÙI** and VVV represents an alphanumeric identifier.)^  ^The values of theseÙF** parameters (also called "host parameter names" or "SQL parameters")Ù?** can be set using the sqlite3_bind_*() routines defined here.¢**ÙA** ^The first argument to the sqlite3_bind_*() routines is alwaysÙ7** a pointer to the [sqlite3_stmt] object returned fromÙ*** [sqlite3_prepare_v2()] or its variants.¢**ÙD** ^The second argument is the index of the SQL parameter to be set.ÙG** ^The leftmost SQL parameter has an index of 1.  ^When the same namedÙ>** SQL parameter is used more than once, second and subsequentÙ;** occurrences have the same index as the first occurrence.Ù=** ^The index for named parameters can be looked up using theÙ?** [sqlite3_bind_parameter_index()] API if desired.  ^The indexÙ-** for "?NNN" parameters is the value of NNN.Ù=** ^The NNN value must be between 1 and the [sqlite3_limit()]ÙA** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 999).¢**Ù=** ^The third argument is the value to bind to the parameter.ÙJ** ^If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16()ÙE** or sqlite3_bind_blob() is a NULL pointer then the fourth parameterÙD** is ignored and the end result is the same as sqlite3_bind_null().¢**ÙD** ^(In those routines that have a fourth argument, its value is theÙC** number of bytes in the parameter.  To be clear: the value is theÙG** number of <u>bytes</u> in the value, not the number of characters.)^ÙK** ^If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16()Ù0** is negative, then the length of the string isÙ7** the number of bytes up to the first zero terminator.ÙC** If the fourth parameter to sqlite3_bind_blob() is negative, then½** the behavior is undefined.ÙH** If a non-negative fourth parameter is provided to sqlite3_bind_text()Ù9** or sqlite3_bind_text16() or sqlite3_bind_text64() thenÙ)** that parameter must be the byte offsetÙD** where the NUL terminator would occur assuming the string were NULÙF** terminated.  If any NUL characters occur at byte offsets less than ÙI** the value of the fourth parameter then the resulting string value willÙF** contain embedded NULs.  The result of expressions involving stringsÙ#** with embedded NULs is undefined.¢**Ù@** ^The fifth argument to the BLOB and string binding interfacesÙ1** is a destructor used to dispose of the BLOB orÙG** string after SQLite has finished with it.  ^The destructor is calledÙG** to dispose of the BLOB or string even if the call to bind API fails.¼** ^If the fifth argument isÙB** the special value [SQLITE_STATIC], then SQLite assumes that theÙK** information is in static, unmanaged space and does not need to be freed.Ù@** ^If the fifth argument has the value [SQLITE_TRANSIENT], thenÙD** SQLite makes its own private copy of the data immediately, beforeÙ(** the sqlite3_bind_*() routine returns.¢**Ù>** ^The sixth argument to sqlite3_bind_text64() must be one ofÙG** [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE]ÙB** to specify the encoding of the text in the third parameter.  IfÙ@** the sixth argument to sqlite3_bind_text64() is not one of theÙC** allowed values shown above, or if the text encoding is differentÙH** from the encoding specified by the sixth parameter, then the behavior°** is undefined.¢**ÙE** ^The sqlite3_bind_zeroblob() routine binds a BLOB of length N thatÙD** is filled with zeroes.  ^A zeroblob uses a fixed amount of memoryÙB** (just an integer to hold its size) while it is being processed.ÙB** Zeroblobs are intended to serve as placeholders for BLOBs whoseÙ!** content is later written usingÙ7** [sqlite3_blob_open | incremental BLOB I/O] routines.ÙD** ^A negative value for the zeroblob results in a zero-length BLOB.¢**ÙL** ^The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter inÙF** [prepared statement] S to have an SQL value of NULL, but to also beÙK** associated with the pointer P of type T.  ^D is either a NULL pointer orÙD** a pointer to a destructor function for P. ^SQLite will invoke theÙE** destructor D with a single argument of P when it is finished usingÙE** P.  The T parameter should be a static string, preferably a stringÙ=** literal. The sqlite3_bind_pointer() routine is part of theÙ7** [pointer passing interface] added for SQLite 3.20.0.¢**ÙJ** ^If any of the sqlite3_bind_*() routines are called with a NULL pointerÙF** for the [prepared statement] or with a prepared statement for whichÙI** [sqlite3_step()] has been called more recently than [sqlite3_reset()],ÙE** then the call will return [SQLITE_MISUSE].  If any sqlite3_bind_()ÙH** routine is passed a [prepared statement] that has been finalized, theÙ,** result is undefined and probably harmful.¢**Ù>** ^Bindings are not cleared by the [sqlite3_reset()] routine.Ù/** ^Unbound parameters are interpreted as NULL.¢**ÙC** ^The sqlite3_bind_* routines return [SQLITE_OK] on success or anÙ'** [error code] if anything goes wrong.ÙE** ^[SQLITE_TOOBIG] might be returned if the size of a string or BLOBÙF** exceeds limits imposed by [sqlite3_limit]([SQLITE_LIMIT_LENGTH]) or·** [SQLITE_MAX_LENGTH].Ù/** ^[SQLITE_RANGE] is returned if the parameterÙI** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.¢**Ù.** See also: [sqlite3_bind_parameter_count()],ÙI** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].¢*/ÙYSQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));ÙSSQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,Ù(                        void(*)(void*));Ù?SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);Ù9SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);ÙESQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);Ù5SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);ÙSSQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));ÙYSQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));ÙSSQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,ÙA                         void(*)(void*), unsigned char encoding);ÙLSQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);Ù[SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));Ù@SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);ÙKSQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64); ¢/*Ù%** CAPI3REF: Number Of SQL Parameters·** METHOD: sqlite3_stmt¢**ÙC** ^This routine can be used to find the number of [SQL parameters]Ù?** in a [prepared statement].  SQL parameters are tokens of theÙ<** form "?", "?NNN", ":AAA", "$AAA", or "@AAA" that serve asÙ?** placeholders for values that are [sqlite3_bind_blob | bound]Ù%** to the parameters at a later time.¢**ÙG** ^(This routine actually returns the index of the largest (rightmost)ÙD** parameter. For all forms except ?NNN, this will correspond to theÙI** number of unique parameters.  If parameters of the ?NNN form are used,Ù#** there may be gaps in the list.)^¢**Ù0** See also: [sqlite3_bind_blob|sqlite3_bind()],Ù'** [sqlite3_bind_parameter_name()], andÙ$** [sqlite3_bind_parameter_index()].¢*/Ù;SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*); ¢/*Ù%** CAPI3REF: Name Of A Host Parameter·** METHOD: sqlite3_stmt¢**Ù:** ^The sqlite3_bind_parameter_name(P,N) interface returnsÙF** the name of the N-th [SQL parameter] in the [prepared statement] P.ÙD** ^(SQL parameters of the form "?NNN" or ":AAA" or "@AAA" or "$AAA"ÙG** have a name which is the string "?NNN" or ":AAA" or "@AAA" or "$AAA"°** respectively.Ù7** In other words, the initial ":" or "$" or "@" or "?"Ù%** is included as part of the name.)^ÙG** ^Parameters of the form "?" without a following integer have no nameÙ?** and are referred to as "nameless" or "anonymous parameters".¢**Ù6** ^The first host parameter has an index of 1, not 0.¢**Ù>** ^If the value N is out of range or if the N-th parameter isÙ<** nameless, then NULL is returned.  ^The returned string isÙ;** always in UTF-8 encoding even if the named parameter wasÙ;** originally specified as UTF-16 in [sqlite3_prepare16()],Ù9** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].¢**Ù0** See also: [sqlite3_bind_blob|sqlite3_bind()],Ù(** [sqlite3_bind_parameter_count()], andÙ$** [sqlite3_bind_parameter_index()].¢*/ÙGSQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int); ¢/*Ù3** CAPI3REF: Index Of A Parameter With A Given Name·** METHOD: sqlite3_stmt¢**Ù>** ^Return the index of an SQL parameter given its name.  ^TheÙ9** index value returned is suitable for use as the secondÙ<** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zeroÙA** is returned if no matching parameter is found.  ^The parameterÙ=** name must be given in UTF-8 even if the original statementÙB** was prepared from UTF-16 text using [sqlite3_prepare16_v2()] or¼** [sqlite3_prepare16_v3()].¢**Ù0** See also: [sqlite3_bind_blob|sqlite3_bind()],Ù(** [sqlite3_bind_parameter_count()], andÙ#** [sqlite3_bind_parameter_name()].¢*/ÙNSQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName); ¢/*Ù7** CAPI3REF: Reset All Bindings On A Prepared Statement·** METHOD: sqlite3_stmt¢**ÙG** ^Contrary to the intuition of many, [sqlite3_reset()] does not resetÙ@** the [sqlite3_bind_blob | bindings] on a [prepared statement].Ù:** ^Use this routine to reset all host parameters to NULL.¢*/Ù5SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*); ¢/*Ù.** CAPI3REF: Number Of Columns In A Result Set·** METHOD: sqlite3_stmt¢**ÙB** ^Return the number of columns in the result set returned by theÙD** [prepared statement]. ^If this routine returns 0, that means the ÙB** [prepared statement] returns no data (for example an [UPDATE]).ÙI** ^However, just because this routine returns a positive number does notÙL** mean that one or more rows of data will be returned.  ^A SELECT statementÙJ** will always have a positive sqlite3_column_count() but depending on theÙK** WHERE clause constraints and the table content, it might return no rows.¢**Ù#** See also: [sqlite3_data_count()]¢*/Ù9SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt); ¢/*Ù)** CAPI3REF: Column Names In A Result Set·** METHOD: sqlite3_stmt¢**ÙB** ^These routines return the name assigned to a particular columnÙI** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()Ù@** interface returns a pointer to a zero-terminated UTF-8 stringÙE** and sqlite3_column_name16() returns a pointer to a zero-terminatedÙC** UTF-16 string.  ^The first parameter is the [prepared statement]ÙG** that implements the [SELECT] statement. ^The second parameter is theÙ4** column number.  ^The leftmost column is number 0.¢**ÙN** ^The returned string pointer is valid until either the [prepared statement]ÙO** is destroyed by [sqlite3_finalize()] or until the statement is automaticallyÙH** reprepared by the first call to [sqlite3_step()] for a particular run¼** or until the next call toÙG** sqlite3_column_name() or sqlite3_column_name16() on the same column.¢**ÙE** ^If sqlite3_malloc() fails during the processing of either routineÙ@** (for example during a conversion from UTF-8 to UTF-16) then a¼** NULL pointer is returned.¢**ÙC** ^The name of a result column is the value of the "AS" clause forÙC** that column, if there is an AS clause.  If there is no AS clauseÙA** then the name of the column is unspecified and may change fromÙ%** one release of SQLite to the next.¢*/ÙASQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);ÙCSQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N); ¢/*Ù-** CAPI3REF: Source Of Data In A Query Result·** METHOD: sqlite3_stmt¢**ÙH** ^These routines provide a means to determine the database, table, andÙC** table column that is the origin of a particular result column in¶** [SELECT] statement.ÙB** ^The name of the database or table or column can be returned asÙD** either a UTF-8 or UTF-16 string.  ^The _database_ routines returnÙE** the database name, the _table_ routines return the table name, andÙ/** the origin_ routines return the column name.ÙL** ^The returned string is valid until the [prepared statement] is destroyedÙE** using [sqlite3_finalize()] or until the statement is automaticallyÙH** reprepared by the first call to [sqlite3_step()] for a particular runÙ-** or until the same information is requestedÙ!** again in a different encoding.¢**Ù?** ^The names returned are the original un-aliased names of the¿** database, table, and column.¢**ÙE** ^The first argument to these interfaces is a [prepared statement].ÙN** ^These functions return information about the Nth result column returned byÙ:** the statement, where N is the second function argument.Ù8** ^The left-most column is column 0 for these routines.¢**ÙC** ^If the Nth column returned by the statement is an expression orÙI** subquery and is not a column value, then all of these functions returnÙL** NULL.  ^These routine might also return NULL if a memory allocation errorÙM** occurs.  ^Otherwise, they return the name of the attached database, table,Ù9** or column that query result column was extracted from.¢**ÙI** ^As with all other SQLite APIs, those whose names end with "16" returnÙ?** UTF-16 encoded strings and the other functions return UTF-8.¢**ÙF** ^These APIs are only available if the library was compiled with theÙ9** [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol.¢**ÙM** If two or more threads call one or more of these routines against the sameÙF** prepared statement and column at the same time then the results are­** undefined.¢**Ù*** If two or more threads call one or moreÙ>** [sqlite3_column_database_name | column metadata interfaces]Ù6** for the same [prepared statement] and result columnÙ3** at the same time then the results are undefined.¢*/ÙGSQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);ÙISQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);ÙDSQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);ÙFSQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);ÙESQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);ÙGSQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int); ¢/*Ù0** CAPI3REF: Declared Datatype Of A Query Result·** METHOD: sqlite3_stmt¢**Ù3** ^(The first parameter is a [prepared statement].ÙF** If this statement is a [SELECT] statement and the Nth column of theÙA** returned result set of that [SELECT] is a table column (not anÙ>** expression or subquery) then the declared type of the tableÙD** column is returned.)^  ^If the Nth column of the result set is anÙ;** expression or subquery, then a NULL pointer is returned.Ù0** ^The returned string is always UTF-8 encoded.¢**Ù,** ^(For example, given the database schema:¢**¿** CREATE TABLE t1(c1 VARIANT);¢**Ù.** and the following statement to be compiled:¢**½** SELECT c1 + 1, c1 FROM t1;¢**ÙG** this routine would return the string "VARIANT" for the second resultÙJ** column (i==1), and a NULL pointer for the first result column (i==0).)^¢**ÙC** ^SQLite uses dynamic run-time typing.  ^So just because a columnÙB** is declared to contain a particular type does not mean that theÙA** data stored in that column is of the declared type.  SQLite isÙ?** strongly typed, but the typing is dynamic not static.  ^TypeÙ@** is associated with individual values, not with the containers½** used to hold those values.¢*/ÙBSQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);ÙDSQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int); ¢/*Ù&** CAPI3REF: Evaluate An SQL Statement·** METHOD: sqlite3_stmt¢**Ù>** After a [prepared statement] has been prepared using any ofÙL** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],Ù3** or [sqlite3_prepare16_v3()] or one of the legacyÙI** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this functionÙ>** must be called one or more times to evaluate the statement.¢**ÙE** The details of the behavior of the sqlite3_step() interface dependÙH** on whether the statement was prepared using the newer "vX" interfacesÙL** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],Ù/** [sqlite3_prepare16_v2()] or the older legacyÙL** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of theÙH** new "vX" interface is recommended for new applications but the legacyÙ+** interface will continue to be supported.¢**ÙK** ^In the legacy interface, the return value will be either [SQLITE_BUSY],ÙC** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].Ù?** ^With the "v2" interface, any of the other [result codes] orÙ5** [extended result codes] might be returned as well.¢**ÙJ** ^[SQLITE_BUSY] means that the database engine was unable to acquire theÙJ** database locks it needs to do its job.  ^If the statement is a [COMMIT]ÙG** or occurs outside of an explicit transaction, then you can retry theÙF** statement.  If the statement is not a [COMMIT] and occurs within anÙG** explicit transaction then you should rollback the transaction before®** continuing.¢**ÙA** ^[SQLITE_DONE] means that the statement has finished executingÙK** successfully.  sqlite3_step() should not be called again on this virtualÙG** machine without first calling [sqlite3_reset()] to reset the virtualÙ%** machine back to its initial state.¢**ÙK** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]ÙI** is returned each time a new row of data is ready for processing by theÙJ** caller. The values may be accessed using the [column access functions].ÙC** sqlite3_step() is called again to retrieve the next row of data.¢**ÙD** ^[SQLITE_ERROR] means that a run-time error (such as a constraintÙI** violation) has occurred.  sqlite3_step() should not be called again onÙG** the VM. More information may be found by calling [sqlite3_errmsg()].ÙG** ^With the legacy interface, a more specific error code (for example,ÙG** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)Ù6** can be obtained by calling [sqlite3_reset()] on theÙ1** [prepared statement].  ^In the "v2" interface,ÙG** the more specific error code is returned directly by sqlite3_step().¢**ÙJ** [SQLITE_MISUSE] means that the this routine was called inappropriately.Ù;** Perhaps it was called on a [prepared statement] that hasÙA** already been [sqlite3_finalize | finalized] or on one that hadÙD** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it couldÙH** be the case that the same database connection is being used by two orÙ+** more threads at the same moment in time.¢**ÙE** For all versions of SQLite up to and including 3.6.23.1, a call toÙH** [sqlite3_reset()] was required after sqlite3_step() returned anythingÙ>** other than [SQLITE_ROW] before any subsequent invocation ofÙB** sqlite3_step().  Failure to reset the prepared statement using ÙC** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return fromÙD** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],·** sqlite3_step() beganÙF** calling [sqlite3_reset()] automatically in this circumstance ratherÙJ** than returning [SQLITE_MISUSE].  This is not considered a compatibilityÙJ** break because any application that ever receives an SQLITE_MISUSE errorÙL** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time optionÙ.** can be used to restore the legacy behavior.¢**ÙL** <b>Goofy Interface Alert:</b> In the legacy interface, the sqlite3_step()ÙI** API always returns a generic error code, [SQLITE_ERROR], following anyÙE** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must callÙH** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of theÙ:** specific [error codes] that better describes the error.ÙD** We admit that this is a goofy design.  The problem has been fixedÙF** with the "v2" interface.  If you prepare all of your SQL statementsÙ9** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]ÙB** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] insteadÙJ** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,Ù=** then the more specific [error codes] are returned directlyÙE** by sqlite3_step().  The use of the "vX" interfaces is recommended.¢*/Ù+SQLITE_API int sqlite3_step(sqlite3_stmt*); ¢/*Ù.** CAPI3REF: Number of columns in a result set·** METHOD: sqlite3_stmt¢**ÙL** ^The sqlite3_data_count(P) interface returns the number of columns in theÙ;** current row of the result set of [prepared statement] P.ÙA** ^If prepared statement P does not have results ready to returnÙA** (via calls to the [sqlite3_column_int | sqlite3_column_*()] ofÙ4** interfaces) then sqlite3_data_count(P) returns 0.ÙL** ^The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer.ÙG** ^The sqlite3_data_count(P) routine returns 0 if the previous call toÙH** [sqlite3_step](P) returned [SQLITE_DONE].  ^The sqlite3_data_count(P)ÙF** will return non-zero if previous call to [sqlite3_step](P) returnedÙF** [SQLITE_ROW], except in the case of the [PRAGMA incremental_vacuum]ÙB** where it always returns zero since each step of that multi-stepÙ$** pragma returns 0 columns of data.¢**Ù%** See also: [sqlite3_column_count()]¢*/Ù7SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt); ¢/*Ù"** CAPI3REF: Fundamental Datatypes¸** KEYWORDS: SQLITE_TEXT¢**ÙA** ^(Every value in SQLite has one of five fundamental datatypes:¢**§** <ul>½** <li> 64-bit signed integerÙ)** <li> 64-bit IEEE floating point number®** <li> string¬** <li> BLOB¬** <li> NULLª** </ul>)^¢**Ù5** These constants are codes for each of those types.¢**ÙG** Note that the SQLITE_TEXT constant was also used in SQLite version 2ÙH** for a completely different meaning.  Software that links against bothÙE** SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not¯** SQLITE_TEXT.¢*/¹#define SQLITE_INTEGER  1¹#define SQLITE_FLOAT    2¹#define SQLITE_BLOB     4¹#define SQLITE_NULL     5²#ifdef SQLITE_TEXT³# undef SQLITE_TEXT¥#elseº# define SQLITE_TEXT     3¦#endifº#define SQLITE3_TEXT     3 ¢/*Ù'** CAPI3REF: Result Values From A QueryÙ&** KEYWORDS: {column access functions}·** METHOD: sqlite3_stmt¢**²** <b>Summary:</b>Ù;** <blockquote><table border=0 cellpadding=0 cellspacing=0>Ù>** <tr><td><b>sqlite3_column_blob</b><td>&rarr;<td>BLOB resultÙ@** <tr><td><b>sqlite3_column_double</b><td>&rarr;<td>REAL resultÙG** <tr><td><b>sqlite3_column_int</b><td>&rarr;<td>32-bit INTEGER resultÙI** <tr><td><b>sqlite3_column_int64</b><td>&rarr;<td>64-bit INTEGER resultÙD** <tr><td><b>sqlite3_column_text</b><td>&rarr;<td>UTF-8 TEXT resultÙG** <tr><td><b>sqlite3_column_text16</b><td>&rarr;<td>UTF-16 TEXT resultÙE** <tr><td><b>sqlite3_column_value</b><td>&rarr;<td>The result as an Ù4** [sqlite3_value|unprotected sqlite3_value] object.Ù%** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;ÙB** <tr><td><b>sqlite3_column_bytes</b><td>&rarr;<td>Size of a BLOBÙ"** or a UTF-8 TEXT result in bytesÙ4** <tr><td><b>sqlite3_column_bytes16&nbsp;&nbsp;</b>Ù+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16°** TEXT in bytesÙ:** <tr><td><b>sqlite3_column_type</b><td>&rarr;<td>Default¹** datatype of the result¸** </table></blockquote>¢**²** <b>Details:</b>¢**ÙJ** ^These routines return information about a single column of the currentÙI** result row of a query.  ^In every case the first argument is a pointerÙK** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]ÙH** that was returned from [sqlite3_prepare_v2()] or one of its variants)ÙK** and the second argument is the index of the column for which informationÙN** should be returned. ^The leftmost column of the result set has the index 0.Ù?** ^The number of columns in the result can be determined using¼** [sqlite3_column_count()].¢**ÙJ** If the SQL statement does not currently point to a valid row, or if theÙ9** column index is out of range, the result is undefined.ÙA** These routines may only be called when the most recent call toÙ9** [sqlite3_step()] has returned [SQLITE_ROW] and neitherÙL** [sqlite3_reset()] nor [sqlite3_finalize()] have been called subsequently.ÙA** If any of these routines are called after [sqlite3_reset()] orÙ>** [sqlite3_finalize()] or after [sqlite3_step()] has returnedÙ@** something other than [SQLITE_ROW], the results are undefined.ÙC** If [sqlite3_step()] or [sqlite3_reset()] or [sqlite3_finalize()]ÙA** are called from a different thread while any of these routinesÙ/** are pending, then the results are undefined.¢**ÙN** The first six interfaces (_blob, _double, _int, _int64, _text, and _text16)ÙJ** each return the value of a result column in a specific data format.  IfÙK** the result column is not initially in the requested format (for example,ÙJ** if the query returns an integer but the sqlite3_column_text() interfaceÙP** is used to extract the value) then an automatic type conversion is performed.¢**Ù1** ^The sqlite3_column_type() routine returns theÙ=** [SQLITE_INTEGER | datatype code] for the initial data typeÙI** of the result column.  ^The returned value is one of [SQLITE_INTEGER],ÙB** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].ÙH** The return value of sqlite3_column_type() can be used to decide whichÙI** of the first six interface should be used to extract the column value.ÙG** The value returned by sqlite3_column_type() is only meaningful if noÙH** automatic type conversions have occurred for the value in question.  ÙG** After a type conversion, the result of calling sqlite3_column_type()Ù)** is undefined, though harmless.  FutureÙF** versions of SQLite may change the behavior of sqlite3_column_type()¿** following a type conversion.¢**ÙL** If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes()ÙK** or sqlite3_column_bytes16() interfaces can be used to determine the sizeº** of that BLOB or string.¢**ÙK** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()Ù>** routine returns the number of bytes in that BLOB or string.ÙJ** ^If the result is a UTF-16 string, then sqlite3_column_bytes() convertsÙ<** the string to UTF-8 and then returns the number of bytes.ÙE** ^If the result is a numeric value then sqlite3_column_bytes() usesÙK** [sqlite3_snprintf()] to convert that value to a UTF-8 string and returnsÙ&** the number of bytes in that string.ÙD** ^If the result is NULL, then sqlite3_column_bytes() returns zero.¢**ÙN** ^If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16()Ù>** routine returns the number of bytes in that BLOB or string.ÙK** ^If the result is a UTF-8 string, then sqlite3_column_bytes16() convertsÙ=** the string to UTF-16 and then returns the number of bytes.ÙG** ^If the result is a numeric value then sqlite3_column_bytes16() usesÙL** [sqlite3_snprintf()] to convert that value to a UTF-16 string and returnsÙ&** the number of bytes in that string.ÙF** ^If the result is NULL, then sqlite3_column_bytes16() returns zero.¢**Ù8** ^The values returned by [sqlite3_column_bytes()] and ÙL** [sqlite3_column_bytes16()] do not include the zero terminators at the endÙ7** of the string.  ^For clarity: the values returned byÙL** [sqlite3_column_bytes()] and [sqlite3_column_bytes16()] are the number ofÙ5** bytes in the string, not the number of characters.¢**ÙJ** ^Strings returned by sqlite3_column_text() and sqlite3_column_text16(),Ù?** even empty strings, are always zero-terminated.  ^The returnÙM** value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.¢**ÙI** <b>Warning:</b> ^The object returned by [sqlite3_column_value()] is anÙG** [unprotected sqlite3_value] object.  In a multithreaded environment,ÙC** an unprotected sqlite3_value object may only be used safely withÙ7** [sqlite3_bind_value()] and [sqlite3_result_value()].Ù8** If the [unprotected sqlite3_value] object returned byÙE** [sqlite3_column_value()] is used in any other way, including callsÙB** to routines like [sqlite3_value_int()], [sqlite3_value_text()],Ù>** or [sqlite3_value_bytes()], the behavior is not threadsafe.Ù.** Hence, the sqlite3_column_value() interfaceÙ8** is normally only useful within the implementation of ÙF** [application-defined SQL functions] or [virtual tables], not within¾** top-level application code.¢**ÙH** The these routines may attempt to convert the datatype of the result.ÙJ** ^For example, if the internal representation is FLOAT and a text resultÙG** is requested, [sqlite3_snprintf()] is used internally to perform theÙK** conversion automatically.  ^(The following table details the conversions´** that are applied:¢**¯** <blockquote>µ** <table border="1">ÙD** <tr><th> Internal<br>Type <th> Requested<br>Type <th>  Conversion¢**Ù4** <tr><td>  NULL    <td> INTEGER   <td> Result is 0Ù6** <tr><td>  NULL    <td>  FLOAT    <td> Result is 0.0ÙA** <tr><td>  NULL    <td>   TEXT    <td> Result is a NULL pointerÙA** <tr><td>  NULL    <td>   BLOB    <td> Result is a NULL pointerÙF** <tr><td> INTEGER  <td>  FLOAT    <td> Convert from integer to floatÙG** <tr><td> INTEGER  <td>   TEXT    <td> ASCII rendering of the integerÙ>** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXTÙ:** <tr><td>  FLOAT   <td> INTEGER   <td> [CAST] to INTEGERÙE** <tr><td>  FLOAT   <td>   TEXT    <td> ASCII rendering of the floatÙ7** <tr><td>  FLOAT   <td>   BLOB    <td> [CAST] to BLOBÙ:** <tr><td>  TEXT    <td> INTEGER   <td> [CAST] to INTEGERÙ7** <tr><td>  TEXT    <td>  FLOAT    <td> [CAST] to REALÙ2** <tr><td>  TEXT    <td>   BLOB    <td> No changeÙ:** <tr><td>  BLOB    <td> INTEGER   <td> [CAST] to INTEGERÙ7** <tr><td>  BLOB    <td>  FLOAT    <td> [CAST] to REALÙH** <tr><td>  BLOB    <td>   TEXT    <td> Add a zero terminator if needed«** </table>²** </blockquote>)^¢**ÙD** Note that when type conversions occur, pointers returned by priorÙ@** calls to sqlite3_column_blob(), sqlite3_column_text(), and/orÙ.** sqlite3_column_text16() may be invalidated.Ù9** Type conversions and pointer invalidations might occurº** in the following cases:¢**§** <ul>ÙB** <li> The initial content is a BLOB and sqlite3_column_text() orÙC**      sqlite3_column_text16() is called.  A zero-terminator mightÙ,**      need to be added to the string.</li>ÙI** <li> The initial content is UTF-8 text and sqlite3_column_bytes16() orÙI**      sqlite3_column_text16() is called.  The content must be converted·**      to UTF-16.</li>ÙH** <li> The initial content is UTF-16 text and sqlite3_column_bytes() orÙG**      sqlite3_column_text() is called.  The content must be converted¶**      to UTF-8.</li>¨** </ul>¢**ÙM** ^Conversions between UTF-16be and UTF-16le are always done in place and doÙM** not invalidate a prior pointer, though of course the content of the bufferÙJ** that the prior pointer references will have been modified.  Other kindsÙJ** of conversion are done in place when it is possible, but sometimes theyÙF** are not possible and in those cases prior pointers are invalidated.¢**Ù0** The safest policy is to invoke these routinesÙ ** in one of the following ways:¢**§** <ul>ÙE**  <li>sqlite3_column_text() followed by sqlite3_column_bytes()</li>ÙE**  <li>sqlite3_column_blob() followed by sqlite3_column_bytes()</li>ÙI**  <li>sqlite3_column_text16() followed by sqlite3_column_bytes16()</li>¨** </ul>¢**Ù9** In other words, you should call sqlite3_column_text(),ÙN** sqlite3_column_blob(), or sqlite3_column_text16() first to force the resultÙA** into the desired format, then invoke sqlite3_column_bytes() orÙM** sqlite3_column_bytes16() to find the size of the result.  Do not mix callsÙB** to sqlite3_column_text() or sqlite3_column_blob() with calls toÙL** sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16()Ù(** with calls to sqlite3_column_bytes().¢**ÙE** ^The pointers returned are valid until a type conversion occurs asÙE** described above, or until [sqlite3_step()] or [sqlite3_reset()] orÙJ** [sqlite3_finalize()] is called.  ^The memory space used to hold stringsÙG** and BLOBs is freed automatically.  Do not pass the pointers returnedÙC** from [sqlite3_column_blob()], [sqlite3_column_text()], etc. into´** [sqlite3_free()].¢**ÙE** ^(If a memory allocation error occurs during the evaluation of anyÙE** of these routines, a default value is returned.  The default valueÙD** is either the integer 0, the floating point number 0.0, or a NULLÙ@** pointer.  Subsequent calls to [sqlite3_errcode()] will return´** [SQLITE_NOMEM].)^¢*/ÙDSQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);ÙASQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);Ù;SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);ÙGSQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);ÙMSQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);ÙFSQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);ÙHSQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);Ù=SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);Ù?SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);Ù<SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol); ¢/*Ù0** CAPI3REF: Destroy A Prepared Statement Object»** DESTRUCTOR: sqlite3_stmt¢**ÙO** ^The sqlite3_finalize() function is called to delete a [prepared statement].ÙH** ^If the most recent evaluation of the statement encountered no errorsÙO** or if the statement is never been evaluated, then sqlite3_finalize() returnsÙI** SQLITE_OK.  ^If the most recent evaluation of statement S failed, thenÙ>** sqlite3_finalize(S) returns the appropriate [error code] or¹** [extended error code].¢**ÙE** ^The sqlite3_finalize(S) routine can be called at any point duringÙ,** the life cycle of [prepared statement] S:Ù.** before statement S is ever evaluated, afterÙ<** one or more calls to [sqlite3_reset()], or after any callÙE** to [sqlite3_step()] regardless of whether or not the statement has·** completed execution.¢**ÙF** ^Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.¢**ÙM** The application must finalize every [prepared statement] in order to avoidÙL** resource leaks.  It is a grievous error for the application to try to useÙK** a prepared statement after it has been finalized.  Any use of a preparedÙD** statement after it has been finalized can result in undefined andÙ>** undesirable behavior such as segfaults and heap corruption.¢*/Ù5SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt); ¢/*Ù.** CAPI3REF: Reset A Prepared Statement Object·** METHOD: sqlite3_stmt¢**ÙI** The sqlite3_reset() function is called to reset a [prepared statement]Ù=** object back to its initial state, ready to be re-executed.ÙC** ^Any SQL statement variables that had values bound to them usingÙF** the [sqlite3_bind_blob | sqlite3_bind_*() API] retain their values.Ù8** Use [sqlite3_clear_bindings()] to reset the bindings.¢**ÙF** ^The [sqlite3_reset(S)] interface resets the [prepared statement] SÙ(** back to the beginning of its program.¢**Ù8** ^If the most recent call to [sqlite3_step(S)] for theÙA** [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],Ù=** or if [sqlite3_step(S)] has never before been called on S,Ù/** then [sqlite3_reset(S)] returns [SQLITE_OK].¢**Ù8** ^If the most recent call to [sqlite3_step(S)] for theÙ2** [prepared statement] S indicated an error, thenÙ:** [sqlite3_reset(S)] returns an appropriate [error code].¢**Ù?** ^The [sqlite3_reset(S)] interface does not change the valuesÙE** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.¢*/Ù2SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt); ¢/*Ù-** CAPI3REF: Create Or Redefine SQL FunctionsÙ)** KEYWORDS: {function creation routines}Ù/** KEYWORDS: {application-defined SQL function}Ù0** KEYWORDS: {application-defined SQL functions}²** METHOD: sqlite3¢**ÙH** ^These functions (collectively known as "function creation routines")ÙJ** are used to add SQL functions or aggregates or to redefine the behaviorÙI** of existing SQL functions or aggregates.  The only differences betweenÙ4** these routines are the text encoding expected forÙ@** the second parameter (the name of the function being created)Ù;** and the presence or absence of a destructor callback forÙ ** the application data pointer.¢**ÙE** ^The first parameter is the [database connection] to which the SQLÙK** function is to be added.  ^If an application uses more than one databaseÙB** connection then application-defined SQL functions must be addedÙ*** to each database connection separately.¢**ÙI** ^The second parameter is the name of the SQL function to be created orÙI** redefined.  ^The length of the name is limited to 255 bytes in a UTF-8ÙI** representation, exclusive of the zero-terminator.  ^Note that the nameÙE** length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.  Ù7** ^Any attempt to create a function with a longer nameÙ1** will result in [SQLITE_MISUSE] being returned.¢**¾** ^The third parameter (nArg)Ù6** is the number of arguments that the SQL function orÙF** aggregate takes. ^If this parameter is -1, then the SQL function orÙE** aggregate may take any number of arguments between 0 and the limitÙE** set by [sqlite3_limit]([SQLITE_LIMIT_FUNCTION_ARG]).  If the thirdÙE** parameter is less than -1 or greater than 127 then the behavior is­** undefined.¢**Ù2** ^The fourth parameter, eTextRep, specifies whatÙ>** [SQLITE_UTF8 | text encoding] this SQL function prefers forÙ@** its parameters.  The application should set this parameter toÙ;** [SQLITE_UTF16LE] if the function implementation invokes ÙE** [sqlite3_value_text16le()] on an input, or [SQLITE_UTF16BE] if theÙD** implementation invokes [sqlite3_value_text16be()] on an input, orÙG** [SQLITE_UTF16] if [sqlite3_value_text16()] is used, or [SQLITE_UTF8]ÙL** otherwise.  ^The same SQL function may be registered multiple times usingÙI** different preferred text encodings, with different implementations for±** each encoding.ÙL** ^When multiple implementations of the same function are available, SQLiteÙG** will pick the one that involves the least amount of data conversion.¢**ÙK** ^The fourth parameter may optionally be ORed with [SQLITE_DETERMINISTIC]ÙG** to signal that the function will always return the same result givenÙI** the same inputs within a single SQL statement.  Most SQL functions areÙJ** deterministic.  The built-in [random()] SQL function is an example of aÙK** function that is not deterministic.  The SQLite query planner is able toÙF** perform additional optimizations on deterministic functions, so useÙD** of the [SQLITE_DETERMINISTIC] flag is recommended where possible.¢**ÙL** ^(The fifth parameter is an arbitrary pointer.  The implementation of theÙJ** function can gain access to this pointer using [sqlite3_user_data()].)^¢**ÙJ** ^The sixth, seventh and eighth parameters, xFunc, xStep and xFinal, areÙF** pointers to C-language functions that implement the SQL function orÙL** aggregate. ^A scalar SQL function requires an implementation of the xFuncÙF** callback only; NULL pointers must be passed as the xStep and xFinalÙM** parameters. ^An aggregate SQL function requires an implementation of xStepÙO** and xFinal and NULL pointer must be passed for xFunc. ^To delete an existingÙG** SQL function or aggregate, pass NULL pointers for all three function­** callbacks.¢**ÙH** ^(If the ninth parameter to sqlite3_create_function_v2() is not NULL,Ù;** then it is destructor for the application data pointer. ÙJ** The destructor is invoked when the function is deleted, either by beingÙ7** overloaded or when the database connection closes.)^Ù1** ^The destructor is also invoked if the call toÙ&** sqlite3_create_function_v2() fails.ÙF** ^When the destructor callback of the tenth parameter is invoked, itÙG** is passed a single argument which is a copy of the application data ÙI** pointer which was the fifth parameter to sqlite3_create_function_v2().¢**ÙD** ^It is permitted to register multiple implementations of the sameÙD** functions with the same name but with either differing numbers ofÙE** arguments or differing preferred text encodings.  ^SQLite will useÙD** the implementation that most closely matches the way in which theÙH** SQL function is used.  ^A function implementation with a non-negativeÙG** nArg parameter is a better match than a function implementation withÙB** a negative nArg.  ^A function where the preferred text encodingÙ,** matches the database encoding is a betterÙ;** match than a function where the encoding is different.  ÙK** ^A function where the encoding difference is between UTF16le and UTF16beÙE** is a closer match than a function where the encoding difference isº** between UTF8 and UTF16.¢**ÙN** ^Built-in functions may be overloaded by new application-defined functions.¢**Ù>** ^An application-defined function is permitted to call otherÙ3** SQLite interfaces.  However, such calls must notÙC** close the database connection nor finalize or reset the preparedÙ.** statement in which the function is running.¢*/Ù'SQLITE_API int sqlite3_create_function(®  sqlite3 *db,¼  const char *zFunctionName,«  int nArg,¯  int eTextRep,­  void *pApp,Ù6  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),Ù6  void (*xStep)(sqlite3_context*,int,sqlite3_value**),Ù"  void (*xFinal)(sqlite3_context*)¢);Ù)SQLITE_API int sqlite3_create_function16(®  sqlite3 *db,¼  const void *zFunctionName,«  int nArg,¯  int eTextRep,­  void *pApp,Ù6  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),Ù6  void (*xStep)(sqlite3_context*,int,sqlite3_value**),Ù"  void (*xFinal)(sqlite3_context*)¢);Ù*SQLITE_API int sqlite3_create_function_v2(®  sqlite3 *db,¼  const char *zFunctionName,«  int nArg,¯  int eTextRep,­  void *pApp,Ù6  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),Ù6  void (*xStep)(sqlite3_context*,int,sqlite3_value**),Ù#  void (*xFinal)(sqlite3_context*),¸  void(*xDestroy)(void*)¢); ¢/*»** CAPI3REF: Text Encodings¢**ÙA** These constant define integer codes that represent the variousÙ&** text encodings supported by SQLite.¢*/Ù;#define SQLITE_UTF8           1    /* IMP: R-37514-35566 */Ù;#define SQLITE_UTF16LE        2    /* IMP: R-03371-37637 */Ù;#define SQLITE_UTF16BE        3    /* IMP: R-51971-34154 */Ù>#define SQLITE_UTF16          4    /* Use native byte order */Ù3#define SQLITE_ANY            5    /* Deprecated */ÙF#define SQLITE_UTF16_ALIGNED  8    /* sqlite3_create_collation only */ ¢/*»** CAPI3REF: Function Flags¢**Ù1** These constants may be ORed together with the ÙA** [SQLITE_UTF8 | preferred text encoding] as the fourth argumentÙD** to [sqlite3_create_function()], [sqlite3_create_function16()], orÙ"** [sqlite3_create_function_v2()].¢*/Ù%#define SQLITE_DETERMINISTIC    0x800 ¢/*Ù!** CAPI3REF: Deprecated Functions­** DEPRECATED¢**Ù:** These functions are [deprecated].  In order to maintainÙE** backwards compatibility with older code, these functions continue Ù;** to be supported.  However, new applications should avoidÙA** the use of these functions.  To encourage programmers to avoidÙ5** these functions, we will not explain what they do.¢*/¾#ifndef SQLITE_OMIT_DEPRECATEDÙKSQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);Ù@SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);ÙYSQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);Ù>SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);Ù?SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);ÙWSQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),Ù+                      void*,sqlite3_int64);¦#endif ¢/*Ù!** CAPI3REF: Obtaining SQL Values¸** METHOD: sqlite3_value¢**²** <b>Summary:</b>Ù;** <blockquote><table border=0 cellpadding=0 cellspacing=0>Ù<** <tr><td><b>sqlite3_value_blob</b><td>&rarr;<td>BLOB valueÙ>** <tr><td><b>sqlite3_value_double</b><td>&rarr;<td>REAL valueÙE** <tr><td><b>sqlite3_value_int</b><td>&rarr;<td>32-bit INTEGER valueÙG** <tr><td><b>sqlite3_value_int64</b><td>&rarr;<td>64-bit INTEGER valueÙB** <tr><td><b>sqlite3_value_pointer</b><td>&rarr;<td>Pointer valueÙB** <tr><td><b>sqlite3_value_text</b><td>&rarr;<td>UTF-8 TEXT valueÙH** <tr><td><b>sqlite3_value_text16</b><td>&rarr;<td>UTF-16 TEXT value in·** the native byteorderÙI** <tr><td><b>sqlite3_value_text16be</b><td>&rarr;<td>UTF-16be TEXT valueÙI** <tr><td><b>sqlite3_value_text16le</b><td>&rarr;<td>UTF-16le TEXT valueÙ%** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;ÙA** <tr><td><b>sqlite3_value_bytes</b><td>&rarr;<td>Size of a BLOB»** or a UTF-8 TEXT in bytesÙ3** <tr><td><b>sqlite3_value_bytes16&nbsp;&nbsp;</b>Ù+** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16°** TEXT in bytesÙ9** <tr><td><b>sqlite3_value_type</b><td>&rarr;<td>Default¸** datatype of the valueÙ8** <tr><td><b>sqlite3_value_numeric_type&nbsp;&nbsp;</b>Ù?** <td>&rarr;&nbsp;&nbsp;<td>Best numeric datatype of the valueÙ4** <tr><td><b>sqlite3_value_nochange&nbsp;&nbsp;</b>ÙI** <td>&rarr;&nbsp;&nbsp;<td>True if the column is unchanged in an UPDATE»** against a virtual table.¸** </table></blockquote>¢**²** <b>Details:</b>¢**ÙB** These routines extract type, size, and content information fromÙF** [protected sqlite3_value] objects.  Protected sqlite3_value objectsÙ@** are used to pass parameter information into implementation ofÙ<** [application-defined SQL functions] and [virtual tables].¢**ÙC** These routines work only with [protected sqlite3_value] objects.ÙF** Any attempt to use these routines on an [unprotected sqlite3_value]µ** is not threadsafe.¢**ÙM** ^These routines work just like the corresponding [column access functions]ÙL** except that these routines take a single [protected sqlite3_value] objectÙM** pointer instead of a [sqlite3_stmt*] pointer and an integer column number.¢**ÙA** ^The sqlite3_value_text16() interface extracts a UTF-16 stringÙ6** in the native byte-order of the host machine.  ^TheÙC** sqlite3_value_text16be() and sqlite3_value_text16le() interfacesÙG** extract UTF-16 strings as big-endian and little-endian respectively.¢**Ù0** ^If [sqlite3_value] object V was initialized ÙO** using [sqlite3_bind_pointer(S,I,P,X,D)] or [sqlite3_result_pointer(C,P,X,D)]ÙJ** and if X and Y are strings that compare equal according to strcmp(X,Y),ÙJ** then sqlite3_value_pointer(V,Y) will return the pointer P.  ^Otherwise,ÙI** sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() ÙN** routine is part of the [pointer passing interface] added for SQLite 3.20.0.¢**Ù4** ^(The sqlite3_value_type(V) interface returns theÙC** [SQLITE_INTEGER | datatype code] for the initial datatype of theÙK** [sqlite3_value] object V. The returned value is one of [SQLITE_INTEGER],ÙD** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].)^ÙJ** Other interfaces might change the datatype for an sqlite3_value object.Ù?** For example, if the datatype is initially SQLITE_INTEGER andÙC** sqlite3_value_text(V) is called to extract a text value for thatÙG** integer, then subsequent calls to sqlite3_value_type(V) might returnÙI** SQLITE_TEXT.  Whether or not a persistent internal datatype conversionÙM** occurs is undefined and may change from one release of SQLite to the next.¢**ÙA** ^(The sqlite3_value_numeric_type() interface attempts to applyÙ@** numeric affinity to the value.  This means that an attempt isÙA** made to convert the value to an integer or floating point.  IfÙF** such a conversion is possible without loss of information (in otherÙ<** words, if the value is a string that looks like a number)ÙE** then the conversion is performed.  Otherwise no conversion occurs.ÙB** The [SQLITE_INTEGER | datatype] after conversion is returned.)^¢**Ù9** ^Within the [xUpdate] method of a [virtual table], theÙB** sqlite3_value_nochange(X) interface returns true if and only ifÙE** the column corresponding to X is unchanged by the UPDATE operationÙ?** that the xUpdate method call was invoked to implement and ifÙD** and the prior [xColumn] method call that was invoked to extractedÙH** the value for that column returned without setting a result (probablyÙI** because it queried [sqlite3_vtab_nochange()] and found that the columnÙE** was unchanging).  ^Within an [xUpdate] method, any value for whichÙF** sqlite3_value_nochange(X) is true will in all other respects appearÙN** to be a NULL value.  If sqlite3_value_nochange(X) is invoked anywhere otherÙE** than within an [xUpdate] method call for an UPDATE statement, thenÙ1** the return value is arbitrary and meaningless.¢**ÙH** Please pay particular attention to the fact that the pointer returnedÙ:** from [sqlite3_value_blob()], [sqlite3_value_text()], orÙF** [sqlite3_value_text16()] can be invalidated by a subsequent call toÙN** [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite3_value_text()],¿** or [sqlite3_value_text16()].¢**Ù8** These routines must be called from the same thread asÙB** the SQL function that supplied the [sqlite3_value*] parameters.¢*/Ù:SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);Ù7SQLITE_API double sqlite3_value_double(sqlite3_value*);Ù1SQLITE_API int sqlite3_value_int(sqlite3_value*);Ù=SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);ÙDSQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);ÙCSQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);Ù<SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);Ù>SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);Ù>SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);Ù3SQLITE_API int sqlite3_value_bytes(sqlite3_value*);Ù5SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);Ù2SQLITE_API int sqlite3_value_type(sqlite3_value*);Ù:SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);Ù6SQLITE_API int sqlite3_value_nochange(sqlite3_value*); ¢/*Ù.** CAPI3REF: Finding The Subtype Of SQL Values¸** METHOD: sqlite3_value¢**Ù@** The sqlite3_value_subtype(V) function returns the subtype forÙA** an [application-defined SQL function] argument V.  The subtypeÙC** information can be used to pass a limited amount of context fromÙC** one SQL function to another.  Use the [sqlite3_result_subtype()]ÙF** routine to set the subtype for the return value of an SQL function.¢*/Ù>SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*); ¢/*Ù%** CAPI3REF: Copy And Free SQL Values¸** METHOD: sqlite3_value¢**ÙJ** ^The sqlite3_value_dup(V) interface makes a copy of the [sqlite3_value]ÙN** object D and returns a pointer to that copy.  ^The [sqlite3_value] returnedÙB** is a [protected sqlite3_value] object even if the input is not.ÙH** ^The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a»** memory allocation fails.¢**ÙG** ^The sqlite3_value_free(V) interface frees an [sqlite3_value] objectÙK** previously obtained from [sqlite3_value_dup()].  ^If V is a NULL pointerÙ2** then sqlite3_value_free(V) is a harmless no-op.¢*/ÙBSQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*);Ù3SQLITE_API void sqlite3_value_free(sqlite3_value*); ¢/*Ù.** CAPI3REF: Obtain Aggregate Function Contextº** METHOD: sqlite3_context¢**Ù6** Implementations of aggregate SQL functions use thisÙ6** routine to allocate memory for storing their state.¢**ÙH** ^The first time the sqlite3_aggregate_context(C,N) routine is called Ù.** for a particular aggregate function, SQLiteÙG** allocates N of memory, zeroes out that memory, and returns a pointerÙ8** to the new memory. ^On second and subsequent calls toÙH** sqlite3_aggregate_context() for the same aggregate function instance,ÙH** the same buffer is returned.  Sqlite3_aggregate_context() is normallyÙE** called once for each invocation of the xStep callback and then oneÙG** last time when the xFinal callback is invoked.  ^(When no rows matchÙE** an aggregate query, the xStep() callback of the aggregate functionÙF** implementation is never called and xFinal() is called exactly once.ÙF** In those cases, sqlite3_aggregate_context() might be called for theÙ%** first time from within xFinal().)^¢**ÙF** ^The sqlite3_aggregate_context(C,N) routine returns a NULL pointer ÙF** when first called if N is less than or equal to zero or if a memory¹** allocate error occurs.¢**ÙG** ^(The amount of space allocated by sqlite3_aggregate_context(C,N) isÙH** determined by the N parameter on first successful call.  Changing theÙF** value of N in subsequent call to sqlite3_aggregate_context() withinÙB** the same aggregate function instance will not resize the memoryÙD** allocation.)^  Within the xFinal callback, it is customary to setÙ=** N=0 in calls to sqlite3_aggregate_context(C,N) so that no Ù&** pointless memory allocations occur.¢**Ù7** ^SQLite automatically frees the memory allocated by ÙB** sqlite3_aggregate_context() when the aggregate query concludes.¢**Ù,** The first parameter must be a copy of theÙG** [sqlite3_context | SQL function context] that is the first parameterÙH** to the xStep or xFinal callback routine that implements the aggregate¬** function.¢**Ù<** This routine must be called from the same thread in whichÙ)** the aggregate SQL function is running.¢*/ÙISQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes); ¢/*Ù$** CAPI3REF: User Data For Functionsº** METHOD: sqlite3_context¢**Ù7** ^The sqlite3_user_data() interface returns a copy ofÙC** the pointer that was the pUserData parameter (the 5th parameter)Ù%** of the [sqlite3_create_function()]Ù=** and [sqlite3_create_function16()] routines that originallyÙ/** registered the application defined function.¢**Ù<** This routine must be called from the same thread in whichÙ/** the application-defined function is running.¢*/Ù5SQLITE_API void *sqlite3_user_data(sqlite3_context*); ¢/*Ù.** CAPI3REF: Database Connection For Functionsº** METHOD: sqlite3_context¢**Ù?** ^The sqlite3_context_db_handle() interface returns a copy ofÙ?** the pointer to the [database connection] (the 1st parameter)Ù%** of the [sqlite3_create_function()]Ù=** and [sqlite3_create_function16()] routines that originallyÙ/** registered the application defined function.¢*/Ù@SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*); ¢/*Ù$** CAPI3REF: Function Auxiliary Dataº** METHOD: sqlite3_context¢**ÙB** These functions may be used by (non-aggregate) SQL functions toÙJ** associate metadata with argument values. If the same value is passed toÙN** multiple invocations of the same SQL function during query execution, underÙK** some circumstances the associated metadata may be preserved.  An exampleÙD** of where this might be useful is in a regular-expression matchingÙL** function. The compiled version of the regular expression can be stored asÙ1** metadata associated with the pattern string.  Ù7** Then as long as the pattern string remains the same,Ù<** the compiled regular expression can be reused on multipleÙ$** invocations of the same function.¢**ÙL** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadataÙP** associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argumentÙK** value to the application-defined function.  ^N is zero for the left-mostÙ/** function argument.  ^If there is no metadataÙP** associated with the function argument, the sqlite3_get_auxdata(C,N) interfaceº** returns a NULL pointer.¢**ÙO** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-thÙ=** argument of the application-defined function.  ^SubsequentÙB** calls to sqlite3_get_auxdata(C,N) return P from the most recentÙF** sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid orÙ+** NULL if the metadata has been discarded.ÙH** ^After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL,ÙH** SQLite will invoke the destructor function X with parameter P exactlyÙ(** once, when the metadata is discarded.ÙF** SQLite is free to discard the metadata at any time, including: <ul>ÙA** <li> ^(when the corresponding function parameter changes)^, orÙJ** <li> ^(when [sqlite3_reset()] or [sqlite3_finalize()] is called for the»**      SQL statement)^, orÙA** <li> ^(when sqlite3_set_auxdata() is invoked again on the same¸**       parameter)^, orÙG** <li> ^(during the original sqlite3_set_auxdata() call when a memory Ù(**      allocation error occurs.)^ </ul>¢**Ù<** Note the last bullet in particular.  The destructor X in ÙG** sqlite3_set_auxdata(C,N,P,X) might be called immediately, before theÙM** sqlite3_set_auxdata() interface even returns.  Hence sqlite3_set_auxdata()ÙG** should be called near the end of the function implementation and theÙ=** function implementation should not make any use of P afterÙ)** sqlite3_set_auxdata() has been called.¢**ÙB** ^(In practice, metadata is preserved between function calls forÙI** function parameters that are compile-time constants, including literalÙD** values and [parameters] and expressions composed from the same.)^¢**ÙK** The value of the N parameter to these interfaces should be non-negative.ÙF** Future enhancements may make use of negative N values to define newÙ&** kinds of function caching behavior.¢**Ù>** These routines must be called from the same thread in which¿** the SQL function is running.¢*/Ù>SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);ÙUSQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));  ¢/*Ù;** CAPI3REF: Constants Defining Special Destructor Behavior¢**ÙG** These are special values for the destructor that is passed in as theÙO** final argument to routines like [sqlite3_result_blob()].  ^If the destructorÙK** argument is SQLITE_STATIC, it means that the content pointer is constantÙB** and will never change.  It does not need to be destroyed.  ^TheÙF** SQLITE_TRANSIENT value means that the content will likely change inÙF** the near future and that SQLite should make its own private copy ofÙ ** the content before returning.¢**Ù>** The typedef is necessary to work around problems in certain±** C++ compilers.¢*/Ù/typedef void (*sqlite3_destructor_type)(void*);Ù7#define SQLITE_STATIC      ((sqlite3_destructor_type)0)Ù8#define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1) ¢/*Ù2** CAPI3REF: Setting The Result Of An SQL Functionº** METHOD: sqlite3_context¢**Ù@** These routines are used by the xFunc or xFinal callbacks thatÙ/** implement SQL functions and aggregates.  SeeÙ@** [sqlite3_create_function()] and [sqlite3_create_function16()]¾** for additional information.¢**ÙH** These functions work very much like the [parameter binding] family ofÙK** functions used to bind values to host parameters in prepared statements.ÙI** Refer to the [SQL parameter] documentation for additional information.¢**Ù<** ^The sqlite3_result_blob() interface sets the result fromÙJ** an application-defined function to be the BLOB whose content is pointedÙF** to by the second parameter and which is N bytes long where N is the³** third parameter.¢**ÙG** ^The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N)ÙF** interfaces set the result of the application-defined function to beÙ8** a BLOB containing all zero bytes and N bytes in size.¢**Ù>** ^The sqlite3_result_double() interface sets the result fromÙI** an application-defined function to be a floating point value specified·** by its 2nd argument.¢**ÙE** ^The sqlite3_result_error() and sqlite3_result_error16() functionsÙ<** cause the implemented SQL function to throw an exception.Ù,** ^SQLite uses the string pointed to by theÙF** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()ÙA** as the text of an error message.  ^SQLite interprets the errorÙ?** message string from sqlite3_result_error() as UTF-8. ^SQLiteÙJ** interprets the string from sqlite3_result_error16() as UTF-16 in nativeÙA** byte order.  ^If the third parameter to sqlite3_result_error()ÙI** or sqlite3_result_error16() is negative then SQLite takes as the errorÙ8** message all text up through the first zero character.Ù7** ^If the third parameter to sqlite3_result_error() orÙG** sqlite3_result_error16() is non-negative then SQLite takes that manyÙF** bytes (not characters) from the 2nd parameter as the error message.Ù;** ^The sqlite3_result_error() and sqlite3_result_error16()Ù@** routines make a private copy of the error message text beforeÙ>** they return.  Hence, the calling function can deallocate orÙ2** modify the text after they return without harm.ÙC** ^The sqlite3_result_error_code() function changes the error codeÙJ** returned by SQLite as a result of an error in a function.  ^By default,ÙP** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()ÙE** or sqlite3_result_error16() resets the error code to SQLITE_ERROR.¢**ÙI** ^The sqlite3_result_error_toobig() interface causes SQLite to throw anÙC** error indicating that a string or BLOB is too long to represent.¢**ÙH** ^The sqlite3_result_error_nomem() interface causes SQLite to throw anÙ4** error indicating that a memory allocation failed.¢**Ù<** ^The sqlite3_result_int() interface sets the return valueÙF** of the application-defined function to be the 32-bit signed integerÙ#** value given in the 2nd argument.Ù>** ^The sqlite3_result_int64() interface sets the return valueÙF** of the application-defined function to be the 64-bit signed integerÙ#** value given in the 2nd argument.¢**Ù=** ^The sqlite3_result_null() interface sets the return valueÙ2** of the application-defined function to be NULL.¢**Ù7** ^The sqlite3_result_text(), sqlite3_result_text16(),ÙF** sqlite3_result_text16le(), and sqlite3_result_text16be() interfacesÙA** set the return value of the application-defined function to beÙI** a text string which is represented as UTF-8, UTF-16 native byte order,Ù<** UTF-16 little endian, or UTF-16 big endian, respectively.ÙE** ^The sqlite3_result_text64() interface sets the return value of anÙB** application-defined function to be a text string in an encodingÙA** specified by the fifth (and last) parameter, which must be oneÙK** of [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE].Ù:** ^SQLite takes the text result from the application fromÙ<** the 2nd parameter of the sqlite3_result_text* interfaces.Ù?** ^If the 3rd parameter to the sqlite3_result_text* interfacesÙD** is negative, then SQLite takes result text from the 2nd parameterÙ$** through the first zero character.Ù?** ^If the 3rd parameter to the sqlite3_result_text* interfacesÙC** is non-negative, then as many bytes (not characters) of the textÙG** pointed to by the 2nd parameter are taken as the application-definedÙB** function result.  If the 3rd parameter is non-negative, then itÙI** must be the byte offset into the string where the NUL terminator wouldÙJ** appear if the string where NUL terminated.  If any NUL characters occurÙH** in the string at a byte offset that is less than the value of the 3rdÙJ** parameter, then the resulting string will contain embedded NULs and theÙN** result of expressions operating on strings with embedded NULs is undefined.Ù?** ^If the 4th parameter to the sqlite3_result_text* interfacesÙG** or sqlite3_result_blob is a non-NULL pointer, then SQLite calls thatÙD** function as the destructor on the text or BLOB result when it has¾** finished using that result.ÙE** ^If the 4th parameter to the sqlite3_result_text* interfaces or toÙI** sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLiteÙI** assumes that the text or BLOB result is in constant space and does notÙI** copy the content of the parameter nor call a destructor on the contentÙ*** when it has finished using that result.Ù?** ^If the 4th parameter to the sqlite3_result_text* interfacesÙB** or sqlite3_result_blob is the special constant SQLITE_TRANSIENTÙ=** then SQLite makes a copy of the result into space obtainedÙ-** from [sqlite3_malloc()] before it returns.¢**Ù;** ^The sqlite3_result_value() interface sets the result ofÙ7** the application-defined function to be a copy of theÙK** [unprotected sqlite3_value] object specified by the 2nd parameter.  ^TheÙG** sqlite3_result_value() interface makes a copy of the [sqlite3_value]ÙG** so that the [sqlite3_value] specified in the parameter may change orÙD** be deallocated after sqlite3_result_value() returns without harm.ÙB** ^A [protected sqlite3_value] object may always be used where anÙ<** [unprotected sqlite3_value] object is required, so eitherÙB** kind of [sqlite3_value] object can be used with this interface.¢**ÙG** ^The sqlite3_result_pointer(C,P,T,D) interface sets the result to anÙE** SQL NULL value, just like [sqlite3_result_null(C)], except that itÙC** also associates the host-language pointer P or type T with that Ù>** NULL value such that the pointer can be retrieved within anÙF** [application-defined SQL function] using [sqlite3_value_pointer()].ÙH** ^If the D parameter is not NULL, then it is a pointer to a destructorÙF** for the P parameter.  ^SQLite invokes D with P as its only argumentÙF** when SQLite is finished with P.  The T parameter should be a staticÙG** string and preferably a string literal. The sqlite3_result_pointer()ÙN** routine is part of the [pointer passing interface] added for SQLite 3.20.0.¢**Ù@** If these routines are called from within the different threadÙI** than the one containing the application-defined function that receivedÙ<** the [sqlite3_context] pointer, the results are undefined.¢*/ÙXSQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));ÙCSQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,Ù:                           sqlite3_uint64,void(*)(void*));Ù@SQLITE_API void sqlite3_result_double(sqlite3_context*, double);ÙISQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);ÙKSQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);Ù>SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);Ù=SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);ÙASQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);Ù:SQLITE_API void sqlite3_result_int(sqlite3_context*, int);ÙFSQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);Ù6SQLITE_API void sqlite3_result_null(sqlite3_context*);ÙXSQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));ÙSSQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,ÙC                           void(*)(void*), unsigned char encoding);ÙZSQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));Ù[SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));Ù[SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));ÙGSQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);Ù[SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));ÙASQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);ÙMSQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);  ¢/*Ù3** CAPI3REF: Setting The Subtype Of An SQL Functionº** METHOD: sqlite3_context¢**ÙA** The sqlite3_result_subtype(C,T) function causes the subtype ofÙ?** the result from the [application-defined SQL function] with ÙA** [sqlite3_context] C to be the value T.  Only the lower 8 bits Ù@** of the subtype T are preserved in current versions of SQLite;Ù#** higher order bits are discarded.ÙA** The number of subtype bytes preserved by SQLite might increaseÙ ** in future releases of SQLite.¢*/ÙFSQLITE_API void sqlite3_result_subtype(sqlite3_context*,unsigned int); ¢/*Ù+** CAPI3REF: Define New Collating Sequences²** METHOD: sqlite3¢**ÙC** ^These functions add, remove, or modify a [collation] associatedÙB** with the [database connection] specified as the first argument.¢**Ù/** ^The name of the collation is a UTF-8 stringÙC** for sqlite3_create_collation() and sqlite3_create_collation_v2()ÙM** and a UTF-16 string in native byte order for sqlite3_create_collation16().ÙL** ^Collation names that compare equal according to [sqlite3_strnicmp()] areÙ"** considered to be the same name.¢**Ù@** ^(The third argument (eTextRep) must be one of the constants:§** <ul>¶** <li> [SQLITE_UTF8],¹** <li> [SQLITE_UTF16LE],¹** <li> [SQLITE_UTF16BE],º** <li> [SQLITE_UTF16], or¿** <li> [SQLITE_UTF16_ALIGNED].ª** </ul>)^ÙC** ^The eTextRep argument determines the encoding of strings passedÙ1** to the collating function callback, xCallback.ÙE** ^The [SQLITE_UTF16] and [SQLITE_UTF16_ALIGNED] values for eTextRepÙ4** force strings to be UTF16 with native byte order.ÙI** ^The [SQLITE_UTF16_ALIGNED] value for eTextRep forces strings to begin»** on an even byte address.¢**ÙL** ^The fourth argument, pArg, is an application data pointer that is passedÙD** through as the first argument to the collating function callback.¢**ÙJ** ^The fifth argument, xCallback, is a pointer to the collating function.ÙJ** ^Multiple collating functions can be registered using the same name butÙC** with different eTextRep parameters and SQLite will use whicheverÙ=** function requires the least amount of data transformation.ÙD** ^If the xCallback argument is NULL then the collating function isÙL** deleted.  ^When all collating functions having the same name are deleted,Ù&** that collation is no longer usable.¢**ÙG** ^The collating function callback is invoked with a copy of the pArg ÙJ** application data pointer and with two strings in the encoding specifiedÙC** by the eTextRep argument.  The collating function must return anÙ.** integer that is negative, zero, or positiveÙJ** if the first string is less than, equal to, or greater than the second,ÙI** respectively.  A collating function must always return the same answerÙL** given the same inputs.  If two or more collating functions are registeredÙH** to the same collation name (using different eTextRep values) then allÙG** must give an equivalent answer when invoked with equivalent strings.ÙD** The collating function must obey the following properties for all·** strings A, B, and C:¢**§** <ol>º** <li> If A==B then B==A.Ù#** <li> If A==B and B==C then A==C.¾** <li> If A&lt;B THEN B&gt;A.Ù)** <li> If A&lt;B and B&lt;C then A&lt;C.¨** </ol>¢**ÙF** If a collating function fails any of the above constraints and thatÙJ** collating function is  registered and used, then the behavior of SQLite°** is undefined.¢**ÙK** ^The sqlite3_create_collation_v2() works like sqlite3_create_collation()ÙG** with the addition that the xDestroy callback is invoked on pArg whenÙ%** the collating function is deleted.ÙE** ^Collating functions are deleted when they are overridden by laterÙ8** calls to the collation creation functions or when theÙ;** [database connection] is closed using [sqlite3_close()].¢**Ù6** ^The xDestroy callback is <u>not</u> called if the ÙJ** sqlite3_create_collation_v2() function fails.  Applications that invokeÙJ** sqlite3_create_collation_v2() with a non-NULL xDestroy argument should ÙD** check the return code and dispose of the application data pointerÙD** themselves rather than expecting SQLite to deal with it for them.ÙK** This is different from every other SQLite interface.  The inconsistency ÙC** is unfortunate but cannot be changed without breaking backwards ±** compatibility.¢**ÙN** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].¢*/Ù(SQLITE_API int sqlite3_create_collation(¬  sqlite3*, µ  const char *zName, °  int eTextRep, ­  void *pArg,Ù7  int(*xCompare)(void*,int,const void*,int,const void*)¢);Ù+SQLITE_API int sqlite3_create_collation_v2(¬  sqlite3*, µ  const char *zName, °  int eTextRep, ­  void *pArg,Ù8  int(*xCompare)(void*,int,const void*,int,const void*),¸  void(*xDestroy)(void*)¢);Ù*SQLITE_API int sqlite3_create_collation16(¬  sqlite3*, ´  const void *zName,°  int eTextRep, ­  void *pArg,Ù7  int(*xCompare)(void*,int,const void*,int,const void*)¢); ¢/*Ù'** CAPI3REF: Collation Needed Callbacks²** METHOD: sqlite3¢**ÙI** ^To avoid having to register all collation sequences before a databaseÙE** can be used, a single callback function may be registered with theÙF** [database connection] to be invoked whenever an undefined collation¸** sequence is required.¢**ÙK** ^If the function is registered using the sqlite3_collation_needed() API,ÙJ** then it is passed the names of undefined collation sequences as stringsÙ>** encoded in UTF-8. ^If sqlite3_collation_needed16() is used,Ù?** the names are passed as UTF-16 in machine native byte order.ÙN** ^A call to either function replaces the existing collation-needed callback.¢**ÙF** ^(When the callback is invoked, the first argument passed is a copyÙ:** of the second argument to sqlite3_collation_needed() orÙE** sqlite3_collation_needed16().  The second argument is the databaseÙM** connection.  The third argument is one of [SQLITE_UTF8], [SQLITE_UTF16BE],ÙK** or [SQLITE_UTF16LE], indicating the most desirable form of the collationÙG** sequence function required.  The fourth parameter is the name of theÙ!** required collation sequence.)^¢**ÙD** The callback function should register the desired collation usingÙC** [sqlite3_create_collation()], [sqlite3_create_collation16()], orÙ#** [sqlite3_create_collation_v2()].¢*/Ù(SQLITE_API int sqlite3_collation_needed(¬  sqlite3*, ©  void*, Ù2  void(*)(void*,sqlite3*,int eTextRep,const char*)¢);Ù*SQLITE_API int sqlite3_collation_needed16(¬  sqlite3*, ¨  void*,Ù2  void(*)(void*,sqlite3*,int eTextRep,const void*)¢); ·#ifdef SQLITE_HAS_CODEC¢/*ÙE** Specify the key for an encrypted database.  This routine should beÙ%** called right after sqlite3_open().¢**ÙH** The code to implement this API is not available in the public release­** of SQLite.¢*/»SQLITE_API int sqlite3_key(Ù=  sqlite3 *db,                   /* Database to be rekeyed */Ù.  const void *pKey, int nKey     /* The key */¢);¾SQLITE_API int sqlite3_key_v2(Ù=  sqlite3 *db,                   /* Database to be rekeyed */Ù;  const char *zDbName,           /* Name of the database */Ù.  const void *pKey, int nKey     /* The key */¢); ¢/*ÙF** Change the key on an open database.  If the current database is notÙG** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the¹** database is decrypted.¢**ÙH** The code to implement this API is not available in the public release­** of SQLite.¢*/½SQLITE_API int sqlite3_rekey(Ù=  sqlite3 *db,                   /* Database to be rekeyed */Ù2  const void *pKey, int nKey     /* The new key */¢);Ù SQLITE_API int sqlite3_rekey_v2(Ù=  sqlite3 *db,                   /* Database to be rekeyed */Ù;  const char *zDbName,           /* Name of the database */Ù2  const void *pKey, int nKey     /* The new key */¢); ¢/*Ù:** Specify the activation key for a SEE database.  Unless Ù1** activated, none of the SEE routines will work.¢*/Ù%SQLITE_API void sqlite3_activate_see(Ù8  const char *zPassPhrase        /* Activation phrase */¢);¦#endif º#ifdef SQLITE_ENABLE_CEROD¢/*Ù<** Specify the activation key for a CEROD database.  Unless Ù3** activated, none of the CEROD routines will work.¢*/Ù'SQLITE_API void sqlite3_activate_cerod(Ù8  const char *zPassPhrase        /* Activation phrase */¢);¦#endif ¢/*Ù/** CAPI3REF: Suspend Execution For A Short Time¢**ÙN** The sqlite3_sleep() function causes the current thread to suspend executionÙD** for at least a number of milliseconds specified in its parameter.¢**Ù?** If the operating system does not support sleep requests withÙC** millisecond time resolution, then the time will be rounded up toÙC** the nearest second. The number of milliseconds of sleep actuallyÙ3** requested from the operating system is returned.¢**Ù<** ^SQLite implements this interface by calling the xSleep()ÙF** method of the default [sqlite3_vfs] object.  If the xSleep() methodÙI** of the default VFS is not implemented correctly, or not implemented atÙM** all, then the behavior of sqlite3_sleep() may deviate from the description¾** in the previous paragraphs.¢*/Ù"SQLITE_API int sqlite3_sleep(int); ¢/*Ù7** CAPI3REF: Name Of The Folder Holding Temporary Files¢**ÙB** ^(If this global variable is made to point to a string which isÙD** the name of a folder (a.k.a. directory), then all temporary filesÙ>** created by SQLite when using a built-in [sqlite3_vfs | VFS]Ù9** will be placed in that directory.)^  ^If this variableÙF** is a NULL pointer, then SQLite performs a search for an appropriate¼** temporary file directory.¢**ÙI** Applications are strongly discouraged from using this global variable.ÙG** It is required to set a temporary folder on Windows Runtime (WinRT).ÙJ** But for all other platforms, it is highly recommended that applicationsÙI** neither read nor write this variable.  This global variable is a relicÙL** that exists for backwards compatibility of legacy applications and should¾** be avoided in new projects.¢**ÙB** It is not safe to read or modify this variable in more than oneÙD** thread at a time.  It is not safe to read or modify this variableÙJ** if a [database connection] is being used at the same time in a separateª** thread.Ù0** It is intended that this variable be set onceÙD** as part of process initialization and before any SQLite interfaceÙD** routines have been called and that this variable remain unchanged®** thereafter.¢**ÙH** ^The [temp_store_directory pragma] may modify this variable and causeÙG** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,ÙC** the [temp_store_directory pragma] always assumes that any stringÙ@** that this variable points to is held in memory obtained from ÙB** [sqlite3_malloc] and the pragma may attempt to free that memory¸** using [sqlite3_free].ÙD** Hence, if this variable is modified directly, either it should beÙF** made NULL or made to point to memory obtained from [sqlite3_malloc]ÙJ** or else the use of the [temp_store_directory pragma] should be avoided.ÙE** Except when requested by the [temp_store_directory pragma], SQLiteÙF** does not free the memory that sqlite3_temp_directory points to.  IfÙ<** the application wants that memory to be freed, it must doÙG** so itself, taking care to only do so after all [database connection]¿** objects have been destroyed.¢**ÙM** <b>Note to Windows Runtime users:</b>  The temporary directory must be setÙL** prior to calling [sqlite3_open] or [sqlite3_open_v2].  Otherwise, variousÙI** features that require the use of temporary files may fail.  Here is anÙ@** example of how to do this using C++ with the Windows Runtime:¢**´** <blockquote><pre>Ù?** LPCWSTR zPath = Windows::Storage::ApplicationData::Current->Ù,** &nbsp;     TemporaryFolder->Path->Data();Ù'** char zPathBuf&#91;MAX_PATH + 1&#93;;Ù)** memset(zPathBuf, 0, sizeof(zPathBuf));ÙI** WideCharToMultiByte(CP_UTF8, 0, zPath, -1, zPathBuf, sizeof(zPathBuf),º** &nbsp;     NULL, NULL);Ù<** sqlite3_temp_directory = sqlite3_mprintf("%s", zPathBuf);¶** </pre></blockquote>¢*/Ù(SQLITE_API char *sqlite3_temp_directory; ¢/*Ù6** CAPI3REF: Name Of The Folder Holding Database Files¢**ÙB** ^(If this global variable is made to point to a string which isÙC** the name of a folder (a.k.a. directory), then all database filesÙ@** specified with a relative pathname and created or accessed byÙK** SQLite when using a built-in windows [sqlite3_vfs | VFS] will be assumedÙB** to be relative to that directory.)^ ^If this variable is a NULLÙA** pointer, then SQLite assumes that all database files specifiedÙA** with a relative pathname are relative to the current directoryÙB** for the process.  Only the windows VFS makes use of this globalÙ+** variable; it is ignored by the unix VFS.¢**ÙE** Changing the value of this variable while a database connection isÙ)** open can result in a corrupt database.¢**ÙB** It is not safe to read or modify this variable in more than oneÙD** thread at a time.  It is not safe to read or modify this variableÙJ** if a [database connection] is being used at the same time in a separateª** thread.Ù0** It is intended that this variable be set onceÙD** as part of process initialization and before any SQLite interfaceÙD** routines have been called and that this variable remain unchanged®** thereafter.¢**ÙH** ^The [data_store_directory pragma] may modify this variable and causeÙG** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,ÙC** the [data_store_directory pragma] always assumes that any stringÙ@** that this variable points to is held in memory obtained from ÙB** [sqlite3_malloc] and the pragma may attempt to free that memory¸** using [sqlite3_free].ÙD** Hence, if this variable is modified directly, either it should beÙF** made NULL or made to point to memory obtained from [sqlite3_malloc]ÙJ** or else the use of the [data_store_directory pragma] should be avoided.¢*/Ù(SQLITE_API char *sqlite3_data_directory; ¢/*Ù&** CAPI3REF: Test For Auto-Commit Mode¾** KEYWORDS: {autocommit mode}²** METHOD: sqlite3¢**Ù>** ^The sqlite3_get_autocommit() interface returns non-zero orÙI** zero if the given database connection is or is not in autocommit mode,Ù4** respectively.  ^Autocommit mode is on by default.Ù7** ^Autocommit mode is disabled by a [BEGIN] statement.Ù>** ^Autocommit mode is re-enabled by a [COMMIT] or [ROLLBACK].¢**ÙK** If certain kinds of errors occur on a statement within a multi-statementÙ?** transaction (errors including [SQLITE_FULL], [SQLITE_IOERR],ÙB** [SQLITE_NOMEM], [SQLITE_BUSY], and [SQLITE_INTERRUPT]) then theÙC** transaction might be rolled back automatically.  The only way toÙJ** find out whether SQLite automatically rolled back the transaction afterÙ$** an error is to use this function.¢**ÙB** If another thread changes the autocommit status of the databaseÙB** connection while this routine is running, then the return value°** is undefined.¢*/Ù0SQLITE_API int sqlite3_get_autocommit(sqlite3*); ¢/*Ù=** CAPI3REF: Find The Database Handle Of A Prepared Statement·** METHOD: sqlite3_stmt¢**ÙL** ^The sqlite3_db_handle interface returns the [database connection] handleÙG** to which a [prepared statement] belongs.  ^The [database connection]ÙB** returned by sqlite3_db_handle is the same [database connection]¾** that was the first argumentÙH** to the [sqlite3_prepare_v2()] call (or its variants) that was used toÙ+** create the statement in the first place.¢*/Ù5SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*); ¢/*Ù:** CAPI3REF: Return The Filename For A Database Connection²** METHOD: sqlite3¢**ÙJ** ^The sqlite3_db_filename(D,N) interface returns a pointer to a filenameÙG** associated with database N of connection D.  ^The main database fileÙK** has the name "main".  If there is no attached database N on the databaseÙL** connection D, or if database N is a temporary or in-memory database, then¾** a NULL pointer is returned.¢**Ù?** ^The filename returned by this function is the output of theÙD** xFullPathname method of the [VFS].  ^In other words, the filenameÙ:** will be an absolute pathname, even if the filename usedÙB** to open the database originally was a URI or relative pathname.¢*/ÙMSQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName); ¢/*Ù1** CAPI3REF: Determine if a database is read-only²** METHOD: sqlite3¢**ÙF** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database NÙI** of connection D is read-only, 0 if it is read/write, or -1 if N is notÙ*** the name of a database on connection D.¢*/ÙESQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName); ¢/*Ù-** CAPI3REF: Find the next prepared statement²** METHOD: sqlite3¢**ÙK** ^This interface returns a pointer to the next [prepared statement] afterÙJ** pStmt associated with the [database connection] pDb.  ^If pStmt is NULLÙH** then this interface returns a pointer to the first prepared statementÙJ** associated with the database connection pDb.  ^If no prepared statementÙ=** satisfies the conditions of this routine, it returns NULL.¢**Ù3** The [database connection] pointer D in a call toÙ:** [sqlite3_next_stmt(D,S)] must refer to an open databaseÙ;** connection and in particular must not be a NULL pointer.¢*/ÙNSQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt); ¢/*Ù7** CAPI3REF: Commit And Rollback Notification Callbacks²** METHOD: sqlite3¢**Ù<** ^The sqlite3_commit_hook() interface registers a callbackÙI** function to be invoked whenever a transaction is [COMMIT | committed].Ù@** ^Any callback set by a previous call to sqlite3_commit_hook()Ù2** for the same database connection is overridden.Ù>** ^The sqlite3_rollback_hook() interface registers a callbackÙM** function to be invoked whenever a transaction is [ROLLBACK | rolled back].ÙB** ^Any callback set by a previous call to sqlite3_rollback_hook()Ù2** for the same database connection is overridden.Ù8** ^The pArg argument is passed through to the callback.Ù?** ^If the callback on a commit hook function returns non-zero,Ù0** then the commit is converted into a rollback.¢**ÙM** ^The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functionsÙD** return the P argument from the previous call of the same functionÙ3** on the same [database connection] D, or NULL forÙ)** the first call for each function on D.¢**Ù<** The commit and rollback hook callbacks are not reentrant.ÙD** The callback implementation must not do anything that will modifyÙB** the database connection that invoked the callback.  Any actionsÙE** to modify the database connection must be deferred until after theÙD** completion of the [sqlite3_step()] call that triggered the commitÙ'** or rollback hook in the first place.ÙK** Note that running any other SQL statements, including SELECT statements,ÙL** or merely calling [sqlite3_prepare_v2()] and [sqlite3_step()] will modifyÙJ** the database connections for the meaning of "modify" in this paragraph.¢**Ù6** ^Registering a NULL function disables the callback.¢**ÙD** ^When the commit hook callback routine returns zero, the [COMMIT]ÙB** operation is allowed to continue normally.  ^If the commit hookÙF** returns non-zero, then the [COMMIT] is converted into a [ROLLBACK].ÙI** ^The rollback hook is invoked on a rollback that results from a commitÙH** hook returning non-zero, just as it would be with any other rollback.¢**ÙD** ^For the purposes of this API, a transaction is said to have beenÙB** rolled back if an explicit "ROLLBACK" statement is executed, orÙ?** an error or constraint causes an implicit rollback to occur.Ù<** ^The rollback callback is not invoked if a transaction isÙG** automatically rolled back because the database connection is closed.¢**Ù2** See also the [sqlite3_update_hook()] interface.¢*/ÙESQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);ÙISQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*); ¢/*Ù/** CAPI3REF: Data Change Notification Callbacks²** METHOD: sqlite3¢**ÙE** ^The sqlite3_update_hook() interface registers a callback functionÙB** with the [database connection] identified by the first argumentÙB** to be invoked whenever a row is updated, inserted or deleted in³** a [rowid table].Ù8** ^Any callback set by a previous call to this functionÙ2** for the same database connection is overridden.¢**ÙE** ^The second argument is a pointer to the function to invoke when aÙ8** row is updated, inserted or deleted in a rowid table.ÙF** ^The first argument to the callback is a copy of the third argument¼** to sqlite3_update_hook().ÙL** ^The second callback argument is one of [SQLITE_INSERT], [SQLITE_DELETE],ÙJ** or [SQLITE_UPDATE], depending on the operation that caused the callback±** to be invoked.ÙJ** ^The third and fourth arguments to the callback contain pointers to theÙ7** database and table name containing the affected row.Ù;** ^The final callback parameter is the [rowid] of the row.ÙO** ^In the case of an update, this is the [rowid] after the update takes place.¢**ÙC** ^(The update hook is not invoked when internal system tables areÙ7** modified (i.e. sqlite_master and sqlite_sequence).)^ÙL** ^The update hook is not invoked when [WITHOUT ROWID] tables are modified.¢**Ù2** ^In the current implementation, the update hookÙA** is not invoked when conflicting rows are deleted because of anÙG** [ON CONFLICT | ON CONFLICT REPLACE] clause.  ^Nor is the update hookÙC** invoked when rows are deleted using the [truncate optimization].ÙD** The exceptions defined in this paragraph might change in a futureµ** release of SQLite.¢**ÙG** The update hook implementation must not do anything that will modifyÙE** the database connection that invoked the update hook.  Any actionsÙE** to modify the database connection must be deferred until after theÙJ** completion of the [sqlite3_step()] call that triggered the update hook.ÙJ** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify theirÙF** database connections for the meaning of "modify" in this paragraph.¢**Ù+** ^The sqlite3_update_hook(D,C,P) functionÙ0** returns the P argument from the previous callÙ3** on the same [database connection] D, or NULL for·** the first call on D.¢**ÙC** See also the [sqlite3_commit_hook()], [sqlite3_rollback_hook()],Ù-** and [sqlite3_preupdate_hook()] interfaces.¢*/Ù%SQLITE_API void *sqlite3_update_hook(¬  sqlite3*, Ù?  void(*)(void *,int ,char const *,char const *,sqlite3_int64),§  void*¢); ¢/*Ù1** CAPI3REF: Enable Or Disable Shared Pager Cache¢**ÙG** ^(This routine enables or disables the sharing of the database cacheÙI** and schema data structures between [database connection | connections]ÙC** to the same database. Sharing is enabled if the argument is trueÙ+** and disabled if the argument is false.)^¢**Ù@** ^Cache sharing is enabled and disabled for an entire process.ÙC** This is a change as of SQLite [version 3.5.0] ([dateof:3.5.0]). ¿** In prior versions of SQLite,Ù>** sharing was enabled or disabled for each thread separately.¢**ÙH** ^(The cache sharing mode set by this interface effects all subsequentÙJ** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].Ù>** Existing database connections continue use the sharing modeÙ5** that was in effect at the time they were opened.)^¢**ÙM** ^(This routine returns [SQLITE_OK] if shared cache was enabled or disabledÙ:** successfully.  An [error code] is returned otherwise.)^¢**ÙA** ^Shared cache is disabled by default. But this might change inÙB** future releases of SQLite.  Applications that care about sharedÙ*** cache setting should set it explicitly.¢**ÙD** Note: This method is disabled on MacOS X 10.7 and iOS version 5.0Ù;** and will always return SQLITE_MISUSE. On those systems, ÙC** shared cache mode should be enabled per-database connection via Ù6** [sqlite3_open_v2()] with [SQLITE_OPEN_SHAREDCACHE].¢**Ù=** This interface is threadsafe on processors where writing a¼** 32-bit integer is atomic.¢**Ù(** See Also:  [SQLite Shared-Cache Mode]¢*/Ù0SQLITE_API int sqlite3_enable_shared_cache(int); ¢/*Ù(** CAPI3REF: Attempt To Free Heap Memory¢**ÙC** ^The sqlite3_release_memory() interface attempts to free N bytesÙB** of heap memory by deallocating non-essential memory allocationsÙ@** held by the database library.   Memory used to cache databaseÙF** pages to improve performance is an example of non-essential memory.ÙH** ^sqlite3_release_memory() returns the number of bytes actually freed,Ù9** which might be more or less than the amount requested.ÙB** ^The sqlite3_release_memory() routine is a no-op returning zeroÙD** if SQLite is not compiled with [SQLITE_ENABLE_MEMORY_MANAGEMENT].¢**Ù*** See also: [sqlite3_db_release_memory()]¢*/Ù+SQLITE_API int sqlite3_release_memory(int); ¢/*Ù6** CAPI3REF: Free Memory Used By A Database Connection²** METHOD: sqlite3¢**ÙL** ^The sqlite3_db_release_memory(D) interface attempts to free as much heapÙ<** memory as possible from database connection D. Unlike theÙI** [sqlite3_release_memory()] interface, this interface is in effect evenÙD** when the [SQLITE_ENABLE_MEMORY_MANAGEMENT] compile-time option is«** omitted.¢**Ù'** See also: [sqlite3_release_memory()]¢*/Ù3SQLITE_API int sqlite3_db_release_memory(sqlite3*); ¢/*Ù(** CAPI3REF: Impose A Limit On Heap Size¢**ÙE** ^The sqlite3_soft_heap_limit64() interface sets and/or queries theÙK** soft limit on the amount of heap memory that may be allocated by SQLite.ÙF** ^SQLite strives to keep heap memory utilization below the soft heapÙ?** limit by reducing the number of pages held in the page cacheÙ.** as heap memory usages approaches the limit.ÙL** ^The soft heap limit is "soft" because even though SQLite strives to stayÙA** below the limit, it will exceed the limit rather than generateÙA** an [SQLITE_NOMEM] error.  In other words, the soft heap limit ´** is advisory only.¢**ÙD** ^The return value from sqlite3_soft_heap_limit64() is the size ofÙG** the soft heap limit prior to the call, or negative in the case of anÙ)** error.  ^If the argument N is negativeÙE** then no change is made to the soft heap limit.  Hence, the currentÙ<** size of the soft heap limit can be determined by invokingÙ8** sqlite3_soft_heap_limit64() with a negative argument.¢**ÙC** ^If the argument N is zero then the soft heap limit is disabled.¢**ÙF** ^(The soft heap limit is not enforced in the current implementationÙ3** if one or more of following conditions are true:¢**§** <ul>Ù+** <li> The soft heap limit is set to zero.Ù@** <li> Memory accounting is disabled using a combination of theÙM**      [sqlite3_config]([SQLITE_CONFIG_MEMSTATUS],...) start-time option andÙ;**      the [SQLITE_DEFAULT_MEMSTATUS] compile-time option.ÙC** <li> An alternative page cache implementation is specified usingÙ6**      [sqlite3_config]([SQLITE_CONFIG_PCACHE2],...).ÙB** <li> The page cache allocates from its own memory pool suppliedÙF**      by [sqlite3_config]([SQLITE_CONFIG_PAGECACHE],...) rather than¶**      from the heap.ª** </ul>)^¢**Ù;** Beginning with SQLite [version 3.7.3] ([dateof:3.7.3]), Ù"** the soft heap limit is enforcedÙE** regardless of whether or not the [SQLITE_ENABLE_MEMORY_MANAGEMENT]ÙK** compile-time option is invoked.  With [SQLITE_ENABLE_MEMORY_MANAGEMENT],ÙG** the soft heap limit is enforced on every memory allocation.  WithoutÙJ** [SQLITE_ENABLE_MEMORY_MANAGEMENT], the soft heap limit is only enforcedÙM** when memory is allocated by the page cache.  Testing suggests that becauseÙ@** the page cache is the predominate memory user in SQLite, mostÙI** applications will achieve adequate soft heap limit enforcement withoutÙ0** the use of [SQLITE_ENABLE_MEMORY_MANAGEMENT].¢**ÙL** The circumstances under which SQLite will enforce the soft heap limit mayÙ(** changes in future releases of SQLite.¢*/ÙDSQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N); ¢/*Ù1** CAPI3REF: Deprecated Soft Heap Limit Interface­** DEPRECATED¢**ÙD** This is a deprecated version of the [sqlite3_soft_heap_limit64()]ÙD** interface.  This routine is provided for historical compatibilityÙ-** only.  All new applications should use theÙ@** [sqlite3_soft_heap_limit64()] interface rather than this one.¢*/ÙASQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);  ¢/*Ù7** CAPI3REF: Extract Metadata About A Column Of A Table²** METHOD: sqlite3¢**ÙD** ^(The sqlite3_table_column_metadata(X,D,T,C,....) routine returnsÙ6** information about column C of table T in database DÙF** on [database connection] X.)^  ^The sqlite3_table_column_metadata()ÙD** interface returns SQLITE_OK and fills in the non-NULL pointers inÙD** the final five arguments with appropriate values if the specifiedÙI** column exists.  ^The sqlite3_table_column_metadata() interface returnsÙ;** SQLITE_ERROR and if the specified column does not exist.ÙH** ^If the column-name parameter to sqlite3_table_column_metadata() is aÙI** NULL pointer, then this routine simply checks for the existence of theÙI** table and returns SQLITE_OK if the table exists and SQLITE_ERROR if itÙ8** does not.  If the table name parameter T in a call toÙH** sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is¶** undefined behavior.¢**ÙJ** ^The column is identified by the second, third and fourth parameters toÙK** this function. ^(The second parameter is either the name of the databaseÙJ** (i.e. "main", "temp", or an attached database) containing the specifiedÙL** table or NULL.)^ ^If it is NULL, then all attached databases are searchedÙH** for the table using the same algorithm used by the database engine toÙ(** resolve unqualified table references.¢**ÙM** ^The third and fourth parameters to this function are the table and columnÙ,** name of the desired column, respectively.¢**ÙM** ^Metadata is returned by writing to the memory locations passed as the 5thÙM** and subsequent parameters to this function. ^Any of these arguments may beÙH** NULL, in which case the corresponding element of metadata is omitted.¢**±** ^(<blockquote>µ** <table border="1">Ù;** <tr><th> Parameter <th> Output<br>Type <th>  Description¢**Ù/** <tr><td> 5th <td> const char* <td> Data typeÙH** <tr><td> 6th <td> const char* <td> Name of default collation sequenceÙN** <tr><td> 7th <td> int         <td> True if column has a NOT NULL constraintÙO** <tr><td> 8th <td> int         <td> True if column is part of the PRIMARY KEYÙG** <tr><td> 9th <td> int         <td> True if column is [AUTOINCREMENT]«** </table>²** </blockquote>)^¢**ÙD** ^The memory pointed to by the character pointers returned for theÙB** declaration type and collation sequence is valid until the nextÙ#** call to any SQLite API function.¢**ÙK** ^If the specified table is actually a view, an [error code] is returned.¢**ÙI** ^If the specified column is "rowid", "oid" or "_rowid_" and the table Ù(** is not a [WITHOUT ROWID] table and anÙM** [INTEGER PRIMARY KEY] column has been explicitly declared, then the outputÙJ** parameters are set for the explicitly declared column. ^(If there is noÙ1** [INTEGER PRIMARY KEY] column, then the outputsÙ&** for the [rowid] are set as follows:¢**¨** <pre>»**     data type: "INTEGER"Ù#**     collation sequence: "BINARY"²**     not null: 0µ**     primary key: 1¸**     auto increment: 0«** </pre>)^¢**ÙF** ^This function causes all database schemas to be read from disk andÙE** parsed, if that has not already been done, and returns an error ifÙ7** any errors are encountered while loading the schema.¢*/Ù-SQLITE_API int sqlite3_table_column_metadata(Ù5  sqlite3 *db,                /* Connection handle */Ù9  const char *zDbName,        /* Database name or NULL */Ù.  const char *zTableName,     /* Table name */Ù/  const char *zColumnName,    /* Column name */Ù>  char const **pzDataType,    /* OUTPUT: Declared data type */ÙC  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */ÙN  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */ÙE  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */ÙL  int *pAutoinc               /* OUTPUT: True if column is auto-increment */¢); ¢/*¾** CAPI3REF: Load An Extension²** METHOD: sqlite3¢**ÙI** ^This interface loads an SQLite extension library from the named file.¢**Ù>** ^The sqlite3_load_extension() interface attempts to load anÙ>** [SQLite extension] library contained in the file zFile.  IfÙ@** the file cannot be loaded directly, attempts are made to loadÙ;** with various operating-system specific extensions added.ÙC** So for example, if "samplelib" cannot be loaded, then names likeÙ?** "samplelib.so" or "samplelib.dylib" or "samplelib.dll" might±** be tried also.¢**½** ^The entry point is zProc.ÙE** ^(zProc may be 0, in which case SQLite will try to come up with anÙI** entry point name on its own.  It first tries "sqlite3_extension_init".ÙI** If that does not work, it constructs a name "sqlite3_X_init" where theÙE** X is consists of the lower-case equivalent of all ASCII alphabeticÙF** characters in the filename from the last "/" to the first followingÙ(** "." and omitting any initial "lib".)^Ù2** ^The sqlite3_load_extension() interface returnsÙE** [SQLITE_OK] on success and [SQLITE_ERROR] if something goes wrong.Ù6** ^If an error occurs and pzErrMsg is not 0, then theÙ8** [sqlite3_load_extension()] interface shall attempt toÙ:** fill *pzErrMsg with error message text stored in memoryÙ9** obtained from [sqlite3_malloc()]. The calling functionÙ7** should free this memory by calling [sqlite3_free()].¢**Ù+** ^Extension loading must be enabled usingÙ'** [sqlite3_enable_load_extension()] orÙI** [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],1,NULL)½** prior to calling this API,Ù'** otherwise an error will be returned.¢**Ù7** <b>Security warning:</b> It is recommended that the ÙM** [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method be used to enable only thisÙI** interface.  The use of the [sqlite3_enable_load_extension()] interfaceÙI** should be avoided.  This will keep the SQL function [load_extension()]Ù<** disabled and prevent SQL injections from giving attackersÙ,** access to extension loading capabilities.¢**Ù0** See also the [load_extension() SQL function].¢*/Ù&SQLITE_API int sqlite3_load_extension(ÙN  sqlite3 *db,          /* Load the extension into this database connection */ÙM  const char *zFile,    /* Name of the shared library containing extension */ÙC  const char *zProc,    /* Entry point.  Derived from zFile if 0 */Ù=  char **pzErrMsg       /* Put error message here if not 0 */¢); ¢/*Ù0** CAPI3REF: Enable Or Disable Extension Loading²** METHOD: sqlite3¢**ÙC** ^So as not to open security holes in older applications that areÙK** unprepared to deal with [extension loading], and as a means of disablingÙK** [extension loading] while evaluating user-entered SQL, the following APIÙK** is provided to turn the [sqlite3_load_extension()] mechanism on and off.¢**Ù(** ^Extension loading is off by default.ÙB** ^Call the sqlite3_enable_load_extension() routine with onoff==1ÙA** to turn extension loading on and call it with onoff==0 to turnµ** it back off again.¢**Ù5** ^This interface enables or disables both the C-APIÙF** [sqlite3_load_extension()] and the SQL function [load_extension()].ÙK** ^(Use [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],..)Ù)** to enable or disable only the C-API.)^¢**ÙD** <b>Security warning:</b> It is recommended that extension loadingÙG** be disabled using the [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] methodÙE** rather than this interface, so the [load_extension()] SQL functionÙK** remains disabled. This will prevent SQL injections from giving attackersÙ,** access to extension loading capabilities.¢*/ÙESQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff); ¢/*Ù<** CAPI3REF: Automatically Load Statically Linked Extensions¢**ÙF** ^This interface causes the xEntryPoint() function to be invoked forÙI** each new [database connection] that is created.  The idea here is thatÙN** xEntryPoint() is the entry point for a statically linked [SQLite extension]ÙH** that is to be automatically loaded into all new database connections.¢**ÙF** ^(Even though the function prototype shows that xEntryPoint() takesÙI** no arguments and returns void, SQLite invokes xEntryPoint() with threeÙE** arguments and expects an integer result as if the signature of theÙ ** entry point where as follows:¢**´** <blockquote><pre>»** &nbsp;  int xEntryPoint(¹** &nbsp;    sqlite3 *db,Ù#** &nbsp;    const char **pzErrMsg,Ù6** &nbsp;    const struct sqlite3_api_routines *pThunk­** &nbsp;  );¸** </pre></blockquote>)^¢**ÙK** If the xEntryPoint routine encounters an error, it should make *pzErrMsgÙL** point to an appropriate error message (obtained from [sqlite3_mprintf()])ÙJ** and return an appropriate [error code].  ^SQLite ensures that *pzErrMsgÙA** is NULL before calling the xEntryPoint().  ^SQLite will invokeÙF** [sqlite3_free()] on *pzErrMsg after xEntryPoint() returns.  ^If anyÙL** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],ÙI** or [sqlite3_open_v2()] call that provoked the xEntryPoint() will fail.¢**ÙK** ^Calling sqlite3_auto_extension(X) with an entry point X that is alreadyÙK** on the list of automatic extensions is a harmless no-op. ^No entry pointÙM** will be called more than once for each database connection that is opened.¢**Ù-** See also: [sqlite3_reset_auto_extension()]Ù(** and [sqlite3_cancel_auto_extension()]¢*/Ù@SQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void)); ¢/*Ù/** CAPI3REF: Cancel Automatic Extension Loading¢**ÙD** ^The [sqlite3_cancel_auto_extension(X)] interface unregisters theÙE** initialization routine X that was registered using a prior call toÙH** [sqlite3_auto_extension(X)].  ^The [sqlite3_cancel_auto_extension(X)]ÙB** routine returns 1 if initialization routine X was successfully ÙK** unregistered and it returns 0 if X was not on the list of initialization¬** routines.¢*/ÙGSQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void)); ¢/*Ù.** CAPI3REF: Reset Automatic Extension Loading¢**Ù?** ^This interface disables all automatic extensions previouslyÙ/** registered using [sqlite3_auto_extension()].¢*/Ù3SQLITE_API void sqlite3_reset_auto_extension(void); ¢/*ÙG** The interface to the virtual-table mechanism is currently consideredÙH** to be experimental.  The interface might change in incompatible ways.ÙG** If this is a problem for you, do not use the interface at this time.¢**ÙC** When the virtual-table mechanism stabilizes, we will declare theÙE** interface fixed, support it indefinitely, and remove this comment.¢*/ ¢/*Ù1** Structures used by the virtual table interface¢*/Ù)typedef struct sqlite3_vtab sqlite3_vtab;Ù5typedef struct sqlite3_index_info sqlite3_index_info;Ù7typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;Ù-typedef struct sqlite3_module sqlite3_module; ¢/*Ù!** CAPI3REF: Virtual Table ObjectÙ2** KEYWORDS: sqlite3_module {virtual table module}¢**Ù>** This structure, sometimes called a "virtual table module", Ù6** defines the implementation of a [virtual tables].  Ù<** This structure consists mostly of methods for the module.¢**Ù@** ^A virtual table module is created by filling in a persistentÙD** instance of this structure and passing a pointer to that instanceÙ@** to [sqlite3_create_module()] or [sqlite3_create_module_v2()].ÙF** ^The registration remains valid until it is replaced by a differentÙA** module or until the [database connection] closes.  The contentÙ@** of this structure must not change while it is registered with»** any database connection.¢*/·struct sqlite3_module {¯  int iVersion;Ù&  int (*xCreate)(sqlite3*, void *pAux,Ù0               int argc, const char *const*argv,Ù.               sqlite3_vtab **ppVTab, char**);Ù'  int (*xConnect)(sqlite3*, void *pAux,Ù0               int argc, const char *const*argv,Ù.               sqlite3_vtab **ppVTab, char**);Ù>  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);Ù*  int (*xDisconnect)(sqlite3_vtab *pVTab);Ù'  int (*xDestroy)(sqlite3_vtab *pVTab);ÙD  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);Ù&  int (*xClose)(sqlite3_vtab_cursor*);ÙF  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,Ù0                int argc, sqlite3_value **argv);Ù%  int (*xNext)(sqlite3_vtab_cursor*);Ù$  int (*xEof)(sqlite3_vtab_cursor*);Ù>  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);Ù=  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);ÙI  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);Ù%  int (*xBegin)(sqlite3_vtab *pVTab);Ù$  int (*xSync)(sqlite3_vtab *pVTab);Ù&  int (*xCommit)(sqlite3_vtab *pVTab);Ù(  int (*xRollback)(sqlite3_vtab *pVTab);ÙH  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,ÙM                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),Ù%                       void **ppArg);Ù8  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);ÙK  /* The methods above are in version 1 of the sqlite_module object. Those Ù,  ** below are for version 2 and greater. */Ù.  int (*xSavepoint)(sqlite3_vtab *pVTab, int);Ù,  int (*xRelease)(sqlite3_vtab *pVTab, int);Ù/  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);¢}; ¢/*Ù/** CAPI3REF: Virtual Table Indexing Information¿** KEYWORDS: sqlite3_index_info¢**ÙI** The sqlite3_index_info structure and its substructures is used as partÙ&** of the [virtual table] interface toÙD** pass information into and receive the reply from the [xBestIndex]ÙK** method of a [virtual table module].  The fields under **Inputs** are theÙB** inputs to xBestIndex and are read-only.  xBestIndex inserts itsÙ'** results into the **Outputs** fields.¢**ÙJ** ^(The aConstraint[] array records WHERE clause constraints of the form:¢**Ù*** <blockquote>column OP expr</blockquote>¢**ÙN** where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator isÙ.** stored in aConstraint[].op using one of theÙD** [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^Ù)** ^(The index of the column is stored inÙB** aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if theÙH** expr on the right-hand side can be evaluated (and thus the constraintÙ'** is usable) and false if it cannot.)^¢**ÙJ** ^The optimizer automatically inverts terms of the form "expr OP column"ÙG** and makes other simplifications to the WHERE clause in an attempt toÙH** get as many WHERE clause terms into the form shown above as possible.ÙD** ^The aConstraint[] array only reports WHERE clause terms that areÙ:** relevant to the particular virtual table being queried.¢**ÙB** ^Information about the ORDER BY clause is stored in aOrderBy[].ÙB** ^Each term of aOrderBy records a column of the ORDER BY clause.¢**ÙH** The colUsed field indicates which columns of the virtual table may beÙH** required by the current scan. Virtual table columns are numbered fromÙK** zero in the order in which they appear within the CREATE TABLE statementÙM** passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),ÙL** the corresponding bit is set within the colUsed mask if the column may beÙJ** required by SQLite. If the table has at least 64 columns and any columnÙK** to the right of the first 63 is required, then bit 63 of colUsed is alsoÙE** set. In other words, column iCol may be required if the expressionÙJ** (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to ¬** non-zero.¢**ÙH** The [xBestIndex] method must fill aConstraintUsage[] with informationÙB** about what parameters to pass to xFilter.  ^If argvIndex>0 thenÙF** the right-hand side of the corresponding aConstraint[] is evaluatedÙL** and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omitÙE** is true, then the constraint is assumed to be fully handled by theÙ6** virtual table and is not checked again by SQLite.)^¢**ÙA** ^The idxNum and idxPtr values are recorded and passed into the´** [xFilter] method.Ù:** ^[sqlite3_free()] is used to free idxPtr if and only if¼** needToFreeIdxPtr is true.¢**ÙN** ^The orderByConsumed means that output from [xFilter]/[xNext] will occur inÙG** the correct order to satisfy the ORDER BY clause so that no separate¼** sorting step is required.¢**ÙF** ^The estimatedCost value is an estimate of the cost of a particularÙK** strategy. A cost of N indicates that the cost of the strategy is similarÙE** to a linear scan of an SQLite table with N rows. A cost of log(N) ÙF** indicates that the expense of the operation is similar to that of aÙJ** binary search on a unique indexed field of an SQLite table with N rows.¢**ÙE** ^The estimatedRows value is an estimate of the number of rows thatÙ$** will be returned by the strategy.¢**ÙK** The xBestIndex method may optionally populate the idxFlags field with a ÙM** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -ÙL** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLiteÙ8** assumes that the strategy may visit at most one row. ¢**ÙK** Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, thenÙH** SQLite also assumes that if a call to the xUpdate() method is made asÙM** part of the same statement to delete or update a virtual table row and theÙN** implementation returns SQLITE_CONSTRAINT, then there is no need to rollbackÙA** any database changes. In other words, if the xUpdate() returnsÙH** SQLITE_CONSTRAINT, the database contents must be exactly as they wereÙM** before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is notÙJ** set and xUpdate returns SQLITE_CONSTRAINT, any database changes made byÙ>** the xUpdate method are automatically rolled back by SQLite.¢**ÙI** IMPORTANT: The estimatedRows field was added to the sqlite3_index_infoÙ:** structure for SQLite [version 3.8.2] ([dateof:3.8.2]). Ù"** If a virtual table extension isÙM** used with an SQLite version earlier than 3.8.2, the results of attempting ÙJ** to read or write the estimatedRows field are undefined (but are likely ÙH** to included crashing the application). The estimatedRows field shouldÙD** therefore only be used if [sqlite3_libversion_number()] returns aÙH** value greater than or equal to 3008002. Similarly, the idxFlags fieldÙ3** was added for [version 3.9.0] ([dateof:3.9.0]). Ù#** It may therefore only be used ifÙG** sqlite3_libversion_number() returns a value greater than or equal to«** 3009000.¢*/»struct sqlite3_index_info {®  /* Inputs */ÙC  int nConstraint;           /* Number of entries in aConstraint */Ù#  struct sqlite3_index_constraint {ÙF     int iColumn;              /* Column constrained.  -1 for ROWID */Ù8     unsigned char op;         /* Constraint operator */ÙF     unsigned char usable;     /* True if this constraint is usable */ÙO     int iTermOffset;          /* Used internally - xBestIndex should ignore */ÙD  } *aConstraint;            /* Table of WHERE clause constraints */ÙI  int nOrderBy;              /* Number of terms in the ORDER BY clause */Ù   struct sqlite3_index_orderby {Ù2     int iColumn;              /* Column number */ÙC     unsigned char desc;       /* True for DESC.  False for ASC. */Ù6  } *aOrderBy;               /* The ORDER BY clause */¯  /* Outputs */Ù)  struct sqlite3_index_constraint_usage {ÙO    int argvIndex;           /* if >0, constraint is part of argv to xFilter */ÙI    unsigned char omit;      /* Do not code a test for this constraint */¶  } *aConstraintUsage;ÙD  int idxNum;                /* Number used to identify the index */ÙP  char *idxStr;              /* String, possibly obtained from sqlite3_malloc */ÙK  int needToFreeIdxStr;      /* Free idxStr using sqlite3_free() if true */ÙD  int orderByConsumed;       /* True if output is already ordered */ÙJ  double estimatedCost;           /* Estimated cost of using this index */ÙA  /* Fields below are only available in SQLite 3.8.2 and later */ÙI  sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */ÙA  /* Fields below are only available in SQLite 3.9.0 and later */ÙD  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */ÙB  /* Fields below are only available in SQLite 3.10.0 and later */ÙK  sqlite3_uint64 colUsed;    /* Input: Mask of columns used by statement */¢}; ¢/*Ù%** CAPI3REF: Virtual Table Scan Flags¢*/ÙK#define SQLITE_INDEX_SCAN_UNIQUE      1     /* Scan visits at most 1 row */ ¢/*Ù4** CAPI3REF: Virtual Table Constraint Operator Codes¢**Ù2** These macros defined the allowed values for theÙF** [sqlite3_index_info].aConstraint[].op field.  Each value representsÙG** an operator that is part of a constraint term in the wHERE clause ofÙ'** a query that uses a [virtual table].¢*/Ù,#define SQLITE_INDEX_CONSTRAINT_EQ         2Ù,#define SQLITE_INDEX_CONSTRAINT_GT         4Ù,#define SQLITE_INDEX_CONSTRAINT_LE         8Ù,#define SQLITE_INDEX_CONSTRAINT_LT        16Ù,#define SQLITE_INDEX_CONSTRAINT_GE        32Ù,#define SQLITE_INDEX_CONSTRAINT_MATCH     64Ù,#define SQLITE_INDEX_CONSTRAINT_LIKE      65Ù,#define SQLITE_INDEX_CONSTRAINT_GLOB      66Ù,#define SQLITE_INDEX_CONSTRAINT_REGEXP    67Ù,#define SQLITE_INDEX_CONSTRAINT_NE        68Ù,#define SQLITE_INDEX_CONSTRAINT_ISNOT     69Ù,#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70Ù,#define SQLITE_INDEX_CONSTRAINT_ISNULL    71Ù,#define SQLITE_INDEX_CONSTRAINT_IS        72 ¢/*Ù4** CAPI3REF: Register A Virtual Table Implementation²** METHOD: sqlite3¢**ÙJ** ^These routines are used to register a new [virtual table module] name.Ù*** ^Module names must be registered beforeÙE** creating a new [virtual table] using the module and before using aÙ.** preexisting [virtual table] for the module.¢**ÙH** ^The module name is registered on the [database connection] specifiedÙD** by the first parameter.  ^The name of the module is given by the Ù:** second parameter.  ^The third parameter is a pointer toÙB** the implementation of the [virtual table module].   ^The fourthÙG** parameter is an arbitrary client data pointer that is passed throughÙH** into the [xCreate] and [xConnect] methods of the virtual table moduleÙA** when a new virtual table is be being created or reinitialized.¢**ÙH** ^The sqlite3_create_module_v2() interface has a fifth parameter whichÙB** is a pointer to a destructor for the pClientData.  ^SQLite willÙA** invoke the destructor function (if it is not NULL) when SQLiteÙF** no longer needs the pClientData pointer.  ^The destructor will alsoÙ>** be invoked if the call to sqlite3_create_module_v2() fails.¿** ^The sqlite3_create_module()ÙD** interface is equivalent to sqlite3_create_module_v2() with a NULL®** destructor.¢*/Ù%SQLITE_API int sqlite3_create_module(ÙL  sqlite3 *db,               /* SQLite connection to register module with */Ù5  const char *zName,         /* Name of the module */Ù9  const sqlite3_module *p,   /* Methods for the module */ÙC  void *pClientData          /* Client data for xCreate/xConnect */¢);Ù(SQLITE_API int sqlite3_create_module_v2(ÙL  sqlite3 *db,               /* SQLite connection to register module with */Ù5  const char *zName,         /* Name of the module */Ù9  const sqlite3_module *p,   /* Methods for the module */ÙC  void *pClientData,         /* Client data for xCreate/xConnect */Ù=  void(*xDestroy)(void*)     /* Module destructor function */¢); ¢/*Ù*** CAPI3REF: Virtual Table Instance Object¹** KEYWORDS: sqlite3_vtab¢**Ù>** Every [virtual table module] implementation uses a subclassÙ3** of this object to describe a particular instanceÙ.** of the [virtual table].  Each subclass willÙB** be tailored to the specific needs of the module implementation.ÙF** The purpose of this superclass is to define certain fields that areÙ(** common to all module implementations.¢**ÙB** ^Virtual tables methods can set an error message by assigning aÙJ** string obtained from [sqlite3_mprintf()] to zErrMsg.  The method shouldÙI** take care that any prior string is freed by a call to [sqlite3_free()]ÙH** prior to assigning a new string to zErrMsg.  ^After the error messageÙN** is delivered up to the client application, the string will be automaticallyÙ@** freed by sqlite3_free() and the zErrMsg field will be zeroed.¢*/µstruct sqlite3_vtab {ÙI  const sqlite3_module *pModule;  /* The module for this virtual table */Ù>  int nRef;                       /* Number of open cursors */ÙL  char *zErrMsg;                  /* Error message from sqlite3_mprintf() */ÙJ  /* Virtual table implementations will typically add additional fields */¢}; ¢/*Ù(** CAPI3REF: Virtual Table Cursor ObjectÙ7** KEYWORDS: sqlite3_vtab_cursor {virtual table cursor}¢**ÙE** Every [virtual table module] implementation uses a subclass of theÙ>** following structure to describe cursors that point into the¿** [virtual table] and are usedÙD** to loop through the virtual table.  Cursors are created using theÙH** [sqlite3_module.xOpen | xOpen] method of the module and are destroyedÙD** by the [sqlite3_module.xClose | xClose] method.  Cursors are usedÙE** by the [xFilter], [xNext], [xEof], [xColumn], and [xRowid] methodsÙ9** of the module.  Each module implementation will defineÙ;** the content of a cursor structure to suit its own needs.¢**ÙF** This superclass exists in order to define fields of the cursor thatÙ%** are common to all implementations.¢*/¼struct sqlite3_vtab_cursor {Ù>  sqlite3_vtab *pVtab;      /* Virtual table of this cursor */ÙJ  /* Virtual table implementations will typically add additional fields */¢}; ¢/*Ù2** CAPI3REF: Declare The Schema Of A Virtual Table¢**Ù-** ^The [xCreate] and [xConnect] methods of aÙ-** [virtual table module] call this interfaceÙD** to declare the format (the names and datatypes of the columns) ofÙ%** the virtual tables they implement.¢*/Ù@SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL); ¢/*Ù4** CAPI3REF: Overload A Function For A Virtual Table²** METHOD: sqlite3¢**ÙH** ^(Virtual tables can provide alternative implementations of functionsÙD** using the [xFindFunction] method of the [virtual table module].  Ù)** But global versions of those functionsÙ*** must exist in order to be overloaded.)^¢**ÙI** ^(This API makes sure a global version of a function with a particularÙD** name and number of parameters exists.  If no such function existsÙO** before this API is called, a new function is created.)^  ^The implementationÙC** of the new function always causes an exception to be thrown.  SoÙA** the new function is not good for anything by itself.  Its onlyÙA** purpose is to be a placeholder function that can be overloaded¸** by a [virtual table].¢*/ÙTSQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg); ¢/*ÙF** The interface to the virtual-table mechanism defined above (back upÙG** to a comment remarkably similar to this one) is currently consideredÙH** to be experimental.  The interface might change in incompatible ways.ÙG** If this is a problem for you, do not use the interface at this time.¢**ÙC** When the virtual-table mechanism stabilizes, we will declare theÙE** interface fixed, support it indefinitely, and remove this comment.¢*/ ¢/*Ù%** CAPI3REF: A Handle To An Open BLOBÙ)** KEYWORDS: {BLOB handle} {BLOB handles}¢**Ù>** An instance of this object represents an open BLOB on whichÙ?** [sqlite3_blob_open | incremental BLOB I/O] can be performed.Ù=** ^Objects of this type are created by [sqlite3_blob_open()]Ù+** and destroyed by [sqlite3_blob_close()].ÙC** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfacesÙ>** can be used to read or write small subsections of the BLOB.ÙO** ^The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.¢*/Ù)typedef struct sqlite3_blob sqlite3_blob; ¢/*Ù,** CAPI3REF: Open A BLOB For Incremental I/O²** METHOD: sqlite3¼** CONSTRUCTOR: sqlite3_blob¢**ÙG** ^(This interfaces opens a [BLOB handle | handle] to the BLOB locatedÙ=** in row iRow, column zColumn, table zTable in database zDb;Ù;** in other words, the same BLOB that would be selected by:¢**¨** <pre>Ù;**     SELECT zColumn FROM zDb.zTable WHERE [rowid] = iRow;«** </pre>)^¢**ÙG** ^(Parameter zDb is not the filename that contains the database, but ÙL** rather the symbolic name of the database. For attached databases, this isÙH** the name that appears after the AS keyword in the [ATTACH] statement.ÙD** For the main database file, the database name is "main". For TEMPÙ)** tables, the database name is "temp".)^¢**ÙH** ^If the flags parameter is non-zero, then the BLOB is opened for readÙL** and write access. ^If the flags parameter is zero, the BLOB is opened for´** read-only access.¢**ÙL** ^(On success, [SQLITE_OK] is returned and the new [BLOB handle] is storedÙJ** in *ppBlob. Otherwise an [error code] is returned and, unless the errorÙN** code is SQLITE_MISUSE, *ppBlob is set to NULL.)^ ^This means that, providedÙL** the API is not misused, it is always safe to call [sqlite3_blob_close()] Ù-** on *ppBlob after this function it returns.¢**ÙJ** This function fails with SQLITE_ERROR if any of the following are true:§** <ul>Ù+**   <li> ^(Database zDb does not exist)^, Ù?**   <li> ^(Table zTable does not exist within database zDb)^, Ù5**   <li> ^(Table zTable is a WITHOUT ROWID table)^, Ù,**   <li> ^(Column zColumn does not exist)^,Ù3**   <li> ^(Row iRow is not present in the table)^,ÙI**   <li> ^(The specified column of row iRow contains a value that is notÙ"**         a TEXT or BLOB value)^,ÙF**   <li> ^(Column zColumn is part of an index, PRIMARY KEY or UNIQUE ÙK**         constraint and the blob is being opened for read/write access)^,ÙM**   <li> ^([foreign key constraints | Foreign key constraints] are enabled, ÙM**         column zColumn is part of a [child key] definition and the blob isÙ0**         being opened for read/write access)^.¨** </ul>¢**Ù<** ^Unless it returns SQLITE_MISUSE, this function sets the Ù?** [database connection] error code and message accessible via ÙE** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions. ¢**ÙA** A BLOB referenced by sqlite3_blob_open() may be read using theÙ8** [sqlite3_blob_read()] interface and modified by usingÙ?** [sqlite3_blob_write()].  The [BLOB handle] can be moved to aÙD** different row of the same table using the [sqlite3_blob_reopen()]ÙI** interface.  However, the column, table, or database of a [BLOB handle]Ù7** cannot be changed after the [BLOB handle] is opened.¢**Ù>** ^(If the row that a BLOB handle points to is modified by anÙ7** [UPDATE], [DELETE], or by [ON CONFLICT] side-effectsÙ/** then the BLOB handle is marked as "expired".ÙB** This is true if any column of the row is changed, even a columnÙ3** other than the one the BLOB handle is open on.)^ÙA** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] forÙD** an expired BLOB handle fail with a return code of [SQLITE_ABORT].ÙC** ^(Changes written into a BLOB prior to the BLOB expiring are notÙK** rolled back by the expiration of the BLOB.  Such changes will eventuallyÙ7** commit if the transaction continues to completion.)^¢**ÙE** ^Use the [sqlite3_blob_bytes()] interface to determine the size ofÙC** the opened blob.  ^The size of a blob may not be changed by thisÙC** interface.  Use the [UPDATE] SQL command to change the size of a¨** blob.¢**ÙL** ^The [sqlite3_bind_zeroblob()] and [sqlite3_result_zeroblob()] interfacesÙD** and the built-in [zeroblob] SQL function may be used to create a ÙJ** zero-filled blob to read or write using the incremental-blob interface.¢**ÙG** To avoid a resource leak, every open [BLOB handle] should eventuallyÙ3** be released by a call to [sqlite3_blob_close()].¢**Ù$** See also: [sqlite3_blob_close()],Ù2** [sqlite3_blob_reopen()], [sqlite3_blob_read()],Ù2** [sqlite3_blob_bytes()], [sqlite3_blob_write()].¢*/Ù!SQLITE_API int sqlite3_blob_open(«  sqlite3*,²  const char *zDb,µ  const char *zTable,¶  const char *zColumn,µ  sqlite3_int64 iRow,¬  int flags,·  sqlite3_blob **ppBlob¢); ¢/*Ù,** CAPI3REF: Move a BLOB Handle to a New Row·** METHOD: sqlite3_blob¢**ÙM** ^This function is used to move an existing [BLOB handle] so that it pointsÙL** to a different row of the same database table. ^The new row is identifiedÙH** by the rowid value passed as the second argument. Only the row can beÙL** changed. ^The database, table and column on which the blob handle is openÙD** remain the same. Moving an existing [BLOB handle] to a new row isÙA** faster than closing the existing handle and opening a new one.¢**ÙK** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -ÙH** it must exist and there must be either a blob or text value stored inÙM** the nominated column.)^ ^If the new row is not present in the table, or ifÙK** it does not contain a blob or text value, or if another error occurs, anÙK** SQLite error code is returned and the blob handle is considered aborted.ÙL** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] orÙG** [sqlite3_blob_reopen()] on an aborted blob handle immediately returnÙJ** SQLITE_ABORT. ^Calling [sqlite3_blob_bytes()] on an aborted blob handle·** always returns zero.¢**ÙB** ^This function sets the database handle error code and message.¢*/ÙBSQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64); ¢/*Ù ** CAPI3REF: Close A BLOB Handle»** DESTRUCTOR: sqlite3_blob¢**ÙK** ^This function closes an open [BLOB handle]. ^(The BLOB handle is closedÙE** unconditionally.  Even if this routine returns an error code, the ¼** handle is still closed.)^¢**ÙL** ^If the blob handle being closed was opened for read-write access, and ifÙM** the database is in auto-commit mode and there are no other open read-writeÙF** blob handles or active write statements, the current transaction isÙL** committed. ^If an error occurs while committing the transaction, an errorÙ4** code is returned and the transaction rolled back.¢**ÙJ** Calling this function with an argument that is not a NULL pointer or anÙJ** open blob handle results in undefined behaviour. ^Calling this routine ÙF** with a null pointer (such as would be returned by a failed call to ÙK** [sqlite3_blob_open()]) is a harmless no-op. ^Otherwise, if this functionÙB** is passed a valid open blob handle, the values returned by the ÙM** sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.¢*/Ù2SQLITE_API int sqlite3_blob_close(sqlite3_blob *); ¢/*Ù,** CAPI3REF: Return The Size Of An Open BLOB·** METHOD: sqlite3_blob¢**Ù=** ^Returns the size in bytes of the BLOB accessible via the Ù@** successfully opened [BLOB handle] in its only argument.  ^TheÙF** incremental blob I/O routines can only read or overwriting existingÙ7** blob content; they cannot change the size of a blob.¢**ÙD** This routine only works on a [BLOB handle] which has been createdÙH** by a prior successful call to [sqlite3_blob_open()] and which has notÙG** been closed by [sqlite3_blob_close()].  Passing any other pointer inÙJ** to this routine results in undefined and probably undesirable behavior.¢*/Ù2SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *); ¢/*Ù0** CAPI3REF: Read Data From A BLOB Incrementally·** METHOD: sqlite3_blob¢**ÙI** ^(This function is used to read data from an open [BLOB handle] into aÙC** caller-supplied buffer. N bytes of data are copied into buffer ZÙ4** from the open BLOB, starting at offset iOffset.)^¢**ÙD** ^If offset iOffset is less than N bytes from the end of the BLOB,ÙG** [SQLITE_ERROR] is returned and no data is read.  ^If N or iOffset isÙB** less than zero, [SQLITE_ERROR] is returned and no data is read.ÙC** ^The size of the blob (and hence the maximum value of N+iOffset)Ù@** can be determined using the [sqlite3_blob_bytes()] interface.¢**ÙB** ^An attempt to read from an expired [BLOB handle] fails with anÙ ** error code of [SQLITE_ABORT].¢**Ù7** ^(On success, sqlite3_blob_read() returns SQLITE_OK.ÙH** Otherwise, an [error code] or an [extended error code] is returned.)^¢**ÙD** This routine only works on a [BLOB handle] which has been createdÙH** by a prior successful call to [sqlite3_blob_open()] and which has notÙG** been closed by [sqlite3_blob_close()].  Passing any other pointer inÙJ** to this routine results in undefined and probably undesirable behavior.¢**Ù$** See also: [sqlite3_blob_write()].¢*/ÙNSQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset); ¢/*Ù1** CAPI3REF: Write Data Into A BLOB Incrementally·** METHOD: sqlite3_blob¢**ÙJ** ^(This function is used to write data into an open [BLOB handle] from aÙG** caller-supplied buffer. N bytes of data are copied from the buffer ZÙ4** into the open BLOB, starting at offset iOffset.)^¢**Ù8** ^(On success, sqlite3_blob_write() returns SQLITE_OK.ÙI** Otherwise, an  [error code] or an [extended error code] is returned.)^Ù=** ^Unless SQLITE_MISUSE is returned, this function sets the Ù?** [database connection] error code and message accessible via ÙE** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions. ¢**ÙH** ^If the [BLOB handle] passed as the first argument was not opened forÙC** writing (the flags parameter to [sqlite3_blob_open()] was zero),Ù+** this function returns [SQLITE_READONLY].¢**Ù@** This function may only modify the contents of the BLOB; it isÙ>** not possible to increase the size of a BLOB using this API.ÙD** ^If offset iOffset is less than N bytes from the end of the BLOB,ÙF** [SQLITE_ERROR] is returned and no data is written. The size of the ÙE** BLOB (and hence the maximum value of N+iOffset) can be determined ÙI** using the [sqlite3_blob_bytes()] interface. ^If N or iOffset are less Ù?** than zero [SQLITE_ERROR] is returned and no data is written.¢**ÙA** ^An attempt to write to an expired [BLOB handle] fails with anÙC** error code of [SQLITE_ABORT].  ^Writes to the BLOB that occurredÙ>** before the [BLOB handle] expired are not rolled back by theÙA** expiration of the handle, though of course those changes mightÙF** have been overwritten by the statement that expired the BLOB handleÙ&** or by other independent statements.¢**ÙD** This routine only works on a [BLOB handle] which has been createdÙH** by a prior successful call to [sqlite3_blob_open()] and which has notÙG** been closed by [sqlite3_blob_close()].  Passing any other pointer inÙJ** to this routine results in undefined and probably undesirable behavior.¢**Ù#** See also: [sqlite3_blob_read()].¢*/ÙUSQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset); ¢/*Ù(** CAPI3REF: Virtual File System Objects¢**Ù8** A virtual filesystem (VFS) is an [sqlite3_vfs] object¿** that SQLite uses to interactÙH** with the underlying operating system.  Most SQLite builds come with aÙ@** single default VFS that is appropriate for the host computer.ÙF** New VFSes can be registered and existing VFSes can be unregistered.Ù)** The following interfaces are provided.¢**ÙO** ^The sqlite3_vfs_find() interface returns a pointer to a VFS given its name.½** ^Names are case sensitive.Ù,** ^Names are zero-terminated UTF-8 strings.Ù5** ^If there is no match, a NULL pointer is returned.Ù9** ^If zVfsName is NULL then the default VFS is returned.¢**Ù9** ^New VFSes are registered with sqlite3_vfs_register().ÙE** ^Each new VFS becomes the default VFS if the makeDflt flag is set.ÙA** ^The same VFS can be registered multiple times without injury.ÙC** ^To make an existing VFS into the default VFS, register it againÙ?** with the makeDflt flag set.  If two different VFSes with theÙ=** same name are registered, the behavior is undefined.  If aÙA** VFS is registered with a name that is NULL or an empty string,Ù"** then the behavior is undefined.¢**ÙA** ^Unregister a VFS with the sqlite3_vfs_unregister() interface.ÙA** ^(If the default VFS is unregistered, another VFS is chosen asÙ;** the default.  The choice for the new VFS is arbitrary.)^¢*/Ù?SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);Ù@SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);Ù4SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*); ¢/*´** CAPI3REF: Mutexes¢**Ù1** The SQLite core uses these routines for threadÙ9** synchronization. Though they are intended for internalÙ3** use by SQLite, code that links against SQLite isÙ*** permitted to use any of these routines.¢**Ù;** The SQLite source code contains multiple implementationsÙ:** of these mutex routines.  An appropriate implementationÙ<** is selected automatically at compile-time.  The followingÙ4** implementations are available in the SQLite core:¢**§** <ul>¿** <li>   SQLITE_MUTEX_PTHREADSº** <li>   SQLITE_MUTEX_W32»** <li>   SQLITE_MUTEX_NOOP¨** </ul>¢**Ù<** The SQLITE_MUTEX_NOOP implementation is a set of routinesÙ:** that does no real locking and is appropriate for use inÙ@** a single-threaded application.  The SQLITE_MUTEX_PTHREADS andÙC** SQLITE_MUTEX_W32 implementations are appropriate for use on Unix¯** and Windows.¢**ÙB** If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessorÙ@** macro defined (with "-DSQLITE_MUTEX_APPDEF=1"), then no mutexÙ@** implementation is included with the library. In this case theÙB** application must supply a custom mutex implementation using theÙ@** [SQLITE_CONFIG_MUTEX] option of the sqlite3_config() functionÙC** before calling sqlite3_initialize() or any other public sqlite3_Ù,** function that calls sqlite3_initialize().¢**Ù5** ^The sqlite3_mutex_alloc() routine allocates a newÙ@** mutex and returns a pointer to it. ^The sqlite3_mutex_alloc()ÙA** routine returns NULL if it is unable to allocate the requestedÙB** mutex.  The argument to sqlite3_mutex_alloc() must one of theseµ** integer constants:¢**§** <ul>º** <li>  SQLITE_MUTEX_FAST¿** <li>  SQLITE_MUTEX_RECURSIVEÙ#** <li>  SQLITE_MUTEX_STATIC_MASTERÙ ** <li>  SQLITE_MUTEX_STATIC_MEMÙ!** <li>  SQLITE_MUTEX_STATIC_OPENÙ!** <li>  SQLITE_MUTEX_STATIC_PRNGÙ ** <li>  SQLITE_MUTEX_STATIC_LRUÙ!** <li>  SQLITE_MUTEX_STATIC_PMEMÙ!** <li>  SQLITE_MUTEX_STATIC_APP1Ù!** <li>  SQLITE_MUTEX_STATIC_APP2Ù!** <li>  SQLITE_MUTEX_STATIC_APP3Ù!** <li>  SQLITE_MUTEX_STATIC_VFS1Ù!** <li>  SQLITE_MUTEX_STATIC_VFS2Ù!** <li>  SQLITE_MUTEX_STATIC_VFS3¨** </ul>¢**ÙJ** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)Ù(** cause sqlite3_mutex_alloc() to createÙH** a new mutex.  ^The new mutex is recursive when SQLITE_MUTEX_RECURSIVEÙA** is used but not necessarily so when SQLITE_MUTEX_FAST is used.Ù?** The mutex implementation does not need to make a distinctionÙB** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it doesÙ>** not want to.  SQLite will only request a recursive mutex inÙD** cases where it really needs one.  If a faster non-recursive mutexÙH** implementation is available on the host platform, the mutex subsystemÙ>** might return such a mutex in response to SQLITE_MUTEX_FAST.¢**ÙI** ^The other allowed parameters to sqlite3_mutex_alloc() (anything otherÙA** than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each returnÙE** a pointer to a static preexisting mutex.  ^Nine static mutexes areÙD** used by the current version of SQLite.  Future versions of SQLiteÙF** may add additional static mutexes.  Static mutexes are for internalÙC** use by SQLite only.  Applications that use SQLite mutexes shouldÙ@** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST orº** SQLITE_MUTEX_RECURSIVE.¢**ÙG** ^Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FASTÙ@** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()Ù<** returns a different mutex on every call.  ^For the staticÙA** mutex types, the same mutex is returned on every call that has¸** the same type number.¢**Ù=** ^The sqlite3_mutex_free() routine deallocates a previouslyÙ>** allocated dynamic mutex.  Attempting to deallocate a staticÙ'** mutex results in undefined behavior.¢**ÙF** ^The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptÙE** to enter a mutex.  ^If another thread is already within the mutex,ÙG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnÙG** SQLITE_BUSY.  ^The sqlite3_mutex_try() interface returns [SQLITE_OK]Ù2** upon successful entry.  ^(Mutexes created usingÙK** SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread.µ** In such cases, theÙF** mutex must be exited an equal number of times before another threadÙB** can enter.)^  If the same thread tries to enter any mutex otherÙL** than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.¢**ÙH** ^(Some systems (for example, Windows 95) do not support the operationÙM** implemented by sqlite3_mutex_try().  On those systems, sqlite3_mutex_try()ÙA** will always return SQLITE_BUSY. The SQLite core only ever usesÙ@** sqlite3_mutex_try() as an optimization so this is acceptable ®** behavior.)^¢**Ù<** ^The sqlite3_mutex_leave() routine exits a mutex that wasÙ8** previously entered by the same thread.   The behaviorÙ<** is undefined if the mutex is not currently entered by theÙ0** calling thread or is not currently allocated.¢**ÙE** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), orÙC** sqlite3_mutex_leave() is a NULL pointer, then all three routines´** behave as no-ops.¢**ÙB** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].¢*/Ù3SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);Ù3SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);Ù4SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);Ù1SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);Ù4SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*); ¢/*Ù!** CAPI3REF: Mutex Methods Object¢**Ù?** An instance of this structure defines the low-level routinesÙ$** used to allocate and use mutexes.¢**ÙD** Usually, the default mutex implementations provided by SQLite areÙN** sufficient, however the application has the option of substituting a customÙI** implementation for specialized deployments or systems for which SQLiteÙL** does not provide a suitable implementation. In this case, the applicationÙ>** creates and populates an instance of this structure to passÙC** to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.Ù@** Additionally, an instance of this structure can be used as anÙA** output variable when querying the system for the current mutexÙ=** implementation, using the [SQLITE_CONFIG_GETMUTEX] option.¢**ÙA** ^The xMutexInit method defined by this structure is invoked asÙF** part of system initialization by the sqlite3_initialize() function.ÙD** ^The xMutexInit routine is called by SQLite exactly once for eachÙ,** effective call to [sqlite3_initialize()].¢**Ù@** ^The xMutexEnd method defined by this structure is invoked asÙB** part of system shutdown by the sqlite3_shutdown() function. TheÙG** implementation of this method is expected to release all outstandingÙE** resources obtained by the mutex methods implementation, especiallyÙ=** those obtained by the xMutexInit method.  ^The xMutexEnd()ÙK** interface is invoked exactly once for each call to [sqlite3_shutdown()].¢**ÙH** ^(The remaining seven methods defined by this structure (xMutexAlloc,ÙB** xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld andÙD** xMutexNotheld) implement the following interfaces (respectively):¢**§** <ul>Ù(**   <li>  [sqlite3_mutex_alloc()] </li>Ù'**   <li>  [sqlite3_mutex_free()] </li>Ù(**   <li>  [sqlite3_mutex_enter()] </li>Ù&**   <li>  [sqlite3_mutex_try()] </li>Ù(**   <li>  [sqlite3_mutex_leave()] </li>Ù'**   <li>  [sqlite3_mutex_held()] </li>Ù***   <li>  [sqlite3_mutex_notheld()] </li>ª** </ul>)^¢**ÙJ** The only difference is that the public sqlite3_XXX functions enumeratedÙI** above silently ignore any invocations that pass a NULL pointer insteadÙF** of a valid mutex handle. The implementations of the methods definedÙF** by this structure are not required to handle this case, the resultsÙJ** of passing a NULL pointer instead of a valid mutex handle are undefinedÙH** (i.e. it is acceptable to provide an implementation that segfaults ifÙ ** it is passed a NULL pointer).¢**ÙF** The xMutexInit() method must be threadsafe.  It must be harmless toÙI** invoke xMutexInit() multiple times within the same process and withoutÙD** intervening calls to xMutexEnd().  Second and subsequent calls to¿** xMutexInit() must be no-ops.¢**ÙI** xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]ÙL** and its associates).  Similarly, xMutexAlloc() must not use SQLite memoryÙH** allocation for a static mutex.  ^However xMutexAlloc() may use SQLiteÙ3** memory allocation for a fast or recursive mutex.¢**ÙJ** ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] isÙG** called, but only if the prior call to xMutexInit returned SQLITE_OK.ÙJ** If xMutexInit fails in any way, it is expected to clean up after itself¶** prior to returning.¢*/Ù;typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;¾struct sqlite3_mutex_methods {º  int (*xMutexInit)(void);¹  int (*xMutexEnd)(void);Ù%  sqlite3_mutex *(*xMutexAlloc)(int);Ù&  void (*xMutexFree)(sqlite3_mutex *);Ù'  void (*xMutexEnter)(sqlite3_mutex *);Ù$  int (*xMutexTry)(sqlite3_mutex *);Ù'  void (*xMutexLeave)(sqlite3_mutex *);Ù%  int (*xMutexHeld)(sqlite3_mutex *);Ù(  int (*xMutexNotheld)(sqlite3_mutex *);¢}; ¢/*Ù(** CAPI3REF: Mutex Verification Routines¢**Ù@** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routinesÙD** are intended for use inside assert() statements.  The SQLite coreÙG** never uses these routines except inside an assert() and applicationsÙD** are advised to follow the lead of the core.  The SQLite core onlyÙB** provides implementations for these routines when it is compiledÙ>** with the SQLITE_DEBUG flag.  External mutex implementationsÙA** are only required to provide these routines if SQLITE_DEBUG isÙ(** defined and if NDEBUG is not defined.¢**ÙC** These routines should return true if the mutex in their argumentÙ<** is held or not held, respectively, by the calling thread.¢**ÙB** The implementation is not required to provide versions of theseÙN** routines that actually work. If the implementation does not provide workingÙK** versions of these routines, it should at least provide stubs that alwaysÙD** return true so that one does not get spurious assertion failures.¢**ÙA** If the argument to sqlite3_mutex_held() is a NULL pointer thenÙD** the routine should return 1.   This seems counter-intuitive sinceÙ>** clearly the mutex cannot be held if it does not exist.  ButÙB** the reason the mutex does not exist is because the build is notÙA** using mutexes.  And we do not want the assert() containing theÙ@** call to sqlite3_mutex_held() to fail, so a non-zero return isÙ<** the appropriate thing to do.  The sqlite3_mutex_notheld()Ù<** interface should also return 1 when given a NULL pointer.¢*/®#ifndef NDEBUGÙ2SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);Ù5SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);¦#endif ¢/*¸** CAPI3REF: Mutex Types¢**Ù@** The [sqlite3_mutex_alloc()] interface takes a single argumentÙ+** which is one of these integer constants.¢**ÙF** The set of static mutexes may change from one SQLite release to theÙE** next.  Applications that override the built-in mutex logic must beÙ5** prepared to accommodate additional static mutexes.¢*/Ù'#define SQLITE_MUTEX_FAST             0Ù'#define SQLITE_MUTEX_RECURSIVE        1Ù'#define SQLITE_MUTEX_STATIC_MASTER    2Ù?#define SQLITE_MUTEX_STATIC_MEM       3  /* sqlite3_malloc() */Ù7#define SQLITE_MUTEX_STATIC_MEM2      4  /* NOT USED */ÙA#define SQLITE_MUTEX_STATIC_OPEN      4  /* sqlite3BtreeOpen() */ÙC#define SQLITE_MUTEX_STATIC_PRNG      5  /* sqlite3_randomness() */Ù<#define SQLITE_MUTEX_STATIC_LRU       6  /* lru page list */Ù7#define SQLITE_MUTEX_STATIC_LRU2      7  /* NOT USED */ÙB#define SQLITE_MUTEX_STATIC_PMEM      7  /* sqlite3PageMalloc() */ÙE#define SQLITE_MUTEX_STATIC_APP1      8  /* For use by application */ÙE#define SQLITE_MUTEX_STATIC_APP2      9  /* For use by application */ÙE#define SQLITE_MUTEX_STATIC_APP3     10  /* For use by application */ÙF#define SQLITE_MUTEX_STATIC_VFS1     11  /* For use by built-in VFS */ÙG#define SQLITE_MUTEX_STATIC_VFS2     12  /* For use by extension VFS */ÙI#define SQLITE_MUTEX_STATIC_VFS3     13  /* For use by application VFS */ ¢/*Ù9** CAPI3REF: Retrieve the mutex for a database connection²** METHOD: sqlite3¢**ÙE** ^This interface returns a pointer the [sqlite3_mutex] object that ÙG** serializes access to the [database connection] given in the argumentÙ+** when the [threading mode] is Serialized.ÙF** ^If the [threading mode] is Single-thread or Multi-thread then thisÙ"** routine returns a NULL pointer.¢*/Ù5SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*); ¢/*Ù0** CAPI3REF: Low-Level Control Of Database Files²** METHOD: sqlite3¢**ÙE** ^The [sqlite3_file_control()] interface makes a direct call to theÙE** xFileControl method for the [sqlite3_io_methods] object associatedÙE** with a particular database identified by the second argument. ^TheÙI** name of the database is "main" for the main database or "temp" for theÙC** TEMP database, or the name that appears after the AS keyword forÙ;** databases that are added using the [ATTACH] SQL command.ÙA** ^A NULL pointer can be used in place of "main" to refer to the¶** main database file.Ù3** ^The third and fourth parameters to this routineÙD** are passed directly through to the second and third parameters ofÙB** the xFileControl method.  ^The return value of the xFileControlÙ3** method becomes the return value of this routine.¢**ÙE** ^The [SQLITE_FCNTL_FILE_POINTER] value for the op parameter causesÙG** a pointer to the underlying [sqlite3_file] object to be written intoÙO** the space pointed to by the 4th parameter.  ^The [SQLITE_FCNTL_FILE_POINTER]ÙB** case is a short-circuit path which does not actually invoke theÙ5** underlying sqlite3_io_methods.xFileControl method.¢**ÙD** ^If the second parameter (zDbName) does not match the name of anyÙB** open database file, then SQLITE_ERROR is returned.  ^This errorÙI** code is not remembered and will not be recalled by [sqlite3_errcode()]ÙC** or [sqlite3_errmsg()].  The underlying xFileControl method mightÙD** also return SQLITE_ERROR.  There is no way to distinguish betweenÙF** an incorrect zDbName and an SQLITE_ERROR return from the underlying·** xFileControl method.¢**Ù#** See also: [file control opcodes]¢*/ÙRSQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*); ¢/*¾** CAPI3REF: Testing Interface¢**ÙE** ^The sqlite3_test_control() interface is used to read out internalÙ?** state of SQLite and to inject faults into SQLite for testingÙG** purposes.  ^The first parameter is an operation code that determinesÙC** the number, meaning, and operation of all subsequent parameters.¢**ÙC** This interface is not for use by applications.  It exists solelyÙH** for verifying the correct operation of the SQLite library.  DependingÙI** on how the SQLite library is compiled, this interface might not exist.¢**ÙE** The details of the operation codes, their meanings, the parametersÙH** they take, and what they do are all subject to change without notice.ÙD** Unlike most of the SQLite API, this function is not guaranteed toÙ5** operate consistently from one release to the next.¢*/Ù1SQLITE_API int sqlite3_test_control(int op, ...); ¢/*Ù.** CAPI3REF: Testing Interface Operation Codes¢**Ù?** These constants are the valid operation code parameters usedÙ5** as the first argument to [sqlite3_test_control()].¢**Ù<** These parameters and their meanings are subject to changeÙ?** without notice.  These values are for testing purposes only.Ù=** Applications should not use any of these parameters or theÙ&** [sqlite3_test_control()] interface.¢*/Ù2#define SQLITE_TESTCTRL_FIRST                    5Ù2#define SQLITE_TESTCTRL_PRNG_SAVE                5Ù2#define SQLITE_TESTCTRL_PRNG_RESTORE             6Ù2#define SQLITE_TESTCTRL_PRNG_RESET               7Ù2#define SQLITE_TESTCTRL_BITVEC_TEST              8Ù2#define SQLITE_TESTCTRL_FAULT_INSTALL            9Ù2#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10Ù2#define SQLITE_TESTCTRL_PENDING_BYTE            11Ù2#define SQLITE_TESTCTRL_ASSERT                  12Ù2#define SQLITE_TESTCTRL_ALWAYS                  13Ù2#define SQLITE_TESTCTRL_RESERVE                 14Ù2#define SQLITE_TESTCTRL_OPTIMIZATIONS           15Ù2#define SQLITE_TESTCTRL_ISKEYWORD               16ÙB#define SQLITE_TESTCTRL_SCRATCHMALLOC           17  /* NOT USED */Ù2#define SQLITE_TESTCTRL_LOCALTIME_FAULT         18ÙB#define SQLITE_TESTCTRL_EXPLAIN_STMT            19  /* NOT USED */Ù2#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD    19Ù2#define SQLITE_TESTCTRL_NEVER_CORRUPT           20Ù2#define SQLITE_TESTCTRL_VDBE_COVERAGE           21Ù2#define SQLITE_TESTCTRL_BYTEORDER               22Ù2#define SQLITE_TESTCTRL_ISINIT                  23Ù2#define SQLITE_TESTCTRL_SORTER_MMAP             24Ù2#define SQLITE_TESTCTRL_IMPOSTER                25Ù2#define SQLITE_TESTCTRL_PARSER_COVERAGE         26ÙJ#define SQLITE_TESTCTRL_LAST                    26  /* Largest TESTCTRL */ ¢/*Ù"** CAPI3REF: SQLite Runtime Status¢**ÙD** ^These interfaces are used to retrieve runtime status informationÙC** about the performance of SQLite, and optionally to reset variousÙ?** highwater marks.  ^The first argument is an integer code forÙA** the specific parameter to measure.  ^(Recognized integer codesÙ=** are of the form [status parameters | SQLITE_STATUS_...].)^ÙB** ^The current value of the parameter is returned into *pCurrent.ÙC** ^The highest recorded value is returned in *pHighwater.  ^If theÙB** resetFlag is true, then the highest record value is reset afterÙG** *pHighwater is written.  ^(Some parameters do not record the highest¿** value.  For those parametersÙF** nothing is written into *pHighwater and the resetFlag is ignored.)^ÙH** ^(Other parameters record only the highwater mark and not the currentÙK** value.  For these latter parameters nothing is written into *pCurrent.)^¢**Ù?** ^The sqlite3_status() and sqlite3_status64() routines returnÙ?** SQLITE_OK on success and a non-zero [error code] on failure.¢**ÙD** If either the current value or the highwater mark is too large toÙB** be represented by a 32-bit integer, then the values returned byÙ"** sqlite3_status() are undefined.¢**Ù"** See also: [sqlite3_db_status()]¢*/ÙUSQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);Ù SQLITE_API int sqlite3_status64(©  int op,º  sqlite3_int64 *pCurrent,¼  sqlite3_int64 *pHighwater,¯  int resetFlag¢);  ¢/*¾** CAPI3REF: Status ParametersÙ ** KEYWORDS: {status parameters}¢**ÙG** These integer constants designate various run-time status parametersÙ.** that can be returned by [sqlite3_status()].¢**§** <dl>ÙE** [[SQLITE_STATUS_MEMORY_USED]] ^(<dt>SQLITE_STATUS_MEMORY_USED</dt>ÙA** <dd>This parameter is the current amount of memory checked outÙ@** using [sqlite3_malloc()], either directly or indirectly.  TheÙF** figure includes calls made to [sqlite3_malloc()] by the applicationÙI** and internal memory usage by the SQLite library.  Auxiliary page-cacheÙD** memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included inÙD** this parameter.  The amount returned is the sum of the allocationÙI** sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>)^¢**ÙE** [[SQLITE_STATUS_MALLOC_SIZE]] ^(<dt>SQLITE_STATUS_MALLOC_SIZE</dt>ÙC** <dd>This parameter records the largest memory allocation requestÙ@** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or theirÙ9** internal equivalents).  Only the value returned in theÙ@** *pHighwater parameter to [sqlite3_status()] is of interest.  ÙF** The value written into the *pCurrent parameter is undefined.</dd>)^¢**ÙG** [[SQLITE_STATUS_MALLOC_COUNT]] ^(<dt>SQLITE_STATUS_MALLOC_COUNT</dt>ÙG** <dd>This parameter records the number of separate memory allocationsÙ ** currently checked out.</dd>)^¢**ÙK** [[SQLITE_STATUS_PAGECACHE_USED]] ^(<dt>SQLITE_STATUS_PAGECACHE_USED</dt>ÙA** <dd>This parameter returns the number of pages used out of theÙ:** [pagecache memory allocator] that was configured using Ù"** [SQLITE_CONFIG_PAGECACHE].  TheÙ3** value returned is in pages, not in bytes.</dd>)^¢**Ù(** [[SQLITE_STATUS_PAGECACHE_OVERFLOW]] Ù.** ^(<dt>SQLITE_STATUS_PAGECACHE_OVERFLOW</dt>Ù?** <dd>This parameter returns the number of bytes of page cacheÙK** allocation which could not be satisfied by the [SQLITE_CONFIG_PAGECACHE]ÙB** buffer and where forced to overflow to [sqlite3_malloc()].  TheÙC** returned value includes allocations that overflowed because theyÙ?** where too large (they were larger than the "sz" parameter toÙE** [SQLITE_CONFIG_PAGECACHE]) and allocations that overflowed becauseÙ.** no space was left in the page cache.</dd>)^¢**ÙK** [[SQLITE_STATUS_PAGECACHE_SIZE]] ^(<dt>SQLITE_STATUS_PAGECACHE_SIZE</dt>ÙC** <dd>This parameter records the largest memory allocation requestÙJ** handed to [pagecache memory allocator].  Only the value returned in theÙ@** *pHighwater parameter to [sqlite3_status()] is of interest.  ÙF** The value written into the *pCurrent parameter is undefined.</dd>)^¢**ÙE** [[SQLITE_STATUS_SCRATCH_USED]] <dt>SQLITE_STATUS_SCRATCH_USED</dt>»** <dd>No longer used.</dd>¢**ÙO** [[SQLITE_STATUS_SCRATCH_OVERFLOW]] ^(<dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>»** <dd>No longer used.</dd>¢**ÙE** [[SQLITE_STATUS_SCRATCH_SIZE]] <dt>SQLITE_STATUS_SCRATCH_SIZE</dt>»** <dd>No longer used.</dd>¢**ÙG** [[SQLITE_STATUS_PARSER_STACK]] ^(<dt>SQLITE_STATUS_PARSER_STACK</dt>ÙC** <dd>The *pHighwater parameter records the deepest parser stack. ÙC** The *pCurrent value is undefined.  The *pHighwater value is onlyÙG** meaningful if SQLite is compiled with [YYTRACKMAXSTACKDEPTH].</dd>)^¨** </dl>¢**Ù8** New status parameters may be added from time to time.¢*/Ù,#define SQLITE_STATUS_MEMORY_USED          0Ù,#define SQLITE_STATUS_PAGECACHE_USED       1Ù,#define SQLITE_STATUS_PAGECACHE_OVERFLOW   2Ù<#define SQLITE_STATUS_SCRATCH_USED         3  /* NOT USED */Ù<#define SQLITE_STATUS_SCRATCH_OVERFLOW     4  /* NOT USED */Ù,#define SQLITE_STATUS_MALLOC_SIZE          5Ù,#define SQLITE_STATUS_PARSER_STACK         6Ù,#define SQLITE_STATUS_PAGECACHE_SIZE       7Ù<#define SQLITE_STATUS_SCRATCH_SIZE         8  /* NOT USED */Ù,#define SQLITE_STATUS_MALLOC_COUNT         9 ¢/*Ù'** CAPI3REF: Database Connection Status²** METHOD: sqlite3¢**ÙB** ^This interface is used to retrieve runtime status information ÙD** about a single [database connection].  ^The first argument is theÙG** database connection object to be interrogated.  ^The second argumentÙ0** is an integer constant, taken from the set ofÙ"** [SQLITE_DBSTATUS options], thatÙ8** determines the parameter to interrogate.  The set of Ù&** [SQLITE_DBSTATUS options] is likelyÙ(** to grow in future releases of SQLite.¢**ÙF** ^The current value of the requested parameter is written into *pCurÙD** and the highest instantaneous value is written into *pHiwtr.  ^IfÙ@** the resetFlg is true, then the highest instantaneous value isÙ(** reset back down to the current value.¢**ÙF** ^The sqlite3_db_status() routine returns SQLITE_OK on success and aÙ$** non-zero [error code] on failure.¢**Ù<** See also: [sqlite3_status()] and [sqlite3_stmt_status()].¢*/ÙYSQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg); ¢/*Ù7** CAPI3REF: Status Parameters for database connectionsÙ&** KEYWORDS: {SQLITE_DBSTATUS options}¢**ÙJ** These constants are the available integer "verbs" that can be passed asÙ>** the second argument to the [sqlite3_db_status()] interface.¢**ÙF** New verbs may be added in future releases of SQLite. Existing verbsÙH** might be discontinued. Applications should check the return code fromÙ;** [sqlite3_db_status()] to make sure that the call worked.ÙH** The [sqlite3_db_status()] interface will return a non-zero error codeÙ4** if a discontinued or unsupported verb is invoked.¢**§** <dl>ÙO** [[SQLITE_DBSTATUS_LOOKASIDE_USED]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_USED</dt>ÙL** <dd>This parameter returns the number of lookaside memory slots currently¶** checked out.</dd>)^¢**ÙM** [[SQLITE_DBSTATUS_LOOKASIDE_HIT]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_HIT</dt>ÙC** <dd>This parameter returns the number malloc attempts that were ÙM** satisfied using lookaside memory. Only the high-water value is meaningful;Ù&** the current value is always zero.)^¢**Ù*** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE]]Ù1** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE</dt>ÙH** <dd>This parameter returns the number malloc attempts that might haveÙH** been satisfied using lookaside memory but failed due to the amount ofÙ>** memory requested being larger than the lookaside slot size.Ù+** Only the high-water value is meaningful;Ù&** the current value is always zero.)^¢**Ù*** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL]]Ù1** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL</dt>ÙH** <dd>This parameter returns the number malloc attempts that might haveÙH** been satisfied using lookaside memory but failed due to all lookaside¿** memory already being in use.Ù+** Only the high-water value is meaningful;Ù&** the current value is always zero.)^¢**ÙG** [[SQLITE_DBSTATUS_CACHE_USED]] ^(<dt>SQLITE_DBSTATUS_CACHE_USED</dt>ÙE** <dd>This parameter returns the approximate number of bytes of heapÙM** memory used by all pager caches associated with the database connection.)^ÙN** ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.¢**Ù)** [[SQLITE_DBSTATUS_CACHE_USED_SHARED]] Ù/** ^(<dt>SQLITE_DBSTATUS_CACHE_USED_SHARED</dt>ÙI** <dd>This parameter is similar to DBSTATUS_CACHE_USED, except that if aÙJ** pager cache is shared between two or more connections the bytes of heapÙI** memory used by that pager cache is divided evenly between the attachedÙI** connections.)^  In other words, if none of the pager caches associatedÙI** with the database connection are shared, this request returns the sameÙK** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches areÙM** shared, the value returned by this call will be smaller than that returnedÙ>** by DBSTATUS_CACHE_USED. ^The highwater mark associated withÙ1** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.¢**ÙI** [[SQLITE_DBSTATUS_SCHEMA_USED]] ^(<dt>SQLITE_DBSTATUS_SCHEMA_USED</dt>ÙE** <dd>This parameter returns the approximate number of bytes of heapÙ?** memory used to store the schema for all databases associatedÙF** with the connection - main, temp, and any [ATTACH]-ed databases.)^ ÙJ** ^The full amount of memory used by the schemas is reported, even if theÙA** schema memory is shared with other database connections due toÙ%** [shared cache mode] being enabled.ÙO** ^The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.¢**ÙE** [[SQLITE_DBSTATUS_STMT_USED]] ^(<dt>SQLITE_DBSTATUS_STMT_USED</dt>ÙE** <dd>This parameter returns the approximate number of bytes of heapÙG** and lookaside memory used by all prepared statements associated with½** the database connection.)^ÙM** ^The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.¨** </dd>¢**ÙE** [[SQLITE_DBSTATUS_CACHE_HIT]] ^(<dt>SQLITE_DBSTATUS_CACHE_HIT</dt>ÙF** <dd>This parameter returns the number of pager cache hits that haveÙM** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT ¯** is always 0.¨** </dd>¢**ÙG** [[SQLITE_DBSTATUS_CACHE_MISS]] ^(<dt>SQLITE_DBSTATUS_CACHE_MISS</dt>ÙH** <dd>This parameter returns the number of pager cache misses that haveÙN** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS ¯** is always 0.¨** </dd>¢**ÙI** [[SQLITE_DBSTATUS_CACHE_WRITE]] ^(<dt>SQLITE_DBSTATUS_CACHE_WRITE</dt>ÙI** <dd>This parameter returns the number of dirty cache entries that haveÙI** been written to disk. Specifically, the number of pages written to theÙH** wal file in wal mode databases, or the number of pages written to theÙI** database file in rollback mode databases. Any pages written as part ofÙI** transaction rollback or database recovery operations are not included.ÙJ** If an IO or other error occurs while writing a page to disk, the effectÙJ** on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined.)^ ^TheÙJ** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.¨** </dd>¢**ÙI** [[SQLITE_DBSTATUS_CACHE_SPILL]] ^(<dt>SQLITE_DBSTATUS_CACHE_SPILL</dt>ÙI** <dd>This parameter returns the number of dirty cache entries that haveÙF** been written to disk in the middle of a transaction due to the pageÙI** cache overflowing. Transactions are more efficient if they are writtenÙI** to disk all at once. When pages spill mid-transaction, that introducesÙ@** additional overhead. This parameter can be used help identifyÙC** inefficiencies that can be resolve by increasing the cache size.¨** </dd>¢**ÙK** [[SQLITE_DBSTATUS_DEFERRED_FKS]] ^(<dt>SQLITE_DBSTATUS_DEFERRED_FKS</dt>ÙG** <dd>This parameter returns zero for the current value if and only ifÙ@** all foreign key constraints (deferred or immediate) have beenÙ0** resolved.)^  ^The highwater mark is always 0.¨** </dd>¨** </dl>¢*/Ù.#define SQLITE_DBSTATUS_LOOKASIDE_USED       0Ù.#define SQLITE_DBSTATUS_CACHE_USED           1Ù.#define SQLITE_DBSTATUS_SCHEMA_USED          2Ù.#define SQLITE_DBSTATUS_STMT_USED            3Ù.#define SQLITE_DBSTATUS_LOOKASIDE_HIT        4Ù.#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE  5Ù.#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL  6Ù.#define SQLITE_DBSTATUS_CACHE_HIT            7Ù.#define SQLITE_DBSTATUS_CACHE_MISS           8Ù.#define SQLITE_DBSTATUS_CACHE_WRITE          9Ù.#define SQLITE_DBSTATUS_DEFERRED_FKS        10Ù.#define SQLITE_DBSTATUS_CACHE_USED_SHARED   11Ù.#define SQLITE_DBSTATUS_CACHE_SPILL         12ÙO#define SQLITE_DBSTATUS_MAX                 12   /* Largest defined DBSTATUS */  ¢/*Ù&** CAPI3REF: Prepared Statement Status·** METHOD: sqlite3_stmt¢**Ù.** ^(Each prepared statement maintains variousÙ7** [SQLITE_STMTSTATUS counters] that measure the numberÙG** of times it has performed specific operations.)^  These counters canÙE** be used to monitor the performance characteristics of the preparedÙI** statements.  For example, if the number of table steps greatly exceedsÙK** the number of table searches or result rows, that would tend to indicateÙE** that the prepared statement is using a full table scan rather than®** an index.  ¢**ÙE** ^(This interface is used to retrieve and reset counter values fromÙH** a [prepared statement].  The first argument is the prepared statementÙ2** object to be interrogated.  The second argumentÙ@** is an integer code for a specific [SQLITE_STMTSTATUS counter]¸** to be interrogated.)^Ù;** ^The current value of the requested counter is returned.ÙI** ^If the resetFlg is true, then the counter is reset to zero after thisº** interface call returns.¢**Ù:** See also: [sqlite3_status()] and [sqlite3_db_status()].¢*/ÙGSQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg); ¢/*Ù6** CAPI3REF: Status Parameters for prepared statementsÙE** KEYWORDS: {SQLITE_STMTSTATUS counter} {SQLITE_STMTSTATUS counters}¢**ÙC** These preprocessor macros define integer codes that name counterÙ@** values associated with the [sqlite3_stmt_status()] interface.Ù7** The meanings of the various counters are as follows:¢**§** <dl>ÙO** [[SQLITE_STMTSTATUS_FULLSCAN_STEP]] <dt>SQLITE_STMTSTATUS_FULLSCAN_STEP</dt>ÙF** <dd>^This is the number of times that SQLite has stepped forward inÙH** a table as part of a full table scan.  Large numbers for this counterÙB** may indicate opportunities for performance improvement through ¿** careful use of indices.</dd>¢**Ù=** [[SQLITE_STMTSTATUS_SORT]] <dt>SQLITE_STMTSTATUS_SORT</dt>ÙA** <dd>^This is the number of sort operations that have occurred.ÙB** A non-zero value in this counter may indicate an opportunity toÙ?** improvement performance through careful use of indices.</dd>¢**ÙG** [[SQLITE_STMTSTATUS_AUTOINDEX]] <dt>SQLITE_STMTSTATUS_AUTOINDEX</dt>ÙG** <dd>^This is the number of rows inserted into transient indices thatÙ@** were created automatically in order to help joins run faster.ÙB** A non-zero value in this counter may indicate an opportunity toÙB** improvement performance by adding permanent indices that do notÙ@** need to be reinitialized each time the statement is run.</dd>¢**ÙC** [[SQLITE_STMTSTATUS_VM_STEP]] <dt>SQLITE_STMTSTATUS_VM_STEP</dt>ÙA** <dd>^This is the number of virtual machine operations executedÙA** by the prepared statement if that number is less than or equalÙC** to 2147483647.  The number of virtual machine operations can be ÙE** used as a proxy for the total work done by the prepared statement.ÙA** If the number of virtual machine operations exceeds 2147483647ÙF** then the value returned by this statement status code is undefined.¢**ÙG** [[SQLITE_STMTSTATUS_REPREPARE]] <dt>SQLITE_STMTSTATUS_REPREPARE</dt>ÙG** <dd>^This is the number of times that the prepare statement has beenÙ@** automatically regenerated due to schema changes or change to Ù7** [bound parameters] that might affect the query plan.¢**Ù;** [[SQLITE_STMTSTATUS_RUN]] <dt>SQLITE_STMTSTATUS_RUN</dt>ÙC** <dd>^This is the number of times that the prepared statement hasÙD** been run.  A single "run" for the purposes of this counter is oneÙM** or more calls to [sqlite3_step()] followed by a call to [sqlite3_reset()].ÙH** The counter is incremented on the first [sqlite3_step()] call of each©** cycle.¢**ÙC** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>Ù>** <dd>^This is the approximate number of bytes of heap memoryÙE** used to store the prepared statement.  ^This value is not actuallyÙD** a counter, and so the resetFlg parameter to sqlite3_stmt_status()Ù;** is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.¨** </dd>¨** </dl>¢*/Ù-#define SQLITE_STMTSTATUS_FULLSCAN_STEP     1Ù-#define SQLITE_STMTSTATUS_SORT              2Ù-#define SQLITE_STMTSTATUS_AUTOINDEX         3Ù-#define SQLITE_STMTSTATUS_VM_STEP           4Ù-#define SQLITE_STMTSTATUS_REPREPARE         5Ù-#define SQLITE_STMTSTATUS_RUN               6Ù.#define SQLITE_STMTSTATUS_MEMUSED           99 ¢/*Ù%** CAPI3REF: Custom Page Cache Object¢**Ù;** The sqlite3_pcache type is opaque.  It is implemented byÙ=** the pluggable module.  The SQLite core has no knowledge ofÙ:** its size or internal structure and never deals with theÙ?** sqlite3_pcache object except by holding and passing pointers±** to the object.¢**Ù<** See [sqlite3_pcache_methods2] for additional information.¢*/Ù-typedef struct sqlite3_pcache sqlite3_pcache; ¢/*Ù%** CAPI3REF: Custom Page Cache Object¢**ÙA** The sqlite3_pcache_page object represents a single page in theÙ>** page cache.  The page cache will allocate instances of thisÙG** object.  Various methods of the page cache use pointers to instancesÙ9** of this object as parameters or as their return value.¢**Ù<** See [sqlite3_pcache_methods2] for additional information.¢*/Ù7typedef struct sqlite3_pcache_page sqlite3_pcache_page;¼struct sqlite3_pcache_page {Ù2  void *pBuf;        /* The content of the page */ÙE  void *pExtra;      /* Extra information associated with the page */¢}; ¢/*Ù,** CAPI3REF: Application Defined Page Cache.¹** KEYWORDS: {page cache}¢**ÙE** ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface canÙF** register an alternative page cache implementation by passing in an Ù7** instance of the sqlite3_pcache_methods2 structure.)^Ù>** In many applications, most of the heap memory allocated by Ù%** SQLite is used for the page cache.µ** By implementing a ÙF** custom page cache using this API, an application can better controlÙ=** the amount of memory consumed by SQLite, the way in which ÙC** that memory is allocated and released, and the policies used to ÙG** determine exactly which parts of a database file are cached and for ¬** how long.¢**Ù-** The alternative page cache mechanism is anÙJ** extreme measure that is only needed by the most demanding applications.Ù8** The built-in page cache is recommended for most uses.¢**ÙK** ^(The contents of the sqlite3_pcache_methods2 structure are copied to anÙH** internal buffer by SQLite within the call to [sqlite3_config].  HenceÙ>** the application may discard the parameter after the call toÙ ** [sqlite3_config()] returns.)^¢**Ù$** [[the xInit() page cache method]]Ù:** ^(The xInit() method is called once for each effective Ù#** call to [sqlite3_initialize()])^ÙH** (usually only once during the lifetime of the process). ^(The xInit()ÙG** method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^ÙH** The intent of the xInit() method is to set up global data structures Ù5** required by the custom page cache implementation. Ù-** ^(If the xInit() method is NULL, then the ÙI** built-in default page cache is used instead of the application defined°** page cache.)^¢**Ù(** [[the xShutdown() page cache method]]Ù=** ^The xShutdown() method is called by [sqlite3_shutdown()].¾** It can be used to clean up ÙB** any outstanding resources before process shutdown, if required.Ù'** ^The xShutdown() method may be NULL.¢**Ù>** ^SQLite automatically serializes calls to the xInit method,Ù4** so the xInit method need not be threadsafe.  ^TheÙG** xShutdown method is only called from [sqlite3_shutdown()] so it doesÙJ** not need to be threadsafe either.  All other methods must be threadsafeÙ!** in multithreaded applications.¢**ÙJ** ^SQLite will never invoke xInit() more than once without an intervening·** call to xShutdown().¢**Ù'** [[the xCreate() page cache methods]]ÙJ** ^SQLite invokes the xCreate() method to construct a new cache instance.ÙO** SQLite will typically create one cache instance for each open database file,Ù&** though this is not guaranteed. ^TheÙG** first parameter, szPage, is the size in bytes of the pages that mustÙH** be allocated by the cache.  ^szPage will always a power of two.  ^TheÙB** second parameter szExtra is a number of bytes of extra storage ÙF** associated with each page cache entry.  ^The szExtra parameter willÙ/** a number less than 250.  SQLite will use theÙJ** extra szExtra bytes on each page to store metadata about the underlyingÙ@** database page on disk.  The value passed into szExtra dependsÙK** on the SQLite version, the target platform, and how SQLite was compiled.ÙK** ^The third argument to xCreate(), bPurgeable, is true if the cache beingÙL** created will be used to cache database pages of a file stored on disk, orÙJ** false if it is used for an in-memory database. The cache implementationÙK** does not have to do anything special based with the value of bPurgeable;ÙM** it is purely advisory.  ^On a cache where bPurgeable is false, SQLite willÙ>** never invoke xUnpin() except to deliberately delete a page.ÙG** ^In other words, calls to xUnpin() on a cache with bPurgeable set toÙ;** false will always have the "discard" flag set to true.  Ù5** ^Hence, a cache created with bPurgeable false willÙ$** never contain any unpinned pages.¢**Ù)** [[the xCachesize() page cache method]]ÙK** ^(The xCachesize() method may be called at any time by SQLite to set theÙE** suggested maximum cache-size (number of pages stored by) the cacheÙL** instance passed as the first argument. This is the value configured usingÙF** the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeableÙI** parameter, the implementation is not required to do anything with this¾** value; it is advisory only.¢**Ù*** [[the xPagecount() page cache methods]]ÙD** The xPagecount() method must return the number of pages currentlyÙ1** stored in the cache, both pinned and unpinned.£** Ù&** [[the xFetch() page cache methods]]ÙL** The xFetch() method locates a page in the cache and returns a pointer to ÙN** an sqlite3_pcache_page object associated with that page, or a NULL pointer.ÙH** The pBuf element of the returned sqlite3_pcache_page object will be aÙF** pointer to a buffer of szPage bytes used to store the content of a ÙK** single database page.  The pExtra element of sqlite3_pcache_page will beÙL** a pointer to the szExtra bytes of extra storage that SQLite has requestedÙ$** for each entry in the page cache.¢**ÙJ** The page to be fetched is determined by the key. ^The minimum key valueÙJ** is 1.  After it has been retrieved using xFetch, the page is considered²** to be "pinned".¢**ÙJ** If the requested page is already in the page cache, then the page cacheÙK** implementation must return a pointer to the page buffer with its contentÙG** intact.  If the requested page is not already in the cache, then theÙ>** cache implementation should use the value of the createFlagÙ7** parameter to help it determined what action to take:¢**Ù*** <table border=1 width=85% align=center>ÙF** <tr><th> createFlag <th> Behavior when page is not already in cacheÙ<** <tr><td> 0 <td> Do not allocate a new page.  Return NULL.ÙJ** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.Ù)**                 Otherwise return NULL.ÙI** <tr><td> 2 <td> Make every effort to allocate a new page.  Only returnÙK**                 NULL if allocating a new page is effectively impossible.«** </table>¢**ÙN** ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLiteÙL** will only use a createFlag of 2 after a prior call with a createFlag of 1Ù:** failed.)^  In between the to xFetch() calls, SQLite mayÙF** attempt to unpin one or more cache pages by spilling the content ofÙE** pinned pages to disk and synching the operating system disk cache.¢**Ù%** [[the xUnpin() page cache method]]ÙJ** ^xUnpin() is called by SQLite with a pointer to a currently pinned pageÙI** as its second argument.  If the third parameter, discard, is non-zero,Ù0** then the page must be evicted from the cache.¿** ^If the discard parameter isÙH** zero, then the page may be discarded or retained at the discretion ofÙ<** page cache implementation. ^The page cache implementationÙ2** may choose to evict unpinned pages at any time.¢**Ù?** The cache must not perform any reference counting. A single ÙL** call to xUnpin() unpins the page regardless of the number of prior calls ¯** to xFetch().¢**Ù&** [[the xRekey() page cache methods]]ÙJ** The xRekey() method is used to change the key value associated with theÙ3** page passed as the second argument. If the cacheÙB** previously contains an entry associated with newKey, it must beÙM** discarded. ^Any prior cache entry associated with newKey is guaranteed not°** to be pinned.¢**ÙG** When SQLite calls the xTruncate() method, the cache must discard allÙH** existing cache entries with page numbers (keys) greater than or equalÙE** to the value of the iLimit parameter passed to xTruncate(). If anyÙH** of these pages are pinned, they are implicitly unpinned, meaning thatÙ ** they can be safely discarded.¢**Ù'** [[the xDestroy() page cache method]]ÙK** ^The xDestroy() method is used to delete a cache allocated by xCreate().ÙL** All resources associated with the specified cache should be freed. ^AfterÙH** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]ÙM** handle invalid, and will not use it with any other sqlite3_pcache_methods2­** functions.¢**Ù&** [[the xShrink() page cache method]]ÙG** ^SQLite invokes the xShrink() method when it wants the page cache toÙM** free up as much of heap memory as possible.  The page cache implementationÙO** is not obligated to free any memory, but well-behaved implementations should±** do their best.¢*/Ù?typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;Ù struct sqlite3_pcache_methods2 {¯  int iVersion;­  void *pArg;¶  int (*xInit)(void*);»  void (*xShutdown)(void*);ÙF  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);Ù6  void (*xCachesize)(sqlite3_pcache*, int nCachesize);Ù%  int (*xPagecount)(sqlite3_pcache*);ÙP  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);ÙE  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);Ù8  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*, Ù(      unsigned oldKey, unsigned newKey);Ù6  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);Ù$  void (*xDestroy)(sqlite3_pcache*);Ù#  void (*xShrink)(sqlite3_pcache*);¢}; ¢/*ÙH** This is the obsolete pcache_methods object that has now been replacedÙI** by sqlite3_pcache_methods2.  This object is not used by SQLite.  It isÙ@** retained in the header file for backwards compatibility only.¢*/Ù=typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;¿struct sqlite3_pcache_methods {­  void *pArg;¶  int (*xInit)(void*);»  void (*xShutdown)(void*);Ù9  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);Ù6  void (*xCachesize)(sqlite3_pcache*, int nCachesize);Ù%  int (*xPagecount)(sqlite3_pcache*);ÙA  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);Ù6  void (*xUnpin)(sqlite3_pcache*, void*, int discard);ÙK  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);Ù6  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);Ù$  void (*xDestroy)(sqlite3_pcache*);¢};  ¢/*Ù!** CAPI3REF: Online Backup Object¢**ÙG** The sqlite3_backup object records state information about an ongoingÙE** online backup operation.  ^The sqlite3_backup object is created byÙB** a call to [sqlite3_backup_init()] and is destroyed by a call to½** [sqlite3_backup_finish()].¢**Ù1** See Also: [Using the SQLite Online Backup API]¢*/Ù-typedef struct sqlite3_backup sqlite3_backup; ¢/*¿** CAPI3REF: Online Backup API.¢**ÙB** The backup API copies the content of one database into another.Ù;** It is useful either for creating backups of databases orÙ@** for copying in-memory databases to or from persistent files. ¢**Ù1** See Also: [Using the SQLite Online Backup API]¢**ÙJ** ^SQLite holds a write transaction open on the destination database fileÙ,** for the duration of the backup operation.ÙC** ^The source database is read-locked only while it is being read;ÙA** it is not locked continuously for the entire backup operation.ÙG** ^Thus, the backup may be performed on a live source database withoutÙ-** preventing other database connections fromÙJ** reading or writing to the source database while the backup is underway.£** Ù$** ^(To perform a backup operation: ©**   <ol>ÙH**     <li><b>sqlite3_backup_init()</b> is called once to initialize the³**         backup, ÙP**     <li><b>sqlite3_backup_step()</b> is called one or more times to transfer Ù:**         the data between the two databases, and finallyÙM**     <li><b>sqlite3_backup_finish()</b> is called to release all resources Ù1**         associated with the backup operation. ¬**   </ol>)^ÙG** There should be exactly one call to sqlite3_backup_finish() for eachÙ,** successful call to sqlite3_backup_init().¢**Ù9** [[sqlite3_backup_init()]] <b>sqlite3_backup_init()</b>¢**ÙB** ^The D and N arguments to sqlite3_backup_init(D,N,S,M) are the ÙB** [database connection] associated with the destination database Ù'** and the database name, respectively.ÙE** ^The database name is "main" for the main database, "temp" for theÙD** temporary database, or the name specified after the AS keyword inÙ2** an [ATTACH] statement for an attached database.Ù$** ^The S and M arguments passed to ÙB** sqlite3_backup_init(D,N,S,M) identify the [database connection]Ù:** and database name of the source database, respectively.ÙJ** ^The source and destination [database connections] (parameters S and D)ÙH** must be different or else sqlite3_backup_init(D,N,S,M) will fail with¬** an error.¢**ÙB** ^A call to sqlite3_backup_init() will fail, returning NULL, if ÙA** there is already a read or read-write transaction open on the ¸** destination database.¢**ÙH** ^If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL isÙA** returned and an error code and error message are stored in theÙ'** destination [database connection] D.ÙK** ^The error code and message for the failed call to sqlite3_backup_init()ÙM** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/orÙ"** [sqlite3_errmsg16()] functions.ÙF** ^A successful call to sqlite3_backup_init() returns a pointer to an»** [sqlite3_backup] object.ÙN** ^The [sqlite3_backup] object may be used with the sqlite3_backup_step() andÙE** sqlite3_backup_finish() functions to perform the specified backup ­** operation.¢**Ù9** [[sqlite3_backup_step()]] <b>sqlite3_backup_step()</b>¢**ÙF** ^Function sqlite3_backup_step(B,N) will copy up to N pages between ÙO** the source and destination databases specified by [sqlite3_backup] object B.Ù=** ^If N is negative, all remaining source pages are copied. ÙE** ^If sqlite3_backup_step(B,N) successfully copies N pages and thereÙL** are still more pages to be copied, then the function returns [SQLITE_OK].ÙG** ^If sqlite3_backup_step(B,N) successfully finishes copying all pagesÙ=** from source to destination, then it returns [SQLITE_DONE].Ù>** ^If an error occurs while running sqlite3_backup_step(B,N),Ù@** then an [error code] is returned. ^As well as [SQLITE_OK] andÙO** [SQLITE_DONE], a call to sqlite3_backup_step() may return [SQLITE_READONLY],Ù8** [SQLITE_NOMEM], [SQLITE_BUSY], [SQLITE_LOCKED], or anÙ@** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.¢**Ù@** ^(The sqlite3_backup_step() might return [SQLITE_READONLY] if§** <ol>Ù9** <li> the destination database was opened read-only, orÙD** <li> the destination database is using write-ahead-log journalingÙ7** and the destination and source page sizes differ, orÙA** <li> the destination database is an in-memory database and theÙ,** destination and source page sizes differ.ª** </ol>)^¢**ÙL** ^If sqlite3_backup_step() cannot obtain a required file-system lock, thenÙ5** the [sqlite3_busy_handler | busy-handler function]Ù-** is invoked (if one is specified). ^If the ÙD** busy-handler returns non-zero before the lock is available, then ÙE** [SQLITE_BUSY] is returned to the caller. ^In this case the call toÙ=** sqlite3_backup_step() can be retried later. ^If the source¸** [database connection]ÙK** is being used to write to the source database when sqlite3_backup_step()ÙK** is called, then [SQLITE_LOCKED] is returned immediately. ^Again, in thisÙG** case the call to sqlite3_backup_step() can be retried later on. ^(IfÙ?** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], orÙ'** [SQLITE_READONLY] is returned, then ÙJ** there is no point in retrying the call to sqlite3_backup_step(). These Ù?** errors are considered fatal.)^  The application must accept ÙM** that the backup operation has failed and pass the backup operation handle ÙB** to the sqlite3_backup_finish() to release associated resources.¢**ÙE** ^The first call to sqlite3_backup_step() obtains an exclusive lockÙM** on the destination file. ^The exclusive lock is not released until either ÙI** sqlite3_backup_finish() is called or the backup operation is complete ÙC** and sqlite3_backup_step() returns [SQLITE_DONE].  ^Every call toÙL** sqlite3_backup_step() obtains a [shared lock] on the source database thatÙ<** lasts for the duration of the sqlite3_backup_step() call.Ù>** ^Because the source database is not locked between calls toÙE** sqlite3_backup_step(), the source database may be modified mid-wayÙI** through the backup process.  ^If the source database is modified by anÙI** external process or via a database connection other than the one beingÙF** used by the backup operation, then the backup will be automaticallyÙG** restarted by the next call to sqlite3_backup_step(). ^If the source ÙL** database is modified by the using the same database connection as is usedÙE** by the backup operation, then the backup database is automatically¼** updated at the same time.¢**Ù=** [[sqlite3_backup_finish()]] <b>sqlite3_backup_finish()</b>¢**ÙF** When sqlite3_backup_step() has returned [SQLITE_DONE], or when the ÙF** application wishes to abandon the backup operation, the applicationÙP** should destroy the [sqlite3_backup] by passing it to sqlite3_backup_finish().Ù7** ^The sqlite3_backup_finish() interfaces releases allÙ:** resources associated with the [sqlite3_backup] object. ÙI** ^If sqlite3_backup_step() has not yet returned [SQLITE_DONE], then anyÙG** active write-transaction on the destination database is rolled back.Ù)** The [sqlite3_backup] object is invalidÙC** and may not be used following a call to sqlite3_backup_finish().¢**ÙD** ^The value returned by sqlite3_backup_finish is [SQLITE_OK] if noÙF** sqlite3_backup_step() errors occurred, regardless or whether or notÙ#** sqlite3_backup_step() completed.ÙG** ^If an out-of-memory condition or IO error occurred during any priorÙG** sqlite3_backup_step() call on the same [sqlite3_backup] object, thenÙB** sqlite3_backup_finish() returns the corresponding [error code].¢**ÙK** ^A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step()ÙC** is not a permanent error and does not affect the return value of»** sqlite3_backup_finish().¢**Ù@** [[sqlite3_backup_remaining()]] [[sqlite3_backup_pagecount()]]ÙC** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>¢**ÙL** ^The sqlite3_backup_remaining() routine returns the number of pages stillÙN** to be backed up at the conclusion of the most recent sqlite3_backup_step().ÙL** ^The sqlite3_backup_pagecount() routine returns the total number of pagesÙ>** in the source database at the conclusion of the most recent¹** sqlite3_backup_step().Ù?** ^(The values returned by these functions are only updated byÙJ** sqlite3_backup_step(). If the source database is modified in a way thatÙL** changes the size of the source database or the number of pages remaining,ÙN** those changes are not reflected in the output of sqlite3_backup_pagecount()Ù6** and sqlite3_backup_remaining() until after the next»** sqlite3_backup_step().)^¢**Ù.** <b>Concurrent Usage of Database Handles</b>¢**ÙM** ^The source [database connection] may be used by the application for otherÙF** purposes while a backup operation is underway or being initialized.ÙG** ^If SQLite is compiled and configured to support threadsafe databaseÙL** connections, then the source database connection may be used concurrently½** from within other threads.¢**Ù@** However, the application must guarantee that the destination ÙN** [database connection] is not passed to any other API (by any thread) after ÙG** sqlite3_backup_init() is called and before the corresponding call toÙC** sqlite3_backup_finish().  SQLite does not currently check to seeÙP** if the application incorrectly accesses the destination [database connection]ÙG** and so no error code is reported, but the operations may malfunctionÙD** nevertheless.  Use of the destination database connection while aÙ@** backup is in progress might also also cause a mutex deadlock.¢**Ù:** If running in [shared cache mode], the application mustÙC** guarantee that the shared cache used by the destination databaseÙF** is not accessed while the backup is running. In practice this meansÙ@** that the application must guarantee that the disk file being ÙE** backed up to is not accessed by any connection within the process,ÙM** not just the specific connection that was passed to sqlite3_backup_init().¢**ÙH** The [sqlite3_backup] object itself is partially threadsafe. Multiple ÙN** threads may safely make multiple concurrent calls to sqlite3_backup_step().ÙI** However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount()ÙH** APIs are not strictly speaking threadsafe. If they are invoked at theÙF** same time as another thread is invoking sqlite3_backup_step() it isÙ,** possible that they return invalid values.¢*/Ù/SQLITE_API sqlite3_backup *sqlite3_backup_init(ÙJ  sqlite3 *pDest,                        /* Destination database handle */ÙH  const char *zDestName,                 /* Destination database name */ÙE  sqlite3 *pSource,                      /* Source database handle */ÙC  const char *zSourceName                /* Source database name */¢);ÙASQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);Ù8SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);Ù;SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);Ù;SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p); ¢/*Ù ** CAPI3REF: Unlock Notification²** METHOD: sqlite3¢**ÙI** ^When running in shared-cache mode, a database operation may fail withÙH** an [SQLITE_LOCKED] error if the required locks on the shared-cache orÙD** individual tables within the shared-cache cannot be obtained. SeeÙI** [SQLite Shared-Cache Mode] for a description of shared-cache locking. ÙH** ^This API may be used to register a callback that SQLite will invoke ÙK** when the connection currently holding the required lock relinquishes it.ÙC** ^This API is only available if the library was compiled with theÙ?** [SQLITE_ENABLE_UNLOCK_NOTIFY] C-preprocessor symbol defined.¢**Ù<** See Also: [Using the SQLite Unlock Notification Feature].¢**ÙH** ^Shared-cache locks are released when a database connection concludesÙH** its current transaction, either by committing it or rolling it back. ¢**ÙI** ^When a connection (known as the blocked connection) fails to obtain aÙE** shared-cache lock and SQLITE_LOCKED is returned to the caller, theÙE** identity of the database connection (the blocking connection) thatÙD** has locked the required resource is stored internally. ^After an Ù?** application receives an SQLITE_LOCKED error, it may call theÙH** sqlite3_unlock_notify() method with the blocked connection handle as ÙE** the first argument to register for a callback that will be invokedÙG** when the blocking connections current transaction is concluded. ^TheÙH** callback is invoked from within the [sqlite3_step] or [sqlite3_close]Ù<** call that concludes the blocking connections transaction.¢**ÙJ** ^(If sqlite3_unlock_notify() is called in a multi-threaded application,ÙC** there is a chance that the blocking connection will have alreadyÙL** concluded its transaction by the time sqlite3_unlock_notify() is invoked.ÙG** If this happens, then the specified callback is invoked immediately,Ù5** from within the call to sqlite3_unlock_notify().)^¢**ÙG** ^If the blocked connection is attempting to obtain a write-lock on aÙI** shared-cache table, and more than one other connection currently holdsÙI** a read-lock on the same table, then SQLite arbitrarily selects one of Ù;** the other connections to use as the blocking connection.¢**ÙE** ^(There may be at most one unlock-notify callback registered by a ÙD** blocked connection. If sqlite3_unlock_notify() is called when theÙF** blocked connection already has a registered unlock-notify callback,ÙK** then the new callback replaces the old.)^ ^If sqlite3_unlock_notify() isÙG** called with a NULL pointer as its second argument, then any existingÙ@** unlock-notify callback is canceled. ^The blocked connections ÙE** unlock-notify callback may also be canceled by closing the blockedÙ&** connection using [sqlite3_close()].¢**ÙI** The unlock-notify callback is not reentrant. If an application invokesÙI** any sqlite3_xxx API functions from within an unlock-notify callback, aÙ'** crash or deadlock may be the result.¢**ÙK** ^Unless deadlock is detected (see below), sqlite3_unlock_notify() alwaysµ** returns SQLITE_OK.¢**Ù%** <b>Callback Invocation Details</b>¢**ÙL** When an unlock-notify callback is registered, the application provides a ÙJ** single void* pointer that is passed to the callback when it is invoked.ÙH** However, the signature of the callback function allows SQLite to passÙF** it an array of void* context pointers. The first argument passed toÙH** an unlock-notify callback is a pointer to an array of void* pointers,Ù8** and the second is the number of entries in the array.¢**ÙE** When a blocking connections transaction is concluded, there may beÙL** more than one blocked connection that has registered for an unlock-notifyÙH** callback. ^If two or more such blocked connections have specified theÙI** same callback function, then instead of invoking the callback functionÙL** multiple times, it is invoked once with the set of void* context pointersÙG** specified by the blocked connections bundled together into an array.ÙG** This gives the application an opportunity to prioritize any actions Ù8** related to the set of unblocked database connections.¢**¼** <b>Deadlock Detection</b>¢**ÙC** Assuming that after registering for an unlock-notify callback a ÙI** database waits for the callback to be issued before taking any furtherÙF** action (a reasonable assumption), then using this API may cause theÙG** application to deadlock. For example, if connection X is waiting forÙG** connection Y's transaction to be concluded, and similarly connectionÙF** Y is waiting on connection X's transaction, then neither connectionÙB** will proceed and the system may remain deadlocked indefinitely.¢**ÙH** To avoid this scenario, the sqlite3_unlock_notify() performs deadlockÙG** detection. ^If a given call to sqlite3_unlock_notify() would put theÙF** system in a deadlocked state, then SQLITE_LOCKED is returned and noÙD** unlock-notify callback is registered. The system is said to be inÙI** a deadlocked state if connection A has registered for an unlock-notifyÙK** callback on the conclusion of connection B's transaction, and connectionÙH** B has itself registered for an unlock-notify callback when connectionÙH** A's transaction is concluded. ^Indirect deadlock is also detected, soÙE** the system is also considered to be deadlocked if connection B hasÙK** registered for an unlock-notify callback on the conclusion of connectionÙG** C's transaction, where connection C is waiting on connection A. ^AnyÙ/** number of levels of indirection are allowed.¢**Ù$** <b>The "DROP TABLE" Exception</b>¢**ÙG** When a call to [sqlite3_step()] returns SQLITE_LOCKED, it is almost ÙH** always appropriate to call sqlite3_unlock_notify(). There is however,ÙJ** one exception. When executing a "DROP TABLE" or "DROP INDEX" statement,ÙG** SQLite checks if there are any currently executing SELECT statementsÙE** that belong to the same connection. If there are, SQLITE_LOCKED isÙH** returned. In this case there is no "blocking connection", so invokingÙF** sqlite3_unlock_notify() results in the unlock-notify callback beingÙL** invoked immediately. If the application then re-attempts the "DROP TABLE"Ù?** or "DROP INDEX" query, an infinite loop might be the result.¢**ÙK** One way around this problem is to check the extended error code returnedÙK** by an sqlite3_step() call. ^(If there is a blocking connection, then theÙI** extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, inÙH** the special "DROP TABLE/INDEX" case, the extended error code is just ³** SQLITE_LOCKED.)^¢*/Ù%SQLITE_API int sqlite3_unlock_notify(ÙF  sqlite3 *pBlocked,                          /* Waiting connection */ÙO  void (*xNotify)(void **apArg, int nArg),    /* Callback function to invoke */ÙO  void *pNotifyArg                            /* Argument to pass to xNotify */¢);  ¢/*¾** CAPI3REF: String Comparison¢**ÙL** ^The [sqlite3_stricmp()] and [sqlite3_strnicmp()] APIs allow applicationsÙI** and extensions to compare the contents of two buffers containing UTF-8ÙL** strings in a case-independent fashion, using the same definition of "caseÙH** independence" that SQLite uses internally when comparing identifiers.¢*/Ù;SQLITE_API int sqlite3_stricmp(const char *, const char *);ÙASQLITE_API int sqlite3_strnicmp(const char *, const char *, int); ¢/*¼** CAPI3REF: String Globbing¡*ÙD** ^The [sqlite3_strglob(P,X)] interface returns zero if and only ifÙ)** string X matches the [GLOB] pattern P.Ù5** ^The definition of [GLOB] pattern matching used inÙK** [sqlite3_strglob(P,X)] is the same as for the "X GLOB P" operator in theÙJ** SQL dialect understood by SQLite.  ^The [sqlite3_strglob(P,X)] functionµ** is case sensitive.¢**ÙM** Note that this routine returns zero on a match and non-zero if the stringsÙJ** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].¢**Ù!** See also: [sqlite3_strlike()].¢*/ÙDSQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr); ¢/*Ù!** CAPI3REF: String LIKE Matching¡*ÙF** ^The [sqlite3_strlike(P,X,E)] interface returns zero if and only ifÙA** string X matches the [LIKE] pattern P with escape character E.Ù5** ^The definition of [LIKE] pattern matching used inÙF** [sqlite3_strlike(P,X,E)] is the same as for the "X LIKE P ESCAPE E"ÙM** operator in the SQL dialect understood by SQLite.  ^For "X LIKE P" withoutÙK** the ESCAPE clause, set the E parameter of [sqlite3_strlike(P,X,E)] to 0.ÙL** ^As with the LIKE operator, the [sqlite3_strlike(P,X,E)] function is caseÙG** insensitive - equivalent upper and lower case ASCII characters match¯** one another.¢**ÙL** ^The [sqlite3_strlike(P,X,E)] function matches Unicode characters, thoughÙ)** only ASCII characters are case folded.¢**ÙM** Note that this routine returns zero on a match and non-zero if the stringsÙJ** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].¢**Ù!** See also: [sqlite3_strglob()].¢*/ÙWSQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc); ¢/*Ù$** CAPI3REF: Error Logging Interface¢**ÙG** ^The [sqlite3_log()] interface writes a message into the [error log]ÙG** established by the [SQLITE_CONFIG_LOG] option to [sqlite3_config()].ÙJ** ^If logging is enabled, the zFormat string and subsequent arguments areÙF** used with [sqlite3_snprintf()] to generate the final output string.¢**ÙH** The sqlite3_log() interface is intended for use by extensions such asÙJ** virtual tables, collating functions, and SQL functions.  While there isÙI** nothing to prevent an application from calling sqlite3_log(), doing soº** is considered bad form.¢**Ù'** The zFormat string must not be NULL.¢**ÙM** To avoid deadlocks and other threading problems, the sqlite3_log() routineÙK** will not use dynamically allocated memory.  The log message is stored inÙI** a fixed-length buffer on the stack.  If the log message is longer thanÙF** a few hundred characters, it will be truncated to the length of theª** buffer.¢*/ÙDSQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...); ¢/*Ù(** CAPI3REF: Write-Ahead Log Commit Hook²** METHOD: sqlite3¢**ÙI** ^The [sqlite3_wal_hook()] function is used to register a callback thatÙD** is invoked each time data is committed to a database in wal mode.¢**ÙL** ^(The callback is invoked by SQLite after the commit has taken place and ÙO** the associated write-lock on the database released)^, so the implementation Ù<** may read, write or [checkpoint] the database as required.¢**ÙJ** ^The first parameter passed to the callback function when it is invokedÙE** is a copy of the third parameter passed to sqlite3_wal_hook() whenÙJ** registering the callback. ^The second is a copy of the database handle.ÙI** ^The third parameter is the name of the database that was written to -ÙN** either "main" or the name of an [ATTACH]-ed database. ^The fourth parameterÙ@** is the number of pages currently in the write-ahead log file,Ù,** including those that were just committed.¢**ÙJ** The callback function should normally return [SQLITE_OK].  ^If an errorÙB** code is returned, that error will propagate back up through theÙE** SQLite code base to cause the statement that provoked the callbackÙI** to report an error, though the commit will have still occurred. If theÙK** callback returns [SQLITE_ROW] or [SQLITE_DONE], or if it returns a valueÙG** that does not correspond to any valid SQLite error code, the results±** are undefined.¢**ÙO** A single database handle may have at most a single write-ahead log callback ÙE** registered at one time. ^Calling [sqlite3_wal_hook()] replaces anyÙA** previously registered write-ahead log callback. ^Note that theÙ3** [sqlite3_wal_autocheckpoint()] interface and theÙH** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and willÙ5** overwrite any prior [sqlite3_wal_hook()] settings.¢*/Ù"SQLITE_API void *sqlite3_wal_hook(¬  sqlite3*, Ù*  int(*)(void *,sqlite3*,const char*,int),§  void*¢); ¢/*Ù)** CAPI3REF: Configure an auto-checkpoint²** METHOD: sqlite3¢**Ù=** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper aroundÙK** [sqlite3_wal_hook()] that causes any database on [database connection] DÙ ** to automatically [checkpoint]Ù3** after committing a transaction if there are N orÙ@** more frames in the [write-ahead log] file.  ^Passing zero or Ù>** a negative value as the nFrame parameter disables automatic¸** checkpoints entirely.¢**ÙK** ^The callback registered by this function replaces any existing callbackÙL** registered using [sqlite3_wal_hook()].  ^Likewise, registering a callbackÙI** using [sqlite3_wal_hook()] disables the automatic checkpoint mechanism¿** configured by this function.¢**ÙH** ^The [wal_autocheckpoint pragma] can be used to invoke this interface¬** from SQL.¢**Ù/** ^Checkpoints initiated by this mechanism areÙ'** [sqlite3_wal_checkpoint_v2|PASSIVE].¢**ÙJ** ^Every new [database connection] defaults to having the auto-checkpointÙJ** enabled with a threshold of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT]Ù$** pages.  The use of this interfaceÙE** is only necessary if the default setting is found to be suboptimalÙ ** for a particular application.¢*/Ù>SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N); ¢/*Ù"** CAPI3REF: Checkpoint a database²** METHOD: sqlite3¢**Ù5** ^(The sqlite3_wal_checkpoint(D,X) is equivalent toÙF** [sqlite3_wal_checkpoint_v2](D,X,[SQLITE_CHECKPOINT_PASSIVE],0,0).)^¢**ÙC** In brief, sqlite3_wal_checkpoint(D,X) causes the content in the ÙD** [write-ahead log] for database X on [database connection] D to beÙD** transferred into the database file and for the write-ahead log toÙ@** be reset.  See the [checkpointing] documentation for addition¯** information.¢**ÙB** This interface used to be the only way to cause a checkpoint toÙM** occur.  But then the newer and more powerful [sqlite3_wal_checkpoint_v2()]ÙA** interface was added.  This interface is retained for backwardsÙL** compatibility and as a convenience for applications that need to manuallyÙK** start a callback but which do not need the full power (and correspondingÙ2** complication) of [sqlite3_wal_checkpoint_v2()].¢*/ÙDSQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb); ¢/*Ù"** CAPI3REF: Checkpoint a database²** METHOD: sqlite3¢**ÙI** ^(The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpointÙH** operation on database X of [database connection] D in mode M.  StatusÙE** information is written back into integers pointed to by L and C.)^Ù9** ^(The M parameter must be a valid [checkpoint mode]:)^¢**§** <dl>Ù$** <dt>SQLITE_CHECKPOINT_PASSIVE<dd>ÙM**   ^Checkpoint as many frames as possible without waiting for any database ÙM**   readers or writers to finish, then sync the database file if all frames Ù?**   in the log were checkpointed. ^The [busy-handler callback]Ù>**   is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode.  ÙK**   ^On the other hand, passive mode might leave the checkpoint unfinishedÙ0**   if there are concurrent readers or writers.¢**Ù!** <dt>SQLITE_CHECKPOINT_FULL<dd>Ù&**   ^This mode blocks (it invokes theÙD**   [sqlite3_busy_handler|busy-handler callback]) until there is noÙN**   database writer and all readers are reading from the most recent databaseÙL**   snapshot. ^It then checkpoints all frames in the log file and syncs theÙO**   database file. ^This mode blocks new database writers while it is pending,Ù@**   but new database readers are allowed to continue unimpeded.¢**Ù$** <dt>SQLITE_CHECKPOINT_RESTART<dd>ÙN**   ^This mode works the same way as SQLITE_CHECKPOINT_FULL with the additionÙ@**   that after checkpointing the log file it blocks (calls the ½**   [busy-handler callback])ÙN**   until all readers are reading from the database file only. ^This ensures ÙG**   that the next writer will restart the log file from the beginning.Ù7**   ^Like SQLITE_CHECKPOINT_FULL, this mode blocks newÙO**   database writer attempts while it is pending, but does not impede readers.¢**Ù%** <dt>SQLITE_CHECKPOINT_TRUNCATE<dd>ÙH**   ^This mode works the same way as SQLITE_CHECKPOINT_RESTART with theÙJ**   addition that it also truncates the log file to zero bytes just prior¼**   to a successful return.¨** </dl>¢**ÙM** ^If pnLog is not NULL, then *pnLog is set to the total number of frames inÙ@** the log file or to -1 if the checkpoint could not run becauseÙN** of an error or because the database is not in [WAL mode]. ^If pnCkpt is notÙM** NULL,then *pnCkpt is set to the total number of checkpointed frames in theÙM** log file (including any that were already checkpointed before the functionÙJ** was called) or to -1 if the checkpoint could not run due to an error orÙF** because the database is not in WAL mode. ^Note that upon successfulÙK** completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have beenÙN** truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.¢**ÙM** ^All calls obtain an exclusive "checkpoint" lock on the database file. ^IfÙM** any other process is running a checkpoint operation at the same time, the ÙL** lock cannot be obtained and SQLITE_BUSY is returned. ^Even if there is a Ù@** busy-handler configured, it will not be invoked in this case.¢**ÙK** ^The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the ÙN** exclusive "writer" lock on the database file. ^If the writer lock cannot beÙL** obtained immediately, and a busy-handler is configured, it is invoked andÙN** the writer lock retried until either the busy-handler returns 0 or the lockÙP** is successfully obtained. ^The busy-handler is also invoked while waiting forÙM** database readers as described above. ^If the busy-handler returns 0 beforeÙI** the writer lock is obtained or while waiting for database readers, theÙD** checkpoint operation proceeds from that point in the same way as ÙH** SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible ÙG** without blocking any further. ^SQLITE_BUSY is returned in this case.¢**ÙH** ^If parameter zDb is NULL or points to a zero length string, then theÙG** specified operation is attempted on all WAL databases [attached] to Ù.** [database connection] db.  In this case theÙM** values written to output parameters *pnLog and *pnCkpt are undefined. ^If ÙJ** an SQLITE_BUSY error is encountered when processing one or more of the ÙM** attached WAL databases, the operation is still attempted on any remaining ÙL** attached databases and SQLITE_BUSY is returned at the end. ^If any other ÙO** error occurs while processing an attached database, processing is abandoned ÙJ** and the error code is returned to the caller immediately. ^If no error ÙK** (SQLITE_BUSY or otherwise) is encountered while processing the attached Ù$** databases, SQLITE_OK is returned.¢**ÙJ** ^If database zDb is the name of an attached database that is not in WALÙI** mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. ^IfÙG** zDb is not NULL (or a zero length string) and is not the name of anyÙ=** attached database, SQLITE_ERROR is returned to the caller.¢**Ù$** ^Unless it returns SQLITE_MISUSE,Ù,** the sqlite3_wal_checkpoint_v2() interfaceÙ0** sets the error information that is queried byÙ.** [sqlite3_errcode()] and [sqlite3_errmsg()].¢**ÙL** ^The [PRAGMA wal_checkpoint] command can be used to invoke this interface¬** from SQL.¢*/Ù)SQLITE_API int sqlite3_wal_checkpoint_v2(Ù7  sqlite3 *db,                    /* Database handle */ÙK  const char *zDb,                /* Name of attached database (or NULL) */ÙA  int eMode,                      /* SQLITE_CHECKPOINT_* value */ÙF  int *pnLog,                     /* OUT: Size of WAL log in frames */ÙP  int *pnCkpt                     /* OUT: Total number of frames checkpointed */¢); ¢/*Ù#** CAPI3REF: Checkpoint Mode Values¾** KEYWORDS: {checkpoint mode}¢**ÙK** These constants define all valid values for the "checkpoint mode" passedÙI** as the third parameter to the [sqlite3_wal_checkpoint_v2()] interface.ÙI** See the [sqlite3_wal_checkpoint_v2()] documentation for details on theÙ-** meaning of each of these checkpoint modes.¢*/ÙO#define SQLITE_CHECKPOINT_PASSIVE  0  /* Do as much as possible w/o blocking */ÙM#define SQLITE_CHECKPOINT_FULL     1  /* Wait for writers, then checkpoint */ÙN#define SQLITE_CHECKPOINT_RESTART  2  /* Like FULL but wait for for readers */ÙN#define SQLITE_CHECKPOINT_TRUNCATE 3  /* Like RESTART but also truncate WAL */ ¢/*Ù2** CAPI3REF: Virtual Table Interface Configuration¢**ÙK** This function may be called by either the [xConnect] or [xCreate] methodÙ3** of a [virtual table] implementation to configureÙ1** various facets of the virtual table interface.¢**ÙE** If this interface is invoked outside the context of an xConnect orÙ?** xCreate virtual table method then the behavior is undefined.¢**ÙD** At present, there is only one option that may be configured usingÙJ** this function. (See [SQLITE_VTAB_CONSTRAINT_SUPPORT].)  Further options¾** may be added in the future.¢*/Ù:SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...); ¢/*Ù0** CAPI3REF: Virtual Table Configuration Options¢**Ù1** These macros define the various options to theÙI** [sqlite3_vtab_config()] interface that [virtual table] implementationsÙ4** can use to customize and optimize their behavior.¢**§** <dl>Ù%** <dt>SQLITE_VTAB_CONSTRAINT_SUPPORT¸** <dd>Calls of the formÙL** [sqlite3_vtab_config](db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported,ÙG** where X is an integer.  If X is zero, then the [virtual table] whoseÙJ** [xCreate] or [xConnect] method invoked [sqlite3_vtab_config()] does notÙH** support constraints.  In this configuration (which is the default) ifÙN** a call to the [xUpdate] method returns [SQLITE_CONSTRAINT], then the entireÙC** statement is rolled back as if [ON CONFLICT | OR ABORT] had beenÙI** specified as part of the users SQL statement, regardless of the actual¾** ON CONFLICT mode specified.¢**ÙE** If X is non-zero, then the virtual table implementation guaranteesÙF** that if [xUpdate] returns [SQLITE_CONSTRAINT], it will do so beforeÙN** any modifications to internal or persistent data structures have been made.ÙH** If the [ON CONFLICT] mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite ÙH** is able to roll back a statement or database transaction, and abandonÙD** or continue processing the current SQL statement as appropriate. ÙF** If the ON CONFLICT mode is REPLACE and the [xUpdate] method returnsÙF** [SQLITE_CONSTRAINT], SQLite handles this as if the ON CONFLICT mode²** had been ABORT.¢**ÙG** Virtual table implementations that are required to handle OR REPLACEÙ<** must do so within the [xUpdate] method. If a call to the ÙG** [sqlite3_vtab_on_conflict()] function indicates that the current ON ÙG** CONFLICT policy is REPLACE, the virtual table implementation should ÙH** silently replace the appropriate rows within the xUpdate callback andÙ?** return SQLITE_OK. Or, if this is not possible, it may returnÙB** SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT ·** constraint handling.¨** </dl>¢*/Ù(#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1 ¢/*Ù8** CAPI3REF: Determine The Virtual Table Conflict Policy¢**ÙN** This function may only be called from within a call to the [xUpdate] methodÙN** of a [virtual table] implementation for an INSERT or UPDATE operation. ^TheÙN** value returned is one of [SQLITE_ROLLBACK], [SQLITE_IGNORE], [SQLITE_FAIL],ÙK** [SQLITE_ABORT], or [SQLITE_REPLACE], according to the [ON CONFLICT] modeÙN** of the SQL statement that triggered the call to the [xUpdate] method of the³** [virtual table].¢*/Ù3SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *); ¢/*ÙC** CAPI3REF: Determine If Virtual Table Column Access Is For UPDATE¢**ÙI** If the sqlite3_vtab_nochange(X) routine is called within the [xColumn]ÙG** method of a [virtual table], then it returns true if and only if theÙJ** column is being fetched as part of an UPDATE operation during which theÙK** column value will not change.  Applications might use this to substituteÙK** a lighter-weight value to return that the corresponding [xUpdate] methodÙ&** understands as a "no-change" value.¢**ÙG** If the [xColumn] method calls sqlite3_vtab_nochange() and finds thatÙF** the column is not changed by the UPDATE statement, they the xColumnÙI** method can optionally return without setting a result, without callingÙE** any of the [sqlite3_result_int|sqlite3_result_xxxxx() interfaces].ÙE** In that case, [sqlite3_value_nochange(X)] will return true for theÙ'** same column in the [xUpdate] method.¢*/Ù7SQLITE_API int sqlite3_vtab_nochange(sqlite3_context*); ¢/*ÙC** CAPI3REF: Determine The Collation For a Virtual Table Constraint¢**ÙJ** This function may only be called from within a call to the [xBestIndex]Ù ** method of a [virtual table]. ¢**ÙG** The first argument must be the sqlite3_index_info object that is theÙJ** first parameter to the xBestIndex() method. The second argument must beÙL** an index into the aConstraint[] array belonging to the sqlite3_index_infoÙO** structure passed to xBestIndex. This function returns a pointer to a buffer ÙF** containing the name of the collation sequence for the corresponding®** constraint.¢*/Ù[SQLITE_API SQLITE_EXPERIMENTAL const char *sqlite3_vtab_collation(sqlite3_index_info*,int); ¢/*Ù&** CAPI3REF: Conflict resolution modesÙ'** KEYWORDS: {conflict resolution mode}¢**ÙB** These constants are returned by [sqlite3_vtab_on_conflict()] toÙF** inform a [virtual table] implementation what the [ON CONFLICT] modeÙ,** is for the SQL statement being evaluated.¢**ÙE** Note that the [SQLITE_IGNORE] constant is also used as a potentialÙE** return value from the [sqlite3_set_authorizer()] callback and thatÙ*** [SQLITE_ABORT] is also a [result code].¢*/¹#define SQLITE_ROLLBACK 1ÙK/* #define SQLITE_IGNORE 2 // Also used by sqlite3_authorizer() callback */¹#define SQLITE_FAIL     3Ù3/* #define SQLITE_ABORT 4  // Also an error code */¹#define SQLITE_REPLACE  5 ¢/*Ù3** CAPI3REF: Prepared Statement Scan Status OpcodesÙ!** KEYWORDS: {scanstatus options}¢**ÙA** The following constants can be used for the T parameter to theÙL** [sqlite3_stmt_scanstatus(S,X,T,V)] interface.  Each constant designates aÙ<** different metric for sqlite3_stmt_scanstatus() to return.¢**ÙI** When the value returned to V is a string, space to hold that string isÙK** managed by the prepared statement S and will be automatically freed when²** S is finalized.¢**§** <dl>Ù;** [[SQLITE_SCANSTAT_NLOOP]] <dt>SQLITE_SCANSTAT_NLOOP</dt>ÙJ** <dd>^The [sqlite3_int64] variable pointed to by the T parameter will beÙD** set to the total number of times that the X-th loop has run.</dd>¢**Ù=** [[SQLITE_SCANSTAT_NVISIT]] <dt>SQLITE_SCANSTAT_NVISIT</dt>ÙN** <dd>^The [sqlite3_int64] variable pointed to by the T parameter will be setÙP** to the total number of rows examined by all iterations of the X-th loop.</dd>¢**Ù7** [[SQLITE_SCANSTAT_EST]] <dt>SQLITE_SCANSTAT_EST</dt>ÙN** <dd>^The "double" variable pointed to by the T parameter will be set to theÙK** query planner's estimate for the average number of rows output from eachÙN** iteration of the X-th loop.  If the query planner's estimates was accurate,ÙE** then this value will approximate the quotient NVISIT/NLOOP and theÙH** product of this value for all prior loops with the same SELECTID willÙ+** be the NLOOP value for the current loop.¢**Ù9** [[SQLITE_SCANSTAT_NAME]] <dt>SQLITE_SCANSTAT_NAME</dt>ÙM** <dd>^The "const char *" variable pointed to by the T parameter will be setÙN** to a zero-terminated UTF-8 string containing the name of the index or tableº** used for the X-th loop.¢**Ù?** [[SQLITE_SCANSTAT_EXPLAIN]] <dt>SQLITE_SCANSTAT_EXPLAIN</dt>ÙM** <dd>^The "const char *" variable pointed to by the T parameter will be setÙH** to a zero-terminated UTF-8 string containing the [EXPLAIN QUERY PLAN]Ù!** description for the X-th loop.¢**Ù?** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECT</dt>ÙK** <dd>^The "int" variable pointed to by the T parameter will be set to theÙJ** "select-id" for the X-th loop.  The select-id identifies which query orÙI** subquery the loop is part of.  The main query has a select-id of zero.ÙC** The select-id is the same value as is output in the first columnÙ$** of an [EXPLAIN QUERY PLAN] query.¨** </dl>¢*/Ù"#define SQLITE_SCANSTAT_NLOOP    0Ù"#define SQLITE_SCANSTAT_NVISIT   1Ù"#define SQLITE_SCANSTAT_EST      2Ù"#define SQLITE_SCANSTAT_NAME     3Ù"#define SQLITE_SCANSTAT_EXPLAIN  4Ù"#define SQLITE_SCANSTAT_SELECTID 5 ¢/*Ù+** CAPI3REF: Prepared Statement Scan Status·** METHOD: sqlite3_stmt¢**ÙF** This interface returns information about the predicted and measuredÙ=** performance for pStmt.  Advanced applications can use thisÙF** interface to compare the predicted and the measured performance andÙD** issue warnings and/or rerun [ANALYZE] if discrepancies are found.¢**ÙA** Since this interface is expected to be rarely used, it is onlyÙL** available if SQLite is compiled using the [SQLITE_ENABLE_STMT_SCANSTATUS]·** compile-time option.¢**ÙO** The "iScanStatusOp" parameter determines which status information to return.ÙN** The "iScanStatusOp" must be one of the [scanstatus options] or the behaviorÙ"** of this interface is undefined.ÙF** ^The requested measurement is written into a variable pointed to by¸** the "pOut" parameter.ÙK** Parameter "idx" identifies the specific loop to retrieve statistics for.ÙM** Loops are numbered starting from zero. ^If idx is out of range - less thanÙO** zero or greater than or equal to the total number of loops used to implementÙJ** the statement - a non-zero value is returned and the variable that pOutº** points to is unchanged.¢**ÙP** ^Statistics might not be available for all loops in all statements. ^In casesÙN** where there exist loops with no available statistics, this function behavesÙL** as if the loop did not exist - it returns non-zero and leave the variableÙ!** that pOut points to unchanged.¢**Ù.** See also: [sqlite3_stmt_scanstatus_reset()]¢*/Ù'SQLITE_API int sqlite3_stmt_scanstatus(ÙK  sqlite3_stmt *pStmt,      /* Prepared statement for which info desired */Ù<  int idx,                  /* Index of loop to report on */ÙI  int iScanStatusOp,        /* Information desired.  SQLITE_SCANSTAT_* */Ù5  void *pOut                /* Result written here */§);      ¢/*Ù&** CAPI3REF: Zero Scan-Status Counters·** METHOD: sqlite3_stmt¢**Ù@** ^Zero all [sqlite3_stmt_scanstatus()] related event counters.¢**ÙH** This API is only available if the library is built with pre-processorÙ2** symbol [SQLITE_ENABLE_STMT_SCANSTATUS] defined.¢*/Ù=SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*); ¢/*Ù1** CAPI3REF: Flush caches to disk mid-transaction¢**ÙF** ^If a write-transaction is open on [database connection] D when theÙ:** [sqlite3_db_cacheflush(D)] interface invoked, any dirtyÙJ** pages in the pager-cache that are not currently in use are written out ÙI** to disk. A dirty page may be in use if a database cursor created by anÙL** active SQL statement is reading from it, or if it is page 1 of a databaseÙE** file (page 1 is always "in use").  ^The [sqlite3_db_cacheflush(D)]ÙA** interface flushes caches for all schemas - "main", "temp", and¼** any [attached] databases.¢**ÙM** ^If this function needs to obtain extra database locks before dirty pages ÙJ** can be flushed to disk, it does so. ^If those locks cannot be obtained ÙM** immediately and there is a busy-handler callback configured, it is invokedÙL** in the usual manner. ^If the required lock still cannot be obtained, thenÙG** the database is skipped and an attempt made to flush any dirty pagesÙI** belonging to the next (if any) database. ^If any databases are skippedÙD** because locks cannot be obtained, but no other error occurs, thisÙ ** function returns SQLITE_BUSY.¢**ÙE** ^If any other error occurs while flushing dirty pages to disk (forÙF** example an IO error or out-of-memory condition), then processing isÙN** abandoned and an SQLite [error code] is returned to the caller immediately.¢**ÙO** ^Otherwise, if no error occurs, [sqlite3_db_cacheflush()] returns SQLITE_OK.¢**ÙH** ^This function does not set the database handle error code or messageÙH** returned by the [sqlite3_errcode()] and [sqlite3_errmsg()] functions.¢*/Ù/SQLITE_API int sqlite3_db_cacheflush(sqlite3*); ¢/*Ù!** CAPI3REF: The pre-update hook.¢**ÙG** ^These interfaces are only available if SQLite is compiled using theÙ6** [SQLITE_ENABLE_PREUPDATE_HOOK] compile-time option.¢**ÙJ** ^The [sqlite3_preupdate_hook()] interface registers a callback functionÙK** that is invoked prior to each [INSERT], [UPDATE], and [DELETE] operation·** on a database table.ÙF** ^At most one preupdate hook may be registered at a time on a singleÙK** [database connection]; each call to [sqlite3_preupdate_hook()] overrides¸** the previous setting.ÙI** ^The preupdate hook is disabled by invoking [sqlite3_preupdate_hook()]Ù/** with a NULL pointer as the second parameter.ÙJ** ^The third parameter to [sqlite3_preupdate_hook()] is passed through asÙ$** the first parameter to callbacks.¢**ÙJ** ^The preupdate hook only fires for changes to real database tables; theÙF** preupdate hook is not invoked for changes to [virtual tables] or toÙ4** system tables like sqlite_master or sqlite_stat1.¢**ÙB** ^The second parameter to the preupdate callback is a pointer toÙ@** the [database connection] that registered the preupdate hook.ÙI** ^The third parameter to the preupdate callback is one of the constantsÙG** [SQLITE_INSERT], [SQLITE_DELETE], or [SQLITE_UPDATE] to identify theÙ3** kind of update operation that is about to occur.ÙF** ^(The fourth parameter to the preupdate callback is the name of theÙH** database within the database connection that is being modified.  ThisÙE** will be "main" for the main database or "temp" for TEMP tables or ÙM** the name given after the AS keyword in the [ATTACH] statement for attached¯** databases.)^ÙD** ^The fifth parameter to the preupdate callback is the name of theÙ ** table that is being modified.¢**ÙB** For an UPDATE or DELETE operation on a [rowid table], the sixthÙL** parameter passed to the preupdate callback is the initial [rowid] of the ÙK** row being modified or deleted. For an INSERT operation on a rowid table,ÙE** or any operation on a WITHOUT ROWID table, the value of the sixth ÙG** parameter is undefined. For an INSERT or UPDATE on a rowid table theÙG** seventh parameter is the final rowid value of the row being insertedÙH** or updated. The value of the seventh parameter passed to the callbackÙI** function is not defined for operations on WITHOUT ROWID tables, or forÙ%** INSERT operations on rowid tables.¢**Ù<** The [sqlite3_preupdate_old()], [sqlite3_preupdate_new()],ÙJ** [sqlite3_preupdate_count()], and [sqlite3_preupdate_depth()] interfacesÙI** provide additional information about a preupdate event. These routinesÙH** may only be called from within a preupdate callback.  Invoking any ofÙ@** these routines from outside of a preupdate callback or with aÙH** [database connection] pointer that is different from the one suppliedÙJ** to the preupdate callback results in undefined and probably undesirable¬** behavior.¢**ÙL** ^The [sqlite3_preupdate_count(D)] interface returns the number of columnsÙ:** in the row that is being inserted, updated, or deleted.¢**ÙK** ^The [sqlite3_preupdate_old(D,N,P)] interface writes into P a pointer toÙK** a [protected sqlite3_value] that contains the value of the Nth column ofÙI** the table row before it is updated.  The N parameter must be between 0ÙB** and one less than the number of columns or the behavior will beÙK** undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETEÙK** preupdate callbacks; if it is used by an SQLITE_INSERT callback then theÙ?** behavior is undefined.  The [sqlite3_value] that P points toÙ9** will be destroyed when the preupdate callback returns.¢**ÙK** ^The [sqlite3_preupdate_new(D,N,P)] interface writes into P a pointer toÙK** a [protected sqlite3_value] that contains the value of the Nth column ofÙH** the table row after it is updated.  The N parameter must be between 0ÙB** and one less than the number of columns or the behavior will beÙK** undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATEÙK** preupdate callbacks; if it is used by an SQLITE_DELETE callback then theÙ?** behavior is undefined.  The [sqlite3_value] that P points toÙ9** will be destroyed when the preupdate callback returns.¢**ÙI** ^The [sqlite3_preupdate_depth(D)] interface returns 0 if the preupdateÙI** callback was invoked as a result of a direct insert, update, or deleteÙI** operation; or 1 for inserts, updates, or deletes invoked by top-level ÙI** triggers; or 2 for changes resulting from triggers called by top-levelº** triggers; and so forth.¢**Ù%** See also:  [sqlite3_update_hook()]¢*/Ù)#if defined(SQLITE_ENABLE_PREUPDATE_HOOK)Ù(SQLITE_API void *sqlite3_preupdate_hook(®  sqlite3 *db,´  void(*xPreUpdate)(ÙM    void *pCtx,                   /* Copy of third arg to preupdate_hook() */Ù7    sqlite3 *db,                  /* Database handle */ÙG    int op,                       /* SQLITE_UPDATE, DELETE or INSERT */Ù5    char const *zDb,              /* Database name */Ù2    char const *zName,            /* Table name */ÙP    sqlite3_int64 iKey1,          /* Rowid of row about to be deleted/updated */ÙL    sqlite3_int64 iKey2           /* New rowid value (for a rowid UPDATE) */¤  ),§  void*¢);ÙGSQLITE_API int sqlite3_preupdate_old(sqlite3 *, int, sqlite3_value **);Ù2SQLITE_API int sqlite3_preupdate_count(sqlite3 *);Ù2SQLITE_API int sqlite3_preupdate_depth(sqlite3 *);ÙGSQLITE_API int sqlite3_preupdate_new(sqlite3 *, int, sqlite3_value **);¦#endif ¢/*Ù(** CAPI3REF: Low-level system error code¢**ÙI** ^Attempt to return the underlying operating system error code or errorÙJ** number that caused the most recent I/O error or failure to open a file.ÙI** The return value is OS-dependent.  For example, on unix systems, afterÙI** [sqlite3_open_v2()] returns [SQLITE_CANTOPEN], this interface could beÙJ** called to get back the underlying "errno" that caused the problem, suchÙ,** as ENOSPC, EAUTH, EISDIR, and so forth.  ¢*/Ù.SQLITE_API int sqlite3_system_errno(sqlite3*); ¢/*¾** CAPI3REF: Database SnapshotÙ*** KEYWORDS: {snapshot} {sqlite3_snapshot}¯** EXPERIMENTAL¢**ÙG** An instance of the snapshot object records the state of a [WAL mode]Ù/** database for some specific point in history.¢**ÙF** In [WAL mode], multiple [database connections] that are open on theÙH** same database file can each be reading a different historical versionÙD** of the database file.  When a [database connection] begins a readÙG** transaction, that connection sees an unchanging copy of the databaseÙJ** as it existed for the point in time when the transaction first started.ÙI** Subsequent changes to the database from other connections are not seenÙ9** by the reader until a new read transaction is started.¢**ÙL** The sqlite3_snapshot object records state information about an historicalÙO** version of the database file so that it is possible to later open a new readÙL** transaction that sees that historical version of the database rather than»** the most recent version.¢**ÙD** The constructor for this object is [sqlite3_snapshot_get()].  TheÙL** [sqlite3_snapshot_open()] method causes a fresh read transaction to referÙ@** to an historical snapshot (if possible).  The destructor for Ù9** sqlite3_snapshot objects is [sqlite3_snapshot_free()].¢*/Ù!typedef struct sqlite3_snapshot {»  unsigned char hidden[48];³} sqlite3_snapshot; ¢/*Ù'** CAPI3REF: Record A Database Snapshot¯** EXPERIMENTAL¢**ÙB** ^The [sqlite3_snapshot_get(D,S,P)] interface attempts to make aÙB** new [sqlite3_snapshot] object that records the current state ofÙ7** schema S in database connection D.  ^On success, theÙH** [sqlite3_snapshot_get(D,S,P)] interface writes a pointer to the newlyÙC** created [sqlite3_snapshot] object into *P and returns SQLITE_OK.ÙC** If there is not already a read-transaction open on schema S whenÙ9** this function is called, one is opened automatically. ¢**ÙE** The following must be true for this function to succeed. If any ofÙD** the following statements are false when sqlite3_snapshot_get() isÙG** called, SQLITE_ERROR is returned. The final value of *P is undefined±** in this case. ¢**§** <ul>Ù;**   <li> The database handle must be in [autocommit mode].¢**ÙL**   <li> Schema S of [database connection] D must be a [WAL mode] database.¢**ÙL**   <li> There must not be a write transaction open on schema S of database·**        connection D.¢**ÙL**   <li> One or more transactions must have been written to the current walÙK**        file since it was created on disk (by any connection). This meansÙM**        that a snapshot cannot be taken on a wal mode database with no wal ÙM**        file immediately after it is first opened. At least one transactionÙ&**        must be written to it first.¨** </ul>¢**ÙH** This function may also return SQLITE_NOMEM.  If it is called with theÙG** database handle in autocommit mode but fails for some other reason, ÙH** whether or not a read transaction is opened on schema S is undefined.¢**ÙC** The [sqlite3_snapshot] object returned from a successful call toÙI** [sqlite3_snapshot_get()] must be freed using [sqlite3_snapshot_free()]º** to avoid a memory leak.¢**ÙD** The [sqlite3_snapshot_get()] interface is only available when theÙ6** SQLITE_ENABLE_SNAPSHOT compile-time option is used.¢*/Ù8SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_get(®  sqlite3 *db,¶  const char *zSchema,¿  sqlite3_snapshot **ppSnapshot¢); ¢/*Ù?** CAPI3REF: Start a read transaction on an historical snapshot¯** EXPERIMENTAL¢**Ù9** ^The [sqlite3_snapshot_open(D,S,P)] interface starts aÙ#** read transaction for schema S ofÙ9** [database connection] D such that the read transactionÙ:** refers to historical [snapshot] P, rather than the mostÙ!** recent change to the database.ÙH** ^The [sqlite3_snapshot_open()] interface returns SQLITE_OK on successÙ.** or an appropriate [error code] if it fails.¢**ÙI** ^In order to succeed, a call to [sqlite3_snapshot_open(D,S,P)] must beÙD** the first operation following the [BEGIN] that takes the schema S¼** out of [autocommit mode].Ù5** ^In other words, schema S must not currently be inÙD** a transaction for [sqlite3_snapshot_open(D,S,P)] to work, but theÙ:** database connection D must be out of [autocommit mode].ÙB** ^A [snapshot] will fail to open if it has been overwritten by a°** [checkpoint].Ù>** ^(A call to [sqlite3_snapshot_open(D,S,P)] will fail if theÙA** database connection D does not know that the database file forÙC** schema S is in [WAL mode].  A database connection might not knowÙE** that the database file is in [WAL mode] if there has been no priorÙJ** I/O on that database connection, or if the database entered [WAL mode] Ù:** after the most recent I/O on the database connection.)^Ù>** (Hint: Run "[PRAGMA application_id]" against a newly openedÙC** database connection in order to make it ready to use snapshots.)¢**ÙE** The [sqlite3_snapshot_open()] interface is only available when theÙ6** SQLITE_ENABLE_SNAPSHOT compile-time option is used.¢*/Ù9SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_open(®  sqlite3 *db,¶  const char *zSchema,½  sqlite3_snapshot *pSnapshot¢); ¢/*¿** CAPI3REF: Destroy a snapshot¯** EXPERIMENTAL¢**ÙK** ^The [sqlite3_snapshot_free(P)] interface destroys [sqlite3_snapshot] P.ÙG** The application must eventually free every [sqlite3_snapshot] objectÙ-** using this routine to avoid a memory leak.¢**ÙE** The [sqlite3_snapshot_free()] interface is only available when theÙ6** SQLITE_ENABLE_SNAPSHOT compile-time option is used.¢*/ÙMSQLITE_API SQLITE_EXPERIMENTAL void sqlite3_snapshot_free(sqlite3_snapshot*); ¢/*Ù6** CAPI3REF: Compare the ages of two snapshot handles.¯** EXPERIMENTAL¢**ÙI** The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the agesÙ"** of two valid snapshot handles. ¢**ÙI** If the two snapshot handles are not associated with the same database Ù4** file, the result of the comparison is undefined. ¢**ÙJ** Additionally, the result of the comparison is only valid if both of theÙM** snapshot handles were obtained by calling sqlite3_snapshot_get() since theÙG** last time the wal file was deleted. The wal file is deleted when theÙK** database is changed back to rollback mode or when the number of databaseÙL** clients drops to zero. If either snapshot handle was obtained before the ÙB** wal file was last deleted, the value returned by this function °** is undefined.¢**ÙH** Otherwise, this API returns a negative value if P1 refers to an olderÙG** snapshot than P2, zero if the two handles refer to the same databaseÙD** snapshot, and a positive value if P1 is a newer snapshot than P2.¢*/Ù8SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_cmp(·  sqlite3_snapshot *p1,¶  sqlite3_snapshot *p2¢); ¢/*Ù.** CAPI3REF: Recover snapshots from a wal file¯** EXPERIMENTAL¢**ÙH** If all connections disconnect from a database file but do not performÙH** a checkpoint, the existing wal file is opened along with the databaseÙF** file the next time the database is opened. At this point it is onlyÙI** possible to successfully call sqlite3_snapshot_open() to open the mostÙI** recent snapshot of the database (the one at the head of the wal file),ÙG** even though the wal file may contain other valid snapshots for whichÙ)** clients have sqlite3_snapshot handles.¢**ÙK** This function attempts to scan the wal file associated with database zDbÙB** of database handle db and make all valid snapshots available toÙE** sqlite3_snapshot_open(). It is an error if there is already a readÙI** transaction open on the database, or if the database is not a wal mode¬** database.¢**ÙJ** SQLITE_OK is returned if successful, or an SQLite error code otherwise.¢*/ÙZSQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb); ¢/*Ù!** CAPI3REF: Serialize a database¢**ÙG** The sqlite3_serialize(D,S,P,F) interface returns a pointer to memoryÙH** that is a serialization of the S database on [database connection] D.ÙE** If P is not a NULL pointer, then the size of the database in bytes¶** is written into *P.¢**ÙE** For an ordinary on-disk database file, the serialization is just aÙJ** copy of the disk file.  For an in-memory database or a "TEMP" database,ÙI** the serialization is the same sequence of bytes which would be writtenÙ4** to disk if that database where backed up to disk.¢**ÙI** The usual case is that sqlite3_serialize() copies the serialization ofÙJ** the database into memory obtained from [sqlite3_malloc64()] and returnsÙG** a pointer to that memory.  The caller is responsible for freeing theÙE** returned value to avoid a memory leak.  However, if the F argumentÙG** contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocationsÙG** are made, and the sqlite3_serialize() function will return a pointerÙF** to the contiguous memory representation of the database that SQLiteÙJ** is currently using for that database, or NULL if the no such contiguousÙE** memory representation of the database exists.  A contiguous memoryÙF** representation of the database will usually only exist if there hasÙD** been a prior call to [sqlite3_deserialize(D,S,...)] with the sameµ** values of D and S.Ù;** The size of the database is written into *P even if the Ù<** SQLITE_SERIALIZE_NOCOPY bit is set but no contigious copyº** of the database exists.¢**ÙE** A call to sqlite3_serialize(D,S,P,F) might return NULL even if theÙE** SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory»** allocation error occurs.¢**ÙB** This interface is only available if SQLite is compiled with theÙ&** [SQLITE_ENABLE_DESERIALIZE] option.¢*/Ù,SQLITE_API unsigned char *sqlite3_serialize(Ù6  sqlite3 *db,           /* The database connection */ÙM  const char *zSchema,   /* Which DB to serialize. ex: "main", "temp", ... */ÙE  sqlite3_int64 *piSize, /* Write size of the DB here, if not NULL */ÙD  unsigned int mFlags    /* Zero or more SQLITE_SERIALIZE_* flags */¢); ¢/*Ù(** CAPI3REF: Flags for sqlite3_serialize¢**ÙD** Zero or more of the following constants can be OR-ed together forÙ2** the F argument to [sqlite3_serialize(D,S,P,F)].¢**ÙG** SQLITE_SERIALIZE_NOCOPY means that [sqlite3_serialize()] will returnÙI** a pointer to contiguous in-memory database that it is currently using,ÙK** without making a copy of the database.  If SQLite is not currently usingÙ;** a contiguous in-memory database, then this option causesÙG** [sqlite3_serialize()] to return a NULL pointer.  SQLite will only beÙH** using a contiguous in-memory database if it has been initialized by aÙ)** prior call to [sqlite3_deserialize()].¢*/ÙF#define SQLITE_SERIALIZE_NOCOPY 0x001   /* Do no memory allocations */ ¢/*Ù#** CAPI3REF: Deserialize a database¢**Ù=** The sqlite3_deserialize(D,S,P,N,M,F) interface causes the ÙA** [database connection] D to disconnect from database S and thenÙI** reopen S as an in-memory database based on the serialization containedÙI** in P.  The serialized database P is N bytes in size.  M is the size ofÙJ** the buffer P, which might be larger than N.  If M is larger than N, andÙF** the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite isÙJ** permitted to add content to the in-memory database as long as the totalÙ ** size does not exceed M bytes.¢**ÙJ** If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite willÙF** invoke sqlite3_free() on the serialization buffer when the databaseÙL** connection closes.  If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, thenÙH** SQLite will try to increase the buffer size using sqlite3_realloc64()ÙB** if writes on the database cause it to grow larger than M bytes.¢**ÙH** The sqlite3_deserialize() interface will fail with SQLITE_BUSY if theÙI** database is currently in a read transaction or is involved in a backup­** operation.¢**ÙG** If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the Ù@** SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, thenÙ@** [sqlite3_free()] is invoked on argument P prior to returning.¢**ÙB** This interface is only available if SQLite is compiled with theÙ&** [SQLITE_ENABLE_DESERIALIZE] option.¢*/Ù#SQLITE_API int sqlite3_deserialize(Ù7  sqlite3 *db,            /* The database connection */ÙK  const char *zSchema,    /* Which DB to reopen with the deserialization */Ù?  unsigned char *pData,   /* The serialized database content */ÙC  sqlite3_int64 szDb,     /* Number bytes in the deserialization */Ù<  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */ÙG  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */¢); ¢/*Ù,** CAPI3REF: Flags for sqlite3_deserialize()¢**ÙH** The following are allowed values for 6th argument (the F argument) toÙ4** the [sqlite3_deserialize(D,S,P,N,M,F)] interface.¢**ÙK** The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serializationÙI** in the P argument is held in memory obtained from [sqlite3_malloc64()]ÙI** and that SQLite should take ownership of this memory and automaticallyÙH** free it when it has finished using it.  Without this flag, the callerÙ>** is resposible for freeing any dynamically allocated memory.¢**ÙI** The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed toÙL** grow the size of the database using calls to [sqlite3_realloc64()].  ThisÙK** flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.ÙN** Without this flag, the deserialized database cannot increase in size beyondÙ4** the number of bytes specified by the M parameter.¢**ÙL** The SQLITE_DESERIALIZE_READONLY flag means that the deserialized databaseÙ"** should be treated as read-only.¢*/ÙK#define SQLITE_DESERIALIZE_FREEONCLOSE 1 /* Call sqlite3_free() on close */ÙO#define SQLITE_DESERIALIZE_RESIZEABLE  2 /* Resize using sqlite3_realloc64() */ÙD#define SQLITE_DESERIALIZE_READONLY    4 /* Database is read-only */ ¢/*ÙB** Undo the hack that converts floating point types to integer forÙ7** builds on processors without floating point support.¢*/Ù!#ifdef SQLITE_OMIT_FLOATING_POINT®# undef double¦#endif ¥#if 0Ù&}  /* End of the 'extern "C"' block */¦#endif¶#endif /* SQLITE3_H */ Ù./******** Begin file sqlite3rtree.h *********/¢/*±** 2010 August 30¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢*/ ¸#ifndef _SQLITE3RTREE_H_¸#define _SQLITE3RTREE_H_  ¥#if 0¬extern "C" {¦#endif Ù=typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;ÙAtypedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info; Ù=/* The double-precision datatype used by RTree depends on theÙ-** SQLITE_RTREE_INT_ONLY compile-time option.¢*/¼#ifdef SQLITE_RTREE_INT_ONLYÙ*  typedef sqlite3_int64 sqlite3_rtree_dbl;¥#elseÙ#  typedef double sqlite3_rtree_dbl;¦#endif ¢/*ÙJ** Register a geometry callback named zGeom that can be used as part of anÙ$** R-Tree geometry query as follows:¢**ÙK**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zGeom(... params ...)¢*/Ù/SQLITE_API int sqlite3_rtree_geometry_callback(®  sqlite3 *db,´  const char *zGeom,ÙF  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),°  void *pContext¢);  ¢/*ÙH** A pointer to a structure of the following type is passed as the firstÙD** argument to callbacks registered using rtree_geometry_callback().¢*/¿struct sqlite3_rtree_geometry {ÙL  void *pContext;                 /* Copy of pContext passed to s_r_g_c() */Ù>  int nParam;                     /* Size of array aParam[] */ÙN  sqlite3_rtree_dbl *aParam;      /* Parameters passed to SQL geom function */ÙI  void *pUser;                    /* Callback implementation user data */ÙJ  void (*xDelUser)(void *);       /* Called by SQLite to clean up pUser */¢}; ¢/*ÙH** Register a 2nd-generation geometry callback named zScore that can be Ù7** used as part of an R-Tree geometry query as follows:¢**ÙP**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zQueryFunc(... params ...)¢*/Ù,SQLITE_API int sqlite3_rtree_query_callback(®  sqlite3 *db,¹  const char *zQueryFunc,Ù/  int (*xQueryFunc)(sqlite3_rtree_query_info*),±  void *pContext,¼  void (*xDestructor)(void*)¢);  ¢/*ÙC** A pointer to a structure of the following type is passed as the Ù8** argument to scored geometry callback registered usingÙ"** sqlite3_rtree_query_callback().¢**ÙB** Note that the first 5 fields of this structure are identical toÙ;** sqlite3_rtree_geometry.  This structure is a subclass ofº** sqlite3_rtree_geometry.¢*/Ù!struct sqlite3_rtree_query_info {ÙP  void *pContext;                   /* pContext from when function registered */ÙG  int nParam;                       /* Number of function parameters */ÙF  sqlite3_rtree_dbl *aParam;        /* value of function parameters */ÙK  void *pUser;                      /* callback can use this, if desired */Ù@  void (*xDelUser)(void*);          /* function to free pUser */ÙO  sqlite3_rtree_dbl *aCoord;        /* Coordinates of node or entry to check */ÙP  unsigned int *anQueue;            /* Number of pending entries in the queue */Ù?  int nCoord;                       /* Number of coordinates */ÙH  int iLevel;                       /* Level of current node or entry */ÙN  int mxLevel;                      /* The largest iLevel value in the tree */ÙA  sqlite3_int64 iRowid;             /* Rowid for current entry */Ù>  sqlite3_rtree_dbl rParentScore;   /* Score of parent node */ÙC  int eParentWithin;                /* Visibility of parent node */Ù8  int eWithin;                      /* OUT: Visiblity */ÙC  sqlite3_rtree_dbl rScore;         /* OUT: Write the score here */ÙC  /* The following fields are only available in 3.8.11 and later */ÙK  sqlite3_value **apSqlParam;       /* Original SQL values of parameters */¢}; ¢/*ÙE** Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.¢*/ÙL#define NOT_WITHIN       0   /* Object completely outside of query region */ÙI#define PARTLY_WITHIN    1   /* Object partially overlaps query region */ÙM#define FULLY_WITHIN     2   /* Object fully contained within query region */  ¥#if 0Ù&}  /* end of the 'extern "C"' block */¦#endif Ù%#endif  /* ifndef _SQLITE3RTREE_H_ */ Ù*/******** End of sqlite3rtree.h *********/Ù0/******** Begin file sqlite3session.h *********/ ÙB#if !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION)¼#define __SQLITESESSION_H_ 1 ¢/*Ù-** Make sure we can call this stuff from C++.¢*/¥#if 0¬extern "C" {¦#endif  ¢/*Ù"** CAPI3REF: Session Object Handle¢**Ù@** An instance of this object is a [session] that can be used toÙ ** record changes to a database.¢*/Ù/typedef struct sqlite3_session sqlite3_session; ¢/*Ù&** CAPI3REF: Changeset Iterator Handle¢**Ù<** An instance of this object acts as a cursor for iteratingÙ4** over the elements of a [changeset] or [patchset].¢*/Ù=typedef struct sqlite3_changeset_iter sqlite3_changeset_iter; ¢/*Ù(** CAPI3REF: Create A New Session Object¿** CONSTRUCTOR: sqlite3_session¢**ÙM** Create a new session object attached to database handle db. If successful,ÙH** a pointer to the new object is written to *ppSession and SQLITE_OK isÙH** returned. If an error occurs, *ppSession is set to NULL and an SQLiteÙ.** error code (e.g. SQLITE_NOMEM) is returned.¢**ÙI** It is possible to create multiple session objects attached to a single³** database handle.¢**ÙJ** Session objects created using this function should be deleted using theÙJ** [sqlite3session_delete()] function before the database handle that theyÙL** are attached to is itself closed. If the database handle is closed beforeÙI** the session object is deleted, then the results of calling any sessionÙM** module function, including [sqlite3session_delete()] on the session object±** are undefined.¢**ÙI** Because the session module uses the [sqlite3_preupdate_hook()] API, itÙH** is not possible for an application to register a pre-update hook on aÙH** database handle that has one or more session objects attached. Nor isÙK** it possible to create a session object attached to a database handle forÙI** which a pre-update hook is already defined. The results of attempting Ù(** either of these things are undefined.¢**ÙE** The session object will be used to create changesets for tables inÙI** database zDb, where zDb is either "main", or "temp", or the name of anÙH** attached database. It is not an error if database zDb is not attachedÙ6** to the database when the session object is created.¢*/Ù%SQLITE_API int sqlite3session_create(Ù7  sqlite3 *db,                    /* Database handle */Ù@  const char *zDb,                /* Name of db (e.g. "main") */Ù?  sqlite3_session **ppSession     /* OUT: New session object */¢); ¢/*Ù$** CAPI3REF: Delete A Session Object¾** DESTRUCTOR: sqlite3_session¢**Ù6** Delete a session object previously allocated using ÙI** [sqlite3session_create()]. Once a session object has been deleted, theÙF** results of attempting to use pSession with any other session moduleº** function are undefined.¢**ÙK** Session objects must be deleted before the database handle to which theyÙ:** are attached is closed. Refer to the documentation for Ù)** [sqlite3session_create()] for details.¢*/ÙASQLITE_API void sqlite3session_delete(sqlite3_session *pSession);  ¢/*Ù/** CAPI3REF: Enable Or Disable A Session Objectº** METHOD: sqlite3_session¢**ÙG** Enable or disable the recording of changes by a session object. WhenÙG** enabled, a session object records changes made to the database. WhenÙE** disabled - it does not. A newly created session object is enabled.ÙJ** Refer to the documentation for [sqlite3session_changeset()] for furtherÙH** details regarding how enabling and disabling a session object affects»** the eventual changesets.¢**ÙF** Passing zero to this function disables the session. Passing a valueÙE** greater than zero enables it. Passing a value less than zero is a ÙD** no-op, and may be used to query the current state of the session.¢**ÙJ** The return value indicates the final state of the session object: 0 if Ù2** the session is disabled, or 1 if it is enabled.¢*/ÙMSQLITE_API int sqlite3session_enable(sqlite3_session *pSession, int bEnable); ¢/*Ù2** CAPI3REF: Set Or Clear the Indirect Change Flagº** METHOD: sqlite3_session¢**ÙI** Each change recorded by a session object is marked as either direct orÙ6** indirect. A change is marked as indirect if either:¢**§** <ul>ÙF**   <li> The session object "indirect" flag is set when the change is²**        made, orÙE**   <li> The change is made by an SQL trigger or foreign key action ÙC**        instead of directly as a result of a users SQL statement.¨** </ul>¢**ÙK** If a single row is affected by more than one operation within a session,ÙM** then the change is considered indirect if all operations meet the criteriaÙ5** for an indirect change above, or direct otherwise.¢**ÙK** This function is used to set, clear or query the session object indirectÙJ** flag.  If the second argument passed to this function is zero, then theÙJ** indirect flag is cleared. If it is greater than zero, the indirect flagÙK** is set. Passing a value less than zero does not modify the current valueÙK** of the indirect flag, and may be used to query the current state of the Ù2** indirect flag for the specified session object.¢**ÙI** The return value indicates the final state of the indirect flag: 0 if Ù"** it is clear, or 1 if it is set.¢*/ÙQSQLITE_API int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect); ¢/*Ù/** CAPI3REF: Attach A Table To A Session Objectº** METHOD: sqlite3_session¢**ÙI** If argument zTab is not NULL, then it is the name of a table to attachÙN** to the session object passed as the first argument. All subsequent changes ÙO** made to the table while the session object is enabled will be recorded. See ÙF** documentation for [sqlite3session_changeset()] for further details.¢**ÙI** Or, if argument zTab is NULL, then changes are recorded for all tablesÙG** in the database. If additional tables are added to the database (by ÙM** executing "CREATE TABLE" statements) after this call is made, changes for Ù$** the new tables are also recorded.¢**ÙM** Changes can only be recorded for tables that have a PRIMARY KEY explicitlyÙN** defined as part of their CREATE TABLE statement. It does not matter if the ÙL** PRIMARY KEY is an "INTEGER PRIMARY KEY" (rowid alias) or not. The PRIMARYÙA** KEY may consist of a single column, or may be a composite key.£** ÙL** It is not an error if the named table does not exist in the database. NorÙJ** is it an error if the named table does not have a PRIMARY KEY. However,Ù<** no changes will be recorded in either of these scenarios.¢**ÙL** Changes are not recorded for individual rows that have NULL values storedÙ/** in one or more of their PRIMARY KEY columns.¢**ÙN** SQLITE_OK is returned if the call completes without error. Or, if an error Ù@** occurs, an SQLite error code (e.g. SQLITE_NOMEM) is returned.¢**Ù)** <h3>Special sqlite_stat1 Handling</h3>¢**ÙL** As of SQLite version 3.22.0, the "sqlite_stat1" table is an exception to ÙE** some of the rules above. In SQLite, the schema of sqlite_stat1 is:©**  <pre>Ù8**  &nbsp;     CREATE TABLE sqlite_stat1(tbl,idx,stat)  ª**  </pre>¢**ÙE** Even though sqlite_stat1 does not have a PRIMARY KEY, changes are ÙM** recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes ÙK** are recorded for rows for which (idx IS NULL) is true. However, for suchÙH** rows a zero-length blob (SQL value X'') is stored in the changeset orÙF** patchset instead of a NULL value. This allows such changesets to beÙF** manipulated by legacy implementations of sqlite3changeset_invert(),¸** concat() and similar.¢**ÙD** The sqlite3changeset_apply() function automatically converts the ÙG** zero-length blob back to a NULL value when updating the sqlite_stat1ÙC** table. However, if the application calls sqlite3changeset_new(),ÙF** sqlite3changeset_old() or sqlite3changeset_conflict on a changeset ÙC** iterator directly (including on a changeset iterator passed to aÙM** conflict-handler callback) then the X'' value is returned. The applicationÙ1** must translate X'' to NULL itself if required.¢**ÙL** Legacy (older than 3.22.0) versions of the sessions module cannot captureÙA** changes made to the sqlite_stat1 table. Legacy versions of theÙM** sqlite3changeset_apply() function silently ignore any modifications to theÙ?** sqlite_stat1 table that are part of a changeset or patchset.¢*/Ù%SQLITE_API int sqlite3session_attach(Ù6  sqlite3_session *pSession,      /* Session object */Ù2  const char *zTab                /* Table name */¢); ¢/*Ù4** CAPI3REF: Set a table filter on a Session Object.º** METHOD: sqlite3_session¢**ÙO** The second argument (xFilter) is the "filter callback". For changes to rows ÙN** in tables that are not attached to the Session object, the filter is calledÙN** to determine whether changes to the table's rows should be tracked or not. ÙK** If xFilter returns 0, changes is not tracked. Note that once a table is Ù.** attached, xFilter will not be called again.¢*/Ù,SQLITE_API void sqlite3session_table_filter(Ù6  sqlite3_session *pSession,      /* Session object */°  int(*xFilter)(ÙL    void *pCtx,                   /* Copy of third arg to _filter_table() */Ù2    const char *zTab              /* Table name */¤  ),ÙH  void *pCtx                      /* First argument passed to xFilter */¢); ¢/*Ù7** CAPI3REF: Generate A Changeset From A Session Objectº** METHOD: sqlite3_session¢**ÙG** Obtain a changeset containing changes to the tables attached to the Ù?** session object passed as the first argument. If successful, ÙB** set *ppChangeset to point to a buffer containing the changeset ÙJ** and *pnChangeset to the size of the changeset in bytes before returningÙK** SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset toÙ(** zero and return an SQLite error code.¢**ÙM** A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes,ÙM** each representing a change to a single row of an attached table. An INSERTÙK** change contains the values of each field of a new database row. A DELETEÙK** contains the original values of each field of a deleted database row. AnÙI** UPDATE change contains the original values of each field of an updatedÙN** database row along with the updated values for each updated non-primary-keyÙM** column. It is not possible for an UPDATE change to represent a change thatÙK** modifies the values of primary key columns. If such a change is made, itÙC** is represented in a changeset as a DELETE followed by an INSERT.¢**ÙL** Changes are not recorded for rows that have NULL values stored in one or ÙK** more of their PRIMARY KEY columns. If such a row is inserted or deleted,ÙH** no corresponding change is present in the changesets returned by thisÙF** function. If an existing row with one or more NULL values stored inÙO** PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL,ÙL** only an INSERT is appears in the changeset. Similarly, if an existing rowÙI** with non-NULL PRIMARY KEY values is updated so that one or more of itsÙJ** PRIMARY KEY columns are set to NULL, the resulting changeset contains a¶** DELETE change only.¢**ÙI** The contents of a changeset may be traversed using an iterator createdÙJ** using the [sqlite3changeset_start()] API. A changeset may be applied toÙK** a database with a compatible schema using the [sqlite3changeset_apply()]§** API.¢**ÙJ** Within a changeset generated by this function, all changes related to aÙL** single table are grouped together. In other words, when iterating throughÙN** a changeset or when applying a changeset to a database, all changes relatedÙM** to a single table are processed before moving on to the next table. TablesÙN** are sorted in the same order in which they were attached (or auto-attached)ÙK** to the sqlite3_session object. The order in which the changes related toÙ*** a single table are stored is undefined.¢**ÙL** Following a successful call to this function, it is the responsibility ofÙM** the caller to eventually free the buffer that *ppChangeset points to using´** [sqlite3_free()].¢**Ù ** <h3>Changeset Generation</h3>¢**ÙI** Once a table has been attached to a session object, the session objectÙJ** records the primary key values of all new rows inserted into the table.ÙJ** It also records the original primary key and other column values of anyÙK** deleted or updated rows. For each unique primary key value, data is onlyÙJ** recorded once - the first time a row with said primary key is inserted,Ù5** updated or deleted in the lifetime of the session.¢**ÙL** There is one exception to the previous paragraph: when a row is inserted,ÙJ** updated or deleted, if one or more of its primary key columns contain aÙ/** NULL value, no record of the change is made.¢**ÙH** The session object therefore accumulates two types of records - thoseÙI** that consist of primary key values only (created when the user insertsÙI** a new record) and those that consist of the primary key values and theÙI** original values of other table columns (created when the users deletes¸** or updates a record).¢**ÙI** When this function is called, the requested changeset is created usingÙH** both the accumulated records and the current contents of the database¶** file. Specifically:¢**§** <ul>ÙI**   <li> For each record generated by an insert, the database is queriedÙK**        for a row with a matching primary key. If one is found, an INSERTÙO**        change is added to the changeset. If no such row is found, no change Ù$**        is added to the changeset.¢**ÙL**   <li> For each record generated by an update or delete, the database is ÙI**        queried for a row with a matching primary key. If such a row isÙG**        found and one or more of the non-primary key fields have beenÙL**        modified from their original values, an UPDATE change is added to ÙL**        the changeset. Or, if no such row is found in the table, a DELETE ÙM**        change is added to the changeset. If there is a row with a matchingÙL**        primary key in the database, but all fields contain their originalÙ6**        values, no change is added to the changeset.¨** </ul>¢**ÙM** This means, amongst other things, that if a row is inserted and then laterÙN** deleted while a session object is active, neither the insert nor the deleteÙM** will be present in the changeset. Or if a row is deleted and then later a ÙJ** row with the same primary key values inserted while a session object isÙK** active, the resulting changeset will contain an UPDATE change instead ofº** a DELETE and an INSERT.¢**ÙM** When a session object is disabled (see the [sqlite3session_enable()] API),ÙM** it does not accumulate records when rows are inserted, updated or deleted.ÙI** This may appear to have some counter-intuitive effects if a single rowÙG** is written to more than once during a session. For example, if a rowÙK** is inserted while a session object is enabled, then later deleted while ÙK** the same session object is disabled, no INSERT record will appear in theÙO** changeset, even though the delete took place while the session was disabled.ÙI** Or, if one field of a row is updated while a session is disabled, and ÙM** another field of the same row is updated while the session is enabled, theÙN** resulting changeset will contain an UPDATE change that updates both fields.¢*/Ù(SQLITE_API int sqlite3session_changeset(Ù6  sqlite3_session *pSession,      /* Session object */ÙK  int *pnChangeset,               /* OUT: Size of buffer at *ppChangeset */ÙH  void **ppChangeset              /* OUT: Buffer containing changeset */¢); ¢/*Ù>** CAPI3REF: Load The Difference Between Tables Into A Sessionº** METHOD: sqlite3_session¢**ÙJ** If it is not already attached to the session object passed as the firstÙH** argument, this function attaches table zTbl in the same manner as theÙG** [sqlite3session_attach()] function. If zTbl does not exist, or if itÙM** does not have a primary key, this function is a no-op (but does not return­** an error).¢**ÙH** Argument zFromDb must be the name of a database ("main", "temp" etc.)ÙL** attached to the same database handle as the session object that contains ÙN** a table compatible with the table attached to the session by this function.Ù*** A table is considered compatible if it:¢**§** <ul>¼**   <li> Has the same name,ÙE**   <li> Has the same set of columns declared in the same order, andÙ.**   <li> Has the same PRIMARY KEY definition.¨** </ul>¢**ÙM** If the tables are not compatible, SQLITE_SCHEMA is returned. If the tablesÙM** are compatible but do not have any PRIMARY KEY columns, it is not an errorÙH** but no changes are added to the session object. As with other sessionÙ8** APIs, tables without PRIMARY KEYs are simply ignored.¢**ÙJ** This function adds a set of changes to the session object that could beÙK** used to update the table in database zFrom (call this the "from-table") ÙH** so that its content is the same as the table attached to the session Ù3** object (call this the "to-table"). Specifically:¢**§** <ul>ÙL**   <li> For each row (primary key) that exists in the to-table but not in ÙG**     the from-table, an INSERT record is added to the session object.¢**ÙL**   <li> For each row (primary key) that exists in the to-table but not in ÙF**     the from-table, a DELETE record is added to the session object.¢**ÙN**   <li> For each row (primary key) that exists in both tables, but features ÙH**     different non-PK values in each, an UPDATE record is added to the±**     session.  ¨** </ul>¢**ÙJ** To clarify, if this function is called and then a changeset constructedÙM** using [sqlite3session_changeset()], then after applying that changeset to ÙE** database zFrom the contents of the two compatible tables would be ­** identical.¢**ÙG** It an error if database zFrom does not exist or does not contain the½** required compatible table.¢**ÙK** If the operation successful, SQLITE_OK is returned. Otherwise, an SQLiteÙH** error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsgÙH** may be set to point to a buffer containing an English language error ÙL** message. It is the responsibility of the caller to free this buffer using²** sqlite3_free().¢*/Ù#SQLITE_API int sqlite3session_diff(¼  sqlite3_session *pSession,¶  const char *zFromDb,³  const char *zTbl,±  char **pzErrMsg¢);  ¢/*Ù6** CAPI3REF: Generate A Patchset From A Session Objectº** METHOD: sqlite3_session¢**Ù?** The differences between a patchset and a changeset are that:¢**§** <ul>ÙE**   <li> DELETE records consist of the primary key fields only. The Ù6**        original values of other fields are omitted.ÙF**   <li> The original values of any modified fields are omitted from ¹**        UPDATE records.¨** </ul>¢**Ù?** A patchset blob may be used with up to date versions of all ÙL** sqlite3changeset_xxx API functions except for sqlite3changeset_invert(), ÙF** which returns SQLITE_CORRUPT if it is passed a patchset. Similarly,Ù=** attempting to use a patchset blob with old versions of theÙD** sqlite3changeset_xxx APIs also provokes an SQLITE_CORRUPT error. ¢**Ù>** Because the non-primary key "old.*" fields are omitted, no ÙL** SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchsetÙK** is passed to the sqlite3changeset_apply() API. Other conflict types workÙ%** in the same way as for changesets.¢**ÙJ** Changes within a patchset are ordered in the same way as for changesetsÙM** generated by the sqlite3session_changeset() function (i.e. all changes forÙK** a single table are grouped together, tables appear in the order in whichÙ-** they were attached to the session object).¢*/Ù'SQLITE_API int sqlite3session_patchset(Ù6  sqlite3_session *pSession,      /* Session object */ÙJ  int *pnPatchset,                /* OUT: Size of buffer at *ppPatchset */ÙG  void **ppPatchset               /* OUT: Buffer containing patchset */¢); ¢/*Ù:** CAPI3REF: Test if a changeset has recorded any changes.¢**ÙJ** Return non-zero if no changes to attached tables have been recorded by ÙI** the session object passed as the first argument. Otherwise, if one or Ù0** more changes have been recorded, return zero.¢**ÙB** Even if this function returns zero, it is possible that callingÙH** [sqlite3session_changeset()] on the session handle may still return aÙE** changeset that contains no changes. This can happen when a row in ÙG** an attached table is modified and then later on the original values ÙG** are restored. However, if this function returns non-zero, then it isÙF** guaranteed that a call to sqlite3session_changeset() will return a Ù%** changeset containing zero changes.¢*/ÙASQLITE_API int sqlite3session_isempty(sqlite3_session *pSession); ¢/*Ù8** CAPI3REF: Create An Iterator To Traverse A Changeset Ù&** CONSTRUCTOR: sqlite3_changeset_iter¢**ÙJ** Create an iterator used to iterate through the contents of a changeset.ÙJ** If successful, *pp is set to point to the iterator handle and SQLITE_OKÙH** is returned. Otherwise, if an error occurs, *pp is set to zero and anÙ!** SQLite error code is returned.¢**ÙH** The following functions can be used to advance and query a changeset Ù%** iterator created by this function:¢**§** <ul>Ù#**   <li> [sqlite3changeset_next()]Ù!**   <li> [sqlite3changeset_op()]Ù"**   <li> [sqlite3changeset_new()]Ù"**   <li> [sqlite3changeset_old()]¨** </ul>¢**ÙL** It is the responsibility of the caller to eventually destroy the iteratorÙL** by passing it to [sqlite3changeset_finalize()]. The buffer containing theÙG** changeset (pChangeset) must remain valid until after the iterator is­** destroyed.¢**Ù8** Assuming the changeset blob was created by one of theÙ?** [sqlite3session_changeset()], [sqlite3changeset_concat()] orÙK** [sqlite3changeset_invert()] functions, all changes within the changeset ÙK** that apply to a single table are grouped together. This means that when ÙL** an application iterates through a changeset using an iterator created by ÙH** this function, all changes that relate to a single table are visited ÙK** consecutively. There is no chance that the iterator will visit a change ÙI** the applies to table X, then one for table Y, and then later on visit ¾** another change for table X.¢*/Ù&SQLITE_API int sqlite3changeset_start(ÙJ  sqlite3_changeset_iter **pp,    /* OUT: New changeset iterator handle */ÙG  int nChangeset,                 /* Size of changeset blob in bytes */ÙL  void *pChangeset                /* Pointer to blob containing changeset */¢);  ¢/*Ù)** CAPI3REF: Advance A Changeset IteratorÙ!** METHOD: sqlite3_changeset_iter¢**ÙD** This function may only be used with iterators created by functionÙG** [sqlite3changeset_start()]. If it is called on an iterator passed toÙK** a conflict-handler callback by [sqlite3changeset_apply()], SQLITE_MISUSEÙ*** is returned and the call has no effect.¢**ÙK** Immediately after an iterator is created by sqlite3changeset_start(), itÙH** does not point to any change in the changeset. Assuming the changesetÙI** is not empty, the first call to this function advances the iterator toÙL** point to the first change in the changeset. Each subsequent call advancesÙI** the iterator to point to the next change in the changeset (if any). IfÙI** no error occurs and the iterator points to a valid change after a callÙG** to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. ÙH** Otherwise, if all changes in the changeset have already been visited,»** SQLITE_DONE is returned.¢**ÙH** If an error occurs, an SQLite error code is returned. Possible error ÙH** codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or °** SQLITE_NOMEM.¢*/ÙDSQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *pIter); ¢/*ÙC** CAPI3REF: Obtain The Current Operation From A Changeset IteratorÙ!** METHOD: sqlite3_changeset_iter¢**ÙG** The pIter argument passed to this function may either be an iteratorÙM** passed to a conflict-handler by [sqlite3changeset_apply()], or an iteratorÙM** created by [sqlite3changeset_start()]. In the latter case, the most recentÙM** call to [sqlite3changeset_next()] must have returned [SQLITE_ROW]. If thisÙ:** is not the case, this function returns [SQLITE_MISUSE].¢**ÙB** If argument pzTab is not NULL, then *pzTab is set to point to aÙG** nul-terminated utf-8 encoded string containing the name of the tableÙH** affected by the current change. The buffer remains valid until eitherÙB** sqlite3changeset_next() is called on the iterator or until the ÙK** conflict-handler function returns. If pnCol is not NULL, then *pnCol is ÙG** set to the number of columns in the table affected by the change. IfÙM** pbIncorrect is not NULL, then *pbIndirect is set to true (1) if the changeÙK** is an indirect change, or false (0) otherwise. See the documentation forÙG** [sqlite3session_indirect()] for a description of direct and indirectÙD** changes. Finally, if pOp is not NULL, then *pOp is set to one of ÙI** [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE], depending on the Ù8** type of change that the iterator currently points to.¢**ÙH** If no error occurs, SQLITE_OK is returned. If an error does occur, anÙL** SQLite error code is returned. The values of the output variables may not»** be trusted in this case.¢*/Ù#SQLITE_API int sqlite3changeset_op(Ù7  sqlite3_changeset_iter *pIter,  /* Iterator object */ÙB  const char **pzTab,             /* OUT: Pointer to table name */ÙG  int *pnCol,                     /* OUT: Number of columns in table */ÙL  int *pOp,                       /* OUT: SQLITE_INSERT, DELETE or UPDATE */ÙJ  int *pbIndirect                 /* OUT: True for an 'indirect' change */¢); ¢/*Ù9** CAPI3REF: Obtain The Primary Key Definition Of A TableÙ!** METHOD: sqlite3_changeset_iter¢**Ù?** For each modified table, a changeset includes the following:¢**§** <ul>Ù1**   <li> The number of columns in the table, andÙ@**   <li> Which of those columns make up the tables PRIMARY KEY.¨** </ul>¢**ÙJ** This function is used to find which columns comprise the PRIMARY KEY ofÙL** the table modified by the change that iterator pIter currently points to.ÙK** If successful, *pabPK is set to point to an array of nCol entries, whereÙL** nCol is the number of columns in the table. Elements of *pabPK are set toÙI** 0x01 if the corresponding column is part of the tables primary key, orµ** 0x00 if it is not.¢**ÙM** If argument pnCol is not NULL, then *pnCol is set to the number of columns°** in the table.¢**ÙI** If this function is called when the iterator does not point to a validÙO** entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise,ÙH** SQLITE_OK is returned and the output variables populated as described©** above.¢*/Ù#SQLITE_API int sqlite3changeset_pk(Ù7  sqlite3_changeset_iter *pIter,  /* Iterator object */ÙP  unsigned char **pabPK,          /* OUT: Array of boolean - true for PK cols */ÙN  int *pnCol                      /* OUT: Number of entries in output array */¢); ¢/*Ù:** CAPI3REF: Obtain old.* Values From A Changeset IteratorÙ!** METHOD: sqlite3_changeset_iter¢**ÙG** The pIter argument passed to this function may either be an iteratorÙM** passed to a conflict-handler by [sqlite3changeset_apply()], or an iteratorÙM** created by [sqlite3changeset_start()]. In the latter case, the most recentÙD** call to [sqlite3changeset_next()] must have returned SQLITE_ROW. ÙM** Furthermore, it may only be called if the type of change that the iteratorÙO** currently points to is either [SQLITE_DELETE] or [SQLITE_UPDATE]. Otherwise,ÙC** this function returns [SQLITE_MISUSE] and sets *ppValue to NULL.¢**ÙM** Argument iVal must be greater than or equal to 0, and less than the numberÙE** of columns in the table affected by the current change. Otherwise,Ù:** [SQLITE_RANGE] is returned and *ppValue is set to NULL.¢**ÙE** If successful, this function sets *ppValue to point to a protectedÙH** sqlite3_value object containing the iVal'th value from the vector of ÙH** original row values stored as part of the UPDATE or DELETE change andÙM** returns SQLITE_OK. The name of the function comes from the fact that this ÙL** is similar to the "old.*" columns available to update or delete triggers.¢**ÙK** If some other error occurs (e.g. an OOM condition), an SQLite error codeÙ+** is returned and *ppValue is set to NULL.¢*/Ù$SQLITE_API int sqlite3changeset_old(Ù:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */Ù5  int iVal,                       /* Column number */ÙH  sqlite3_value **ppValue         /* OUT: Old value (or NULL pointer) */¢); ¢/*Ù:** CAPI3REF: Obtain new.* Values From A Changeset IteratorÙ!** METHOD: sqlite3_changeset_iter¢**ÙG** The pIter argument passed to this function may either be an iteratorÙM** passed to a conflict-handler by [sqlite3changeset_apply()], or an iteratorÙM** created by [sqlite3changeset_start()]. In the latter case, the most recentÙD** call to [sqlite3changeset_next()] must have returned SQLITE_ROW. ÙM** Furthermore, it may only be called if the type of change that the iteratorÙO** currently points to is either [SQLITE_UPDATE] or [SQLITE_INSERT]. Otherwise,ÙC** this function returns [SQLITE_MISUSE] and sets *ppValue to NULL.¢**ÙM** Argument iVal must be greater than or equal to 0, and less than the numberÙE** of columns in the table affected by the current change. Otherwise,Ù:** [SQLITE_RANGE] is returned and *ppValue is set to NULL.¢**ÙE** If successful, this function sets *ppValue to point to a protectedÙH** sqlite3_value object containing the iVal'th value from the vector of ÙC** new row values stored as part of the UPDATE or INSERT change andÙE** returns SQLITE_OK. If the change is an UPDATE and does not includeÙE** a new value for the requested column, *ppValue is set to NULL and ÙI** SQLITE_OK returned. The name of the function comes from the fact that ÙH** this is similar to the "new.*" columns available to update or delete ¬** triggers.¢**ÙK** If some other error occurs (e.g. an OOM condition), an SQLite error codeÙ+** is returned and *ppValue is set to NULL.¢*/Ù$SQLITE_API int sqlite3changeset_new(Ù:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */Ù5  int iVal,                       /* Column number */ÙH  sqlite3_value **ppValue         /* OUT: New value (or NULL pointer) */¢); ¢/*ÙD** CAPI3REF: Obtain Conflicting Row Values From A Changeset IteratorÙ!** METHOD: sqlite3_changeset_iter¢**ÙF** This function should only be used with iterator objects passed to aÙF** conflict-handler callback by [sqlite3changeset_apply()] with eitherÙK** [SQLITE_CHANGESET_DATA] or [SQLITE_CHANGESET_CONFLICT]. If this functionÙL** is called on any other iterator, [SQLITE_MISUSE] is returned and *ppValue²** is set to NULL.¢**ÙM** Argument iVal must be greater than or equal to 0, and less than the numberÙE** of columns in the table affected by the current change. Otherwise,Ù:** [SQLITE_RANGE] is returned and *ppValue is set to NULL.¢**ÙE** If successful, this function sets *ppValue to point to a protectedÙ>** sqlite3_value object containing the iVal'th value from the ÙJ** "conflicting row" associated with the current conflict-handler callback¹** and returns SQLITE_OK.¢**ÙK** If some other error occurs (e.g. an OOM condition), an SQLite error codeÙ+** is returned and *ppValue is set to NULL.¢*/Ù)SQLITE_API int sqlite3changeset_conflict(Ù:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */Ù5  int iVal,                       /* Column number */ÙG  sqlite3_value **ppValue         /* OUT: Value from conflicting row */¢); ¢/*ÙF** CAPI3REF: Determine The Number Of Foreign Key Constraint ViolationsÙ!** METHOD: sqlite3_changeset_iter¢**ÙA** This function may only be called with an iterator passed to anÙG** SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this caseÙG** it sets the output variable to the total number of known foreign keyÙ@** violations in the destination database and returns SQLITE_OK.¢**Ù:** In all other cases this function returns SQLITE_MISUSE.¢*/Ù-SQLITE_API int sqlite3changeset_fk_conflicts(Ù:  sqlite3_changeset_iter *pIter,  /* Changeset iterator */ÙD  int *pnOut                      /* OUT: Number of FK violations */¢);  ¢/*Ù*** CAPI3REF: Finalize A Changeset IteratorÙ!** METHOD: sqlite3_changeset_iter¢**Ù?** This function is used to finalize an iterator allocated with¾** [sqlite3changeset_start()].¢**ÙE** This function should only be called on iterators created using theÙD** [sqlite3changeset_start()] function. If an application calls thisÙ<** function with an iterator passed to a conflict-handler byÙN** [sqlite3changeset_apply()], [SQLITE_MISUSE] is immediately returned and the¶** call has no effect.¢**ÙI** If an error was encountered within a call to an sqlite3changeset_xxx()ÙP** function (for example an [SQLITE_CORRUPT] in [sqlite3changeset_next()] or an ÙO** [SQLITE_NOMEM] in [sqlite3changeset_new()]) then an error code correspondingÙF** to that error is returned by this function. Otherwise, SQLITE_OK isÙB** returned. This is to allow the following pattern (pseudo-code):¢**¨** <pre>¾**   sqlite3changeset_start();Ù2**   while( SQLITE_ROW==sqlite3changeset_next() ){Ù#**     // Do something with change.¦**   }Ù&**   rc = sqlite3changeset_finalize();¹**   if( rc!=SQLITE_OK ){Ù **     // An error has occurred ¦**   }©** </pre>¢*/ÙHSQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter); ¢/*¿** CAPI3REF: Invert A Changeset¢**ÙM** This function is used to "invert" a changeset object. Applying an invertedÙJ** changeset to a database reverses the effects of applying the uninverted»** changeset. Specifically:¢**§** <ul>Ù9**   <li> Each DELETE change is changed to an INSERT, andÙ8**   <li> Each INSERT change is changed to a DELETE, andÙK**   <li> For each UPDATE change, the old.* and new.* values are exchanged.¨** </ul>¢**ÙI** This function does not change the order in which changes appear withinÙI** the changeset. It merely reverses the sense of each individual change.¢**ÙI** If successful, a pointer to a buffer containing the inverted changesetÙL** is stored in *ppOut, the size of the same buffer is stored in *pnOut, andÙH** SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut areÙ,** zeroed and an SQLite error code returned.¢**ÙK** It is the responsibility of the caller to eventually call sqlite3_free()ÙN** on the *ppOut pointer to free the buffer allocation following a successful ¹** call to this function.¢**ÙJ** WARNING/TODO: This function currently assumes that the input is a validÙ6** changeset. If it is not, the results are undefined.¢*/Ù'SQLITE_API int sqlite3changeset_invert(Ù7  int nIn, const void *pIn,       /* Input changeset */Ù=  int *pnOut, void **ppOut        /* OUT: Inverse of input */¢); ¢/*Ù.** CAPI3REF: Concatenate Two Changeset Objects¢**ÙH** This function is used to concatenate two changesets, A and B, into a ÙE** single changeset. The result is a changeset equivalent to applyingÙ(** changeset A followed by changeset B. ¢**Ù<** This function combines the two input changesets using an ÙI** sqlite3_changegroup object. Calling it produces similar results as the»** following code fragment:¢**¨** <pre>¿**   sqlite3_changegroup *pGrp;Ù)**   rc = sqlite3_changegroup_new(&pGrp);ÙC**   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nA, pA);ÙC**   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nB, pB);¹**   if( rc==SQLITE_OK ){Ù:**     rc = sqlite3changegroup_output(pGrp, pnOut, ppOut);«**   }else{²**     *ppOut = 0;²**     *pnOut = 0;¦**   }©** </pre>¢**ÙD** Refer to the sqlite3_changegroup documentation below for details.¢*/Ù'SQLITE_API int sqlite3changeset_concat(ÙD  int nA,                         /* Number of bytes in buffer pA */ÙP  void *pA,                       /* Pointer to buffer containing changeset A */ÙD  int nB,                         /* Number of bytes in buffer pB */ÙP  void *pB,                       /* Pointer to buffer containing changeset B */ÙP  int *pnOut,                     /* OUT: Number of bytes in output changeset */ÙO  void **ppOut                    /* OUT: Buffer containing output changeset */¢);  ¢/*¿** CAPI3REF: Changegroup Handle¢**Ù:** A changegroup is an object used to combine two or more ¾** [changesets] or [patchsets]¢*/Ù7typedef struct sqlite3_changegroup sqlite3_changegroup; ¢/*Ù,** CAPI3REF: Create A New Changegroup ObjectÙ#** CONSTRUCTOR: sqlite3_changegroup¢**ÙJ** An sqlite3_changegroup object is used to combine two or more changesetsÙM** (or patchsets) into a single changeset (or patchset). A single changegroupÙJ** object may combine changesets or patchsets, but not both. The output isÙ*** always in the same format as the input.¢**ÙJ** If successful, this function returns SQLITE_OK and populates (*pp) withÙM** a pointer to a new sqlite3_changegroup object before returning. The callerÙ>** should eventually free the returned object using a call to ÙH** sqlite3changegroup_delete(). If an error occurs, an SQLite error codeÙ:** (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.¢**ÙK** The usual usage pattern for an sqlite3_changegroup object is as follows:¢**§** <ul>ÙA**   <li> It is created using a call to sqlite3changegroup_new().¢**ÙH**   <li> Zero or more changesets (or patchsets) are added to the objectÙ.**        by calling sqlite3changegroup_add().¢**ÙL**   <li> The result of combining all input changesets together is obtained ÙG**        by the application via a call to sqlite3changegroup_output().¢**ÙL**   <li> The object is deleted using a call to sqlite3changegroup_delete().¨** </ul>¢**ÙM** Any number of calls to add() and output() may be made between the calls toÙ(** new() and delete(), and in any order.¢**Ù7** As well as the regular sqlite3changegroup_add() and ÙJ** sqlite3changegroup_output() functions, also available are the streamingÙO** versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().¢*/Ù@SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp); ¢/*Ù-** CAPI3REF: Add A Changeset To A Changegroup¾** METHOD: sqlite3_changegroup¢**ÙK** Add all changes within the changeset (or patchset) in buffer pData (sizeÙ$** nData bytes) to the changegroup. ¢**ÙK** If the buffer contains a patchset, then all prior calls to this functionÙL** on the same changegroup object must also have specified patchsets. Or, ifÙJ** the buffer contains a changeset, so must have the earlier calls to thisÙI** function. Otherwise, SQLITE_ERROR is returned and no changes are added¶** to the changegroup.¢**ÙL** Rows within the changeset and changegroup are identified by the values inÙH** their PRIMARY KEY columns. A change in the changeset is considered toÙJ** apply to the same row as a change already present in the changegroup ifÙ*** the two rows have the same primary key.¢**ÙD** Changes to rows that do not already appear in the changegroup areÙK** simply copied into it. Or, if both the new changeset and the changegroupÙH** contain changes that apply to a single row, the final contents of theÙ>** changegroup depends on the type of each change, as follows:¢**Ù<** <table border=1 style="margin-left:8ex;margin-right:8ex">Ù;**   <tr><th style="white-space:pre">Existing Change  </th>Ù;**       <th style="white-space:pre">New Change       </th>º**       <th>Output ChangeÙ#**   <tr><td>INSERT <td>INSERT <td>ÙG**       The new change is ignored. This case does not occur if the newÙH**       changeset was recorded immediately after the changesets alreadyÙ"**       added to the changegroup.Ù#**   <tr><td>INSERT <td>UPDATE <td>ÙI**       The INSERT change remains in the changegroup. The values in the ÙE**       INSERT change are modified as if the row was inserted by theÙF**       existing change and then updated according to the new change.Ù#**   <tr><td>INSERT <td>DELETE <td>ÙK**       The existing INSERT is removed from the changegroup. The DELETE is³**       not added.Ù#**   <tr><td>UPDATE <td>INSERT <td>ÙG**       The new change is ignored. This case does not occur if the newÙH**       changeset was recorded immediately after the changesets alreadyÙ"**       added to the changegroup.Ù#**   <tr><td>UPDATE <td>UPDATE <td>ÙK**       The existing UPDATE remains within the changegroup. It is amended ÙL**       so that the accompanying values are as if the row was updated once ÙA**       by the existing change and then again by the new change.Ù#**   <tr><td>UPDATE <td>DELETE <td>ÙE**       The existing UPDATE is replaced by the new DELETE within theµ**       changegroup.Ù#**   <tr><td>DELETE <td>INSERT <td>ÙG**       If one or more of the column values in the row inserted by theÙI**       new change differ from those in the row deleted by the existing ÙH**       change, the existing DELETE is replaced by an UPDATE within theÙI**       changegroup. Otherwise, if the inserted row is exactly the same ÙE**       as the deleted row, the existing DELETE is simply discarded.Ù#**   <tr><td>DELETE <td>UPDATE <td>ÙG**       The new change is ignored. This case does not occur if the newÙH**       changeset was recorded immediately after the changesets alreadyÙ"**       added to the changegroup.Ù#**   <tr><td>DELETE <td>DELETE <td>ÙG**       The new change is ignored. This case does not occur if the newÙH**       changeset was recorded immediately after the changesets alreadyÙ"**       added to the changegroup.«** </table>¢**ÙK** If the new changeset contains changes to a table that is already presentÙI** in the changegroup, then the number of columns and the position of theÙK** primary key columns for the table must be consistent. If this is not theÙG** case, this function fails with SQLITE_SCHEMA. If the input changesetÙJ** appears to be corrupt and the corruption is detected, SQLITE_CORRUPT isÙM** returned. Or, if an out-of-memory condition occurs during processing, thisÙF** function returns SQLITE_NOMEM. In all cases, if an error occurs theÙ2** final contents of the changegroup is undefined.¢**Ù-** If no error occurs, SQLITE_OK is returned.¢*/ÙTSQLITE_API int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData); ¢/*Ù<** CAPI3REF: Obtain A Composite Changeset From A Changegroup¾** METHOD: sqlite3_changegroup¢**ÙH** Obtain a buffer containing a changeset (or patchset) representing theÙH** current contents of the changegroup. If the inputs to the changegroupÙD** were themselves changesets, the output is a changeset. Or, if theÙ8** inputs were patchsets, the output is also a patchset.¢**Ù;** As with the output of the sqlite3session_changeset() andÙG** sqlite3session_patchset() functions, all changes related to a singleÙK** table are grouped together in the output of this function. Tables appearÙN** in the same order as for the very first changeset added to the changegroup.ÙJ** If the second or subsequent changesets added to the changegroup containÙI** changes for tables that do not appear in the first changeset, they areÙG** appended onto the end of the output changeset, again in the order inÙ$** which they are first encountered.¢**ÙF** If an error occurs, an SQLite error code is returned and the outputÙG** variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OKÙE** is returned and the output variables are set to the size of and a ÙE** pointer to the output buffer, respectively. In this case it is theÙE** responsibility of the caller to eventually free the buffer using aº** call to sqlite3_free().¢*/Ù)SQLITE_API int sqlite3changegroup_output(·  sqlite3_changegroup*,ÙK  int *pnData,                    /* OUT: Size of output buffer in bytes */ÙE  void **ppData                   /* OUT: Pointer to output buffer */¢); ¢/*Ù(** CAPI3REF: Delete A Changegroup ObjectÙ"** DESTRUCTOR: sqlite3_changegroup¢*/Ù@SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*); ¢/*Ù,** CAPI3REF: Apply A Changeset To A Database¢**ÙJ** Apply a changeset or patchset to a database. These functions attempt toÙM** update the "main" database attached to handle db with the changes found inÙ<** the changeset passed via the second and third arguments. ¢**ÙI** The fourth argument (xFilter) passed to these functions is the "filterÙM** callback". If it is not NULL, then for each table affected by at least oneÙ?** change in the changeset, the filter callback is invoked withÙK** the table name as the second argument, and a copy of the context pointerÙF** passed as the sixth argument as the first. If the "filter callback"ÙK** returns zero, then no attempt is made to apply any changes to the table.ÙH** Otherwise, if the return value is non-zero or the xFilter argument toÙ;** is NULL, all changes related to the table are attempted.¢**ÙM** For each table that is not excluded by the filter callback, this function ÙJ** tests that the target database contains a compatible table. A table is Ù:** considered compatible if all of the following are true:¢**§** <ul>ÙB**   <li> The table has the same name as the name recorded in the ¸**        changeset, andÙD**   <li> The table has at least as many columns as recorded in the ¸**        changeset, andÙD**   <li> The table has primary key columns in the same position as Ù$**        recorded in the changeset.¨** </ul>¢**ÙG** If there is no compatible table, it is not an error, but none of theÙM** changes associated with the table are applied. A warning message is issuedÙM** via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At mostÙ>** one such warning is issued for each table in the changeset.¢**ÙM** For each change for which there is a compatible table, an attempt is made ÙJ** to modify the table contents according to the UPDATE, INSERT or DELETE ÙG** change. If a change cannot be applied cleanly, the conflict handler ÙL** function passed as the fifth argument to sqlite3changeset_apply() may be ÙN** invoked. A description of exactly when the conflict handler is invoked for Ù ** each type of change is below.¢**ÙM** Unlike the xFilter argument, xConflict may not be passed NULL. The resultsÙK** of passing anything other than a valid function pointer as the xConflictº** argument are undefined.¢**ÙI** Each time the conflict handler function is invoked, it must return oneÙ;** of [SQLITE_CHANGESET_OMIT], [SQLITE_CHANGESET_ABORT] or ÙL** [SQLITE_CHANGESET_REPLACE]. SQLITE_CHANGESET_REPLACE may only be returnedÙB** if the second argument passed to the conflict handler is eitherÙN** SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handlerÙI** returns an illegal value, any changes already made are rolled back andÙI** the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different ÙG** actions are taken by sqlite3changeset_apply() depending on the valueÙI** returned by each invocation of the conflict-handler function. Refer toÙ#** the documentation for the three Ù?** [SQLITE_CHANGESET_OMIT|available return values] for details.¢**§** <dl>¹** <dt>DELETE Changes<dd>ÙH**   For each DELETE change, the function checks if the target database ÙG**   contains a row with the same primary key value (or values) as the ÙM**   original row values stored in the changeset. If it does, and the values ÙK**   stored in all non-primary key columns also match the values stored in Ù?**   the changeset the row is deleted from the target database.¢**ÙK**   If a row with matching primary key values is found, but one or more ofÙL**   the non-primary key fields contains a value different from the originalÙH**   row value stored in the changeset, the conflict-handler function isÙH**   invoked with [SQLITE_CHANGESET_DATA] as the second argument. If theÙH**   database table has more columns than are recorded in the changeset,ÙI**   only the values of those non-primary key fields are compared againstÙH**   the current database contents - any trailing database table columns±**   are ignored.¢**ÙI**   If no row with matching primary key values is found in the database,ÙN**   the conflict-handler function is invoked with [SQLITE_CHANGESET_NOTFOUND]Ù#**   passed as the second argument.¢**ÙO**   If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINTÙI**   (which can only happen if a foreign key constraint is violated), theÙL**   conflict-handler function is invoked with [SQLITE_CHANGESET_CONSTRAINT]ÙK**   passed as the second argument. This includes the case where the DELETEÙK**   operation is attempted because an earlier call to the conflict handlerÙ2**   function returned [SQLITE_CHANGESET_REPLACE].¢**¹** <dt>INSERT Changes<dd>ÙJ**   For each INSERT change, an attempt is made to insert the new row intoÙF**   the database. If the changeset row contains fewer fields than theÙI**   database table, the trailing fields are populated with their default¬**   values.¢**ÙI**   If the attempt to insert the row fails because the database already ÙJ**   contains a row with the same primary key values, the conflict handlerÙ9**   function is invoked with the second argument set to Ù!**   [SQLITE_CHANGESET_CONFLICT].¢**ÙL**   If the attempt to insert the row fails because of some other constraintÙK**   violation (e.g. NOT NULL or UNIQUE), the conflict handler function is ÙK**   invoked with the second argument set to [SQLITE_CHANGESET_CONSTRAINT].ÙO**   This includes the case where the INSERT operation is re-attempted because Ù?**   an earlier call to the conflict handler function returned Ù **   [SQLITE_CHANGESET_REPLACE].¢**¹** <dt>UPDATE Changes<dd>ÙH**   For each UPDATE change, the function checks if the target database ÙG**   contains a row with the same primary key value (or values) as the ÙM**   original row values stored in the changeset. If it does, and the values ÙI**   stored in all modified non-primary key columns also match the valuesÙK**   stored in the changeset the row is updated within the target database.¢**ÙK**   If a row with matching primary key values is found, but one or more ofÙK**   the modified non-primary key fields contains a value different from anÙN**   original row value stored in the changeset, the conflict-handler functionÙJ**   is invoked with [SQLITE_CHANGESET_DATA] as the second argument. SinceÙK**   UPDATE changes only contain values for non-primary key fields that areÙK**   to be modified, only those fields need to match the original values toÙ?**   avoid the SQLITE_CHANGESET_DATA conflict-handler callback.¢**ÙI**   If no row with matching primary key values is found in the database,ÙN**   the conflict-handler function is invoked with [SQLITE_CHANGESET_NOTFOUND]Ù#**   passed as the second argument.¢**Ù>**   If the UPDATE operation is attempted, but SQLite returns ÙF**   SQLITE_CONSTRAINT, the conflict-handler function is invoked with ÙA**   [SQLITE_CHANGESET_CONSTRAINT] passed as the second argument.ÙJ**   This includes the case where the UPDATE operation is attempted after Ù>**   an earlier call to the conflict handler function returnedÙ"**   [SQLITE_CHANGESET_REPLACE].  ¨** </dl>¢**ÙJ** It is safe to execute SQL statements, including those that write to theÙJ** table that the callback related to, from within the xConflict callback.ÙB** This can be used to further customize the applications conflict·** resolution strategy.¢**ÙO** All changes made by these functions are enclosed in a savepoint transaction.ÙI** If any other error (aside from a constraint failure when attempting toÙJ** write to the target database) occurs, then the savepoint transaction isÙL** rolled back, restoring the target database to its original state, and an ¾** SQLite error code returned.¢**ÙF** If the output parameters (ppRebase) and (pnRebase) are non-NULL andÙN** the input is a changeset (not a patchset), then sqlite3changeset_apply_v2()ÙH** may set (*ppRebase) to point to a "rebase" that may be used with the ÙI** sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase)ÙM** is set to the size of the buffer in bytes. It is the responsibility of theÙM** caller to eventually free any such buffer using sqlite3_free(). The bufferÙL** is only allocated and populated if one or more conflicts were encounteredÙL** while applying the patchset. See comments surrounding the sqlite3_rebaser¼** APIs for further details.¢**ÙK** The behavior of sqlite3changeset_apply_v2() and its streaming equivalentÙ.** may be modified by passing a combination ofÙN** [SQLITE_CHANGESETAPPLY_NOSAVEPOINT | supported flags] as the 9th parameter.¢**ÙM** Note that the sqlite3changeset_apply_v2() API is still <b>experimental</b>Ù#** and therefore subject to change.¢*/Ù&SQLITE_API int sqlite3changeset_apply(ÙP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ÙB  int nChangeset,                 /* Size of changeset in bytes */Ù6  void *pChangeset,               /* Changeset blob */°  int(*xFilter)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ù2    const char *zTab              /* Table name */¤  ),²  int(*xConflict)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */ÙK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ÙM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */¤  ),ÙJ  void *pCtx                      /* First argument passed to xConflict */¢);Ù)SQLITE_API int sqlite3changeset_apply_v2(ÙP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ÙB  int nChangeset,                 /* Size of changeset in bytes */Ù6  void *pChangeset,               /* Changeset blob */°  int(*xFilter)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ù2    const char *zTab              /* Table name */¤  ),²  int(*xConflict)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */ÙK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ÙM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */¤  ),ÙJ  void *pCtx,                     /* First argument passed to xConflict */Ù8  void **ppRebase, int *pnRebase, /* OUT: Rebase data */ÙL  int flags                       /* Combination of SESSION_APPLY_* flags */¢); ¢/*Ù0** CAPI3REF: Flags for sqlite3changeset_apply_v2¢**Ù:** The following flags may passed via the 9th parameter toÙD** [sqlite3changeset_apply_v2] and [sqlite3changeset_apply_v2_strm]:¢**§** <dl>Ù-** <dt>SQLITE_CHANGESETAPPLY_NOSAVEPOINT <dd>ÙF**   Usually, the sessions module encloses all operations performed byÙI**   a single call to apply_v2() or apply_v2_strm() in a [SAVEPOINT]. TheÙH**   SAVEPOINT is committed if the changeset or patchset is successfullyÙE**   applied, or rolled back if an error occurs. Specifying this flagÙL**   causes the sessions module to omit this savepoint. In this case, if theÙL**   caller has an open transaction or savepoint when apply_v2() is called, ÙF**   it may revert the partially applied changeset by rolling it back.¢*/Ù2#define SQLITE_CHANGESETAPPLY_NOSAVEPOINT   0x0001 £/* Ù5** CAPI3REF: Constants Passed To The Conflict Handler¢**ÙJ** Values that may be passed as the second argument to a conflict-handler.¢**§** <dl>Ù ** <dt>SQLITE_CHANGESET_DATA<dd>ÙO**   The conflict handler is invoked with CHANGESET_DATA as the second argumentÙI**   when processing a DELETE or UPDATE change if a row with the requiredÙJ**   PRIMARY KEY fields is present in the database, but one or more other ÙH**   (non primary-key) fields modified by the update do not contain the ¾**   expected "before" values.£** ÙM**   The conflicting row, in this case, is the database row with the matching±**   primary key.£** Ù$** <dt>SQLITE_CHANGESET_NOTFOUND<dd>ÙJ**   The conflict handler is invoked with CHANGESET_NOTFOUND as the secondÙI**   argument when processing a DELETE or UPDATE change if a row with theÙ@**   required PRIMARY KEY fields is not present in the database.£** ÙJ**   There is no conflicting row in this case. The results of invoking theÙ3**   sqlite3changeset_conflict() API are undefined.£** Ù$** <dt>SQLITE_CHANGESET_CONFLICT<dd>ÙH**   CHANGESET_CONFLICT is passed as the second argument to the conflictÙM**   handler while processing an INSERT change if the operation would result Ù%**   in duplicate primary key values.£** ÙK**   The conflicting row in this case is the database row with the matching±**   primary key.¢**Ù'** <dt>SQLITE_CHANGESET_FOREIGN_KEY<dd>ÙL**   If foreign key handling is enabled, and applying a changeset leaves theÙI**   database in a state containing foreign key violations, the conflict ÙI**   handler is invoked with CHANGESET_FOREIGN_KEY as the second argumentÙL**   exactly once before the changeset is committed. If the conflict handlerÙI**   returns CHANGESET_OMIT, the changes, including those that caused theÙG**   foreign key constraint violation, are committed. Or, if it returnsÙ3**   CHANGESET_ABORT, the changeset is rolled back.¢**ÙM**   No current or conflicting row information is provided. The only functionÙI**   it is possible to call on the supplied sqlite3_changeset_iter handleÙ(**   is sqlite3changeset_fk_conflicts().£** Ù&** <dt>SQLITE_CHANGESET_CONSTRAINT<dd>ÙL**   If any other constraint violation occurs while applying a change (i.e. ÙF**   a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is Ù>**   invoked with CHANGESET_CONSTRAINT as the second argument.£** ÙJ**   There is no conflicting row in this case. The results of invoking theÙ3**   sqlite3changeset_conflict() API are undefined.¢**¨** </dl>¢*/Ù&#define SQLITE_CHANGESET_DATA        1Ù&#define SQLITE_CHANGESET_NOTFOUND    2Ù&#define SQLITE_CHANGESET_CONFLICT    3Ù&#define SQLITE_CHANGESET_CONSTRAINT  4Ù&#define SQLITE_CHANGESET_FOREIGN_KEY 5 £/* Ù7** CAPI3REF: Constants Returned By The Conflict Handler¢**ÙM** A conflict handler callback must return one of the following three values.¢**§** <dl>Ù ** <dt>SQLITE_CHANGESET_OMIT<dd>ÙM**   If a conflict handler returns this value no special action is taken. TheÙH**   change that caused the conflict is not applied. The session module Ù3**   continues to the next change in the changeset.¢**Ù#** <dt>SQLITE_CHANGESET_REPLACE<dd>ÙK**   This value may only be returned if the second argument to the conflictÙL**   handler was SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If thisÙI**   is not the case, any changes applied so far are rolled back and the Ù<**   call to sqlite3changeset_apply() returns SQLITE_MISUSE.¢**ÙJ**   If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflictÙN**   handler, then the conflicting row is either updated or deleted, depending»**   on the type of change.¢**ÙN**   If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflictÙI**   handler, then the conflicting row is removed from the database and aÙN**   second attempt to apply the change is made. If this second attempt fails,ÙD**   the original row is restored to the database before continuing.¢**Ù!** <dt>SQLITE_CHANGESET_ABORT<dd>ÙK**   If this value is returned, any changes applied so far are rolled back ÙC**   and the call to sqlite3changeset_apply() returns SQLITE_ABORT.¨** </dl>¢*/Ù%#define SQLITE_CHANGESET_OMIT       0Ù%#define SQLITE_CHANGESET_REPLACE    1Ù%#define SQLITE_CHANGESET_ABORT      2 £/* Ù ** CAPI3REF: Rebasing changesets¯** EXPERIMENTAL¢**ÙC** Suppose there is a site hosting a database in state S0. And thatÙC** modifications are made that move that database to state S1 and aÙF** changeset recorded (the "local" changeset). Then, a changeset basedÙD** on S0 is received from another site (the "remote" changeset) and Ù:** applied to the database. The database is then in state Ù?** (S1+"remote"), where the exact state depends on any conflictÙG** resolution decisions (OMIT or REPLACE) made while applying "remote".Ù?** Rebasing a changeset is to update it to take those conflict Ù@** resolution decisions into account, so that the same conflictsÙ8** do not have to be resolved elsewhere in the network. ¢**ÙB** For example, if both the local and remote changesets contain anÙA** INSERT of the same key on "CREATE TABLE t1(a PRIMARY KEY, b)":¢**Ù,**   local:  INSERT INTO t1 VALUES(1, 'v1');Ù,**   remote: INSERT INTO t1 VALUES(1, 'v2');¢**ÙD** and the conflict resolution is REPLACE, then the INSERT change isÙC** removed from the local changeset (it was overridden). Or, if theÙG** conflict resolution was "OMIT", then the local changeset is modified¶** to instead contain:¢**Ù.**           UPDATE t1 SET b = 'v2' WHERE a=1;¢**Ù=** Changes within the local changeset are rebased as follows:¢**§** <dl>·** <dt>Local INSERT<dd>ÙB**   This may only conflict with a remote INSERT. If the conflict ÙB**   resolution was OMIT, then add an UPDATE change to the rebasedÙ?**   changeset. Or, if the conflict resolution was REPLACE, addÙ&**   nothing to the rebased changeset.¢**·** <dt>Local DELETE<dd>ÙH**   This may conflict with a remote UPDATE or DELETE. In both cases theÙD**   only possible resolution is OMIT. If the remote operation was aÙG**   DELETE, then add no change to the rebased changeset. If the remoteÙI**   operation was an UPDATE, then the old.* fields of change are updatedÙ/**   to reflect the new.* values in the UPDATE.¢**·** <dt>Local UPDATE<dd>ÙF**   This may conflict with a remote UPDATE or DELETE. If it conflictsÙI**   with a DELETE, and the conflict resolution was OMIT, then the updateÙH**   is changed into an INSERT. Any undefined values in the new.* recordÙE**   from the update change are filled in using the old.* values fromÙH**   the conflicting DELETE. Or, if the conflict resolution was REPLACE,ÙD**   the UPDATE change is simply omitted from the rebased changeset.¢**ÙI**   If conflict is with a remote UPDATE and the resolution is OMIT, thenÙF**   the old.* values are rebased using the new.* values in the remoteÙH**   change. Or, if the resolution is REPLACE, then the change is copiedÙG**   into the rebased changeset with updates to columns also updated byÙK**   the conflicting remote UPDATE removed. If this means no columns would Ù'**   be updated, the change is omitted.¨** </dl>¢**ÙA** A local change may be rebased against multiple remote changes ÙB** simultaneously. If a single key is modified by multiple remote ÙF** changesets, they are combined as follows before the local changeset®** is rebased:¢**§** <ul>ÙA**    <li> If there has been one or more REPLACE resolutions on aÙ5**         key, it is rebased according to a REPLACE.¢**ÙC**    <li> If there have been no REPLACE resolutions on a key, thenÙF**         the local changeset is rebased according to the most recentÙ#**         of the OMIT resolutions.¨** </ul>¢**ÙF** Note that conflict resolutions from multiple remote changesets are ÙF** combined on a per-field basis, not per-row. This means that in the ÙF** case of multiple remote UPDATE operations, some fields of a single ÙH** local change may be rebased for REPLACE while others are rebased for ¨** OMIT.¢**ÙH** In order to rebase a local changeset, the remote changeset must firstÙI** be applied to the local database using sqlite3changeset_apply_v2() andÙ3** the buffer of rebase information captured. Then:¢**§** <ol>Ù:**   <li> An sqlite3_rebaser object is created by calling Ù"**        sqlite3rebaser_create().ÙK**   <li> The new object is configured with the rebase buffer obtained fromÙL**        sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure().ÙI**        If the local changeset is to be rebased against multiple remoteÙF**        changesets, then sqlite3rebaser_configure() should be calledÙ=**        multiple times, in the same order that the multipleÙ6**        sqlite3changeset_apply_v2() calls were made.ÙM**   <li> Each local changeset is rebased by calling sqlite3rebaser_rebase().Ù:**   <li> The sqlite3_rebaser object is deleted by callingÙ"**        sqlite3rebaser_delete().¨** </ol>¢*/Ù/typedef struct sqlite3_rebaser sqlite3_rebaser; ¢/*Ù/** CAPI3REF: Create a changeset rebaser object.¯** EXPERIMENTAL¢**ÙJ** Allocate a new changeset rebaser object. If successful, set (*ppNew) toÙG** point to the new object and return SQLITE_OK. Otherwise, if an errorÙL** occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) ¬** to NULL. ¢*/Ù>SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew); ¢/*Ù2** CAPI3REF: Configure a changeset rebaser object.¯** EXPERIMENTAL¢**ÙH** Configure the changeset rebaser object to rebase changesets accordingÙH** to the conflict resolutions described by buffer pRebase (size nRebaseÙ@** bytes), which must have been obtained from a previous call to¿** sqlite3changeset_apply_v2().¢*/Ù(SQLITE_API int sqlite3rebaser_configure(´  sqlite3_rebaser*, Ù"  int nRebase, const void *pRebase£);  ¢/*¿** CAPI3REF: Rebase a changeset¯** EXPERIMENTAL¢**ÙG** Argument pIn must point to a buffer containing a changeset nIn bytesÙF** in size. This function allocates and populates a buffer with a copyÙI** of the changeset rebased rebased according to the configuration of theÙG** rebaser object passed as the first argument. If successful, (*ppOut)ÙI** is set to point to the new buffer containing the rebased changset and ÙB** (*pnOut) to its size in bytes and SQLITE_OK returned. It is theÙG** responsibility of the caller to eventually free the new buffer usingÙG** sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut)Ù5** are set to zero and an SQLite error code returned.¢*/Ù%SQLITE_API int sqlite3rebaser_rebase(³  sqlite3_rebaser*,¼  int nIn, const void *pIn, »  int *pnOut, void **ppOut ¢); ¢/*Ù/** CAPI3REF: Delete a changeset rebaser object.¯** EXPERIMENTAL¢**ÙJ** Delete the changeset rebaser object and all associated resources. ThereÙE** should be one call to this function for each successful invocation¾** of sqlite3rebaser_create().¢*/Ù;SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p);  ¢/*Ù1** CAPI3REF: Streaming Versions of API functions.¢**ÙL** The six streaming API xxx_strm() functions serve similar purposes to the Ù-** corresponding non-streaming API functions:¢**Ù<** <table border=1 style="margin-left:8ex;margin-right:8ex">Ù@**   <tr><th>Streaming function<th>Non-streaming equivalent</th>ÙE**   <tr><td>sqlite3changeset_apply_strm<td>[sqlite3changeset_apply] ÙK**   <tr><td>sqlite3changeset_apply_strm_v2<td>[sqlite3changeset_apply_v2] ÙG**   <tr><td>sqlite3changeset_concat_strm<td>[sqlite3changeset_concat] ÙG**   <tr><td>sqlite3changeset_invert_strm<td>[sqlite3changeset_invert] ÙE**   <tr><td>sqlite3changeset_start_strm<td>[sqlite3changeset_start] ÙI**   <tr><td>sqlite3session_changeset_strm<td>[sqlite3session_changeset] ÙG**   <tr><td>sqlite3session_patchset_strm<td>[sqlite3session_patchset] «** </table>¢**ÙI** Non-streaming functions that accept changesets (or patchsets) as inputÙM** require that the entire changeset be stored in a single buffer in memory. ÙK** Similarly, those that return a changeset or patchset do so by returning ÙH** a pointer to a single large buffer allocated using sqlite3_malloc(). ÙH** Normally this is convenient. However, if an application running in a ÙJ** low-memory environment is required to handle very large changesets, theÙC** large contiguous memory allocations required can become onerous.¢**ÙJ** In order to avoid this problem, instead of a single large buffer, inputÙL** is passed to a streaming API functions by way of a callback function thatÙK** the sessions module invokes to incrementally request input data as it isÙD** required. In all cases, a pair of API function parameters such as¢**©**  <pre>¾**  &nbsp;     int nChangeset,Ù **  &nbsp;     void *pChangeset,ª**  </pre>¢**²** Is replaced by:¢**©**  <pre>ÙB**  &nbsp;     int (*xInput)(void *pIn, void *pData, int *pnData),¹**  &nbsp;     void *pIn,ª**  </pre>¢**ÙM** Each time the xInput callback is invoked by the sessions module, the firstÙM** argument passed is a copy of the supplied pIn context pointer. The second ÙL** argument, pData, points to a buffer (*pnData) bytes in size. Assuming no ÙL** error occurs the xInput method should copy up to (*pnData) bytes of data ÙJ** into the buffer and set (*pnData) to the actual number of bytes copied ÙO** before returning SQLITE_OK. If the input is completely exhausted, (*pnData) ÙM** should be set to zero to indicate this. Or, if an error occurs, an SQLite ÙM** error code should be returned. In all cases, if an xInput callback returnsÙG** an error, all processing is abandoned and the streaming API functionÙ2** returns a copy of the error code to the caller.¢**ÙK** In the case of sqlite3changeset_start_strm(), the xInput callback may beÙI** invoked by the sessions module at any point during the lifetime of theÙM** iterator. If such an xInput callback returns an error, the iterator entersÙF** an error state, whereby all subsequent calls to iterator functions ÙC** immediately fail with the same error code as returned by xInput.¢**ÙK** Similarly, streaming API functions that return changesets (or patchsets)ÙG** return them in chunks by way of a callback function instead of via aÙL** pointer to a single large buffer. In this case, a pair of parameters such¦** as:¢**©**  <pre>Ù **  &nbsp;     int *pnChangeset,Ù"**  &nbsp;     void **ppChangeset,ª**  </pre>¢**²** Is replaced by:¢**©**  <pre>ÙH**  &nbsp;     int (*xOutput)(void *pOut, const void *pData, int nData),¹**  &nbsp;     void *pOutª**  </pre>¢**ÙG** The xOutput callback is invoked zero or more times to return data toÙL** the application. The first parameter passed to each call is a copy of theÙI** pOut pointer supplied by the application. The second parameter, pData,ÙH** points to a buffer nData bytes in size containing the chunk of outputÙJ** data being returned. If the xOutput callback successfully processes theÙL** supplied data, it should return SQLITE_OK to indicate success. Otherwise,ÙI** it should return some other SQLite error code. In this case processingÙI** is immediately abandoned and the streaming API function returns a copyÙ0** of the xOutput error code to the application.¢**ÙH** The sessions module never invokes an xOutput callback with the third ÙH** parameter set to a value less than or equal to zero. Other than this,ÙH** no guarantees are made as to the size of the chunks of data returned.¢*/Ù+SQLITE_API int sqlite3changeset_apply_strm(ÙP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ÙJ  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */ÙP  void *pIn,                                          /* First arg for xInput */°  int(*xFilter)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ù2    const char *zTab              /* Table name */¤  ),²  int(*xConflict)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */ÙK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ÙM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */¤  ),ÙJ  void *pCtx                      /* First argument passed to xConflict */¢);Ù.SQLITE_API int sqlite3changeset_apply_v2_strm(ÙP  sqlite3 *db,                    /* Apply change to "main" db of this handle */ÙJ  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */ÙP  void *pIn,                                          /* First arg for xInput */°  int(*xFilter)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */Ù2    const char *zTab              /* Table name */¤  ),²  int(*xConflict)(ÙE    void *pCtx,                   /* Copy of sixth arg to _apply() */ÙK    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */ÙM    sqlite3_changeset_iter *p     /* Handle describing change and conflict */¤  ),ÙJ  void *pCtx,                     /* First argument passed to xConflict */Ù!  void **ppRebase, int *pnRebase,«  int flags¢);Ù,SQLITE_API int sqlite3changeset_concat_strm(Ù6  int (*xInputA)(void *pIn, void *pData, int *pnData),­  void *pInA,Ù6  int (*xInputB)(void *pIn, void *pData, int *pnData),­  void *pInB,Ù;  int (*xOutput)(void *pOut, const void *pData, int nData),¬  void *pOut¢);Ù,SQLITE_API int sqlite3changeset_invert_strm(Ù5  int (*xInput)(void *pIn, void *pData, int *pnData),¬  void *pIn,Ù;  int (*xOutput)(void *pOut, const void *pData, int nData),¬  void *pOut¢);Ù+SQLITE_API int sqlite3changeset_start_strm(¾  sqlite3_changeset_iter **pp,Ù5  int (*xInput)(void *pIn, void *pData, int *pnData),«  void *pIn¢);Ù-SQLITE_API int sqlite3session_changeset_strm(¼  sqlite3_session *pSession,Ù;  int (*xOutput)(void *pOut, const void *pData, int nData),¬  void *pOut¢);Ù,SQLITE_API int sqlite3session_patchset_strm(¼  sqlite3_session *pSession,Ù;  int (*xOutput)(void *pOut, const void *pData, int nData),¬  void *pOut¢);ÙASQLITE_API int sqlite3changegroup_add_strm(sqlite3_changegroup*, Ù7    int (*xInput)(void *pIn, void *pData, int *pnData),­    void *pIn¢);ÙCSQLITE_API int sqlite3changegroup_output_strm(sqlite3_changegroup*,Ù>    int (*xOutput)(void *pOut, const void *pData, int nData), ®    void *pOut¢);Ù*SQLITE_API int sqlite3rebaser_rebase_strm(¼  sqlite3_rebaser *pRebaser,Ù5  int (*xInput)(void *pIn, void *pData, int *pnData),¬  void *pIn,Ù;  int (*xOutput)(void *pOut, const void *pData, int nData),¬  void *pOut¢);  ¢/*Ù-** Make sure we can call this stuff from C++.¢*/¥#if 0¡}¦#endif ÙL#endif  /* !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION) */ Ù,/******** End of sqlite3session.h *********/Ù&/******** Begin file fts5.h *********/¢/*®** 2014 May 31¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙI** Interfaces to extend FTS5. Using the interfaces defined in this file, ½** FTS5 may be extended with:¢**¿**     * custom tokenizers, andÙ$**     * custom auxiliary functions.¢*/  ¯#ifndef _FTS5_H¯#define _FTS5_H  ¥#if 0¬extern "C" {¦#endif ÙJ/*************************************************************************½** CUSTOM AUXILIARY FUNCTIONS¢**ÙK** Virtual table implementations may overload SQL functions by implementingÙ-** the sqlite3_module.xFindFunction() method.¢*/ Ù1typedef struct Fts5ExtensionApi Fts5ExtensionApi;Ù'typedef struct Fts5Context Fts5Context;Ù-typedef struct Fts5PhraseIter Fts5PhraseIter; Ù(typedef void (*fts5_extension_function)(ÙJ  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */ÙK  Fts5Context *pFts,              /* First arg to pass to pApi functions */ÙJ  sqlite3_context *pCtx,          /* Context for returning result/error */ÙI  int nVal,                       /* Number of values in apVal[] array */ÙC  sqlite3_value **apVal           /* Array of trailing arguments */¢); ·struct Fts5PhraseIter {¹  const unsigned char *a;¹  const unsigned char *b;¢}; ¢/*º** EXTENSION API FUNCTIONS¢**³** xUserData(pFts):ÙE**   Return a copy of the context pointer the extension function was µ**   registered with.¢**Ù)** xColumnTotalSize(pFts, iCol, pnToken):ÙF**   If parameter iCol is less than zero, set output variable *pnTokenÙD**   to the total number of tokens in the FTS5 table. Or, if iCol isÙJ**   non-negative but less than the number of columns in the table, returnÙH**   the total number of tokens in column iCol, considering all rows in ´**   the FTS5 table.¢**ÙH**   If parameter iCol is greater than or equal to the number of columnsÙI**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.ÙH**   an OOM condition or IO error), an appropriate SQLite error code is ®**   returned.¢**¶** xColumnCount(pFts):Ù/**   Return the number of columns in the table.¢**Ù$** xColumnSize(pFts, iCol, pnToken):ÙF**   If parameter iCol is less than zero, set output variable *pnTokenÙE**   to the total number of tokens in the current row. Or, if iCol isÙG**   non-negative but less than the number of columns in the table, setÙH**   *pnToken to the number of tokens in column iCol of the current row.¢**ÙH**   If parameter iCol is greater than or equal to the number of columnsÙI**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.ÙH**   an OOM condition or IO error), an appropriate SQLite error code is ®**   returned.¢**ÙF**   This function may be quite inefficient if used with an FTS5 tableÙ,**   created with the "columnsize=0" option.¢**¯** xColumnText:ÙF**   This function attempts to retrieve the text of column iCol of theÙG**   current document. If successful, (*pz) is set to point to a bufferÙM**   containing the text in utf-8 encoding, (*pn) is set to the size in bytesÙI**   (not characters) of the buffer and SQLITE_OK is returned. Otherwise,ÙN**   if an error occurs, an SQLite error code is returned and the final valuesÙ&**   of (*pz) and (*pn) are undefined.¢**°** xPhraseCount:ÙC**   Returns the number of phrases in the current query expression.¢**¯** xPhraseSize:ÙI**   Returns the number of tokens in phrase iPhrase of the query. PhrasesÙ%**   are numbered starting from zero.¢**®** xInstCount:ÙI**   Set *pnInst to the total number of occurrences of all phrases withinÙI**   the query within the current row. Return SQLITE_OK if successful, orÙ:**   an error code (i.e. SQLITE_NOMEM) if an error occurs.¢**ÙK**   This API can be quite slow if used with an FTS5 table created with theÙK**   "detail=none" or "detail=column" option. If the FTS5 table is created ÙH**   with either "detail=none" or "detail=column" and "content=" option ÙI**   (i.e. if it is a contentless table), then this API always returns 0.¢**©** xInst:ÙG**   Query for the details of phrase match iIdx within the current row.ÙI**   Phrase matches are numbered starting from zero, so the iIdx argumentÙG**   should be greater than or equal to zero and smaller than the value¼**   output by xInstCount().¢**ÙL**   Usually, output parameter *piPhrase is set to the phrase number, *piColÙH**   to the column in which it occurs and *piOff the token offset of theÙI**   first token of the phrase. The exception is if the table was createdÙG**   with the offsets=0 option specified. In this case *piOff is always¯**   set to -1.¢**ÙK**   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) ¸**   if an error occurs.¢**ÙK**   This API can be quite slow if used with an FTS5 table created with theÙ.**   "detail=none" or "detail=column" option. ¢**ª** xRowid:Ù***   Returns the rowid of the current row.¢**­** xTokenize:ÙC**   Tokenize text using the tokenizer belonging to the FTS5 table.¢**Ù6** xQueryPhrase(pFts5, iPhrase, pUserData, xCallback):ÙH**   This API function is used to query the FTS table for phrase iPhraseÙ?**   of the current query. Specifically, a query equivalent to:¢**ÙA**       ... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid¢**ÙD**   with $p set to a phrase equivalent to the phrase iPhrase of theÙA**   current query is executed. Any column filter that applies toÙE**   phrase iPhrase of the current query is included in $p. For each ÙF**   row visited, the callback function passed as the fourth argument ÙD**   is invoked. The context and API objects passed to the callback ÙG**   function may be used to access the properties of each matched row.ÙF**   Invoking Api.xUserData() returns a copy of the pointer passed as Ù%**   the third argument to pUserData.¢**ÙI**   If the callback function returns any value other than SQLITE_OK, theÙJ**   query is abandoned and the xQueryPhrase function returns immediately.ÙJ**   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.Ù5**   Otherwise, the error code is propagated upwards.¢**ÙM**   If the query runs to completion without incident, SQLITE_OK is returned.ÙI**   Or, if some error occurs before the query completes or is aborted byÙ4**   the callback, an SQLite error code is returned.¢**¢**Ù$** xSetAuxdata(pFts5, pAux, xDelete)¢**ÙO**   Save the pointer passed as the second argument as the extension functions ÙN**   "auxiliary data". The pointer may then be retrieved by the current or anyÙJ**   future invocation of the same fts5 extension function made as part ofÙ9**   of the same MATCH query using the xGetAuxdata() API.¢**ÙJ**   Each extension function is allocated a single auxiliary data slot forÙM**   each FTS query (MATCH expression). If the extension function is invoked ÙI**   more than once for a single FTS query, then all invocations share a Ù#**   single auxiliary data context.¢**ÙH**   If there is already an auxiliary data pointer when this function isÙL**   invoked, then it is replaced by the new pointer. If an xDelete callbackÙI**   was specified along with the original pointer, it is invoked at this«**   point.¢**ÙF**   The xDelete callback, if one is specified, is also invoked on theÙ>**   auxiliary data pointer after the FTS5 query has finished.¢**ÙH**   If an error (e.g. an OOM condition) occurs within this function, anÙI**   the auxiliary data is set to NULL and an error code returned. If theÙH**   xDelete parameter was not NULL, it is invoked on the auxiliary data¾**   pointer before returning.¢**¢**½** xGetAuxdata(pFts5, bClear)¢**ÙG**   Returns the current auxiliary data pointer for the fts5 extension Ù8**   function. See the xSetAuxdata() method for details.¢**ÙK**   If the bClear argument is non-zero, then the auxiliary data is clearedÙJ**   (set to NULL) before this function returns. In this case the xDelete,¼**   if any, is not invoked.¢**¢**º** xRowCount(pFts5, pnRow)¢**ÙM**   This function is used to retrieve the total number of rows in the table.Ù>**   In other words, the same value that would be returned by:¢**Ù(**        SELECT count(*) FROM ftstable;¢**±** xPhraseFirst()ÙN**   This function is used, along with type Fts5PhraseIter and the xPhraseNextÙM**   method, to iterate through all instances of a single query phrase withinÙK**   the current row. This is the same information as is accessible via theÙO**   xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenientÙI**   to use, this API may be faster under some circumstances. To iterate ÙA**   through instances of phrase iPhrase, use the following code:¢**½**       Fts5PhraseIter iter;¸**       int iCol, iOff;ÙD**       for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);µ**           iCol>=0;Ù9**           pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)«**       ){ÙI**         // An instance of phrase iPhrase at offset iOff of column iColª**       }¢**ÙK**   The Fts5PhraseIter structure is defined above. Applications should notÙK**   modify this structure directly - it should only be used as shown aboveÙB**   with the xPhraseFirst() and xPhraseNext() API methods (and byÙH**   xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).¢**ÙK**   This API can be quite slow if used with an FTS5 table created with theÙK**   "detail=none" or "detail=column" option. If the FTS5 table is created ÙH**   with either "detail=none" or "detail=column" and "content=" option ÙG**   (i.e. if it is a contentless table), then this API always iteratesÙG**   through an empty set (all calls to xPhraseFirst() set iCol to -1).¢**°** xPhraseNext()¼**   See xPhraseFirst above.¢**·** xPhraseFirstColumn()ÙL**   This function and xPhraseNextColumn() are similar to the xPhraseFirst()ÙK**   and xPhraseNext() APIs described above. The difference is that insteadÙM**   of iterating through all instances of a phrase in the current row, theseÙK**   APIs are used to iterate through the set of columns in the current rowÙK**   that contain one or more instances of a specified phrase. For example:¢**½**       Fts5PhraseIter iter;²**       int iCol;ÙC**       for(pApi->xPhraseFirstColumn(pFts, iPhrase, &iter, &iCol);µ**           iCol>=0;Ù8**           pApi->xPhraseNextColumn(pFts, &iter, &iCol)«**       ){ÙJ**         // Column iCol contains at least one instance of phrase iPhraseª**       }¢**ÙK**   This API can be quite slow if used with an FTS5 table created with theÙD**   "detail=none" option. If the FTS5 table is created with either ÙJ**   "detail=none" "content=" option (i.e. if it is a contentless table), ÙF**   then this API always iterates through an empty set (all calls to Ù***   xPhraseFirstColumn() set iCol to -1).¢**Ù>**   The information accessed using this API and its companionÙM**   xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNextÙI**   (or xInst/xInstCount). The chief advantage of this API is that it isÙH**   significantly more efficient than those alternatives when used with¾**   "detail=column" tables.  ¢**¶** xPhraseNextColumn()Ù"**   See xPhraseFirstColumn above.¢*/¹struct Fts5ExtensionApi {ÙA  int iVersion;                   /* Currently always set to 3 */ Ù#  void *(*xUserData)(Fts5Context*); Ù$  int (*xColumnCount)(Fts5Context*);Ù7  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);ÙJ  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken); Ù!  int (*xTokenize)(Fts5Context*, Ù8    const char *pText, int nText, /* Text to tokenize */ÙB    void *pCtx,                   /* Context passed to xToken() */ÙN    int (*xToken)(void*, int, const char*, int, int, int)       /* Callback */¤  ); Ù$  int (*xPhraseCount)(Fts5Context*);Ù0  int (*xPhraseSize)(Fts5Context*, int iPhrase); Ù/  int (*xInstCount)(Fts5Context*, int *pnInst);ÙN  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff); Ù(  sqlite3_int64 (*xRowid)(Fts5Context*);ÙG  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);Ù;  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken); ÙA  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,Ù6    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)¤  );ÙF  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));Ù1  void *(*xGetAuxdata)(Fts5Context*, int bClear); ÙN  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);ÙM  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff); ÙN  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);ÙG  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);¢}; £/* ½** CUSTOM AUXILIARY FUNCTIONSÙJ*************************************************************************/ ÙJ/*************************************************************************´** CUSTOM TOKENIZERS¢**ÙF** Applications may also register custom tokenizer types. A tokenizer ÙD** is registered by providing fts5 with a populated instance of the ÙF** following structure. All structure methods must be defined, settingÙE** any member of the fts5_tokenizer struct to NULL leads to undefinedÙH** behaviour. The structure methods are expected to function as follows:¢**«** xCreate:ÙK**   This function is used to allocate and initialize a tokenizer instance.Ù@**   A tokenizer instance is required to actually tokenize text.¢**ÙH**   The first argument passed to this function is a copy of the (void*)ÙG**   pointer provided by the application when the fts5_tokenizer objectÙJ**   was registered with FTS5 (the third argument to xCreateTokenizer()). ÙJ**   The second and third arguments are an array of nul-terminated stringsÙH**   containing the tokenizer arguments, if any, specified following theÙF**   tokenizer name as part of the CREATE VIRTUAL TABLE statement used¾**   to create the FTS5 table.¢**ÙG**   The final argument is an output variable. If successful, (*ppOut) ÙE**   should be set to point to the new tokenizer handle and SQLITE_OKÙI**   returned. If an error occurs, some value other than SQLITE_OK shouldÙL**   be returned. In this case, fts5 assumes that the final value of *ppOut ²**   is undefined.¢**«** xDelete:ÙE**   This function is invoked to delete a tokenizer handle previouslyÙG**   allocated using xCreate(). Fts5 guarantees that this function willÙC**   be invoked exactly once for each successful call to xCreate().¢**­** xTokenize:ÙK**   This function is expected to tokenize the nText byte string indicated ÙI**   by argument pText. pText may or may not be nul-terminated. The firstÙM**   argument passed to this function is a pointer to an Fts5Tokenizer objectÙ.**   returned by an earlier call to xCreate().¢**ÙE**   The second argument indicates the reason that FTS5 is requestingÙK**   tokenization of the supplied text. This is always one of the following±**   four values:¢**ÙO**   <ul><li> <b>FTS5_TOKENIZE_DOCUMENT</b> - A document is being inserted intoÙN**            or removed from the FTS table. The tokenizer is being invoked toÙH**            determine the set of tokens to add to (or delete from) the¸**            FTS index.¢**ÙK**       <li> <b>FTS5_TOKENIZE_QUERY</b> - A MATCH query is being executed ÙO**            against the FTS index. The tokenizer is being called to tokenize ÙI**            a bareword or quoted string specified as part of the query.¢**ÙK**       <li> <b>(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)</b> - Same asÙO**            FTS5_TOKENIZE_QUERY, except that the bareword or quoted string isÙI**            followed by a "*" character, indicating that the last tokenÙJ**            returned by the tokenizer will be treated as a token prefix.¢**ÙK**       <li> <b>FTS5_TOKENIZE_AUX</b> - The tokenizer is being invoked to ÙJ**            satisfy an fts5_api.xTokenize() request made by an auxiliaryÙM**            function. Or an fts5_api.xColumnSize() request made by the sameÙ+**            on a columnsize=0 database.  ª**   </ul>¢**ÙL**   For each token in the input string, the supplied callback xToken() mustÙI**   be invoked. The first argument to it should be a copy of the pointerÙG**   passed as the second argument to xTokenize(). The third and fourthÙK**   arguments are a pointer to a buffer containing the token text, and theÙO**   size of the token in bytes. The 4th and 5th arguments are the byte offsetsÙL**   of the first byte of and first byte immediately following the text fromÙ1**   which the token is derived within the input.¢**ÙJ**   The second argument passed to the xToken() callback ("tflags") shouldÙF**   normally be set to 0. The exception is if the tokenizer supports ÙA**   synonyms. In this case see the discussion below for details.¢**ÙI**   FTS5 assumes the xToken() callback is invoked for each token in the Ù1**   order that they occur within the input text.¢**ÙI**   If an xToken() callback returns any value other than SQLITE_OK, thenÙK**   the tokenization should be abandoned and the xTokenize() method shouldÙG**   immediately return a copy of the xToken() return value. Or, if theÙM**   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,ÙF**   if an error occurs with the xTokenize() implementation itself, itÙF**   may abandon the tokenization and return any error code other than¾**   SQLITE_OK or SQLITE_DONE.¢**²** SYNONYM SUPPORT¢**ÙL**   Custom tokenizers may also support synonyms. Consider a case in which aÙH**   user wishes to query for a phrase such as "first place". Using the ÙM**   built-in tokenizers, the FTS5 query 'first + place' will match instancesÙH**   of "first place" within the document set, but not alternative formsÙK**   such as "1st place". In some applications, it would be better to matchÙK**   all instances of "first place" or "1st place" regardless of which formÙ0**   the user specified in the MATCH query text.¢**Ù5**   There are several ways to approach this in FTS5:¢**ÙK**   <ol><li> By mapping all synonyms to a single token. In this case, the ÙM**            In the above example, this means that the tokenizer returns theÙK**            same token for inputs "first" and "1st". Say that token is inÙM**            fact "first", so that when the user inserts the document "I wonÙN**            1st place" entries are added to the index for tokens "i", "won",ÙN**            "first" and "place". If the user then queries for '1st + place',ÙM**            the tokenizer substitutes "first" for "1st" and the query worksº**            as expected.¢**ÙM**       <li> By adding multiple synonyms for a single term to the FTS index.ÙJ**            In this case, when tokenizing query text, the tokenizer may ÙN**            provide multiple synonyms for a single term within the document.ÙL**            FTS5 then queries the index for each synonym individually. ForÙ,**            example, faced with the query:¢**°**   <codeblock>Ù***     ... MATCH 'first place'</codeblock>¢**ÙM**            the tokenizer offers both "1st" and "first" as synonyms for theÙO**            first token in the MATCH query and FTS5 effectively runs a query ¹**            similar to:¢**°**   <codeblock>Ù3**     ... MATCH '(first OR 1st) place'</codeblock>¢**ÙM**            except that, for the purposes of auxiliary functions, the queryÙK**            still appears to contain just two phrases - "(first OR 1st)" Ù/**            being treated as a single phrase.¢**ÙM**       <li> By adding multiple synonyms for a single term to the FTS index.ÙM**            Using this method, when tokenizing document text, the tokenizerÙH**            provides multiple synonyms for each token. So that when a ÙL**            document such as "I won first place" is tokenized, entries areÙG**            added to the FTS index for "i", "won", "first", "1st" and¶**            "place".¢**ÙG**            This way, even if the tokenizer does not provide synonymsÙH**            when tokenizing query text (it should not - to do would beÙF**            inefficient), it doesn't matter if the user queries for ÙK**            'first + place' or '1st + place', as there are entires in theÙG**            FTS index corresponding to both forms of the first token.ª**   </ol>¢**ÙJ**   Whether it is parsing document or query text, any call to xToken thatÙI**   specifies a <i>tflags</i> argument with the FTS5_TOKEN_COLOCATED bitÙK**   is considered to supply a synonym for the previous token. For example,ÙM**   when parsing the document "I won first place", a tokenizer that supportsÙ6**   synonyms would call xToken() 5 times, as follows:¢**°**   <codeblock>Ù>**       xToken(pCtx, 0, "i",                      1,  0,  1);Ù>**       xToken(pCtx, 0, "won",                    3,  2,  5);Ù>**       xToken(pCtx, 0, "first",                  5,  6, 11);Ù>**       xToken(pCtx, FTS5_TOKEN_COLOCATED, "1st", 3,  6, 11);Ù>**       xToken(pCtx, 0, "place",                  5, 12, 17);®**</codeblock>¢**ÙK**   It is an error to specify the FTS5_TOKEN_COLOCATED flag the first timeÙN**   xToken() is called. Multiple synonyms may be specified for a single tokenÙK**   by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. ÙK**   There is no limit to the number of synonyms that may be provided for a²**   single token.¢**ÙK**   In many cases, method (1) above is the best approach. It does not add ÙM**   extra data to the FTS index or require FTS5 to query for multiple terms,ÙK**   so it is efficient in terms of disk space and query speed. However, itÙK**   does not support prefix queries very well. If, as suggested above, theÙL**   token "first" is subsituted for "1st" by the tokenizer, then the query:¢**°**   <codeblock>Ù"**     ... MATCH '1s*'</codeblock>¢**ÙL**   will not match documents that contain the token "1st" (as the tokenizerÙ:**   will probably not map "1s" to any prefix of "first").¢**ÙI**   For full prefix support, method (3) may be preferred. In this case, ÙJ**   because the index contains entries for both "first" and "1st", prefixÙJ**   queries such as 'fi*' or '1s*' will match correctly. However, becauseÙJ**   extra entries are added to the FTS index, this method uses more space¹**   within the database.¢**ÙI**   Method (2) offers a midpoint between (1) and (3). Using this method,ÙI**   a query such as '1s*' will match documents that contain the literal ÙH**   token "1st", but not "first" (assuming the tokenizer is not able toÙK**   provide synonyms for prefixes). However, a non-prefix query like '1st'ÙG**   will match against "1st" and "first". This method does not requireÙG**   extra disk space, as no extra entries are added to the FTS index. ÙL**   On the other hand, it may require more CPU cycles to run MATCH queries,ÙH**   as separate queries of the FTS index are required for each synonym.¢**ÙK**   When using methods (2) or (3), it is important that the tokenizer onlyÙI**   provide synonyms when tokenizing document text (method (2)) or queryÙL**   text (method (3)), not both. Doing so will not cause any errors, but is±**   inefficient.¢*/Ù+typedef struct Fts5Tokenizer Fts5Tokenizer;Ù-typedef struct fts5_tokenizer fts5_tokenizer;·struct fts5_tokenizer {ÙM  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);Ù"  void (*xDelete)(Fts5Tokenizer*);Ù#  int (*xTokenize)(Fts5Tokenizer*, ±      void *pCtx,Ù?      int flags,            /* Mask of FTS5_TOKENIZE_* flags */Ù$      const char *pText, int nText, ´      int (*xToken)(ÙE        void *pCtx,         /* Copy of 2nd argument to xTokenize() */Ù<        int tflags,         /* Mask of FTS5_TOKEN_* flags */ÙD        const char *pToken, /* Pointer to buffer containing token */Ù8        int nToken,         /* Size of token in bytes */ÙH        int iStart,         /* Byte offset of token within input text */ÙO        int iEnd            /* Byte offset of end of token within input text */§      )¤  );¢}; ÙC/* Flags that may be passed as the third argument to xTokenize() */Ù&#define FTS5_TOKENIZE_QUERY     0x0001Ù&#define FTS5_TOKENIZE_PREFIX    0x0002Ù&#define FTS5_TOKENIZE_DOCUMENT  0x0004Ù&#define FTS5_TOKENIZE_AUX       0x0008 ÙH/* Flags that may be passed by the tokenizer implementation back to FTS5Ù<** as the third argument to the supplied xToken callback. */ÙN#define FTS5_TOKEN_COLOCATED    0x0001      /* Same position as prev. token */ ¢/*»** END OF CUSTOM TOKENIZERSÙJ*************************************************************************/ ÙJ/*************************************************************************Ù"** FTS5 EXTENSION REGISTRATION API¢*/Ù!typedef struct fts5_api fts5_api;±struct fts5_api {ÙA  int iVersion;                   /* Currently always set to 2 */ ¾  /* Create a new tokenizer */º  int (*xCreateTokenizer)(³    fts5_api *pApi,¶    const char *zName,³    void *pContext,¿    fts5_tokenizer *pTokenizer,»    void (*xDestroy)(void*)¤  ); Ù"  /* Find an existing tokenizer */¸  int (*xFindTokenizer)(³    fts5_api *pApi,¶    const char *zName,µ    void **ppContext,¾    fts5_tokenizer *pTokenizer¤  ); Ù'  /* Create a new auxiliary function */¹  int (*xCreateFunction)(³    fts5_api *pApi,¶    const char *zName,³    void *pContext,Ù&    fts5_extension_function xFunction,»    void (*xDestroy)(void*)¤  );¢}; ¢/*º** END OF REGISTRATION APIÙJ*************************************************************************/ ¥#if 0Ù&}  /* end of the 'extern "C"' block */¦#endif ´#endif /* _FTS5_H */ Ù"/******** End of fts5.h *********/ ÙO/************** End of sqlite3.h *********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ ¢/*ÙL** Include the configuration header output by 'configure' if we're using the·** autoconf-based build¢*/Ù>#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)¹/* #include "config.h" */¸#define SQLITECONFIG_H 1¦#endif ÙO/************** Include sqliteLimit.h in the middle of sqliteInt.h ***********/ÙO/************** Begin file sqliteLimit.h *************************************/¢/*­** 2007 May 7¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************£** Ù?** This file defines various limits of what SQLite can process.¢*/ ¢/*Ù=** The maximum length of a TEXT or BLOB in bytes.   This alsoÙ0** limits the size of a row in a table or index.¢**Ù;** The hard limit is the ability of a 32-bit signed integerÙ+** to count the size: 2^31-1 or 2147483647.¢*/¹#ifndef SQLITE_MAX_LENGTHÙ%# define SQLITE_MAX_LENGTH 1000000000¦#endif ¢/*Ù ** This is the maximum number of¢**º**    * Columns in a table»**    * Columns in an index¹**    * Columns in a viewÙ6**    * Terms in the SET clause of an UPDATE statementÙ5**    * Terms in the result set of a SELECT statementÙH**    * Terms in the GROUP BY or ORDER BY clauses of a SELECT statement.Ù9**    * Terms in the VALUES clause of an INSERT statement¢**ÙA** The hard upper limit here is 32676.  Most database people willÙB** tell you that in a well-normalized database, you usually shouldÙA** not have more than a dozen or so columns in any table.  And ifÙ@** that is the case, there is no point in having more than a fewÙ?** dozen values in any of the other situations described above.¢*/¹#ifndef SQLITE_MAX_COLUMN¿# define SQLITE_MAX_COLUMN 2000¦#endif ¢/*Ù9** The maximum length of a single SQL statement in bytes.¢**Ù?** It used to be the case that setting this value to zero wouldÙC** turn the limit off.  That is no longer true.  It is not possibleº** to turn this limit off.¢*/½#ifndef SQLITE_MAX_SQL_LENGTHÙ)# define SQLITE_MAX_SQL_LENGTH 1000000000¦#endif ¢/*Ù?** The maximum depth of an expression tree. This is limited to Ù@** some extent by SQLITE_MAX_SQL_LENGTH. But sometime you might Ù<** want to place more severe limits on the complexity of an ®** expression.¢**Ù=** A value of 0 used to mean that the limit was not enforced.ÙB** But that is no longer true.  The limit is now strictly enforced°** at all times.¢*/½#ifndef SQLITE_MAX_EXPR_DEPTHÙ## define SQLITE_MAX_EXPR_DEPTH 1000¦#endif ¢/*Ù>** The maximum number of terms in a compound SELECT statement.Ù=** The code generator for compound SELECT statements does oneÙA** level of recursion for each term.  A stack overflow can resultÙ>** if the number of terms is too large.  In practice, most SQLÙA** never has more than 3 or 4 terms.  Use a value of 0 to disableÙ9** any limit on the number of terms in a compount SELECT.¢*/Ù"#ifndef SQLITE_MAX_COMPOUND_SELECTÙ'# define SQLITE_MAX_COMPOUND_SELECT 500¦#endif ¢/*Ù3** The maximum number of opcodes in a VDBE program.º** Not currently enforced.¢*/º#ifndef SQLITE_MAX_VDBE_OPÙ%# define SQLITE_MAX_VDBE_OP 250000000¦#endif ¢/*Ù6** The maximum number of arguments to an SQL function.¢*/¿#ifndef SQLITE_MAX_FUNCTION_ARGÙ$# define SQLITE_MAX_FUNCTION_ARG 127¦#endif ¢/*Ù=** The suggested maximum number of in-memory pages to use forÙ4** the main database table and for temporary tables.¢**ÙN** IMPLEMENTATION-OF: R-30185-15359 The default suggested cache size is -2000,ÙD** which means the cache size is limited to 2048000 bytes of memory.ÙK** IMPLEMENTATION-OF: R-48205-43578 The default suggested cache size can beÙD** altered using the SQLITE_DEFAULT_CACHE_SIZE compile-time options.¢*/Ù!#ifndef SQLITE_DEFAULT_CACHE_SIZEÙ)# define SQLITE_DEFAULT_CACHE_SIZE  -2000¦#endif ¢/*ÙD** The default number of frames to accumulate in the log file beforeÙ*** checkpointing the database in WAL mode.¢*/Ù)#ifndef SQLITE_DEFAULT_WAL_AUTOCHECKPOINTÙ0# define SQLITE_DEFAULT_WAL_AUTOCHECKPOINT  1000¦#endif ¢/*ÙD** The maximum number of attached databases.  This must be between 0ÙI** and 125.  The upper bound of 125 is because the attached databases areÙH** counted using a signed 8-bit integer which has a maximum value of 127ÙK** and we have to allow 2 extra counts for the "main" and "temp" databases.¢*/»#ifndef SQLITE_MAX_ATTACHED¿# define SQLITE_MAX_ATTACHED 10¦#endif  ¢/*ÙD** The maximum value of a ?nnn wildcard that the parser will accept.¢*/Ù"#ifndef SQLITE_MAX_VARIABLE_NUMBERÙ'# define SQLITE_MAX_VARIABLE_NUMBER 999¦#endif ÙL/* Maximum page size.  The upper bound on this value is 65536.  This a limitÙ9** imposed by the use of 16-bit offsets within each page.¢**ÙF** Earlier versions of SQLite allowed the user to change this value atÙL** compile time. This is no longer permitted, on the grounds that it createsÙE** a library that is technically incompatible with an SQLite library ÙI** compiled with a different limit. If a process operating on a database ÙG** with a page-size of 65536 bytes crashes, then an instance of SQLite ÙJ** compiled with the default page-size limit will not be able to rollback ÙC** the aborted transaction. This could lead to database corruption.¢*/»#ifdef SQLITE_MAX_PAGE_SIZE¼# undef SQLITE_MAX_PAGE_SIZE¦#endifÙ"#define SQLITE_MAX_PAGE_SIZE 65536  ¢/*Ù'** The default size of a database page.¢*/Ù #ifndef SQLITE_DEFAULT_PAGE_SIZEÙ&# define SQLITE_DEFAULT_PAGE_SIZE 4096¦#endifÙ1#if SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZEÙ # undef SQLITE_DEFAULT_PAGE_SIZEÙ6# define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE¦#endif ¢/*ÙK** Ordinarily, if no value is explicitly provided, SQLite creates databasesÙE** with page size SQLITE_DEFAULT_PAGE_SIZE. However, based on certainÙC** device characteristics (sector-size and atomic write() support),ÙG** SQLite may choose a larger value. This constant is the maximum valueÙ!** SQLite will choose on its own.¢*/Ù$#ifndef SQLITE_MAX_DEFAULT_PAGE_SIZEÙ*# define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192¦#endifÙ5#if SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZEÙ$# undef SQLITE_MAX_DEFAULT_PAGE_SIZEÙ:# define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE¦#endif  ¢/*Ù0** Maximum number of pages in one database file.¢**ÙG** This is really just the default value for the max_page_count pragma.ÙC** This value can be lowered (or raised) at run-time using that the¸** max_page_count macro.¢*/½#ifndef SQLITE_MAX_PAGE_COUNTÙ)# define SQLITE_MAX_PAGE_COUNT 1073741823¦#endif ¢/*Ù=** Maximum length (in bytes) of the pattern in a LIKE or GLOB¬** operator.¢*/Ù&#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTHÙ-# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000¦#endif ¢/*Ù+** Maximum depth of recursion for triggers.¢**ÙG** A value of 1 means that a trigger program will not be able to itselfÙI** fire any triggers. A value of 0 means that no trigger programs at all ³** may be executed.¢*/Ù #ifndef SQLITE_MAX_TRIGGER_DEPTHÙ&# define SQLITE_MAX_TRIGGER_DEPTH 1000¦#endif ÙO/************** End of sqliteLimit.h *****************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ Ù4/* Disable nuisance warnings on Borland compilers */¹#if defined(__BORLANDC__)Ù(#pragma warn -rch /* unreachable code */Ù9#pragma warn -ccc /* Condition is always true or false */Ù4#pragma warn -aus /* Assigned value is never used */Ù5#pragma warn -csu /* Comparing signed and unsigned */Ù5#pragma warn -spa /* Suspicious pointer arithmetic */¦#endif ¢/*Ù-** Include standard header files as necessary¢*/´#ifdef HAVE_STDINT_H³#include <stdint.h>¦#endif¶#ifdef HAVE_INTTYPES_Hµ#include <inttypes.h>¦#endif ¢/*ÙA** The following macros are used to cast pointers to integers andÙF** integers to pointers.  The way you do this varies from one compilerÙH** to the next, so we have developed the following set of #if statementsÙ@** to generate appropriate macros for a wide range of compilers.¢**ÙA** The correct "ANSI" way to do this is to use the intptr_t type.ÙD** Unfortunately, that typedef is not available on all compilers, orÙB** if it is available, it requires an #include of specific headersÙ*** that vary from one machine to the next.¢**Ù@** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes onÙK** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).ÙE** So we have to define the macros in different ways depending on the¬** compiler.¢*/ÙB#if defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */Ù=# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))Ù;# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))ÙH#elif !defined(__GNUC__)       /* Works for compilers other than LLVM */Ù6# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])Ù;# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))ÙJ#elif defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */Ù5# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))Ù3# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))ÙN#else                          /* Generates a warning - but it always works */Ù+# define SQLITE_INT_TO_PTR(X)  ((void*)(X))Ù)# define SQLITE_PTR_TO_INT(X)  ((int)(X))¦#endif ¢/*Ù@** A macro to hint to the compiler that a function should not be«** inlined.¢*/µ#if defined(__GNUC__)Ù4#  define SQLITE_NOINLINE  __attribute__((noinline))Ù)#elif defined(_MSC_VER) && _MSC_VER>=1310Ù/#  define SQLITE_NOINLINE  __declspec(noinline)¥#else¹#  define SQLITE_NOINLINE¦#endif ¢/*ÙD** Make sure that the compiler intrinsics we desire are enabled whenÙD** compiling with an appropriate version of MSVC unless prevented byÙ'** the SQLITE_DISABLE_INTRINSIC define.¢*/Ù&#if !defined(SQLITE_DISABLE_INTRINSIC)Ù)#  if defined(_MSC_VER) && _MSC_VER>=1400¼#    if !defined(_WIN32_WCE)¹#      include <intrin.h>Ù)#      pragma intrinsic(_byteswap_ushort)Ù(#      pragma intrinsic(_byteswap_ulong)Ù)#      pragma intrinsic(_byteswap_uint64)Ù*#      pragma intrinsic(_ReadWriteBarrier)©#    else¼#      include <cmnintrin.h>ª#    endif¨#  endif¦#endif ¢/*Ù=** The SQLITE_THREADSAFE macro must be defined as 0, 1, or 2.ÙC** 0 means mutexes are permanently disable and the library is neverÙF** threadsafe.  1 means the library is serialized which is the highestÙJ** level of threadsafety.  2 means the library is multithreaded - multipleÙG** threads can use SQLite as long as no two threads try to use the sameÙ(** database connection at the same time.¢**Ù>** Older versions of SQLite used an optional THREADSAFE macro.¾** We support that for legacy.¢**ÙM** To ensure that the correct value of "THREADSAFE" is reported when queryingÙL** for compile-time options at runtime (e.g. "PRAGMA compile_options"), thisÙM** logic is partially replicated in ctime.c. If it is updated here, it should¹** also be updated there.¢*/¿#if !defined(SQLITE_THREADSAFE)¸# if defined(THREADSAFE)Ù'#   define SQLITE_THREADSAFE THREADSAFE¦# elseÙ7#   define SQLITE_THREADSAFE 1 /* IMP: R-07272-22309 */§# endif¦#endif ¢/*ÙE** Powersafe overwrite is on by default.  But can be turned off usingÙ:** the -DSQLITE_POWERSAFE_OVERWRITE=0 command-line option.¢*/Ù"#ifndef SQLITE_POWERSAFE_OVERWRITEÙ%# define SQLITE_POWERSAFE_OVERWRITE 1¦#endif ¢/*ÙI** EVIDENCE-OF: R-25715-37072 Memory allocation statistics are enabled byÙG** default unless SQLite is compiled with SQLITE_DEFAULT_MEMSTATUS=0 inÙC** which case memory allocation statistics are disabled by default.¢*/Ù&#if !defined(SQLITE_DEFAULT_MEMSTATUS)Ù## define SQLITE_DEFAULT_MEMSTATUS 1¦#endif ¢/*ÙB** Exactly one of the following macros must be defined in order toÙ4** specify which memory allocation subsystem to use.¢**ÙB**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()ÙA**     SQLITE_WIN32_MALLOC           // Use Win32 native heap APIÙN**     SQLITE_ZERO_MALLOC            // Use a stub allocator that always failsÙL**     SQLITE_MEMDEBUG               // Debugging version of system malloc()¢**ÙK** On Windows, if the SQLITE_WIN32_MALLOC_VALIDATE macro is defined and theÙL** assert() macro is enabled, each call into the Win32 native heap subsystemÙL** will cause HeapValidate to be called.  If heap validation should fail, an¿** assertion will be triggered.¢**ÙE** If none of the above are defined, then set SQLITE_SYSTEM_MALLOC as¯** the default.¢*/Ù##if defined(SQLITE_SYSTEM_MALLOC) \Ù"  + defined(SQLITE_WIN32_MALLOC) \Ù!  + defined(SQLITE_ZERO_MALLOC) \¾  + defined(SQLITE_MEMDEBUG)>1ÙI# error "Two or more of the following compile-time configuration options\Ù) are defined but at most one is allowed:\Ù= SQLITE_SYSTEM_MALLOC, SQLITE_WIN32_MALLOC, SQLITE_MEMDEBUG,\´ SQLITE_ZERO_MALLOC"¦#endifÙ##if defined(SQLITE_SYSTEM_MALLOC) \Ù"  + defined(SQLITE_WIN32_MALLOC) \Ù!  + defined(SQLITE_ZERO_MALLOC) \¿  + defined(SQLITE_MEMDEBUG)==0¿# define SQLITE_SYSTEM_MALLOC 1¦#endif ¢/*Ù@** If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep theÙ?** sizes of memory allocations below this value where possible.¢*/Ù&#if !defined(SQLITE_MALLOC_SOFT_LIMIT)Ù&# define SQLITE_MALLOC_SOFT_LIMIT 1024¦#endif ¢/*Ù@** We need to define _XOPEN_SOURCE as follows in order to enableÙB** recursive mutexes on most Unix systems and fchmod() on OpenBSD.ÙA** But _XOPEN_SOURCE define causes problems for Mac OS X, so omit¦** it.¢*/ÙJ#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__)»#  define _XOPEN_SOURCE 600¦#endif ¢/*ÙH** NDEBUG and SQLITE_DEBUG are opposites.  It should always be true thatÙK** defined(NDEBUG)==!defined(SQLITE_DEBUG).  If this is not currently true,Ù1** make it true by defining or undefining NDEBUG.¢**ÙD** Setting NDEBUG makes the code smaller and faster by disabling theÙB** assert() statements in the code.  So we want the default actionÙM** to be for NDEBUG to be set and NDEBUG to be undefined only if SQLITE_DEBUGÙ@** is set.  Thus NDEBUG becomes an opt-in rather than an opt-out«** feature.¢*/Ù.#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)±# define NDEBUG 1¦#endifÙ,#if defined(NDEBUG) && defined(SQLITE_DEBUG)®# undef NDEBUG¦#endif ¢/*ÙF** Enable SQLITE_ENABLE_EXPLAIN_COMMENTS if SQLITE_DEBUG is turned on.¢*/ÙE#if !defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) && defined(SQLITE_DEBUG)Ù)# define SQLITE_ENABLE_EXPLAIN_COMMENTS 1¦#endif ¢/*ÙA** The testcase() macro is used to aid in coverage testing.  WhenÙ?** doing coverage testing, the condition inside the argument toÙ?** testcase() must be evaluated both true and false in order toÙ>** get full branch coverage.  The testcase() macro is insertedÙ?** to help ensure adequate test coverage in places where simpleÙF** condition/decision coverage is inadequate.  For example, testcase()Ù<** can be used to make sure boundary values are tested.  ForÙ>** bitmask tests, testcase() can be used to make sure each bitÙ?** is significant and used at least once.  On switch statementsÙ@** where multiple cases go to the same block of code, testcase()Ù+** can insure that all cases are evaluated.¢**¢*/»#ifdef SQLITE_COVERAGE_TESTÙ+SQLITE_PRIVATE   void sqlite3Coverage(int);Ù;# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }¥#else´# define testcase(X)¦#endif ¢/*ÙA** The TESTONLY macro is used to enclose variable declarations orÙ>** other bits of code that are needed to support the argumentsÙ)** within testcase() and assert() macros.¢*/Ù5#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)·# define TESTONLY(X)  X¥#else´# define TESTONLY(X)¦#endif ¢/*ÙM** Sometimes we need a small amount of code such as a variable initializationÙH** to setup for a later assert() statement.  We do not want this code toÙF** appear when assert() is disabled.  The following macro is thereforeÙA** used to contain that setup code.  The "VVA" acronym stands forÙF** "Verification, Validation, and Accreditation".  In other words, theÙF** code within VVA_ONLY() will only run during verification processes.¢*/®#ifndef NDEBUG·# define VVA_ONLY(X)  X¥#else´# define VVA_ONLY(X)¦#endif ¢/*ÙA** The ALWAYS and NEVER macros surround boolean expressions whichÙ?** are intended to always be true or false, respectively.  SuchÙC** expressions could be omitted from the code completely.  But theyÙA** are included in a few cases in order to enhance the resilienceÙE** of SQLite to unexpected behavior - to make the code "self-healing"ÙE** or "ductile" rather than being "brittle" and crashing at the first¾** hint of unplanned behavior.¢**ÙA** In other words, ALWAYS and NEVER are added for defensive code.¢**ÙA** When doing coverage testing ALWAYS and NEVER are hard-coded toÙC** be true and false so that the unreachable code they specify willÙ#** not be counted as untested code.¢*/ÙB#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)»# define ALWAYS(X)      (1)»# define NEVER(X)       (0)¶#elif !defined(NDEBUG)Ù-# define ALWAYS(X)      ((X)?1:(assert(0),0))Ù-# define NEVER(X)       ((X)?(assert(0),1):0)¥#else»# define ALWAYS(X)      (X)»# define NEVER(X)       (X)¦#endif ¢/*ÙD** Some conditionals are optimizations only.  In other words, if theÙG** conditionals are replaced with a constant 1 (true) or 0 (false) thenÙG** the correct answer is still obtained, though perhaps not as quickly.¢**Ù>** The following macros mark these optimizations conditionals.¢*/Ù!#if defined(SQLITE_MUTATION_TEST)Ù"# define OK_IF_ALWAYS_TRUE(X)  (1)Ù"# define OK_IF_ALWAYS_FALSE(X) (0)¥#elseÙ"# define OK_IF_ALWAYS_TRUE(X)  (X)Ù"# define OK_IF_ALWAYS_FALSE(X) (X)¦#endif ¢/*ÙJ** Some malloc failures are only possible if SQLITE_TEST_REALLOC_STRESS isÙG** defined.  We need to defend against those failures when testing withÙI** SQLITE_TEST_REALLOC_STRESS, but we don't want the unreachable branchesÙK** during a normal build.  The following macro can be used to disable testsÙG** that are always false except when SQLITE_TEST_REALLOC_STRESS is set.¢*/Ù'#if defined(SQLITE_TEST_REALLOC_STRESS)Ù'# define ONLY_IF_REALLOC_STRESS(X)  (X)¶#elif !defined(NDEBUG)Ù9# define ONLY_IF_REALLOC_STRESS(X)  ((X)?(assert(0),1):0)¥#elseÙ'# define ONLY_IF_REALLOC_STRESS(X)  (0)¦#endif ¢/*ÙA** Declarations used for tracing the operating system interfaces.¢*/Ù?#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) || \Ù,    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)¼  extern int sqlite3OSTrace;ÙF# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X½# define SQLITE_HAVE_OS_TRACE¥#else³# define OSTRACE(X)½# undef  SQLITE_HAVE_OS_TRACE¦#endif ¢/*ÙD** Is the sqlite3ErrName() function needed in the build?  Currently,ÙC** it is needed by "mutex_w32.c" (when debugging), "os_win.c" (whenÙA** OSTRACE is enabled), and by several "test*.c" files (which are¿** compiled using SQLITE_TEST).¢*/Ù>#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) || \Ù,    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)½# define SQLITE_NEED_ERR_NAME¥#else½# undef  SQLITE_NEED_ERR_NAME¦#endif ¢/*ÙJ** SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN¢*/º#ifdef SQLITE_OMIT_EXPLAINÙ&# undef SQLITE_ENABLE_EXPLAIN_COMMENTS¦#endif ¢/*ÙF** Return true (non-zero) if the input is an integer that is too largeÙF** to fit in 32-bits.  This macro is used inside of various testcase()ÙF** macros to verify that we have tested SQLite for large-file support.¢*/Ù2#define IS_BIG_INT(X)  (((X)&~(i64)0xffffffff)!=0) ¢/*Ù:** The macro unlikely() is a hint that surrounds a booleanÙ>** expression that is usually false.  Macro likely() surroundsÙA** a boolean expression that is usually true.  These hints could,ÙB** in theory, be used by the compiler to generate better code, butÙ6** currently they are just comments for human readers.¢*/¸#define likely(X)    (X)¸#define unlikely(X)  (X) ÙO/************** Include hash.h in the middle of sqliteInt.h ******************/ÙO/************** Begin file hash.h ********************************************/¢/*´** 2001 September 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙD** This is the header file for the generic hash-table implementation²** used in SQLite.¢*/µ#ifndef SQLITE_HASH_Hµ#define SQLITE_HASH_H Ù)/* Forward declarations of structures. */¹typedef struct Hash Hash;Ù!typedef struct HashElem HashElem; ÙC/* A complete hash table is an instance of the following structure.ÙF** The internals of this structure are intended to be opaque -- clientÙK** code should not attempt to access or modify the fields of this structureÙE** directly.  Change this structure only by using the routines below.ÙF** However, some of the "procedures" and "functions" for modifying andÙF** accessing this structure are really macros, so we can't really make¹** this structure opaque.¢**ÙE** All elements of the hash table are on a single doubly-linked list.Ù.** Hash.first points to the head of this list.¢**ÙB** There are Hash.htsize buckets.  Each bucket points to a spot inÙE** the global doubly-linked list.  The contents of the bucket are theÙE** element pointed to plus the next _ht.count-1 elements in the list.¢**ÙD** Hash.htsize and Hash.ht may be zero.  In that case lookup is doneÙA** by a linear search of the global list.  For small tables, the ÙE** Hash.ht table is never allocated because if there are few elementsÙB** in the table, it is faster to do a linear search than to manage²** the hash table.¢*/­struct Hash {ÙE  unsigned int htsize;      /* Number of buckets in the hash table */ÙA  unsigned int count;       /* Number of entries in this table */Ù@  HashElem *first;          /* The first element of the array */Ù0  struct _ht {              /* the hash table */ÙE    int count;                 /* Number of entries with this hash */ÙJ    HashElem *chain;           /* Pointer to first entry with this hash */¨  } *ht;¢}; ÙB/* Each element in the hash table is an instance of the following ÙF** structure.  All elements are stored on a single doubly-linked list.¢**ÙF** Again, this structure is intended to be opaque, but it can't reallyÙ*** be opaque because it is used by macros.¢*/±struct HashElem {ÙL  HashElem *next, *prev;       /* Next and previous elements in the table */ÙF  void *data;                  /* Data associated with this element */ÙE  const char *pKey;            /* Key associated with this element */¢}; ¢/*Ù6** Access routines.  To delete, insert a NULL pointer.¢*/Ù+SQLITE_PRIVATE void sqlite3HashInit(Hash*);ÙMSQLITE_PRIVATE void *sqlite3HashInsert(Hash*, const char *pKey, void *pData);ÙDSQLITE_PRIVATE void *sqlite3HashFind(const Hash*, const char *pKey);Ù,SQLITE_PRIVATE void sqlite3HashClear(Hash*); ¢/*ÙF** Macros for looping over all elements of a hash table.  The idiom is­** like this:¢**¬**   Hash h;±**   HashElem *p;¨**   ...Ù8**   for(p=sqliteHashFirst(&h); p; p=sqliteHashNext(p)){Ù0**     SomeStructure *pData = sqliteHashData(p);Ù!**     // do something with pData¦**   }¢*/Ù(#define sqliteHashFirst(H)  ((H)->first)Ù'#define sqliteHashNext(E)   ((E)->next)Ù'#define sqliteHashData(E)   ((E)->data)Ù9/* #define sqliteHashKey(E)    ((E)->pKey) // NOT USED */Ù;/* #define sqliteHashKeysize(E) ((E)->nKey)  // NOT USED */ ¢/*Ù$** Number of entries in a hash table¢*/Ù:/* #define sqliteHashCount(H)  ((H)->count) // NOT USED */ º#endif /* SQLITE_HASH_H */ ÙO/************** End of hash.h ************************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ÙO/************** Include parse.h in the middle of sqliteInt.h *****************/ÙO/************** Begin file parse.h *******************************************/Ù-#define TK_SEMI                             1Ù-#define TK_EXPLAIN                          2Ù-#define TK_QUERY                            3Ù-#define TK_PLAN                             4Ù-#define TK_BEGIN                            5Ù-#define TK_TRANSACTION                      6Ù-#define TK_DEFERRED                         7Ù-#define TK_IMMEDIATE                        8Ù-#define TK_EXCLUSIVE                        9Ù-#define TK_COMMIT                          10Ù-#define TK_END                             11Ù-#define TK_ROLLBACK                        12Ù-#define TK_SAVEPOINT                       13Ù-#define TK_RELEASE                         14Ù-#define TK_TO                              15Ù-#define TK_TABLE                           16Ù-#define TK_CREATE                          17Ù-#define TK_IF                              18Ù-#define TK_NOT                             19Ù-#define TK_EXISTS                          20Ù-#define TK_TEMP                            21Ù-#define TK_LP                              22Ù-#define TK_RP                              23Ù-#define TK_AS                              24Ù-#define TK_WITHOUT                         25Ù-#define TK_COMMA                           26Ù-#define TK_ABORT                           27Ù-#define TK_ACTION                          28Ù-#define TK_AFTER                           29Ù-#define TK_ANALYZE                         30Ù-#define TK_ASC                             31Ù-#define TK_ATTACH                          32Ù-#define TK_BEFORE                          33Ù-#define TK_BY                              34Ù-#define TK_CASCADE                         35Ù-#define TK_CAST                            36Ù-#define TK_CONFLICT                        37Ù-#define TK_DATABASE                        38Ù-#define TK_DESC                            39Ù-#define TK_DETACH                          40Ù-#define TK_EACH                            41Ù-#define TK_FAIL                            42Ù-#define TK_OR                              43Ù-#define TK_AND                             44Ù-#define TK_IS                              45Ù-#define TK_MATCH                           46Ù-#define TK_LIKE_KW                         47Ù-#define TK_BETWEEN                         48Ù-#define TK_IN                              49Ù-#define TK_ISNULL                          50Ù-#define TK_NOTNULL                         51Ù-#define TK_NE                              52Ù-#define TK_EQ                              53Ù-#define TK_GT                              54Ù-#define TK_LE                              55Ù-#define TK_LT                              56Ù-#define TK_GE                              57Ù-#define TK_ESCAPE                          58Ù-#define TK_ID                              59Ù-#define TK_COLUMNKW                        60Ù-#define TK_FOR                             61Ù-#define TK_IGNORE                          62Ù-#define TK_INITIALLY                       63Ù-#define TK_INSTEAD                         64Ù-#define TK_NO                              65Ù-#define TK_KEY                             66Ù-#define TK_OF                              67Ù-#define TK_OFFSET                          68Ù-#define TK_PRAGMA                          69Ù-#define TK_RAISE                           70Ù-#define TK_RECURSIVE                       71Ù-#define TK_REPLACE                         72Ù-#define TK_RESTRICT                        73Ù-#define TK_ROW                             74Ù-#define TK_TRIGGER                         75Ù-#define TK_VACUUM                          76Ù-#define TK_VIEW                            77Ù-#define TK_VIRTUAL                         78Ù-#define TK_WITH                            79Ù-#define TK_REINDEX                         80Ù-#define TK_RENAME                          81Ù-#define TK_CTIME_KW                        82Ù-#define TK_ANY                             83Ù-#define TK_BITAND                          84Ù-#define TK_BITOR                           85Ù-#define TK_LSHIFT                          86Ù-#define TK_RSHIFT                          87Ù-#define TK_PLUS                            88Ù-#define TK_MINUS                           89Ù-#define TK_STAR                            90Ù-#define TK_SLASH                           91Ù-#define TK_REM                             92Ù-#define TK_CONCAT                          93Ù-#define TK_COLLATE                         94Ù-#define TK_BITNOT                          95Ù-#define TK_INDEXED                         96Ù-#define TK_STRING                          97Ù-#define TK_JOIN_KW                         98Ù-#define TK_CONSTRAINT                      99Ù-#define TK_DEFAULT                        100Ù-#define TK_NULL                           101Ù-#define TK_PRIMARY                        102Ù-#define TK_UNIQUE                         103Ù-#define TK_CHECK                          104Ù-#define TK_REFERENCES                     105Ù-#define TK_AUTOINCR                       106Ù-#define TK_ON                             107Ù-#define TK_INSERT                         108Ù-#define TK_DELETE                         109Ù-#define TK_UPDATE                         110Ù-#define TK_SET                            111Ù-#define TK_DEFERRABLE                     112Ù-#define TK_FOREIGN                        113Ù-#define TK_DROP                           114Ù-#define TK_UNION                          115Ù-#define TK_ALL                            116Ù-#define TK_EXCEPT                         117Ù-#define TK_INTERSECT                      118Ù-#define TK_SELECT                         119Ù-#define TK_VALUES                         120Ù-#define TK_DISTINCT                       121Ù-#define TK_DOT                            122Ù-#define TK_FROM                           123Ù-#define TK_JOIN                           124Ù-#define TK_USING                          125Ù-#define TK_ORDER                          126Ù-#define TK_GROUP                          127Ù-#define TK_HAVING                         128Ù-#define TK_LIMIT                          129Ù-#define TK_WHERE                          130Ù-#define TK_INTO                           131Ù-#define TK_FLOAT                          132Ù-#define TK_BLOB                           133Ù-#define TK_INTEGER                        134Ù-#define TK_VARIABLE                       135Ù-#define TK_CASE                           136Ù-#define TK_WHEN                           137Ù-#define TK_THEN                           138Ù-#define TK_ELSE                           139Ù-#define TK_INDEX                          140Ù-#define TK_ALTER                          141Ù-#define TK_ADD                            142Ù-#define TK_TRUEFALSE                      143Ù-#define TK_ISNOT                          144Ù-#define TK_FUNCTION                       145Ù-#define TK_COLUMN                         146Ù-#define TK_AGG_FUNCTION                   147Ù-#define TK_AGG_COLUMN                     148Ù-#define TK_UMINUS                         149Ù-#define TK_UPLUS                          150Ù-#define TK_TRUTH                          151Ù-#define TK_REGISTER                       152Ù-#define TK_VECTOR                         153Ù-#define TK_SELECT_COLUMN                  154Ù-#define TK_IF_NULL_ROW                    155Ù-#define TK_ASTERISK                       156Ù-#define TK_SPAN                           157Ù-#define TK_END_OF_FILE                    158Ù-#define TK_UNCLOSED_STRING                159Ù-#define TK_SPACE                          160Ù-#define TK_ILLEGAL                        161 Ù2/* The token codes above must all fit in 8 bits */Ù##define TKFLG_MASK           0xff   Ù9/* Flags that can be added to a token code when it is not»** being stored in a u8: */ÙM#define TKFLG_DONTFOLD       0x100  /* Omit constant folding optimizations */ ÙO/************** End of parse.h ***********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/²#include <stdio.h>³#include <stdlib.h>³#include <string.h>³#include <assert.h>³#include <stddef.h> ¢/*ÙI** Use a macro to replace memcpy() if compiled with SQLITE_INLINE_MEMCPY.ÙI** This allows better measurements of where memcpy() is used when runningÙE** cachegrind.  But this macro version of memcpy() is very slow so itÙG** should not be used in production.  This is a performance measurement­** hack only.¢*/»#ifdef SQLITE_INLINE_MEMCPYÙM# define memcpy(D,S,N) {char*xxd=(char*)(D);const char*xxs=(const char*)(S);\ÙE                        int xxn=(N);while(xxn-->0)*(xxd++)=*(xxs++);}¦#endif ¢/*ÙB** If compiling for a processor that lacks floating point support,Ù(** substitute integer for floating-point¢*/Ù!#ifdef SQLITE_OMIT_FLOATING_POINT¼# define double sqlite_int64»# define float sqlite_int64Ù%# define LONGDOUBLE_TYPE sqlite_int64·# ifndef SQLITE_BIG_DBLÙ2#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)§# endifÙ%# define SQLITE_OMIT_DATETIME_FUNCS 1¼# define SQLITE_OMIT_TRACE 1Ù'# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT¹# undef SQLITE_HAVE_ISNAN¦#endif¶#ifndef SQLITE_BIG_DBL¾# define SQLITE_BIG_DBL (1e99)¦#endif ¢/*ÙA** OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0ÙA** afterward. Having this macro allows us to cause the C compilerÙE** to omit code used by TEMP tables without messy #ifndef statements.¢*/¹#ifdef SQLITE_OMIT_TEMPDBµ#define OMIT_TEMPDB 1¥#elseµ#define OMIT_TEMPDB 0¦#endif ¢/*ÙF** The "file format" number is an integer that is incremented wheneverÙG** the VDBE-level file format changes.  The following macros define theÙH** the default file format for new databases and the maximum file format½** that the library can read.¢*/Ù #define SQLITE_MAX_FILE_FORMAT 4Ù"#ifndef SQLITE_DEFAULT_FILE_FORMATÙ%# define SQLITE_DEFAULT_FILE_FORMAT 4¦#endif ¢/*ÙD** Determine whether triggers are recursive by default.  This can beÙ&** changed at run-time using a pragma.¢*/Ù)#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERSÙ,# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0¦#endif ¢/*ÙL** Provide a default value for SQLITE_TEMP_STORE in case it is not specified¶** on the command-line¢*/¹#ifndef SQLITE_TEMP_STORE¼# define SQLITE_TEMP_STORE 1¦#endif ¢/*ÙE** If no value has been provided for SQLITE_MAX_WORKER_THREADS, or ifÙD** SQLITE_TEMP_STORE is set to 3 (never use temporary files), set it«** to zero.¢*/Ù0#if SQLITE_TEMP_STORE==3 || SQLITE_THREADSAFE==0Ù!# undef SQLITE_MAX_WORKER_THREADSÙ$# define SQLITE_MAX_WORKER_THREADS 0¦#endifÙ!#ifndef SQLITE_MAX_WORKER_THREADSÙ$# define SQLITE_MAX_WORKER_THREADS 8¦#endifÙ%#ifndef SQLITE_DEFAULT_WORKER_THREADSÙ(# define SQLITE_DEFAULT_WORKER_THREADS 0¦#endifÙ;#if SQLITE_DEFAULT_WORKER_THREADS>SQLITE_MAX_WORKER_THREADSÙ!# undef SQLITE_MAX_WORKER_THREADSÙ@# define SQLITE_MAX_WORKER_THREADS SQLITE_DEFAULT_WORKER_THREADS¦#endif ¢/*ÙG** The default initial allocation for the pagecache when using separateÙE** pagecaches for each database connection.  A positive number is theÙI** number of pages.  A negative number N translations means that a bufferÙL** of -1024*N bytes is allocated and used for as many pages as it will hold.¢**ÙH** The default value of "20" was choosen to minimize the run-time of theÙD** speedtest1 test program with options: --shrink-memory --reprepare¢*/Ù$#ifndef SQLITE_DEFAULT_PCACHE_INITSZÙ(# define SQLITE_DEFAULT_PCACHE_INITSZ 20¦#endif ¢/*Ù6** The compile-time options SQLITE_MMAP_READWRITE and ÙH** SQLITE_ENABLE_BATCH_ATOMIC_WRITE are not compatible with one another.Ù>** You must choose one or the other (or neither) but not both.¢*/ÙO#if defined(SQLITE_MMAP_READWRITE) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)ÙQ#error Cannot use both SQLITE_MMAP_READWRITE and SQLITE_ENABLE_BATCH_ATOMIC_WRITE¦#endif ¢/*ÙB** GCC does not define the offsetof() macro so we'll have to do it­** ourselves.¢*/°#ifndef offsetofÙI#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))¦#endif ¢/*Ù8** Macros to compute minimum and maximum of two numbers.¢*/«#ifndef MINÙ## define MIN(A,B) ((A)<(B)?(A):(B))¦#endif«#ifndef MAXÙ## define MAX(A,B) ((A)>(B)?(A):(B))¦#endif ¢/*Ù!** Swap two objects of type TYPE.¢*/Ù,#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;} ¢/*ÙA** Check to see if this machine uses EBCDIC.  (Yes, believe it orÙ<** not, there are still machines out there that use EBCDIC.)¢*/±#if 'A' == '\301'¸# define SQLITE_EBCDIC 1¥#else·# define SQLITE_ASCII 1¦#endif ¢/*ÙJ** Integers of known sizes.  These typedefs might change for architecturesÙG** where the sizes very.  Preprocessor macros are available so that theÙC** types can be conveniently redefined at compile-type.  Like this:¢**Ù0**         cc '-DUINTPTR_TYPE=long long int' ...¢*/³#ifndef UINT32_TYPEµ# ifdef HAVE_UINT32_T¾#  define UINT32_TYPE uint32_t¦# elseÙ"#  define UINT32_TYPE unsigned int§# endif¦#endif³#ifndef UINT16_TYPEµ# ifdef HAVE_UINT16_T¾#  define UINT16_TYPE uint16_t¦# elseÙ(#  define UINT16_TYPE unsigned short int§# endif¦#endif²#ifndef INT16_TYPE´# ifdef HAVE_INT16_T¼#  define INT16_TYPE int16_t¦# else¾#  define INT16_TYPE short int§# endif¦#endif²#ifndef UINT8_TYPE´# ifdef HAVE_UINT8_T¼#  define UINT8_TYPE uint8_t¦# elseÙ"#  define UINT8_TYPE unsigned char§# endif¦#endif±#ifndef INT8_TYPE³# ifdef HAVE_INT8_Tº#  define INT8_TYPE int8_t¦# else¿#  define INT8_TYPE signed char§# endif¦#endif·#ifndef LONGDOUBLE_TYPEÙ$# define LONGDOUBLE_TYPE long double¦#endifÙ>typedef sqlite_int64 i64;          /* 8-byte signed integer */Ù@typedef sqlite_uint64 u64;         /* 8-byte unsigned integer */Ù@typedef UINT32_TYPE u32;           /* 4-byte unsigned integer */Ù@typedef UINT16_TYPE u16;           /* 2-byte unsigned integer */Ù>typedef INT16_TYPE i16;            /* 2-byte signed integer */Ù@typedef UINT8_TYPE u8;             /* 1-byte unsigned integer */Ù>typedef INT8_TYPE i8;              /* 1-byte signed integer */ ¢/*ÙA** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 valueÙ?** that can be stored in a u32 without loss of data.  The valueÙF** is 0x00000000ffffffff.  But because of quirks of some compilers, weÙ@** have to specify the value in the less intuitive manner shown:¢*/Ù*#define SQLITE_MAX_U32  ((((u64)1)<<32)-1) ¢/*ÙB** The datatype used to store estimates of the number of rows in aÙC** table or index.  This is an unsigned integer type.  For 99.9% ofÙC** the world, a 32-bit integer is sufficient.  But a 64-bit integerÙ*** can be used at compile-time if desired.¢*/¹#ifdef SQLITE_64BIT_STATSÙG typedef u64 tRowcnt;    /* 64-bit only if requested at compile-time */¥#elseÙ4 typedef u32 tRowcnt;    /* 32-bit is the default */¦#endif ¢/*ÙD** Estimated quantities used for query planning are stored as 16-bitÙE** logarithms.  For quantity X, the value stored is 10*log2(X).  ThisÙG** gives a possible range of values of approximately 1.0e986 to 1e-986.ÙJ** But the allowed values are "grainy".  Not every value is representable.ÙE** For example, quantities 16 and 17 are both represented by a LogEstÙH** of 40.  However, since LogEst quantities are suppose to be estimates,Ù7** not exact values, this imprecision is not a problem.¢**Ù0** "LogEst" is short for "Logarithmic Estimate".¢**¬** Examples:Ù:**      1 -> 0              20 -> 43          10000 -> 132Ù:**      2 -> 10             25 -> 46          25000 -> 146Ù:**      3 -> 16            100 -> 66        1000000 -> 199Ù:**      4 -> 20           1000 -> 99        1048576 -> 200Ù:**     10 -> 33           1024 -> 100    4294967296 -> 320¢**Ù<** The LogEst can be negative to indicate fractional values.¬** Examples:¢**Ù:**    0.5 -> -10           0.1 -> -33        0.0625 -> -40¢*/ºtypedef INT16_TYPE LogEst; ¢/*ÙC** Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer¢*/¶#ifndef SQLITE_PTRSIZEÙ # if defined(__SIZEOF_POINTER__)Ù,#   define SQLITE_PTRSIZE __SIZEOF_POINTER__ÙK# elif defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \ÙA       defined(_M_ARM)   || defined(__arm__)    || defined(__x86)»#   define SQLITE_PTRSIZE 4¦# else»#   define SQLITE_PTRSIZE 8§# endif¦#endif ÙF/* The uptr type is an unsigned integer large enough to hold a pointer¢*/º#if defined(HAVE_STDINT_H)¹  typedef uintptr_t uptr;·#elif SQLITE_PTRSIZE==4³  typedef u32 uptr;¥#else³  typedef u64 uptr;¦#endif ¢/*ÙF** The SQLITE_WITHIN(P,S,E) macro checks to see if pointer P points toÙ5** something between S (inclusive) and E (exclusive).¢**ÙK** In other words, S is a buffer and E is a pointer to the first byte afterÙI** the end of buffer S.  This macro returns true if P points to somethingÙ!** contained within the buffer S.¢*/ÙL#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))  ¢/*ÙC** Macros to determine whether the machine is big or little endian,ÙE** and whether or not that determination is run-time or compile-time.¢**ÙF** For best performance, an attempt is made to guess at the byte-orderÙ?** using C-preprocessor macros.  If that is unsuccessful, or ifÙ=** -DSQLITE_BYTEORDER=0 is set, then byte-order is determined¯** at run-time.¢*/¸#ifndef SQLITE_BYTEORDERÙI# if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \ÙI     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \ÙI     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \µ     defined(__arm__)Ù##   define SQLITE_BYTEORDER    1234Ù,# elif defined(sparc)    || defined(__ppc__)Ù##   define SQLITE_BYTEORDER    4321¦# else½#   define SQLITE_BYTEORDER 0§# endif¦#endifº#if SQLITE_BYTEORDER==4321¾# define SQLITE_BIGENDIAN    1¾# define SQLITE_LITTLEENDIAN 0Ù+# define SQLITE_UTF16NATIVE  SQLITE_UTF16BE¼#elif SQLITE_BYTEORDER==1234¾# define SQLITE_BIGENDIAN    0¾# define SQLITE_LITTLEENDIAN 1Ù+# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE¥#else»# ifdef SQLITE_AMALGAMATION»  const int sqlite3one = 1;¦# else¾  extern const int sqlite3one;§# endifÙ8# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)Ù8# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)ÙM# define SQLITE_UTF16NATIVE  (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)¦#endif ¢/*ÙJ** Constants for the largest and smallest possible 64-bit signed integers.ÙH** These macros are designed to work correctly on both 32-bit and 64-bit­** compilers.¢*/Ù;#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))Ù2#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64) ¢/*ÙD** Round up a number to the next larger multiple of 8.  This is usedÙ5** to force 8-byte alignment on 64-bit architectures.¢*/Ù"#define ROUND8(x)     (((x)+7)&~7) ¢/*Ù*** Round down to the nearest multiple of 8¢*/¾#define ROUNDDOWN8(x) ((x)&~7) ¢/*ÙD** Assert that the pointer X is aligned to an 8-byte boundary.  ThisÙB** macro is used only within assert() to verify that the code getsÙ&** all alignment restrictions correct.¢**Ù?** Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then theÙD** underlying malloc() implementation might return us 4-byte alignedÙ9** pointers.  In that case, only verify 4-byte alignment.¢*/Ù##ifdef SQLITE_4_BYTE_ALIGNED_MALLOCÙC# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)¥#elseÙC# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)¦#endif ¢/*Ù:** Disable MMAP on platforms where it is known to not work¢*/Ù/#if defined(__OpenBSD__) || defined(__QNXNTO__)¼# undef SQLITE_MAX_MMAP_SIZE¿# define SQLITE_MAX_MMAP_SIZE 0¦#endif ¢/*ÙF** Default maximum size of memory used by memory-mapped I/O in the VFS¢*/°#ifdef __APPLE__Ù # include <TargetConditionals.h>¦#endif¼#ifndef SQLITE_MAX_MMAP_SIZE¹# if defined(__linux__) \¶  || defined(_WIN32) \Ù0  || (defined(__APPLE__) && defined(__MACH__)) \µ  || defined(__sun) \»  || defined(__FreeBSD__) \»  || defined(__DragonFly__)Ù<#   define SQLITE_MAX_MMAP_SIZE 0x7fff0000  /* 2147418112 */¦# elseÙ!#   define SQLITE_MAX_MMAP_SIZE 0§# endif¦#endif ¢/*ÙH** The default MMAP_SIZE is zero on all platforms.  Or, even if a largerÙI** default MMAP_SIZE is specified at compile-time, make sure that it doesÙ$** not exceed the maximum mmap size.¢*/Ù #ifndef SQLITE_DEFAULT_MMAP_SIZEÙ## define SQLITE_DEFAULT_MMAP_SIZE 0¦#endifÙ1#if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZEÙ # undef SQLITE_DEFAULT_MMAP_SIZEÙ6# define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE¦#endif ¢/*ÙI** Only one of SQLITE_ENABLE_STAT3 or SQLITE_ENABLE_STAT4 can be defined.ÙI** Priority is given to SQLITE_ENABLE_STAT4.  If either are defined, alsoÙ&** define SQLITE_ENABLE_STAT3_OR_STAT4¢*/º#ifdef SQLITE_ENABLE_STAT4»# undef SQLITE_ENABLE_STAT3Ù'# define SQLITE_ENABLE_STAT3_OR_STAT4 1¹#elif SQLITE_ENABLE_STAT3Ù'# define SQLITE_ENABLE_STAT3_OR_STAT4 1Ù"#elif SQLITE_ENABLE_STAT3_OR_STAT4Ù$# undef SQLITE_ENABLE_STAT3_OR_STAT4¦#endif ¢/*ÙH** SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or notÙ9** the Select query generator tracing logic is turned on.¢*/Ù&#if defined(SQLITE_ENABLE_SELECTTRACE)¾# define SELECTTRACE_ENABLED 1¥#else¾# define SELECTTRACE_ENABLED 0¦#endif ¢/*ÙK** An instance of the following structure is used to store the busy-handlerÙ&** callback for a given sqlite handle.¢**ÙG** The sqlite.busyHandler member of the sqlite struct contains the busyÙE** callback for the database handle. Each pager opened via the sqliteÙE** handle is passed a pointer to sqlite.busyHandler. The busy-handlerÙ:** callback is currently invoked only from within pager.c.¢*/Ù'typedef struct BusyHandler BusyHandler;´struct BusyHandler {Ù;  int (*xBusyHandler)(void *,int);  /* The busy callback */ÙD  void *pBusyArg;                   /* First arg to busy callback */ÙI  int nBusy;                        /* Incremented with each busy call */ÙN  u8 bExtraFileArg;                 /* Include sqlite3_file as callback arg */¢}; ¢/*Ù@** Name of the master database table.  The master database tableÙ@** is a special table that holds the names and attributes of all»** user tables and indices.¢*/Ù)#define MASTER_NAME       "sqlite_master"Ù.#define TEMP_MASTER_NAME  "sqlite_temp_master" ¢/*Ù.** The root-page of the master database table.¢*/»#define MASTER_ROOT       1 ¢/*Ù ** The name of the schema table.¢*/ÙN#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME) ¢/*Ù=** A convenience macro that returns the number of elements in¬** an array.¢*/Ù7#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0]))) ¢/*Ù.** Determine if the argument is a power of two¢*/Ù*#define IsPowerOfTwo(X) (((X)&((X)-1))==0) ¢/*ÙD** The following value as a destructor means to use sqlite3DbFree().ÙE** The sqlite3DbFree() routine requires two parameters instead of theÙI** one parameter that destructors normally want.  So we have to introduceÙC** this magic value that the code knows to handle differently.  AnyÙF** pointer will work here as long as it is distinct from SQLITE_STATIC¸** and SQLITE_TRANSIENT.¢*/ÙE#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3MallocSize) ¢/*ÙJ** When SQLITE_OMIT_WSD is defined, it means that the target platform doesÙN** not support Writable Static Data (WSD) such as global and static variables.ÙJ** All variables must either be on the stack or dynamically allocated fromÙJ** the heap.  When WSD is unsupported, the variable declarations scatteredÙL** throughout the SQLite code must become constants instead.  The SQLITE_WSDÙK** macro is used for this purpose.  And instead of referencing the variableÙJ** directly, we use its constant as a key to lookup the run-time allocatedÙI** buffer that holds real variable.  The constant is also the initializerÙ%** for the run-time allocated buffer.¢**ÙF** In the usual case where WSD is supported, the SQLITE_WSD and GLOBALÙ9** macros become no-ops and have zero performance impact.¢*/¶#ifdef SQLITE_OMIT_WSDº  #define SQLITE_WSD constÙE  #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))ÙI  #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)Ù.SQLITE_API int sqlite3_wsd_init(int N, int J);Ù2SQLITE_API void *sqlite3_wsd_find(void *K, int L);¥#else´  #define SQLITE_WSD·  #define GLOBAL(t,v) vÙ+  #define sqlite3GlobalConfig sqlite3Config¦#endif ¢/*ÙE** The following macros are used to suppress compiler warnings and toÙK** make it clear to human readers when a function parameter is deliberatelyÙG** left unused within the body of a function. This usually happens whenÙ?** a function is called via a function pointer. For example theÙC** implementation of an SQL aggregate step callback may not use theÙH** parameter indicating the number of arguments passed to the aggregate,Ù/** if it knows that this is enforced elsewhere.¢**ÙN** When a function parameter is not used at all within the body of a function,ÙM** it is generally named "NotUsed" or "NotUsed2" to make things even clearer.ÙI** However, these macros may also be used to suppress warnings related toÙK** parameters that may or may not be used depending on compilation options.ÙJ** For example those parameters only used in assert() statements. In theseÙ?** cases the parameters are named as per the usual conventions.¢*/Ù%#define UNUSED_PARAMETER(x) (void)(x)ÙF#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y) ¢/*Ù#** Forward references to structures¢*/¿typedef struct AggInfo AggInfo;Ù'typedef struct AuthContext AuthContext;Ù'typedef struct AutoincInfo AutoincInfo;½typedef struct Bitvec Bitvec;¿typedef struct CollSeq CollSeq;½typedef struct Column Column;µtypedef struct Db Db;½typedef struct Schema Schema;¹typedef struct Expr Expr;Ù!typedef struct ExprList ExprList;¹typedef struct FKey FKey;Ù-typedef struct FuncDestructor FuncDestructor;¿typedef struct FuncDef FuncDef;Ù'typedef struct FuncDefHash FuncDefHash;½typedef struct IdList IdList;»typedef struct Index Index;Ù'typedef struct IndexSample IndexSample;Ù!typedef struct KeyClass KeyClass;¿typedef struct KeyInfo KeyInfo;Ù#typedef struct Lookaside Lookaside;Ù+typedef struct LookasideSlot LookasideSlot;½typedef struct Module Module;Ù'typedef struct NameContext NameContext;»typedef struct Parse Parse;Ù#typedef struct PreUpdate PreUpdate;Ù/typedef struct PrintfArguments PrintfArguments;½typedef struct RowSet RowSet;Ù#typedef struct Savepoint Savepoint;½typedef struct Select Select;Ù)typedef struct SQLiteThread SQLiteThread;Ù%typedef struct SelectDest SelectDest;¿typedef struct SrcList SrcList;Ù!typedef struct StrAccum StrAccum;»typedef struct Table Table;Ù#typedef struct TableLock TableLock;»typedef struct Token Token;Ù!typedef struct TreeView TreeView;¿typedef struct Trigger Trigger;Ù%typedef struct TriggerPrg TriggerPrg;Ù'typedef struct TriggerStep TriggerStep;Ù-typedef struct UnpackedRecord UnpackedRecord;½typedef struct VTable VTable;¿typedef struct VtabCtx VtabCtx;½typedef struct Walker Walker;Ù#typedef struct WhereInfo WhereInfo;¹typedef struct With With; ÙJ/* A VList object records a mapping between parameters/variables/wildcardsÙE** in the SQL statement (such as $abc, @pqr, or :xyz) and the integerÙN** variable number associated with that parameter.  See the format descriptionÙL** on the sqlite3VListAdd() routine for more information.  A VList is really½** just an array of integers.¢*/²typedef int VList; ¢/*Ù=** Defer sourcing vdbe.h and btree.h until after the "u8" andÙC** "BusyHandler" typedefs. vdbe.h also requires a few of the opaqueÙ.** pointer types (i.e. FuncDef) defined above.¢*/ÙO/************** Include btree.h in the middle of sqliteInt.h *****************/ÙO/************** Begin file btree.h *******************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙE** This header file defines the interface that the sqlite B-Tree fileÙI** subsystem.  See comments in the source code for a detailed descriptionÙ'** of what each interface routine does.¢*/¶#ifndef SQLITE_BTREE_H¶#define SQLITE_BTREE_H ÙF/* TODO: This definition is just included so other modules compile. It¹** needs to be revisited.¢*/¾#define SQLITE_N_BTREE_META 16 ¢/*ÙG** If defined as non-zero, auto-vacuum is enabled by default. OtherwiseÙI** it must be turned on for each database using "PRAGMA auto_vacuum = 1".¢*/Ù!#ifndef SQLITE_DEFAULT_AUTOVACUUMÙ%  #define SQLITE_DEFAULT_AUTOVACUUM 0¦#endif ÙB#define BTREE_AUTOVACUUM_NONE 0        /* Do not do auto-vacuum */Ù@#define BTREE_AUTOVACUUM_FULL 1        /* Do full auto-vacuum */Ù?#define BTREE_AUTOVACUUM_INCR 2        /* Incremental vacuum */ ¢/*Ù$** Forward declarations of structure¢*/»typedef struct Btree Btree;Ù!typedef struct BtCursor BtCursor;Ù!typedef struct BtShared BtShared;Ù)typedef struct BtreePayload BtreePayload;  Ù$SQLITE_PRIVATE int sqlite3BtreeOpen(Ù<  sqlite3_vfs *pVfs,       /* VFS to use with this b-tree */Ù>  const char *zFilename,   /* Name of database file to open */Ù?  sqlite3 *db,             /* Associated database connection */Ù8  Btree **ppBtree,         /* Return open Btree* here */Ù&  int flags,               /* Flags */ÙA  int vfsFlags             /* Flags passed through to VFS open */¢); ÙG/* The flags parameter to sqlite3BtreeOpen can be the bitwise or of the´** following values.¢**ÙD** NOTE:  These values must match the corresponding PAGER_ values in«** pager.h.¢*/ÙL#define BTREE_OMIT_JOURNAL  1  /* Do not create or use a rollback journal */Ù<#define BTREE_MEMORY        2  /* This is an in-memory DB */ÙG#define BTREE_SINGLE        4  /* The file contains at most 1 b-tree */ÙG#define BTREE_UNORDERED     8  /* Use of a hash implementation is OK */ Ù-SQLITE_PRIVATE int sqlite3BtreeClose(Btree*);Ù8SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree*,int);Ù8SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree*,int);º#if SQLITE_MAX_MMAP_SIZE>0ÙDSQLITE_PRIVATE   int sqlite3BtreeSetMmapLimit(Btree*,sqlite3_int64);¦#endifÙ>SQLITE_PRIVATE int sqlite3BtreeSetPagerFlags(Btree*,unsigned);Ù\SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);Ù3SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*);Ù8SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int);Ù0SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);Ù8SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*,int);Ù9SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree*);Ù;SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p);Ù;SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int);Ù6SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *);Ù6SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int);ÙKSQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);Ù;SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree*, int);Ù.SQLITE_PRIVATE int sqlite3BtreeCommit(Btree*);Ù8SQLITE_PRIVATE int sqlite3BtreeRollback(Btree*,int,int);Ù5SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree*,int);ÙDSQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, int*, int flags);Ù1SQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree*);Ù5SQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree*);Ù2SQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree*);ÙGSQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));Ù;SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *pBtree);Ù #ifndef SQLITE_OMIT_SHARED_CACHEÙRSQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);¦#endifÙ<SQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *, int, int); Ù<SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *);Ù?SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *);Ù:SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *, Btree *); Ù3SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *); ÙG/* The flags parameter to sqlite3BtreeCreateTable can be the bitwise OR¼** of the flags shown below.¢**ÙI** Every SQLite table must have either BTREE_INTKEY or BTREE_BLOBKEY set.ÙJ** With BTREE_INTKEY, the table key is a 64-bit integer and arbitrary dataÙI** is stored in the leaves.  (BTREE_INTKEY is used for SQL tables.)  WithÙG** BTREE_BLOBKEY, the key is an arbitrary BLOB and no content is storedÙE** anywhere - the key is the content.  (BTREE_BLOBKEY is used for SQL¬** indices.)¢*/ÙM#define BTREE_INTKEY     1    /* Table has only 64-bit signed integer keys */ÙA#define BTREE_BLOBKEY    2    /* Table has keys only - no data */ Ù<SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree*, int, int*);Ù=SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, int*);Ù=SQLITE_PRIVATE int sqlite3BtreeClearTableOfCursor(BtCursor*);Ù@SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree*, int, int); ÙMSQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);ÙFSQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value); Ù/SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p); ¢/*ÙH** The second parameter to sqlite3BtreeGetMeta or sqlite3BtreeUpdateMetaÙJ** should be one of the following values. The integer values are assigned ÙC** to constants so that the offset of the corresponding field in anÙC** SQLite database header may be found using the following formula:¢**¼**   offset = 36 + (idx * 4)¢**ÙI** For example, the free-page-count field is located at byte offset 36 ofÙE** the database file header. The incr-vacuum-flag field is located at¾** byte offset 64 (== 36+4*7).¢**ÙK** The BTREE_DATA_VERSION value is not really a value stored in the header.ÙH** It is a read-only number computed by the pager.  But we merge it withÙI** the header value access routines since its access pattern is the same.Ù"** Call it a "virtual meta value".¢*/Ù##define BTREE_FREE_PAGE_COUNT     0Ù##define BTREE_SCHEMA_VERSION      1Ù##define BTREE_FILE_FORMAT         2Ù##define BTREE_DEFAULT_CACHE_SIZE  3Ù##define BTREE_LARGEST_ROOT_PAGE   4Ù##define BTREE_TEXT_ENCODING       5Ù##define BTREE_USER_VERSION        6Ù##define BTREE_INCR_VACUUM         7Ù##define BTREE_APPLICATION_ID      8Ù@#define BTREE_DATA_VERSION        15  /* A virtual meta-value */ ¢/*ÙF** Kinds of hints that can be passed into the sqlite3BtreeCursorHint()­** interface.¢**Ù-** BTREE_HINT_RANGE  (arguments: Expr*, Mem*)¢**ÙM**     The first argument is an Expr* (which is guaranteed to be constant forÙI**     the lifetime of the cursor) that defines constraints on which rowsÙE**     might be fetched with this cursor.  The Expr* tree may containÙN**     TK_REGISTER nodes that refer to values stored in the array of registersÙO**     passed as the second parameter.  In other words, if Expr.op==TK_REGISTERÙI**     then the value of the node is the value in Mem[pExpr.iTable].  AnyÙJ**     TK_COLUMN node in the expression tree refers to the Expr.iColumn-thÙJ**     column of the b-tree of the cursor.  The Expr tree will not containÙM**     any function calls nor subqueries nor references to b-trees other than¿**     the cursor being hinted.¢**ÙK**     The design of the _RANGE hint is aid b-tree implementations that tryÙB**     to prefetch content from remote machines - to provide thoseÙM**     implementations with limits on what needs to be prefetched and therebyÙ **     reduce network bandwidth.¢**ÙJ** Note that BTREE_HINT_FLAGS with BTREE_BULKLOAD is the only hint used byÙI** standard SQLite.  The other hints are provided for extentions that useÙH** the SQLite parser and code generator but substitute their own storageª** engine.¢*/ÙC#define BTREE_HINT_RANGE 0       /* Range constraints on queries */ ¢/*Ù?** Values that may be OR'd together to form the argument to theÙ6** BTREE_HINT_FLAGS hint for sqlite3BtreeCursorHint():¢**ÙJ** The BTREE_BULKLOAD flag is set on index cursors when the index is goingÙ=** to be filled with content that is already in sorted order.¢**ÙF** The BTREE_SEEK_EQ flag is set on cursors that will get OP_SeekGE orÙG** OP_SeekLE opcodes for a range search, but where the range of entriesÙH** selected will all have the same key.  In other words, the cursor willÙ*** be used only for equality key searches.¢**¢*/ÙK#define BTREE_BULKLOAD 0x00000001  /* Used to full index in sorted order */ÙG#define BTREE_SEEK_EQ  0x00000002  /* EQ seeks only - no range seeks */ £/* Ù>** Flags passed as the third argument to sqlite3BtreeCursor().¢**ÙK** For read-only cursors the wrFlag argument is always zero. For read-writeÙH** cursors it may be set to either (BTREE_WRCSR|BTREE_FORDELETE) or justÙI** (BTREE_WRCSR). If the BTREE_FORDELETE bit is set, then the cursor willÙ,** only be used by SQLite for the following:¢**Ù:**   * to seek to and then delete specific entries, and/or¢**ÙA**   * to read values that will be used to create keys that otherÙ7**     BTREE_FORDELETE cursors will seek to and delete.¢**ÙG** The BTREE_FORDELETE flag is an optimization hint.  It is not used byÙF** by this, the native b-tree engine of SQLite, but it is available toÙI** alternative storage engines that might be substituted in place of thisÙG** b-tree system.  For alternative storage engines in which a delete ofÙE** the main table row automatically deletes corresponding index rows,ÙF** the FORDELETE flag hint allows those alternative storage engines toÙE** skip a lot of work.  Namely:  FORDELETE cursors may treat all SEEKÙD** and DELETE operations as no-ops, and any READ operation against aÙ5** FORDELETE cursor may return a null row: 0x01 0x00.¢*/Ù>#define BTREE_WRCSR     0x00000004     /* read-write cursor */ÙK#define BTREE_FORDELETE 0x00000008     /* Cursor is for seek/delete only */ Ù&SQLITE_PRIVATE int sqlite3BtreeCursor(ÙK  Btree*,                              /* BTree containing table to open */Ù?  int iTable,                          /* Index of root page */ÙL  int wrFlag,                          /* 1 for writing.  0 for read-only */ÙO  struct KeyInfo*,                     /* First argument to compare function */ÙL  BtCursor *pCursor                    /* Space to write cursor structure */¢);Ù;SQLITE_PRIVATE BtCursor *sqlite3BtreeFakeValidCursor(void);Ù0SQLITE_PRIVATE int sqlite3BtreeCursorSize(void);Ù6SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor*);ÙESQLITE_PRIVATE void sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);Ù!#ifdef SQLITE_ENABLE_CURSOR_HINTSÙ@SQLITE_PRIVATE void sqlite3BtreeCursorHint(BtCursor*, int, ...);¦#endif Ù6SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor*);Ù.SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(¬  BtCursor*,¹  UnpackedRecord *pUnKey,­  i64 intKey,«  int bias,«  int *pRes¢);Ù9SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*);Ù>SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor*, int*);Ù;SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*, u8 flags); ÙE/* Allowed flags for sqlite3BtreeDelete() and sqlite3BtreeInsert() */ÙL#define BTREE_SAVEPOSITION 0x02  /* Leave cursor pointing at NEXT or PREV */ÙG#define BTREE_AUXDELETE    0x04  /* not the primary delete operation */ÙA#define BTREE_APPEND       0x08  /* Insert is likely an append */ ÙK/* An instance of the BtreePayload object describes the content of a singleÙ+** entry in either an index or table btree.¢**ÙH** Index btrees (used for indexes and also WITHOUT ROWID tables) containÙJ** an arbitrary key and no data.  These btrees have pKey,nKey set to theirÙ)** key and pData,nData,nZero set to zero.¢**ÙH** Table btrees (used for rowid tables) contain an integer rowid used asÙC** the key and passed in the nKey field.  The pKey field is zero.  ÙI** pData,nData hold the content of the new entry.  nZero extra zero bytesÙF** are appended to the end of the content when constructing the entry.¢**ÙJ** This object is used to pass information into sqlite3BtreeInsert().  TheÙO** same information used to be passed as five separate parameters.  But placingÙE** the information into this object helps to keep the interface more ÙH** organized and understandable, and it also helps the resulting code toÙF** run a little faster by using fewer registers for parameter passing.¢*/µstruct BtreePayload {ÙI  const void *pKey;       /* Key content for indexes.  NULL for tables */ÙO  sqlite3_int64 nKey;     /* Size of pKey for indexes.  PRIMARY KEY for tabs */ÙB  const void *pData;      /* Data for tables.  NULL for indexes */ÙH  sqlite3_value *aMem;    /* First of nMem value in the unpacked pKey */ÙF  u16 nMem;               /* Number of aMem[] value.  Might be zero */Ù:  int nData;              /* Size of pData.  0 if none. */ÙJ  int nZero;              /* Extra zero data appended after pData,nData */¢}; ÙNSQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,Ù2                       int flags, int seekResult);Ù;SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes);Ù:SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes);Ù:SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int flags);Ù.SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*);Ù>SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int flags);Ù5SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor*);Ù$#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNCÙ1SQLITE_PRIVATE i64 sqlite3BtreeOffset(BtCursor*);¦#endifÙNSQLITE_PRIVATE int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);ÙJSQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);Ù6SQLITE_PRIVATE u32 sqlite3BtreePayloadSize(BtCursor*); ÙZSQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);Ù7SQLITE_PRIVATE struct Pager *sqlite3BtreePager(Btree*);Ù6SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor*); ¼#ifndef SQLITE_OMIT_INCRBLOBÙUSQLITE_PRIVATE int sqlite3BtreePayloadChecked(BtCursor*, u32 offset, u32 amt, void*);ÙNSQLITE_PRIVATE int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);Ù;SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *);¦#endifÙ8SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *);ÙDSQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);ÙKSQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);Ù6SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *pBt);Ù0SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void); ®#ifndef NDEBUGÙ8SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor*);¦#endifÙ:SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor*); ¾#ifndef SQLITE_OMIT_BTREECOUNTÙ8SQLITE_PRIVATE int sqlite3BtreeCount(BtCursor *, i64 *);¦#endif ²#ifdef SQLITE_TESTÙ@SQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int);Ù3SQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*);¦#endif ·#ifndef SQLITE_OMIT_WALÙGSQLITE_PRIVATE   int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);¦#endif ¢/*Ù=** If we are not using shared cache, then there is no need toÙ>** use mutexes to access the BtShared structures.  So make theÙ%** Enter and Leave procedures no-ops.¢*/Ù #ifndef SQLITE_OMIT_SHARED_CACHEÙ0SQLITE_PRIVATE   void sqlite3BtreeEnter(Btree*);Ù5SQLITE_PRIVATE   void sqlite3BtreeEnterAll(sqlite3*);Ù2SQLITE_PRIVATE   int sqlite3BtreeSharable(Btree*);Ù9SQLITE_PRIVATE   void sqlite3BtreeEnterCursor(BtCursor*);Ù9SQLITE_PRIVATE   int sqlite3BtreeConnectionCount(Btree*);¥#else¾# define sqlite3BtreeEnter(X) Ù # define sqlite3BtreeEnterAll(X)Ù"# define sqlite3BtreeSharable(X) 0Ù## define sqlite3BtreeEnterCursor(X)Ù)# define sqlite3BtreeConnectionCount(X) 1¦#endif Ù;#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFEÙ0SQLITE_PRIVATE   void sqlite3BtreeLeave(Btree*);Ù9SQLITE_PRIVATE   void sqlite3BtreeLeaveCursor(BtCursor*);Ù5SQLITE_PRIVATE   void sqlite3BtreeLeaveAll(sqlite3*);®#ifndef NDEBUGÙ@  /* These routines are used inside assert() statements only. */Ù4SQLITE_PRIVATE   int sqlite3BtreeHoldsMutex(Btree*);Ù;SQLITE_PRIVATE   int sqlite3BtreeHoldsAllMutexes(sqlite3*);ÙBSQLITE_PRIVATE   int sqlite3SchemaMutexHeld(sqlite3*,int,Schema*);¦#endif¥#else ½# define sqlite3BtreeLeave(X)Ù## define sqlite3BtreeLeaveCursor(X)Ù # define sqlite3BtreeLeaveAll(X) Ù$# define sqlite3BtreeHoldsMutex(X) 1Ù)# define sqlite3BtreeHoldsAllMutexes(X) 1Ù(# define sqlite3SchemaMutexHeld(X,Y,Z) 1¦#endif  »#endif /* SQLITE_BTREE_H */ ÙO/************** End of btree.h ***********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ÙO/************** Include vdbe.h in the middle of sqliteInt.h ******************/ÙO/************** Begin file vdbe.h ********************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù5** Header file for the Virtual DataBase Engine (VDBE)¢**ÙC** This header defines the interface to the virtual database engineÙ@** or VDBE.  The VDBE implements an abstract machine that runs aÙ?** simple program to access and modify the underlying database.¢*/µ#ifndef SQLITE_VDBE_Hµ#define SQLITE_VDBE_H¸/* #include <stdio.h> */ ¢/*ÙD** A single VDBE is an opaque structure named "Vdbe".  Only routinesÙA** in the source file sqliteVdbe.c are allowed to see the insidesµ** of this structure.¢*/¹typedef struct Vdbe Vdbe; ¢/*ÙF** The names of the following types declared in vdbeInt.h are required½** for the VdbeOp definition.¢*/Ù!typedef struct sqlite3_value Mem;Ù%typedef struct SubProgram SubProgram; ¢/*Ù<** A single instruction of the virtual machine has an opcodeÙ>** and as many as three operands.  The instruction is recordedÙ-** as an instance of the following structure:¢*/¯struct VdbeOp {Ù5  u8 opcode;          /* What operation to perform */Ù>  signed char p4type; /* One of the P4_xxx constants for p4 */ÙI  u16 p5;             /* Fifth parameter is an unsigned 16-bit integer */Ù)  int p1;             /* First operand */ÙI  int p2;             /* Second parameter (often the jump destination) */Ù/  int p3;             /* The third parameter */Ù,  union p4union {     /* fourth parameter */ÙB    int i;                 /* Integer value if p4type==P4_INT32 */Ù0    void *p;               /* Generic pointer */ÙN    char *z;               /* Pointer to data for string (char array) types */Ù=    i64 *pI64;             /* Used when p4type is P4_INT64 */Ù<    double *pReal;         /* Used when p4type is P4_REAL */Ù?    FuncDef *pFunc;        /* Used when p4type is P4_FUNCDEF */Ù?    sqlite3_context *pCtx; /* Used when p4type is P4_FUNCCTX */Ù?    CollSeq *pColl;        /* Used when p4type is P4_COLLSEQ */Ù;    Mem *pMem;             /* Used when p4type is P4_MEM */Ù<    VTable *pVtab;         /* Used when p4type is P4_VTAB */Ù?    KeyInfo *pKeyInfo;     /* Used when p4type is P4_KEYINFO */Ù@    int *ai;               /* Used when p4type is P4_INTARRAY */ÙB    SubProgram *pProgram;  /* Used when p4type is P4_SUBPROGRAM */Ù=    Table *pTab;           /* Used when p4type is P4_TABLE */Ù!#ifdef SQLITE_ENABLE_CURSOR_HINTSÙ<    Expr *pExpr;           /* Used when p4type is P4_EXPR */¦#endifÙ%    int (*xAdvance)(BtCursor *, int);§  } p4;Ù%#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTSÙ?  char *zComment;          /* Comment to improve readability */¦#endif³#ifdef VDBE_PROFILEÙN  u32 cnt;                 /* Number of times this instruction was executed */ÙL  u64 cycles;              /* Total time spent executing this instruction */¦#endif»#ifdef SQLITE_VDBE_COVERAGEÙL  int iSrcLine;            /* Source-code line that generated this opcode */¦#endif¢};½typedef struct VdbeOp VdbeOp;  ¢/*Ù5** A sub-routine used to implement a trigger program.¢*/³struct SubProgram {ÙF  VdbeOp *aOp;                  /* Array of opcodes for sub-program */Ù7  int nOp;                      /* Elements in aOp[] */ÙE  int nMem;                     /* Number of memory cells required */Ù@  int nCsr;                     /* Number of cursors required */Ù<  u8 *aOnce;                    /* Array of OP_Once flags */ÙO  void *token;                  /* id that may be used to recursive triggers */ÙF  SubProgram *pNext;            /* Next sub-program already visited */¢}; ¢/*ÙL** A smaller version of VdbeOp used for the VdbeAddOpList() function becauseº** it takes up less space.¢*/³struct VdbeOpList {Ù5  u8 opcode;          /* What operation to perform */Ù)  signed char p1;     /* First operand */ÙI  signed char p2;     /* Second parameter (often the jump destination) */Ù+  signed char p3;     /* Third parameter */¢};Ù%typedef struct VdbeOpList VdbeOpList; ¢/*Ù"** Allowed values of VdbeOp.p4type¢*/Ù>#define P4_NOTUSED      0   /* The P4 parameter is not used */ÙG#define P4_TRANSIENT    0   /* P4 is a pointer to a transient string */Ù<#define P4_STATIC     (-1)  /* Pointer to a static string */ÙH#define P4_COLLSEQ    (-2)  /* P4 is a pointer to a CollSeq structure */Ù?#define P4_INT32      (-3)  /* P4 is a 32-bit signed integer */ÙK#define P4_SUBPROGRAM (-4)  /* P4 is a pointer to a SubProgram structure */ÙO#define P4_ADVANCE    (-5)  /* P4 is a pointer to BtreeNext() or BtreePrev() */ÙF#define P4_TABLE      (-6)  /* P4 is a pointer to a Table structure */Ù</* Above do not own any resources.  Must free those below */º#define P4_FREE_IF_LE (-7)ÙG#define P4_DYNAMIC    (-7)  /* Pointer to memory from sqliteMalloc() */ÙH#define P4_FUNCDEF    (-8)  /* P4 is a pointer to a FuncDef structure */ÙH#define P4_KEYINFO    (-9)  /* P4 is a pointer to a KeyInfo structure */ÙA#define P4_EXPR       (-10) /* P4 is a pointer to an Expr tree */ÙH#define P4_MEM        (-11) /* P4 is a pointer to a Mem*    structure */ÙN#define P4_VTAB       (-12) /* P4 is a pointer to an sqlite3_vtab structure */ÙE#define P4_REAL       (-13) /* P4 is a 64-bit floating point value */Ù?#define P4_INT64      (-14) /* P4 is a 64-bit signed integer */ÙC#define P4_INTARRAY   (-15) /* P4 is a vector of 32-bit integers */ÙN#define P4_FUNCCTX    (-16) /* P4 is a pointer to an sqlite3_context object */ÙG#define P4_DYNBLOB    (-17) /* Pointer to memory from sqliteMalloc() */ Ù%/* Error message codes for OP_Halt */¾#define P5_ConstraintNotNull 1¾#define P5_ConstraintUnique  2¾#define P5_ConstraintCheck   3¾#define P5_ConstraintFK      4 ¢/*ÙF** The Vdbe.aColName array contains 5n Mem structures, where n is the Ù7** number of columns of data returned by the statement.¢*/º#define COLNAME_NAME     0º#define COLNAME_DECLTYPE 1º#define COLNAME_DATABASE 2º#define COLNAME_TABLE    3º#define COLNAME_COLUMN   4Ù$#ifdef SQLITE_ENABLE_COLUMN_METADATAÙD# define COLNAME_N        5      /* Number of COLNAME_xxx symbols */¥#else¼# ifdef SQLITE_OMIT_DECLTYPEÙ:#   define COLNAME_N      1      /* Store only the name */¦# elseÙB#   define COLNAME_N      2      /* Store the name and decltype */§# endif¦#endif ¢/*ÙB** The following macro converts a relative address in the p2 fieldÙ8** of a VdbeOp structure into a negative number so that ÙF** sqlite3VdbeAddOpList() knows that the address is relative.  CallingÙ(** the macro again restores the address.¢*/¹#define ADDR(X)  (-1-(X)) ¢/*ÙH** The makefile scans the vdbe.c source file and creates the "opcodes.h"ÙF** header file that defines a number for each opcode used by the VDBE.¢*/ÙO/************** Include opcodes.h in the middle of vdbe.h ********************/ÙO/************** Begin file opcodes.h *****************************************/Ù+/* Automatically generated.  Do not edit */Ù3/* See the tool/mkopcodeh.tcl script for details */¼#define OP_Savepoint       0¼#define OP_AutoCommit      1¼#define OP_Transaction     2ÙM#define OP_SorterNext      3 /* jump                                       */ÙM#define OP_PrevIfOpen      4 /* jump                                       */ÙM#define OP_NextIfOpen      5 /* jump                                       */ÙM#define OP_Prev            6 /* jump                                       */ÙM#define OP_Next            7 /* jump                                       */¼#define OP_Checkpoint      8¼#define OP_JournalMode     9¼#define OP_Vacuum         10ÙM#define OP_VFilter        11 /* jump, synopsis: iplan=r[P3] zplan='P4'     */ÙM#define OP_VUpdate        12 /* synopsis: data=r[P3@P2]                    */ÙM#define OP_Goto           13 /* jump                                       */ÙM#define OP_Gosub          14 /* jump                                       */ÙM#define OP_InitCoroutine  15 /* jump                                       */ÙM#define OP_Yield          16 /* jump                                       */ÙM#define OP_MustBeInt      17 /* jump                                       */ÙM#define OP_Jump           18 /* jump                                       */ÙM#define OP_Not            19 /* same as TK_NOT, synopsis: r[P2]= !r[P1]    */ÙM#define OP_Once           20 /* jump                                       */ÙM#define OP_If             21 /* jump                                       */ÙM#define OP_IfNot          22 /* jump                                       */ÙY#define OP_IfNullRow      23 /* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 */ÙM#define OP_SeekLT         24 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_SeekLE         25 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_SeekGE         26 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_SeekGT         27 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_NoConflict     28 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_NotFound       29 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_Found          30 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_SeekRowid      31 /* jump, synopsis: intkey=r[P3]               */ÙM#define OP_NotExists      32 /* jump, synopsis: intkey=r[P3]               */ÙM#define OP_Last           33 /* jump                                       */ÙM#define OP_IfSmaller      34 /* jump                                       */ÙM#define OP_SorterSort     35 /* jump                                       */ÙM#define OP_Sort           36 /* jump                                       */ÙM#define OP_Rewind         37 /* jump                                       */ÙM#define OP_IdxLE          38 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_IdxGT          39 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_IdxLT          40 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_IdxGE          41 /* jump, synopsis: key=r[P3@P4]               */ÙM#define OP_RowSetRead     42 /* jump, synopsis: r[P3]=rowset(P1)           */ÙR#define OP_Or             43 /* same as TK_OR, synopsis: r[P3]=(r[P1] || r[P2]) */ÙS#define OP_And            44 /* same as TK_AND, synopsis: r[P3]=(r[P1] && r[P2]) */ÙQ#define OP_RowSetTest     45 /* jump, synopsis: if r[P3] in rowset(P1) goto P2 */ÙM#define OP_Program        46 /* jump                                       */ÙM#define OP_FkIfZero       47 /* jump, synopsis: if fkctr[P1]==0 goto P2    */ÙU#define OP_IfPos          48 /* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 */ÙT#define OP_IfNotZero      49 /* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 */Ù\#define OP_IsNull         50 /* jump, same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 */Ù]#define OP_NotNull        51 /* jump, same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 */ÙQ#define OP_Ne             52 /* jump, same as TK_NE, synopsis: IF r[P3]!=r[P1] */ÙQ#define OP_Eq             53 /* jump, same as TK_EQ, synopsis: IF r[P3]==r[P1] */ÙP#define OP_Gt             54 /* jump, same as TK_GT, synopsis: IF r[P3]>r[P1] */ÙQ#define OP_Le             55 /* jump, same as TK_LE, synopsis: IF r[P3]<=r[P1] */ÙP#define OP_Lt             56 /* jump, same as TK_LT, synopsis: IF r[P3]<r[P1] */ÙQ#define OP_Ge             57 /* jump, same as TK_GE, synopsis: IF r[P3]>=r[P1] */ÙM#define OP_ElseNotEq      58 /* jump, same as TK_ESCAPE                    */ÙM#define OP_DecrJumpZero   59 /* jump, synopsis: if (--r[P1])==0 goto P2    */ÙM#define OP_IncrVacuum     60 /* jump                                       */ÙM#define OP_VNext          61 /* jump                                       */ÙM#define OP_Init           62 /* jump, synopsis: Start at P2                */¼#define OP_Return         63¼#define OP_EndCoroutine   64ÙM#define OP_HaltIfNull     65 /* synopsis: if r[P3]=null halt               */¼#define OP_Halt           66ÙM#define OP_Integer        67 /* synopsis: r[P2]=P1                         */ÙM#define OP_Int64          68 /* synopsis: r[P2]=P4                         */ÙM#define OP_String         69 /* synopsis: r[P2]='P4' (len=P1)              */ÙM#define OP_Null           70 /* synopsis: r[P2..P3]=NULL                   */ÙM#define OP_SoftNull       71 /* synopsis: r[P1]=NULL                       */ÙM#define OP_Blob           72 /* synopsis: r[P2]=P4 (len=P1)                */ÙM#define OP_Variable       73 /* synopsis: r[P2]=parameter(P1,P4)           */ÙM#define OP_Move           74 /* synopsis: r[P2@P3]=r[P1@P3]                */ÙM#define OP_Copy           75 /* synopsis: r[P2@P3+1]=r[P1@P3+1]            */ÙM#define OP_SCopy          76 /* synopsis: r[P2]=r[P1]                      */ÙM#define OP_IntCopy        77 /* synopsis: r[P2]=r[P1]                      */ÙM#define OP_ResultRow      78 /* synopsis: output=r[P1@P2]                  */¼#define OP_CollSeq        79ÙM#define OP_AddImm         80 /* synopsis: r[P1]=r[P1]+P2                   */¼#define OP_RealAffinity   81ÙM#define OP_Cast           82 /* synopsis: affinity(r[P1])                  */¼#define OP_Permutation    83ÙQ#define OP_BitAnd         84 /* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] */ÙP#define OP_BitOr          85 /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */ÙR#define OP_ShiftLeft      86 /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] */ÙR#define OP_ShiftRight     87 /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] */ÙO#define OP_Add            88 /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */ÙP#define OP_Subtract       89 /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */ÙO#define OP_Multiply       90 /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */ÙP#define OP_Divide         91 /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */ÙN#define OP_Remainder      92 /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */ÙQ#define OP_Concat         93 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */ÙM#define OP_Compare        94 /* synopsis: r[P1@P3] <-> r[P2@P3]            */ÙM#define OP_BitNot         95 /* same as TK_BITNOT, synopsis: r[P1]= ~r[P1] */ÙR#define OP_IsTrue         96 /* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 */ÙM#define OP_String8        97 /* same as TK_STRING, synopsis: r[P2]='P4'    */ÙM#define OP_Offset         98 /* synopsis: r[P3] = sqlite_offset(P1)        */ÙM#define OP_Column         99 /* synopsis: r[P3]=PX                         */ÙM#define OP_Affinity      100 /* synopsis: affinity(r[P1@P2])               */ÙM#define OP_MakeRecord    101 /* synopsis: r[P3]=mkrec(r[P1@P2])            */ÙM#define OP_Count         102 /* synopsis: r[P2]=count()                    */¼#define OP_ReadCookie    103¼#define OP_SetCookie     104ÙM#define OP_ReopenIdx     105 /* synopsis: root=P2 iDb=P3                   */ÙM#define OP_OpenRead      106 /* synopsis: root=P2 iDb=P3                   */ÙM#define OP_OpenWrite     107 /* synopsis: root=P2 iDb=P3                   */¼#define OP_OpenDup       108ÙM#define OP_OpenAutoindex 109 /* synopsis: nColumn=P2                       */ÙM#define OP_OpenEphemeral 110 /* synopsis: nColumn=P2                       */¼#define OP_SorterOpen    111ÙM#define OP_SequenceTest  112 /* synopsis: if( cursor[P1].ctr++ ) pc = P2   */ÙM#define OP_OpenPseudo    113 /* synopsis: P3 columns in r[P2]              */¼#define OP_Close         114¼#define OP_ColumnsUsed   115ÙM#define OP_Sequence      116 /* synopsis: r[P2]=cursor[P1].ctr++           */ÙM#define OP_NewRowid      117 /* synopsis: r[P2]=rowid                      */ÙM#define OP_Insert        118 /* synopsis: intkey=r[P3] data=r[P2]          */ÙM#define OP_InsertInt     119 /* synopsis: intkey=P3 data=r[P2]             */¼#define OP_Delete        120¼#define OP_ResetCount    121ÙO#define OP_SorterCompare 122 /* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 */ÙM#define OP_SorterData    123 /* synopsis: r[P2]=data                       */ÙM#define OP_RowData       124 /* synopsis: r[P2]=data                       */ÙM#define OP_Rowid         125 /* synopsis: r[P2]=rowid                      */¼#define OP_NullRow       126¼#define OP_SeekEnd       127ÙM#define OP_SorterInsert  128 /* synopsis: key=r[P2]                        */ÙM#define OP_IdxInsert     129 /* synopsis: key=r[P2]                        */ÙM#define OP_IdxDelete     130 /* synopsis: key=r[P2@P3]                     */ÙM#define OP_DeferredSeek  131 /* synopsis: Move P3 to P1.rowid if needed    */ÙM#define OP_Real          132 /* same as TK_FLOAT, synopsis: r[P2]=P4       */ÙM#define OP_IdxRowid      133 /* synopsis: r[P2]=rowid                      */¼#define OP_Destroy       134¼#define OP_Clear         135¼#define OP_ResetSorter   136ÙM#define OP_CreateBtree   137 /* synopsis: r[P2]=root iDb=P1 flags=P3       */¼#define OP_SqlExec       138¼#define OP_ParseSchema   139¼#define OP_LoadAnalysis  140¼#define OP_DropTable     141¼#define OP_DropIndex     142¼#define OP_DropTrigger   143¼#define OP_IntegrityCk   144ÙM#define OP_RowSetAdd     145 /* synopsis: rowset(P1)=r[P2]                 */¼#define OP_Param         146ÙM#define OP_FkCounter     147 /* synopsis: fkctr[P1]+=P2                    */ÙM#define OP_MemMax        148 /* synopsis: r[P1]=max(r[P1],r[P2])           */Ùe#define OP_OffsetLimit   149 /* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */ÙM#define OP_AggStep0      150 /* synopsis: accum=r[P3] step(r[P2@P5])       */ÙM#define OP_AggStep       151 /* synopsis: accum=r[P3] step(r[P2@P5])       */ÙM#define OP_AggFinal      152 /* synopsis: accum=r[P1] N=P2                 */¼#define OP_Expire        153ÙM#define OP_TableLock     154 /* synopsis: iDb=P1 root=P2 write=P3          */¼#define OP_VBegin        155¼#define OP_VCreate       156¼#define OP_VDestroy      157¼#define OP_VOpen         158ÙM#define OP_VColumn       159 /* synopsis: r[P3]=vcolumn(P2)                */¼#define OP_VRename       160¼#define OP_Pagecount     161¼#define OP_MaxPgcnt      162¼#define OP_PureFunc0     163ÙM#define OP_Function0     164 /* synopsis: r[P3]=func(r[P2@P5])             */¼#define OP_PureFunc      165ÙM#define OP_Function      166 /* synopsis: r[P3]=func(r[P2@P5])             */¼#define OP_Trace         167¼#define OP_CursorHint    168¼#define OP_Noop          169¼#define OP_Explain       170 Ù</* Properties such as "out2" or "jump" that are specified inÙ>** comments following the "case" for each opcode in the vdbe.cÙ*** are encoded into bitvectors as follows:¢*/Ù@#define OPFLG_JUMP        0x01  /* jump:  P2 holds jmp target */Ù;#define OPFLG_IN1         0x02  /* in1:   P1 is an input */Ù;#define OPFLG_IN2         0x04  /* in2:   P2 is an input */Ù;#define OPFLG_IN3         0x08  /* in3:   P3 is an input */Ù<#define OPFLG_OUT2        0x10  /* out2:  P2 is an output */Ù<#define OPFLG_OUT3        0x20  /* out3:  P3 is an output */¼#define OPFLG_INITIALIZER {\Ù:/*   0 */ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,\Ù:/*   8 */ 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01,\Ù:/*  16 */ 0x03, 0x03, 0x01, 0x12, 0x01, 0x03, 0x03, 0x01,\Ù:/*  24 */ 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,\Ù:/*  32 */ 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\Ù:/*  40 */ 0x01, 0x01, 0x23, 0x26, 0x26, 0x0b, 0x01, 0x01,\Ù:/*  48 */ 0x03, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\Ù:/*  56 */ 0x0b, 0x0b, 0x01, 0x03, 0x01, 0x01, 0x01, 0x02,\Ù:/*  64 */ 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00,\Ù:/*  72 */ 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\Ù:/*  80 */ 0x02, 0x02, 0x02, 0x00, 0x26, 0x26, 0x26, 0x26,\Ù:/*  88 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12,\Ù:/*  96 */ 0x12, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10, 0x10,\Ù:/* 104 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\Ù:/* 112 */ 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\Ù:/* 120 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,\Ù:/* 128 */ 0x04, 0x04, 0x00, 0x00, 0x10, 0x10, 0x10, 0x00,\Ù:/* 136 */ 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\Ù:/* 144 */ 0x00, 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00,\Ù:/* 152 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\Ù:/* 160 */ 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,\¼/* 168 */ 0x00, 0x00, 0x00,} ÙB/* The sqlite3P2Values() routine is able to run faster if it knowsÙA** the value of the largest JUMP opcode.  The smaller the maximumÙ;** JUMP opcode the better, so the mkopcodeh.tcl script thatÙ@** generated this include file strives to group all JUMP opcodesÙ+** together near the beginning of the list.¢*/Ù<#define SQLITE_MX_JUMP_OPCODE  62  /* Maximum JUMP opcode */ ÙO/************** End of opcodes.h *********************************************/ÙO/************** Continuing where we left off in vdbe.h ***********************/ ¢/*Ù/** Additional non-public SQLITE_PREPARE_* flags¢*/Ù=#define SQLITE_PREPARE_SAVESQL  0x80  /* Preserve SQL text */Ù@#define SQLITE_PREPARE_MASK     0x0f  /* Mask of public flags */ ¢/*ÙI** Prototypes for the VDBE interface.  See comments on the implementationÙ9** for a description of what each of these routines does.¢*/Ù/SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse*);Ù0SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*,int);Ù4SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*,int,int);Ù8SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*,int,int,int);Ù.SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe*,int);Ù@SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe*,int,const char*);ÙDSQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);Ù<SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);ÙPSQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);ÙNSQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);ÙCSQLITE_PRIVATE int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);Ù7SQLITE_PRIVATE void sqlite3VdbeEndCoroutine(Vdbe*,int);ÙA#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)ÙHSQLITE_PRIVATE   void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);Ù<SQLITE_PRIVATE   void sqlite3VdbeVerifyNoResultRow(Vdbe *p);¥#elseÙ/# define sqlite3VdbeVerifyNoMallocRequired(A,B)Ù(# define sqlite3VdbeVerifyNoResultRow(A)¦#endifÙ`SQLITE_PRIVATE VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp, int iLineno);ÙASQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*,int,char*);ÙASQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, u32 addr, u8);ÙASQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, u32 addr, int P1);ÙASQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, u32 addr, int P2);ÙASQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, u32 addr, int P3);Ù7SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u16 P5);Ù9SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr);Ù<SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe*, int addr);Ù>SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);ÙQSQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);ÙFSQLITE_PRIVATE void sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type);Ù<SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse*, Index*);Ù5SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe*, int);Ù4SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);Ù/SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe*);Ù2SQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe*);Ù/SQLITE_PRIVATE void sqlite3VdbeReusable(Vdbe*);Ù-SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe*);Ù;SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3*,Vdbe*);Ù7SQLITE_PRIVATE void sqlite3VdbeMakeReady(Vdbe*,Parse*);Ù.SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe*);Ù8SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe*, int);Ù1SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe*);³#ifdef SQLITE_DEBUGÙ<SQLITE_PRIVATE   int sqlite3VdbeAssertMayAbort(Vdbe *, int);¦#endifÙ6SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe*);Ù-SQLITE_PRIVATE void sqlite3VdbeRewind(Vdbe*);Ù+SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe*);Ù5SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*,int);ÙXSQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));Ù3SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*);Ù-SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*);Ù1SQLITE_PRIVATE u8 sqlite3VdbePrepareFlags(Vdbe*);ÙGSQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);Ù1SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*,Vdbe*);ÙASQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);ÙGSQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);Ù6SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe*, int);¹#ifndef SQLITE_OMIT_TRACEÙ@SQLITE_PRIVATE   char *sqlite3VdbeExpandSql(Vdbe*, const char*);¦#endifÙMSQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*); ÙVSQLITE_PRIVATE void sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,UnpackedRecord*);ÙMSQLITE_PRIVATE int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);Ù^SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);ÙHSQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*); Ù>typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);ÙESQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*); »#ifndef SQLITE_OMIT_TRIGGERÙDSQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);¦#endif Ù8SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context*); ÙG/* Use SQLITE_ENABLE_COMMENTS to enable generation of extra comments on´** each VDBE opcode.¢**ÙF** Use the SQLITE_ENABLE_MODULE_COMMENTS macro to see some extra no-opÙF** comments in VDBE programs that show key decision points in the code­** generator.¢*/Ù%#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTSÙBSQLITE_PRIVATE   void sqlite3VdbeComment(Vdbe*, const char*, ...);Ù-# define VdbeComment(X)  sqlite3VdbeComment XÙFSQLITE_PRIVATE   void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);Ù5# define VdbeNoopComment(X)  sqlite3VdbeNoopComment XÙ%# ifdef SQLITE_ENABLE_MODULE_COMMENTSÙ9#   define VdbeModuleComment(X)  sqlite3VdbeNoopComment X¦# else¿#   define VdbeModuleComment(X)§# endif¥#else·# define VdbeComment(X)»# define VdbeNoopComment(X)½# define VdbeModuleComment(X)¦#endif ¢/*ÙC** The VdbeCoverage macros are used to set a coverage testing pointÙF** for VDBE branch instructions.  The coverage testing points are lineÙF** numbers in the sqlite3.c source file.  VDBE branch coverage testingÙH** only works with an amalagmation build.  That's ok since a VDBE branchÙK** coverage build designed for testing the test suite only.  No applicationÙB** should ever ship with VDBE branch coverage measuring turned on.¢**ÙO**    VdbeCoverage(v)                  // Mark the previously coded instructionÙ5**                                     // as a branch¢**ÙK**    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true¢**ÙI**    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken¢**ÙH**    VdbeCoverageNeverTaken(v)        // Previous branch is never taken¢**ÙK** Every VDBE branch operation must be tagged with one of the macros above.ÙG** If not, then when "make test" is run with -DSQLITE_VDBE_COVERAGE andÙD** -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()Ù?** routine in vdbe.c, alerting the developer to the missed tag.¢*/»#ifdef SQLITE_VDBE_COVERAGEÙ:SQLITE_PRIVATE   void sqlite3VdbeSetLineNumber(Vdbe*,int);Ù=# define VdbeCoverage(v) sqlite3VdbeSetLineNumber(v,__LINE__)ÙF# define VdbeCoverageIf(v,x) if(x)sqlite3VdbeSetLineNumber(v,__LINE__)ÙB# define VdbeCoverageAlwaysTaken(v) sqlite3VdbeSetLineNumber(v,2);ÙA# define VdbeCoverageNeverTaken(v) sqlite3VdbeSetLineNumber(v,1);Ù+# define VDBE_OFFSET_LINENO(x) (__LINE__+x)¥#else¸# define VdbeCoverage(v)¼# define VdbeCoverageIf(v,x)Ù## define VdbeCoverageAlwaysTaken(v)Ù"# define VdbeCoverageNeverTaken(v)Ù # define VDBE_OFFSET_LINENO(x) 0¦#endif Ù$#ifdef SQLITE_ENABLE_STMT_SCANSTATUSÙUSQLITE_PRIVATE void sqlite3VdbeScanStatus(Vdbe*, int, int, int, LogEst, const char*);¥#elseÙ)# define sqlite3VdbeScanStatus(a,b,c,d,e)¦#endif º#endif /* SQLITE_VDBE_H */ ÙO/************** End of vdbe.h ************************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ÙO/************** Include pager.h in the middle of sqliteInt.h *****************/ÙO/************** Begin file pager.h *******************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙD** This header file defines the interface that the sqlite page cacheÙF** subsystem.  The page cache subsystem reads and writes a file a pageÙ1** at a time and provides a journal for rollback.¢*/ ¶#ifndef SQLITE_PAGER_H¶#define SQLITE_PAGER_H ¢/*ÙA** Default maximum size for persistent journal files. A negative Ù@** value means no limit. This value may be overridden using the ÙL** sqlite3PagerJournalSizeLimit() API. See also "PRAGMA journal_size_limit".¢*/Ù)#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMITÙ.  #define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1¦#endif ¢/*ÙF** The type used to represent a page number.  The first page in a fileÙ:** is called page 1.  0 is used to represent "not a page".¢*/±typedef u32 Pgno; ¢/*ÙM** Each open file is managed by a separate instance of the "Pager" structure.¢*/»typedef struct Pager Pager; ¢/*¹** Handle type for pages.¢*/¼typedef struct PgHdr DbPage; ¢/*ÙG** Page number PAGER_MJ_PGNO is never used in an SQLite database (it isÙF** reserved for working around a windows/posix incompatibility). It isÙI** used in the journal to signify that the remainder of the journal file ÙK** is devoted to storing a master journal name - there are no more pages toÙH** roll back. See comments for function writeMasterJournal() in pager.c ¯** for details.¢*/ÙC#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1)) ¢/*Ù@** Allowed values for the flags parameter to sqlite3PagerOpen().¢**ÙL** NOTE: These values must match the corresponding BTREE_ values in btree.h.¢*/ÙI#define PAGER_OMIT_JOURNAL  0x0001    /* Do not use a rollback journal */Ù>#define PAGER_MEMORY        0x0002    /* In-memory database */ ¢/*ÙE** Valid values for the second argument to sqlite3PagerLockingMode().¢*/Ù'#define PAGER_LOCKINGMODE_QUERY      -1Ù'#define PAGER_LOCKINGMODE_NORMAL      0Ù'#define PAGER_LOCKINGMODE_EXCLUSIVE   1 ¢/*Ù1** Numeric constants that encode the journalmode.¢**ÙG** The numeric values encoded here (other than PAGER_JOURNALMODE_QUERY)ÙC** are exposed in the API via the "PRAGMA journal_mode" command andÙ=** therefore cannot be changed without a compatibility break.¢*/ÙN#define PAGER_JOURNALMODE_QUERY     (-1)  /* Query the value of journalmode */ÙO#define PAGER_JOURNALMODE_DELETE      0   /* Commit by deleting journal file */ÙP#define PAGER_JOURNALMODE_PERSIST     1   /* Commit by zeroing journal header */ÙA#define PAGER_JOURNALMODE_OFF         2   /* Journal omitted.  */ÙL#define PAGER_JOURNALMODE_TRUNCATE    3   /* Commit by truncating journal */ÙF#define PAGER_JOURNALMODE_MEMORY      4   /* In-memory journal file */ÙG#define PAGER_JOURNALMODE_WAL         5   /* Use write-ahead logging */ ¢/*Ù;** Flags that make up the mask passed to sqlite3PagerGet().¢*/ÙF#define PAGER_GET_NOCONTENT     0x01  /* Do not load data from disk */ÙH#define PAGER_GET_READONLY      0x02  /* Read-only page is acceptable */ ¢/*Ù#** Flags for sqlite3PagerSetFlags()¢**Ù-** Value constraints (enforced via assert()):Ù.**    PAGER_FULLFSYNC      == SQLITE_FullFSyncÙ2**    PAGER_CKPT_FULLFSYNC == SQLITE_CkptFullFSyncÙ/**    PAGER_CACHE_SPILL    == SQLITE_CacheSpill¢*/ÙF#define PAGER_SYNCHRONOUS_OFF       0x01  /* PRAGMA synchronous=OFF */ÙI#define PAGER_SYNCHRONOUS_NORMAL    0x02  /* PRAGMA synchronous=NORMAL */ÙG#define PAGER_SYNCHRONOUS_FULL      0x03  /* PRAGMA synchronous=FULL */ÙH#define PAGER_SYNCHRONOUS_EXTRA     0x04  /* PRAGMA synchronous=EXTRA */ÙJ#define PAGER_SYNCHRONOUS_MASK      0x07  /* Mask for four values above */ÙC#define PAGER_FULLFSYNC             0x08  /* PRAGMA fullfsync=ON */ÙN#define PAGER_CKPT_FULLFSYNC        0x10  /* PRAGMA checkpoint_fullfsync=ON */ÙE#define PAGER_CACHESPILL            0x20  /* PRAGMA cache_spill=ON */ÙL#define PAGER_FLAGS_MASK            0x38  /* All above except SYNCHRONOUS */ ¢/*ÙH** The remainder of this file contains the declarations of the functionsÙG** that make up the Pager sub-system API. See source code comments for Ù*** a detailed description of each routine.¢*/ Ù)/* Open and close a Pager connection. */ Ù$SQLITE_PRIVATE int sqlite3PagerOpen(¯  sqlite3_vfs*,²  Pager **ppPager,®  const char*,¦  int,¦  int,¦  int,²  void(*)(DbPage*)¢);Ù>SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3*);ÙKSQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*); Ù1/* Functions used to configure a Pager object. */ÙOSQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);Ù>SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);·#ifdef SQLITE_HAS_CODECÙ<SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager*,Pager*);¦#endifÙ9SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);Ù:SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);Ù9SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int);ÙESQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);Ù/SQLITE_PRIVATE void sqlite3PagerShrink(Pager*);Ù:SQLITE_PRIVATE void sqlite3PagerSetFlags(Pager*,unsigned);Ù9SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int);Ù<SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int);Ù6SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*);Ù=SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*);Ù>SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64);Ù>SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*);Ù-SQLITE_PRIVATE int sqlite3PagerFlush(Pager*); Ù</* Functions used to obtain and release page references. */ Ù[SQLITE_PRIVATE int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);ÙDSQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);Ù-SQLITE_PRIVATE void sqlite3PagerRef(DbPage*);Ù/SQLITE_PRIVATE void sqlite3PagerUnref(DbPage*);Ù6SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage*);Ù6SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage*); Ù$/* Operations on page references. */Ù.SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*);Ù3SQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*);ÙASQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);Ù5SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*);Ù4SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *); Ù5SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *);  ÙA/* Functions used to manage pager transactions and savepoints. */Ù8SQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*);Ù>SQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int);ÙOSQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, int);Ù5SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*);ÙHSQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster);Ù6SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*);Ù0SQLITE_PRIVATE int sqlite3PagerRollback(Pager*);ÙCSQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n);ÙPSQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);Ù9SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager); ·#ifndef SQLITE_OMIT_WALÙVSQLITE_PRIVATE   int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*);Ù=SQLITE_PRIVATE   int sqlite3PagerWalSupported(Pager *pPager);Ù<SQLITE_PRIVATE   int sqlite3PagerWalCallback(Pager *pPager);ÙFSQLITE_PRIVATE   int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);ÙCSQLITE_PRIVATE   int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);Ù## ifdef SQLITE_DIRECT_OVERFLOW_READÙ=SQLITE_PRIVATE   int sqlite3PagerUseWal(Pager *pPager, Pgno);§# endif¾# ifdef SQLITE_ENABLE_SNAPSHOTÙ[SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot);ÙZSQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot);Ù@SQLITE_PRIVATE   int sqlite3PagerSnapshotRecover(Pager *pPager);§# endif¥#elseÙ"# define sqlite3PagerUseWal(x,y) 0¦#endif »#ifdef SQLITE_ENABLE_ZIPVFSÙ=SQLITE_PRIVATE   int sqlite3PagerWalFramesize(Pager *pPager);¦#endif Ù</* Functions used to query pager state and configuration. */Ù1SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*);Ù3SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager*);³#ifdef SQLITE_DEBUGÙ2SQLITE_PRIVATE   int sqlite3PagerRefcount(Pager*);¦#endifÙ/SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*);Ù=SQLITE_PRIVATE const char *sqlite3PagerFilename(Pager*, int);Ù4SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager*);Ù6SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*);Ù:SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager*);Ù;SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*);Ù3SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);Ù/SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);ÙDSQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);Ù3SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);Ù5SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);Ù"#ifdef SQLITE_ENABLE_SETLK_TIMEOUTÙ@SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager);¥#elseÙ(# define sqlite3PagerResetLockTimeout(X)¦#endif Ù3/* Functions used to truncate the database file. */Ù;SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno); Ù:SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16); Ù:#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_OMIT_WAL)Ù1SQLITE_PRIVATE void *sqlite3PagerCodec(DbPage *);¦#endif Ù1/* Functions to support testing and debugging. */Ù,#if !defined(NDEBUG) || defined(SQLITE_TEST)Ù6SQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);Ù6SQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);¦#endif²#ifdef SQLITE_TESTÙ0SQLITE_PRIVATE   int *sqlite3PagerStats(Pager*);Ù2SQLITE_PRIVATE   void sqlite3PagerRefdump(Pager*);Ù)  void disable_simulated_io_errors(void);Ù(  void enable_simulated_io_errors(void);¥#elseÙ&# define disable_simulated_io_errors()Ù%# define enable_simulated_io_errors()¦#endif »#endif /* SQLITE_PAGER_H */ ÙO/************** End of pager.h ***********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ÙO/************** Include pcache.h in the middle of sqliteInt.h ****************/ÙO/************** Begin file pcache.h ******************************************/¢/*±** 2008 August 05¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙD** This header file defines the interface that the sqlite page cache®** subsystem. ¢*/ ²#ifndef _PCACHE_H_ »typedef struct PgHdr PgHdr;½typedef struct PCache PCache; ¢/*ÙH** Every page in the cache is controlled by an instance of the following­** structure.¢*/®struct PgHdr {Ù@  sqlite3_pcache_page *pPage;    /* Pcache object page handle */Ù0  void *pData;                   /* Page data */Ù4  void *pExtra;                  /* Extra content */ÙI  PCache *pCache;                /* PRIVATE: Cache that owns this page */ÙM  PgHdr *pDirty;                 /* Transient list of dirty sorted by pgno */ÙE  Pager *pPager;                 /* The pager this page is part of */Ù@  Pgno pgno;                     /* Page number for this page */¹#ifdef SQLITE_CHECK_PAGESÙ;  u32 pageHash;                  /* Hash of page content */¦#endifÙ@  u16 flags;                     /* PGHDR flags defined below */ ÙI  /**********************************************************************ÙE  ** Elements above, except pCache, are public.  All that follow are ÙE  ** private to pcache.c and should not be accessed by other modules.Ù?  ** pCache is grouped with the public elements for efficiency.¤  */ÙC  i16 nRef;                      /* Number of users of this page */ÙJ  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */ÙN  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */ÙO                          /* NB: pDirtyNext and pDirtyPrev are undefined if theÙ9                          ** PgHdr object is not dirty */¢}; Ù /* Bit values for PgHdr.flags */ÙM#define PGHDR_CLEAN           0x001  /* Page not on the PCache.pDirty list */ÙL#define PGHDR_DIRTY           0x002  /* Page is on the PCache.pDirty list */ÙH#define PGHDR_WRITEABLE       0x004  /* Journaled and ready to modify */ÙI#define PGHDR_NEED_SYNC       0x008  /* Fsync the rollback journal beforeÙL                                     ** writing this page to the database */ÙG#define PGHDR_DONT_WRITE      0x010  /* Do not write content to disk */ÙF#define PGHDR_MMAP            0x020  /* This is an mmap page object */ Ù?#define PGHDR_WAL_APPEND      0x040  /* Appended to wal file */ Ù6/* Initialize and shutdown the page cache subsystem */Ù1SQLITE_PRIVATE int sqlite3PcacheInitialize(void);Ù0SQLITE_PRIVATE void sqlite3PcacheShutdown(void); Ù /* Page cache buffer management:Ù4** These routines implement SQLITE_CONFIG_PAGECACHE.¢*/ÙDSQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *, int sz, int n); ¼/* Create a new pager cache.ÙB** Under memory stress, invoke xStress to try to make pages clean.Ù2** Only clean and unpinned pages can be reclaimed.¢*/Ù%SQLITE_PRIVATE int sqlite3PcacheOpen(Ù9  int szPage,                    /* Size of every page */ÙL  int szExtra,                   /* Extra space associated with each page */ÙI  int bPurgeable,                /* True if pages are on backing store */ÙF  int (*xStress)(void*, PgHdr*), /* Call to try to make pages clean */Ù:  void *pStress,                 /* Argument to xStress */ÙH  PCache *pToInit                /* Preallocated space for the PCache */¢); Ù</* Modify the page-size after the cache has been created. */Ù;SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *, int); ÙD/* Return the size in bytes of a PCache object.  Used to preallocate±** storage space.¢*/Ù+SQLITE_PRIVATE int sqlite3PcacheSize(void); ÙD/* One release per successful fetch.  Page is pinned until released.¶** Reference counted. ¢*/ÙVSQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(PCache*, Pgno, int createFlag);ÙRSQLITE_PRIVATE int sqlite3PcacheFetchStress(PCache*, Pgno, sqlite3_pcache_page**);ÙZSQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(PCache*, Pgno, sqlite3_pcache_page *pPage);Ù1SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr*); ÙSSQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr*);         /* Remove page from cache */Ù[SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr*);    /* Make sure page is marked dirty */ÙXSQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr*);    /* Mark a single page as clean */Ù_SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache*);    /* Mark all dirty list pages as clean */Ù8SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache*); Ù1/* Change a page number.  Used by incr-vacuum. */Ù4SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr*, Pgno); Ù</* Remove all pages with pgno>x.  Reset the cache if x==0 */Ù;SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache*, Pgno x); ÙG/* Get a list of all dirty pages in the cache, sorted by page number */Ù6SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache*); Ù&/* Reset and close the cache object */Ù0SQLITE_PRIVATE void sqlite3PcacheClose(PCache*); Ù./* Clear flags from pages of the page cache */Ù:SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *); Ù'/* Discard the contents of the cache */Ù0SQLITE_PRIVATE void sqlite3PcacheClear(PCache*); Ù</* Return the total number of outstanding page references */Ù2SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*); Ù7/* Increment the reference count of an existing page */Ù-SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr*); Ù5SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*); Ù:/* Return the total number of pages stored in the cache */Ù3SQLITE_PRIVATE int sqlite3PcachePagecount(PCache*); Ù8#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)ÙF/* Iterate through all dirty pages currently stored in the cache. ThisÙI** interface is only available if SQLITE_CHECK_PAGES is defined when the ´** library is built.¢*/ÙVSQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *));¦#endif ¹#if defined(SQLITE_DEBUG)Ù(/* Check invariants on a PgHdr object */Ù3SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr*);¦#endif ÙF/* Set and get the suggested cache-size for the specified pager-cache.¢**ÙH** If no global maximum is configured, then the system attempts to limitÙH** the total number of pages cached by purgeable pager-caches to the sumÙ ** of the suggested cache-sizes.¢*/Ù=SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *, int);²#ifdef SQLITE_TESTÙ7SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *);¦#endif ÙE/* Set or get the suggested spill-size for the specified pager-cache.¢**ÙJ** The spill-size is the minimum number of pages in cache before the cacheÙ8** will attempt to spill dirty pages by calling xStress.¢*/Ù<SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *, int); Ù</* Free up as much memory as possible from the page cache */Ù1SQLITE_PRIVATE void sqlite3PcacheShrink(PCache*); Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTÙL/* Try to return memory used by the pcache module to the main memory heap */Ù3SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int);¦#endif ²#ifdef SQLITE_TESTÙ<SQLITE_PRIVATE void sqlite3PcacheStats(int*,int*,int*,int*);¦#endif Ù2SQLITE_PRIVATE void sqlite3PCacheSetDefault(void); ¼/* Return the header size */Ù1SQLITE_PRIVATE int sqlite3HeaderSizePcache(void);Ù2SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void); ÙH/* Number of dirty pages as a percentage of the configured cache size */Ù6SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache*); ·#endif /* _PCACHE_H_ */ ÙO/************** End of pcache.h **********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ÙO/************** Include os.h in the middle of sqliteInt.h ********************/ÙO/************** Begin file os.h **********************************************/¢/*´** 2001 September 16¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙB** This header file (together with is companion C source-code fileÙF** "os.c") attempt to abstract the underlying operating system so thatÙB** the SQLite library will work on both POSIX and windows systems.¢**ÙB** This header file is #include-ed by sqliteInt.h and thus ends upÙ'** being included by every source file.¢*/µ#ifndef _SQLITE_OS_H_µ#define _SQLITE_OS_H_ ¢/*ÙE** Attempt to automatically detect the operating system and setup theÙ)** necessary pre-processor macros for it.¢*/ÙO/************** Include os_setup.h in the middle of os.h *********************/ÙO/************** Begin file os_setup.h ****************************************/¢/*³** 2013 November 25¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙJ** This file contains pre-processor directives related to operating systemº** detection and/or setup.¢*/¹#ifndef SQLITE_OS_SETUP_H¹#define SQLITE_OS_SETUP_H ¢/*ÙK** Figure out if we are dealing with Unix, Windows, or some other operatingª** system.¢**ÙI** After the following block of preprocess macros, all of SQLITE_OS_UNIX,ÙL** SQLITE_OS_WIN, and SQLITE_OS_OTHER will defined to either 1 or 0.  One ofÙ1** the three will be 1.  The other two will be 0.¢*/¼#if defined(SQLITE_OS_OTHER)¸#  if SQLITE_OS_OTHER==1¹#    undef SQLITE_OS_UNIX¼#    define SQLITE_OS_UNIX 0¸#    undef SQLITE_OS_WIN»#    define SQLITE_OS_WIN 0§#  elseº#    undef SQLITE_OS_OTHER¨#  endif¦#endifÙ9#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)»#  define SQLITE_OS_OTHER 0·#  ifndef SQLITE_OS_WINÙE#    if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \Ù5        defined(__MINGW32__) || defined(__BORLANDC__)½#      define SQLITE_OS_WIN 1¾#      define SQLITE_OS_UNIX 0©#    else½#      define SQLITE_OS_WIN 0¾#      define SQLITE_OS_UNIX 1ª#    endif§#  else¼#    define SQLITE_OS_UNIX 0¨#  endif¥#else·#  ifndef SQLITE_OS_WIN»#    define SQLITE_OS_WIN 0¨#  endif¦#endif ¾#endif /* SQLITE_OS_SETUP_H */ ÙO/************** End of os_setup.h ********************************************/ÙO/************** Continuing where we left off in os.h *************************/ Ù?/* If the SET_FULLSYNC macro is not defined above, then make itª** a no-op¢*/´#ifndef SET_FULLSYNCº# define SET_FULLSYNC(x,y)¦#endif ¢/*Ù$** The default size of a disk sector¢*/Ù"#ifndef SQLITE_DEFAULT_SECTOR_SIZEÙ(# define SQLITE_DEFAULT_SECTOR_SIZE 4096¦#endif ¢/*ÙL** Temporary files are named starting with this prefix followed by 16 randomÙI** alphanumeric characters, and no file extension. They are stored in theÙI** OS's standard temporary file directory, and are deleted prior to exit.ÙM** If sqlite is being embedded in another program, you may wish to change theÙG** prefix to reflect your program's name, so that if your program exitsÙN** prematurely, old temporary files can be easily identified. This can be doneÙJ** using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.¢**ÙB** 2006-10-31:  The default prefix used to be "sqlite_".  But thenÙA** Mcafee started using SQLite in their anti-virus product and itÙF** started putting files with the "sqlite" name in the c:/temp folder.ÙA** This annoyed many windows users.  Those users would then do a Ù@** Google search for "sqlite", find the telephone numbers of theÙ=** developers and call to wake them up at night and complain.ÙF** For this reason, the default name prefix is changed to be "sqlite" ÙB** spelled backwards.  So the temp files are still identified, butÙC** anybody smart enough to figure out the code is also likely smartÙB** enough to know that calling the developer will not help get rid¯** of the file.¢*/¿#ifndef SQLITE_TEMP_FILE_PREFIXÙ*# define SQLITE_TEMP_FILE_PREFIX "etilqs_"¦#endif ¢/*Ù?** The following values may be passed as the second argument toÙF** sqlite3OsLock(). The various locks exhibit the following semantics:¢**ÙL** SHARED:    Any number of processes may hold a SHARED lock simultaneously.ÙD** RESERVED:  A single process may hold a RESERVED lock on a file atÙM**            any time. Other processes may hold and obtain new SHARED locks.ÙC** PENDING:   A single process may hold a PENDING lock on a file atÙI**            any one time. Existing SHARED locks may persist, but no newÙ>**            SHARED locks may be obtained by other processes.Ù:** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.¢**ÙI** PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, aÙH** process that requests an EXCLUSIVE lock may actually obtain a PENDINGÙJ** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to³** sqlite3OsLock().¢*/¹#define NO_LOCK         0¹#define SHARED_LOCK     1¹#define RESERVED_LOCK   2¹#define PENDING_LOCK    3¹#define EXCLUSIVE_LOCK  4 ¢/*ÙJ** File Locking Notes:  (Mostly about windows but also some info for Unix)¢**ÙF** We cannot use LockFileEx() or UnlockFileEx() on Win95/98/ME becauseÙD** those functions are not available.  So we use only LockFile() and°** UnlockFile().¢**ÙL** LockFile() prevents not just writing but also reading by other processes.ÙA** A SHARED_LOCK is obtained by locking a single randomly-chosen ÙG** byte out of a specific range of bytes. The lock byte is obtained at ÙF** random so two separate readers can probably access the file at the ÙD** same time, unless they are unlucky and choose the same lock byte.ÙC** An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.ÙH** There can only be one writer.  A RESERVED_LOCK is obtained by lockingÙJ** a single byte of the file that is designated as the reserved lock byte.ÙI** A PENDING_LOCK is obtained by locking a designated byte different fromº** the RESERVED_LOCK byte.¢**ÙI** On WinNT/2K/XP systems, LockFileEx() and UnlockFileEx() are available,ÙH** which means we can use reader/writer locks.  When reader/writer locksÙG** are used, the lock is placed on the same range of bytes that is usedÙG** for probabilistic locking in Win95/98/ME.  Hence, the locking schemeÙG** will support two or more Win95 readers or two or more WinNT readers.ÙI** But a single Win95 reader will lock out all WinNT readers and a singleÙ6** WinNT reader will lock out all other Win95 readers.¢**ÙF** The following #defines specify the range of bytes used for locking.ÙF** SHARED_SIZE is the number of bytes available in the pool from whichÙF** a random byte is selected for a shared lock.  The pool of bytes forÙ(** shared locks begins at SHARED_FIRST. ¢**Ù ** The same locking strategy andÙM** byte ranges are used for Unix.  This leaves open the possibility of havingÙH** clients on win95, winNT, and unix all talking to the same shared fileÙM** and all locking correctly.  To do so would require that samba (or whateverÙJ** tool is being used for file sharing) implements locks correctly betweenÙF** windows and unix.  I'm guessing that isn't likely to happen, but byÙH** using the same locking range we are at least open to the possibility.¢**ÙE** Locking in windows is manditory.  For this reason, we cannot storeÙH** actual data in the bytes used for locking.  The pager never allocatesÙG** the pages involved in locking therefore.  SHARED_SIZE is selected soÙJ** that all locks will fit on a single page even at the minimum page size.ÙL** PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTEÙF** is set high so that we don't have to allocate an unused page exceptÙJ** for very large databases.  But one should test the page skipping logic ÙG** by setting PENDING_BYTE low and running the entire regression suite.¢**ÙF** Changing the value of PENDING_BYTE results in a subtly incompatibleÙE** file format.  Depending on how it is changed, you might not noticeÙG** the incompatibility right away, even running a full regression test.ÙB** The default location of PENDING_BYTE is the first byte past the°** 1GB boundary.¢**¢*/¶#ifdef SQLITE_OMIT_WSDÙ&# define PENDING_BYTE     (0x40000000)¥#elseÙ-# define PENDING_BYTE      sqlite3PendingByte¦#endifÙ*#define RESERVED_BYTE     (PENDING_BYTE+1)Ù*#define SHARED_FIRST      (PENDING_BYTE+2)½#define SHARED_SIZE       510 ¢/*Ù9** Wrapper around OS specific sqlite3_os_init() function.¢*/Ù'SQLITE_PRIVATE int sqlite3OsInit(void); £/* Ù0** Functions for accessing sqlite3_file methods ¢*/Ù2SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file*);ÙLSQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);ÙSSQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);Ù>SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size);Ù5SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int);Ù@SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);Ù5SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int);Ù7SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int);ÙNSQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);ÙASQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*);ÙFSQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file*,int,void*);Ù,#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0Ù9SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id);ÙDSQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);·#ifndef SQLITE_OMIT_WALÙPSQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);ÙESQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int);Ù:SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id);Ù<SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);¼#endif /* SQLITE_OMIT_WAL */ÙGSQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);ÙASQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *, i64, void *);  £/* Ù/** Functions for accessing sqlite3_vfs methods ¢*/ÙYSQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);ÙESQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int);ÙSSQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);ÙSSQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);Ù"#ifndef SQLITE_OMIT_LOAD_EXTENSIONÙBSQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);ÙASQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *);ÙQSQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);Ù<SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);Ù'#endif /* SQLITE_OMIT_LOAD_EXTENSION */ÙCSQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *);Ù6SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int);Ù7SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs*);ÙLSQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*); ¢/*Ù=** Convenience functions for opening and closing files using ÙB** sqlite3_malloc() to obtain space for the file-handle structure.¢*/Ù_SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);Ù7SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *); º#endif /* _SQLITE_OS_H_ */ ÙO/************** End of os.h **************************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ÙO/************** Include mutex.h in the middle of sqliteInt.h *****************/ÙO/************** Begin file mutex.h *******************************************/¢/*±** 2007 August 28¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙF** This file contains the common header for all mutex implementations.ÙE** The sqliteInt.h header #includes this file so that it is availableÙF** to all source files.  We break it out in an effort to keep the code´** better organized.¢**ÙG** NOTE:  source files should *not* #include this header file directly.ÙF** Source files should #include the sqliteInt.h file and let that file¿** include this one indirectly.¢*/  ¢/*Ù?** Figure out what version of the code to use.  The choices are¢**ÙD**   SQLITE_MUTEX_OMIT         No mutex logic.  Not even stubs.  TheÙJ**                             mutexes implementation cannot be overriddenÙ-**                             at start-time.¢**ÙD**   SQLITE_MUTEX_NOOP         For single-threaded applications.  NoÙF**                             mutual exclusion is provided.  But thisÙB**                             implementation can be overridden atÙ***                             start-time.¢**ÙG**   SQLITE_MUTEX_PTHREADS     For multi-threaded applications on Unix.¢**ÙH**   SQLITE_MUTEX_W32          For multi-threaded applications on Win32.¢*/¶#if !SQLITE_THREADSAFEº# define SQLITE_MUTEX_OMIT¦#endifÙ4#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)´#  if SQLITE_OS_UNIXÙ!#    define SQLITE_MUTEX_PTHREADSµ#  elif SQLITE_OS_WIN¼#    define SQLITE_MUTEX_W32§#  else½#    define SQLITE_MUTEX_NOOP¨#  endif¦#endif ¸#ifdef SQLITE_MUTEX_OMIT¢/*ÙE** If this is a no-op implementation, implement everything as macros.¢*/Ù5#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)½#define sqlite3_mutex_free(X)Ù"#define sqlite3_mutex_enter(X)    Ù+#define sqlite3_mutex_try(X)      SQLITE_OKÙ"#define sqlite3_mutex_leave(X)    Ù/#define sqlite3_mutex_held(X)     ((void)(X),1)Ù/#define sqlite3_mutex_notheld(X)  ((void)(X),1)Ù5#define sqlite3MutexAlloc(X)      ((sqlite3_mutex*)8)Ù+#define sqlite3MutexInit()        SQLITE_OK¹#define sqlite3MutexEnd()¶#define MUTEX_LOGIC(X)¥#elseÙ##define MUTEX_LOGIC(X)            XÙ'#endif /* defined(SQLITE_MUTEX_OMIT) */ ÙO/************** End of mutex.h ***********************************************/ÙO/************** Continuing where we left off in sqliteInt.h ******************/ ÙG/* The SQLITE_EXTRA_DURABLE compile-time option used to set the defaultÙ<** synchronous setting to EXTRA.  It is no longer supported.¢*/»#ifdef SQLITE_EXTRA_DURABLEÙJ# warning Use SQLITE_DEFAULT_SYNCHRONOUS=3 instead of SQLITE_EXTRA_DURABLEÙ%# define SQLITE_DEFAULT_SYNCHRONOUS 3¦#endif ¢/*¾** Default synchronous levels.¢**ÙJ** Note that (for historcal reasons) the PAGER_SYNCHRONOUS_* macros differÙ2** from the SQLITE_DEFAULT_SYNCHRONOUS value by 1.¢**Ù8**           PAGER_SYNCHRONOUS       DEFAULT_SYNCHRONOUSÙ.**   OFF           1                         0Ù.**   NORMAL        2                         1Ù.**   FULL          3                         2Ù.**   EXTRA         4                         3¢**ÙG** The "PRAGMA synchronous" statement also uses the zero-based numbers.ÙN** In other words, the zero-based numbers are used for all external interfacesÙ0** and the one-based values are used internally.¢*/Ù"#ifndef SQLITE_DEFAULT_SYNCHRONOUSÙ%# define SQLITE_DEFAULT_SYNCHRONOUS 2¦#endifÙ&#ifndef SQLITE_DEFAULT_WAL_SYNCHRONOUSÙB# define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS¦#endif ¢/*ÙA** Each database file to be accessed by the system is an instanceÙJ** of the following structure.  There are normally two of these structuresÙC** in the sqlite.aDb[] array.  aDb[0] is the main database file andÙI** aDb[1] is the database file used to hold temporary tables.  Additional½** databases may be attached.¢*/«struct Db {ÙO  char *zDbSName;      /* Name of this database. (schema name, not filename) */ÙH  Btree *pBt;          /* The B*Tree structure for this database file */ÙC  u8 safety_level;     /* How aggressive at syncing data to disk */ÙH  u8 bSyncSet;         /* True if "PRAGMA synchronous=N" has been run */ÙI  Schema *pSchema;     /* Pointer to database schema (possibly shared) */¢}; ¢/*ÙC** An instance of the following structure stores a database schema.¢**ÙE** Most Schema objects are associated with a Btree.  The exception isÙL** the Schema for the TEMP databaes (sqlite3.aDb[1]) which is free-standing.ÙI** In shared cache mode, a single Schema object can be shared by multipleÙ<** Btrees that refer to the same underlying BtShared object.¢**ÙH** Schema objects are automatically deallocated when the last Btree thatÙG** references them is destroyed.   The TEMP Schema is manually freed by³** sqlite3_close().¡*ÙG** A thread must be holding a mutex on the corresponding Btree in orderÙG** to access Schema content.  This implies that the thread must also beÙI** holding a mutex on the sqlite3 connection pointer that owns the Btree.Ù<** For a TEMP Schema, only the connection mutex is required.¢*/¯struct Schema {ÙI  int schema_cookie;   /* Database schema version number for this file */ÙN  int iGeneration;     /* Generation counter.  Incremented with each change */Ù7  Hash tblHash;        /* All tables indexed by name */Ù@  Hash idxHash;        /* All (named) indices indexed by name */Ù9  Hash trigHash;       /* All triggers indexed by name */ÙF  Hash fkeyHash;       /* All foreign keys by referenced table name */ÙL  Table *pSeqTab;      /* The sqlite_sequence table used by AUTOINCREMENT */Ù@  u8 file_format;      /* Schema format version for this file */Ù@  u8 enc;              /* Text encoding used by this database */Ù>  u16 schemaFlags;     /* Flags associated with this schema */Ù@  int cache_size;      /* Number of pages to use in the cache */¢}; ¢/*Ù>** These macros can be used to test, set, or clear bits in the»** Db.pSchema->flags field.¢*/ÙN#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))ÙL#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)ÙF#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->schemaFlags|=(P)ÙG#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->schemaFlags&=~(P) ¢/*Ù2** Allowed values for the DB.pSchema->flags field.¢**ÙE** The DB_SchemaLoaded flag is set after the database schema has beenÙ"** read into internal hash tables.¢**ÙF** DB_UnresetViews means that one or more views have column names thatÙI** have been filled out.  If the schema changes, these column names mightÙ1** changes and so the view will need to be reset.¢*/ÙC#define DB_SchemaLoaded    0x0001  /* The schema has been loaded */ÙM#define DB_UnresetViews    0x0002  /* Some views have defined column names */ÙK#define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */ÙM#define DB_ResetWanted     0x0008  /* Reset the schema when nSchemaLock==0 */ ¢/*Ù>** The number of different kinds of things that can be limitedÙ'** using the sqlite3_limit() interface.¢*/Ù6#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1) ¢/*ÙC** Lookaside malloc is a set of fixed-size buffers that can be usedÙD** to satisfy small transient memory allocation requests for objectsÙ@** associated with a particular database connection.  The use ofÙB** lookaside malloc provides a significant performance enhancementÙG** (approx 10%) by avoiding numerous malloc/free requests while parsing²** SQL statements.¢**ÙD** The Lookaside structure holds configuration information about theÙC** lookaside malloc subsystem.  Each available memory allocation inÙF** the lookaside subsystem is stored on a linked list of LookasideSlot«** objects.¢**ÙI** Lookaside allocations are only allowed for objects that are associatedÙK** with a particular database connection.  Hence, schema information cannotÙM** be stored in lookaside because in shared cache mode the schema informationÙH** is shared by multiple database connections.  Therefore, while parsingÙE** schema information, the Lookaside.bEnabled flag is cleared so thatÙF** lookaside allocations are not used to construct the schema objects.¢*/²struct Lookaside {ÙD  u32 bDisable;           /* Only operate the lookaside when zero */Ù<  u16 sz;                 /* Size of each buffer in bytes */ÙM  u8 bMalloced;           /* True if pStart obtained from sqlite3_malloc() */ÙC  u32 nSlot;              /* Number of lookaside slots allocated */ÙI  u32 anStat[3];          /* 0: hits.  1: size misses.  2: full misses */ÙC  LookasideSlot *pInit;   /* List of buffers not previously used */Ù9  LookasideSlot *pFree;   /* List of available buffers */ÙD  void *pStart;           /* First byte of available memory space */ÙF  void *pEnd;             /* First byte past end of available space */¢};¶struct LookasideSlot {ÙH  LookasideSlot *pNext;    /* Next buffer in the list of free buffers */¢}; ¢/*ÙH** A hash table for built-in function definitions.  (Application-definedÙ4** functions use a regular table table from hash.h.)¢**ÙE** Hash each FuncDef structure into one of the FuncDefHash.a[] slots.Ù/** Collisions are on the FuncDef.u.pHash chain.¢*/¾#define SQLITE_FUNC_HASH_SZ 23´struct FuncDefHash {ÙG  FuncDef *a[SQLITE_FUNC_HASH_SZ];       /* Hash table for functions */¢}; Ù!#ifdef SQLITE_USER_AUTHENTICATION¢/*ÙH** Information held in the "sqlite3" database connection object and usedÙ!** to manage user authentication.¢*/Ù1typedef struct sqlite3_userauth sqlite3_userauth;¹struct sqlite3_userauth {ÙB  u8 authLevel;                 /* Current authentication level */ÙB  int nAuthPW;                  /* Size of the zAuthPW in bytes */ÙC  char *zAuthPW;                /* Password used to authenticate */ÙD  char *zAuthUser;              /* User name used to authenticate */¢}; Ù3/* Allowed values for sqlite3_userauth.authLevel */ÙD#define UAUTH_Unknown     0     /* Authentication not yet checked */Ù@#define UAUTH_Fail        1     /* User authentication failed */ÙD#define UAUTH_User        2     /* Authenticated as a normal user */ÙG#define UAUTH_Admin       3     /* Authenticated as an administrator */ Ù5/* Functions used only by user authorization logic */Ù5SQLITE_PRIVATE int sqlite3UserAuthTable(const char*);ÙGSQLITE_PRIVATE int sqlite3UserAuthCheckLogin(sqlite3*,const char*,u8*);Ù2SQLITE_PRIVATE void sqlite3UserAuthInit(sqlite3*);ÙKSQLITE_PRIVATE void sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**); Ù'#endif /* SQLITE_USER_AUTHENTICATION */ ¢/*Ù3** typedef for the authorization callback function.¢*/Ù!#ifdef SQLITE_USER_AUTHENTICATIONÙM  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,Ù9                               const char*, const char*);¥#elseÙM  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,Ù,                               const char*);¦#endif ¾#ifndef SQLITE_OMIT_DEPRECATEDÙF/* This is an extra SQLITE_TRACE macro that indicates "legacy" tracingÙ"** in the style of sqlite3_trace()¢*/Ù!#define SQLITE_TRACE_LEGACY  0x80¥#else¾#define SQLITE_TRACE_LEGACY  0Ù##endif /* SQLITE_OMIT_DEPRECATED */  ¢/*ÙF** Each database connection is an instance of the following structure.¢*/°struct sqlite3 {Ù2  sqlite3_vfs *pVfs;            /* OS Interface */ÙE  struct Vdbe *pVdbe;           /* List of active virtual machines */ÙM  CollSeq *pDfltColl;           /* The default collating sequence (BINARY) */Ù6  sqlite3_mutex *mutex;         /* Connection mutex */Ù2  Db *aDb;                      /* All backends */ÙI  int nDb;                      /* Number of backends currently in use */ÙD  u32 mDbFlags;                 /* flags recording internal state */ÙJ  u32 flags;                    /* flags settable by pragmas. See below */ÙM  i64 lastRowid;                /* ROWID of most recent insert (see above) */Ù?  i64 szMmap;                   /* Default mmap_size setting */ÙK  u32 nSchemaLock;              /* Do not reset the schema when non-zero */ÙI  unsigned int openFlags;       /* Flags passed to sqlite3_vfs.xOpen() */ÙG  int errCode;                  /* Most recent error code (SQLITE_*) */ÙO  int errMask;                  /* & result codes with this before returning */ÙH  int iSysErrno;                /* Errno value from last system error */ÙK  u16 dbOptFlags;               /* Flags to enable/disable optimizations */Ù3  u8 enc;                       /* Text encoding */Ù;  u8 autoCommit;                /* The auto-commit flag. */ÙB  u8 temp_store;                /* 1: file 2: memory 0: default */ÙK  u8 mallocFailed;              /* True if we have seen a malloc failure */ÙA  u8 bBenignMalloc;             /* Do not require OOMs if true */ÙK  u8 dfltLockMode;              /* Default locking-mode for attached dbs */ÙI  signed char nextAutovac;      /* Autovac setting after VACUUM if >=0 */ÙI  u8 suppressErr;               /* Do not issue error messages if true */ÙO  u8 vtabOnConflict;            /* Value to return for s3_vtab_on_conflict() */ÙM  u8 isTransactionSavepoint;    /* True if the outermost savepoint is a TS */ÙE  u8 mTrace;                    /* zero or more SQLITE_TRACE flags */ÙF  u8 skipBtreeMutex;            /* True if no shared-cache backends */ÙJ  u8 nSqlExec;                  /* Number of pending OP_SqlExec opcodes */ÙA  int nextPagesize;             /* Pagesize after VACUUM if >0 */ÙL  u32 magic;                    /* Magic number for detect library misuse */ÙI  int nChange;                  /* Value returned by sqlite3_changes() */ÙO  int nTotalChange;             /* Value returned by sqlite3_total_changes() */Ù,  int aLimit[SQLITE_N_LIMIT];   /* Limits */ÙN  int nMaxSorterMmap;           /* Maximum size of regions mapped by sorter */ÙL  struct sqlite3InitInfo {      /* Information used during initialization */ÙI    int newTnum;                /* Rootpage of table being initialized */ÙH    u8 iDb;                     /* Which db file is being initialized */ÙD    u8 busy;                    /* TRUE if currently initializing */ÙM    unsigned orphanTrigger : 1; /* Last statement is orphaned TEMP trigger */Ù@    unsigned imposterTable : 1; /* Building an imposter table */ÙK    unsigned reopenMemdb : 1;   /* ATTACH is really a reopen using MemDB */©  } init;ÙG  int nVdbeActive;              /* Number of VDBEs currently running */ÙO  int nVdbeRead;                /* Number of active VDBEs that read or write */ÙP  int nVdbeWrite;               /* Number of active VDBEs that read and write */ÙJ  int nVdbeExec;                /* Number of nested calls to VdbeExec() */ÙM  int nVDestroy;                /* Number of active OP_VDestroy operations */ÙA  int nExtension;               /* Number of loaded extensions */ÙE  void **aExtension;            /* Array of shared library handles */Ù@  int (*xTrace)(u32,void*,void*,void*);     /* Trace function */ÙP  void *pTraceArg;                          /* Argument to the trace function */ÙD  void (*xProfile)(void*,const char*,u64);  /* Profiling function */ÙN  void *pProfileArg;                        /* Argument to profile function */ÙG  void *pCommitArg;                 /* Argument to xCommitCallback() */ÙB  int (*xCommitCallback)(void*);    /* Invoked at every commit. */ÙI  void *pRollbackArg;               /* Argument to xRollbackCallback() */ÙB  void (*xRollbackCallback)(void*); /* Invoked at every commit. */³  void *pUpdateArg;ÙK  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);Ù##ifdef SQLITE_ENABLE_PREUPDATE_HOOKÙJ  void *pPreUpdateArg;          /* First argument to xPreUpdateCallback */ÙO  void (*xPreUpdateCallback)(   /* Registered using sqlite3_preupdate_hook() */ÙJ    void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64¤  );ÙL  PreUpdate *pPreUpdate;        /* Context for active pre-update callback */Ù)#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */·#ifndef SQLITE_OMIT_WALÙ<  int (*xWalCallback)(void *, sqlite3 *, const char *, int);°  void *pWalArg;¦#endifÙ>  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);Ù@  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);·  void *pCollNeededArg;Ù?  sqlite3_value *pErr;          /* Most recent error message */©  union {ÙO    volatile int isInterrupted; /* True if sqlite3_interrupt has been called */Ù,    double notUsed1;            /* Spacer */§  } u1;ÙD  Lookaside lookaside;          /* Lookaside malloc configuration */Ù!#ifndef SQLITE_OMIT_AUTHORIZATIONÙC  sqlite3_xauth xAuth;          /* Access authorization function */ÙN  void *pAuthArg;               /* 1st argument to the access auth function */¦#endifÙ%#ifndef SQLITE_OMIT_PROGRESS_CALLBACKÙ;  int (*xProgress)(void *);     /* The progress callback */ÙG  void *pProgressArg;           /* Argument to the progress callback */ÙM  unsigned nProgressOps;        /* Number of opcodes for progress callback */¦#endifÙ #ifndef SQLITE_OMIT_VIRTUALTABLEÙ?  int nVTrans;                  /* Allocated size of aVTrans */ÙJ  Hash aModule;                 /* populated by sqlite3_create_module() */ÙL  VtabCtx *pVtabCtx;            /* Context for active vtab connect/create */ÙK  VTable **aVTrans;             /* Virtual tables with open transactions */ÙP  VTable *pDisconnect;          /* Disconnect these in next sqlite3_prepare() */¦#endifÙH  Hash aFunc;                   /* Hash table of connection functions */Ù=  Hash aCollSeq;                /* All collating sequences */Ù3  BusyHandler busyHandler;      /* Busy callback */ÙM  Db aDbStatic[2];              /* Static space for the 2 default backends */Ù?  Savepoint *pSavepoint;        /* List of active savepoints */ÙC  int busyTimeout;              /* Busy handler timeout, in msec */ÙJ  int nSavepoint;               /* Number of non-transaction savepoints */ÙN  int nStatement;               /* Number of nested statement-transactions  */ÙP  i64 nDeferredCons;            /* Net deferred constraints this transaction. */ÙH  i64 nDeferredImmCons;         /* Net deferred immediate constraints */ÙM  int *pnBytesFreed;            /* If not NULL, increment this in DbFree() */Ù"#ifdef SQLITE_ENABLE_UNLOCK_NOTIFYÙC  /* The following variables are all protected by the STATIC_MASTERÙD  ** mutex, not by sqlite3.mutex. They are used by code in notify.c.¤  **ÙG  ** When X.pUnlockConnection==Y, that means that X is waiting for Y toÙ#  ** unlock so that it can proceed.¤  **ÙJ  ** When X.pBlockingConnection==Y, that means that something that X triedÙI  ** tried to do recently failed with an SQLITE_LOCKED error due to locks¯  ** held by Y.¤  */ÙJ  sqlite3 *pBlockingConnection; /* Connection that caused SQLITE_LOCKED */ÙL  sqlite3 *pUnlockConnection;           /* Connection to watch for unlock */ÙG  void *pUnlockArg;                     /* Argument to xUnlockNotify */ÙD  void (*xUnlockNotify)(void **, int);  /* Unlock notify callback */ÙM  sqlite3 *pNextBlocked;        /* Next in list of all blocked connections */¦#endifÙ!#ifdef SQLITE_USER_AUTHENTICATIONÙE  sqlite3_userauth auth;        /* User authentication information */¦#endif¢}; ¢/*Ù2** A macro to discover the encoding of a database.¢*/Ù2#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)Ù"#define ENC(db)        ((db)->enc) ¢/*Ù)** Possible values for the sqlite3.flags.¢**Ù-** Value constraints (enforced via assert()):Ù/**      SQLITE_FullFSync     == PAGER_FULLFSYNCÙ4**      SQLITE_CkptFullFSync == PAGER_CKPT_FULLFSYNCÙ1**      SQLITE_CacheSpill    == PAGER_CACHE_SPILL¢*/ÙJ#define SQLITE_WriteSchema    0x00000001  /* OK to update SQLITE_MASTER */ÙP#define SQLITE_LegacyFileFmt  0x00000002  /* Create new databases in format 1 */ÙP#define SQLITE_FullColNames   0x00000004  /* Show full column names on SELECT */ÙM#define SQLITE_FullFSync      0x00000008  /* Use full fsync on the backend */ÙM#define SQLITE_CkptFullFSync  0x00000010  /* Use full fsync for checkpoint */ÙG#define SQLITE_CacheSpill     0x00000020  /* OK to spill pager cache */ÙH#define SQLITE_ShortColNames  0x00000040  /* Show short columns names */ÙM#define SQLITE_CountRows      0x00000080  /* Count rows changed by INSERT, */ÙN                                          /*   DELETE, or UPDATE and return */ÙM                                          /*   the count using a callback. */ÙO#define SQLITE_NullCallback   0x00000100  /* Invoke the callback once if the */ÙE                                          /*   result set is empty */ÙP#define SQLITE_IgnoreChecks   0x00000200  /* Do not enforce check constraints */ÙP#define SQLITE_ReadUncommit   0x00000400  /* READ UNCOMMITTED in shared-cache */ÙO#define SQLITE_NoCkptOnClose  0x00000800  /* No checkpoint on close()/DETACH */ÙI#define SQLITE_ReverseOrder   0x00001000  /* Reverse unordered SELECTs */ÙI#define SQLITE_RecTriggers    0x00002000  /* Enable recursive triggers */ÙP#define SQLITE_ForeignKeys    0x00004000  /* Enforce foreign key constraints  */ÙH#define SQLITE_AutoIndex      0x00008000  /* Enable automatic indexes */ÙE#define SQLITE_LoadExtension  0x00010000  /* Enable load_extension */ÙP#define SQLITE_LoadExtFunc    0x00020000  /* Enable load_extension() SQL func */ÙG#define SQLITE_EnableTrigger  0x00040000  /* True to enable triggers */ÙH#define SQLITE_DeferFKs       0x00080000  /* Defer all FK constraints */ÙH#define SQLITE_QueryOnly      0x00100000  /* Disable database changes */ÙN#define SQLITE_CellSizeCk     0x00200000  /* Check btree cell sizes on load */ÙH#define SQLITE_Fts3Tokenizer  0x00400000  /* Enable fts3_tokenizer(2) */ÙP#define SQLITE_EnableQPSG     0x00800000  /* Query Planner Stability Guarantee*/ÙO#define SQLITE_TriggerEQP     0x01000000  /* Show trigger EXPLAIN QUERY PLAN */ Ù"/* Flags used only if debugging */³#ifdef SQLITE_DEBUGÙN#define SQLITE_SqlTrace       0x08000000  /* Debug print SQL as it executes */ÙO#define SQLITE_VdbeListing    0x10000000  /* Debug listings of VDBE programs */ÙL#define SQLITE_VdbeTrace      0x20000000  /* True to trace VDBE execution */ÙN#define SQLITE_VdbeAddopTrace 0x40000000  /* Trace sqlite3VdbeAddOp() calls */ÙH#define SQLITE_VdbeEQP        0x80000000  /* Debug EXPLAIN QUERY PLAN */¦#endif ¢/*Ù&** Allowed values for sqlite3.mDbFlags¢*/ÙJ#define DBFLAG_SchemaChange   0x0001  /* Uncommitted Hash table changes */ÙH#define DBFLAG_PreferBuiltin  0x0002  /* Preference to built-in funcs */ÙA#define DBFLAG_Vacuum         0x0004  /* Currently in a VACUUM */ ¢/*Ù<** Bits of the sqlite3.dbOptFlags field that are used by theÙG** sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...) interface toÙ-** selectively disable various optimizations.¢*/Ù=#define SQLITE_QueryFlattener 0x0001   /* Query flattening */Ù9#define SQLITE_ColumnCache    0x0002   /* Column cache */ÙE#define SQLITE_GroupByOrder   0x0004   /* GROUPBY cover of ORDERBY */Ù?#define SQLITE_FactorOutConst 0x0008   /* Constant factoring */ÙC#define SQLITE_DistinctOpt    0x0010   /* DISTINCT using indexes */ÙA#define SQLITE_CoverIdxScan   0x0020   /* Covering index scans */ÙH#define SQLITE_OrderByIdxJoin 0x0040   /* ORDER BY of joins via index */ÙC#define SQLITE_Transitive     0x0080   /* Transitive constraints */ÙH#define SQLITE_OmitNoopJoin   0x0100   /* Omit unused tables in joins */ÙK#define SQLITE_CountOfView    0x0200   /* The count-of-view optimization */ÙF#define SQLITE_CursorHints    0x0400   /* Add OP_CursorHint opcodes */ÙD#define SQLITE_Stat34         0x0800   /* Use STAT3 or STAT4 data */ÙL   /* TH3 expects the Stat34  ^^^^^^ value to be 0x0800.  Don't change it */ÙG#define SQLITE_PushDown       0x1000   /* The push-down optimization */ÙF#define SQLITE_SimplifyJoin   0x2000   /* Convert LEFT JOIN to JOIN */Ù>#define SQLITE_AllOpts        0xffff   /* All optimizations */ ¢/*ÙK** Macros for testing whether or not optimizations are enabled or disabled.¢*/ÙF#define OptimizationDisabled(db, mask)  (((db)->dbOptFlags&(mask))!=0)ÙF#define OptimizationEnabled(db, mask)   (((db)->dbOptFlags&(mask))==0) ¢/*ÙN** Return true if it OK to factor constant expressions into the initializationÙ?** code. The argument is a Parse object for the code generator.¢*/Ù-#define ConstFactorOk(P) ((P)->okConstFactor) ¢/*Ù.** Possible values for the sqlite.magic field.ÙH** The numbers are obtained at random and have no special meaning, otherÙ(** than being distinct from one another.¢*/Ù@#define SQLITE_MAGIC_OPEN     0xa029a697  /* Database is open */ÙB#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /* Database is closed */ÙH#define SQLITE_MAGIC_SICK     0x4b771290  /* Error and awaiting close */ÙI#define SQLITE_MAGIC_BUSY     0xf03b7906  /* Database currently in use */ÙO#define SQLITE_MAGIC_ERROR    0xb5357930  /* An SQLITE_MISUSE error occurred */ÙO#define SQLITE_MAGIC_ZOMBIE   0x64cffc7f  /* Close with last statement close */ ¢/*Ù?** Each SQL function is defined by an instance of the followingÙK** structure.  For global built-in functions (ex: substr(), max(), count())ÙM** a pointer to this structure is held in the sqlite3BuiltinFunctions object.ÙF** For per-connection application-defined functions, a pointer to thisÙ1** structure is held in the db->aHash hash table.¢**ÙH** The u.pHash field is used by the global built-ins.  The u.pDestructorÙ5** field is used by per-connection app-def functions.¢*/°struct FuncDef {ÙE  i8 nArg;             /* Number of arguments.  -1 means unlimited */Ù>  u16 funcFlags;       /* Some combination of SQLITE_FUNC_* */Ù0  void *pUserData;     /* User data parameter */Ù9  FuncDef *pNext;      /* Next function with same name */ÙN  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**); /* func or agg-step */ÙK  void (*xFinalize)(sqlite3_context*);                  /* Agg finalizer */Ù6  const char *zName;   /* SQL name of the function. */©  union {ÙK    FuncDef *pHash;      /* Next with a different name but the same hash */ÙN    FuncDestructor *pDestructor;   /* Reference counted destructor function */¦  } u;¢}; ¢/*ÙF** This structure encapsulates a user-function destructor callback (asÙG** configured using create_function_v2()) and a reference counter. WhenÙI** create_function_v2() is called to create a function with a destructor,ÙK** a single object of this type is allocated. FuncDestructor.nRef is set toÙM** the number of FuncDef objects created (either 1 or 3, depending on whetherÙH** or not the specified encoding is SQLITE_ANY). The FuncDef.pDestructorÙM** member of each of the new FuncDef objects is set to point to the allocated²** FuncDestructor.¢**ÙH** Thereafter, when one of the FuncDef objects is deleted, the referenceÙI** count on this object is decremented. When it reaches 0, the destructorÙ5** is invoked and the FuncDestructor structure freed.¢*/·struct FuncDestructor {«  int nRef;»  void (*xDestroy)(void *);²  void *pUserData;¢}; ¢/*ÙH** Possible values for FuncDef.flags.  Note that the _LENGTH and _TYPEOFÙH** values must correspond to OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG.  AndÙH** SQLITE_FUNC_CONSTANT must be the same as SQLITE_DETERMINISTIC.  ThereÙ6** are assert() statements in the code to verify this.¢**Ù-** Value constraints (enforced via assert()):ÙB**     SQLITE_FUNC_MINMAX    ==  NC_MinMaxAgg      == SF_MinMaxAggÙ1**     SQLITE_FUNC_LENGTH    ==  OPFLAG_LENGTHARGÙ1**     SQLITE_FUNC_TYPEOF    ==  OPFLAG_TYPEOFARGÙB**     SQLITE_FUNC_CONSTANT  ==  SQLITE_DETERMINISTIC from the APIÙE**     SQLITE_FUNC_ENCMASK   depends on SQLITE_UTF* macros in the API¢*/ÙP#define SQLITE_FUNC_ENCMASK  0x0003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */ÙM#define SQLITE_FUNC_LIKE     0x0004 /* Candidate for the LIKE optimization */ÙK#define SQLITE_FUNC_CASE     0x0008 /* Case-sensitive LIKE-type function */ÙF#define SQLITE_FUNC_EPHEM    0x0010 /* Ephemeral.  Delete with VDBE */ÙP#define SQLITE_FUNC_NEEDCOLL 0x0020 /* sqlite3GetFuncCollSeq() might be called*/ÙD#define SQLITE_FUNC_LENGTH   0x0040 /* Built-in length() function */ÙD#define SQLITE_FUNC_TYPEOF   0x0080 /* Built-in typeof() function */ÙE#define SQLITE_FUNC_COUNT    0x0100 /* Built-in count(*) aggregate */ÙI#define SQLITE_FUNC_COALESCE 0x0200 /* Built-in coalesce() or ifnull() */ÙF#define SQLITE_FUNC_UNLIKELY 0x0400 /* Built-in unlikely() function */ÙP#define SQLITE_FUNC_CONSTANT 0x0800 /* Constant inputs give a constant output */ÙM#define SQLITE_FUNC_MINMAX   0x1000 /* True for min() and max() aggregates */ÙM#define SQLITE_FUNC_SLOCHNG  0x2000 /* "Slow Change". Value constant during aÙO                                    ** single query - might change over time */ÙF#define SQLITE_FUNC_AFFINITY 0x4000 /* Built-in affinity() function */ÙK#define SQLITE_FUNC_OFFSET   0x8000 /* Built-in sqlite_offset() function */ ¢/*ÙI** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() areÙ>** used to create the initializers for the FuncDef structures.¢**Ù,**   FUNCTION(zName, nArg, iArg, bNC, xFunc)ÙF**     Used to create a scalar function definition of a function zNameÙG**     implemented by C function xFunc that accepts nArg arguments. TheÙC**     value passed as iArg is cast to a (void*) and made availableÙB**     as the user-data (sqlite3_user_data()) for the function. IfÙG**     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set.¢**Ù-**   VFUNCTION(zName, nArg, iArg, bNC, xFunc)ÙC**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag.¢**Ù-**   DFUNCTION(zName, nArg, iArg, bNC, xFunc)ÙF**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag andÙI**     adds the SQLITE_FUNC_SLOCHNG flag.  Used for date & time functionsÙJ**     and functions like sqlite_version() that can change, but not duringÙI**     a single query.  The iArg is ignored.  The user-data is always setÙ9**     to a NULL pointer.  The bNC parameter is not used.¢**Ù-**   PURE_DATE(zName, nArg, iArg, bNC, xFunc)ÙH**     Used for "pure" date/time functions, this macro is like DFUNCTIONÙG**     except that it does set the SQLITE_FUNC_CONSTANT flags.  iArg isÙB**     ignored and the user-data for these functions is set to an ÙB**     arbitrary non-NULL pointer.  The bNC parameter is not used.¢**Ù5**   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)ÙE**     Used to create an aggregate function definition implemented byÙB**     the C functions xStep and xFinal. The first four parametersÙC**     are interpreted in the same way as the first 4 parameters to²**     FUNCTION().¢**Ù'**   LIKEFUNC(zName, nArg, pArg, flags)ÙF**     Used to create a scalar function definition of a function zNameÙD**     that accepts nArg arguments and is implemented by a call to CÙF**     function likeFunc. Argument pArg is cast to a (void *) and madeÙE**     available as the function user-data (sqlite3_user_data()). TheÙE**     FuncDef.flags variable is set to the value passed as the flags±**     parameter.¢*/Ù1#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \ÙG  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \Ù6   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }Ù2#define VFUNCTION(zName, nArg, iArg, bNC, xFunc) \Ù2  {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \Ù6   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }Ù2#define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \Ù+  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \Ù    0, 0, xFunc, 0, #zName, {0} }Ù2#define PURE_DATE(zName, nArg, iArg, bNC, xFunc) \Ù@  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \Ù4   (void*)&sqlite3Config, 0, xFunc, 0, #zName, {0} }Ù>#define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \ÙP  {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\Ù6   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, #zName, {0} }Ù5#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \ÙF  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \¿   pArg, 0, xFunc, 0, #zName, }Ù+#define LIKEFUNC(zName, nArg, arg, flags) \Ù2  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \Ù-   (void *)arg, 0, likeFunc, 0, #zName, {0} }Ù8#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) \Ù1  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL), \Ù7   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,#zName, {0}}ÙE#define AGGREGATE2(zName, nArg, arg, nc, xStep, xFinal, extraFlags) \Ù<  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|extraFlags, \Ù7   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,#zName, {0}} ¢/*ÙA** All current savepoints are stored in a linked list starting atÙI** sqlite3.pSavepoint. The first element in the list is the most recentlyÙA** opened savepoint. Savepoints are added to the list by the vdbe¼** OP_Savepoint instruction.¢*/²struct Savepoint {ÙK  char *zName;                        /* Savepoint name (nul-terminated) */ÙL  i64 nDeferredCons;                  /* Number of deferred fk violations */ÙF  i64 nDeferredImmCons;               /* Number of deferred imm fk. */ÙE  Savepoint *pNext;                   /* Parent savepoint (if any) */¢}; ¢/*ÙH** The following are used as the second parameter to sqlite3Savepoint(),Ù:** and as the P1 argument to the OP_Savepoint instruction.¢*/¾#define SAVEPOINT_BEGIN      0¾#define SAVEPOINT_RELEASE    1¾#define SAVEPOINT_ROLLBACK   2  ¢/*ÙA** Each SQLite module (virtual table definition) is defined by anÙE** instance of the following structure, stored in the sqlite3.aModule®** hash table.¢*/¯struct Module {Ù>  const sqlite3_module *pModule;       /* Callback pointers */ÙK  const char *zName;                   /* Name passed to create_module() */ÙK  void *pAux;                          /* pAux passed to create_module() */ÙG  void (*xDestroy)(void *);            /* Module destructor function */ÙL  Table *pEpoTab;                      /* Eponymous table for this module */¢}; ¢/*ÙG** information about each column of an SQL table is held in an instanceµ** of this structure.¢*/¯struct Column {ÙA  char *zName;     /* Name of this column, \000, then the type */Ù5  Expr *pDflt;     /* Default value of this column */ÙF  char *zColl;     /* Collating sequence.  If NULL, use the default */ÙG  u8 notNull;      /* An OE_ code for handling a NOT NULL constraint */Ù9  char affinity;   /* One of the SQLITE_AFF_... values */ÙO  u8 szEst;        /* Estimated size of value in this column. sizeof(INT)==1 */ÙH  u8 colFlags;     /* Boolean properties.  See COLFLAG_ defines below */¢}; Ù&/* Allowed values for Column.colFlags:¢*/ÙJ#define COLFLAG_PRIMKEY  0x0001    /* Column is part of the primary key */ÙK#define COLFLAG_HIDDEN   0x0002    /* A hidden column in a virtual table */ÙF#define COLFLAG_HASTYPE  0x0004    /* Type name follows column name */ÙM#define COLFLAG_UNIQUE   0x0008    /* Column def contains "UNIQUE" or "PK" */ ¢/*ÙD** A "Collating Sequence" is defined by an instance of the followingÙG** structure. Conceptually, a collating sequence consists of a name andÙ@** a comparison routine that defines the order of that sequence.¢**Ù-** If CollSeq.xCmp is NULL, it means that theÙB** collating sequence is undefined.  Indices built on an undefinedÙ1** collating sequence may not be read or written.¢*/°struct CollSeq {ÙK  char *zName;          /* Name of the collating sequence, UTF-8 encoded */Ù=  u8 enc;               /* Text encoding handled by xCmp() */Ù6  void *pUser;          /* First argument to xCmp() */Ù8  int (*xCmp)(void*,int, const void*, int, const void*);Ù2  void (*xDel)(void*);  /* Destructor for pUser */¢}; ¢/*Ù*** A sort order can be either ASC or DESC.¢*/Ù<#define SQLITE_SO_ASC       0  /* Sort in ascending order */Ù<#define SQLITE_SO_DESC      1  /* Sort in ascending order */Ù<#define SQLITE_SO_UNDEFINED -1 /* No sort order specified */ ¢/*¹** Column affinity types.¢**ÙG** These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER andÙG** 't' for SQLITE_AFF_TEXT.  But we can save a little space and improveÙ<** the speed a little by numbering the values consecutively.¢**ÙC** But rather than start with 0 or 1, we begin with 'A'.  That way,ÙB** when multiple affinity types are concatenated into a string andÙ6** used as the P4 operand, they will be more readable.¢**ÙH** Note also that the numeric types are grouped together so that testingÙJ** for a numeric type is a single comparison.  And the BLOB type is first.¢*/¿#define SQLITE_AFF_BLOB     'A'¿#define SQLITE_AFF_TEXT     'B'¿#define SQLITE_AFF_NUMERIC  'C'¿#define SQLITE_AFF_INTEGER  'D'¿#define SQLITE_AFF_REAL     'E' Ù>#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC) ¢/*ÙB** The SQLITE_AFF_MASK values masks off the significant bits of an²** affinity value.¢*/Ù #define SQLITE_AFF_MASK     0x47 ¢/*ÙB** Additional bit values that can be ORed with an affinity without¹** changing the affinity.¢**ÙE** The SQLITE_NOTNULL flag is a combination of NULLEQ and JUMPIFNULL.ÙB** It causes an assert() to fire if either operand to a comparisonÙD** operator is NULL.  It is added to certain comparison operators toÙ/** prove that the operands are always NOT NULL.¢*/Ù?#define SQLITE_KEEPNULL     0x08  /* Used by vector == or <> */ÙG#define SQLITE_JUMPIFNULL   0x10  /* jumps if either operand is NULL */ÙP#define SQLITE_STOREP2      0x20  /* Store result in reg[P2] rather than jump */Ù1#define SQLITE_NULLEQ       0x80  /* NULL=NULL */ÙK#define SQLITE_NOTNULL      0x90  /* Assert that operands are never NULL */ ¢/*ÙF** An object of this type is created for each virtual table present in·** the database schema.¢**ÙG** If the database schema is shared, then there is one instance of thisÙI** structure for each database connection (sqlite3*) that uses the sharedÙK** schema. This is because each database connection requires its own uniqueÙH** instance of the sqlite3_vtab* handle used to access the virtual tableÙB** implementation. sqlite3_vtab* handles can not be shared betweenÙE** database connections, even when the rest of the in-memory databaseÙD** schema is shared, as the implementation often stores the databaseÙH** connection handle passed to it via the xConnect() or xCreate() methodÙH** during initialization internally. This database connection handle mayÙI** then be used by the virtual table implementation to access real tablesÙB** within the database. So that they appear as part of the callersÙD** transaction, these accesses need to be made via the same databaseÙJ** connection as that used to execute SQL operations on the virtual table.¢**ÙC** All VTable objects that correspond to a single table in a sharedÙF** database schema are initially stored in a linked-list pointed to byÙG** the Table.pVTable member variable of the corresponding Table object.ÙH** When an sqlite3_prepare() operation is required to access the virtualÙE** table, it searches the list for the VTable that corresponds to theÙC** database connection doing the preparing so as to use the correctÙ.** sqlite3_vtab* handle in the compiled query.¢**ÙB** When an in-memory Table object is deleted (for example when theÙH** schema is being reloaded for some reason), the VTable objects are notÙ@** deleted and the sqlite3_vtab* handles are not xDisconnect()edÙF** immediately. Instead, they are moved from the Table.pVTable list toÙF** another linked list headed by the sqlite3.pDisconnect member of theÙG** corresponding sqlite3 structure. They are then deleted/xDisconnectedÙF** next time a statement is prepared using said sqlite3*. This is doneÙE** to avoid deadlock issues involving multiple sqlite3.mutex mutexes.ÙB** Refer to comments above function sqlite3VtabUnlockList() for anÙM** explanation as to why it is safe to add an entry to an sqlite3.pDisconnectÙ>** list without holding the corresponding sqlite3.mutex mutex.¢**Ù=** The memory for objects of this type is always allocated byÙH** sqlite3DbMalloc(), using the connection handle stored in VTable.db as¶** the first argument.¢*/¯struct VTable {ÙP  sqlite3 *db;              /* Database connection associated with this table */ÙB  Module *pMod;             /* Pointer to module implementation */Ù:  sqlite3_vtab *pVtab;      /* Pointer to vtab instance */ÙF  int nRef;                 /* Number of pointers to this structure */ÙC  u8 bConstraint;           /* True if constraints are supported */Ù>  int iSavepoint;           /* Depth of the SAVEPOINT stack */ÙA  VTable *pNext;            /* Next in linked list (see above) */¢}; ¢/*ÙB** The schema for each SQL table and view is represented in memoryÙ-** by an instance of the following structure.¢*/®struct Table {Ù6  char *zName;         /* Name of the table or view */Ù:  Column *aCol;        /* Information about each column */Ù?  Index *pIndex;       /* List of SQL indexes on this table. */ÙN  Select *pSelect;     /* NULL for tables.  Points to definition if a view. */ÙJ  FKey *pFKey;         /* Linked list of all foreign keys in this table */ÙH  char *zColAff;       /* String defining the affinity of each column */Ù2  ExprList *pCheck;    /* All CHECK constraints */ÙJ                       /*   ... also used as column name list in a VIEW */Ù;  int tnum;            /* Root BTree page for this table */Ù=  u32 nTabRef;         /* Number of pointers to this Table */Ù0  u32 tabFlags;        /* Mask of TF_* values */ÙJ  i16 iPKey;           /* If not negative, use aCol[iPKey] as the rowid */Ù<  i16 nCol;            /* Number of columns in this table */ÙN  LogEst nRowLogEst;   /* Estimated rows in table - from sqlite_stat1 table */ÙF  LogEst szTabRow;     /* Estimated size of each table row in bytes */½#ifdef SQLITE_ENABLE_COSTMULTÙA  LogEst costMult;     /* Cost multiplier for using this table */¦#endifÙO  u8 keyConf;          /* What to do in case of uniqueness conflict on iPKey */¾#ifndef SQLITE_OMIT_ALTERTABLEÙL  int addColOffset;    /* Offset in CREATE TABLE stmt to add a new column */¦#endifÙ #ifndef SQLITE_OMIT_VIRTUALTABLEÙ>  int nModuleArg;      /* Number of arguments to the module */ÙH  char **azModuleArg;  /* 0: module 1: schema 2: vtab name 3...: args */Ù4  VTable *pVTable;     /* List of VTable objects. */¦#endifÙ?  Trigger *pTrigger;   /* List of triggers stored in pSchema */Ù<  Schema *pSchema;     /* Schema that contains this table */Ù>  Table *pNextZombie;  /* Next on the Parse.pZombieTab list */¢}; ¢/*Ù%** Allowed values for Table.tabFlags.¢**ÙK** TF_OOOHidden applies to tables or view that have hidden columns that areÙK** followed by non-hidden columns.  Example:  "CREATE VIRTUAL TABLE x USINGÙM** vtab1(a HIDDEN, b);".  Since "b" is a non-hidden column but "a" is hidden,ÙL** the TF_OOOHidden attribute would apply in this case.  Such tables requireÙ-** special handling during INSERT processing.¢*/ÙA#define TF_Readonly        0x0001    /* Read-only system table */Ù=#define TF_Ephemeral       0x0002    /* An ephemeral table */ÙB#define TF_HasPrimaryKey   0x0004    /* Table has a primary key */ÙO#define TF_Autoincrement   0x0008    /* Integer primary key is autoincrement */ÙK#define TF_HasStat1        0x0010    /* nRowLogEst set from sqlite_stat1 */ÙL#define TF_WithoutRowid    0x0020    /* No rowid.  PRIMARY KEY is the key */ÙI#define TF_NoVisibleRowid  0x0040    /* No user-visible "rowid" column */ÙF#define TF_OOOHidden       0x0080    /* Out-of-Order hidden columns */ÙK#define TF_StatsUsed       0x0100    /* Query planner decisions affected byÙE                                     ** Index.aiRowLogEst[] values */ÙH#define TF_HasNotNull      0x0200    /* Contains NOT NULL constraints */ ¢/*ÙB** Test to see whether or not a table is a virtual table.  This isÙ@** done as a macro so that it will be optimized out when virtualÙ+** table support is omitted from the build.¢*/Ù #ifndef SQLITE_OMIT_VIRTUALTABLEÙ-#  define IsVirtual(X)      ((X)->nModuleArg)¥#else½#  define IsVirtual(X)      0¦#endif ¢/*ÙG** Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()ÙG** only works for non-virtual tables (ordinary tables and views) and isÙD** always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  TheÙ-** IsHiddenColumn() macro is general purpose.¢*/Ù)#if defined(SQLITE_ENABLE_HIDDEN_COLUMNS)ÙI#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)ÙI#  define IsOrdinaryHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)Ù(#elif !defined(SQLITE_OMIT_VIRTUALTABLE)ÙI#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)Ù%#  define IsOrdinaryHiddenColumn(X) 0¥#elseÙ%#  define IsHiddenColumn(X)         0Ù%#  define IsOrdinaryHiddenColumn(X) 0¦#endif  Ù!/* Does the table have a rowid */Ù>#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)Ù@#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0) ¢/*ÙI** Each foreign key constraint is an instance of the following structure.¢**ÙD** A foreign key is associated with two tables.  The "from" table isÙI** the table that contains the REFERENCES clause that creates the foreignÙL** key.  The "to" table is the table that is named in the REFERENCES clause.¹** Consider this example:¢**¸**     CREATE TABLE ex1(¿**       a INTEGER PRIMARY KEY,Ù3**       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)©**     );¢**ÙL** For foreign key "fk1", the from-table is "ex1" and the to-table is "ex2".´** Equivalent names:¢**Ù **     from-table == child-tableÙ!**       to-table == parent-table¢**ÙJ** Each REFERENCES clause generates an instance of the following structureÙI** which is attached to the from-table.  The to-table need not exist whenÙL** the from-table is created.  The existence of the to-table is not checked.¢**Ù@** The list of all parents for child Table X is held at X.pFKey.¢**ÙJ** A list of all children for a table named Z (which might not even exist)Ù3** is held in Schema.fkeyHash with a hash key of Z.¢*/­struct FKey {ÙM  Table *pFrom;     /* Table containing the REFERENCES clause (aka: Child) */ÙP  FKey *pNextFrom;  /* Next FKey with the same in pFrom. Next parent of pFrom */ÙL  char *zTo;        /* Name of table that the key points to (aka: Parent) */ÙD  FKey *pNextTo;    /* Next with the same zTo. Next child of zTo. */Ù4  FKey *pPrevTo;    /* Previous with the same zTo */Ù7  int nCol;         /* Number of columns in this key */¹  /* EV: R-30323-21917 */ÙP  u8 isDeferred;       /* True if constraint checking is deferred till COMMIT */ÙK  u8 aAction[2];        /* ON DELETE and ON UPDATE actions, respectively */Ù<  Trigger *apTrigger[2];/* Triggers for aAction[] actions */ÙK  struct sColMap {      /* Mapping of columns in pFrom to columns in zTo */Ù8    int iFrom;            /* Index of column in pFrom */ÙO    char *zCol;           /* Name of column in zTo.  If NULL use PRIMARY KEY */Ù@  } aCol[1];            /* One entry for each of nCol columns */¢}; ¢/*Ù>** SQLite supports many different ways to resolve a constraintÙ@** error.  ROLLBACK processing means that a constraint violationÙJ** causes the operation in process to fail and for the current transactionÙF** to be rolled back.  ABORT processing means the operation in processÙF** fails and any prior changes from that one operation are backed out,ÙF** but the transaction is not rolled back.  FAIL processing means thatÙH** the operation in progress stops and returns an error code.  But priorÙG** changes due to the same operation are not backed out and no rollbackÙK** occurs.  IGNORE means that the particular row that caused the constraintÙG** error is not inserted or updated.  Processing continues and no errorÙI** is returned.  REPLACE means that preexisting database rows that causedÙF** a UNIQUE constraint violation are removed so that the new insert orÙF** update can proceed.  Processing continues and no error is reported.¢**ÙE** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.ÙC** RESTRICT is the same as ABORT for IMMEDIATE foreign keys and theÙF** same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreignÙD** key is set to NULL.  CASCADE means that a DELETE or UPDATE of theÙA** referenced table row is propagated into the row that holds the¯** foreign key.¢**Ù>** The following symbolic values are used to record which typeµ** of action to take.¢*/Ù=#define OE_None     0   /* There is no constraint to check */ÙM#define OE_Rollback 1   /* Fail the operation and rollback the transaction */ÙM#define OE_Abort    2   /* Back out changes but do no rollback transaction */ÙL#define OE_Fail     3   /* Stop the operation but leave all prior changes */ÙN#define OE_Ignore   4   /* Ignore the error. Do not do the INSERT or UPDATE */ÙN#define OE_Replace  5   /* Delete existing record, then do INSERT or UPDATE */ ÙN#define OE_Restrict 6   /* OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED */Ù?#define OE_SetNull  7   /* Set the foreign key value to NULL */ÙF#define OE_SetDflt  8   /* Set the foreign key value to its default */Ù1#define OE_Cascade  9   /* Cascade the changes */ Ù?#define OE_Default  10  /* Do whatever the default action is */  ¢/*Ù@** An instance of the following structure is passed as the firstÙ?** argument to sqlite3VdbeKeyCompare and is used to control theÙ$** comparison of the two index keys.¢**ÙA** Note that aSortOrder[] and aColl[] have nField+1 slots.  ThereÙC** are nField slots for the columns of an index then one extra slot¼** for the rowid at the end.¢*/°struct KeyInfo {ÙG  u32 nRef;           /* Number of references to this KeyInfo object */ÙI  u8 enc;             /* Text encoding - one of the SQLITE_UTF* values */Ù>  u16 nKeyField;      /* Number of key columns in the index */ÙD  u16 nAllField;      /* Total columns, including key plus others */Ù3  sqlite3 *db;        /* The database connection */Ù7  u8 *aSortOrder;     /* Sort order for each column. */ÙG  CollSeq *aColl[1];  /* Collating sequence for each term of the key */¢}; ¢/*ÙG** This object holds a record which has been parsed out into individualÙ2** fields, for the purposes of doing a comparison.¢**ÙB** A record is an object that contains one or more fields of data.ÙD** Records are used to store the content of a table row and to storeÙB** the key of an index.  A blob encoding of a record is created byÙB** the OP_MakeRecord opcode of the VDBE and is disassembled by the´** OP_Column opcode.¢**ÙE** An instance of this object serves as a "key" for doing a search onÙD** an index b+tree. The goal of the search is to find the entry thatÙI** is closed to the key described by this object.  This object might holdÙ>** just a prefix of the key.  The number of fields is given by´** pKeyInfo->nField.¢**ÙI** The r1 and r2 fields are the values to return if this key is less thanÙH** or greater than a key in the btree, respectively.  These are normallyÙK** -1 and +1 respectively, but might be inverted to +1 and -1 if the b-tree´** is in DESC order.¢**ÙI** The key comparison functions actually return default_rc when they findÙG** an equals comparison.  default_rc can be -1, 0, or +1.  If there areÙF** multiple entries in the b-tree with the same key (when only lookingÙG** at the first pKeyInfo->nFields,) then default_rc can be set to -1 toÙH** cause the search to find the last match, or +1 to cause the search to¸** find the first match.¢**ÙD** The key comparison functions will set eqSeen to true if they everÙJ** get and equal results when comparing this structure to a b-tree record.ÙH** When default_rc!=0, the search might end up on the record immediatelyÙC** before the first match or immediately after the last match.  TheÙI** eqSeen field will indicate whether or not an exact match exists in theª** b-tree.¢*/·struct UnpackedRecord {Ù@  KeyInfo *pKeyInfo;  /* Collation and sort-order information */Ù"  Mem *aMem;          /* Values */Ù8  u16 nField;         /* Number of entries in apMem[] */Ù?  i8 default_rc;      /* Comparison result if keys are equal */ÙO  u8 errCode;         /* Error detected by xRecordCompare (CORRUPT or NOMEM) */Ù:  i8 r1;              /* Value to return if (lhs < rhs) */Ù:  i8 r2;              /* Value to return if (lhs > rhs) */ÙH  u8 eqSeen;          /* True if an equality comparison has been seen */¢};  ¢/*Ù0** Each SQL index is represented in memory by anÙ'** instance of the following structure.¢**Ù@** The columns of the table that are to be indexed are describedÙC** by the aiColumn[] field of this structure.  For example, supposeÙ)** we have the following table and index:¢**Ù1**     CREATE TABLE Ex1(c1 int, c2 int, c3 text);Ù&**     CREATE INDEX Ex2 ON Ex1(c3,c1);¢**ÙC** In the Table structure describing Ex1, nCol==3 because there areÙA** three columns in the table.  In the Index structure describingÙ?** Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed.Ù?** The value of aiColumn is {2, 0}.  aiColumn[0]==2 because theÙC** first column to be indexed (c3) has an index of 2 in Ex1.aCol[].Ù<** The second column to be indexed (c1) has an index of 0 inÙ(** Ex1.aCol[], hence Ex2.aiColumn[1]==0.¢**ÙH** The Index.onError field determines whether or not the indexed columnsÙN** must be unique and what to do if they are not.  When Index.onError=OE_None,ÙG** it means this is not a unique index.  Otherwise it is a unique indexÙH** and the value of Index.onError indicate the which conflict resolutionÙI** algorithm to employ whenever an attempt is made to insert a non-unique«** element.¢**ÙE** While parsing a CREATE TABLE or CREATE INDEX statement in order toÙK** generate VDBE code (as opposed to parsing one read from an sqlite_masterÙM** table as part of parsing an existing database schema), transient instancesÙL** of this structure may be created. In this case the Index.tnum variable isÙG** used to store the address of a VDBE instruction, not a database pageÙH** number (it cannot - the database page is not allocated until the VDBEÙF** program is executed). See convertToWithoutRowidTable() for details.¢*/®struct Index {Ù3  char *zName;             /* Name of this index */ÙP  i16 *aiColumn;           /* Which columns are used by this index.  1st is 0 */ÙP  LogEst *aiRowLogEst;     /* From ANALYZE: Est. rows selected by each column */Ù<  Table *pTable;           /* The SQL table being indexed */ÙL  char *zColAff;           /* String defining the affinity of each column */ÙN  Index *pNext;            /* The next index associated with the same table */Ù=  Schema *pSchema;         /* Schema containing this index */ÙH  u8 *aSortOrder;          /* for each column: True==DESC, False==ASC */ÙL  const char **azColl;     /* Array of collation sequence names for index */ÙA  Expr *pPartIdxWhere;     /* WHERE clause for partial indices */Ù3  ExprList *aColExpr;      /* Column expressions */ÙF  int tnum;                /* DB Page containing root of this index */ÙD  LogEst szIdxRow;         /* Estimated average row size in bytes */ÙB  u16 nKeyCol;             /* Number of columns forming the key */ÙF  u16 nColumn;             /* Number of columns stored in the index */ÙL  u8 onError;              /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */ÙK  unsigned idxType:2;      /* 1==UNIQUE, 2==PRIMARY KEY, 0==CREATE INDEX */ÙI  unsigned bUnordered:1;   /* Use this index for == or IN queries only */ÙL  unsigned uniqNotNull:1;  /* True if UNIQUE and NOT NULL for all columns */ÙL  unsigned isResized:1;    /* True if resizeIndexObject() has been called */ÙA  unsigned isCovering:1;   /* True if this is a covering index */ÙD  unsigned noSkipScan:1;   /* Do not try to use skip-scan if true */ÙJ  unsigned hasStat1:1;     /* aiRowLogEst values come from sqlite_stat1 */ÙJ  unsigned bNoQuery:1;     /* Do not use this index to optimize queries */Ù##ifdef SQLITE_ENABLE_STAT3_OR_STAT4Ù@  int nSample;             /* Number of elements in aSample[] */ÙE  int nSampleCol;          /* Size of IndexSample.anEq[] and so on */ÙK  tRowcnt *aAvgEq;         /* Average nEq values for keys not in aSample */Ù=  IndexSample *aSample;    /* Samples of the left-most key */ÙJ  tRowcnt *aiRowEst;       /* Non-logarithmic stat1 data for this index */ÙL  tRowcnt nRowEst0;        /* Non-logarithmic number of rows in the index */¦#endif¢}; ¢/*Ù#** Allowed values for Index.idxType¢*/ÙG#define SQLITE_IDXTYPE_APPDEF      0   /* Created using CREATE INDEX */ÙK#define SQLITE_IDXTYPE_UNIQUE      1   /* Implements a UNIQUE constraint */ÙM#define SQLITE_IDXTYPE_PRIMARYKEY  2   /* Is the PRIMARY KEY for the table */ Ù3/* Return true if index X is a PRIMARY KEY index */ÙG#define IsPrimaryKeyIndex(X)  ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY) Ù./* Return true if index X is a UNIQUE index */Ù5#define IsUniqueIndex(X)      ((X)->onError!=OE_None) ÙB/* The Index.aiColumn[] values are normally positive integer.  ButÙ<** there are some negative values that have special meaning:¢*/Ù?#define XN_ROWID     (-1)     /* Indexed column is the rowid */ÙC#define XN_EXPR      (-2)     /* Indexed column is an expression */ ¢/*ÙH** Each sample stored in the sqlite_stat3 table is represented in memoryÙG** using a structure of this type.  See documentation at the top of theÙ4** analyze.c source file for additional information.¢*/´struct IndexSample {Ù3  void *p;          /* Pointer to sampled record */Ù1  int n;            /* Size of record in bytes */ÙN  tRowcnt *anEq;    /* Est. number of rows where the key equals this sample */ÙP  tRowcnt *anLt;    /* Est. number of rows where key is less than this sample */ÙL  tRowcnt *anDLt;   /* Est. number of distinct keys less than this sample */¢}; ¢/*Ù7** Each token coming out of the lexer is an instance ofÙB** this structure.  Tokens are also used as part of an expression.¢**ÙB** Note if Token.z==0 then Token.dyn and Token.n are undefined andÙJ** may contain random values.  Do not make any assumptions about Token.dyn¿** and Token.n when Token.z==0.¢*/®struct Token {ÙC  const char *z;     /* Text of the token.  Not NULL-terminated! */Ù=  unsigned int n;    /* Number of characters in this token */¢}; ¢/*ÙH** An instance of this structure contains information needed to generateÙ7** code for a SELECT that contains aggregate functions.¢**ÙG** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is aÙE** pointer to this structure.  The Expr.iColumn field is the index inÙF** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate¶** code for that node.¢**ÙF** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within theÙH** original Select structure that describes the SELECT statement.  TheseÙJ** fields do not need to be freed when deallocating the AggInfo structure.¢*/°struct AggInfo {ÙK  u8 directMode;          /* Direct rendering mode means take data directlyÙP                          ** from source tables rather than from accumulators */ÙO  u8 useSortingIdx;       /* In direct mode, reference the sorting index ratherÙ5                          ** than the source table */ÙB  int sortingIdx;         /* Cursor number of the sorting index */Ù=  int sortingIdxPTab;     /* Cursor number of pseudo-table */ÙF  int nSortingColumn;     /* Number of columns in the sorting index */ÙO  int mnReg, mxReg;       /* Range of registers allocated for aCol and aFunc */Ù3  ExprList *pGroupBy;     /* The group by clause */ÙE  struct AggInfo_col {    /* For each column used in source tables */Ù/    Table *pTab;             /* Source table */ÙD    int iTable;              /* Cursor number of the source table */ÙH    int iColumn;             /* Column number within the source table */ÙE    int iSorterColumn;       /* Column number in the sorting index */ÙK    int iMem;                /* Memory location that acts as accumulator */Ù:    Expr *pExpr;             /* The original expression */ª  } *aCol;Ù@  int nColumn;            /* Number of used entries in aCol[] */ÙO  int nAccumulator;       /* Number of columns that show through to the output.ÙN                          ** Additional columns are used only as parameters toÙ3                          ** aggregate functions */Ù;  struct AggInfo_func {   /* For each aggregate function */ÙC    Expr *pExpr;             /* Expression encoding the function */ÙH    FuncDef *pFunc;          /* The aggregate function implementation */ÙK    int iMem;                /* Memory location that acts as accumulator */ÙK    int iDistinct;           /* Ephemeral table used to enforce DISTINCT */«  } *aFunc;Ù<  int nFunc;              /* Number of entries in aFunc[] */¢}; ¢/*ÙC** The datatype ynVar is a signed integer, either 16-bit or 32-bit.ÙG** Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greaterÙE** than 32767 we have to make it 32-bit.  16-bit is preferred becauseÙE** it uses less memory in the Expr object, which is a big memory userÙE** in systems with lots of prepared statements.  And few applicationsÙH** need more than about 10 or 20 variables.  But some extreme users wantÙF** to have prepared statements with over 32767 variables, and for themÙ-** the option is available (at compile-time).¢*/Ù%#if SQLITE_MAX_VARIABLE_NUMBER<=32767²typedef i16 ynVar;¥#else²typedef int ynVar;¦#endif ¢/*Ù>** Each node of an expression in the parse tree is an instanceµ** of this structure.¢**ÙC** Expr.op is the opcode. The integer parser token codes are reusedÙJ** as opcodes here. For example, the parser defines TK_GE to be an integerÙH** code representing the ">=" operator. This same integer code is reusedÙG** to represent the greater-than-or-equal-to operator in the expression¨** tree.¢**ÙF** If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB,ÙJ** or TK_STRING), then Expr.token contains the text of the SQL literal. IfÙK** the expression is a variable (TK_VARIABLE), then Expr.token contains theÙN** variable name. Finally, if the expression is an SQL function (TK_FUNCTION),Ù5** then Expr.token contains the name of the function.¢**ÙH** Expr.pRight and Expr.pLeft are the left and right subexpressions of aÙ/** binary operator. Either or both may be NULL.¢**ÙL** Expr.x.pList is a list of arguments if the expression is an SQL function,ÙN** a CASE expression or an IN expression of the form "<lhs> IN (<y>, <z>...)".ÙO** Expr.x.pSelect is used if the expression is a sub-select or an expression ofÙJ** the form "<lhs> IN (SELECT ...)". If the EP_xIsSelect bit is set in theÙL** Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is©** valid.¢**ÙG** An expression of the form ID or ID.ID refers to a column in a table.ÙG** For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable isÙH** the integer cursor number of a VDBE cursor pointing to that table andÙE** Expr.iColumn is the column number for the specific column.  If theÙB** expression is used as a result in an aggregate SELECT, then theÙH** value is also stored in the Expr.iAgg column in the aggregate so thatÙ8** it can be accessed after all aggregates are computed.¢**ÙC** If the expression is an unbound variable marker (a question markÙJ** character '?' in the original SQL) then the Expr.iTable holds the index¼** number for that variable.¢**ÙE** If the expression is a subquery then Expr.iColumn holds an integerÙA** register number containing the result of the subquery.  If theÙH** subquery gives a constant result, then iTable is -1.  If the subqueryÙJ** gives a different answer at different times during statement processingÙI** then iTable is the address of a subroutine that computes the subquery.¢**ÙG** If the Expr is of type OP_Column, and the table it is selecting fromÙG** is a disk table or the "old.*" pseudo-table, then pTab points to theÙ"** corresponding table definition.¢**´** ALLOCATION NOTES:¢**ÙE** Expr objects can use a lot of memory space in database schema.  ToÙD** help reduce memory requirements, sometimes an Expr object will beÙH** truncated.  And to reduce the number of memory allocations, sometimesÙI** two or more Expr objects will be stored in a single memory allocation,Ù%** together with Expr.zToken strings.¢**Ù8** If the EP_Reduced and EP_TokenOnly flags are set whenÙA** an Expr object is truncated.  When EP_Reduced is set, then allÙD** the child Expr objects in the Expr.pLeft and Expr.pRight subtreesÙH** are contained within the same memory allocation.  Note, however, thatÙG** the subtrees in Expr.x.pList or Expr.x.pSelect are always separatelyÙ=** allocated, regardless of whether or not EP_Reduced is set.¢*/­struct Expr {Ù?  u8 op;                 /* Operation performed by this node */ÙN  char affinity;         /* The affinity of the column or 0 if not a column */Ù=  u32 flags;             /* Various flags.  EP_* See below */©  union {ÙJ    char *zToken;          /* Token value. Zero terminated and dequoted */ÙJ    int iValue;            /* Non-negative integer value if EP_IntValue */¦  } u; ÙD  /* If the EP_TokenOnly flag is set in the Expr.flags mask, then noÙF  ** space is allocated for the fields below this point. An attempt toÙ:  ** access them will result in a segfault or malfunction.ÙH  *********************************************************************/ Ù+  Expr *pLeft;           /* Left subnode */Ù,  Expr *pRight;          /* Right subnode */©  union {ÙO    ExprList *pList;     /* op = IN, EXISTS, SELECT, CASE, FUNCTION, BETWEEN */ÙG    Select *pSelect;     /* EP_xIsSelect and op = IN, EXISTS, SELECT */¦  } x; ÙB  /* If the EP_Reduced flag is set in the Expr.flags mask, then noÙF  ** space is allocated for the fields below this point. An attempt toÙ:  ** access them will result in a segfault or malfunction.ÙH  *********************************************************************/ »#if SQLITE_MAX_EXPR_DEPTH>0ÙE  int nHeight;           /* Height of the tree headed by this node */¦#endifÙL  int iTable;            /* TK_COLUMN: cursor number of table holding columnÙ8                         ** TK_REGISTER: register numberÙ:                         ** TK_TRIGGER: 1 -> new, 0 -> oldÙD                         ** EP_Unlikely:  134217728 times likelihoodÙG                         ** TK_SELECT: 1st register of result vector */ÙC  ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.ÙG                         ** TK_VARIABLE: variable number (always >= 1).ÙL                         ** TK_SELECT_COLUMN: column of the result vector */ÙK  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */ÙJ  i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */ÙB  u8 op2;                /* TK_REGISTER: original value of Expr.opÙD                         ** TK_COLUMN: the value of p5 for OP_ColumnÙ=                         ** TK_AGG_FUNCTION: nesting depth */ÙH  AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */ÙI  Table *pTab;           /* Table for TK_COLUMN expressions.  Can be NULLÙH                         ** for a column of an index on an expression */¢}; ¢/*ÙB** The following are the meanings of bits in the Expr.flags field.¢*/ÙO#define EP_FromJoin  0x000001 /* Originates in ON/USING clause of outer join */ÙL#define EP_Agg       0x000002 /* Contains one or more aggregate functions */ÙN#define EP_HasFunc   0x000004 /* Contains one or more functions of any kind */Ù5                  /* 0x000008 // available for use */ÙL#define EP_Distinct  0x000010 /* Aggregate function with DISTINCT keyword */ÙG#define EP_VarSelect 0x000020 /* pSelect is correlated, not constant */ÙC#define EP_DblQuoted 0x000040 /* token.z was originally in "..." */ÙO#define EP_InfixFunc 0x000080 /* True for an infix function: LIKE, GLOB, etc */ÙG#define EP_Collate   0x000100 /* Tree contains a TK_COLLATE operator */ÙK#define EP_Generic   0x000200 /* Ignore COLLATE or affinity on this tree */ÙG#define EP_IntValue  0x000400 /* Integer value contained in u.iValue */ÙM#define EP_xIsSelect 0x000800 /* x.pSelect is valid (otherwise x.pList is) */Ù<#define EP_Skip      0x001000 /* COLLATE, AS, or UNLIKELY */ÙK#define EP_Reduced   0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */ÙM#define EP_TokenOnly 0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */ÙM#define EP_Static    0x008000 /* Held in memory not obtained from malloc() */ÙG#define EP_MemToken  0x010000 /* Need to sqlite3DbFree() Expr.zToken */ÙC#define EP_NoReduce  0x020000 /* Cannot EXPRDUP_REDUCE this Expr */ÙG#define EP_Unlikely  0x040000 /* unlikely() or likelihood() function */ÙO#define EP_ConstFunc 0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */ÙK#define EP_CanBeNull 0x100000 /* Can be null despite NOT NULL constraint */ÙF#define EP_Subquery  0x200000 /* Tree contains a TK_SELECT operator */ÙG#define EP_Alias     0x400000 /* Is an alias for a result set column */ÙL#define EP_Leaf      0x800000 /* Expr.pLeft, .pRight, .u.pSelect all NULL */ ¢/*ÙL** The EP_Propagate mask is a set of properties that automatically propagate½** upwards into parent nodes.¢*/Ù8#define EP_Propagate (EP_Collate|EP_Subquery|EP_HasFunc) ¢/*Ù>** These macros can be used to test, set, or clear bits in the´** Expr.flags field.¢*/Ù6#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)Ù8#define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))Ù0#define ExprSetProperty(E,P)     (E)->flags|=(P)Ù1#define ExprClearProperty(E,P)   (E)->flags&=~(P) ÙG/* The ExprSetVVAProperty() macro is used for Verification, Validation,ÙF** and Accreditation only.  It works like ExprSetProperty() during VVAÙ)** processes but is a no-op for delivery.¢*/³#ifdef SQLITE_DEBUGÙ1# define ExprSetVVAProperty(E,P)  (E)->flags|=(P)¥#elseÙ # define ExprSetVVAProperty(E,P)¦#endif ¢/*ÙD** Macros to determine the number of bytes required by a normal ExprÙD** struct, an Expr struct with the EP_Reduced flag set in Expr.flagsÙ5** and an Expr struct with the EP_TokenOnly flag set.¢*/ÙF#define EXPR_FULLSIZE           sizeof(Expr)           /* Full size */ÙL#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /* Common features */ÙK#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /* Fewer features */ ¢/*ÙH** Flags passed to the sqlite3ExprDup() function. See the header commentÙ&** above sqlite3ExprDup() for details.¢*/ÙI#define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */ ¢/*Ù@** A list of expressions.  Each expression may optionally have aÙD** name.  An expr/name combination can be used in several ways, suchÙD** as the list of "expr AS ID" fields following a "SELECT" or in theÙE** list of "ID = expr" items in an UPDATE.  A list of expressions canÙH** also be used as the argument to a function, in which case the a.zNameµ** field is not used.¢**ÙH** By default the Expr.zSpan field holds a human-readable description ofÙF** the expression that is used in the generation of error messages andÙF** column labels.  In this case, Expr.zSpan is typically the text of aÙE** column expression as it exists in a SELECT statement.  However, ifÙH** the bSpanIsTab flag is set, then zSpan is overloaded to mean the nameÙG** of the result column in the form: DATABASE.TABLE.COLUMN.  This laterÙ=** form is used for name resolution with nested FROM clauses.¢*/±struct ExprList {Ù@  int nExpr;             /* Number of expressions on the list */Ù>  struct ExprList_item { /* For each expression in the list */ÙD    Expr *pExpr;            /* The parse tree for this expression */ÙG    char *zName;            /* Token associated with this expression */ÙA    char *zSpan;            /* Original text of the expression */Ù9    u8 sortOrder;           /* 1 for DESC or 0 for ASC */ÙP    unsigned done :1;       /* A flag to indicate when processing is finished */Ù=    unsigned bSpanIsTab :1; /* zSpan holds DB.TABLE.COLUMN */ÙA    unsigned reusable :1;   /* Constant expression is reusable */«    union {®      struct {ÙM        u16 iOrderByCol;      /* For ORDER BY, column number in result set */ÙG        u16 iAlias;           /* Index into Parse.aAlias[] for zName */ª      } x;ÙJ      int iConstExprReg;      /* Register in which Expr value is cached */¨    } u;ÙI  } a[1];                  /* One slot for each expression in the list */¢}; ¢/*ÙG** An instance of this structure can hold a simple list of identifiers,Ù8** such as the list "a,b,c" in the following statements:¢**Ù(**      INSERT INTO t(a,b,c) VALUES ...;Ù%**      CREATE INDEX idx ON t(a,b,c);Ù:**      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;¢**ÙH** The IdList.a.idx field is used when the IdList represents the list ofÙL** column names after a table name in an INSERT statement.  In the statement¢**¿**     INSERT INTO t(a,b,c) ...¢**ÙC** If "a" is the k-th column of table "t", then IdList.a[0].idx==k.¢*/¯struct IdList {¶  struct IdList_item {Ù2    char *zName;      /* Name of the identifier */ÙN    int idx;          /* Index in some Table.aCol[] of a column named zName */§  } *a;Ù:  int nId;         /* Number of identifiers on the list */¢}; ¢/*ÙH** The bitmask datatype defined below is used for various optimizations.¢**ÙD** Changing this from a 64-bit to a 32-bit type limits the number ofÙF** tables in a join to 32 instead of 64.  But it also reduces the sizeÙ'** of the library by 738 bytes on ix86.¢*/º#ifdef SQLITE_BITMASK_TYPEÙ&  typedef SQLITE_BITMASK_TYPE Bitmask;¥#else¶  typedef u64 Bitmask;¦#endif ¢/*Ù@** The number of bits in a Bitmask.  "BMS" means "BitMask Size".¢*/Ù'#define BMS  ((int)(sizeof(Bitmask)*8)) ¢/*µ** A bit in a Bitmask¢*/Ù(#define MASKBIT(n)   (((Bitmask)1)<<(n))Ù-#define MASKBIT32(n) (((unsigned int)1)<<(n))Ù"#define ALLBITS      ((Bitmask)-1) ¢/*ÙK** The following structure describes the FROM clause of a SELECT statement.ÙE** Each table or subquery in the FROM clause is a separate element of¹** the SrcList.a[] array.¢**ÙJ** With the addition of multiple database support, the following structureÙI** can also be used to describe a particular table such as the table thatÙK** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,ÙH** such a table must be a simple name: ID.  But in SQLite, the table canÙK** now be identified by a database name, a dot, then the table name: ID.ID.¢**ÙJ** The jointype starts out showing the join type between the current tableÙH** and the next table on the list.  The parser builds the list this way.ÙL** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that eachÙH** jointype expresses the join between the table and the previous table.¢**ÙH** In the colUsed field, the high-order bit (bit 63) is set if the tableÙG** contains more than 63 columns and the 64-th or later column is used.¢*/°struct SrcList {ÙJ  int nSrc;        /* Number of tables or subqueries in the FROM clause */ÙA  u32 nAlloc;      /* Number of entries allocated in a[] below */·  struct SrcList_item {Ù>    Schema *pSchema;  /* Schema to which this item is fixed */Ù?    char *zDatabase;  /* Name of database holding this table */Ù-    char *zName;      /* Name of the table */ÙP    char *zAlias;     /* The "B" part of a "A AS B" phrase.  zName is the "A" */Ù?    Table *pTab;      /* An SQL table corresponding to zName */ÙL    Select *pSelect;  /* A SELECT statement used in place of a table name */ÙH    int addrFillSub;  /* Address of subroutine to manifest a subquery */ÙJ    int regReturn;    /* Register holding return address of addrFillSub */ÙE    int regResult;    /* Registers holding results of a co-routine */¬    struct {ÙN      u8 jointype;      /* Type of join between this table and the previous */ÙL      unsigned notIndexed :1;    /* True if there is a NOT INDEXED clause */ÙL      unsigned isIndexedBy :1;   /* True if there is an INDEXED BY clause */ÙK      unsigned isTabFunc :1;     /* True if table-valued-function syntax */ÙF      unsigned isCorrelated :1;  /* True if sub-query is correlated */ÙB      unsigned viaCoroutine :1;  /* Implemented as a co-routine */ÙK      unsigned isRecursive :1;   /* True for recursive reference in WITH */©    } fg;»#ifndef SQLITE_OMIT_EXPLAINÙJ    u8 iSelectId;     /* If pSelect!=0, the id of the sub-select in EQP */¦#endifÙL    int iCursor;      /* The VDBE cursor number used to access this table */Ù3    Expr *pOn;        /* The ON clause of a join */Ù6    IdList *pUsing;   /* The USING clause of a join */ÙH    Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */«    union {ÙM      char *zIndexedBy;    /* Identifier from "INDEXED BY <zIndex>" clause */ÙC      ExprList *pFuncArg;  /* Arguments to table-valued-function */©    } u1;ÙJ    Index *pIBIndex;  /* Index structure corresponding to u1.zIndexedBy */ÙE  } a[1];             /* One entry for each identifier on the list */¢}; ¢/*Ù3** Permitted values of the SrcList.a.jointype field¢*/ÙD#define JT_INNER     0x0001    /* Any kind of inner or cross join */ÙF#define JT_CROSS     0x0002    /* Explicit use of the CROSS keyword */Ù>#define JT_NATURAL   0x0004    /* True for a "natural" join */Ù4#define JT_LEFT      0x0008    /* Left outer join */Ù5#define JT_RIGHT     0x0010    /* Right outer join */ÙC#define JT_OUTER     0x0020    /* The "OUTER" keyword is present */ÙE#define JT_ERROR     0x0040    /* unknown or unsupported join type */  ¢/*ÙH** Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()Ù'** and the WhereInfo.wctrlFlags member.¢**Ù-** Value constraints (enforced via assert()):Ù(**     WHERE_USE_LIMIT  == SF_FixedLimit¢*/Ù1#define WHERE_ORDERBY_NORMAL   0x0000 /* No-op */ÙN#define WHERE_ORDERBY_MIN      0x0001 /* ORDER BY processing for min() func */ÙN#define WHERE_ORDERBY_MAX      0x0002 /* ORDER BY processing for max() func */ÙM#define WHERE_ONEPASS_DESIRED  0x0004 /* Want to do one-pass UPDATE/DELETE */ÙL#define WHERE_ONEPASS_MULTIROW 0x0008 /* ONEPASS is ok with multiple rows */ÙM#define WHERE_DUPLICATES_OK    0x0010 /* Ok to return a row more than once */ÙJ#define WHERE_OR_SUBCLAUSE     0x0020 /* Processing a sub-WHERE as part ofÙ@                                      ** the OR optimization  */ÙI#define WHERE_GROUPBY          0x0040 /* pOrderBy is really a GROUP BY */ÙP#define WHERE_DISTINCTBY       0x0080 /* pOrderby is really a DISTINCT clause */ÙK#define WHERE_WANT_DISTINCT    0x0100 /* All output needs to be distinct */ÙJ#define WHERE_SORTBYGROUP      0x0200 /* Support sqlite3WhereIsSorted() */ÙL#define WHERE_SEEK_TABLE       0x0400 /* Do not defer seeks on main table */ÙK#define WHERE_ORDERBY_LIMIT    0x0800 /* ORDERBY+LIMIT on the inner loop */ÙH#define WHERE_SEEK_UNIQ_TABLE  0x1000 /* Do not defer seeks if unique */Ù>                        /*     0x2000    not currently used */ÙK#define WHERE_USE_LIMIT        0x4000 /* Use the LIMIT in cost estimates */Ù>                        /*     0x8000    not currently used */ Ù6/* Allowed return values from sqlite3WhereIsDistinct()¢*/ÙC#define WHERE_DISTINCT_NOOP      0  /* DISTINCT keyword not used */Ù7#define WHERE_DISTINCT_UNIQUE    1  /* No duplicates */ÙE#define WHERE_DISTINCT_ORDERED   2  /* All duplicates are adjacent */ÙB#define WHERE_DISTINCT_UNORDERED 3  /* Duplicates are scattered */ ¢/*ÙG** A NameContext defines a context in which to resolve table and columnÙL** names.  The context consists of a list of tables (the pSrcList) field andÙF** a list of named expression (pEList).  The named expression list mayÙC** be NULL.  The pSrc corresponds to the FROM clause of a SELECT orÙD** to the table being operated on by INSERT, UPDATE, or DELETE.  TheÙC** pEList corresponds to the result set of a SELECT and is NULL for´** other statements.¢**ÙD** NameContexts can be nested.  When resolving names, the inner-mostÙC** context is searched first.  If no match is found, the next outerÙD** context is checked.  If there is still no match, the next contextÙD** is checked.  This process continues until either a match is foundÙH** or all contexts are check.  When a match is found, the nRef member ofÙ3** the context containing the match is incremented.¢**ÙG** Each subquery gets a new NameContext.  The pNext field points to theÙE** NameContext in the parent query.  Thus the process of scanning theÙG** NameContext list corresponds to searching through successively outerÙ"** subqueries looking for a match.¢*/´struct NameContext {Ù'  Parse *pParse;       /* The parser */ÙE  SrcList *pSrcList;   /* One or more tables used to resolve names */Ù@  ExprList *pEList;    /* Optional list of result-set columns */ÙG  AggInfo *pAggInfo;   /* Information about aggregates at this level */ÙI  NameContext *pNext;  /* Next outer name context.  NULL for outermost */ÙE  int nRef;            /* Number of names resolved by this context */ÙO  int nErr;            /* Number of errors encountered while resolving names */ÙB  u16 ncFlags;         /* Zero or more NC_* flags defined below */¢}; ¢/*Ù5** Allowed values for the NameContext, ncFlags field.¢**Ù0** Value constraints (all checked via assert()):¿**    NC_HasAgg    == SF_HasAggÙ8**    NC_MinMaxAgg == SF_MinMaxAgg == SQLITE_FUNC_MINMAX¢**¢*/ÙG#define NC_AllowAgg  0x0001  /* Aggregate functions are allowed here */ÙJ#define NC_PartIdx   0x0002  /* True if resolving a partial index WHERE */ÙP#define NC_IsCheck   0x0004  /* True if resolving names in a CHECK constraint */ÙM#define NC_InAggFunc 0x0008  /* True if analyzing arguments to an agg func */ÙG#define NC_HasAgg    0x0010  /* One or more aggregate functions seen */ÙL#define NC_IdxExpr   0x0020  /* True if resolving columns of CREATE INDEX */ÙF#define NC_VarSelect 0x0040  /* A correlated subquery has been seen */ÙK#define NC_MinMaxAgg 0x1000  /* min/max aggregates seen.  See note above */ÙF#define NC_Complex   0x2000  /* True if a function or subquery seen */ ¢/*ÙB** An instance of the following structure contains all informationÙ9** needed to generate code for a single SELECT statement.¢**ÙI** nLimit is set to -1 if there is no LIMIT clause.  nOffset is set to 0.ÙI** If there is a LIMIT clause, the parser sets nLimit to the value of theÙE** limit and nOffset to the value of the offset (or 0 if there is notÙI** offset).  But later on, nLimit and nOffset become the memory locationsÙ9** in the VDBE that record the limit and offset counters.¢**ÙJ** addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.ÙD** These addresses must be stored so that we can go back and fill inÙC** the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo norÙ?** the number of columns in P2 can be computed at the same timeÙ6** as the OP_OpenEphm instruction is coded because notÙF** enough information about the compound query is known at that point.ÙG** The KeyInfo for addrOpenTran[0] and [1] contains collating sequencesÙJ** for the result set.  The KeyInfo for addrOpenEphm[2] contains collatingÙ%** sequences for the ORDER BY clause.¢*/¯struct Select {Ù7  ExprList *pEList;      /* The fields of the result */ÙM  u8 op;                 /* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT */Ù>  LogEst nSelectRow;     /* Estimated number of result rows */Ù2  u32 selFlags;          /* Various SF_* values */ÙO  int iLimit, iOffset;   /* Memory registers holding LIMIT & OFFSET counters */·#if SELECTTRACE_ENABLEDÙM  char zSelName[12];     /* Symbolic name of this SELECT use for debugging */¦#endifÙJ  int addrOpenEphm[2];   /* OP_OpenEphem opcodes related to this select */Ù.  SrcList *pSrc;         /* The FROM clause */Ù/  Expr *pWhere;          /* The WHERE clause */Ù2  ExprList *pGroupBy;    /* The GROUP BY clause */Ù0  Expr *pHaving;         /* The HAVING clause */Ù2  ExprList *pOrderBy;    /* The ORDER BY clause */ÙJ  Select *pPrior;        /* Prior select in a compound select statement */ÙD  Select *pNext;         /* Next select to the left in a compound */ÙE  Expr *pLimit;          /* LIMIT expression. NULL means not used. */ÙL  With *pWith;           /* WITH clause attached to this select. Or NULL. */¢}; ¢/*ÙB** Allowed values for Select.selFlags.  The "SF" prefix stands for±** "Select Flag".¢**Ù/** Value constraints (all checked via assert())Ù!**     SF_HasAgg     == NC_HasAggÙ>**     SF_MinMaxAgg  == NC_MinMaxAgg     == SQLITE_FUNC_MINMAXÙ'**     SF_FixedLimit == WHERE_USE_LIMIT¢*/ÙB#define SF_Distinct       0x00001  /* Output should be DISTINCT */ÙA#define SF_All            0x00002  /* Includes the ALL keyword */ÙG#define SF_Resolved       0x00004  /* Identifiers have been resolved */ÙM#define SF_Aggregate      0x00008  /* Contains agg functions or a GROUP BY */ÙE#define SF_HasAgg         0x00010  /* Contains aggregate functions */ÙF#define SF_UsesEphemeral  0x00020  /* Uses the OpenEphemeral opcode */ÙM#define SF_Expanded       0x00040  /* sqlite3SelectExpand() called on this */ÙL#define SF_HasTypeInfo    0x00080  /* FROM subqueries have Table metadata */ÙA#define SF_Compound       0x00100  /* Part of a compound query */ÙG#define SF_Values         0x00200  /* Synthesized from VALUES clause */ÙN#define SF_MultiValue     0x00400  /* Single VALUES term with multiple rows */ÙL#define SF_NestedFrom     0x00800  /* Part of a parenthesized FROM clause */ÙL#define SF_MinMaxAgg      0x01000  /* Aggregate containing min() or max() */ÙN#define SF_Recursive      0x02000  /* The recursive part of a recursive CTE */ÙK#define SF_FixedLimit     0x04000  /* nSelectRow set by a constant LIMIT */ÙO#define SF_MaybeConvert   0x08000  /* Need convertCompoundSelectToSubquery() */ÙM#define SF_Converted      0x10000  /* By convertCompoundSelectToSubquery() */ÙI#define SF_IncludeHidden  0x20000  /* Include hidden columns in output */ÙQ#define SF_ComplexResult  0x40000  /* Result set contains subquery or function */  ¢/*ÙI** The results of a SELECT can be distributed in several ways, as definedÙI** by one of the following macros.  The "SRT" prefix means "SELECT Result©** Type".¢**ÙB**     SRT_Union       Store results as a key in a temporary indexÙ4**                     identified by pDest->iSDParm.¢**ÙN**     SRT_Except      Remove results from the temporary index pDest->iSDParm.¢**ÙL**     SRT_Exists      Store a 1 in memory cell pDest->iSDParm if the resultÙ(**                     set is not empty.¢**ÙF**     SRT_Discard     Throw the results away.  This is used by SELECTÙG**                     statements within triggers whose only purpose isÙ5**                     the side-effects of functions.¢**ÙH** All of the above are free to ignore their ORDER BY clause. Those thatÙ)** follow must honor the ORDER BY clause.¢**ÙG**     SRT_Output      Generate a row of output (using the OP_ResultRowÙ>**                     opcode) for each row in the result set.¢**ÙC**     SRT_Mem         Only valid if the result is a single column.ÙE**                     Store the first column of the first result rowÙG**                     in register pDest->iSDParm then abandon the restÙI**                     of the query.  This destination implies "LIMIT 1".¢**ÙF**     SRT_Set         The result must be a single column.  Store eachÙH**                     row of result as the key in table pDest->iSDParm.ÙG**                     Apply the affinity pDest->affSdst before storingÙE**                     results.  Used to implement "IN (SELECT ...)".¢**ÙI**     SRT_EphemTab    Create an temporary table pDest->iSDParm and storeÙF**                     the result there. The cursor is left open afterÙE**                     returning.  This is like SRT_Table except thatÙG**                     this destination uses OP_OpenEphemeral to createÙ'**                     the table first.¢**ÙF**     SRT_Coroutine   Generate a co-routine that returns a new row ofÙH**                     results each time it is invoked.  The entry pointÙM**                     of the co-routine is stored in register pDest->iSDParmÙM**                     and the result row is stored in pDest->nDest registersÙ2**                     starting with pDest->iSdst.¢**ÙG**     SRT_Table       Store results in temporary table pDest->iSDParm.ÙF**     SRT_Fifo        This is like SRT_EphemTab except that the tableÙC**                     is assumed to already be open.  SRT_Fifo hasÙF**                     the additional property of being able to ignoreÙ+**                     the ORDER BY clause.¢**ÙI**     SRT_DistFifo    Store results in a temporary table pDest->iSDParm.ÙG**                     But also use temporary table pDest->iSDParm+1 asÙM**                     a record of all prior results and ignore any duplicateÙ;**                     rows.  Name means:  "Distinct Fifo".¢**ÙM**     SRT_Queue       Store results in priority queue pDest->iSDParm (reallyÙO**                     an index).  Append a sequence number so that all entriesÙ$**                     are distinct.¢**ÙM**     SRT_DistQueue   Store results in priority queue pDest->iSDParm only ifÙI**                     the same record has never been stored before.  TheÙG**                     index at pDest->iSDParm+1 hold all prior stores.¢*/ÙB#define SRT_Union        1  /* Store result as keys in an index */ÙB#define SRT_Except       2  /* Remove result from a UNION index */ÙD#define SRT_Exists       3  /* Store 1 if the result is not empty */ÙB#define SRT_Discard      4  /* Do not save the results anywhere */ÙN#define SRT_Fifo         5  /* Store result as data with an automatic rowid */ÙH#define SRT_DistFifo     6  /* Like SRT_Fifo, but unique results only */Ù:#define SRT_Queue        7  /* Store result in an queue */ÙI#define SRT_DistQueue    8  /* Like SRT_Queue, but unique results only */ Ù9/* The ORDER BY clause is ignored for all of the above */Ù7#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue) Ù;#define SRT_Output       9  /* Output each row of result */Ù?#define SRT_Mem         10  /* Store result in a memory cell */ÙC#define SRT_Set         11  /* Store results as keys in an index */ÙO#define SRT_EphemTab    12  /* Create transient tab and store like SRT_Table */ÙA#define SRT_Coroutine   13  /* Generate a single row of result */ÙN#define SRT_Table       14  /* Store result as data with an automatic rowid */ ¢/*ÙF** An instance of this object describes where to put of the results of¶** a SELECT statement.¢*/³struct SelectDest {ÙO  u8 eDest;            /* How to dispose of the results.  On of SRT_* above. */ÙJ  int iSDParm;         /* A parameter used by the eDest disposal method */ÙD  int iSdst;           /* Base register where results are written */Ù:  int nSdst;           /* Number of registers allocated */Ù>  char *zAffSdst;      /* Affinity used when eDest==SRT_Set */ÙH  ExprList *pOrderBy;  /* Key columns for SRT_Queue and SRT_DistQueue */¢}; ¢/*ÙJ** During code generation of statements that do inserts into AUTOINCREMENTÙI** tables, the following information is attached to the Table.u.autoInc.pÙK** pointer of each autoincrement table to record some side information thatÙE** the code generator needs.  We have to keep per-table autoincrementÙI** information in case inserts are done within triggers.  Triggers do notÙI** normally coordinate their activities, but we do need to coordinate theÙ3** loading and saving of autoincrement information.¢*/´struct AutoincInfo {ÙC  AutoincInfo *pNext;   /* Next info block in a list of them all */Ù=  Table *pTab;          /* Table this info block refers to */ÙM  int iDb;              /* Index in sqlite3.aDb[] of database holding pTab */ÙG  int regCtr;           /* Memory register holding the rowid counter */¢}; ¢/*»** Size of the column cache¢*/¹#ifndef SQLITE_N_COLCACHE½# define SQLITE_N_COLCACHE 10¦#endif ¢/*ÙG** At least one instance of the following structure is created for eachÙF** trigger that may be fired while parsing an INSERT, UPDATE or DELETEÙF** statement. All such objects are stored in the linked list headed atÙD** Parse.pTriggerPrg and deleted once statement compilation has been­** completed.¢**ÙI** A Vdbe sub-program that implements the body and WHEN clause of triggerÙ@** TriggerPrg.pTrigger, assuming a default ON CONFLICT clause ofÙD** TriggerPrg.orconf, is stored in the TriggerPrg.pProgram variable.ÙF** The Parse.pTriggerPrg list never contains two entries with the sameÙ'** values for both pTrigger and orconf.¢**ÙH** The TriggerPrg.aColmask[0] variable is set to a mask of old.* columnsÙA** accessed (or set to 0 for triggers fired as a result of INSERTÙH** statements). Similarly, the TriggerPrg.aColmask[1] variable is set toÙ/** a mask of new.* columns used by the program.¢*/³struct TriggerPrg {ÙC  Trigger *pTrigger;      /* Trigger this program was coded from */ÙD  TriggerPrg *pNext;      /* Next entry in Parse.pTriggerPrg list */ÙD  SubProgram *pProgram;   /* Program implementing pTrigger/orconf */Ù:  int orconf;             /* Default ON CONFLICT policy */ÙF  u32 aColmask[2];        /* Masks of old.*, new.* columns accessed */¢}; ¢/*ÙB** The yDbMask datatype for the bitmask of all attached databases.¢*/º#if SQLITE_MAX_ATTACHED>30Ù;  typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)/8];Ù:# define DbMaskTest(M,I)    (((M)[(I)/8]&(1<<((I)&7)))!=0)Ù3# define DbMaskZero(M)      memset((M),0,sizeof(M))Ù4# define DbMaskSet(M,I)     (M)[(I)/8]|=(1<<((I)&7))Ù3# define DbMaskAllZero(M)   sqlite3DbMaskAllZero(M)Ù8# define DbMaskNonZero(M)   (sqlite3DbMaskAllZero(M)==0)¥#else¿  typedef unsigned int yDbMask;Ù:# define DbMaskTest(M,I)    (((M)&(((yDbMask)1)<<(I)))!=0)Ù!# define DbMaskZero(M)      (M)=0Ù4# define DbMaskSet(M,I)     (M)|=(((yDbMask)1)<<(I))Ù"# define DbMaskAllZero(M)   (M)==0Ù"# define DbMaskNonZero(M)   (M)!=0¦#endif ¢/*ÙE** An SQL parser context.  A copy of this structure is passed throughÙE** the parser and down into all the parser action routine in order toÙ?** carry around information that is global to the entire parse.¢**ÙE** The structure is divided into two parts.  When the parser and codeÙH** generate call themselves recursively, the first part of the structureÙG** is constant but the second part is reset at the beginning and end of²** each recursion.¢**ÙL** The nTableLock and aTableLock variables are only used if the shared-cacheÙH** feature is enabled (if sqlite3Tsd()->useSharedData is true). They areÙG** used to store the set of table-locks required by the statement beingÙF** compiled. Function sqlite3TableLock() is used to add entries to the¨** list.¢*/®struct Parse {Ù8  sqlite3 *db;         /* The main database structure */Ù-  char *zErrMsg;       /* An error message */ÙF  Vdbe *pVdbe;         /* An engine for executing database bytecode */Ù7  int rc;              /* Return code from execution */ÙN  u8 colNamesSet;      /* TRUE after OP_ColumnName has been issued to pVdbe */ÙF  u8 checkSchema;      /* Causes schema cookie check after an error */ÙP  u8 nested;           /* Number of nested calls to the parser/code generator */ÙH  u8 nTempReg;         /* Number of temporary registers in aTempReg[] */ÙN  u8 isMultiWrite;     /* True if statement may modify/insert multiple rows */ÙK  u8 mayAbort;         /* True if statement may throw an ABORT exception */ÙM  u8 hasCompound;      /* Need to invoke convertCompoundSelectToSubquery() */Ù7  u8 okConstFactor;    /* OK to factor out constants */ÙH  u8 disableLookaside; /* Number of times lookaside has been disabled */Ù=  u8 nColCache;        /* Number of entries in aColCache[] */ÙA  int nRangeReg;       /* Size of the temporary register block */ÙG  int iRangeReg;       /* First register in temporary register block */Ù2  int nErr;            /* Number of errors seen */ÙH  int nTab;            /* Number of previously allocated VDBE cursors */Ù?  int nMem;            /* Number of memory cells used so far */ÙE  int nOpAlloc;        /* Number of slots allocated for Vdbe.aOp[] */ÙK  int szOpAlloc;       /* Bytes of memory space allocated for Vdbe.aOp[] */ÙM  int iSelfTab;        /* Table associated with an index on expr, or negativeÙN                       ** of the base register during check-constraint eval */ÙP  int iCacheLevel;     /* ColCache valid when aColCache[].iLevel<=iCacheLevel */ÙL  int iCacheCnt;       /* Counter used to generate aColCache[].lru values */Ù2  int nLabel;          /* Number of labels used */Ù5  int *aLabel;         /* Space to hold the labels */Ù1  ExprList *pConstExpr;/* Constant expressions */ÙJ  Token constraintName;/* Name of the constraint currently being parsed */ÙI  yDbMask writeMask;   /* Start a write transaction on these databases */ÙA  yDbMask cookieMask;  /* Bitmask of schema verified databases */ÙI  int regRowid;        /* Register holding rowid of CREATE TABLE entry */ÙN  int regRoot;         /* Register holding root page number for new objects */ÙL  int nMaxArg;         /* Max args passed to user function by sub-program */·#if SELECTTRACE_ENABLEDÙ=  int nSelect;         /* Number of SELECT statements seen */¦#endifÙ #ifndef SQLITE_OMIT_SHARED_CACHEÙ<  int nTableLock;        /* Number of locks in aTableLock */ÙI  TableLock *aTableLock; /* Required table locks for shared-cache mode */¦#endifÙE  AutoincInfo *pAinc;  /* Information about AUTOINCREMENT counters */ÙG  Parse *pToplevel;    /* Parse structure for main program (or NULL) */Ù?  Table *pTriggerTab;  /* Table triggers are being coded for */ÙM  int addrCrTab;       /* Address of OP_CreateBtree opcode on CREATE TABLE */ÙM  u32 nQueryLoop;      /* Est number of iterations of a query (10*log2(N)) */Ù=  u32 oldmask;         /* Mask of old.* columns referenced */Ù=  u32 newmask;         /* Mask of new.* columns referenced */Ù>  u8 eTriggerOp;       /* TK_UPDATE, TK_INSERT or TK_DELETE */ÙI  u8 eOrconf;          /* Default ON CONFLICT policy for trigger steps */Ù5  u8 disableTriggers;  /* True to disable triggers */ ÙM  /**************************************************************************ÙG  ** Fields above must be initialized to zero.  The fields that follow,ÙF  ** down to the beginning of the recursive section, do not need to beÙH  ** initialized as they will be set before being used.  The boundary isÙ-  ** determined by offsetof(Parse,aColCache).ÙM  **************************************************************************/ ´  struct yColCache {Ù3    int iTable;           /* Table cursor number */Ù3    i16 iColumn;          /* Table column number */ÙN    u8 tempReg;           /* iReg is a temp register that needs to be freed */Ù-    int iLevel;           /* Nesting level */ÙL    int iReg;             /* Reg with value of this column. 0 means none. */ÙP    int lru;              /* Least recently used entry has the smallest value */ÙH  } aColCache[SQLITE_N_COLCACHE];  /* One for each column cache entry */ÙD  int aTempReg[8];        /* Holding area for temporary registers */ÙI  Token sNameToken;       /* Token with unqualified schema object name */ ÙK  /************************************************************************ÙK  ** Above is constant between recursions.  Below is reset before and afterÙJ  ** each recursion.  The boundary between these two regions is determinedÙI  ** using offsetof(Parse,sLastToken) so the sLastToken field must be theÙ)  ** first field in the recursive region.ÙK  ************************************************************************/ Ù5  Token sLastToken;       /* The last token parsed */ÙP  ynVar nVar;               /* Number of '?' variables seen in the SQL so far */ÙE  u8 iPkSortOrder;          /* ASC or DESC for INTEGER PRIMARY KEY */ÙP  u8 explain;               /* True if the EXPLAIN flag is found on the query */Ù #ifndef SQLITE_OMIT_VIRTUALTABLEÙG  u8 declareVtab;           /* True if inside sqlite3_declare_vtab() */ÙB  int nVtabLock;            /* Number of virtual tables to lock */¦#endifÙN  int nHeight;              /* Expression tree height of current sub-select */»#ifndef SQLITE_OMIT_EXPLAINÙI  int iSelectId;            /* ID of current select for EXPLAIN output */ÙM  int iNextSelectId;        /* Next available select ID for EXPLAIN output */¦#endifÙL  VList *pVList;            /* Mapping between variable names and numbers */ÙJ  Vdbe *pReprepare;         /* VM being reprepared (sqlite3Reprepare()) */ÙM  const char *zTail;        /* All SQL text past the last semicolon parsed */ÙK  Table *pNewTable;         /* A table being constructed by CREATE TABLE */ÙM  Trigger *pNewTrigger;     /* Trigger under construct by a CREATE TRIGGER */ÙJ  const char *zAuthContext; /* The 6th parameter to db->xAuth callbacks */Ù #ifndef SQLITE_OMIT_VIRTUALTABLEÙD  Token sArg;               /* Complete text of a module argument */ÙK  Table **apVtabLock;       /* Pointer to virtual tables needing locking */¦#endifÙP  Table *pZombieTab;        /* List of Table objects to delete after code gen */Ù?  TriggerPrg *pTriggerPrg;  /* Linked list of coded triggers */Ù>  With *pWith;              /* Current WITH clause, or NULL */ÙO  With *pWithToFree;        /* Free this WITH object at the end of the parse */¢}; ¢/*Ù;** Sizes and pointers of various parts of the Parse object.¢*/ÙP#define PARSE_HDR_SZ offsetof(Parse,aColCache) /* Recursive part w/o aColCache*/ÙK#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)    /* Recursive part */ÙO#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ) /* Non-recursive part */ÙL#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)  /* Pointer to tail */ ¢/*ÙB** Return true if currently inside an sqlite3_declare_vtab() call.¢*/¿#ifdef SQLITE_OMIT_VIRTUALTABLE»  #define IN_DECLARE_VTAB 0¥#elseÙ/  #define IN_DECLARE_VTAB (pParse->declareVtab)¦#endif ¢/*ÙM** An instance of the following structure can be declared on a stack and usedÙI** to save the Parse.zAuthContext value so that it can be restored later.¢*/´struct AuthContext {ÙE  const char *zAuthContext;   /* Put saved Parse.zAuthContext here */Ù7  Parse *pParse;              /* The Parse structure */¢}; ¢/*Ù2** Bitfield flags for P5 value in various opcodes.¢**Ù-** Value constraints (enforced via assert()):Ù/**    OPFLAG_LENGTHARG    == SQLITE_FUNC_LENGTHÙ/**    OPFLAG_TYPEOFARG    == SQLITE_FUNC_TYPEOFÙ+**    OPFLAG_BULKCSR      == BTREE_BULKLOADÙ***    OPFLAG_SEEKEQ       == BTREE_SEEK_EQÙ,**    OPFLAG_FORDELETE    == BTREE_FORDELETEÙ/**    OPFLAG_SAVEPOSITION == BTREE_SAVEPOSITIONÙ,**    OPFLAG_AUXDELETE    == BTREE_AUXDELETE¢*/ÙO#define OPFLAG_NCHANGE       0x01    /* OP_Insert: Set to update db->nChange */ÙP                                     /* Also used in P2 (not P5) of OP_Delete */ÙL#define OPFLAG_EPHEM         0x01    /* OP_Column: Ephemeral output is ok */ÙF#define OPFLAG_LASTROWID     0x20    /* Set to update db->lastRowid */ÙJ#define OPFLAG_ISUPDATE      0x04    /* This OP_Insert is an sql UPDATE */ÙI#define OPFLAG_APPEND        0x08    /* This is likely to be an append */ÙO#define OPFLAG_USESEEKRESULT 0x10    /* Try to avoid a seek in BtreeInsert() */ÙN#define OPFLAG_ISNOOP        0x40    /* OP_Delete does pre-update-hook only */ÙK#define OPFLAG_LENGTHARG     0x40    /* OP_Column only used for length() */ÙK#define OPFLAG_TYPEOFARG     0x80    /* OP_Column only used for typeof() */ÙM#define OPFLAG_BULKCSR       0x01    /* OP_Open** used to open bulk cursor */ÙM#define OPFLAG_SEEKEQ        0x02    /* OP_Open** cursor uses EQ seek only */ÙM#define OPFLAG_FORDELETE     0x08    /* OP_Open should use BTREE_FORDELETE */ÙO#define OPFLAG_P2ISREG       0x10    /* P2 to OP_Open** is a register number */ÙJ#define OPFLAG_PERMUTE       0x01    /* OP_Compare: use the permutation */ÙL#define OPFLAG_SAVEPOSITION  0x02    /* OP_Delete/Insert: save cursor pos */ÙJ#define OPFLAG_AUXDELETE     0x04    /* OP_Delete: index in a DELETE op */ÙM#define OPFLAG_NOCHNG_MAGIC  0x6d    /* OP_MakeRecord: serialtype 10 is ok */ ¢/*ÙJ * Each trigger present in the database schema is stored as an instance of² * struct Trigger.¢ *ÙB * Pointers to instances of struct Trigger are stored in two ways.ÙL * 1. In the "trigHash" hash table (part of the sqlite3* that represents theÙH *    database). This allows Trigger structures to be retrieved by name.ÙO * 2. All triggers associated with a single table form a linked list, using theÙK *    pNext member of struct Trigger. A pointer to the first element of theÙF *    linked list is stored as the "pTrigger" member of the associated³ *    struct Table.¢ *ÙF * The "step_list" member points to the first element of a linked listÙB * containing the SQL statements specified as the trigger program.£ */°struct Trigger {ÙN  char *zName;            /* The name of the trigger                        */ÙN  char *table;            /* The table or view to which the trigger applies */ÙN  u8 op;                  /* One of TK_DELETE, TK_UPDATE, TK_INSERT         */ÙD  u8 tr_tm;               /* One of TRIGGER_BEFORE, TRIGGER_AFTER */ÙO  Expr *pWhen;            /* The WHEN clause of the expression (may be NULL) */ÙK  IdList *pColumns;       /* If this is an UPDATE OF <column-list> trigger,Ù@                             the <column-list> is stored here */Ù=  Schema *pSchema;        /* Schema containing the trigger */Ù;  Schema *pTabSchema;     /* Schema containing the table */ÙN  TriggerStep *step_list; /* Link list of trigger program steps             */ÙF  Trigger *pNext;         /* Next trigger associated with the table */¢}; ¢/*ÙM** A trigger is either a BEFORE or an AFTER trigger.  The following constants³** determine which.¢**ÙK** If there are multiple triggers, you might of some BEFORE and some AFTER.Ù;** In that cases, the constants below can be ORed together.¢*/¹#define TRIGGER_BEFORE  1¹#define TRIGGER_AFTER   2 ¢/*ÙL * An instance of struct TriggerStep is used to store a single SQL statementÙ' * that is a part of a trigger-program.¢ *ÙM * Instances of struct TriggerStep are stored in a singly linked list (linkedÙH * using the "pNext" member) referenced by the "step_list" member of theÙN * associated struct Trigger instance. The first element of the linked list isÙ) * the first step of the trigger-program.¢ *ÙN * The "op" member indicates whether this is a "DELETE", "INSERT", "UPDATE" orÙM * "SELECT" statement. The meanings of the other members is determined by the¼ * value of "op" as follows:¢ *´ * (op == TK_INSERT)Ù0 * orconf    -> stores the ON CONFLICT algorithmÙH * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, thenÙN *              this stores a pointer to the SELECT statement. Otherwise NULL.Ù: * zTarget   -> Dequoted name of the table to insert into.ÙH * pExprList -> If this is an INSERT INTO ... VALUES ... statement, thenÙB *              this stores values to be inserted. Otherwise NULL.ÙI * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ...ÙB *              statement, then this stores the column-names to be¾ *              inserted into.¢ *´ * (op == TK_DELETE)Ù: * zTarget   -> Dequoted name of the table to delete from.ÙM * pWhere    -> The WHERE clause of the DELETE statement if one is specified.¿ *              Otherwise NULL.¢ *´ * (op == TK_UPDATE)Ù5 * zTarget   -> Dequoted name of the table to update.ÙM * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.¿ *              Otherwise NULL.ÙM * pExprList -> A list of the columns to update and the expressions to updateÙH *              them to. See sqlite3Update() documentation of "pChanges"¹ *              argument.¢ *£ */´struct TriggerStep {ÙN  u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */Ù-  u8 orconf;           /* OE_Rollback etc. */ÙD  Trigger *pTrig;      /* The trigger that this step is a part of */ÙN  Select *pSelect;     /* SELECT statement or RHS of INSERT INTO SELECT ... */ÙD  char *zTarget;       /* Target table for DELETE, UPDATE, INSERT */ÙH  Expr *pWhere;        /* The WHERE clause for DELETE or UPDATE steps */Ù3  ExprList *pExprList; /* SET clause for UPDATE. */Ù4  IdList *pIdList;     /* Column names for INSERT */Ù>  char *zSpan;         /* Original SQL text of this command */Ù2  TriggerStep *pNext;  /* Next in the link-list */ÙO  TriggerStep *pLast;  /* Last element in link-list. Valid for 1st elem only */¢}; ¢/*ÙH** The following structure contains information used by the sqliteFix...ÙC** routines as they walk the parse tree to make database references¬** explicit.¢*/¿typedef struct DbFixer DbFixer;°struct DbFixer {ÙM  Parse *pParse;      /* The parsing context.  Error messages written here */Ù4  Schema *pSchema;    /* Fix items to this schema */Ù>  int bVarOnly;       /* Check for variable references only */ÙP  const char *zDb;    /* Make sure all objects are contained in this database */ÙK  const char *zType;  /* Type of the container - used for error messages */ÙK  const Token *pName; /* Name of the container - used for error messages */¢}; ¢/*Ù?** An objected used to accumulate the text of a string where weÙA** do not necessarily know how big the string will be in the end.¢*/±struct StrAccum {ÙJ  sqlite3 *db;         /* Optional database for lookaside.  Can be NULL */Ù8  char *zText;         /* The string collected so far */Ù?  u32  nAlloc;         /* Amount of space allocated in zText */ÙO  u32  mxAlloc;        /* Maximum allowed allocation.  0 for no malloc usage */Ù8  u32  nChar;          /* Length of the string so far */Ù>  u8   accError;       /* STRACCUM_NOMEM or STRACCUM_TOOBIG */Ù6  u8   printfFlags;    /* SQLITE_PRINTF flags below */¢};º#define STRACCUM_NOMEM   1º#define STRACCUM_TOOBIG  2ÙO#define SQLITE_PRINTF_INTERNAL 0x01  /* Internal-use-only converters allowed */ÙM#define SQLITE_PRINTF_SQLFUNC  0x02  /* SQL function arguments to VXPrintf */ÙK#define SQLITE_PRINTF_MALLOCED 0x04  /* True if xText is allocated space */ ÙG#define isMalloced(X)  (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)  ¢/*ÙA** A pointer to this structure is used to communicate informationÙD** from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.¢*/°typedef struct {Ù:  sqlite3 *db;        /* The database being initialized */Ù5  char **pzErrMsg;    /* Error message stored here */ÙN  int iDb;            /* 0 for main database.  1 for TEMP, 2.. for ATTACHed */Ù3  int rc;             /* Result code stored here */«} InitData; ¢/*ÙI** Structure containing global configuration data for the SQLite library.¢**Ù7** This structure also contains some state information.¢*/¶struct Sqlite3Config {ÙF  int bMemstat;                     /* True to enable memory status */ÙF  int bCoreMutex;                   /* True to enable core mutexing */ÙF  int bFullMutex;                   /* True to enable full mutexing */ÙM  int bOpenUri;                     /* True to interpret filenames as URIs */ÙM  int bUseCis;                      /* Use covering indices for full-scans */ÙP  int bSmallMalloc;                 /* Avoid large memory allocations if true */Ù?  int mxStrlen;                     /* Maximum string length */ÙH  int neverCorrupt;                 /* Database is always well-formed */ÙG  int szLookaside;                  /* Default lookaside buffer size */ÙH  int nLookaside;                   /* Default lookaside buffer count */ÙN  int nStmtSpill;                   /* Stmt-journal spill-to-disk threshold */ÙO  sqlite3_mem_methods m;            /* Low-level memory allocation interface */ÙC  sqlite3_mutex_methods mutex;      /* Low-level mutex interface */ÙH  sqlite3_pcache_methods2 pcache2;  /* Low-level page-cache interface */Ù<  void *pHeap;                      /* Heap storage space */Ù9  int nHeap;                        /* Size of pHeap[] */ÙI  int mnReq, mxReq;                 /* Min and max heap requests sizes */ÙD  sqlite3_int64 szMmap;             /* mmap() space per open file */ÙB  sqlite3_int64 mxMmap;             /* Maximum value for szMmap */Ù;  void *pPage;                      /* Page cache memory */ÙF  int szPage;                       /* Size of each page in pPage[] */ÙD  int nPage;                        /* Number of pages in pPage[] */ÙK  int mxParserStack;                /* maximum depth of the parser stack */ÙK  int sharedCacheEnabled;           /* true if shared-cache mode enabled */ÙA  u32 szPma;                        /* Maximum Sorter PMA size */ÙN  /* The above might be initialized to non-zero.  The following need to alwaysÙ#  ** initially be zero, however. */ÙP  int isInit;                       /* True after initialization has finished */ÙO  int inProgress;                   /* True while initialization in progress */ÙL  int isMutexInit;                  /* True after mutexes are initialized */ÙJ  int isMallocInit;                 /* True after malloc is initialized */ÙJ  int isPCacheInit;                 /* True after malloc is initialized */ÙG  int nRefInitMutex;                /* Number of users of pInitMutex */ÙL  sqlite3_mutex *pInitMutex;        /* Mutex used by sqlite3_initialize() */ÙA  void (*xLog)(void*,int,const char*); /* Function for logging */ÙE  void *pLogArg;                       /* First argument to xLog() */»#ifdef SQLITE_ENABLE_SQLLOGÙ2  void(*xSqllog)(void*,sqlite3*,const char*, int);³  void *pSqllogArg;¦#endif»#ifdef SQLITE_VDBE_COVERAGEÙI  /* The following callback (if not NULL) is invoked on every VDBE branchÙF  ** operation.  Set the callback using SQLITE_TESTCTRL_VDBE_COVERAGE.¤  */ÙJ  void (*xVdbeBranch)(void*,int iSrcLine,u8 eThis,u8 eMx);  /* Callback */ÙN  void *pVdbeBranchArg;                                     /* 1st argument */¦#endif¹#ifndef SQLITE_UNTESTABLEÙF  int (*xTestCallback)(int);        /* Invoked by sqlite3FaultSim() */¦#endifÙH  int bLocaltimeFault;              /* True to fail localtime() calls */ÙH  int iOnceResetThreshold;          /* When to reset OP_Once counters */¢}; ¢/*ÙD** This macro is used inside of assert() statements to indicate thatÙC** the assert is only valid on a well-formed database.  Instead of:¢**³**     assert( X );¢**®** One writes:¢**Ù!**     assert( X || CORRUPT_DB );¢**ÙL** CORRUPT_DB is true during normal operation.  CORRUPT_DB does not indicateÙJ** that the database is definitely corrupt, only that it might be corrupt.ÙB** For most test cases, CORRUPT_DB is set to false using a specialÙE** sqlite3_test_control().  This enables assert() statements to proveÙ9** things that are always true for well-formed databases.¢*/Ù3#define CORRUPT_DB  (sqlite3Config.neverCorrupt==0) ¢/*Ù5** Context pointer passed down through the tree-walk.¢*/¯struct Walker {ÙB  Parse *pParse;                            /* Parser context.  */ÙJ  int (*xExprCallback)(Walker*, Expr*);     /* Callback for expressions */ÙF  int (*xSelectCallback)(Walker*,Select*);  /* Callback for SELECTs */ÙM  void (*xSelectCallback2)(Walker*,Select*);/* Second callback for SELECTs */ÙF  int walkerDepth;                          /* Number of subqueries */ÙI  u8 eCode;                                 /* A small processing code */ÙI  union {                                   /* Extra data for callback */ÙB    NameContext *pNC;                         /* Naming context */Ù=    int n;                                    /* A counter */ÙC    int iCur;                                 /* A cursor number */Ù?    SrcList *pSrcList;                        /* FROM clause */ÙN    struct SrcCount *pSrcCount;               /* Counting column references */ÙL    struct CCurHint *pCCurHint;               /* Used by codeCursorHint() */ÙK    int *aiCol;                               /* array of column indexes */ÙL    struct IdxCover *pIdxCover;               /* Check for index coverage */ÙP    struct IdxExprTrans *pIdxTrans;           /* Convert idxed expr to column */ÙC    ExprList *pGroupBy;                       /* GROUP BY clause */ÙN    Select *pSelect;                          /* HAVING to WHERE clause ctx */¦  } u;¢}; º/* Forward declarations */Ù3SQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*);Ù;SQLITE_PRIVATE int sqlite3WalkExprList(Walker*, ExprList*);Ù7SQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*);Ù;SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*);Ù;SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*);Ù7SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker*, Expr*);Ù;SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker*, Select*);Ù;SQLITE_PRIVATE int sqlite3SelectWalkFail(Walker*, Select*);³#ifdef SQLITE_DEBUGÙ?SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker*, Select*);¦#endif ¢/*Ù?** Return code from the parse-tree walking primitives and their­** callbacks.¢*/Ù=#define WRC_Continue    0   /* Continue down into children */ÙM#define WRC_Prune       1   /* Omit children but continue walking siblings */Ù7#define WRC_Abort       2   /* Abandon the tree walk */ ¢/*ÙE** An instance of this structure represents a set of one or more CTEsÙ>** (common table expressions) created by a single WITH clause.¢*/­struct With {ÙI  int nCte;                       /* Number of CTEs in the WITH clause */ÙG  With *pOuter;                   /* Containing WITH clause, or NULL */ÙK  struct Cte {                    /* For each CTE in the WITH clause.... */Ù:    char *zName;                    /* Name of this CTE */ÙP    ExprList *pCols;                /* List of explicit column names, or NULL */ÙD    Select *pSelect;                /* The definition of this CTE */ÙO    const char *zCteErr;            /* Error message for circular references */©  } a[1];¢}; ³#ifdef SQLITE_DEBUG¢/*ÙI** An instance of the TreeView object is used for printing the content ofÙB** data structures on sqlite3DebugPrintf() using a tree-like view.¢*/±struct TreeView {ÙA  int iLevel;             /* Which level of the tree we are on */ÙM  u8  bLine[100];         /* Draw vertical in column i if bLine[i] is true */¢};¹#endif /* SQLITE_DEBUG */ ¢/*Ù>** Assuming zIn points to the first byte of a UTF-8 character,ÙF** advance zIn to point to the first byte of the next UTF-8 character.¢*/Ù8#define SQLITE_SKIP_UTF8(zIn) {                        \Ù8  if( (*(zIn++))>=0xc0 ){                              \Ù8    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \Ù8  }                                                    \¡} ¢/*ÙD** The SQLITE_*_BKPT macros are substitutes for the error codes withÙC** the same name but without the _BKPT suffix.  These macros invokeÙE** routines that report the line-number on which the error originatedÙE** using sqlite3_log().  The routines also provide a convenient placeÙ ** to set a debugger breakpoint.¢*/ÙOSQLITE_PRIVATE int sqlite3ReportError(int iErr, int lineno, const char *zType);Ù,SQLITE_PRIVATE int sqlite3CorruptError(int);Ù+SQLITE_PRIVATE int sqlite3MisuseError(int);Ù-SQLITE_PRIVATE int sqlite3CantopenError(int);Ù9#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)Ù7#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)Ù;#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)³#ifdef SQLITE_DEBUGÙ,SQLITE_PRIVATE   int sqlite3NomemError(int);Ù1SQLITE_PRIVATE   int sqlite3IoerrnomemError(int);Ù7SQLITE_PRIVATE   int sqlite3CorruptPgnoError(int,Pgno);Ù6# define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)ÙA# define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)ÙE# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))¥#elseÙ'# define SQLITE_NOMEM_BKPT SQLITE_NOMEMÙ3# define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEMÙ=# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)¦#endif ¢/*Ù3** FTS3 and FTS4 both require virtual table support¢*/Ù%#if defined(SQLITE_OMIT_VIRTUALTABLE)º# undef SQLITE_ENABLE_FTS3º# undef SQLITE_ENABLE_FTS4¦#endif ¢/*ÙA** FTS4 is really an extension for FTS3.  It is enabled using theÙA** SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also callÙL** the SQLITE_ENABLE_FTS4 macro to serve as an alias for SQLITE_ENABLE_FTS3.¢*/Ù?#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)½# define SQLITE_ENABLE_FTS3 1¦#endif ¢/*ÙB** The ctype.h header is needed for non-ASCII systems.  It is alsoÙ<** needed by FTS3 when FTS3 is included in the amalgamation.¢*/¿#if !defined(SQLITE_ASCII) || \ÙA    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))³# include <ctype.h>¦#endif ¢/*ÙG** The following macros mimic the standard library functions toupper(),ÙD** isspace(), isalnum(), isdigit() and isxdigit(), respectively. TheÙH** sqlite versions only work for ASCII characters, regardless of locale.¢*/³#ifdef SQLITE_ASCIIÙM# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))ÙG# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)ÙG# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)ÙG# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)ÙG# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)ÙG# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)ÙF# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])ÙG# define sqlite3Isquote(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x80)¥#elseÙ8# define sqlite3Toupper(x)   toupper((unsigned char)(x))Ù8# define sqlite3Isspace(x)   isspace((unsigned char)(x))Ù8# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))Ù8# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))Ù8# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))Ù9# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))Ù8# define sqlite3Tolower(x)   tolower((unsigned char)(x))ÙF# define sqlite3Isquote(x)   ((x)=='"'||(x)=='\''||(x)=='['||(x)=='`')¦#endifÙ'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSÙ'SQLITE_PRIVATE int sqlite3IsIdChar(u8);¦#endif ¢/*¿** Internal function prototypes¢*/Ù;SQLITE_PRIVATE int sqlite3StrICmp(const char*,const char*);Ù0SQLITE_PRIVATE int sqlite3Strlen30(const char*);Ù6SQLITE_PRIVATE char *sqlite3ColumnType(Column*,char*);Ù(#define sqlite3StrNICmp sqlite3_strnicmp Ù+SQLITE_PRIVATE int sqlite3MallocInit(void);Ù+SQLITE_PRIVATE void sqlite3MallocEnd(void);Ù(SQLITE_PRIVATE void *sqlite3Malloc(u64);Ù,SQLITE_PRIVATE void *sqlite3MallocZero(u64);Ù8SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, u64);Ù7SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, u64);Ù9SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3*, u64);Ù;SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*,const char*);ÙASQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, u64);ÙHSQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3*,const char*,const char*);Ù0SQLITE_PRIVATE void *sqlite3Realloc(void*, u64);ÙDSQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);Ù>SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, u64);Ù3SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*);Ù5SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3*, void*);Ù,SQLITE_PRIVATE int sqlite3MallocSize(void*);Ù8SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);Ù,SQLITE_PRIVATE void *sqlite3PageMalloc(int);Ù+SQLITE_PRIVATE void sqlite3PageFree(void*);Ù/SQLITE_PRIVATE void sqlite3MemSetDefault(void);¹#ifndef SQLITE_UNTESTABLEÙMSQLITE_PRIVATE void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));¦#endifÙ/SQLITE_PRIVATE int sqlite3HeapNearlyFull(void); ¢/*ÙD** On systems with ample stack space and that support alloca(), makeÙL** use of alloca() to obtain space for large automatic objects.  By default,¾** obtain space from malloc().¢**ÙG** The alloca() routine never returns NULL.  This will cause code pathsÙA** that deal with sqlite3StackAlloc() failures to be unreachable.¢*/¸#ifdef SQLITE_USE_ALLOCAÙ.# define sqlite3StackAllocRaw(D,N)   alloca(N)Ù<# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)¾# define sqlite3StackFree(D,P)¥#elseÙ<# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)Ù=# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)Ù7# define sqlite3StackFree(D,P)       sqlite3DbFree(D,P)¦#endif ÙI/* Do not allow both MEMSYS5 and MEMSYS3 to be defined together.  If they·** are, disable MEMSYS3¢*/¼#ifdef SQLITE_ENABLE_MEMSYS5ÙESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void);¼#undef SQLITE_ENABLE_MEMSYS3¦#endif¼#ifdef SQLITE_ENABLE_MEMSYS3ÙESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void);¦#endif  ¹#ifndef SQLITE_MUTEX_OMITÙHSQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3DefaultMutex(void);ÙESQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3NoopMutex(void);Ù7SQLITE_PRIVATE   sqlite3_mutex *sqlite3MutexAlloc(int);Ù,SQLITE_PRIVATE   int sqlite3MutexInit(void);Ù+SQLITE_PRIVATE   int sqlite3MutexEnd(void);¦#endifÙ>#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)Ù1SQLITE_PRIVATE   void sqlite3MemoryBarrier(void);¥#else¿# define sqlite3MemoryBarrier()¦#endif Ù5SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int);Ù.SQLITE_PRIVATE void sqlite3StatusUp(int, int);Ù0SQLITE_PRIVATE void sqlite3StatusDown(int, int);Ù5SQLITE_PRIVATE void sqlite3StatusHighwater(int, int);Ù7SQLITE_PRIVATE int sqlite3LookasideUsed(sqlite3*,int*); Ù0/* Access to mutexes used by sqlite3_status() */Ù8SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void);Ù7SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void); ÙN#if defined(SQLITE_ENABLE_MULTITHREADED_CHECKS) && !defined(SQLITE_MUTEX_OMIT)ÙASQLITE_PRIVATE void sqlite3MutexWarnOnContention(sqlite3_mutex*);¥#elseÙ(# define sqlite3MutexWarnOnContention(x)¦#endif Ù"#ifndef SQLITE_OMIT_FLOATING_POINTÙ*SQLITE_PRIVATE   int sqlite3IsNaN(double);¥#else»# define sqlite3IsNaN(X)  0¦#endif ¢/*ÙE** An instance of the following structure holds information about SQLÙH** functions arguments that are the parameters to the printf() function.¢*/¸struct PrintfArguments {Ù:  int nArg;                /* Total number of arguments */Ù@  int nUsed;               /* Number of arguments used so far */Ù4  sqlite3_value **apArg;   /* The argument values */¢}; ÙESQLITE_PRIVATE void sqlite3VXPrintf(StrAccum*, const char*, va_list);Ù@SQLITE_PRIVATE void sqlite3XPrintf(StrAccum*, const char*, ...);Ù?SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*,const char*, ...);ÙDSQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*,const char*, va_list);Ù:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)Ù;SQLITE_PRIVATE   void sqlite3DebugPrintf(const char*, ...);¦#endif¸#if defined(SQLITE_TEST)Ù9SQLITE_PRIVATE   void *sqlite3TestTextToPtr(const char*);¦#endif ¹#if defined(SQLITE_DEBUG)ÙFSQLITE_PRIVATE   void sqlite3TreeViewExpr(TreeView*, const Expr*, u8);Ù[SQLITE_PRIVATE   void sqlite3TreeViewBareExprList(TreeView*, const ExprList*, const char*);Ù[SQLITE_PRIVATE   void sqlite3TreeViewExprList(TreeView*, const ExprList*, u8, const char*);ÙJSQLITE_PRIVATE   void sqlite3TreeViewSelect(TreeView*, const Select*, u8);ÙFSQLITE_PRIVATE   void sqlite3TreeViewWith(TreeView*, const With*, u8);¦#endif  ÙESQLITE_PRIVATE void sqlite3SetString(char **, sqlite3*, const char*);Ù>SQLITE_PRIVATE void sqlite3ErrorMsg(Parse*, const char*, ...);Ù*SQLITE_PRIVATE void sqlite3Dequote(char*);Ù3SQLITE_PRIVATE void sqlite3TokenInit(Token*,char*);ÙASQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char*, int);ÙBSQLITE_PRIVATE int sqlite3RunParser(Parse*, const char*, char **);Ù0SQLITE_PRIVATE void sqlite3FinishCoding(Parse*);Ù-SQLITE_PRIVATE int sqlite3GetTempReg(Parse*);Ù6SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse*,int);Ù3SQLITE_PRIVATE int sqlite3GetTempRange(Parse*,int);Ù<SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse*,int,int);Ù5SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse*);³#ifdef SQLITE_DEBUGÙ9SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse*,int,int);¦#endifÙESQLITE_PRIVATE Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);Ù;SQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*,int,const char*);ÙJSQLITE_PRIVATE void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);Ù=SQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*);ÙBSQLITE_PRIVATE void sqlite3PExprAddSelect(Parse*, Expr*, Select*);Ù;SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*);ÙCSQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*);ÙCSQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);Ù7SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*);ÙGSQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);ÙUSQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);Ù?SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*,int);ÙHSQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);ÙUSQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);Ù?SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);Ù9SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList*);Ù1SQLITE_PRIVATE int sqlite3Init(sqlite3*, char**);ÙCSQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**);ÙCSQLITE_PRIVATE void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);Ù #ifndef SQLITE_OMIT_VIRTUALTABLEÙMSQLITE_PRIVATE Module *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);¦#endifÙASQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3*);Ù8SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3*,int);Ù;SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3*);Ù;SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*);Ù>SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3*,Table*);ÙNSQLITE_PRIVATE int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);ÙRSQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*);Ù?SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*);Ù9SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);Ù5SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table*);Ù5SQLITE_PRIVATE i16 sqlite3ColumnOfIndex(Index*, i16);ÙLSQLITE_PRIVATE void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);Ù #if SQLITE_ENABLE_HIDDEN_COLUMNSÙGSQLITE_PRIVATE   void sqlite3ColumnPropertiesFromName(Table*, Column*);¥#elseÙ9# define sqlite3ColumnPropertiesFromName(T,C) /* no-op */¦#endifÙ;SQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token*,Token*);Ù3SQLITE_PRIVATE void sqlite3AddNotNull(Parse*, int);ÙKSQLITE_PRIVATE void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);Ù=SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*);ÙQSQLITE_PRIVATE void sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);Ù:SQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*);ÙESQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);ÙISQLITE_PRIVATE int sqlite3ParseUri(const char*,const char*,unsigned int*,Ù2                    sqlite3_vfs**,char**,char **);ÙASQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3*,const char*); ¸#ifdef SQLITE_UNTESTABLEÙ%# define sqlite3FaultSim(X) SQLITE_OK¥#elseÙ*SQLITE_PRIVATE   int sqlite3FaultSim(int);¦#endif Ù0SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32);Ù3SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec*, u32);Ù:SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec*, u32);Ù2SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec*, u32);Ù<SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec*, u32, void*);Ù2SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec*);Ù.SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec*);¹#ifndef SQLITE_UNTESTABLEÙ6SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int,int*);¦#endif ÙHSQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3*, void*, unsigned int);Ù0SQLITE_PRIVATE void sqlite3RowSetClear(RowSet*);Ù6SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet*, i64);Ù?SQLITE_PRIVATE int sqlite3RowSetTest(RowSet*, int iBatch, i64);Ù4SQLITE_PRIVATE int sqlite3RowSetNext(RowSet*, i64*); Ù]SQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int); ÙD#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)Ù>SQLITE_PRIVATE   int sqlite3ViewGetColumnNames(Parse*,Table*);¥#elseÙ)# define sqlite3ViewGetColumnNames(A,B) 0¦#endif º#if SQLITE_MAX_ATTACHED>30Ù3SQLITE_PRIVATE   int sqlite3DbMaskAllZero(yDbMask);¦#endifÙASQLITE_PRIVATE void sqlite3DropTable(Parse*, SrcList*, int, int);ÙCSQLITE_PRIVATE void sqlite3CodeDropTable(Parse*, Table*, int, int);Ù9SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3*, Table*);Ù!#ifndef SQLITE_OMIT_AUTOINCREMENTÙ?SQLITE_PRIVATE   void sqlite3AutoincrementBegin(Parse *pParse);Ù=SQLITE_PRIVATE   void sqlite3AutoincrementEnd(Parse *pParse);¥#elseÙ%# define sqlite3AutoincrementBegin(X)Ù## define sqlite3AutoincrementEnd(X)¦#endifÙKSQLITE_PRIVATE void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int);ÙHSQLITE_PRIVATE void *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);ÙFSQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*);Ù;SQLITE_PRIVATE int sqlite3IdListIndex(IdList*,const char*);ÙLSQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int);ÙQSQLITE_PRIVATE SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*);ÙVSQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,ÙG                                      Token*, Select*, Expr*, IdList*);ÙISQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);ÙHSQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);ÙJSQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);Ù:SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*);ÙBSQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*);Ù;SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3*, IdList*);Ù=SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3*, SrcList*);ÙJSQLITE_PRIVATE Index *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**);ÙZSQLITE_PRIVATE void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,Ù/                          Expr*, int, int, u8);Ù<SQLITE_PRIVATE void sqlite3DropIndex(Parse*, SrcList*, int);Ù?SQLITE_PRIVATE int sqlite3Select(Parse*, Select*, SelectDest*);ÙRSQLITE_PRIVATE Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,Ù4                         Expr*,ExprList*,u32,Expr*);Ù;SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3*, Select*);Ù=SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse*, SrcList*);Ù:SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int);ÙMSQLITE_PRIVATE void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);ÙP#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)ÙTSQLITE_PRIVATE Expr *sqlite3LimitWhere(Parse*,SrcList*,Expr*,ExprList*,Expr*,char*);¦#endifÙQSQLITE_PRIVATE void sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*);ÙYSQLITE_PRIVATE void sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*);Ù_SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,ExprList*,u16,int);Ù0SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo*);Ù=SQLITE_PRIVATE LogEst sqlite3WhereOutputRowCount(WhereInfo*);Ù6SQLITE_PRIVATE int sqlite3WhereIsDistinct(WhereInfo*);Ù5SQLITE_PRIVATE int sqlite3WhereIsOrdered(WhereInfo*);Ù<SQLITE_PRIVATE int sqlite3WhereOrderedInnerLoop(WhereInfo*);Ù4SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo*);Ù9SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo*);Ù6SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo*);Ù;SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo*, int*);ÙB#define ONEPASS_OFF      0        /* Use of ONEPASS not allowed */ÙM#define ONEPASS_SINGLE   1        /* ONEPASS valid for a single row update */ÙJ#define ONEPASS_MULTI    2        /* ONEPASS is valid for multiple rows */ÙRSQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);ÙOSQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);ÙQSQLITE_PRIVATE void sqlite3ExprCodeGetColumnToReg(Parse*, Table*, int, int, int);ÙRSQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);Ù?SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int);ÙASQLITE_PRIVATE void sqlite3ExprCacheStore(Parse*, int, int, int);Ù1SQLITE_PRIVATE void sqlite3ExprCachePush(Parse*);Ù0SQLITE_PRIVATE void sqlite3ExprCachePop(Parse*);Ù=SQLITE_PRIVATE void sqlite3ExprCacheRemove(Parse*, int, int);Ù2SQLITE_PRIVATE void sqlite3ExprCacheClear(Parse*);ÙESQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse*, int, int);Ù8SQLITE_PRIVATE void sqlite3ExprCode(Parse*, Expr*, int);Ù<SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, Expr*, int);ÙBSQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse*, Expr*, int);Ù=SQLITE_PRIVATE int sqlite3ExprCodeAtInit(Parse*, Expr*, int);Ù<SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*);Ù=SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int);Ù@SQLITE_PRIVATE void sqlite3ExprCodeAndCache(Parse*, Expr*, int);ÙLSQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);ÙA#define SQLITE_ECEL_DUP      0x01  /* Deep, not shallow copies */ÙB#define SQLITE_ECEL_FACTOR   0x02  /* Factor out constant terms */ÙE#define SQLITE_ECEL_REF      0x04  /* Use ExprList.u.x.iOrderByCol */ÙI#define SQLITE_ECEL_OMITREF  0x08  /* Omit if ExprList.u.x.iOrderByCol */Ù?SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int);Ù@SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int);ÙCSQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);ÙJSQLITE_PRIVATE Table *sqlite3FindTable(sqlite3*,const char*, const char*);»#define LOCATE_VIEW    0x01»#define LOCATE_NOERR   0x02ÙTSQLITE_PRIVATE Table *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*);ÙUSQLITE_PRIVATE Table *sqlite3LocateTableItem(Parse*,u32 flags,struct SrcList_item *);ÙJSQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3*,const char*, const char*);ÙJSQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);ÙJSQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);Ù1SQLITE_PRIVATE void sqlite3Vacuum(Parse*,Token*);Ù;SQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*, int);Ù<SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*);Ù@SQLITE_PRIVATE int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);Ù=SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*, Expr*, int);ÙESQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);ÙDSQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);Ù;SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int);ÙFSQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);ÙFSQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);ÙKSQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);Ù?SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr*, SrcList*);Ù,SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*);¹#ifndef SQLITE_UNTESTABLEÙ/SQLITE_PRIVATE void sqlite3PrngSaveState(void);Ù2SQLITE_PRIVATE void sqlite3PrngRestoreState(void);¦#endifÙ5SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*,int);Ù9SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int);ÙJSQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);Ù9SQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int);Ù6SQLITE_PRIVATE void sqlite3EndTransaction(Parse*,int);Ù:SQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*);Ù6SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *);Ù>SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3*);Ù3SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr*);Ù6SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr*);Ù0SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);Ù7SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);Ù>SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*, u8);ÙLSQLITE_PRIVATE int sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);Ù9SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr*,int);Ù!#ifdef SQLITE_ENABLE_CURSOR_HINTSÙ6SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr*);¦#endifÙ5SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*);Ù5SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr*);ÙGSQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);Ù/SQLITE_PRIVATE int sqlite3IsRowid(const char*);Ù-SQLITE_PRIVATE void sqlite3GenerateRowDelete(Ù9    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);ÙWSQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);Ù[SQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);Ù;SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse*,int);ÙWSQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,Ù:                                     u8,u8,int,int*,int*);¾#ifdef SQLITE_ENABLE_NULL_TRIMÙ;SQLITE_PRIVATE   void sqlite3SetMakeRecordP5(Vdbe*,Table*);¥#elseÙ$# define sqlite3SetMakeRecordP5(A,B)¦#endifÙYSQLITE_PRIVATE void sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int);Ù]SQLITE_PRIVATE int sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);ÙASQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse*, int, int);Ù.SQLITE_PRIVATE void sqlite3MultiWrite(Parse*);Ù,SQLITE_PRIVATE void sqlite3MayAbort(Parse*);ÙKSQLITE_PRIVATE void sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);ÙASQLITE_PRIVATE void sqlite3UniqueConstraint(Parse*, int, Index*);Ù@SQLITE_PRIVATE void sqlite3RowidConstraint(Parse*, int, Table*);Ù8SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,Expr*,int);ÙDSQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);ÙASQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);Ù:SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,IdList*);Ù>SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,Select*,int);·#if SELECTTRACE_ENABLEDÙ>SQLITE_PRIVATE void sqlite3SelectSetName(Select*,const char*);¥#elseÙ"# define sqlite3SelectSetName(A,B)¦#endifÙ<SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(FuncDef*,int);ÙLSQLITE_PRIVATE FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8);Ù:SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(void);Ù;SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void);ÙKSQLITE_PRIVATE void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);Ù2SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3*);Ù8SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3*);Ù5SQLITE_PRIVATE void sqlite3ChangeCookie(Parse*, int); Ù?#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)ÙWSQLITE_PRIVATE void sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);¦#endif »#ifndef SQLITE_OMIT_TRIGGERÙYSQLITE_PRIVATE   void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,Ù+                           Expr*,int, int);ÙISQLITE_PRIVATE   void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);Ù@SQLITE_PRIVATE   void sqlite3DropTrigger(Parse*, SrcList*, int);Ù>SQLITE_PRIVATE   void sqlite3DropTriggerPtr(Parse*, Trigger*);Ù\SQLITE_PRIVATE   Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);Ù?SQLITE_PRIVATE   Trigger *sqlite3TriggerList(Parse *, Table *);Ù\SQLITE_PRIVATE   void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,Ù+                            int, int, int);Ù^SQLITE_PRIVATE   void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);ÙA  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);ÙGSQLITE_PRIVATE   void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);ÙHSQLITE_PRIVATE   TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,ÙA                                        const char*,const char*);ÙPSQLITE_PRIVATE   TriggerStep *sqlite3TriggerInsertStep(sqlite3*,Token*, IdList*,ÙL                                        Select*,u8,const char*,const char*);Ù\SQLITE_PRIVATE   TriggerStep *sqlite3TriggerUpdateStep(sqlite3*,Token*,ExprList*, Expr*, u8,ÙA                                        const char*,const char*);ÙNSQLITE_PRIVATE   TriggerStep *sqlite3TriggerDeleteStep(sqlite3*,Token*, Expr*,ÙA                                        const char*,const char*);Ù?SQLITE_PRIVATE   void sqlite3DeleteTrigger(sqlite3*, Trigger*);ÙNSQLITE_PRIVATE   void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);ÙYSQLITE_PRIVATE   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);ÙH# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))Ù1# define sqlite3IsToplevel(p) ((p)->pToplevel==0)¥#elseÙ*# define sqlite3TriggersExist(B,C,D,E,F) 0Ù"# define sqlite3DeleteTrigger(A,B)Ù## define sqlite3DropTriggerPtr(A,B)Ù-# define sqlite3UnlinkAndDeleteTrigger(A,B,C)Ù1# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)Ù1# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)Ù## define sqlite3TriggerList(X, Y) 0Ù"# define sqlite3ParseToplevel(p) p¿# define sqlite3IsToplevel(p) 1Ù/# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0¦#endif ÙCSQLITE_PRIVATE int sqlite3JoinType(Parse*, Token*, Token*, Token*);ÙWSQLITE_PRIVATE void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);Ù8SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse*, int);Ù!#ifndef SQLITE_OMIT_AUTHORIZATIONÙESQLITE_PRIVATE   void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);ÙYSQLITE_PRIVATE   int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);ÙPSQLITE_PRIVATE   void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);Ù:SQLITE_PRIVATE   void sqlite3AuthContextPop(AuthContext*);ÙQSQLITE_PRIVATE   int sqlite3AuthReadCol(Parse*, const char *, const char *, int);¥#elseÙ!# define sqlite3AuthRead(a,b,c,d)Ù1# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OKÙ&# define sqlite3AuthContextPush(a,b,c)Ù.# define sqlite3AuthContextPop(a)  ((void)(a))¦#endifÙ?SQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);Ù1SQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*);ÙUSQLITE_PRIVATE void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);Ù9SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*);Ù7SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*);Ù3SQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*);Ù;SQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*);ÙASQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);Ù@SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8);Ù7SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);Ù,SQLITE_PRIVATE int sqlite3Atoi(const char*);¹#ifndef SQLITE_OMIT_UTF16ÙESQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);¦#endifÙDSQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);Ù/SQLITE_PRIVATE u32 sqlite3Utf8Read(const u8**);Ù)SQLITE_PRIVATE LogEst sqlite3LogEst(u64);Ù6SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst,LogEst);Ù #ifndef SQLITE_OMIT_VIRTUALTABLEÙ6SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);¦#endifÙ/#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \Ù.    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \Ù*    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)Ù.SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);¦#endifÙKSQLITE_PRIVATE VList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);Ù=SQLITE_PRIVATE const char *sqlite3VListNumToName(VList*,int);ÙASQLITE_PRIVATE int sqlite3VListNameToNum(VList*,const char*,int); ¢/*ÙF** Routines to read and write variable-length integers.  These used toÙG** be defined locally, but now we use the varint routines in the util.c¨** file.¢*/Ù9SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64);ÙASQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, u64 *);ÙCSQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *, u32 *);Ù+SQLITE_PRIVATE int sqlite3VarintLen(u64 v); ¢/*ÙG** The common case is for a varint to be a single byte.  They followingÙH** macros handle the common case without a procedure call, but then callÙ$** the procedure for larger varints.¢*/»#define getVarint32(A,B)  \ÙM  (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))»#define putVarint32(A,B)  \Ù9  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\¼  sqlite3PutVarint((A),(B)))Ù%#define getVarint    sqlite3GetVarintÙ%#define putVarint    sqlite3PutVarint  ÙESQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3*, Index*);Ù=SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe*, Table*, int);ÙCSQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2);ÙJSQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);Ù;SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table*,int);Ù5SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr);Ù=SQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*, int, u8);Ù;SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char*, i64*);ÙHSQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);Ù/SQLITE_PRIVATE void sqlite3Error(sqlite3*,int);Ù5SQLITE_PRIVATE void sqlite3SystemError(sqlite3*,int);ÙFSQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n);Ù)SQLITE_PRIVATE u8 sqlite3HexToInt(int h);ÙKSQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **); Ù!#if defined(SQLITE_NEED_ERR_NAME)Ù/SQLITE_PRIVATE const char *sqlite3ErrName(int);¦#endif Ù #ifdef SQLITE_ENABLE_DESERIALIZEÙ*SQLITE_PRIVATE int sqlite3MemdbInit(void);¦#endif Ù.SQLITE_PRIVATE const char *sqlite3ErrStr(int);Ù4SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);ÙMSQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);ÙNSQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);ÙGSQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);ÙISQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);Ù?SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);ÙYSQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);ÙKSQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);Ù3SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*);Ù;SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);ÙASQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *);Ù:SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);Ù-SQLITE_PRIVATE int sqlite3AddInt64(i64*,i64);Ù-SQLITE_PRIVATE int sqlite3SubInt64(i64*,i64);Ù-SQLITE_PRIVATE int sqlite3MulInt64(i64*,i64);Ù(SQLITE_PRIVATE int sqlite3AbsInt32(int);¾#ifdef SQLITE_ENABLE_8_3_NAMESÙ;SQLITE_PRIVATE void sqlite3FileSuffix3(const char*, char*);¥#elseÙ # define sqlite3FileSuffix3(X,Y)¦#endifÙ6SQLITE_PRIVATE u8 sqlite3GetBoolean(const char *z,u8); Ù@SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8);Ù9SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8);ÙLSQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,Ù(                        void(*)(void*));Ù8SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value*);Ù5SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);Ù9SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);¹#ifndef SQLITE_OMIT_UTF16ÙFSQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);¦#endifÙUSQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);ÙGSQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);»#ifndef SQLITE_AMALGAMATIONÙ;SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[];Ù-SQLITE_PRIVATE const char sqlite3StrBINARY[];Ù9SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[];Ù5SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[];Ù.SQLITE_PRIVATE const Token sqlite3IntTokens[];Ù=SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config;Ù3SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;·#ifndef SQLITE_OMIT_WSDÙ&SQLITE_PRIVATE int sqlite3PendingByte;¦#endif¦#endif³#ifdef VDBE_PROFILEÙ1SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt;¦#endifÙBSQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, int, int);Ù;SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*);Ù0SQLITE_PRIVATE void sqlite3AlterFunctions(void);ÙFSQLITE_PRIVATE void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);ÙASQLITE_PRIVATE int sqlite3GetToken(const unsigned char *, int *);ÙASQLITE_PRIVATE void sqlite3NestedParse(Parse*, const char*, ...);Ù>SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3*);ÙBSQLITE_PRIVATE int sqlite3CodeSubselect(Parse*, Expr *, int, int);ÙESQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*);ÙNSQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);Ù\SQLITE_PRIVATE int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);Ù@SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*);ÙHSQLITE_PRIVATE int sqlite3ResolveExprListNames(NameContext*, ExprList*);ÙMSQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);ÙSSQLITE_PRIVATE void sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);ÙWSQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);ÙDSQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *, Table *, int, int);ÙBSQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *, Token *);ÙCSQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *, SrcList *);ÙNSQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);Ù:SQLITE_PRIVATE char sqlite3AffinityType(const char*, u8*);Ù;SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*);ÙISQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);Ù3SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*);Ù>SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *);Ù9SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB);Ù?SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3*,Index*);Ù1SQLITE_PRIVATE void sqlite3DefaultRowEst(Index*);Ù@SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3*, int);ÙDSQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);Ù/SQLITE_PRIVATE void sqlite3SchemaClear(void *);Ù<SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *, Btree *);Ù?SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *);Ù>SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);Ù2SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo*);Ù4SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo*);Ù>SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);³#ifdef SQLITE_DEBUGÙ7SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo*);¦#endifÙOSQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,Ù2  void (*)(sqlite3_context*,int,sqlite3_value **),ÙN  void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*),½  FuncDestructor *pDestructor¢);Ù.SQLITE_PRIVATE void sqlite3OomFault(sqlite3*);Ù.SQLITE_PRIVATE void sqlite3OomClear(sqlite3*);Ù4SQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int);Ù4SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *); ÙNSQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);ÙESQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum*,const char*,int);ÙDSQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum*,const char*);Ù:SQLITE_PRIVATE void sqlite3AppendChar(StrAccum*,int,char);Ù6SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum*);Ù4SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum*);Ù?SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest*,int,int);ÙMSQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int); Ù;SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *);ÙLSQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *); ¼#ifndef SQLITE_OMIT_SUBQUERYÙ5SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse*, Expr*);¥#elseÙ*# define sqlite3ExprCheckIN(x,y) SQLITE_OK¦#endif Ù##ifdef SQLITE_ENABLE_STAT3_OR_STAT4Ù2SQLITE_PRIVATE void sqlite3AnalyzeFunctions(void);Ù-SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(Ù7    Parse*,Index*,UnpackedRecord**,Expr*,int,int,int*);ÙQSQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**);Ù;SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord*);ÙXSQLITE_PRIVATE int sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**);ÙFSQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3*, Index*, int);¦#endif ¢/*Ù.** The interface to the LEMON-generated parser¢*/»#ifndef SQLITE_AMALGAMATIONÙ9SQLITE_PRIVATE   void *sqlite3ParserAlloc(void*(*)(u64));Ù?SQLITE_PRIVATE   void sqlite3ParserFree(void*, void(*)(void*));¦#endifÙ=SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);»#ifdef YYTRACKMAXSTACKDEPTHÙ3SQLITE_PRIVATE   int sqlite3ParserStackPeak(void*);¦#endif Ù8SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3*);Ù"#ifndef SQLITE_OMIT_LOAD_EXTENSIONÙ7SQLITE_PRIVATE   void sqlite3CloseExtensions(sqlite3*);¥#elseÙ"# define sqlite3CloseExtensions(X)¦#endif Ù #ifndef SQLITE_OMIT_SHARED_CACHEÙLSQLITE_PRIVATE   void sqlite3TableLock(Parse *, int, int, u8, const char *);¥#elseÙ%  #define sqlite3TableLock(v,w,x,y,z)¦#endif ²#ifdef SQLITE_TESTÙ4SQLITE_PRIVATE   int sqlite3Utf8To8(unsigned char*);¦#endif ¿#ifdef SQLITE_OMIT_VIRTUALTABLE½#  define sqlite3VtabClear(Y)Ù(#  define sqlite3VtabSync(X,Y) SQLITE_OKÙ #  define sqlite3VtabRollback(X)¾#  define sqlite3VtabCommit(X)Ù!#  define sqlite3VtabInSync(db) 0¼#  define sqlite3VtabLock(X)¾#  define sqlite3VtabUnlock(X)Ù"#  define sqlite3VtabUnlockList(X)Ù1#  define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OKÙ-#  define sqlite3GetVTable(X,Y)  ((VTable*)0)¥#elseÙ=SQLITE_PRIVATE    void sqlite3VtabClear(sqlite3 *db, Table*);ÙDSQLITE_PRIVATE    void sqlite3VtabDisconnect(sqlite3 *db, Table *p);Ù:SQLITE_PRIVATE    int sqlite3VtabSync(sqlite3 *db, Vdbe*);Ù7SQLITE_PRIVATE    int sqlite3VtabRollback(sqlite3 *db);Ù5SQLITE_PRIVATE    int sqlite3VtabCommit(sqlite3 *db);Ù1SQLITE_PRIVATE    void sqlite3VtabLock(VTable *);Ù3SQLITE_PRIVATE    void sqlite3VtabUnlock(VTable *);Ù7SQLITE_PRIVATE    void sqlite3VtabUnlockList(sqlite3*);Ù@SQLITE_PRIVATE    int sqlite3VtabSavepoint(sqlite3 *, int, int);ÙESQLITE_PRIVATE    void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);Ù=SQLITE_PRIVATE    VTable *sqlite3GetVTable(sqlite3*, Table*);Ù2SQLITE_PRIVATE    Module *sqlite3VtabCreateModule(®     sqlite3*,±     const char*,»     const sqlite3_module*,«     void*,³     void(*)(void*)¥   );ÙE#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)¦#endifÙASQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse*,Module*);ÙESQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3*,Module*);Ù;SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*);ÙOSQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);Ù;SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*);Ù/SQLITE_PRIVATE void sqlite3VtabArgInit(Parse*);Ù9SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse*, Token*);ÙOSQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);Ù:SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse*, Table*);ÙGSQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3*, int, const char *);Ù9SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *, VTable *);ÙYSQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);ÙQSQLITE_PRIVATE void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**);ÙFSQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);ÙFSQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);ÙKSQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);Ù/SQLITE_PRIVATE void sqlite3ParserReset(Parse*);Ù+SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*);ÙOSQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);ÙMSQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);Ù7SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3*);Ù7SQLITE_PRIVATE const char *sqlite3JournalModename(int);·#ifndef SQLITE_OMIT_WALÙGSQLITE_PRIVATE   int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);ÙKSQLITE_PRIVATE   int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);¦#endif·#ifndef SQLITE_OMIT_CTEÙMSQLITE_PRIVATE   With *sqlite3WithAdd(Parse*,With*,Token*,ExprList*,Select*);Ù8SQLITE_PRIVATE   void sqlite3WithDelete(sqlite3*,With*);Ù9SQLITE_PRIVATE   void sqlite3WithPush(Parse*, With*, u8);¥#else¾#define sqlite3WithPush(x,y,z)¾#define sqlite3WithDelete(x,y)¦#endif ÙE/* Declarations for functions in fkey.c. All of these are replaced byÙG** no-op macros if OMIT_FOREIGN_KEY is defined. In this case no foreignÙA** key functionality is available. If OMIT_TRIGGER is defined butÙF** OMIT_FOREIGN_KEY is not, only some of the functions are no-oped. InÙC** this case foreign keys are parsed, but no other functionality isÙM** provided (enforcement of FK constraints requires the triggers sub-system).¢*/ÙF#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)ÙJSQLITE_PRIVATE   void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);ÙDSQLITE_PRIVATE   void sqlite3FkDropTable(Parse*, SrcList *, Table*);ÙRSQLITE_PRIVATE   void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);ÙBSQLITE_PRIVATE   int sqlite3FkRequired(Parse*, Table*, int*, int);Ù6SQLITE_PRIVATE   u32 sqlite3FkOldmask(Parse*, Table*);Ù4SQLITE_PRIVATE   FKey *sqlite3FkReferences(Table *);¥#elseÙ'  #define sqlite3FkActions(a,b,c,d,e,f)Ù%  #define sqlite3FkCheck(a,b,c,d,e,f)Ù#  #define sqlite3FkDropTable(a,b,c)Ù)  #define sqlite3FkOldmask(a,b)         0Ù)  #define sqlite3FkRequired(a,b,c,d)    0Ù)  #define sqlite3FkReferences(a)        0¦#endif¿#ifndef SQLITE_OMIT_FOREIGN_KEYÙ9SQLITE_PRIVATE   void sqlite3FkDelete(sqlite3 *, Table*);ÙMSQLITE_PRIVATE   int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);¥#else¾  #define sqlite3FkDelete(a,b)Ù)  #define sqlite3FkLocateIndex(a,b,c,d,e)¦#endif  ¢/*ÙC** Available fault injectors.  Should be numbered beginning with 0.¢*/Ù)#define SQLITE_FAULTINJECTOR_MALLOC     0Ù)#define SQLITE_FAULTINJECTOR_COUNT      1 ¢/*ÙE** The interface to the code in fault.c used for identifying "benign"Ù=** malloc failures. This is only present if SQLITE_UNTESTABLE²** is not defined.¢*/¹#ifndef SQLITE_UNTESTABLEÙ5SQLITE_PRIVATE   void sqlite3BeginBenignMalloc(void);Ù3SQLITE_PRIVATE   void sqlite3EndBenignMalloc(void);¥#elseÙ$  #define sqlite3BeginBenignMalloc()Ù"  #define sqlite3EndBenignMalloc()¦#endif ¢/*Ù2** Allowed return values from sqlite3FindInIndex()¢*/ÙE#define IN_INDEX_ROWID        1   /* Search the rowid of the table */ÙB#define IN_INDEX_EPH          2   /* Search an ephemeral b-tree */Ù@#define IN_INDEX_INDEX_ASC    3   /* Existing index ASCENDING */ÙA#define IN_INDEX_INDEX_DESC   4   /* Existing index DESCENDING */ÙK#define IN_INDEX_NOOP         5   /* No table available. Use comparisons */¢/*Ù?** Allowed flags for the 3rd parameter to sqlite3FindInIndex().¢*/ÙE#define IN_INDEX_NOOP_OK     0x0001  /* OK to return IN_INDEX_NOOP */ÙO#define IN_INDEX_MEMBERSHIP  0x0002  /* IN operator used for membership test */ÙE#define IN_INDEX_LOOP        0x0004  /* IN operator used as a loop */ÙHSQLITE_PRIVATE int sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*); Ù]SQLITE_PRIVATE int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);Ù5SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *);Ù)#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \Ù- || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ù:SQLITE_PRIVATE   int sqlite3JournalCreate(sqlite3_file *);¦#endif Ù=SQLITE_PRIVATE int sqlite3JournalIsInMemory(sqlite3_file *p);Ù:SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *); ÙISQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);»#if SQLITE_MAX_EXPR_DEPTH>0Ù7SQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);Ù9SQLITE_PRIVATE   int sqlite3ExprCheckHeight(Parse*, int);¥#elseÙ&  #define sqlite3SelectExprHeight(x) 0Ù%  #define sqlite3ExprCheckHeight(x,y)¦#endif Ù.SQLITE_PRIVATE u32 sqlite3Get4byte(const u8*);Ù.SQLITE_PRIVATE void sqlite3Put4byte(u8*, u32); Ù"#ifdef SQLITE_ENABLE_UNLOCK_NOTIFYÙESQLITE_PRIVATE   void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);Ù=SQLITE_PRIVATE   void sqlite3ConnectionUnlocked(sqlite3 *db);Ù;SQLITE_PRIVATE   void sqlite3ConnectionClosed(sqlite3 *db);¥#elseÙ'  #define sqlite3ConnectionBlocked(x,y)Ù&  #define sqlite3ConnectionUnlocked(x)Ù$  #define sqlite3ConnectionClosed(x)¦#endif ³#ifdef SQLITE_DEBUGÙ8SQLITE_PRIVATE   void sqlite3ParserTrace(FILE*, char *);¦#endif·#if defined(YYCOVERAGE)Ù2SQLITE_PRIVATE   int sqlite3ParserCoverage(FILE*);¦#endif ¢/*Ù?** If the SQLITE_ENABLE IOTRACE exists then the global variableÙ?** sqlite3IoTrace is a pointer to a printf-like routine used to¾** print I/O tracing messages.¢*/¼#ifdef SQLITE_ENABLE_IOTRACEÙ># define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }Ù3SQLITE_PRIVATE   void sqlite3VdbeIOTraceSql(Vdbe*);ÙNSQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);¥#else³# define IOTRACE(A)Ù!# define sqlite3VdbeIOTraceSql(X)¦#endif ¢/*ÙI** These routines are available for the mem2.c debugging memory allocatorÙB** only.  They are used to verify that different "types" of memoryÙ2** allocations are properly tracked by the system.¢**ÙF** sqlite3MemdebugSetType() sets the "type" of an allocation to one ofÙG** the MEMTYPE_* macros defined below.  The type must be a bitmask with´** a single bit set.¢**ÙI** sqlite3MemdebugHasType() returns true if any of the bits in its secondÙH** argument match the type set by the previous sqlite3MemdebugSetType().ÙK** sqlite3MemdebugHasType() is intended for use inside assert() statements.¢**ÙI** sqlite3MemdebugNoType() returns true if none of the bits in its secondÙH** argument match the type set by the previous sqlite3MemdebugSetType().¢**ÙJ** Perhaps the most important point is the difference between MEMTYPE_HEAPÙL** and MEMTYPE_LOOKASIDE.  If an allocation is MEMTYPE_LOOKASIDE, that meansÙG** it might have been allocated by lookaside, except the allocation wasÙF** too large or lookaside was already full.  It is important to verifyÙG** that allocations that might have been satisfied by lookaside are notÙE** passed back to non-lookaside free() routines.  Asserts such as theÙJ** example above are placed on the non-lookaside free() routines to verify³** this constraint.¢**ÙC** All of this is no-op for a production build.  It only comes intoÙ=** play when the SQLITE_MEMDEBUG compile-time option is used.¢*/¶#ifdef SQLITE_MEMDEBUGÙ7SQLITE_PRIVATE   void sqlite3MemdebugSetType(void*,u8);Ù6SQLITE_PRIVATE   int sqlite3MemdebugHasType(void*,u8);Ù5SQLITE_PRIVATE   int sqlite3MemdebugNoType(void*,u8);¥#elseÙ1# define sqlite3MemdebugSetType(X,Y)  /* no-op */Ù'# define sqlite3MemdebugHasType(X,Y)  1Ù'# define sqlite3MemdebugNoType(X,Y)   1¦#endifÙ?#define MEMTYPE_HEAP       0x01  /* General heap allocations */ÙJ#define MEMTYPE_LOOKASIDE  0x02  /* Heap that might have been lookaside */Ù=#define MEMTYPE_PCACHE     0x04  /* Page cache allocations */ ¢/*¶** Threading interface¢*/¿#if SQLITE_MAX_WORKER_THREADS>0ÙMSQLITE_PRIVATE int sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*);Ù<SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread*, void**);¦#endif Ù>#if defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)Ù3SQLITE_PRIVATE int sqlite3DbpageRegister(sqlite3*);¦#endifÙ>#if defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)Ù3SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3*);¦#endif Ù6SQLITE_PRIVATE int sqlite3ExprVectorSize(Expr *pExpr);Ù4SQLITE_PRIVATE int sqlite3ExprIsVector(Expr *pExpr);Ù;SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr*, int);ÙASQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*,Expr*,int);Ù9SQLITE_PRIVATE void sqlite3VectorErrorMsg(Parse*, Expr*); Ù'#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSÙ>SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt);¦#endif ¸#endif /* SQLITEINT_H */ ÙO/************** End of sqliteInt.h *******************************************/ÙO/************** Begin file global.c ******************************************/¢/*¯** 2008 June 13¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙD** This file contains definitions of global variables and constants.¢*/¼/* #include "sqliteInt.h" */ ÙE/* An array to map all upper-case characters into their corresponding¹** lower-case character. ¢**ÙD** SQLite only considers US-ASCII (or EBCDIC) characters.  We do notÙE** handle case conversions for the UTF character set since the tablesÙ;** involved are nearly as big or bigger than SQLite itself.¢*/Ù<SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {³#ifdef SQLITE_ASCIIÙL      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,ÙL     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,ÙL     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,ÙL     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,ÙL    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,ÙL    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,ÙL    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,ÙL    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,ÙL    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,ÙL    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,ÙL    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,ÙL    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,ÙL    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,ÙL    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,³    252,253,254,255¦#endif´#ifdef SQLITE_EBCDICÙM      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */ÙM     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */ÙM     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */ÙM     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */ÙM     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */ÙM     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */ÙM     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111, /* 6x */ÙM    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127, /* 7x */ÙM    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */ÙM    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159, /* 9x */ÙM    160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */ÙM    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */ÙM    192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */ÙM    208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */ÙM    224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239, /* Ex */ÙM    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, /* Fx */¦#endif¢}; ¢/*ÙJ** The following 256 byte lookup table is used to support SQLites built-inÙ;** equivalents to the following standard library functions:¢**Ù***   isspace()                        0x01Ù***   isalpha()                        0x02Ù***   isdigit()                        0x04Ù***   isalnum()                        0x06Ù***   isxdigit()                       0x08Ù***   toupper()                        0x20Ù***   SQLite identifier character      0x40Ù***   Quote character                  0x80¢**ÙH** Bit 0x20 is set if the mapped character requires translation to upperÙ?** case. i.e. if the character is a lower-case ASCII character.ÙG** If x is a lower-case ASCII character, then its upper-case equivalentÙ<** is (x - 0x20). Therefore toupper() can be implemented as:¢**¹**   (x & ~(map[x]&0x20))¢**ÙM** The equivalent of tolower() is implemented using the sqlite3UpperToLower[]Ù@** array. tolower() is used more often than toupper() by SQLite.¢**ÙN** Bit 0x40 is set if the character is non-alphanumeric and can be used in an ÙG** SQLite identifier.  Identifiers are alphanumerics, "_", "$", and anyÙL** non-ASCII UTF character. Hence the test for whether or not a character isÙ!** part of an identifier is 0x46.¢*/³#ifdef SQLITE_ASCIIÙ;SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {ÙK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */ÙK  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */ÙK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */ÙK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */ÙK  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  /* 20..27     !"#$%&' */ÙK  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */ÙK  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */ÙK  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */ ÙK  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */ÙK  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */ÙK  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */ÙK  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  /* 58..5f    XYZ[\]^_ */ÙK  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */ÙK  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */ÙK  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */ÙK  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */ ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 80..87    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 88..8f    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 90..97    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 98..9f    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a0..a7    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a8..af    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b0..b7    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b8..bf    ........ */ ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c0..c7    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c8..cf    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d0..d7    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d8..df    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e0..e7    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e8..ef    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* f0..f7    ........ */ÙK  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   /* f8..ff    ........ */¢};¦#endif ÙA/* EVIDENCE-OF: R-02982-34736 In order to maintain full backwardsÙH** compatibility for legacy applications, the URI filename capability is·** disabled by default.¢**ÙF** EVIDENCE-OF: R-38799-08373 URI filenames can be enabled or disabledÙG** using the SQLITE_USE_URI=1 or SQLITE_USE_URI=0 compile-time options.¢**ÙB** EVIDENCE-OF: R-43642-56306 By default, URI handling is globallyÙC** disabled. The default value may be changed by compiling with theÙ!** SQLITE_USE_URI symbol defined.¢**Ù>** URI filenames are enabled by default if SQLITE_HAS_CODEC is«** enabled.¢*/¶#ifndef SQLITE_USE_URI¸# ifdef SQLITE_HAS_CODECº#  define SQLITE_USE_URI 1¦# elseº#  define SQLITE_USE_URI 0§# endif¦#endif ÙF/* EVIDENCE-OF: R-38720-18127 The default setting is determined by theÙF** SQLITE_ALLOW_COVERING_INDEX_SCAN compile-time option, or is "on" ifÙ'** that compile-time option is omitted.¢*/Ù(#ifndef SQLITE_ALLOW_COVERING_INDEX_SCANÙ+# define SQLITE_ALLOW_COVERING_INDEX_SCAN 1¦#endif ÙG/* The minimum PMA size is set to this value multiplied by the database¶** page size in bytes.¢*/»#ifndef SQLITE_SORTER_PMASZÙ # define SQLITE_SORTER_PMASZ 250¦#endif ÙI/* Statement journals spill to disk when their size exceeds the followingÙH** threshold (in bytes). 0 means that statement journals are created andÙH** written to disk immediately (the default behavior for SQLite versionsÙH** before 3.12.0).  -1 means always keep the entire statement journal inÙI** memory.  (The statement journal is also always held entirely in memoryÙE** if journal_mode=MEMORY or if temp_store=MEMORY, regardless of this¬** setting.)¢*/¾#ifndef SQLITE_STMTJRNL_SPILL Ù(# define SQLITE_STMTJRNL_SPILL (64*1024)¦#endif ¢/*ÙE** The default lookaside-configuration, the format "SZ,N".  SZ is theÙE** number of bytes in each lookaside slot (should be a multiple of 8)ÙD** and N is the number of slots.  The lookaside-configuration can beÙF** changed as start-time using sqlite3_config(SQLITE_CONFIG_LOOKASIDE)Ù=** or at run-time for an individual database connection usingÙ4** sqlite3_db_config(db, SQLITE_DBCONFIG_LOOKASIDE);¢*/Ù #ifndef SQLITE_DEFAULT_LOOKASIDEÙ*# define SQLITE_DEFAULT_LOOKASIDE 1200,100¦#endif  ¢/*Ù@** The following singleton contains the global configuration for¶** the SQLite library.¢*/Ù@SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {Ù,   SQLITE_DEFAULT_MEMSTATUS,  /* bMemstat */Ù.   1,                         /* bCoreMutex */Ù.   SQLITE_THREADSAFE==1,      /* bFullMutex */Ù,   SQLITE_USE_URI,            /* bOpenUri */Ù4   SQLITE_ALLOW_COVERING_INDEX_SCAN,   /* bUseCis */Ù0   0,                         /* bSmallMalloc */Ù,   0x7ffffffe,                /* mxStrlen */Ù0   0,                         /* neverCorrupt */Ù;   SQLITE_DEFAULT_LOOKASIDE,  /* szLookaside, nLookaside */Ù.   SQLITE_STMTJRNL_SPILL,     /* nStmtSpill */Ù%   {0,0,0,0,0,0,0,0},         /* m */Ù)   {0,0,0,0,0,0,0,0,0},       /* mutex */Ù,   {0,0,0,0,0,0,0,0,0,0,0,0,0},/* pcache2 */Ù)   (void*)0,                  /* pHeap */Ù)   0,                         /* nHeap */Ù2   0, 0,                      /* mnHeap, mxHeap */Ù*   SQLITE_DEFAULT_MMAP_SIZE,  /* szMmap */Ù*   SQLITE_MAX_MMAP_SIZE,      /* mxMmap */Ù)   (void*)0,                  /* pPage */Ù*   0,                         /* szPage */Ù,   SQLITE_DEFAULT_PCACHE_INITSZ, /* nPage */Ù1   0,                         /* mxParserStack */Ù6   0,                         /* sharedCacheEnabled */Ù)   SQLITE_SORTER_PMASZ,       /* szPma */Ù:   /* All the rest should always be initialized to zero */Ù*   0,                         /* isInit */Ù.   0,                         /* inProgress */Ù/   0,                         /* isMutexInit */Ù0   0,                         /* isMallocInit */Ù0   0,                         /* isPCacheInit */Ù1   0,                         /* nRefInitMutex */Ù.   0,                         /* pInitMutex */Ù(   0,                         /* xLog */Ù+   0,                         /* pLogArg */»#ifdef SQLITE_ENABLE_SQLLOGÙ+   0,                         /* xSqllog */Ù.   0,                         /* pSqllogArg */¦#endif»#ifdef SQLITE_VDBE_COVERAGEÙ/   0,                         /* xVdbeBranch */Ù1   0,                         /* pVbeBranchArg */¦#endif¹#ifndef SQLITE_UNTESTABLEÙ1   0,                         /* xTestCallback */¦#endifÙ3   0,                         /* bLocaltimeFault */Ù7   0x7ffffffe                 /* iOnceResetThreshold */¢}; ¢/*Ù<** Hash table for global functions - functions common to allÙ=** database connections.  After initialization, this table is­** read-only.¢*/Ù3SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions; ¢/*Ù&** Constant tokens for values 0 and 1.¢*/Ù1SQLITE_PRIVATE const Token sqlite3IntTokens[] = {®   { "0", 1 },­   { "1", 1 }¢}; ³#ifdef VDBE_PROFILE¢/*Ù<** The following performance counter can be used in place ofÙF** sqlite3Hwtime() for profiling.  This is a no-op on standard builds.¢*/Ù5SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt = 0;¦#endif ¢/*ÙF** The value of the "pending" byte must be 0x40000000 (1 byte past theÙD** 1-gibabyte boundary) in a compatible database.  SQLite never usesÙG** the database page that contains the pending byte.  It never attemptsÙB** to read or write that page.  The pending byte page is set asideÙ>** for use by the VFS layers as space for managing file locks.¢**ÙD** During testing, it is often desirable to move the pending byte toÙB** a different position in the file.  This allows code that has toÙC** deal with the pending byte to run on files that are much smallerÙC** than 1 GiB.  The sqlite3_test_control() interface can be used to¹** move the pending byte.¢**Ù@** IMPORTANT:  Changing the pending byte to any value other thanÙ>** 0x40000000 results in an incompatible database file format!ÙF** Changing the pending byte during operation will result in undefinedº** and incorrect behavior.¢*/·#ifndef SQLITE_OMIT_WSDÙ3SQLITE_PRIVATE int sqlite3PendingByte = 0x40000000;¦#endif º/* #include "opcodes.h" */¢/*Ù9** Properties of opcodes.  The OPFLG_INITIALIZER macro isÙA** created by mkopcodeh.awk during compilation.  Data is obtainedÙ@** from the comments following the "case OP_xxxx:" statements inµ** the vdbe.c file.  ¢*/ÙOSQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER; ¢/*Ù)** Name of the default collating sequence¢*/Ù8SQLITE_PRIVATE const char sqlite3StrBINARY[] = "BINARY"; ÙO/************** End of global.c **********************************************/ÙO/************** Begin file status.c ******************************************/¢/*¯** 2008 June 18¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙD** This module implements the sqlite3_status() interface and related±** functionality.¢*/¼/* #include "sqliteInt.h" */ÙO/************** Include vdbeInt.h in the middle of status.c ******************/ÙO/************** Begin file vdbeInt.h *****************************************/¢/*³** 2003 September 6¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙA** This is the header file for information that is private to theÙB** VDBE.  This information used to all be at the top of the singleÙB** source code file "vdbe.c".  When that file became too big (overÙB** 6000 lines long) it was split up into several smaller files andÙ,** this header information was factored out.¢*/¸#ifndef SQLITE_VDBEINT_H¸#define SQLITE_VDBEINT_H ¢/*ÙC** The maximum number of times that a statement will try to reparseÙ7** itself before giving up and returning SQLITE_SCHEMA.¢*/¿#ifndef SQLITE_MAX_SCHEMA_RETRYÙ## define SQLITE_MAX_SCHEMA_RETRY 50¦#endif ¢/*ÙC** VDBE_DISPLAY_P4 is true or false depending on whether or not theÙ)** "explain" P4 display logic is enabled.¢*/Ù7#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \Ù6     || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)º# define VDBE_DISPLAY_P4 1¥#elseº# define VDBE_DISPLAY_P4 0¦#endif ¢/*Ù:** SQL is translated into a sequence of instructions to beÙB** executed by a virtual machine.  Each instruction is an instance¾** of the following structure.¢*/¹typedef struct VdbeOp Op; ¢/*±** Boolean values¢*/¶typedef unsigned Bool; Ù,/* Opaque type used by code in vdbesort.c */Ù%typedef struct VdbeSorter VdbeSorter; Ù2/* Elements of the linked list at Vdbe.pAuxData */¿typedef struct AuxData AuxData; »/* Types of VDBE cursors */½#define CURTYPE_BTREE       0½#define CURTYPE_SORTER      1½#define CURTYPE_VTAB        2½#define CURTYPE_PSEUDO      3 ¢/*ÙH** A VdbeCursor is an superclass (a wrapper) for various cursor objects:¢**¹**      * A b-tree cursorÙ?**          -  In the main database or in an ephemeral databaseÙ,**          -  On either an index or a table²**      * A sorter¹**      * A virtual tableÙ=**      * A one-row "pseudotable" stored in a single register¢*/Ù%typedef struct VdbeCursor VdbeCursor;³struct VdbeCursor {ÙA  u8 eCurType;            /* One of the CURTYPE_* values above */ÙM  i8 iDb;                 /* Index of cursor database in db->aDb[] (or -1) */ÙF  u8 nullRow;             /* True if pointing to a row with no data */ÙH  u8 deferredMoveto;      /* A call to sqlite3BtreeMoveto() is needed */ÙI  u8 isTable;             /* True for rowid tables.  False for indexes */³#ifdef SQLITE_DEBUGÙI  u8 seekOp;              /* Most recent seek operation on this cursor */ÙK  u8 wrFlag;              /* The wrFlag argument to sqlite3BtreeCursor() */¦#endifÙ;  Bool isEphemeral:1;     /* True for an ephemeral table */ÙI  Bool useRandomRowid:1;  /* Generate new record numbers semi-randomly */ÙH  Bool isOrdered:1;       /* True if the table is not BTREE_UNORDERED */ÙE  Btree *pBtx;            /* Separate file holding temporary table */Ù0  i64 seqCount;           /* Sequence counter */ÙJ  int *aAltMap;           /* Mapping from table to index column numbers */ ÙL  /* Cached OP_Column parse information is only valid if cacheStatus matchesÙB  ** Vdbe.cacheCtr.  Vdbe.cacheCtr will never take on the value ofÙK  ** CACHE_STALE (0) and so setting cacheStatus=CACHE_STALE guarantees thatÙ!  ** the cache is out of date. */ÙL  u32 cacheStatus;        /* Cache is valid if this matches Vdbe.cacheCtr */ÙI  int seekResult;         /* Result of previous sqlite3BtreeMoveto() or 0ÙP                          ** if there have been no prior seeks on the cursor. */ÙI  /* seekResult does not distinguish between "no seeks have ever occurredÙC  ** on this cursor" and "the most recent seek was an exact match".ÙI  ** For CURTYPE_PSEUDO, seekResult is the register holding the record */ ÙJ  /* When a new VdbeCursor is allocated, only the fields above are zeroed.ÙG  ** The fields that follow are uninitialized, and must be individuallyÙ'  ** initialized prior to first use. */ÙJ  VdbeCursor *pAltCursor; /* Associated index cursor from which to read */©  union {ÙM    BtCursor *pCursor;          /* CURTYPE_BTREE or _PSEUDO.  Btree cursor */ÙL    sqlite3_vtab_cursor *pVCur; /* CURTYPE_VTAB.              Vtab cursor */ÙN    VdbeSorter *pSorter;        /* CURTYPE_SORTER.            Sorter object */§  } uc;ÙM  KeyInfo *pKeyInfo;      /* Info about index keys needed by index cursors */ÙJ  u32 iHdrOffset;         /* Offset to next unparsed byte of the header */ÙB  Pgno pgnoRoot;          /* Root page of the open btree cursor */Ù>  i16 nField;             /* Number of fields in the header */ÙE  u16 nHdrParsed;         /* Number of header fields parsed so far */ÙM  i64 movetoTarget;       /* Argument to the deferred sqlite3BtreeMoveto() */Ù8  u32 *aOffset;           /* Pointer to aType[nField] */ÙL  const u8 *aRow;         /* Data for the current row, if all on one page */ÙC  u32 payloadSize;        /* Total number of bytes in the record */Ù6  u32 szRow;              /* Byte available in aRow */Ù%#ifdef SQLITE_ENABLE_COLUMN_USED_MASKÙC  u64 maskUsed;           /* Mask of columns used by this cursor */¦#endif ÙH  /* 2*nField extra array elements allocated for aType[], beyond the oneÙL  ** static element declared in the structure.  nField total array slots forÙ6  ** aType[] and nField+1 array slots for aOffset[] */ÙH  u32 aType[1];           /* Type values record decode.  MUST BE LAST */¢};  ¢/*ÙM** A value for VdbeCursor.cacheStatus that means the cache is always invalid.¢*/µ#define CACHE_STALE 0 ¢/*ÙH** When a sub-program is executed (OP_Program), a structure of this typeÙE** is allocated to store the current value of the program counter, asÙI** well as the current memory cell array and various other frame specificÙG** values stored in the Vdbe struct. When the sub-program is finished, ÙI** these values are copied back to the Vdbe from the VdbeFrame structure,ÙD** restoring the state of the VM to as it was before the sub-program³** began executing.¢**ÙI** The memory for a VdbeFrame object is allocated and managed by a memoryÙI** cell in the parent (calling) frame. When the memory cell is deleted orÙJ** overwritten, the VdbeFrame object is not freed immediately. Instead, itÙM** is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrameÙK** list is deleted when the VM is reset in VdbeHalt(). The reason for doingÙK** this instead of deleting the VdbeFrame immediately is to avoid recursiveÙJ** calls to sqlite3VdbeMemRelease() when the memory cells belonging to the¼** child frame are released.¢**ÙI** The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame isÙD** set to NULL if the currently executing frame is the main program.¢*/Ù#typedef struct VdbeFrame VdbeFrame;²struct VdbeFrame {Ù8  Vdbe *v;                /* VM this frame belongs to */ÙO  VdbeFrame *pParent;     /* Parent of this frame, or NULL if parent is main */ÙE  Op *aOp;                /* Program instructions for parent frame */Ù@  i64 *anExec;            /* Event counters from parent frame */ÙF  Mem *aMem;              /* Array of memory cells for parent frame */ÙF  VdbeCursor **apCsr;     /* Array of Vdbe cursors for parent frame */Ù7  u8 *aOnce;              /* Bitmask used by OP_Once */Ù8  void *token;            /* Copy of SubProgram.token */ÙE  i64 lastRowid;          /* Last insert rowid (sqlite3.lastRowid) */ÙB  AuxData *pAuxData;      /* Linked list of auxdata allocations */Ù:  int nCursor;            /* Number of entries in apCsr */ÙI  int pc;                 /* Program Counter in parent (calling) frame */Ù1  int nOp;                /* Size of aOp array */Ù9  int nMem;               /* Number of entries in aMem */ÙF  int nChildMem;          /* Number of memory cells for child frame */ÙA  int nChildCsr;          /* Number of cursors for child frame */ÙD  int nChange;            /* Statement changes (Vdbe.nChange)     */Ù4  int nDbChange;          /* Value of db->nChange */¢}; ÙF#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))]) ¢/*Ù@** Internally, the vdbe manipulates nearly all SQL values as MemÙJ** structures. Each Mem struct may cache multiple representations (string,Ù#** integer etc.) of the same value.¢*/¶struct sqlite3_value {²  union MemValue {ÙK    double r;           /* Real value used when MEM_Real is set in flags */ÙM    i64 i;              /* Integer value used when MEM_Int is set in flags */ÙM    int nZero;          /* Extra zero bytes when MEM_Zero and MEM_Blob set */ÙM    const char *zPType; /* Pointer type when MEM_Term|MEM_Subtype|MEM_Null */Ù;    FuncDef *pDef;      /* Used only when flags==MEM_Agg */Ù>    RowSet *pRowSet;    /* Used only when flags==MEM_RowSet */Ù8    VdbeFrame *pFrame;  /* Used when flags==MEM_Frame */¦  } u;ÙP  u16 flags;          /* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */ÙG  u8  enc;            /* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */Ù2  u8  eSubtype;       /* Subtype for this value */ÙP  int n;              /* Number of characters in string value, excluding '\0' */Ù0  char *z;            /* String or BLOB value */Ù<  /* ShallowCopy only needs to copy the information above */ÙK  char *zMalloc;      /* Space to hold MEM_Str or MEM_Blob if szMalloc>0 */Ù:  int szMalloc;       /* Size of the zMalloc allocation */ÙN  u32 uTemp;          /* Transient storage for serial_type in OP_MakeRecord */Ù>  sqlite3 *db;        /* The associated database connection */ÙH  void (*xDel)(void*);/* Destructor for Mem.z - only valid if MEM_Dyn */³#ifdef SQLITE_DEBUGÙD  Mem *pScopyFrom;    /* This Mem is a shallow copy of pScopyFrom */ÙB  void *pFiller;      /* So that sizeof(Mem) is a multiple of 8 */¦#endif¢}; ¢/*ÙK** Size of struct Mem not including the Mem.zMalloc member or anything that«** follows.¢*/Ù)#define MEMCELLSIZE offsetof(Mem,zMalloc) ÙE/* One or more of the following flags are set to indicate the validOKÙ9** representations of the value stored in the Mem struct.¢**ÙD** If the MEM_Null flag is set, then the value is an SQL NULL value.Ù=** For a pointer type created using sqlite3_bind_pointer() orÙL** sqlite3_result_pointer() the MEM_Term and MEM_Subtype flags are also set.¢**ÙK** If the MEM_Str flag is set then Mem.z points at a string representation.ÙC** Usually this is encoded in the same unicode encoding as the mainÙD** database (see below for exceptions). If the MEM_Term flag is alsoÙD** set, then the string is nul terminated. The MEM_Int and MEM_Real Ù+** flags may coexist with the MEM_Str flag.¢*/ÙA#define MEM_Null      0x0001   /* Value is NULL (or a pointer) */Ù6#define MEM_Str       0x0002   /* Value is a string */Ù8#define MEM_Int       0x0004   /* Value is an integer */Ù;#define MEM_Real      0x0008   /* Value is a real number */Ù4#define MEM_Blob      0x0010   /* Value is a BLOB */Ù:#define MEM_AffMask   0x001f   /* Mask of affinity bits */Ù=#define MEM_RowSet    0x0020   /* Value is a RowSet object */Ù@#define MEM_Frame     0x0040   /* Value is a VdbeFrame object */Ù7#define MEM_Undefined 0x0080   /* Value is undefined */ÙG#define MEM_Cleared   0x0100   /* NULL set by OP_Null, not from data */Ù6#define MEM_TypeMask  0xc1ff   /* Mask of type bits */  ÙF/* Whenever Mem contains a valid string or blob representation, one ofÙE** the following flags must be set to determine the memory managementÙC** policy for Mem.z.  The MEM_Term flag tells us whether or not theÙ&** string is \000 or \u0000 terminated¢*/ÙG#define MEM_Term      0x0200   /* String in Mem.z is zero terminated */ÙE#define MEM_Dyn       0x0400   /* Need to call Mem.xDel() on Mem.z */ÙD#define MEM_Static    0x0800   /* Mem.z points to a static string */ÙH#define MEM_Ephem     0x1000   /* Mem.z points to an ephemeral string */ÙL#define MEM_Agg       0x2000   /* Mem.z points to an agg function context */ÙP#define MEM_Zero      0x4000   /* Mem.i contains count of 0s appended to blob */Ù:#define MEM_Subtype   0x8000   /* Mem.eSubtype is valid */»#ifdef SQLITE_OMIT_INCRBLOB±  #undef MEM_Zero¹  #define MEM_Zero 0x0000¦#endif ÙI/* Return TRUE if Mem X contains dynamically allocated content - anythingÙ0** that needs to be deallocated to avoid a leak.¢*/¼#define VdbeMemDynamic(X)  \Ù:  (((X)->flags&(MEM_Agg|MEM_Dyn|MEM_RowSet|MEM_Frame))!=0) ¢/*ÙC** Clear any existing type flags from a Mem and replace them with f¢*/¾#define MemSetTypeFlag(p, f) \Ù9   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f) ¢/*ÙE** Return true if a memory cell is not marked as invalid.  This macroÙ.** is for use inside assert() statements only.¢*/³#ifdef SQLITE_DEBUGÙ6#define memIsValid(M)  ((M)->flags & MEM_Undefined)==0¦#endif ¢/*ÙA** Each auxiliary data pointer stored by a user defined function ÙH** implementation calling sqlite3_set_auxdata() is stored in an instanceÙE** of this structure. All such structures associated with a single VMÙI** are stored in a linked list headed at Vdbe.pAuxData. All are destroyedÙ)** when the VM is halted (if not before).¢*/°struct AuxData {ÙP  int iAuxOp;                     /* Instruction number of OP_Function opcode */ÙC  int iAuxArg;                    /* Index of function argument. */Ù8  void *pAux;                     /* Aux data pointer */ÙC  void (*xDeleteAux)(void*);      /* Destructor for the aux data */Ù<  AuxData *pNextAux;              /* Next element in list */¢}; ¢/*ÙG** The "context" argument for an installable function.  A pointer to anÙH** instance of this structure is the first argument to the routines used¿** implement the SQL functions.¢**ÙG** There is a typedef for this structure in sqlite.h.  So all routines,ÙL** even the public interface to SQLite, can use a pointer to this structure.ÙE** But this file is the only place where the internal details of this·** structure are known.¢**ÙN** This structure is defined inside of vdbeInt.h because it uses substructuresÙ&** (Mem) which are only defined there.¢*/¸struct sqlite3_context {Ù?  Mem *pOut;              /* The return value is stored here */Ù?  FuncDef *pFunc;         /* Pointer to function information */ÙK  Mem *pMem;              /* Memory cell used to store aggregate context */Ù=  Vdbe *pVdbe;            /* The VM that owns this context */ÙA  int iOp;                /* Instruction number of OP_Function */ÙD  int isError;            /* Error code returned by the function. */Ù@  u8 skipFlag;            /* Skip accumulator loading if true */Ù3  u8 argc;                /* Number of arguments */Ù,  sqlite3_value *argv[1]; /* Argument set */¢}; ÙM/* A bitfield type for use inside of structures.  Always follow with :N where»** N is the number of bits.¢*/Ù+typedef unsigned bft;  /* Bit Field Type */ Ù%typedef struct ScanStatus ScanStatus;³struct ScanStatus {Ù;  int addrExplain;                /* OP_Explain for loop */ÙB  int addrLoop;                   /* Address of "loops" counter */ÙI  int addrVisit;                  /* Address of "rows visited" counter */ÙE  int iSelectID;                  /* The "Select-ID" for this loop */ÙF  LogEst nEst;                    /* Estimated output rows per loop */Ù>  char *zName;                    /* Name of table or index */¢}; ¢/*ÙL** An instance of the virtual machine.  This structure contains the completeÙ ** state of the virtual machine.¢**ÙM** The "sqlite3_stmt" structure pointer that is returned by sqlite3_prepare()Ù8** is really a pointer to an instance of this structure.¢*/­struct Vdbe {ÙP  sqlite3 *db;            /* The database connection that owns this statement */ÙJ  Vdbe *pPrev,*pNext;     /* Linked list of VDBEs with the same Vdbe.db */ÙH  Parse *pParse;          /* Parsing context used to create this Vdbe */Ù;  ynVar nVar;             /* Number of entries in aVar[] */Ù@  u32 magic;              /* Magic number for sanity checking */ÙN  int nMem;               /* Number of memory locations currently allocated */Ù:  int nCursor;            /* Number of slots in apCsr[] */ÙG  u32 cacheCtr;           /* VdbeCursor row cache generation counter */Ù3  int pc;                 /* The program counter */Ù/  int rc;                 /* Value to return */ÙJ  int nChange;            /* Number of db changes made since last reset */ÙN  int iStatement;         /* Statement number (or 0 if has not opened stmt) */ÙL  i64 iCurrentTime;       /* Value of julianday('now') for this statement */ÙE  i64 nFkConstraint;      /* Number of imm. FK constraints this VM */ÙL  i64 nStmtDefCons;       /* Number of def. constraints when stmt started */ÙP  i64 nStmtDefImmCons;    /* Number of def. imm constraints when stmt started */ ÙI  /* When allocating a new Vdbe object, all of the fields below should beÙ#  ** initialized to zero or NULL */ ÙK  Op *aOp;                /* Space to hold the virtual machine's program */Ù4  Mem *aMem;              /* The memory locations */ÙN  Mem **apArg;            /* Arguments to currently executing user function */Ù6  Mem *aColName;          /* Column names to return */Ù>  Mem *pResultSet;        /* Pointer to an array of results */Ù:  char *zErrMsg;          /* Error message written here */ÙN  VdbeCursor **apCsr;     /* One element of this array for each open cursor */ÙB  Mem *aVar;              /* Values for the OP_Variable opcode. */Ù1  VList *pVList;          /* Name of variables */¹#ifndef SQLITE_OMIT_TRACEÙL  i64 startTime;          /* Time when query started - used for profiling */¦#endifÙE  int nOp;                /* Number of instructions in the program */³#ifdef SQLITE_DEBUGÙJ  int rcApp;              /* errcode set by sqlite3_result_error_code() */¦#endifÙN  u16 nResColumn;         /* Number of columns in one row of the result set */ÙI  u8 errorAction;         /* Recovery action to do in case of an error */ÙO  u8 minWriteFileFormat;  /* Minimum file format for writable database files */Ù6  u8 prepFlags;           /* SQLITE_PREPARE_* flags */ÙE  bft expired:1;          /* True if the VM needs to be recompiled */ÙI  bft doingRerun:1;       /* True if rerunning after an auto-reprepare */ÙF  bft explain:2;          /* True if EXPLAIN present on SQL command */ÙA  bft changeCntOn:1;      /* True to update the change-counter */Ù=  bft runOnlyOnce:1;      /* Automatically expire on reset */Ù@  bft usesStmtJournal:1;  /* True if uses a statement journal */ÙE  bft readOnly:1;         /* True for statements that do not write */Ù=  bft bIsReader:1;        /* True for statements that read */ÙG  yDbMask btreeMask;      /* Bitmask of db->aDb[] entries referenced */ÙH  yDbMask lockMask;       /* Subset of btreeMask that requires a lock */ÙF  u32 aCounter[7];        /* Counters used by sqlite3_stmt_status() */ÙM  char *zSql;             /* Text of the SQL statement that generated this */Ù@  void *pFree;            /* Free this when deleting the vdbe */Ù,  VdbeFrame *pFrame;      /* Parent frame */ÙI  VdbeFrame *pDelFrame;   /* List of frame objects to free on VM reset */Ù?  int nFrame;             /* Number of frames in pFrame list */ÙD  u32 expmask;            /* Binding to these vars invalidates VM */ÙJ  SubProgram *pProgram;   /* Linked list of all sub-programs used by VM */ÙB  AuxData *pAuxData;      /* Linked list of auxdata allocations */Ù$#ifdef SQLITE_ENABLE_STMT_SCANSTATUSÙI  i64 *anExec;            /* Number of times each op has been executed */Ù2  int nScan;              /* Entries in aScan[] */ÙN  ScanStatus *aScan;      /* Scan definitions for sqlite3_stmt_scanstatus() */¦#endif¢}; ¢/*Ù2** The following are allowed values for Vdbe.magic¢*/ÙG#define VDBE_MAGIC_INIT     0x16bceaa5    /* Building a VDBE program */ÙH#define VDBE_MAGIC_RUN      0x2df20da3    /* VDBE is ready to execute */ÙL#define VDBE_MAGIC_HALT     0x319c2973    /* VDBE has completed execution */ÙL#define VDBE_MAGIC_RESET    0x48fa9f76    /* Reset and ready to run again */ÙM#define VDBE_MAGIC_DEAD     0x5606c3c8    /* The VDBE has been deallocated */ ¢/*Ù7** Structure used to store the context required by the Ù'** sqlite3_preupdate_*() API functions.¢*/²struct PreUpdate {ª  Vdbe *v;ÙF  VdbeCursor *pCsr;               /* Cursor to read old values from */ÙL  int op;                         /* One of SQLITE_INSERT, UPDATE, DELETE */Ù=  u8 *aRecord;                    /* old.* database record */²  KeyInfo keyinfo;ÙE  UnpackedRecord *pUnpacked;      /* Unpacked version of aRecord[] */ÙH  UnpackedRecord *pNewUnpacked;   /* Unpacked version of new.* record */ÙA  int iNewReg;                    /* Register for new.* values */ÙF  i64 iKey1;                      /* First key value passed to hook */ÙG  i64 iKey2;                      /* Second key value passed to hook */Ù=  Mem *aNew;                      /* Array of new.* values */ÙL  Table *pTab;                    /* Schema object being upated */          ÙI  Index *pPk;                     /* PK index if pTab is WITHOUT ROWID */¢}; ¢/*¶** Function prototypes¢*/Ù?SQLITE_PRIVATE void sqlite3VdbeError(Vdbe*, const char *, ...);Ù?SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);Ù#void sqliteVdbePopStack(Vdbe*,int);Ù?SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);Ù9SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor*);Ù2#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)Ù8SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE*, int, Op*);¦#endifÙ1SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32);Ù6SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8);Ù:SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem*, int, u32*);ÙCSQLITE_PRIVATE u32 sqlite3VdbeSerialPut(unsigned char*, Mem*, u32);ÙISQLITE_PRIVATE u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);ÙLSQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int); ÙFint sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);ÙWSQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*);ÙBSQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);Ù*SQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*);Ù*SQLITE_PRIVATE int sqlite3VdbeList(Vdbe*);Ù*SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*);Ù9SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int);Ù.SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*);Ù8SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem*, const Mem*);ÙESQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);Ù3SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem*, Mem*);Ù4SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem*);ÙTSQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));Ù6SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64);Ù!#ifdef SQLITE_OMIT_FLOATING_POINTÙ7# define sqlite3VdbeMemSetDouble sqlite3VdbeMemSetInt64¥#elseÙ<SQLITE_PRIVATE   void sqlite3VdbeMemSetDouble(Mem*, double);¦#endifÙWSQLITE_PRIVATE void sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*));Ù:SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem*,sqlite3*,u16);Ù0SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*);Ù8SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*,int);Ù2SQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem*);Ù5SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem*);Ù9SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem*, u8, u8);Ù-SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*);Ù2SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*);Ù1SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*);Ù=SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem*, int ifNull);Ù5SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*);Ù/SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*);Ù0SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*);Ù3SQLITE_PRIVATE void sqlite3VdbeMemCast(Mem*,u8,u8);ÙCSQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*);Ù2SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p);Ù:SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*);Ù2SQLITE_PRIVATE const char *sqlite3OpcodeName(int);ÙFSQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);ÙBSQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int n);Ù:SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *, int);Ù7SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame*);Ù8SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *);Ù##ifdef SQLITE_ENABLE_PREUPDATE_HOOKÙ_SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(Vdbe*,VdbeCursor*,int,const char*,Table*,i64,int);¦#endifÙ5SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p); ÙGSQLITE_PRIVATE int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);ÙDSQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);ÙDSQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);ÙFSQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);ÙHSQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *);ÙFSQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *, int *);ÙESQLITE_PRIVATE int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);ÙSSQLITE_PRIVATE int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *); Ù'#if !defined(SQLITE_OMIT_SHARED_CACHE) Ù.SQLITE_PRIVATE   void sqlite3VdbeEnter(Vdbe*);¥#else¼# define sqlite3VdbeEnter(X)¦#endif Ù=#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0Ù.SQLITE_PRIVATE   void sqlite3VdbeLeave(Vdbe*);¥#else¼# define sqlite3VdbeLeave(X)¦#endif ³#ifdef SQLITE_DEBUGÙ<SQLITE_PRIVATE void sqlite3VdbeMemAboutToChange(Vdbe*,Mem*);Ù7SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem*);¦#endif ¿#ifndef SQLITE_OMIT_FOREIGN_KEYÙ3SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *, int);¥#elseÙ"# define sqlite3VdbeCheckFk(p,i) 0¦#endif ³#ifdef SQLITE_DEBUGÙ1SQLITE_PRIVATE   void sqlite3VdbePrintSql(Vdbe*);ÙGSQLITE_PRIVATE   void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf);¦#endif¹#ifndef SQLITE_OMIT_UTF16Ù7SQLITE_PRIVATE   int sqlite3VdbeMemTranslate(Mem*, u8);Ù8SQLITE_PRIVATE   int sqlite3VdbeMemHandleBom(Mem *pMem);¦#endif ¼#ifndef SQLITE_OMIT_INCRBLOBÙ5SQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);ÙM  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)¥#elseÙ/  #define sqlite3VdbeMemExpandBlob(x) SQLITE_OKÙ!  #define ExpandBlob(P) SQLITE_OK¦#endif Ù'#endif /* !defined(SQLITE_VDBEINT_H) */ ÙO/************** End of vdbeInt.h *********************************************/ÙO/************** Continuing where we left off in status.c *********************/ ¢/*Ù3** Variables in which to record status information.¢*/´#if SQLITE_PTRSIZE>4Ù+typedef sqlite3_int64 sqlite3StatValueType;¥#elseÙ!typedef u32 sqlite3StatValueType;¦#endifÙ/typedef struct sqlite3StatType sqlite3StatType;Ù*static SQLITE_WSD struct sqlite3StatType {Ù9  sqlite3StatValueType nowValue[10];  /* Current value */Ù9  sqlite3StatValueType mxValue[10];   /* Maximum value */¿} sqlite3Stat = { {0,}, {0,} }; ¢/*ÙI** Elements of sqlite3Stat[] are protected by either the memory allocatorÙI** mutex, or by the pcache1 mutex.  The following array determines which.¢*/Ù!static const char statMutex[] = {Ù%  0,  /* SQLITE_STATUS_MEMORY_USED */Ù(  1,  /* SQLITE_STATUS_PAGECACHE_USED */Ù,  1,  /* SQLITE_STATUS_PAGECACHE_OVERFLOW */Ù&  0,  /* SQLITE_STATUS_SCRATCH_USED */Ù*  0,  /* SQLITE_STATUS_SCRATCH_OVERFLOW */Ù%  0,  /* SQLITE_STATUS_MALLOC_SIZE */Ù&  0,  /* SQLITE_STATUS_PARSER_STACK */Ù(  1,  /* SQLITE_STATUS_PAGECACHE_SIZE */Ù&  0,  /* SQLITE_STATUS_SCRATCH_SIZE */Ù&  0,  /* SQLITE_STATUS_MALLOC_COUNT */¢};  Ù=/* The "wsdStat" macro will resolve to the status informationÙG** state vector.  If writable static data is unsupported on the target,ÙF** we have to locate the state vector at run-time.  In the more commonÙK** case where writable static data is supported, wsdStat can refer directlyÙ4** to the "sqlite3Stat" state vector declared above.¢*/¶#ifdef SQLITE_OMIT_WSDÙO# define wsdStatInit  sqlite3StatType *x = &GLOBAL(sqlite3StatType,sqlite3Stat)µ# define wsdStat x[0]¥#else´# define wsdStatInit¼# define wsdStat sqlite3Stat¦#endif ¢/*ÙC** Return the current value of a status parameter.  The caller mustÙ$** be holding the appropriate mutex.¢*/Ù8SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int op){®  wsdStatInit;Ù4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );Ù-  assert( op>=0 && op<ArraySize(statMutex) );ÙB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ÙE                                           : sqlite3MallocMutex()) );¾  return wsdStat.nowValue[op];¡} ¢/*ÙC** Add N to the value of a status record.  The caller must hold theÙ8** appropriate mutex.  (Locking is checked by assert()).¢**ÙG** The StatusUp() routine can accept positive or negative values for N.ÙI** The value of N is added to the current status value and the high-waterÙ!** mark is adjusted if necessary.¢**ÙI** The StatusDown() routine lowers the current value by N.  The highwaterÙ?** mark is unchanged.  N must be non-negative for StatusDown().¢*/Ù3SQLITE_PRIVATE void sqlite3StatusUp(int op, int N){®  wsdStatInit;Ù4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );Ù-  assert( op>=0 && op<ArraySize(statMutex) );ÙB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ÙE                                           : sqlite3MallocMutex()) );¼  wsdStat.nowValue[op] += N;Ù1  if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){Ù/    wsdStat.mxValue[op] = wsdStat.nowValue[op];£  }¡}Ù5SQLITE_PRIVATE void sqlite3StatusDown(int op, int N){®  wsdStatInit;±  assert( N>=0 );Ù-  assert( op>=0 && op<ArraySize(statMutex) );ÙB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ÙE                                           : sqlite3MallocMutex()) );Ù4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );¼  wsdStat.nowValue[op] -= N;¡} ¢/*Ù*** Adjust the highwater mark if necessary.Ù.** The caller must hold the appropriate mutex.¢*/Ù:SQLITE_PRIVATE void sqlite3StatusHighwater(int op, int X){Ù   sqlite3StatValueType newValue;®  wsdStatInit;±  assert( X>=0 );Ù%  newValue = (sqlite3StatValueType)X;Ù4  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );Ù-  assert( op>=0 && op<ArraySize(statMutex) );ÙB  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()ÙE                                           : sqlite3MallocMutex()) );Ù'  assert( op==SQLITE_STATUS_MALLOC_SIZEÙ-          || op==SQLITE_STATUS_PAGECACHE_SIZEÙ.          || op==SQLITE_STATUS_PARSER_STACK );Ù%  if( newValue>wsdStat.mxValue[op] ){Ù#    wsdStat.mxValue[op] = newValue;£  }¡} ¢/*¼** Query status information.¢*/Ù SQLITE_API int sqlite3_status64(©  int op,º  sqlite3_int64 *pCurrent,¼  sqlite3_int64 *pHighwater,¯  int resetFlag¢){¸  sqlite3_mutex *pMutex;®  wsdStatInit;Ù0  if( op<0 || op>=ArraySize(wsdStat.nowValue) ){¾    return SQLITE_MISUSE_BKPT;£  }¾#ifdef SQLITE_ENABLE_API_ARMORÙ?  if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;¦#endifÙH  pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();¾  sqlite3_mutex_enter(pMutex);Ù#  *pCurrent = wsdStat.nowValue[op];Ù$  *pHighwater = wsdStat.mxValue[op];²  if( resetFlag ){Ù/    wsdStat.mxValue[op] = wsdStat.nowValue[op];£  }¾  sqlite3_mutex_leave(pMutex);Ù?  (void)pMutex;  /* Prevent warning when SQLITE_THREADSAFE=0 */³  return SQLITE_OK;¡}ÙUSQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){Ù$  sqlite3_int64 iCur = 0, iHwtr = 0;©  int rc;¾#ifdef SQLITE_ENABLE_API_ARMORÙ?  if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;¦#endifÙ6  rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);®  if( rc==0 ){º    *pCurrent = (int)iCur;½    *pHighwater = (int)iHwtr;£  }¬  return rc;¡} ¢/*ÙA** Return the number of LookasideSlot elements on the linked list¢*/Ù1static u32 countLookasideSlots(LookasideSlot *p){®  u32 cnt = 0;­  while( p ){±    p = p->pNext;ª    cnt++;£  }­  return cnt;¡} ¢/*ÙE** Count the number of slots of lookaside memory that are outstanding¢*/ÙFSQLITE_PRIVATE int sqlite3LookasideUsed(sqlite3 *db, int *pHighwater){Ù7  u32 nInit = countLookasideSlots(db->lookaside.pInit);Ù7  u32 nFree = countLookasideSlots(db->lookaside.pFree);Ù=  if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;Ù-  return db->lookaside.nSlot - (nInit+nFree);¡} ¢/*Ù<** Query status information for a single database connection¢*/Ù!SQLITE_API int sqlite3_db_status(ÙM  sqlite3 *db,          /* The database connection whose status is desired */Ù)  int op,               /* Status verb */Ù6  int *pCurrent,        /* Write current value here */Ù8  int *pHighwater,      /* Write high-water mark here */Ù;  int resetFlag         /* Reset high-water mark if true */¢){Ù)  int rc = SQLITE_OK;   /* Return code */¾#ifdef SQLITE_ENABLE_API_ARMORÙA  if( !sqlite3SafetyCheckOk(db) || pCurrent==0|| pHighwater==0 ){¾    return SQLITE_MISUSE_BKPT;£  }¦#endifÙ!  sqlite3_mutex_enter(db->mutex);¯  switch( op ){Ù*    case SQLITE_DBSTATUS_LOOKASIDE_USED: {Ù7      *pCurrent = sqlite3LookasideUsed(db, pHighwater);¶      if( resetFlag ){Ù/        LookasideSlot *p = db->lookaside.pFree;°        if( p ){Ù)          while( p->pNext ) p = p->pNext;Ù)          p->pNext = db->lookaside.pInit;Ù4          db->lookaside.pInit = db->lookaside.pFree;Ù"          db->lookaside.pFree = 0;©        }§      }¬      break;¥    } Ù'    case SQLITE_DBSTATUS_LOOKASIDE_HIT:Ù-    case SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE:Ù/    case SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: {Ù4      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_HIT );Ù:      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE );Ù:      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL );Ù6      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 );Ù5      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 );´      *pCurrent = 0;ÙM      *pHighwater = db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT];¶      if( resetFlag ){ÙE        db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT] = 0;§      }¬      break;¥    } §    /* ÙF    ** Return an approximation for the amount of memory currently usedÙH    ** by all pagers associated with the given database connection.  TheÙ=    ** highwater mark is meaningless and is returned as zero.¦    */Ù+    case SQLITE_DBSTATUS_CACHE_USED_SHARED:Ù&    case SQLITE_DBSTATUS_CACHE_USED: {¸      int totalUsed = 0;¬      int i;¿      sqlite3BtreeEnterAll(db);¿      for(i=0; i<db->nDb; i++){Ù$        Btree *pBt = db->aDb[i].pBt;²        if( pBt ){Ù1          Pager *pPager = sqlite3BtreePager(pBt);Ù2          int nByte = sqlite3PagerMemUsed(pPager);Ù6          if( op==SQLITE_DBSTATUS_CACHE_USED_SHARED ){Ù=            nByte = nByte / sqlite3BtreeConnectionCount(pBt);«          }½          totalUsed += nByte;©        }§      }¿      sqlite3BtreeLeaveAll(db);¼      *pCurrent = totalUsed;¶      *pHighwater = 0;¬      break;¥    } ¦    /*ÙG    ** *pCurrent gets an accurate estimate of the amount of memory usedÙJ    ** to store the schema for all databases (main, temp, and any ATTACHedÙ.    ** databases.  *pHighwater is set to zero.¦    */Ù'    case SQLITE_DBSTATUS_SCHEMA_USED: {ÙG      int i;                      /* Used to iterate through schemas */ÙG      int nByte = 0;              /* Used to accumulate return value */ ¿      sqlite3BtreeEnterAll(db);Ù       db->pnBytesFreed = &nByte;¿      for(i=0; i<db->nDb; i++){Ù-        Schema *pSchema = db->aDb[i].pSchema;Ù!        if( ALWAYS(pSchema!=0) ){¶          HashElem *p; ÙG          nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (Ù%              pSchema->tblHash.count Ù%            + pSchema->trigHash.countÙ$            + pSchema->idxHash.countÙ%            + pSchema->fkeyHash.count¬          );Ù6          nByte += sqlite3_msize(pSchema->tblHash.ht);Ù7          nByte += sqlite3_msize(pSchema->trigHash.ht);Ù6          nByte += sqlite3_msize(pSchema->idxHash.ht);Ù7          nByte += sqlite3_msize(pSchema->fkeyHash.ht); ÙM          for(p=sqliteHashFirst(&pSchema->trigHash); p; p=sqliteHashNext(p)){ÙB            sqlite3DeleteTrigger(db, (Trigger*)sqliteHashData(p));«          }ÙL          for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){Ù?            sqlite3DeleteTable(db, (Table *)sqliteHashData(p));«          }©        }§      }»      db->pnBytesFreed = 0;¿      sqlite3BtreeLeaveAll(db); ¶      *pHighwater = 0;¸      *pCurrent = nByte;¬      break;¥    } ¦    /*ÙG    ** *pCurrent gets an accurate estimate of the amount of memory usedÙ(    ** to store all prepared statements.Ù"    ** *pHighwater is set to zero.¦    */Ù%    case SQLITE_DBSTATUS_STMT_USED: {ÙC      struct Vdbe *pVdbe;         /* Used to iterate through VMs */ÙG      int nByte = 0;              /* Used to accumulate return value */ Ù       db->pnBytesFreed = &nByte;Ù6      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){Ù*        sqlite3VdbeClearObject(db, pVdbe);Ù!        sqlite3DbFree(db, pVdbe);§      }»      db->pnBytesFreed = 0; Ù0      *pHighwater = 0;  /* IMP: R-64479-57858 */¸      *pCurrent = nByte; ¬      break;¥    } ¦    /*ÙI    ** Set *pCurrent to the total cache hits or misses encountered by allÙM    ** pagers the database handle is connected to. *pHighwater is always set ¯    ** to zero.¦    */Ù%    case SQLITE_DBSTATUS_CACHE_SPILL:Ù)      op = SQLITE_DBSTATUS_CACHE_WRITE+1;Ù+      /* Fall through into the next case */Ù#    case SQLITE_DBSTATUS_CACHE_HIT:Ù$    case SQLITE_DBSTATUS_CACHE_MISS:Ù&    case SQLITE_DBSTATUS_CACHE_WRITE:{¬      int i;³      int nRet = 0;ÙH      assert( SQLITE_DBSTATUS_CACHE_MISS==SQLITE_DBSTATUS_CACHE_HIT+1 );ÙI      assert( SQLITE_DBSTATUS_CACHE_WRITE==SQLITE_DBSTATUS_CACHE_HIT+2 ); ¿      for(i=0; i<db->nDb; i++){½        if( db->aDb[i].pBt ){Ù<          Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);Ù>          sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);©        }§      }Ù/      *pHighwater = 0; /* IMP: R-42420-56072 */Ù/                       /* IMP: R-54100-20147 */Ù/                       /* IMP: R-29431-39229 */·      *pCurrent = nRet;¬      break;¥    } ÙI    /* Set *pCurrent to non-zero if there are unresolved deferred foreignÙM    ** key constraints.  Set *pCurrent to zero if all foreign key constraintsÙC    ** have been satisfied.  The *pHighwater is always set to zero.¦    */Ù(    case SQLITE_DBSTATUS_DEFERRED_FKS: {Ù0      *pHighwater = 0;  /* IMP: R-11967-56545 */Ù@      *pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;¬      break;¥    } ®    default: {¸      rc = SQLITE_ERROR;¥    }£  }Ù!  sqlite3_mutex_leave(db->mutex);¬  return rc;¡} ÙO/************** End of status.c **********************************************/ÙO/************** Begin file date.c ********************************************/¢/*²** 2003 October 31¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙB** This file contains the C functions that implement date and timeº** functions for SQLite.  ¢**Ù@** There is only one exported symbol in this file - the functionÙF** sqlite3RegisterDateTimeFunctions() found at the bottom of the file.Ù!** All other code has file scope.¢**ÙC** SQLite processes all times and dates as julian day numbers.  TheÙ>** dates and times are stored as the number of days since noonÙD** in Greenwich on November 24, 4714 B.C. according to the Gregorian´** calendar system. ¢**Ù&** 1970-01-01 00:00:00 is JD 2440587.5Ù&** 2000-01-01 00:00:00 is JD 2451544.5¢**ÙI** This implementation requires years to be expressed as a 4-digit numberÙD** which means that only dates between 0000-01-01 and 9999-12-31 canÙD** be represented, even though julian day numbers allow a much wider²** range of dates.¢**ÙA** The Gregorian calendar system is used for all dates and times,ÙF** even those that predate the Gregorian calendar.  Historians usuallyÙE** use the julian calendar for dates prior to 1582-10-15 and for someÙE** dates afterwards, depending on locale.  Beware of this difference.¢**ÙB** The conversion algorithms are implemented based on descriptions¹** in the following text:¢**²**      Jean MeeusÙ2**      Astronomical Algorithms, 2nd Edition, 1998º**      ISBN 0-943396-61-1º**      Willmann-Bell, IncÙ **      Richmond, Virginia (USA)¢*/¼/* #include "sqliteInt.h" */¹/* #include <stdlib.h> */¹/* #include <assert.h> */±#include <time.h> Ù"#ifndef SQLITE_OMIT_DATETIME_FUNCS ¢/*ÙB** The MSVC CRT on Windows CE may not have a localtime() function.Ù>** So declare a substitute.  The substitute function itself is¹** defined in "os_win.c".¢*/Ù?#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) && \ÙG    (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)Ù-struct tm *__cdecl localtime(const time_t *);¦#endif ¢/*Ù2** A structure for holding a single date and time.¢*/Ù!typedef struct DateTime DateTime;±struct DateTime {Ù@  sqlite3_int64 iJD;  /* The julian day number times 86400000 */Ù0  int Y, M, D;        /* Year, month, and day */Ù,  int h, m;           /* Hour and minutes */Ù6  int tz;             /* Timezone offset in minutes */Ù#  double s;           /* Seconds */Ù4  char validJD;       /* True (1) if iJD is valid */Ù9  char rawS;          /* Raw numeric value stored in s */Ù7  char validYMD;      /* True (1) if Y,M,D are valid */Ù7  char validHMS;      /* True (1) if h,m,s are valid */Ù3  char validTZ;       /* True (1) if tz is valid */Ù7  char tzSet;         /* Timezone was set explicitly */Ù4  char isError;       /* An overflow has occurred */¢};  ¢/*ÙF** Convert zDate into one or more integers according to the conversionµ** specifier zFormat.¢**ÙI** zFormat[] contains 4 characters for each integer converted, except forÙH** the last integer which is specified by three characters.  The meaningÙ1** of a four-character format specifiers ABCD is:¢**Ù;**    A:   number of digits to convert.  Always "2" or "4".Ù-**    B:   minimum value.  Always "0" or "1".Ù%**    C:   maximum value, decoded as:³**           a:  12³**           b:  14³**           c:  24³**           d:  31³**           e:  59µ**           f:  9999ÙC**    D:   the separator character, or \000 to indicate this is theÙ"**         last number to convert.¢**ÙG** Example:  To translate an ISO-8601 date YYYY-MM-DD, the format wouldÙL** be "40f-21a-20c".  The "40f-" indicates the 4-digit year followed by "-".ÙO** The "21a-" indicates the 2-digit month followed by "-".  The "20c" indicatesÙ8** the 2-digit day which is the last integer in the set.¢**Ù=** The function returns the number of successful conversions.¢*/ÙBstatic int getDigits(const char *zDate, const char *zFormat, ...){Ù@  /* The aMx[] array translates the 3rd character of each formatÙ8  ** spec into a max size:    a   b   c   d   e     f */Ù8  static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };­  va_list ap;®  int cnt = 0;­  char nextC;¸  va_start(ap, zFormat);¥  do{¾    char N = zFormat[0] - '0';Ù     char min = zFormat[1] - '0';°    int val = 0;¬    u16 max; Ù1    assert( zFormat[2]>='a' && zFormat[2]<='f' );Ù     max = aMx[zFormat[2] - 'a'];·    nextC = zFormat[3];¬    val = 0;±    while( N-- ){Ù$      if( !sqlite3Isdigit(*zDate) ){»        goto end_getDigits;§      }Ù"      val = val*10 + *zDate - '0';®      zDate++;¥    }ÙF    if( val<(int)min || val>(int)max || (nextC!=0 && nextC!=*zDate) ){¹      goto end_getDigits;¥    }»    *va_arg(ap,int*) = val;¬    zDate++;ª    cnt++;±    zFormat += 4;²  }while( nextC );®end_getDigits:­  va_end(ap);­  return cnt;¡} ¢/*Ù8** Parse a timezone extension on the end of a date-time.Ù ** The extension is of the form:¢**´**        (+/-)HH:MM¢**º** Or the "zulu" notation:¢**«**        Z¢**Ù:** If the parse is successful, write the number of minutesÙ>** of change in p->tz and return 0.  If a parser error occurs,³** return non-zero.¢**Ù2** A missing specifier is not considered an error.¢*/Ù9static int parseTimezone(const char *zDate, DateTime *p){®  int sgn = 0;¯  int nHr, nMn;¨  int c;Ù-  while( sqlite3Isspace(*zDate) ){ zDate++; }¬  p->tz = 0;­  c = *zDate;¯  if( c=='-' ){­    sgn = -1;µ  }else if( c=='+' ){­    sgn = +1;¿  }else if( c=='Z' || c=='z' ){¬    zDate++;³    goto zulu_time;¨  }else{°    return c!=0;£  }ª  zDate++;Ù3  if( getDigits(zDate, "20b:20e", &nHr, &nMn)!=2 ){­    return 1;£  }­  zDate += 5;½  p->tz = sgn*(nMn + nHr*60);ªzulu_time:Ù-  while( sqlite3Isspace(*zDate) ){ zDate++; }¯  p->tzSet = 1;³  return *zDate!=0;¡} ¢/*Ù>** Parse times of the form HH:MM or HH:MM:SS or HH:MM:SS.FFFF.Ù9** The HH, MM, and SS must each be exactly 2 digits.  TheÙ5** fractional seconds FFFF can be one or more digits.¢**Ù9** Return 1 if there is a parsing error and 0 on success.¢*/Ù7static int parseHhMmSs(const char *zDate, DateTime *p){®  int h, m, s;²  double ms = 0.0;Ù/  if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){­    return 1;£  }­  zDate += 5;´  if( *zDate==':' ){¬    zDate++;Ù)    if( getDigits(zDate, "20e", &s)!=1 ){¯      return 1;¥    }¯    zDate += 2;Ù2    if( *zDate=='.' && sqlite3Isdigit(zDate[1]) ){º      double rScale = 1.0;®      zDate++;Ù&      while( sqlite3Isdigit(*zDate) ){Ù$        ms = ms*10.0 + *zDate - '0';·        rScale *= 10.0;°        zDate++;§      }³      ms /= rScale;¥    }¨  }else{ª    s = 0;£  }±  p->validJD = 0;®  p->rawS = 0;²  p->validHMS = 1;«  p->h = h;«  p->m = m;°  p->s = s + ms;Ù)  if( parseTimezone(zDate, p) ) return 1;¾  p->validTZ = (p->tz!=0)?1:0;«  return 0;¡} ¢/*Ù0** Put the DateTime object into its error state.¢*/Ù'static void datetimeError(DateTime *p){»  memset(p, 0, sizeof(*p));±  p->isError = 1;¡} ¢/*ÙD** Convert from YYYY-MM-DD HH:MM:SS to julian day.  We always assumeÙ>** that the YYYY-MM-DD is according to the Gregorian calendar.¢**¼** Reference:  Meeus page 61¢*/Ù#static void computeJD(DateTime *p){¼  int Y, M, D, A, B, X1, X2; º  if( p->validJD ) return;´  if( p->validYMD ){­    Y = p->Y;­    M = p->M;­    D = p->D;¨  }else{Ù<    Y = 2000;  /* If no YMD specified, assume 2000-Jan-01 */ª    M = 1;ª    D = 1;£  }Ù%  if( Y<-4713 || Y>9999 || p->rawS ){µ    datetimeError(p);«    return;£  }­  if( M<=2 ){¨    Y--;¬    M += 12;£  }¬  A = Y/100;´  B = 2 - A + (A/4);º  X1 = 36525*(Y+4716)/100;º  X2 = 306001*(M+1)/10000;ÙC  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);±  p->validJD = 1;´  if( p->validHMS ){ÙE    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);µ    if( p->validTZ ){¼      p->iJD -= p->tz*60000;¶      p->validYMD = 0;¶      p->validHMS = 0;µ      p->validTZ = 0;¥    }£  }¡} ¢/*º** Parse dates of the form¢**¾**     YYYY-MM-DD HH:MM:SS.FFFº**     YYYY-MM-DD HH:MM:SS·**     YYYY-MM-DD HH:MM±**     YYYY-MM-DD¢**Ù<** Write the result into the DateTime structure and return 0Ù<** on success and 1 if the input string is not a well-formed¨** date.¢*/Ù9static int parseYyyyMmDd(const char *zDate, DateTime *p){³  int Y, M, D, neg; ¶  if( zDate[0]=='-' ){¬    zDate++;¬    neg = 1;¨  }else{¬    neg = 0;£  }Ù7  if( getDigits(zDate, "40f-21a-21d", &Y, &M, &D)!=3 ){­    return 1;£  }®  zDate += 10;ÙA  while( sqlite3Isspace(*zDate) || 'T'==*(u8*)zDate ){ zDate++; }Ù!  if( parseHhMmSs(zDate, p)==0 ){¹    /* We got the time */¸  }else if( *zDate==0 ){´    p->validHMS = 0;¨  }else{­    return 1;£  }±  p->validJD = 0;²  p->validYMD = 1;¶  p->Y = neg ? -Y : Y;«  p->M = M;«  p->D = D;³  if( p->validTZ ){±    computeJD(p);£  }«  return 0;¡} ¢/*Ù8** Set the time to the current time reported by the VFS.¢**¿** Return the number of errors.¢*/ÙGstatic int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){Ù+  p->iJD = sqlite3StmtCurrentTime(context);±  if( p->iJD>0 ){³    p->validJD = 1;­    return 0;¨  }else{­    return 1;£  }¡} ¢/*ÙF** Input "r" is a numeric quantity which might be a julian day number,ÙD** or the number of seconds since 1970.  If the value if r is withinÙD** range of a julian day number, install it as such and set validJD.ÙJ** If the value is a valid unix timestamp, put it in p->s and set p->rawS.¢*/Ù4static void setRawDateNumber(DateTime *p, double r){«  p->s = r;®  p->rawS = 1;¾  if( r>=0.0 && r<5373484.5 ){Ù1    p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);³    p->validJD = 1;£  }¡} ¢/*ÙF** Attempt to parse the given string into a julian day number.  Return¸** the number of errors.¢**Ù;** The following are acceptable forms for the input string:¢**Ù)**      YYYY-MM-DD HH:MM:SS.FFF  +/-HH:MM°**      DDDD.DD «**      now¢**ÙF** In the first form, the +/-HH:MM is always optional.  The fractionalÙC** seconds extension (the ".FFF") is optional.  The seconds portionÙC** (":SS.FFF") is option.  The year and date can be omitted as longÙE** as there is a time string.  The time string can be omitted as long¿** as there is a year and date.¢*/»static int parseDateOrTime(¼  sqlite3_context *context, µ  const char *zDate, ­  DateTime *p¢){«  double r;Ù"  if( parseYyyyMmDd(zDate,p)==0 ){­    return 0;Ù'  }else if( parseHhMmSs(zDate, p)==0 ){­    return 0;ÙL  }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){Ù,    return setDateTimeToCurrent(context, p);ÙJ  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8) ){»    setRawDateNumber(p, r);­    return 0;£  }«  return 1;¡} ÙH/* The julian day number for 9999-12-31 23:59:59.999 is 5373484.4999999.ÙJ** Multiplying this by 86400000 gives 464269060799999 as the maximum value´** for DateTime.iJD.¢**ÙK** But some older compilers (ex: gcc 4.2.1 on older Macs) cannot deal with Ù9** such a large integer literal, so we have to encode it.¢*/Ù>#define INT_464269060799999  ((((i64)0x1a640)<<32)|0x1072fdff) ¢/*Ù>** Return TRUE if the given julian day number is within range.¢**Ù-** The input is the JulianDay times 86400000.¢*/Ù-static int validJulianDay(sqlite3_int64 iJD){Ù,  return iJD>=0 && iJD<=INT_464269060799999;¡} ¢/*Ù?** Compute the Year, Month, and Day from the julian day number.¢*/Ù$static void computeYMD(DateTime *p){»  int Z, A, B, C, D, E, X1;»  if( p->validYMD ) return;´  if( !p->validJD ){°    p->Y = 2000;­    p->M = 1;­    p->D = 1;Ù&  }else if( !validJulianDay(p->iJD) ){µ    datetimeError(p);«    return;¨  }else{Ù,    Z = (int)((p->iJD + 43200000)/86400000);Ù)    A = (int)((Z - 1867216.25)/36524.25);º    A = Z + 1 + A - (A/4);±    B = A + 1524;Ù"    C = (int)((B - 122.1)/365.25);¾    D = (36525*(C&32767))/100;½    E = (int)((B-D)/30.6001);º    X1 = (int)(30.6001*E);¶    p->D = B - D - X1;½    p->M = E<14 ? E-1 : E-13;Ù(    p->Y = p->M>2 ? C - 4716 : C - 4715;£  }²  p->validYMD = 1;¡} ¢/*ÙD** Compute the Hour, Minute, and Seconds from the julian day number.¢*/Ù$static void computeHMS(DateTime *p){¨  int s;»  if( p->validHMS ) return;¯  computeJD(p);Ù,  s = (int)((p->iJD + 43200000) % 86400000);²  p->s = s/1000.0;°  s = (int)p->s;¬  p->s -= s;°  p->h = s/3600;±  s -= p->h*3600;®  p->m = s/60;¶  p->s += s - p->m*60;®  p->rawS = 0;²  p->validHMS = 1;¡} ¢/*»** Compute both YMD and HMS¢*/Ù(static void computeYMD_HMS(DateTime *p){°  computeYMD(p);°  computeHMS(p);¡} ¢/*Ù#** Clear the YMD and HMS and the TZ¢*/Ù)static void clearYMD_HMS_TZ(DateTime *p){²  p->validYMD = 0;²  p->validHMS = 0;±  p->validTZ = 0;¡} ½#ifndef SQLITE_OMIT_LOCALTIME¢/*ÙG** On recent Windows platforms, the localtime_s() function is availableÙ@** as part of the "Secure CRT". It is essentially equivalent to ÙG** localtime_r() available under most POSIX platforms, except that the Ù'** order of the parameters is reversed.¢**ÙD** See http://msdn.microsoft.com/en-us/library/a442x3ye(VS.80).aspx.¢**ÙF** If the user has not indicated to use localtime_r() or localtime_s()Ù>** already, check for an MSVC build environment that provides ±** localtime_s().¢*/Ù,#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S \Ù<    && defined(_MSC_VER) && defined(_CRT_INSECURE_DEPRECATE)¸#undef  HAVE_LOCALTIME_Sº#define HAVE_LOCALTIME_S 1¦#endif ¢/*ÙI** The following routine implements the rough equivalent of localtime_r()ÙC** using whatever operating-system specific localtime facility thatÙ7** is available.  This routine returns 0 on success andÙ!** non-zero on any kind of error.¢**ÙH** If the sqlite3GlobalConfig.bLocaltimeFault variable is true then this¼** routine will always fail.¢**ÙD** EVIDENCE-OF: R-62172-00036 In this implementation, the standard CÙI** library function localtime_r() is used to assist in the calculation of®** local time.¢*/Ù2static int osLocaltime(time_t *t, struct tm *pTm){©  int rc;Ù*#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S°  struct tm *pX;·#if SQLITE_THREADSAFE>0ÙG  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);¦#endif½  sqlite3_mutex_enter(mutex);´  pX = localtime(t);¹#ifndef SQLITE_UNTESTABLEÙ3  if( sqlite3GlobalConfig.bLocaltimeFault ) pX = 0;¦#endif¶  if( pX ) *pTm = *pX;½  sqlite3_mutex_leave(mutex);­  rc = pX==0;¥#else¹#ifndef SQLITE_UNTESTABLEÙ5  if( sqlite3GlobalConfig.bLocaltimeFault ) return 1;¦#endif´#if HAVE_LOCALTIME_R¾  rc = localtime_r(t, pTm)==0;¥#else»  rc = localtime_s(pTm, t);½#endif /* HAVE_LOCALTIME_R */Ù1#endif /* HAVE_LOCALTIME_R || HAVE_LOCALTIME_S */¬  return rc;¡}Ù"#endif /* SQLITE_OMIT_LOCALTIME */  ½#ifndef SQLITE_OMIT_LOCALTIME¢/*ÙE** Compute the difference (in milliseconds) between localtime and UTCÙK** (a.k.a. GMT) for the time value p where p is in UTC. If no error occurs,Ù0** return this value and set *pRc to SQLITE_OK. ¢**ÙK** Or, if an error does occur, set *pRc to SQLITE_ERROR. The returned value½** is undefined in this case.¢*/Ù%static sqlite3_int64 localtimeOffset(ÙI  DateTime *p,                    /* Date at which to calculate offset */ÙF  sqlite3_context *pCtx,          /* Write error here if one occurs */ÙK  int *pRc                        /* OUT: Error code. SQLITE_OK or ERROR */¢){°  DateTime x, y;«  time_t t;³  struct tm sLocal; ÙF  /* Initialize the contents of sLocal to avoid a compiler warning. */Ù%  memset(&sLocal, 0, sizeof(sLocal)); ©  x = *p;µ  computeYMD_HMS(&x);¾  if( x.Y<1971 || x.Y>=2038 ){ÙL    /* EVIDENCE-OF: R-55269-29598 The localtime_r() C function normally onlyÙK    ** works for years between 1970 and 2037. For dates outside this range,ÙJ    ** SQLite attempts to map the year into an equivalent year within thisÙ9    ** range, do the calculation, then map the year back.¦    */¯    x.Y = 2000;¬    x.M = 1;¬    x.D = 1;¬    x.h = 0;¬    x.m = 0;®    x.s = 0.0;ª  } else {½    int s = (int)(x.s + 0.5);¬    x.s = s;£  }«  x.tz = 0;°  x.validJD = 0;°  computeJD(&x);Ù1  t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);Ù!  if( osLocaltime(&t, &sLocal) ){Ù=    sqlite3_result_error(pCtx, "local time unavailable", -1);¸    *pRc = SQLITE_ERROR;­    return 0;£  }¾  y.Y = sLocal.tm_year + 1900;º  y.M = sLocal.tm_mon + 1;·  y.D = sLocal.tm_mday;·  y.h = sLocal.tm_hour;¶  y.m = sLocal.tm_min;¶  y.s = sLocal.tm_sec;±  y.validYMD = 1;±  y.validHMS = 1;°  y.validJD = 0;­  y.rawS = 0;°  y.validTZ = 0;°  y.isError = 0;°  computeJD(&y);³  *pRc = SQLITE_OK;·  return y.iJD - x.iJD;¡}Ù"#endif /* SQLITE_OMIT_LOCALTIME */ ¢/*ÙG** The following table defines various date transformations of the form¢**¸**            'NNN days'¢**ÙH** Where NNN is an arbitrary floating-point number and "days" can be one¼** of several units of time.¢*/µstatic const struct {Ù4  u8 eType;           /* Transformation type code */Ù-  u8 nName;           /* Length of th name */Ù6  char *zName;        /* Name of the transformation */Ù@  double rLimit;      /* Maximum NNN value for this transform */Ù<  double rXform;      /* Constant used for this transform */²} aXformType[] = {ÙB  { 0, 6, "second", 464269060800.0, 86400000.0/(24.0*60.0*60.0) },ÙB  { 0, 6, "minute", 7737817680.0,   86400000.0/(24.0*60.0)      },ÙB  { 0, 4, "hour",   128963628.0,    86400000.0/24.0             },ÙB  { 0, 3, "day",    5373485.0,      86400000.0                  },ÙB  { 1, 5, "month",  176546.0,       30.0*86400000.0             },ÙB  { 2, 4, "year",   14713.0,        365.0*86400000.0            },¢}; ¢/*Ù>** Process a modifier to a date-time stamp.  The modifiers are®** as follows:¢**¯**     NNN days°**     NNN hours²**     NNN minutes·**     NNN.NNNN seconds±**     NNN months°**     NNN yearsµ**     start of month´**     start of year´**     start of week³**     start of day°**     weekday N°**     unixepoch°**     localtimeª**     utc¢**ÙH** Return 0 on success and 1 if there is any kind of error. If the errorÙK** is in a system call (i.e. localtime()), then an error message is writtenÙI** to context pCtx. If the error is an unrecognized modifier, no error is³** written to pCtx.¢*/¹static int parseModifier(Ù4  sqlite3_context *pCtx,      /* Function context */Ù<  const char *z,              /* The text of the modifier */Ù;  int n,                      /* Length of zMod in bytes */ÙF  DateTime *p                 /* The date/time value to be modified */¢){­  int rc = 1;«  double r;Ù)  switch(sqlite3UpperToLower[(u8)z[0]] ){½#ifndef SQLITE_OMIT_LOCALTIME¯    case 'l': {µ      /*    localtime¨      **ÙI      ** Assuming the current time value is UTC (a.k.a. GMT), shift it to¹      ** show local time.¨      */ÙK      if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){µ        computeJD(p);Ù0        p->iJD += localtimeOffset(p, pCtx, &rc);»        clearYMD_HMS_TZ(p);§      }¬      break;¥    }¦#endif¯    case 'u': {¨      /*µ      **    unixepoch¨      **Ù9      ** Treat the current value of p->s as the number ofÙB      ** seconds since 1970.  Convert to a real julian day number.¨      */Ù:      if( sqlite3_stricmp(z, "unixepoch")==0 && p->rawS ){Ù,        r = p->s*1000.0 + 210866760000000.0;Ù,        if( r>=0.0 && r<464269060800000.0 ){½          clearYMD_HMS_TZ(p);Ù$          p->iJD = (sqlite3_int64)r;¹          p->validJD = 1;¶          p->rawS = 0;±          rc = 0;©        }§      }½#ifndef SQLITE_OMIT_LOCALTIMEÙJ      else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){º        if( p->tzSet==0 ){»          sqlite3_int64 c1;·          computeJD(p);Ù-          c1 = localtimeOffset(p, pCtx, &rc);¾          if( rc==SQLITE_OK ){¹            p->iJD -= c1;¿            clearYMD_HMS_TZ(p);Ù9            p->iJD += c1 - localtimeOffset(p, pCtx, &rc);«          }·          p->tzSet = 1;®        }else{¹          rc = SQLITE_OK;©        }§      }¦#endif¬      break;¥    }¯    case 'w': {¨      /*µ      **    weekday N¨      **ÙA      ** Move the date to the same time on the next occurrence ofÙD      ** weekday N where 0==Sunday, 1==Monday, and so forth.  If theÙE      ** date is already on the appropriate weekday, this is a no-op.¨      */Ù/      if( sqlite3_strnicmp(z, "weekday ", 8)==0ÙM               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)Ù1               && (n=(int)r)==r && n>=0 && r<7 ){¸        sqlite3_int64 Z;º        computeYMD_HMS(p);·        p->validTZ = 0;·        p->validJD = 0;µ        computeJD(p);Ù0        Z = ((p->iJD + 129600000)/86400000) % 7;¹        if( Z>n ) Z -= 7;Ù#        p->iJD += (n - Z)*86400000;»        clearYMD_HMS_TZ(p);¯        rc = 0;§      }¬      break;¥    }¯    case 's': {¨      /*º      **    start of TTTTT¨      **ÙE      ** Move the date backwards to the beginning of the current day,º      ** or month or year.¨      */Ù9      if( sqlite3_strnicmp(z, "start of ", 9)!=0 ) break;Ù>      if( !p->validJD && !p->validYMD && !p->validHMS ) break;­      z += 9;´      computeYMD(p);¶      p->validHMS = 1;¶      p->h = p->m = 0;±      p->s = 0.0;²      p->rawS = 0;µ      p->validTZ = 0;µ      p->validJD = 0;Ù*      if( sqlite3_stricmp(z,"month")==0 ){±        p->D = 1;¯        rc = 0;Ù/      }else if( sqlite3_stricmp(z,"year")==0 ){±        p->M = 1;±        p->D = 1;¯        rc = 0;Ù.      }else if( sqlite3_stricmp(z,"day")==0 ){¯        rc = 0;§      }¬      break;¥    }­    case '+':­    case '-':­    case '0':­    case '1':­    case '2':­    case '3':­    case '4':­    case '5':­    case '6':­    case '7':­    case '8':¯    case '9': {¶      double rRounder;¬      int i;ÙA      for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}Ù0      if( !sqlite3AtoF(z, &r, n, SQLITE_UTF8) ){¯        rc = 1;®        break;§      }¶      if( z[n]==':' ){ÙK        /* A modifier of the form (+|-)HH:MM:SS.FFF adds (or subtracts) theÙN        ** specified number of hours, minutes, seconds, and fractional secondsÙI        ** to the time.  The ".FFF" may be omitted.  The ":SS.FFF" may be³        ** omitted.ª        */»        const char *z2 = z;´        DateTime tx;º        sqlite3_int64 day;Ù(        if( !sqlite3Isdigit(*z2) ) z2++;Ù#        memset(&tx, 0, sizeof(tx));Ù)        if( parseHhMmSs(z2, &tx) ) break;·        computeJD(&tx);»        tx.iJD -= 43200000;¾        day = tx.iJD/86400000;¿        tx.iJD -= day*86400000;Ù)        if( z[0]=='-' ) tx.iJD = -tx.iJD;µ        computeJD(p);»        clearYMD_HMS_TZ(p);¹        p->iJD += tx.iJD;¯        rc = 0;®        break;§      } ÙF      /* If control reaches this point, it means the transformation isÙ/      ** one of the forms like "+NNN days".  */­      z += n;Ù&      while( sqlite3Isspace(*z) ) z++;½      n = sqlite3Strlen30(z);¾      if( n>10 || n<3 ) break;Ù5      if( sqlite3UpperToLower[(u8)z[n-1]]=='s' ) n--;³      computeJD(p);­      rc = 1;Ù#      rRounder = r<0 ? -0.5 : +0.5;Ù-      for(i=0; i<ArraySize(aXformType); i++){Ù"        if( aXformType[i].nName==nÙ:         && sqlite3_strnicmp(aXformType[i].zName, z, n)==0Ù=         && r>-aXformType[i].rLimit && r<aXformType[i].rLimitª        ){Ù(          switch( aXformType[i].eType ){Ù<            case 1: { /* Special processing to add months */´              int x;Ù               computeYMD_HMS(p);½              p->M += (int)r;Ù6              x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;¸              p->Y += x;»              p->M -= x*12;½              p->validJD = 0;º              r -= (int)r;´              break;­            }Ù;            case 2: { /* Special processing to add years */½              int y = (int)r;Ù               computeYMD_HMS(p);¸              p->Y += y;½              p->validJD = 0;º              r -= (int)r;´              break;­            }«          }·          computeJD(p);ÙG          p->iJD += (sqlite3_int64)(r*aXformType[i].rXform + rRounder);±          rc = 0;°          break;©        }§      }¹      clearYMD_HMS_TZ(p);¬      break;¥    }®    default: {¬      break;¥    }£  }¬  return rc;¡} ¢/*ÙB** Process time function arguments.  argv[0] is a date-time stamp.ÙA** argv[1] and following are modifiers.  Parse them all and writeÙ>** the resulting time into the DateTime structure p.  Return 0Ù,** on success and 1 if there are any errors.¢**Ù>** If there are zero parameters (if even argv[0] is undefined)Ù4** then assume a default value of "now" for argv[0].¢*/²static int isDate(¼  sqlite3_context *context, ¬  int argc, ¸  sqlite3_value **argv, ­  DateTime *p¢){«  int i, n;¹  const unsigned char *z;¬  int eType;»  memset(p, 0, sizeof(*p));°  if( argc==0 ){Ù,    return setDateTimeToCurrent(context, p);£  }Ù9  if( (eType = sqlite3_value_type(argv[0]))==SQLITE_FLOATÙ.                   || eType==SQLITE_INTEGER ){Ù7    setRawDateNumber(p, sqlite3_value_double(argv[0]));¨  }else{Ù$    z = sqlite3_value_text(argv[0]);Ù6    if( !z || parseDateOrTime(context, (char*)z, p) ){¯      return 1;¥    }£  }¸  for(i=1; i<argc; i++){Ù$    z = sqlite3_value_text(argv[i]);Ù%    n = sqlite3_value_bytes(argv[i]);ÙB    if( z==0 || parseModifier(context, (char*)z, n, p) ) return 1;£  }¯  computeJD(p);Ù7  if( p->isError || !validJulianDay(p->iJD) ) return 1;«  return 0;¡}  ¢/*ÙG** The following routines implement the various date and time functions­** of SQLite.¢*/ ¢/*Ù+**    julianday( TIMESTRING, MOD, MOD, ...)¢**ÙF** Return the julian day number of the date specified in the arguments¢*/ºstatic void juliandayFunc(»  sqlite3_context *context,«  int argc,¶  sqlite3_value **argv¢){­  DateTime x;Ù+  if( isDate(context, argc, argv, &x)==0 ){²    computeJD(&x);Ù5    sqlite3_result_double(context, x.iJD/86400000.0);£  }¡} ¢/*Ù***    datetime( TIMESTRING, MOD, MOD, ...)¢**½** Return YYYY-MM-DD HH:MM:SS¢*/¹static void datetimeFunc(»  sqlite3_context *context,«  int argc,¶  sqlite3_value **argv¢){­  DateTime x;Ù+  if( isDate(context, argc, argv, &x)==0 ){³    char zBuf[100];·    computeYMD_HMS(&x);ÙI    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",Ù:                     x.Y, x.M, x.D, x.h, x.m, (int)(x.s));Ù=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }¡} ¢/*Ù&**    time( TIMESTRING, MOD, MOD, ...)¢**²** Return HH:MM:SS¢*/µstatic void timeFunc(»  sqlite3_context *context,«  int argc,¶  sqlite3_value **argv¢){­  DateTime x;Ù+  if( isDate(context, argc, argv, &x)==0 ){³    char zBuf[100];³    computeHMS(&x);ÙO    sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);Ù=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }¡} ¢/*Ù&**    date( TIMESTRING, MOD, MOD, ...)¢**´** Return YYYY-MM-DD¢*/µstatic void dateFunc(»  sqlite3_context *context,«  int argc,¶  sqlite3_value **argv¢){­  DateTime x;Ù+  if( isDate(context, argc, argv, &x)==0 ){³    char zBuf[100];³    computeYMD(&x);ÙJ    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);Ù=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }¡} ¢/*Ù2**    strftime( FORMAT, TIMESTRING, MOD, MOD, ...)¢**Ù@** Return a string described by FORMAT.  Conversions as follows:¢**µ**   %d  day of monthÙ&**   %f  ** fractional seconds  SS.SSS³**   %H  hour 00-24¼**   %j  day of year 000-366½**   %J  ** julian day number´**   %m  month 01-12µ**   %M  minute 00-59Ù!**   %s  seconds since 1970-01-01¶**   %S  seconds 00-59Ù#**   %w  day of week 0-6  sunday==0»**   %W  week of year 00-53·**   %Y  year 0000-9999ª**   %%  %¢*/¹static void strftimeFunc(»  sqlite3_context *context,«  int argc,¶  sqlite3_value **argv¢){­  DateTime x;¨  u64 n;­  size_t i,j;ª  char *z;®  sqlite3 *db;³  const char *zFmt;±  char zBuf[100];·  if( argc==0 ) return;Ù2  zFmt = (const char*)sqlite3_value_text(argv[0]);Ù>  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;Ù*  db = sqlite3_context_db_handle(context);Ù#  for(i=0, n=1; zFmt[i]; i++, n++){·    if( zFmt[i]=='%' ){º      switch( zFmt[i+1] ){±        case 'd':±        case 'H':±        case 'm':±        case 'M':±        case 'S':±        case 'W':®          n++;¹          /* fall thru */±        case 'w':±        case '%':°          break;±        case 'f':±          n += 8;°          break;±        case 'j':±          n += 3;°          break;±        case 'Y':±          n += 8;°          break;±        case 's':±        case 'J':²          n += 50;°          break;°        default:Ù.          return;  /* ERROR.  return a NULL */§      }ª      i++;¥    }£  }Ù   testcase( n==sizeof(zBuf)-1 );¾  testcase( n==sizeof(zBuf) );Ù8  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );Ù6  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH] );·  if( n<sizeof(zBuf) ){­    z = zBuf;Ù5  }else if( n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH] ){Ù)    sqlite3_result_error_toobig(context);«    return;¨  }else{Ù)    z = sqlite3DbMallocRawNN(db, (int)n);¯    if( z==0 ){Ù*      sqlite3_result_error_nomem(context);­      return;¥    }£  }°  computeJD(&x);µ  computeYMD_HMS(&x);»  for(i=j=0; zFmt[i]; i++){·    if( zFmt[i]!='%' ){·      z[j++] = zFmt[i];ª    }else{ª      i++;¸      switch( zFmt[i] ){ÙF        case 'd':  sqlite3_snprintf(3, &z[j],"%02d",x.D); j+=2; break;³        case 'f': {¹          double s = x.s;Ù$          if( s>59.999 ) s = 59.999;Ù1          sqlite3_snprintf(7, &z[j],"%06.3f", s);Ù&          j += sqlite3Strlen30(&z[j]);°          break;©        }ÙF        case 'H':  sqlite3_snprintf(3, &z[j],"%02d",x.h); j+=2; break;Ù!        case 'W': /* Fall thru */³        case 'j': {ÙJ          int nDay;             /* Number of days since 1st day of year */¹          DateTime y = x;¸          y.validJD = 0;²          y.M = 1;²          y.D = 1;¸          computeJD(&y);Ù8          nDay = (int)((x.iJD-y.iJD+43200000)/86400000);½          if( zFmt[i]=='W' ){Ù=            int wd;   /* 0=Monday, 1=Tuesday, ... 6=Sunday */Ù6            wd = (int)(((x.iJD+43200000)/86400000)%7);Ù<            sqlite3_snprintf(3, &z[j],"%02d",(nDay+7-wd)/7);³            j += 2;°          }else{Ù5            sqlite3_snprintf(4, &z[j],"%03d",nDay+1);³            j += 3;«          }°          break;©        }³        case 'J': {Ù?          sqlite3_snprintf(20, &z[j],"%.16g",x.iJD/86400000.0);Ù$          j+=sqlite3Strlen30(&z[j]);°          break;©        }ÙF        case 'm':  sqlite3_snprintf(3, &z[j],"%02d",x.M); j+=2; break;ÙF        case 'M':  sqlite3_snprintf(3, &z[j],"%02d",x.m); j+=2; break;³        case 's': {Ù+          sqlite3_snprintf(30,&z[j],"%lld",ÙD                           (i64)(x.iJD/1000 - 21086676*(i64)10000));Ù&          j += sqlite3Strlen30(&z[j]);°          break;©        }ÙJ        case 'S':  sqlite3_snprintf(3,&z[j],"%02d",(int)x.s); j+=2; break;³        case 'w': {ÙB          z[j++] = (char)(((x.iJD+129600000)/86400000) % 7) + '0';°          break;©        }³        case 'Y': {ÙJ          sqlite3_snprintf(5,&z[j],"%04d",x.Y); j+=sqlite3Strlen30(&z[j]);°          break;©        }Ù'        default:   z[j++] = '%'; break;§      }¥    }£  }«  z[j] = 0;Ù%  sqlite3_result_text(context, z, -1,ÙC                      z==zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC);¡} ¢/*±** current_time()¢**Ù7** This function returns the same value as time('now').¢*/¶static void ctimeFunc(»  sqlite3_context *context,®  int NotUsed,º  sqlite3_value **NotUsed2¢){Ù'  UNUSED_PARAMETER2(NotUsed, NotUsed2);º  timeFunc(context, 0, 0);¡} ¢/*±** current_date()¢**Ù7** This function returns the same value as date('now').¢*/¶static void cdateFunc(»  sqlite3_context *context,®  int NotUsed,º  sqlite3_value **NotUsed2¢){Ù'  UNUSED_PARAMETER2(NotUsed, NotUsed2);º  dateFunc(context, 0, 0);¡} ¢/*¶** current_timestamp()¢**Ù;** This function returns the same value as datetime('now').¢*/»static void ctimestampFunc(»  sqlite3_context *context,®  int NotUsed,º  sqlite3_value **NotUsed2¢){Ù'  UNUSED_PARAMETER2(NotUsed, NotUsed2);¾  datetimeFunc(context, 0, 0);¡}Ù1#endif /* !defined(SQLITE_OMIT_DATETIME_FUNCS) */ Ù!#ifdef SQLITE_OMIT_DATETIME_FUNCS¢/*ÙB** If the library is compiled to omit the full-scale date and timeÙD** handling (to get a smaller binary), the following minimal versionÙJ** of the functions current_time(), current_date() and current_timestamp()ÙD** are included instead. This is to support column declarations thatÙ&** include "DEFAULT CURRENT_TIME" etc.¢**Ù>** This function uses the C-library functions time(), gmtime()ÙF** and strftime(). The format string to pass to strftime() is suppliedÙ%** as the user-data for the function.¢*/¼static void currentTimeFunc(»  sqlite3_context *context,«  int argc,¶  sqlite3_value **argv¢){«  time_t t;Ù5  char *zFormat = (char *)sqlite3_user_data(context);³  sqlite3_int64 iT;±  struct tm *pTm;±  struct tm sNow;°  char zBuf[20]; ¹  UNUSED_PARAMETER(argc);¹  UNUSED_PARAMETER(argv); Ù'  iT = sqlite3StmtCurrentTime(context);µ  if( iT<=0 ) return;Ù.  t = iT/1000 - 10000*(sqlite3_int64)21086676;±#if HAVE_GMTIME_R¼  pTm = gmtime_r(&t, &sNow);¥#elseÙE  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));³  pTm = gmtime(&t);Ù-  if( pTm ) memcpy(&sNow, pTm, sizeof(sNow));ÙE  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));¦#endif¬  if( pTm ){Ù'    strftime(zBuf, 20, zFormat, &sNow);Ù=    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);£  }¡}¦#endif ¢/*Ù?** This function registered all of the above C functions as SQLÙ@** functions.  This should be the only routine in this file with´** external linkage.¢*/Ù;SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){Ù%  static FuncDef aDateTimeFuncs[] = {Ù"#ifndef SQLITE_OMIT_DATETIME_FUNCSÙ:    PURE_DATE(julianday,        -1, 0, 0, juliandayFunc ),Ù:    PURE_DATE(date,             -1, 0, 0, dateFunc      ),Ù:    PURE_DATE(time,             -1, 0, 0, timeFunc      ),Ù:    PURE_DATE(datetime,         -1, 0, 0, datetimeFunc  ),Ù:    PURE_DATE(strftime,         -1, 0, 0, strftimeFunc  ),Ù:    DFUNCTION(current_time,      0, 0, 0, ctimeFunc     ),Ù:    DFUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),Ù:    DFUNCTION(current_date,      0, 0, 0, cdateFunc     ),¥#elseÙP    STR_FUNCTION(current_time,      0, "%H:%M:%S",          0, currentTimeFunc),ÙP    STR_FUNCTION(current_date,      0, "%Y-%m-%d",          0, currentTimeFunc),ÙP    STR_FUNCTION(current_timestamp, 0, "%Y-%m-%d %H:%M:%S", 0, currentTimeFunc),¦#endif¤  };ÙG  sqlite3InsertBuiltinFuncs(aDateTimeFuncs, ArraySize(aDateTimeFuncs));¡} ÙO/************** End of date.c ************************************************/ÙO/************** Begin file os.c **********************************************/¢/*³** 2005 November 29¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**Ù=** This file contains OS interface code that is common to all±** architectures.¢*/¼/* #include "sqliteInt.h" */ ¢/*ÙI** If we compile with the SQLITE_TEST macro set, then the following blockÙG** of code will give us the ability to simulate a disk I/O error.  ThisÙ.** is used for testing the I/O recovery logic.¢*/¸#if defined(SQLITE_TEST)ÙTSQLITE_API int sqlite3_io_error_hit = 0;            /* Total number of I/O Errors */ÙUSQLITE_API int sqlite3_io_error_hardhit = 0;        /* Number of non-benign errors */ÙWSQLITE_API int sqlite3_io_error_pending = 0;        /* Count down to first I/O error */ÙTSQLITE_API int sqlite3_io_error_persist = 0;        /* True if I/O errors persist */ÙSSQLITE_API int sqlite3_io_error_benign = 0;         /* True if errors are benign */Ù,SQLITE_API int sqlite3_diskfull_pending = 0;Ù$SQLITE_API int sqlite3_diskfull = 0;Ù!#endif /* defined(SQLITE_TEST) */ ¢/*Ù?** When testing, also keep a count of the number of open files.¢*/¸#if defined(SQLITE_TEST)Ù+SQLITE_API int sqlite3_open_file_count = 0;Ù!#endif /* defined(SQLITE_TEST) */ ¢/*ÙA** The default SQLite sqlite3_vfs implementations do not allocateÙA** memory (actually, os_unix.c allocates a small amount of memoryÙC** from within OsOpen()), but some third-party implementations may.ÙF** So we test the effects of a malloc() failing and the sqlite3OsXXX()ÙK** function returning SQLITE_IOERR_NOMEM using the DO_OS_MALLOC_TEST macro.¢**Ù@** The following functions are instrumented for malloc() failure«** testing:¢**¶**     sqlite3OsRead()·**     sqlite3OsWrite()¶**     sqlite3OsSync()º**     sqlite3OsFileSize()¶**     sqlite3OsLock()Ù#**     sqlite3OsCheckReservedLock()½**     sqlite3OsFileControl()¸**     sqlite3OsShmMap()¶**     sqlite3OsOpen()¸**     sqlite3OsDelete()¸**     sqlite3OsAccess()¾**     sqlite3OsFullPathname()¢**¢*/¸#if defined(SQLITE_TEST)Ù1SQLITE_API int sqlite3_memdebug_vfs_oom_test = 1;ÙF  #define DO_OS_MALLOC_TEST(x)                                       \ÙP  if (sqlite3_memdebug_vfs_oom_test && (!x || !sqlite3JournalIsInMemory(x))) { \ÙF    void *pTstAlloc = sqlite3Malloc(10);                             \ÙF    if (!pTstAlloc) return SQLITE_IOERR_NOMEM_BKPT;                  \ÙF    sqlite3_free(pTstAlloc);                                         \£  }¥#else¾  #define DO_OS_MALLOC_TEST(x)¦#endif ¢/*ÙA** The following routines are convenience wrappers around methodsÙH** of the sqlite3_file object.  This is mostly just syntactic sugar. AllÙC** of this would be completely automatic if SQLite were coded using¾** C++ instead of plain old C.¢*/Ù6SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file *pId){¶  if( pId->pMethods ){¿    pId->pMethods->xClose(pId);¶    pId->pMethods = 0;£  }¡}ÙTSQLITE_PRIVATE int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){¸  DO_OS_MALLOC_TEST(id);Ù4  return id->pMethods->xRead(id, pBuf, amt, offset);¡}Ù[SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){¸  DO_OS_MALLOC_TEST(id);Ù5  return id->pMethods->xWrite(id, pBuf, amt, offset);¡}ÙASQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file *id, i64 size){Ù+  return id->pMethods->xTruncate(id, size);¡}Ù>SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file *id, int flags){¸  DO_OS_MALLOC_TEST(id);Ù<  return flags ? id->pMethods->xSync(id, flags) : SQLITE_OK;¡}ÙCSQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){¸  DO_OS_MALLOC_TEST(id);Ù,  return id->pMethods->xFileSize(id, pSize);¡}ÙASQLITE_PRIVATE int sqlite3OsLock(sqlite3_file *id, int lockType){¸  DO_OS_MALLOC_TEST(id);Ù+  return id->pMethods->xLock(id, lockType);¡}ÙCSQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file *id, int lockType){Ù-  return id->pMethods->xUnlock(id, lockType);¡}ÙNSQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){¸  DO_OS_MALLOC_TEST(id);Ù7  return id->pMethods->xCheckReservedLock(id, pResOut);¡} ¢/*ÙI** Use sqlite3OsFileControl() when we are doing something that might failÙJ** and we need to know about the failures.  Use sqlite3OsFileControlHint()ÙI** when simply tossing information over the wall to the VFS and we do notÙK** really care if the VFS receives and understands the information since itÙL** is only a hint and can be safely ignored.  The sqlite3OsFileControlHint()ÙK** routine has no return value since the return value would be meaningless.¢*/ÙNSQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){Ù/  if( id->pMethods==0 ) return SQLITE_NOTFOUND;²#ifdef SQLITE_TESTÙ&  if( op!=SQLITE_FCNTL_COMMIT_PHASETWOÙ#   && op!=SQLITE_FCNTL_LOCK_TIMEOUT¤  ){ÙL    /* Faults are not injected into COMMIT_PHASETWO because, assuming SQLiteÙC    ** is using a regular VFS, it is called after the correspondingÙF    ** transaction has been committed. Injecting a fault at this pointÙI    ** confuses the test scripts - the COMMIT comand returns SQLITE_NOMEMÙ/    ** but the transaction is committed anyway.¦    **ÙJ    ** The core must call OsFileControl() though, not OsFileControlHint(),ÙJ    ** as if a custom VFS (e.g. zipvfs) returns an error here, it probablyÙI    ** means the commit really has failed and an error should be returned·    ** to the user.  */º    DO_OS_MALLOC_TEST(id);£  }¦#endifÙ2  return id->pMethods->xFileControl(id, op, pArg);¡}ÙSSQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){ÙD  if( id->pMethods ) (void)id->pMethods->xFileControl(id, op, pArg);¡} Ù9SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id){Ù@  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;ÙF  return (xSectorSize ? xSectorSize(id) : SQLITE_DEFAULT_SECTOR_SIZE);¡}ÙDSQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id){Ù2  return id->pMethods->xDeviceCharacteristics(id);¡}·#ifndef SQLITE_OMIT_WALÙTSQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){Ù6  return id->pMethods->xShmLock(id, offset, n, flags);¡}Ù:SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id){Ù   id->pMethods->xShmBarrier(id);¡}ÙGSQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){Ù1  return id->pMethods->xShmUnmap(id, deleteFlag);¡}Ù#SQLITE_PRIVATE int sqlite3OsShmMap(Ù<  sqlite3_file *id,               /* Database file handle */¬  int iPage,«  int pgsz,ÙH  int bExtend,                    /* True to extend file if necessary */Ù?  void volatile **pp              /* OUT: Pointer to mapping */¢){¸  DO_OS_MALLOC_TEST(id);Ù=  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);¡}¼#endif /* SQLITE_OMIT_WAL */ º#if SQLITE_MAX_MMAP_SIZE>0Ù4/* The real implementation of xFetch and xUnfetch */ÙSSQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){¸  DO_OS_MALLOC_TEST(id);Ù2  return id->pMethods->xFetch(id, iOff, iAmt, pp);¡}ÙISQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){Ù-  return id->pMethods->xUnfetch(id, iOff, p);¡}¥#elseÙ;/* No-op stubs to use when memory-mapped I/O is disabled */ÙSSQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){ª  *pp = 0;³  return SQLITE_OK;¡}ÙISQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){³  return SQLITE_OK;¡}¦#endif ¢/*ÙA** The next group of routines are convenience wrappers around the¯** VFS methods.¢*/Ù!SQLITE_PRIVATE int sqlite3OsOpen(´  sqlite3_vfs *pVfs,´  const char *zPath,¶  sqlite3_file *pFile,¬  int flags,°  int *pFlagsOut¢){©  int rc;·  DO_OS_MALLOC_TEST(0);ÙH  /* 0x87f7f is a mask of SQLITE_OPEN_ flags that are valid to be passedÙD  ** down into the VFS layer.  Some SQLITE_OPEN_ flags (for example,ÙI  ** SQLITE_OPEN_FULLMUTEX or SQLITE_OPEN_SHAREDCACHE) are blocked before¹  ** reaching the VFS. */ÙC  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x87f7f, pFlagsOut);Ù0  assert( rc==SQLITE_OK || pFile->pMethods==0 );¬  return rc;¡}ÙVSQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){·  DO_OS_MALLOC_TEST(0);Ù%  assert( dirSync==0 || dirSync==1 );Ù-  return pVfs->xDelete(pVfs, zPath, dirSync);¡}Ù#SQLITE_PRIVATE int sqlite3OsAccess(´  sqlite3_vfs *pVfs,´  const char *zPath,¬  int flags,®  int *pResOut¢){·  DO_OS_MALLOC_TEST(0);Ù4  return pVfs->xAccess(pVfs, zPath, flags, pResOut);¡}Ù)SQLITE_PRIVATE int sqlite3OsFullPathname(´  sqlite3_vfs *pVfs,´  const char *zPath,¯  int nPathOut,°  char *zPathOut¢){·  DO_OS_MALLOC_TEST(0);²  zPathOut[0] = 0;Ù>  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);¡}Ù"#ifndef SQLITE_OMIT_LOAD_EXTENSIONÙKSQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){Ù$  return pVfs->xDlOpen(pVfs, zPath);¡}ÙRSQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){Ù'  pVfs->xDlError(pVfs, nByte, zBufOut);¡}Ù^SQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){Ù)  return pVfs->xDlSym(pVfs, pHdle, zSym);¡}ÙGSQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){Ù   pVfs->xDlClose(pVfs, pHandle);¡}Ù'#endif /* SQLITE_OMIT_LOAD_EXTENSION */ÙTSQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){Ù1  return pVfs->xRandomness(pVfs, nByte, zBufOut);¡}ÙASQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){Ù$  return pVfs->xSleep(pVfs, nMicro);¡}Ù<SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs *pVfs){ÙC  return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0;¡}ÙYSQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){©  int rc;ÙM  /* IMPLEMENTATION-OF: R-49045-42493 SQLite will use the xCurrentTimeInt64()ÙH  ** method to get the current date and time if that method is availableÙK  ** (if iVersion is 2 or greater and the function pointer is not NULL) andÙ?  ** will fall back to xCurrentTime() if xCurrentTimeInt64() is±  ** unavailable.¤  */Ù5  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){Ù1    rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);¨  }else{­    double r;Ù&    rc = pVfs->xCurrentTime(pVfs, &r);Ù.    *pTimeOut = (sqlite3_int64)(r*86400000.0);£  }¬  return rc;¡} Ù'SQLITE_PRIVATE int sqlite3OsOpenMalloc(´  sqlite3_vfs *pVfs,´  const char *zFile,¸  sqlite3_file **ppFile,¬  int flags,°  int *pOutFlags¢){©  int rc;¶  sqlite3_file *pFile;Ù<  pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);®  if( pFile ){Ù=    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);¸    if( rc!=SQLITE_OK ){º      sqlite3_free(pFile);ª    }else{¶      *ppFile = pFile;¥    }¨  }else{»    rc = SQLITE_NOMEM_BKPT;£  }¬  return rc;¡}Ù<SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *pFile){²  assert( pFile );¸  sqlite3OsClose(pFile);¶  sqlite3_free(pFile);¡} ¢/*ÙF** This function is a wrapper around the OS specific implementation ofÙB** sqlite3_os_init(). The purpose of the wrapper is to provide theÙC** ability to simulate a malloc failure, so that the handling of anÙ@** error in sqlite3_os_init() by the upper layers can be tested.¢*/Ù'SQLITE_PRIVATE int sqlite3OsInit(void){¿  void *p = sqlite3_malloc(10);Ù&  if( p==0 ) return SQLITE_NOMEM_BKPT;²  sqlite3_free(p);»  return sqlite3_os_init();¡} ¢/*Ù2** The list of all registered VFS implementations.¢*/Ù,static sqlite3_vfs * SQLITE_WSD vfsList = 0;Ù.#define vfsList GLOBAL(sqlite3_vfs *, vfsList) ¢/*Ù@** Locate a VFS by name.  If no name is given, simply return the¹** first VFS on the list.¢*/Ù;SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){¸  sqlite3_vfs *pVfs = 0;µ#if SQLITE_THREADSAFE·  sqlite3_mutex *mutex;¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ   int rc = sqlite3_initialize();´  if( rc ) return 0;¦#endifµ#if SQLITE_THREADSAFEÙ8  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);¦#endif½  sqlite3_mutex_enter(mutex);Ù.  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){¸    if( zVfs==0 ) break;Ù-    if( strcmp(zVfs, pVfs->zName)==0 ) break;£  }½  sqlite3_mutex_leave(mutex);®  return pVfs;¡} ¢/*Ù$** Unlink a VFS from the linked list¢*/Ù)static void vfsUnlink(sqlite3_vfs *pVfs){ÙN  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) );°  if( pVfs==0 ){¯    /* No-op */¼  }else if( vfsList==pVfs ){º    vfsList = pVfs->pNext;¶  }else if( vfsList ){½    sqlite3_vfs *p = vfsList;Ù(    while( p->pNext && p->pNext!=pVfs ){³      p = p->pNext;¥    }¹    if( p->pNext==pVfs ){½      p->pNext = pVfs->pNext;¥    }£  }¡} ¢/*ÙG** Register a VFS with the system.  It is harmless to register the sameÙF** VFS multiple times.  The new VFS becomes the default if makeDflt is¨** true.¢*/ÙESQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){Ù$  MUTEX_LOGIC(sqlite3_mutex *mutex;)¼#ifndef SQLITE_OMIT_AUTOINITÙ   int rc = sqlite3_initialize();µ  if( rc ) return rc;¦#endif¾#ifdef SQLITE_ENABLE_API_ARMORÙ*  if( pVfs==0 ) return SQLITE_MISUSE_BKPT;¦#endif ÙG  MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )½  sqlite3_mutex_enter(mutex);²  vfsUnlink(pVfs);¿  if( makeDflt || vfsList==0 ){º    pVfs->pNext = vfsList;³    vfsList = pVfs;¨  }else{Ù!    pVfs->pNext = vfsList->pNext;º    vfsList->pNext = pVfs;£  }²  assert(vfsList);½  sqlite3_mutex_leave(mutex);³  return SQLITE_OK;¡} ¢/*Ù7** Unregister a VFS so that it is no longer accessible.¢*/Ù9SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){µ#if SQLITE_THREADSAFEÙG  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);¦#endif½  sqlite3_mutex_enter(mutex);²  vfsUnlink(pVfs);½  sqlite3_mutex_leave(mutex);³  return SQLITE_OK;¡} ÙO/************** End of os.c **************************************************/ÙO/************** Begin file fault.c *******************************************/¢/*®** 2008 Jan 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**Ù>** This file contains code to support the concept of "benign" ÙB** malloc failures (when the xMalloc() or xRealloc() method of theÙD** sqlite3_mem_methods structure fails to allocate a block of memory³** and returns 0). ¢**Ù@** Most malloc failures are non-benign. After they occur, SQLiteÙD** abandons the current operation and returns an error code (usuallyÙK** SQLITE_NOMEM) to the user. However, sometimes a fault is not necessarilyÙK** fatal. For example, if a malloc fails while resizing a hash table, this ÙH** is completely recoverable simply by not carrying out the resize. The ÙG** hash table will continue to function normally.  So a malloc failure Ù0** during a hash table resize is a benign fault.¢*/ ¼/* #include "sqliteInt.h" */ ¹#ifndef SQLITE_UNTESTABLE ¢/*´** Global variables.¢*/Ù3typedef struct BenignMallocHooks BenignMallocHooks;Ù,static SQLITE_WSD struct BenignMallocHooks {½  void (*xBenignBegin)(void);»  void (*xBenignEnd)(void);º} sqlite3Hooks = { 0, 0 }; ÙI/* The "wsdHooks" macro will resolve to the appropriate BenignMallocHooksÙD** structure.  If writable static data is unsupported on the target,ÙF** we have to locate the state vector at run-time.  In the more commonÙL** case where writable static data is supported, wsdHooks can refer directlyÙ5** to the "sqlite3Hooks" state vector declared above.¢*/¶#ifdef SQLITE_OMIT_WSD·# define wsdHooksInit \Ù@  BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)¶# define wsdHooks x[0]¥#elseµ# define wsdHooksInit¾# define wsdHooks sqlite3Hooks¦#endif  ¢/*Ù=** Register hooks to call when sqlite3BeginBenignMalloc() andÙ5** sqlite3EndBenignMalloc() are called, respectively.¢*/Ù-SQLITE_PRIVATE void sqlite3BenignMallocHooks(½  void (*xBenignBegin)(void),º  void (*xBenignEnd)(void)¢){¯  wsdHooksInit;Ù'  wsdHooks.xBenignBegin = xBenignBegin;Ù#  wsdHooks.xBenignEnd = xBenignEnd;¡} ¢/*ÙL** This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate thatÙL** subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()Ù<** indicates that subsequent malloc failures are non-benign.¢*/Ù3SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void){¯  wsdHooksInit;¾  if( wsdHooks.xBenignBegin ){¼    wsdHooks.xBenignBegin();£  }¡}Ù1SQLITE_PRIVATE void sqlite3EndBenignMalloc(void){¯  wsdHooksInit;¼  if( wsdHooks.xBenignEnd ){º    wsdHooks.xBenignEnd();£  }¡} Ù(#endif   /* #ifndef SQLITE_UNTESTABLE */ ÙO/************** End of fault.c ***********************************************/ÙO/************** Begin file mem0.c ********************************************/¢/*²** 2008 October 28¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙD** This file contains a no-op memory allocation drivers for use whenÙE** SQLITE_ZERO_MALLOC is defined.  The allocation drivers implementedÙH** here always fail.  SQLite will not operate with these drivers.  TheseÙC** are merely placeholders.  Real drivers must be substituted usingÙ/** sqlite3_config() before SQLite will operate.¢*/¼/* #include "sqliteInt.h" */ ¢/*Ù>** This version of the memory allocator is the default.  It isÙF** used when no other memory allocator is specified using compile-timeª** macros.¢*/¹#ifdef SQLITE_ZERO_MALLOC ¢/*Ù3** No-op versions of all memory allocation routines¢*/Ù5static void *sqlite3MemMalloc(int nByte){ return 0; }Ù3static void sqlite3MemFree(void *pPrior){ return; }ÙDstatic void *sqlite3MemRealloc(void *pPrior, int nByte){ return 0; }Ù4static int sqlite3MemSize(void *pPrior){ return 0; }Ù0static int sqlite3MemRoundup(int n){ return n; }Ù=static int sqlite3MemInit(void *NotUsed){ return SQLITE_OK; }Ù8static void sqlite3MemShutdown(void *NotUsed){ return; } ¢/*ÙG** This routine is the only routine in this file with external linkage.¢**Ù@** Populate the low-level memory allocation function pointers inÙD** sqlite3GlobalConfig.m with pointers to the routines in this file.¢*/Ù/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ù5  static const sqlite3_mem_methods defaultMethods = {¶     sqlite3MemMalloc,´     sqlite3MemFree,·     sqlite3MemRealloc,´     sqlite3MemSize,·     sqlite3MemRoundup,´     sqlite3MemInit,¸     sqlite3MemShutdown,¦     0¤  };Ù8  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);¡} ¿#endif /* SQLITE_ZERO_MALLOC */ ÙO/************** End of mem0.c ************************************************/ÙO/************** Begin file mem1.c ********************************************/¢/*±** 2007 August 14¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙB** This file contains low-level memory allocation drivers for whenÙG** SQLite will use the standard C-library malloc/realloc/free interfaceÙ!** to obtain the memory it needs.¢**ÙH** This file contains implementations of the low-level memory allocationÙH** routines specified in the sqlite3_mem_methods object.  The content ofÙB** this file is only used if SQLITE_SYSTEM_MALLOC is defined.  TheÙE** SQLITE_SYSTEM_MALLOC macro is defined automatically if neither theÙG** SQLITE_MEMDEBUG nor the SQLITE_WIN32_MALLOC macros are defined.  TheÙE** default configuration is to use memory allocation routines in this¨** file.¢**Ù ** C-preprocessor macro summary:¢**ÙJ**    HAVE_MALLOC_USABLE_SIZE     The configure script sets this symbol ifÙK**                                the malloc_usable_size() interface existsÙJ**                                on the target platform.  Or, this symbolÙB**                                can be set manually, if desired.ÙF**                                If an equivalent interface exists byÙG**                                a different name, using a separate -DÙ6**                                option to rename it.¢**ÙK**    SQLITE_WITHOUT_ZONEMALLOC   Some older macs lack support for the zoneÙN**                                memory allocator.  Set this symbol to enableÙ9**                                building on older macs.¢**ÙG**    SQLITE_WITHOUT_MSIZE        Set this symbol to disable the use ofÙJ**                                _msize() on windows systems.  This mightÙI**                                be necessary when compiling for Delphi,Ù.**                                for example.¢*/¼/* #include "sqliteInt.h" */ ¢/*Ù>** This version of the memory allocator is the default.  It isÙF** used when no other memory allocator is specified using compile-timeª** macros.¢*/»#ifdef SQLITE_SYSTEM_MALLOCÙ=#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC) ¢/*Ù@** Use the zone allocator available on apple products unless theÙ/** SQLITE_WITHOUT_ZONEMALLOC symbol is defined.¢*/·#include <sys/sysctl.h>º#include <malloc/malloc.h>Ù"#ifdef SQLITE_MIGHT_BE_SINGLE_CORE½#include <libkern/OSAtomic.h>Ù(#endif /* SQLITE_MIGHT_BE_SINGLE_CORE */Ù#static malloc_zone_t* _sqliteZone_;Ù>#define SQLITE_MALLOC(x) malloc_zone_malloc(_sqliteZone_, (x))Ù;#define SQLITE_FREE(x) malloc_zone_free(_sqliteZone_, (x));ÙG#define SQLITE_REALLOC(x,y) malloc_zone_realloc(_sqliteZone_, (x), (y))¾#define SQLITE_MALLOCSIZE(x) \ÙL        (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,x) : malloc_size(x)) ¼#else /* if not __APPLE__ */ ¢/*ÙA** Use standard C library malloc and free on non-Apple systems.  ÙF** Also used by Apple systems if SQLITE_WITHOUT_ZONEMALLOC is defined.¢*/Ù.#define SQLITE_MALLOC(x)             malloc(x)Ù,#define SQLITE_FREE(x)               free(x)Ù5#define SQLITE_REALLOC(x,y)          realloc((x),(y)) ¢/*ÙG** The malloc.h header file is needed for malloc_usable_size() functionÙ ** on some systems (e.g. Linux).¢*/Ù,#if HAVE_MALLOC_H && HAVE_MALLOC_USABLE_SIZE¿#  define SQLITE_USE_MALLOC_H 1Ù)#  define SQLITE_USE_MALLOC_USABLE_SIZE 1¢/*ÙG** The MSVCRT has malloc_usable_size(), but it is called _msize().  TheÙF** use of _msize() is automatic, but can be disabled by compiling withÙE** -DSQLITE_WITHOUT_MSIZE.  Using the _msize() function also requires¼** the malloc.h header file.¢*/Ù9#elif defined(_MSC_VER) && !defined(SQLITE_WITHOUT_MSIZE)½#  define SQLITE_USE_MALLOC_Hº#  define SQLITE_USE_MSIZE¦#endif ¢/*ÙI** Include the malloc.h header file, if necessary.  Also set define macroÙH** SQLITE_MALLOCSIZE to the appropriate function name, which is _msize()ÙI** for MSVC and malloc_usable_size() for most other systems (e.g. Linux).ÙI** The memory size function can always be overridden manually by definingÙ<** the macro SQLITE_MALLOCSIZE to the desired function name.¢*/Ù #if defined(SQLITE_USE_MALLOC_H)µ#  include <malloc.h>Ù,#  if defined(SQLITE_USE_MALLOC_USABLE_SIZE)Ù##    if !defined(SQLITE_MALLOCSIZE)Ù:#      define SQLITE_MALLOCSIZE(x)   malloc_usable_size(x)ª#    endifÙ!#  elif defined(SQLITE_USE_MSIZE)Ù##    if !defined(SQLITE_MALLOCSIZE)Ù+#      define SQLITE_MALLOCSIZE      _msizeª#    endif¨#  endifÙ)#endif /* defined(SQLITE_USE_MALLOC_H) */ Ù'#endif /* __APPLE__ or not __APPLE__ */ ¢/*Ù9** Like malloc(), but remember the size of the allocationÙ7** so that we can find it later using sqlite3MemSize().¢**ÙE** For this low-level routine, we are guaranteed that nByte>0 becauseÙG** cases of nByte<=0 will be intercepted and dealt with by higher level¬** routines.¢*/Ù)static void *sqlite3MemMalloc(int nByte){¸#ifdef SQLITE_MALLOCSIZEª  void *p;Ù#  testcase( ROUND8(nByte)==nByte );½  p = SQLITE_MALLOC( nByte );­  if( p==0 ){Ù,    testcase( sqlite3GlobalConfig.xLog!=0 );ÙN    sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);£  }«  return p;¥#else³  sqlite3_int64 *p;´  assert( nByte>0 );Ù#  testcase( ROUND8(nByte)!=nByte );¿  p = SQLITE_MALLOC( nByte+8 );ª  if( p ){±    p[0] = nByte;¨    p++;¨  }else{Ù,    testcase( sqlite3GlobalConfig.xLog!=0 );ÙN    sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);£  }³  return (void *)p;¦#endif¡} ¢/*ÙI** Like free() but works for allocations obtained from sqlite3MemMalloc()º** or sqlite3MemRealloc().¢**ÙC** For this low-level routine, we already know that pPrior!=0 sinceÙA** cases where pPrior==0 will have been intecepted and dealt with¼** by higher-level routines.¢*/Ù)static void sqlite3MemFree(void *pPrior){¸#ifdef SQLITE_MALLOCSIZE¶  SQLITE_FREE(pPrior);¥#elseÙ,  sqlite3_int64 *p = (sqlite3_int64*)pPrior;¶  assert( pPrior!=0 );¦  p--;±  SQLITE_FREE(p);¦#endif¡} ¢/*Ù=** Report the allocated size of a prior return from xMalloc()±** or xRealloc().¢*/Ù(static int sqlite3MemSize(void *pPrior){¸#ifdef SQLITE_MALLOCSIZE¶  assert( pPrior!=0 );Ù(  return (int)SQLITE_MALLOCSIZE(pPrior);¥#else³  sqlite3_int64 *p;¶  assert( pPrior!=0 );½  p = (sqlite3_int64*)pPrior;¦  p--;³  return (int)p[0];¦#endif¡} ¢/*ÙA** Like realloc().  Resize an allocation previously obtained from¶** sqlite3MemMalloc().¢**ÙE** For this low-level interface, we know that pPrior!=0.  Cases whereÙD** pPrior==0 while have been intercepted by higher-level routine andÙB** redirected to xMalloc.  Similarly, we know that nByte>0 becauseÙB** cases where nByte<=0 will have been intercepted by higher-levelÙ$** routines and redirected to xFree.¢*/Ù8static void *sqlite3MemRealloc(void *pPrior, int nByte){¸#ifdef SQLITE_MALLOCSIZEÙ*  void *p = SQLITE_REALLOC(pPrior, nByte);­  if( p==0 ){Ù,    testcase( sqlite3GlobalConfig.xLog!=0 );½    sqlite3_log(SQLITE_NOMEM,Ù,      "failed memory resize %u to %u bytes",Ù(      SQLITE_MALLOCSIZE(pPrior), nByte);£  }«  return p;¥#elseÙ,  sqlite3_int64 *p = (sqlite3_int64*)pPrior;Ù!  assert( pPrior!=0 && nByte>0 );Ù9  assert( nByte==ROUND8(nByte) ); /* EV: R-46199-30249 */¦  p--;Ù"  p = SQLITE_REALLOC(p, nByte+8 );ª  if( p ){±    p[0] = nByte;¨    p++;¨  }else{Ù,    testcase( sqlite3GlobalConfig.xLog!=0 );½    sqlite3_log(SQLITE_NOMEM,Ù,      "failed memory resize %u to %u bytes",Ù%      sqlite3MemSize(pPrior), nByte);£  }²  return (void*)p;¦#endif¡} ¢/*Ù=** Round up a request size to the next valid allocation size.¢*/Ù$static int sqlite3MemRoundup(int n){³  return ROUND8(n);¡} ¢/*º** Initialize this module.¢*/Ù)static int sqlite3MemInit(void *NotUsed){Ù=#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)¯  int cpuCount;­  size_t len;µ  if( _sqliteZone_ ){µ    return SQLITE_OK;£  }¹  len = sizeof(cpuCount);ÙM  /* One usually wants to use hw.acctivecpu for MT decisions, but not here */Ù4  sysctlbyname("hw.ncpu", &cpuCount, &len, NULL, 0);³  if( cpuCount>1 ){Ù-    /* defer MT decisions to system malloc */Ù)    _sqliteZone_ = malloc_default_zone();¨  }else{ÙF    /* only 1 core, use our own zone to contention over global locks, Ù.    ** e.g. we have our own dedicated locks */Ù/    _sqliteZone_ = malloc_create_zone(4096, 0);Ù6    malloc_set_zone_name(_sqliteZone_, "Sqlite_Heap");£  }ÙG#endif /*  defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC) */¼  UNUSED_PARAMETER(NotUsed);³  return SQLITE_OK;¡} ¢/*¼** Deinitialize this module.¢*/Ù.static void sqlite3MemShutdown(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);©  return;¡} ¢/*ÙG** This routine is the only routine in this file with external linkage.¢**Ù@** Populate the low-level memory allocation function pointers inÙD** sqlite3GlobalConfig.m with pointers to the routines in this file.¢*/Ù/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ù5  static const sqlite3_mem_methods defaultMethods = {¶     sqlite3MemMalloc,´     sqlite3MemFree,·     sqlite3MemRealloc,´     sqlite3MemSize,·     sqlite3MemRoundup,´     sqlite3MemInit,¸     sqlite3MemShutdown,¦     0¤  };Ù8  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);¡} Ù!#endif /* SQLITE_SYSTEM_MALLOC */ ÙO/************** End of mem1.c ************************************************/ÙO/************** Begin file mem2.c ********************************************/¢/*±** 2007 August 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙB** This file contains low-level memory allocation drivers for whenÙG** SQLite will use the standard C-library malloc/realloc/free interfaceÙJ** to obtain the memory it needs while adding lots of additional debuggingÙH** information to each allocation in order to help detect and fix memoryÙ!** leaks and memory usage errors.¢**ÙH** This file contains implementations of the low-level memory allocationÙ8** routines specified in the sqlite3_mem_methods object.¢*/¼/* #include "sqliteInt.h" */ ¢/*Ù;** This version of the memory allocator is used only if theÙ#** SQLITE_MEMDEBUG macro is defined¢*/¶#ifdef SQLITE_MEMDEBUG ¢/*Ù;** The backtrace functionality is only available with GLIBC¢*/°#ifdef __GLIBC__Ù#  extern int backtrace(void**,int);Ù8  extern void backtrace_symbols_fd(void*const*,int,int);¥#else¹# define backtrace(A,B) 1Ù$# define backtrace_symbols_fd(A,B,C)¦#endif¸/* #include <stdio.h> */ ¢/*Ù*** Each memory allocation looks like this:¢**ÙL**  ------------------------------------------------------------------------ÙL**  | Title |  backtrace pointers |  MemBlockHdr |  allocation |  EndGuard |ÙL**  ------------------------------------------------------------------------¢**ÙG** The application code sees only a pointer to the allocation.  We haveÙG** to back up from the allocation pointer to find the MemBlockHdr.  TheÙD** MemBlockHdr tells us the size of the allocation and the number ofÙD** backtrace pointers.  There is also a guard word at the end of the¯** MemBlockHdr.¢*/´struct MemBlockHdr {ÙC  i64 iSize;                          /* Size of this allocation */ÙM  struct MemBlockHdr *pNext, *pPrev;  /* Linked list of all unfreed memory */ÙN  char nBacktrace;                    /* Number of backtraces on this alloc */ÙE  char nBacktraceSlots;               /* Available backtrace slots */ÙI  u8 nTitle;                          /* Bytes of title; includes '\0' */Ù@  u8 eType;                           /* Allocation type code */ÙA  int iForeGuard;                     /* Guard word for sanity */¢}; ¢/*®** Guard words¢*/¼#define FOREGUARD 0x80F5E153¼#define REARGUARD 0xE4676B53 ¢/*Ù-** Number of malloc size increments to track.¢*/´#define NCSIZE  1000 ¢/*Ù@** All of the static variables used by this module are collectedÙ<** into a single structure named "mem".  This is to keep theÙ?** static variables organized and to reduce namespace pollutionÙ?** when this module is combined with other in the amalgamation.¢*/¯static struct {¢  ¤  /*Ù@  ** Mutex to control access to the memory allocation subsystem.¤  */·  sqlite3_mutex *mutex; ¤  /*ÙB  ** Head and tail of a linked list of all outstanding allocations¤  */½  struct MemBlockHdr *pFirst;¼  struct MemBlockHdr *pLast;¢  ¤  /*ÙB  ** The number of levels of backtrace to save in new allocations.¤  */±  int nBacktrace;Ù(  void (*xBacktrace)(int, int, void **); ¤  /*Ù0  ** Title text to insert in front of each block¤  */ÙN  int nTitle;        /* Bytes of zTitle to save.  Includes '\0' and padding */Ù)  char zTitle[100];  /* The title text */ ¥  /* Ù>  ** sqlite3MallocDisallow() increments the following counter.Ù(  ** sqlite3MallocAllow() decrements it.¤  */Ù4  int disallow; /* Do not allow memory allocation */ ¤  /*Ù:  ** Gather statistics on the sizes of memory allocations.Ù:  ** nAlloc[i] is the number of allocation attempts of i*8Ù?  ** bytes.  i==NCSIZE is the number of allocation attempts forÙ$  ** sizes more than NCSIZE*8 bytes.¤  */Ù<  int nAlloc[NCSIZE];      /* Total number of allocations */Ù>  int nCurrent[NCSIZE];    /* Current number of allocations */Ù<  int mxCurrent[NCSIZE];   /* Highwater mark for nCurrent */ ¦} mem;  ¢/*Ù!** Adjust memory usage statistics¢*/Ù2static void adjustStats(int iSize, int increment){º  int i = ROUND8(iSize)/8;³  if( i>NCSIZE-1 ){³    i = NCSIZE - 1;£  }´  if( increment>0 ){´    mem.nAlloc[i]++;¶    mem.nCurrent[i]++;Ù+    if( mem.nCurrent[i]>mem.mxCurrent[i] ){Ù)      mem.mxCurrent[i] = mem.nCurrent[i];¥    }¨  }else{¶    mem.nCurrent[i]--;Ù!    assert( mem.nCurrent[i]>=0 );£  }¡} ¢/*ÙA** Given an allocation, find the MemBlockHdr for that allocation.¢**ÙE** This routine checks the guards at either end of the allocation andÙ$** if they are incorrect it asserts.¢*/ÙEstatic struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){¸  struct MemBlockHdr *p;¬  int *pInt;ª  u8 *pU8;¯  int nReserve; Ù'  p = (struct MemBlockHdr*)pAllocation;¦  p--;Ù*  assert( p->iForeGuard==(int)FOREGUARD );¾  nReserve = ROUND8(p->iSize);»  pInt = (int*)pAllocation;¹  pU8 = (u8*)pAllocation;Ù7  assert( pInt[nReserve/sizeof(int)]==(int)REARGUARD );Ù7  /* This checks any of the "extra" bytes allocated dueÙ4  ** to rounding up to an 8 byte boundary to ensure Ù#  ** they haven't been overwritten.¤  */Ù?  while( nReserve-- > p->iSize ) assert( pU8[nReserve]==0x65 );«  return p;¡} ¢/*Ù?** Return the number of bytes currently allocated at address p.¢*/Ù#static int sqlite3MemSize(void *p){»  struct MemBlockHdr *pHdr;«  if( !p ){­    return 0;£  }Ù#  pHdr = sqlite3MemsysGetHeader(p);º  return (int)pHdr->iSize;¡} ¢/*Ù.** Initialize the memory allocation subsystem.¢*/Ù)static int sqlite3MemInit(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);Ù0  assert( (sizeof(struct MemBlockHdr)&7) == 0 );Ù&  if( !sqlite3GlobalConfig.bMemstat ){ÙJ    /* If memory status is enabled, then the malloc.c wrapper will alreadyÙG    ** hold the STATIC_MEM mutex when the routines here are invoked. */Ù;    mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);£  }³  return SQLITE_OK;¡} ¢/*Ù0** Deinitialize the memory allocation subsystem.¢*/Ù.static void sqlite3MemShutdown(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);°  mem.mutex = 0;¡} ¢/*Ù=** Round up a request size to the next valid allocation size.¢*/Ù$static int sqlite3MemRoundup(int n){³  return ROUND8(n);¡} ¢/*ÙB** Fill a buffer with pseudo-random bytes.  This is used to presetÙE** the content of a new memory allocation to unpredictable values andÙF** to clear the content of a freed allocation to unpredictable values.¢*/Ù.static void randomFill(char *pBuf, int nByte){·  unsigned int x, y, r;¾  x = SQLITE_PTR_TO_INT(pBuf);°  y = nByte | 1;¶  while( nByte >= 4 ){Ù,    x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);½    y = y*1103515245 + 12345;®    r = x ^ y;´    *(int*)pBuf = r;®    pBuf += 4;¯    nByte -= 4;£  }·  while( nByte-- > 0 ){Ù,    x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);½    y = y*1103515245 + 12345;®    r = x ^ y;¹    *(pBuf++) = r & 0xff;£  }¡} ¢/*Ù"** Allocate nByte bytes of memory.¢*/Ù)static void *sqlite3MemMalloc(int nByte){»  struct MemBlockHdr *pHdr;­  void **pBt;ª  char *z;¬  int *pInt;®  void *p = 0;°  int totalSize;¯  int nReserve;Ù!  sqlite3_mutex_enter(mem.mutex);¼  assert( mem.disallow==0 );»  nReserve = ROUND8(nByte);Ù6  totalSize = nReserve + sizeof(*pHdr) + sizeof(int) +Ù9               mem.nBacktrace*sizeof(void*) + mem.nTitle;¸  p = malloc(totalSize);ª  if( p ){ª    z = p;Ù!    pBt = (void**)&z[mem.nTitle];Ù5    pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace];´    pHdr->pNext = 0;¼    pHdr->pPrev = mem.pLast;´    if( mem.pLast ){¾      mem.pLast->pNext = pHdr;ª    }else{¸      mem.pFirst = pHdr;¥    }µ    mem.pLast = pHdr;Ù!    pHdr->iForeGuard = FOREGUARD;¿    pHdr->eType = MEMTYPE_HEAP;Ù+    pHdr->nBacktraceSlots = mem.nBacktrace;¾    pHdr->nTitle = mem.nTitle;¹    if( mem.nBacktrace ){¶      void *aAddr[40];Ù>      pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1;Ù=      memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));µ      assert(pBt[0]);»      if( mem.xBacktrace ){Ù=        mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]);§      }ª    }else{»      pHdr->nBacktrace = 0;¥    }µ    if( mem.nTitle ){Ù(      memcpy(z, mem.zTitle, mem.nTitle);¥    }¸    pHdr->iSize = nByte;»    adjustStats(nByte, +1);º    pInt = (int*)&pHdr[1];Ù+    pInt[nReserve/sizeof(int)] = REARGUARD;Ù#    randomFill((char*)pInt, nByte);Ù6    memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);´    p = (void*)pInt;£  }Ù!  sqlite3_mutex_leave(mem.mutex);¬  return p; ¡} ¢/*¯** Free memory.¢*/Ù)static void sqlite3MemFree(void *pPrior){»  struct MemBlockHdr *pHdr;­  void **pBt;ª  char *z;ÙL  assert( sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0 ¹       || mem.mutex!=0 );Ù(  pHdr = sqlite3MemsysGetHeader(pPrior);µ  pBt = (void**)pHdr;¿  pBt -= pHdr->nBacktraceSlots;Ù!  sqlite3_mutex_enter(mem.mutex);´  if( pHdr->pPrev ){Ù'    assert( pHdr->pPrev->pNext==pHdr );Ù%    pHdr->pPrev->pNext = pHdr->pNext;¨  }else{¿    assert( mem.pFirst==pHdr );½    mem.pFirst = pHdr->pNext;£  }´  if( pHdr->pNext ){Ù'    assert( pHdr->pNext->pPrev==pHdr );Ù%    pHdr->pNext->pPrev = pHdr->pPrev;¨  }else{¾    assert( mem.pLast==pHdr );¼    mem.pLast = pHdr->pPrev;£  }±  z = (char*)pBt;´  z -= pHdr->nTitle;Ù$  adjustStats((int)pHdr->iSize, -1);ÙE  randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +Ù?                (int)pHdr->iSize + sizeof(int) + pHdr->nTitle);ª  free(z);Ù#  sqlite3_mutex_leave(mem.mutex);  ¡} ¢/*Ù4** Change the size of an existing memory allocation.¢**ÙD** For this debugging implementation, we *always* make a copy of theÙ?** allocation into a new place in memory.  In this way, if the ÙC** higher level code is using pointer to the old allocation, it is Ù@** much more likely to break and we are much more liking to find­** the error.¢*/Ù8static void *sqlite3MemRealloc(void *pPrior, int nByte){¾  struct MemBlockHdr *pOldHdr;­  void *pNew;¼  assert( mem.disallow==0 );Ù7  assert( (nByte & 7)==0 );     /* EV: R-46199-30249 */Ù+  pOldHdr = sqlite3MemsysGetHeader(pPrior);Ù!  pNew = sqlite3MemMalloc(nByte);­  if( pNew ){ÙO    memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));¿    if( nByte>pOldHdr->iSize ){ÙN      randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - (int)pOldHdr->iSize);¥    }»    sqlite3MemFree(pPrior);£  }®  return pNew;¡} ¢/*Ù@** Populate the low-level memory allocation function pointers inÙD** sqlite3GlobalConfig.m with pointers to the routines in this file.¢*/Ù/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ù5  static const sqlite3_mem_methods defaultMethods = {¶     sqlite3MemMalloc,´     sqlite3MemFree,·     sqlite3MemRealloc,´     sqlite3MemSize,·     sqlite3MemRoundup,´     sqlite3MemInit,¸     sqlite3MemShutdown,¦     0¤  };Ù8  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);¡} ¢/*Ù#** Set the "type" of an allocation.¢*/Ù>SQLITE_PRIVATE void sqlite3MemdebugSetType(void *p, u8 eType){Ù=  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){½    struct MemBlockHdr *pHdr;Ù%    pHdr = sqlite3MemsysGetHeader(p);Ù*    assert( pHdr->iForeGuard==FOREGUARD );¸    pHdr->eType = eType;£  }¡} ¢/*ÙC** Return TRUE if the mask of type in eType matches the type of theÙ.** allocation p.  Also return true if p==NULL.¢**ÙD** This routine is designed for use within an assert() statement, toÙ2** verify the type of an allocation.  For example:¢**Ù9**     assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );¢*/Ù=SQLITE_PRIVATE int sqlite3MemdebugHasType(void *p, u8 eType){­  int rc = 1;Ù=  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){½    struct MemBlockHdr *pHdr;Ù%    pHdr = sqlite3MemsysGetHeader(p);ÙL    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */Ù!    if( (pHdr->eType&eType)==0 ){­      rc = 0;¥    }£  }¬  return rc;¡} ¢/*ÙN** Return TRUE if the mask of type in eType matches no bits of the type of theÙ.** allocation p.  Also return true if p==NULL.¢**ÙD** This routine is designed for use within an assert() statement, toÙ2** verify the type of an allocation.  For example:¢**Ù=**     assert( sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );¢*/Ù<SQLITE_PRIVATE int sqlite3MemdebugNoType(void *p, u8 eType){­  int rc = 1;Ù=  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){½    struct MemBlockHdr *pHdr;Ù%    pHdr = sqlite3MemsysGetHeader(p);ÙL    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */Ù!    if( (pHdr->eType&eType)!=0 ){­      rc = 0;¥    }£  }¬  return rc;¡} ¢/*Ù?** Set the number of backtrace levels kept for each allocation.ÙG** A value of zero turns off backtracing.  The number is always rounded¹** up to a multiple of 2.¢*/Ù8SQLITE_PRIVATE void sqlite3MemdebugBacktrace(int depth){½  if( depth<0 ){ depth = 0; }¿  if( depth>20 ){ depth = 20; }¹  depth = (depth+1)&0xfe;¹  mem.nBacktrace = depth;¡} Ù\SQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){¾  mem.xBacktrace = xBacktrace;¡} ¢/*Ù3** Set the title string for subsequent allocations.¢*/Ù@SQLITE_PRIVATE void sqlite3MemdebugSettitle(const char *zTitle){Ù/  unsigned int n = sqlite3Strlen30(zTitle) + 1;Ù!  sqlite3_mutex_enter(mem.mutex);Ù7  if( n>=sizeof(mem.zTitle) ) n = sizeof(mem.zTitle)-1;Ù   memcpy(mem.zTitle, zTitle, n);´  mem.zTitle[n] = 0;¹  mem.nTitle = ROUND8(n);Ù!  sqlite3_mutex_leave(mem.mutex);¡} Ù*SQLITE_PRIVATE void sqlite3MemdebugSync(){»  struct MemBlockHdr *pHdr;Ù/  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){¾    void **pBt = (void**)pHdr;Ù!    pBt -= pHdr->nBacktraceSlots;ÙB    mem.xBacktrace((int)pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]);£  }¡} ¢/*ÙA** Open the file indicated and write a log of all unfreed memory ½** allocations into that log.¢*/Ù?SQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename){¬  FILE *out;»  struct MemBlockHdr *pHdr;­  void **pBt;¨  int i;¾  out = fopen(zFilename, "w");¯  if( out==0 ){ÙK    fprintf(stderr, "** Unable to output memory debug output log: %s **\n",¿                    zFilename);«    return;£  }Ù/  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){º    char *z = (char*)pHdr;Ù<    z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;Ù9    fprintf(out, "**** %lld bytes at %p from %s ****\n", Ù=            pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : "???");»    if( pHdr->nBacktrace ){²      fflush(out);¹      pBt = (void**)pHdr;Ù#      pBt -= pHdr->nBacktraceSlots;Ù?      backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));¹      fprintf(out, "\n");¥    }£  }¼  fprintf(out, "COUNTS:\n");¼  for(i=0; i<NCSIZE-1; i++){¸    if( mem.nAlloc[i] ){Ù/      fprintf(out, "   %5d: %10d %10d %10d\n", ÙC            i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);¥    }£  }½  if( mem.nAlloc[NCSIZE-1] ){Ù,    fprintf(out, "   %5d: %10d %10d %10d\n",Ù.             NCSIZE*8-8, mem.nAlloc[NCSIZE-1],Ù>             mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]);£  }®  fclose(out);¡} ¢/*ÙA** Return the number of times sqlite3MemMalloc() has been called.¢*/Ù0SQLITE_PRIVATE int sqlite3MemdebugMallocCount(){¨  int i;±  int nTotal = 0;º  for(i=0; i<NCSIZE; i++){¼    nTotal += mem.nAlloc[i];£  }°  return nTotal;¡}  ¼#endif /* SQLITE_MEMDEBUG */ ÙO/************** End of mem2.c ************************************************/ÙO/************** Begin file mem3.c ********************************************/¢/*²** 2007 October 14¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù=** This file contains the C functions that implement a memoryÙ+** allocation subsystem for use by SQLite. ¢**Ù<** This version of the memory allocation subsystem omits allÙ>** use of malloc(). The SQLite user supplies a block of memoryÙ=** before calling sqlite3_initialize() from which allocationsÙ9** are made and returned by the xMalloc() and xRealloc() Ù>** implementations. Once sqlite3_initialize() has been called,Ù?** the amount of memory available to SQLite is fixed and cannot®** be changed.¢**Ù>** This version of the memory allocation subsystem is includedÙ9** in the build only if SQLITE_ENABLE_MEMSYS3 is defined.¢*/¼/* #include "sqliteInt.h" */ ¢/*ÙF** This version of the memory allocator is only built into the libraryÙB** SQLITE_ENABLE_MEMSYS3 is defined. Defining this symbol does notÙE** mean that the library will use a memory-pool by default, just thatÙA** it is available. The mempool allocator is activated by calling´** sqlite3_config().¢*/¼#ifdef SQLITE_ENABLE_MEMSYS3 ¢/*Ù3** Maximum size (in Mem3Blocks) of a "small" chunk.¢*/³#define MX_SMALL 10  ¢/*Ù ** Number of freelist hash slots¢*/²#define N_HASH  61 ¢/*ÙB** A memory allocation (also called a "chunk") consists of two or ÙC** more blocks where each block is 8 bytes.  The first 8 bytes are Ù-** a header that is not returned to the user.¢**Ù>** A chunk is two or more blocks that is either checked out orÙH** free.  The first block has format u.hdr.  u.hdr.size4x is 4 times theÙ>** size of the allocation in blocks if the allocation is free.ÙA** The u.hdr.size4x&1 bit is true if the chunk is checked out andÙA** false if the chunk is on the freelist.  The u.hdr.size4x&2 bitÙ@** is true if the previous chunk is checked out and false if theÙC** previous chunk is free.  The u.hdr.prevSize field is the size ofÙ?** the previous chunk in blocks if the previous chunk is on theÙ7** freelist. If the previous chunk is checked out, thenÙC** u.hdr.prevSize can be part of the data for that chunk and shouldº** not be read or written.¢**Ù@** We often identify a chunk by its index in mem3.aPool[].  WhenÙ>** this is done, the chunk index refers to the second block ofÙ>** the chunk.  In this way, the first chunk has an index of 1.ÙA** A chunk index of 0 means "no such chunk" and is the equivalentµ** of a NULL pointer.¢**Ù>** The second block of free chunks is of the form u.list.  TheÙC** two fields form a double-linked list of chunks of related sizes.ÙA** Pointers to the head of the list are stored in mem3.aiSmall[] Ù:** for smaller chunks and mem3.aiHash[] for larger chunks.¢**ÙD** The second block of a chunk is user data if the chunk is checked ÙA** out.  If a chunk is checked out, the user data may extend intoÙ3** the u.hdr.prevSize value of the following chunk.¢*/Ù#typedef struct Mem3Block Mem3Block;²struct Mem3Block {©  union {¬    struct {ÙH      u32 prevSize;   /* Size of previous chunk in Mem3Block elements */ÙN      u32 size4x;     /* 4x the size of current chunk in Mem3Block elements */ª    } hdr;¬    struct {ÙD      u32 next;       /* Index in mem3.aPool[] of next free chunk */ÙH      u32 prev;       /* Index in mem3.aPool[] of previous free chunk */«    } list;¦  } u;¢}; ¢/*Ù@** All of the static variables used by this module are collectedÙ=** into a single structure named "mem3".  This is to keep theÙ?** static variables organized and to reduce namespace pollutionÙ?** when this module is combined with other in the amalgamation.¢*/Ù%static SQLITE_WSD struct Mem3Global {¤  /*ÙD  ** Memory available for allocation. nPool is the size of the arrayÙ0  ** (in Mem3Blocks) pointed to by aPool less 2.¤  */¬  u32 nPool;³  Mem3Block *aPool; ¤  /*Ù9  ** True if we are evaluating an out-of-memory callback.¤  */°  int alarmBusy;¢  ¤  /*Ù@  ** Mutex to control access to the memory allocation subsystem.¤  */·  sqlite3_mutex *mutex;¢  ¤  /*Ù8  ** The minimum amount of free space that we have seen.¤  */¯  u32 mnMaster; ¤  /*ÙD  ** iMaster is the index of the master chunk.  Most new allocationsÙC  ** occur off of this chunk.  szMaster is the size (in Mem3Blocks)ÙG  ** of the current master.  iMaster is 0 if there is not master chunk.ÙA  ** The master chunk is not in either the aiHash[] or aiSmall[].¤  */®  u32 iMaster;¯  u32 szMaster; ¤  /*Ù?  ** Array of lists of free blocks according to the block size Ù?  ** for smaller chunks, or a hash on the block size for larger¬  ** chunks.¤  */ÙJ  u32 aiSmall[MX_SMALL-1];   /* For sizes 2 through MX_SMALL, inclusive */ÙB  u32 aiHash[N_HASH];        /* For sizes MX_SMALL+1 and larger */¶} mem3 = { 97535575 }; Ù,#define mem3 GLOBAL(struct Mem3Global, mem3) ¢/*Ù>** Unlink the chunk at mem3.aPool[i] from list it is currentlyÙ1** on.  *pRoot is the list that i is a member of.¢*/Ù5static void memsys3UnlinkFromList(u32 i, u32 *pRoot){Ù'  u32 next = mem3.aPool[i].u.list.next;Ù'  u32 prev = mem3.aPool[i].u.list.prev;Ù+  assert( sqlite3_mutex_held(mem3.mutex) );°  if( prev==0 ){²    *pRoot = next;¨  }else{Ù(    mem3.aPool[prev].u.list.next = next;£  }­  if( next ){Ù(    mem3.aPool[next].u.list.prev = prev;£  }Ù   mem3.aPool[i].u.list.next = 0;Ù   mem3.aPool[i].u.list.prev = 0;¡} ¢/*Ù$** Unlink the chunk at index i from Ù*** whatever list is currently a member of.¢*/Ù!static void memsys3Unlink(u32 i){±  u32 size, hash;Ù+  assert( sqlite3_mutex_held(mem3.mutex) );Ù2  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );±  assert( i>=1 );Ù(  size = mem3.aPool[i-1].u.hdr.size4x/4;Ù6  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );´  assert( size>=2 );¹  if( size <= MX_SMALL ){Ù4    memsys3UnlinkFromList(i, &mem3.aiSmall[size-2]);¨  }else{¹    hash = size % N_HASH;Ù1    memsys3UnlinkFromList(i, &mem3.aiHash[hash]);£  }¡} ¢/*Ù@** Link the chunk at mem3.aPool[i] so that is on the list rooted­** at *pRoot.¢*/Ù3static void memsys3LinkIntoList(u32 i, u32 *pRoot){Ù+  assert( sqlite3_mutex_held(mem3.mutex) );Ù%  mem3.aPool[i].u.list.next = *pRoot;Ù   mem3.aPool[i].u.list.prev = 0;¯  if( *pRoot ){Ù'    mem3.aPool[*pRoot].u.list.prev = i;£  }­  *pRoot = i;¡} ¢/*Ù8** Link the chunk at index i into either the appropriateÙ8** small chunk list, or into the large chunk hash table.¢*/¿static void memsys3Link(u32 i){±  u32 size, hash;Ù+  assert( sqlite3_mutex_held(mem3.mutex) );±  assert( i>=1 );Ù2  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );Ù(  size = mem3.aPool[i-1].u.hdr.size4x/4;Ù6  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );´  assert( size>=2 );¹  if( size <= MX_SMALL ){Ù2    memsys3LinkIntoList(i, &mem3.aiSmall[size-2]);¨  }else{¹    hash = size % N_HASH;Ù/    memsys3LinkIntoList(i, &mem3.aiHash[hash]);£  }¡} ¢/*ÙH** If the STATIC_MEM mutex is not already held, obtain it now. The mutexÙ9** will already be held (obtained by code in malloc.c) ifÙ(** sqlite3GlobalConfig.bMemStat is true.¢*/¿static void memsys3Enter(void){Ù9  if( sqlite3GlobalConfig.bMemstat==0 && mem3.mutex==0 ){Ù<    mem3.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);£  }Ù"  sqlite3_mutex_enter(mem3.mutex);¡}¿static void memsys3Leave(void){Ù"  sqlite3_mutex_leave(mem3.mutex);¡} ¢/*Ù@** Called when we are unable to satisfy an allocation of nBytes.¢*/Ù*static void memsys3OutOfMemory(int nByte){¸  if( !mem3.alarmBusy ){·    mem3.alarmBusy = 1;Ù-    assert( sqlite3_mutex_held(mem3.mutex) );Ù$    sqlite3_mutex_leave(mem3.mutex);Ù"    sqlite3_release_memory(nByte);Ù$    sqlite3_mutex_enter(mem3.mutex);·    mem3.alarmBusy = 0;£  }¡}  ¢/*Ù?** Chunk i is a free chunk that has been unlinked.  Adjust its Ù=** size parameters for check-out and return a pointer to the ½** user portion of the chunk.¢*/Ù0static void *memsys3Checkout(u32 i, u32 nBlock){¨  u32 x;Ù+  assert( sqlite3_mutex_held(mem3.mutex) );±  assert( i>=1 );Ù3  assert( mem3.aPool[i-1].u.hdr.size4x/4==nBlock );Ù:  assert( mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock );Ù#  x = mem3.aPool[i-1].u.hdr.size4x;Ù6  mem3.aPool[i-1].u.hdr.size4x = nBlock*4 | 1 | (x&2);Ù1  mem3.aPool[i+nBlock-1].u.hdr.prevSize = nBlock;Ù+  mem3.aPool[i+nBlock-1].u.hdr.size4x |= 2;¸  return &mem3.aPool[i];¡} ¢/*Ù?** Carve a piece off of the end of the mem3.iMaster free chunk.ÙC** Return a pointer to the new allocation.  Or, if the master chunkÙ!** is not large enough, return 0.¢*/Ù+static void *memsys3FromMaster(u32 nBlock){Ù+  assert( sqlite3_mutex_held(mem3.mutex) );Ù"  assert( mem3.szMaster>=nBlock );Ù   if( nBlock>=mem3.szMaster-1 ){¿    /* Use the entire master */Ù;    void *p = memsys3Checkout(mem3.iMaster, mem3.szMaster);µ    mem3.iMaster = 0;¶    mem3.szMaster = 0;¶    mem3.mnMaster = 0;­    return p;¨  }else{Ù3    /* Split the master block.  Return the tail. */°    u32 newi, x;Ù1    newi = mem3.iMaster + mem3.szMaster - nBlock;Ù$    assert( newi > mem3.iMaster+1 );ÙE    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = nBlock;Ù?    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x |= 2;Ù3    mem3.aPool[newi-1].u.hdr.size4x = nBlock*4 + 1;¼    mem3.szMaster -= nBlock;Ù6    mem3.aPool[newi-1].u.hdr.prevSize = mem3.szMaster;Ù4    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;ÙB    mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;Ù(    if( mem3.szMaster < mem3.mnMaster ){Ù$      mem3.mnMaster = mem3.szMaster;¥    }Ù$    return (void*)&mem3.aPool[newi];£  }¡} ¢/*Ù?** *pRoot is the head of a list of free chunks of the same sizeÙC** or same size hash.  In other words, *pRoot is an entry in eitherÙ%** mem3.aiSmall[] or mem3.aiHash[].  ¢**Ù@** This routine examines all entries on the given list and triesÙ8** to coalesce each entries with adjacent free chunks.  ¢**ÙD** If it sees a chunk that is larger than mem3.iMaster, it replaces ÙD** the current mem3.iMaster with the new larger chunk.  In order forÙB** this mem3.iMaster replacement to work, the master chunk must beÙ@** linked into the hash tables.  That is not the normal state ofÙ@** affairs, of course.  The calling routine must link the masterÙE** chunk before invoking this routine, then must unlink the (possiblyÙ8** changed) master chunk once this routine has finished.¢*/Ù%static void memsys3Merge(u32 *pRoot){¾  u32 iNext, prev, size, i, x; Ù+  assert( sqlite3_mutex_held(mem3.mutex) );¾  for(i=*pRoot; i>0; i=iNext){Ù&    iNext = mem3.aPool[i].u.list.next;Ù(    size = mem3.aPool[i-1].u.hdr.size4x;º    assert( (size&1)==0 );¶    if( (size&2)==0 ){Ù&      memsys3UnlinkFromList(i, pRoot);Ù3      assert( i > mem3.aPool[i-1].u.hdr.prevSize );Ù0      prev = i - mem3.aPool[i-1].u.hdr.prevSize;¸      if( prev==iNext ){Ù-        iNext = mem3.aPool[prev].u.list.next;§      }º      memsys3Unlink(prev);¿      size = i + size/4 - prev;Ù.      x = mem3.aPool[prev-1].u.hdr.size4x & 2;Ù3      mem3.aPool[prev-1].u.hdr.size4x = size*4 | x;Ù4      mem3.aPool[prev+size-1].u.hdr.prevSize = size;¸      memsys3Link(prev);¯      i = prev;ª    }else{°      size /= 4;¥    }½    if( size>mem3.szMaster ){·      mem3.iMaster = i;»      mem3.szMaster = size;¥    }£  }¡} ¢/*Ù7** Return a block of memory of at least nBytes in size.¹** Return NULL if unable.¢**Ù@** This function assumes that the necessary mutexes, if any, areÙ.** already held by the caller. Hence "Unsafe".¢*/Ù,static void *memsys3MallocUnsafe(int nByte){¨  u32 i;­  u32 nBlock;­  u32 toFree; Ù+  assert( sqlite3_mutex_held(mem3.mutex) );Ù!  assert( sizeof(Mem3Block)==8 );²  if( nByte<=12 ){¯    nBlock = 2;¨  }else{¼    nBlock = (nByte + 11)/8;£  }¶  assert( nBlock>=2 ); ¬  /* STEP 1:Ù>  ** Look for an entry of the correct size in either the smallÙ;  ** chunk table or in the large chunk hash table.  This isÙ;  ** successful most of the time (about 9 times out of 10).¤  */»  if( nBlock <= MX_SMALL ){¿    i = mem3.aiSmall[nBlock-2];®    if( i>0 ){Ù8      memsys3UnlinkFromList(i, &mem3.aiSmall[nBlock-2]);Ù(      return memsys3Checkout(i, nBlock);¥    }¨  }else{¿    int hash = nBlock % N_HASH;Ù?    for(i=mem3.aiHash[hash]; i>0; i=mem3.aPool[i].u.list.next){Ù3      if( mem3.aPool[i-1].u.hdr.size4x/4==nBlock ){Ù5        memsys3UnlinkFromList(i, &mem3.aiHash[hash]);Ù*        return memsys3Checkout(i, nBlock);§      }¥    }£  } ¬  /* STEP 2:ÙD  ** Try to satisfy the allocation by carving a piece off of the endÙC  ** of the master chunk.  This step usually works if step 1 fails.¤  */¾  if( mem3.szMaster>=nBlock ){Ù%    return memsys3FromMaster(nBlock);£  }  ®  /* STEP 3:  ÙA  ** Loop through the entire memory pool.  Coalesce adjacent freeÙC  ** chunks.  Recompute the master chunk as the largest free chunk.ÙD  ** Then try again to satisfy the allocation by carving a piece offÙ<  ** of the end of the master chunk.  This step happens very¶  ** rarely (we hope!)¤  */Ù=  for(toFree=nBlock*16; toFree<(mem3.nPool*16); toFree *= 2){¿    memsys3OutOfMemory(toFree);·    if( mem3.iMaster ){Ù       memsys3Link(mem3.iMaster);·      mem3.iMaster = 0;¸      mem3.szMaster = 0;¥    }¼    for(i=0; i<N_HASH; i++){Ù$      memsys3Merge(&mem3.aiHash[i]);¥    }Ù     for(i=0; i<MX_SMALL-1; i++){Ù%      memsys3Merge(&mem3.aiSmall[i]);¥    }¸    if( mem3.szMaster ){Ù"      memsys3Unlink(mem3.iMaster);Ù"      if( mem3.szMaster>=nBlock ){Ù)        return memsys3FromMaster(nBlock);§      }¥    }£  } Ù2  /* If none of the above worked, then we fail. */«  return 0;¡} ¢/*Ù)** Free an outstanding memory allocation.¢**Ù@** This function assumes that the necessary mutexes, if any, areÙ.** already held by the caller. Hence "Unsafe".¢*/Ù*static void memsys3FreeUnsafe(void *pOld){Ù"  Mem3Block *p = (Mem3Block*)pOld;¨  int i;®  u32 size, x;Ù+  assert( sqlite3_mutex_held(mem3.mutex) );Ù6  assert( p>mem3.aPool && p<&mem3.aPool[mem3.nPool] );µ  i = p - mem3.aPool;Ù0  assert( (mem3.aPool[i-1].u.hdr.size4x&1)==1 );Ù(  size = mem3.aPool[i-1].u.hdr.size4x/4;Ù!  assert( i+size<=mem3.nPool+1 );Ù%  mem3.aPool[i-1].u.hdr.size4x &= ~1;Ù-  mem3.aPool[i+size-1].u.hdr.prevSize = size;Ù*  mem3.aPool[i+size-1].u.hdr.size4x &= ~2;±  memsys3Link(i); Ù<  /* Try to expand the master using the newly freed chunk */µ  if( mem3.iMaster ){Ù<    while( (mem3.aPool[mem3.iMaster-1].u.hdr.size4x&2)==0 ){Ù7      size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize;»      mem3.iMaster -= size;¼      mem3.szMaster += size;Ù"      memsys3Unlink(mem3.iMaster);Ù6      x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;ÙD      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;ÙN      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;¥    }Ù4    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;ÙJ    while( (mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x&1)==0 ){Ù0      memsys3Unlink(mem3.iMaster+mem3.szMaster);ÙO      mem3.szMaster += mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x/4;ÙD      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;ÙN      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;¥    }£  }¡} ¢/*Ù?** Return the size of an outstanding allocation, in bytes.  TheÙ=** size returned omits the 8-byte header overhead.  This onlyÙ3** works for chunks that are currently checked out.¢*/Ù static int memsys3Size(void *p){´  Mem3Block *pBlock;±  assert( p!=0 );¹  pBlock = (Mem3Block*)p;Ù+  assert( (pBlock[-1].u.hdr.size4x&1)!=0 );Ù,  return (pBlock[-1].u.hdr.size4x&~3)*2 - 4;¡} ¢/*Ù=** Round up a request size to the next valid allocation size.¢*/Ù!static int memsys3Roundup(int n){®  if( n<=12 ){®    return 12;¨  }else{»    return ((n+11)&~7) - 4;£  }¡} ¢/*½** Allocate nBytes of memory.¢*/Ù'static void *memsys3Malloc(int nBytes){³  sqlite3_int64 *p;ÙI  assert( nBytes>0 );          /* malloc.c filters out 0 byte requests */±  memsys3Enter();Ù"  p = memsys3MallocUnsafe(nBytes);±  memsys3Leave();³  return (void*)p; ¡} ¢/*¯** Free memory.¢*/Ù&static void memsys3Free(void *pPrior){³  assert( pPrior );±  memsys3Enter();¼  memsys3FreeUnsafe(pPrior);±  memsys3Leave();¡} ¢/*Ù3** Change the size of an existing memory allocation¢*/Ù6static void *memsys3Realloc(void *pPrior, int nBytes){«  int nOld;ª  void *p;²  if( pPrior==0 ){Ù"    return sqlite3_malloc(nBytes);£  }²  if( nBytes<=0 ){¹    sqlite3_free(pPrior);­    return 0;£  }½  nOld = memsys3Size(pPrior);Ù)  if( nBytes<=nOld && nBytes>=nOld-128 ){²    return pPrior;£  }±  memsys3Enter();Ù"  p = memsys3MallocUnsafe(nBytes);ª  if( p ){¶    if( nOld<nBytes ){¾      memcpy(p, pPrior, nOld);ª    }else{Ù       memcpy(p, pPrior, nBytes);¥    }¾    memsys3FreeUnsafe(pPrior);£  }±  memsys3Leave();«  return p;¡} ¢/*º** Initialize this module.¢*/Ù&static int memsys3Init(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);Ù#  if( !sqlite3GlobalConfig.pHeap ){¸    return SQLITE_ERROR;£  } ÙE  /* Store a pointer to the memory block in global structure mem3. */Ù!  assert( sizeof(Mem3Block)==8 );Ù6  mem3.aPool = (Mem3Block *)sqlite3GlobalConfig.pHeap;ÙC  mem3.nPool = (sqlite3GlobalConfig.nHeap / sizeof(Mem3Block)) - 2; Ù$  /* Initialize the master block. */½  mem3.szMaster = mem3.nPool;Ù   mem3.mnMaster = mem3.szMaster;³  mem3.iMaster = 1;Ù6  mem3.aPool[0].u.hdr.size4x = (mem3.szMaster<<2) + 2;Ù5  mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool;Ù*  mem3.aPool[mem3.nPool].u.hdr.size4x = 1; ³  return SQLITE_OK;¡} ¢/*¼** Deinitialize this module.¢*/Ù+static void memsys3Shutdown(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);±  mem3.mutex = 0;©  return;¡}   ¢/*ÙA** Open the file indicated and write a log of all unfreed memory ½** allocations into that log.¢*/Ù>SQLITE_PRIVATE void sqlite3Memsys3Dump(const char *zFilename){³#ifdef SQLITE_DEBUG¬  FILE *out;«  u32 i, j;«  u32 size;Ù(  if( zFilename==0 || zFilename[0]==0 ){±    out = stdout;¨  }else{Ù     out = fopen(zFilename, "w");±    if( out==0 ){ÙM      fprintf(stderr, "** Unable to output memory debug output log: %s **\n",Ù!                      zFilename);­      return;¥    }£  }±  memsys3Enter();¼  fprintf(out, "CHUNKS:\n");Ù%  for(i=1; i<=mem3.nPool; i+=size/4){Ù(    size = mem3.aPool[i-1].u.hdr.size4x;´    if( size/4<=1 ){Ù6      fprintf(out, "%p size error\n", &mem3.aPool[i]);²      assert( 0 );¬      break;¥    }ÙG    if( (size&1)==0 && mem3.aPool[i+size/4-1].u.hdr.prevSize!=size/4 ){ÙD      fprintf(out, "%p tail size does not match\n", &mem3.aPool[i]);²      assert( 0 );¬      break;¥    }ÙA    if( ((mem3.aPool[i+size/4-1].u.hdr.size4x&2)>>1)!=(size&1) ){ÙJ      fprintf(out, "%p tail checkout bit is incorrect\n", &mem3.aPool[i]);²      assert( 0 );¬      break;¥    }±    if( size&1 ){ÙO      fprintf(out, "%p %6d bytes checked out\n", &mem3.aPool[i], (size/4)*8-8);ª    }else{ÙI      fprintf(out, "%p %6d bytes free%s\n", &mem3.aPool[i], (size/4)*8-8,Ù8                  i==mem3.iMaster ? " **master**" : "");¥    }£  }¾  for(i=0; i<MX_SMALL-1; i++){Ù&    if( mem3.aiSmall[i]==0 ) continue;Ù#    fprintf(out, "small(%2d):", i);Ù?    for(j = mem3.aiSmall[i]; j>0; j=mem3.aPool[j].u.list.next){Ù-      fprintf(out, " %p(%d)", &mem3.aPool[j],Ù4              (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);¥    }¸    fprintf(out, "\n"); £  }º  for(i=0; i<N_HASH; i++){Ù%    if( mem3.aiHash[i]==0 ) continue;Ù"    fprintf(out, "hash(%2d):", i);Ù>    for(j = mem3.aiHash[i]; j>0; j=mem3.aPool[j].u.list.next){Ù-      fprintf(out, " %p(%d)", &mem3.aPool[j],Ù4              (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);¥    }¸    fprintf(out, "\n"); £  }Ù,  fprintf(out, "master=%d\n", mem3.iMaster);Ù?  fprintf(out, "nowUsed=%d\n", mem3.nPool*8 - mem3.szMaster*8);Ù>  fprintf(out, "mxUsed=%d\n", mem3.nPool*8 - mem3.mnMaster*8);Ù"  sqlite3_mutex_leave(mem3.mutex);´  if( out==stdout ){³    fflush(stdout);¨  }else{°    fclose(out);£  }¥#else¾  UNUSED_PARAMETER(zFilename);¦#endif¡} ¢/*Ù?** This routine is the only routine in this file with external «** linkage.¢**Ù@** Populate the low-level memory allocation function pointers inÙH** sqlite3GlobalConfig.m with pointers to the routines in this file. TheÙ3** arguments specify the block of memory to manage.¢**ÙA** This routine is only called by sqlite3_config(), and thereforeÙ0** is not required to be threadsafe (it is not).¢*/ÙESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void){Ù5  static const sqlite3_mem_methods mempoolMethods = {³     memsys3Malloc,±     memsys3Free,´     memsys3Realloc,±     memsys3Size,´     memsys3Roundup,±     memsys3Init,µ     memsys3Shutdown,¦     0¤  };¹  return &mempoolMethods;¡} Ù"#endif /* SQLITE_ENABLE_MEMSYS3 */ ÙO/************** End of mem3.c ************************************************/ÙO/************** Begin file mem5.c ********************************************/¢/*²** 2007 October 14¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù=** This file contains the C functions that implement a memoryÙ+** allocation subsystem for use by SQLite. ¢**Ù<** This version of the memory allocation subsystem omits allÙB** use of malloc(). The application gives SQLite a block of memoryÙ=** before calling sqlite3_initialize() from which allocationsÙ9** are made and returned by the xMalloc() and xRealloc() Ù>** implementations. Once sqlite3_initialize() has been called,Ù?** the amount of memory available to SQLite is fixed and cannot®** be changed.¢**Ù>** This version of the memory allocation subsystem is includedÙ9** in the build only if SQLITE_ENABLE_MEMSYS5 is defined.¢**Ù6** This memory allocator uses the following algorithm:¢**ÙD**   1.  All memory allocation sizes are rounded up to a power of 2.¢**ÙF**   2.  If two adjacent free blocks are the halves of a larger block,ÙH**       then the two blocks are coalesced into the single larger block.¢**ÙE**   3.  New memory is allocated from the first available free block.¢**ÙK** This algorithm is described in: J. M. Robson. "Bounds for Some FunctionsÙI** Concerning Dynamic Storage Allocation". Journal of the Association forÙF** Computing Machinery, Volume 21, Number 8, July 1974, pages 491-499.£** ÙE** Let n be the size of the largest allocation divided by the minimumÙH** allocation size (after rounding all sizes up to a power of 2.)  Let MÙE** be the maximum amount of memory ever outstanding at one time.  LetÙD** N be the total amount of memory available for allocation.  RobsonÙA** proved that this memory allocator will never breakdown due to Ù;** fragmentation as long as the following constraint holds:¢**Ù'**      N >=  M*(1 + log2(n)/2) - n + 1¢**ÙE** The sqlite3_status() logic tracks the maximum values of n and M soÙ@** that an application can, at any time, verify this constraint.¢*/¼/* #include "sqliteInt.h" */ ¢/*Ù:** This version of the memory allocator is used only when Ù$** SQLITE_ENABLE_MEMSYS5 is defined.¢*/¼#ifdef SQLITE_ENABLE_MEMSYS5 ¢/*ÙB** A minimum allocation is an instance of the following structure.Ù@** Larger allocations are an array of these structures where theÙ%** size of the array is a power of 2.¢**Ù@** The size of this object must be a power of two.  That fact is½** verified in memsys5Init().¢*/Ù!typedef struct Mem5Link Mem5Link;±struct Mem5Link {Ù0  int next;       /* Index of next free chunk */Ù4  int prev;       /* Index of previous free chunk */¢}; ¢/*ÙE** Maximum size of any allocation is ((1<<LOGMAX)*mem5.szAtom). SinceÙA** mem5.szAtom is always at least 8 and 32-bit integers are used,Ù3** it is not actually possible to reach this limit.¢*/±#define LOGMAX 30 ¢/*Ù(** Masks used for mem5.aCtrl[] elements.¢*/Ù;#define CTRL_LOGSIZE  0x1f    /* Log2 Size of this block */Ù;#define CTRL_FREE     0x20    /* True if not checked out */ ¢/*Ù@** All of the static variables used by this module are collectedÙ=** into a single structure named "mem5".  This is to keep theÙ?** static variables organized and to reduce namespace pollutionÙ?** when this module is combined with other in the amalgamation.¢*/Ù%static SQLITE_WSD struct Mem5Global {¤  /*Ù$  ** Memory available for allocation¤  */Ù>  int szAtom;      /* Smallest possible allocation in bytes */Ù?  int nBlock;      /* Number of szAtom sized blocks in zPool */Ù9  u8 *zPool;       /* Memory available to be allocated */¢  ¤  /*Ù@  ** Mutex to control access to the memory allocation subsystem.¤  */·  sqlite3_mutex *mutex; Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)¤  /*»  ** Performance statistics¤  */Ù;  u64 nAlloc;         /* Total number of calls to malloc */ÙN  u64 totalAlloc;     /* Total of all malloc calls - includes internal frag */Ù8  u64 totalExcess;    /* Total internal fragmentation */ÙN  u32 currentOut;     /* Current checkout, including internal fragmentation */Ù@  u32 currentCount;   /* Current number of distinct checkouts */Ù<  u32 maxOut;         /* Maximum instantaneous currentOut */Ù>  u32 maxCount;       /* Maximum instantaneous currentCount */ÙK  u32 maxRequest;     /* Largest allocation (exclusive of internal frag) */¦#endif¢  ¤  /*ÙE  ** Lists of free blocks.  aiFreelist[0] is a list of free blocks ofÙD  ** size mem5.szAtom.  aiFreelist[1] holds blocks of size szAtom*2.ÙE  ** aiFreelist[2] holds free blocks of size szAtom*4.  And so forth.¤  */»  int aiFreelist[LOGMAX+1]; ¤  /*ÙA  ** Space for tracking which blocks are checked out and the sizeÙ(  ** of each block.  One byte per block.¤  */¬  u8 *aCtrl; §} mem5; ¢/*ÙB** Access the static variable through a macro for SQLITE_OMIT_WSD.¢*/Ù,#define mem5 GLOBAL(struct Mem5Global, mem5) ¢/*Ù>** Assuming mem5.zPool is divided up into an array of Mem5LinkÙ8** structures, return a pointer to the idx-th such link.¢*/ÙD#define MEM5LINK(idx) ((Mem5Link *)(&mem5.zPool[(idx)*mem5.szAtom])) ¢/*Ù>** Unlink the chunk at mem5.aPool[i] from list it is currentlyÙ8** on.  It should be found on mem5.aiFreelist[iLogsize].¢*/Ù/static void memsys5Unlink(int i, int iLogsize){±  int next, prev;Ù"  assert( i>=0 && i<mem5.nBlock );Ù,  assert( iLogsize>=0 && iLogsize<=LOGMAX );Ù5  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize ); »  next = MEM5LINK(i)->next;»  prev = MEM5LINK(i)->prev;¯  if( prev<0 ){Ù%    mem5.aiFreelist[iLogsize] = next;¨  }else{Ù     MEM5LINK(prev)->next = next;£  }°  if( next>=0 ){Ù     MEM5LINK(next)->prev = prev;£  }¡} ¢/*Ù=** Link the chunk at mem5.aPool[i] so that is on the iLogsize­** free list.¢*/Ù-static void memsys5Link(int i, int iLogsize){¨  int x;Ù+  assert( sqlite3_mutex_held(mem5.mutex) );Ù"  assert( i>=0 && i<mem5.nBlock );Ù,  assert( iLogsize>=0 && iLogsize<=LOGMAX );Ù5  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize ); Ù4  x = MEM5LINK(i)->next = mem5.aiFreelist[iLogsize];¹  MEM5LINK(i)->prev = -1;­  if( x>=0 ){¼    assert( x<mem5.nBlock );º    MEM5LINK(x)->prev = i;£  }Ù   mem5.aiFreelist[iLogsize] = i;¡} ¢/*ÙG** Obtain or release the mutex needed to access global data structures.¢*/¿static void memsys5Enter(void){Ù"  sqlite3_mutex_enter(mem5.mutex);¡}¿static void memsys5Leave(void){Ù"  sqlite3_mutex_leave(mem5.mutex);¡} ¢/*Ù:** Return the size of an outstanding allocation, in bytes.Ù=** This only works for chunks that are currently checked out.¢*/Ù static int memsys5Size(void *p){¯  int iSize, i;±  assert( p!=0 );Ù.  i = (int)(((u8 *)p-mem5.zPool)/mem5.szAtom);Ù"  assert( i>=0 && i<mem5.nBlock );Ù<  iSize = mem5.szAtom * (1 << (mem5.aCtrl[i]&CTRL_LOGSIZE));¯  return iSize;¡} ¢/*Ù7** Return a block of memory of at least nBytes in size.Ù4** Return NULL if unable.  Return NULL if nBytes==0.¢**Ù0** The caller guarantees that nByte is positive.¢**Ù9** The caller has obtained a mutex prior to invoking thisÙ8** routine so there is never any chance that two or moreÙ3** threads can be in this routine at the same time.¢*/Ù,static void *memsys5MallocUnsafe(int nByte){Ù5  int i;           /* Index of a mem5.aPool[] slot */Ù5  int iBin;        /* Index into mem5.aiFreelist[] */ÙD  int iFullSz;     /* Size of allocation rounded up to power of 2 */Ù1  int iLogsize;    /* Log2 of iFullSz/POW2_MIN */ Ù   /* nByte must be a positive */´  assert( nByte>0 ); Ù(  /* No more than 1GiB per allocation */Ù$  if( nByte > 0x40000000 ) return 0; Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)ÙD  /* Keep track of the maximum allocation request.  Even unfulfilled¼  ** requests are counted */Ù#  if( (u32)nByte>mem5.maxRequest ){¼    mem5.maxRequest = nByte;£  }¦#endif  Ù5  /* Round nByte up to the next valid power of two */ÙM  for(iFullSz=mem5.szAtom,iLogsize=0; iFullSz<nByte; iFullSz*=2,iLogsize++){} ÙC  /* Make sure mem5.aiFreelist[iLogsize] contains at least one freeÙC  ** block.  If not, then split a block of the next larger power ofÙ>  ** two in order to create a new free block of size iLogsize.¤  */ÙG  for(iBin=iLogsize; iBin<=LOGMAX && mem5.aiFreelist[iBin]<0; iBin++){}´  if( iBin>LOGMAX ){Ù,    testcase( sqlite3GlobalConfig.xLog!=0 );ÙD    sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes", nByte);­    return 0;£  }¼  i = mem5.aiFreelist[iBin];¹  memsys5Unlink(i, iBin);¹  while( iBin>iLogsize ){°    int newSize; «    iBin--;¸    newSize = 1 << iBin;Ù-    mem5.aCtrl[i+newSize] = CTRL_FREE | iBin;Ù!    memsys5Link(i+newSize, iBin);£  }»  mem5.aCtrl[i] = iLogsize; Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ù0  /* Update allocator performance statistics. */°  mem5.nAlloc++;½  mem5.totalAlloc += iFullSz;Ù&  mem5.totalExcess += iFullSz - nByte;¶  mem5.currentCount++;½  mem5.currentOut += iFullSz;ÙJ  if( mem5.maxCount<mem5.currentCount ) mem5.maxCount = mem5.currentCount;ÙB  if( mem5.maxOut<mem5.currentOut ) mem5.maxOut = mem5.currentOut;¦#endif ³#ifdef SQLITE_DEBUGÙJ  /* Make sure the allocated memory does not assume that it is set to zeroÙ5  ** or retains a value from a previous allocation */Ù4  memset(&mem5.zPool[i*mem5.szAtom], 0xAA, iFullSz);¦#endif Ù1  /* Return a pointer to the allocated memory. */Ù+  return (void*)&mem5.zPool[i*mem5.szAtom];¡} ¢/*Ù)** Free an outstanding memory allocation.¢*/Ù*static void memsys5FreeUnsafe(void *pOld){µ  u32 size, iLogsize;­  int iBlock; Ù@  /* Set iBlock to the index of the block pointed to by pOld in ÙC  ** the array of mem5.szAtom byte blocks pointed to by mem5.zPool.¤  */Ù6  iBlock = (int)(((u8 *)pOld-mem5.zPool)/mem5.szAtom); ÙF  /* Check that the pointer pOld points to a valid, non-free block. */Ù,  assert( iBlock>=0 && iBlock<mem5.nBlock );Ù3  assert( ((u8 *)pOld-mem5.zPool)%mem5.szAtom==0 );Ù0  assert( (mem5.aCtrl[iBlock] & CTRL_FREE)==0 ); Ù/  iLogsize = mem5.aCtrl[iBlock] & CTRL_LOGSIZE;µ  size = 1<<iLogsize;Ù+  assert( iBlock+size-1<(u32)mem5.nBlock ); Ù"  mem5.aCtrl[iBlock] |= CTRL_FREE;Ù)  mem5.aCtrl[iBlock+size-1] |= CTRL_FREE; Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ù   assert( mem5.currentCount>0 );Ù0  assert( mem5.currentOut>=(size*mem5.szAtom) );¶  mem5.currentCount--;Ù&  mem5.currentOut -= size*mem5.szAtom;Ù6  assert( mem5.currentOut>0 || mem5.currentCount==0 );Ù6  assert( mem5.currentCount>0 || mem5.currentOut==0 );¦#endif Ù,  mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;Ù#  while( ALWAYS(iLogsize<LOGMAX) ){¯    int iBuddy;Ù!    if( (iBlock>>iLogsize) & 1 ){½      iBuddy = iBlock - size;º      assert( iBuddy>=0 );ª    }else{½      iBuddy = iBlock + size;Ù&      if( iBuddy>=mem5.nBlock ) break;¥    }Ù;    if( mem5.aCtrl[iBuddy]!=(CTRL_FREE | iLogsize) ) break;Ù$    memsys5Unlink(iBuddy, iLogsize);¯    iLogsize++;¸    if( iBuddy<iBlock ){Ù0      mem5.aCtrl[iBuddy] = CTRL_FREE | iLogsize;½      mem5.aCtrl[iBlock] = 0;¶      iBlock = iBuddy;ª    }else{Ù0      mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;½      mem5.aCtrl[iBuddy] = 0;¥    }®    size *= 2;£  } ³#ifdef SQLITE_DEBUGÙJ  /* Overwrite freed memory with the 0x55 bit pattern to verify that it isÙ"  ** not used after being freed */Ù6  memset(&mem5.zPool[iBlock*mem5.szAtom], 0x55, size);¦#endif Ù   memsys5Link(iBlock, iLogsize);¡} ¢/*½** Allocate nBytes of memory.¢*/Ù'static void *memsys5Malloc(int nBytes){·  sqlite3_int64 *p = 0;±  if( nBytes>0 ){³    memsys5Enter();Ù$    p = memsys5MallocUnsafe(nBytes);³    memsys5Leave();£  }³  return (void*)p; ¡} ¢/*¯** Free memory.¢**Ù>** The outer layer memory allocator prevents this routine from¿** being called with pPrior==0.¢*/Ù&static void memsys5Free(void *pPrior){¶  assert( pPrior!=0 );±  memsys5Enter();¼  memsys5FreeUnsafe(pPrior);³  memsys5Leave();  ¡} ¢/*Ù4** Change the size of an existing memory allocation.¢**Ù>** The outer layer memory allocator prevents this routine fromÙ!** being called with pPrior==0.  ¢**Ù9** nBytes is always a value obtained from a prior call toÙ?** memsys5Round().  Hence nBytes is always a non-negative powerÙ?** of two.  If nBytes==0 that means that an oversize allocationÙ@** (an allocation larger than 0x40000000) was requested and thisÙ2** routine should return 0 without freeing pPrior.¢*/Ù6static void *memsys5Realloc(void *pPrior, int nBytes){«  int nOld;ª  void *p;¶  assert( pPrior!=0 );Ù<  assert( (nBytes&(nBytes-1))==0 );  /* EV: R-46199-30249 */¶  assert( nBytes>=0 );²  if( nBytes==0 ){­    return 0;£  }½  nOld = memsys5Size(pPrior);µ  if( nBytes<=nOld ){²    return pPrior;£  }¼  p = memsys5Malloc(nBytes);ª  if( p ){¼    memcpy(p, pPrior, nOld);¸    memsys5Free(pPrior);£  }«  return p;¡} ¢/*ÙA** Round up a request size to the next valid allocation size.  IfÙG** the allocation is too large to be handled by this allocation system,¬** return 0.¢**ÙD** All allocations must be a power of two and must be expressed by aÙE** 32-bit signed integer.  Hence the largest allocation is 0x40000000·** or 1073741824 bytes.¢*/Ù!static int memsys5Roundup(int n){®  int iFullSz;Ù   if( n > 0x40000000 ) return 0;Ù4  for(iFullSz=mem5.szAtom; iFullSz<n; iFullSz *= 2);±  return iFullSz;¡} ¢/*Ù8** Return the ceiling of the logarithm base 2 of iValue.¢**Ù!** Examples:   memsys5Log(1) -> 0Ù!**             memsys5Log(2) -> 1Ù!**             memsys5Log(4) -> 2Ù!**             memsys5Log(5) -> 3Ù!**             memsys5Log(8) -> 3Ù!**             memsys5Log(9) -> 4¢*/Ù"static int memsys5Log(int iValue){«  int iLog;ÙK  for(iLog=0; (iLog<(int)((sizeof(int)*8)-1)) && (1<<iLog)<iValue; iLog++);®  return iLog;¡} ¢/*Ù#** Initialize the memory allocator.¢**ÙF** This routine is not threadsafe.  The caller must be holding a mutexÙ>** to prevent multiple threads from entering at the same time.¢*/Ù&static int memsys5Init(void *NotUsed){Ù'  int ii;            /* Loop counter */ÙP  int nByte;         /* Number of bytes of memory available to this allocator */Ù:  u8 *zByte;         /* Memory usable by this allocator */ÙI  int nMinLog;       /* Log base 2 of minimum allocation size in bytes */Ù6  int iOffset;       /* An offset into mem5.aCtrl[] */ ¼  UNUSED_PARAMETER(NotUsed); Ù;  /* For the purposes of this routine, disable the mutex */±  mem5.mutex = 0; ÙG  /* The size of a Mem5Link object must be a power of two.  Verify that²  ** this is case.¤  */Ù7  assert( (sizeof(Mem5Link)&(sizeof(Mem5Link)-1))==0 ); Ù$  nByte = sqlite3GlobalConfig.nHeap;Ù)  zByte = (u8*)sqlite3GlobalConfig.pHeap;ÙF  assert( zByte!=0 );  /* sqlite3_config() does not allow otherwise */ ÙP  /* boundaries on sqlite3GlobalConfig.mnReq are enforced in sqlite3_config() */Ù2  nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq);½  mem5.szAtom = (1<<nMinLog);Ù-  while( (int)sizeof(Mem5Link)>mem5.szAtom ){Ù#    mem5.szAtom = mem5.szAtom << 1;£  } Ù3  mem5.nBlock = (nByte / (mem5.szAtom+sizeof(u8)));µ  mem5.zPool = zByte;Ù:  mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.szAtom]; ¾  for(ii=0; ii<=LOGMAX; ii++){½    mem5.aiFreelist[ii] = -1;£  } ®  iOffset = 0;¾  for(ii=LOGMAX; ii>=0; ii--){¹    int nAlloc = (1<<ii);Ù(    if( (iOffset+nAlloc)<=mem5.nBlock ){Ù+      mem5.aCtrl[iOffset] = ii | CTRL_FREE;¿      memsys5Link(iOffset, ii);¸      iOffset += nAlloc;¥    }Ù)    assert((iOffset+nAlloc)>mem5.nBlock);£  } ÙA  /* If a mutex is required for normal operation, allocate one */Ù(  if( sqlite3GlobalConfig.bMemstat==0 ){Ù<    mem5.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);£  } ³  return SQLITE_OK;¡} ¢/*¼** Deinitialize this module.¢*/Ù+static void memsys5Shutdown(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);±  mem5.mutex = 0;©  return;¡} ²#ifdef SQLITE_TEST¢/*ÙA** Open the file indicated and write a log of all unfreed memory ½** allocations into that log.¢*/Ù>SQLITE_PRIVATE void sqlite3Memsys5Dump(const char *zFilename){¬  FILE *out;®  int i, j, n;®  int nMinLog; Ù(  if( zFilename==0 || zFilename[0]==0 ){±    out = stdout;¨  }else{Ù     out = fopen(zFilename, "w");±    if( out==0 ){ÙM      fprintf(stderr, "** Unable to output memory debug output log: %s **\n",Ù!                      zFilename);­      return;¥    }£  }±  memsys5Enter();Ù$  nMinLog = memsys5Log(mem5.szAtom);Ù+  for(i=0; i<=LOGMAX && i+nMinLog<32; i++){ÙF    for(n=0, j=mem5.aiFreelist[i]; j>=0; j = MEM5LINK(j)->next, n++){}ÙI    fprintf(out, "freelist items of size %d: %d\n", mem5.szAtom << i, n);£  }Ù:  fprintf(out, "mem5.nAlloc       = %llu\n", mem5.nAlloc);Ù>  fprintf(out, "mem5.totalAlloc   = %llu\n", mem5.totalAlloc);Ù?  fprintf(out, "mem5.totalExcess  = %llu\n", mem5.totalExcess);Ù<  fprintf(out, "mem5.currentOut   = %u\n", mem5.currentOut);Ù>  fprintf(out, "mem5.currentCount = %u\n", mem5.currentCount);Ù8  fprintf(out, "mem5.maxOut       = %u\n", mem5.maxOut);Ù:  fprintf(out, "mem5.maxCount     = %u\n", mem5.maxCount);Ù<  fprintf(out, "mem5.maxRequest   = %u\n", mem5.maxRequest);±  memsys5Leave();´  if( out==stdout ){³    fflush(stdout);¨  }else{°    fclose(out);£  }¡}¦#endif ¢/*Ù?** This routine is the only routine in this file with external Ù@** linkage. It returns a pointer to a static sqlite3_mem_methodsÙ-** struct populated with the memsys5 methods.¢*/ÙESQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){Ù5  static const sqlite3_mem_methods memsys5Methods = {³     memsys5Malloc,±     memsys5Free,´     memsys5Realloc,±     memsys5Size,´     memsys5Roundup,±     memsys5Init,µ     memsys5Shutdown,¦     0¤  };¹  return &memsys5Methods;¡} Ù"#endif /* SQLITE_ENABLE_MEMSYS5 */ ÙO/************** End of mem5.c ************************************************/ÙO/************** Begin file mutex.c *******************************************/¢/*±** 2007 August 14¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù=** This file contains the C functions that implement mutexes.¢**ÙK** This file contains code that is common across all mutex implementations.¢*/¼/* #include "sqliteInt.h" */ Ù8#if defined(SQLITE_DEBUG) && !defined(SQLITE_MUTEX_OMIT)¢/*ÙI** For debugging purposes, record when the mutex subsystem is initializedÙF** and uninitialized so that we can assert() if there is an attempt toÙ6** allocate a mutex while the system is uninitialized.¢*/Ù&static SQLITE_WSD int mutexIsInit = 0;Ù8#endif /* SQLITE_DEBUG && !defined(SQLITE_MUTEX_OMIT) */  ¹#ifndef SQLITE_MUTEX_OMIT Ù)#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS¢/*ÙG** This block (enclosed by SQLITE_ENABLE_MULTITHREADED_CHECKS) containsÙB** the implementation of a wrapper around the system default mutexÙ+** implementation (sqlite3DefaultMutex()). ¢**ÙC** Most calls are passed directly through to the underlying defaultÙD** mutex implementation. Except, if a mutex is configured by callingÙC** sqlite3MutexWarnOnContention() on it, then if contention is everÙK** encountered within xMutexEnter() a warning is emitted via sqlite3_log().¢**ÙG** This type of mutex is used as the database handle mutex when testingÙ8** apps that usually use SQLITE_CONFIG_MULTITHREAD mode.¢*/ £/* ÙD** Type for all mutexes used when SQLITE_ENABLE_MULTITHREADED_CHECKSÙG** is defined. Variable CheckMutex.mutex is a pointer to the real mutexÙN** allocated by the system mutex implementation. Variable iType is usually setÙM** to the type of mutex requested - SQLITE_MUTEX_RECURSIVE, SQLITE_MUTEX_FASTÙK** or one of the static mutex identifiers. Or, if this is a recursive mutexÙG** that has been configured using sqlite3MutexWarnOnContention(), it isÙ(** set to SQLITE_MUTEX_WARNONCONTENTION.¢*/Ù%typedef struct CheckMutex CheckMutex;³struct CheckMutex {¬  int iType;·  sqlite3_mutex *mutex;¢}; Ù+#define SQLITE_MUTEX_WARNONCONTENTION  (-1) £/* Ù>** Pointer to real mutex methods object used by the CheckMutexÙ,** implementation. Set by checkMutexInit(). ¢*/ÙCstatic SQLITE_WSD const sqlite3_mutex_methods *pGlobalMutexMethods; ³#ifdef SQLITE_DEBUGÙ,static int checkMutexHeld(sqlite3_mutex *p){ÙB  return pGlobalMutexMethods->xMutexHeld(((CheckMutex*)p)->mutex);¡}Ù/static int checkMutexNotheld(sqlite3_mutex *p){ÙE  return pGlobalMutexMethods->xMutexNotheld(((CheckMutex*)p)->mutex);¡}¦#endif ¢/*Ù3** Initialize and deinitialize the mutex subsystem.¢*/Ù!static int checkMutexInit(void){ Ù.  pGlobalMutexMethods = sqlite3DefaultMutex();´  return SQLITE_OK; ¡}Ù static int checkMutexEnd(void){ º  pGlobalMutexMethods = 0;´  return SQLITE_OK; ¡} ¢/*´** Allocate a mutex.¢*/Ù1static sqlite3_mutex *checkMutexAlloc(int iType){Ù'  static CheckMutex staticMutexes[] = {Ù#    {2, 0}, {3, 0}, {4, 0}, {5, 0},Ù#    {6, 0}, {7, 0}, {8, 0}, {9, 0},Ù&    {10, 0}, {11, 0}, {12, 0}, {13, 0}¤  };´  CheckMutex *p = 0; Ù>  assert( SQLITE_MUTEX_RECURSIVE==1 && SQLITE_MUTEX_FAST==0 );°  if( iType<2 ){Ù.    p = sqlite3MallocZero(sizeof(CheckMutex));¸    if( p==0 ) return 0;µ    p->iType = iType;¨  }else{¾#ifdef SQLITE_ENABLE_API_ARMORÙ,    if( iType-2>=ArraySize(staticMutexes) ){¿      (void)SQLITE_MISUSE_BKPT;¯      return 0;¥    }¦#endifÙ     p = &staticMutexes[iType-2];£  } ´  if( p->mutex==0 ){Ù7    p->mutex = pGlobalMutexMethods->xMutexAlloc(iType);¶    if( p->mutex==0 ){´      if( iType<2 ){¸        sqlite3_free(p);§      }¬      p = 0;¥    }£  } »  return (sqlite3_mutex*)p;¡} ¢/*°** Free a mutex.¢*/Ù-static void checkMutexFree(sqlite3_mutex *p){Ù%  assert( SQLITE_MUTEX_RECURSIVE<2 );Ù   assert( SQLITE_MUTEX_FAST<2 );Ù,  assert( SQLITE_MUTEX_WARNONCONTENTION<2 ); »#if SQLITE_ENABLE_API_ARMORÙ!  if( ((CheckMutex*)p)->iType<2 )¦#endif£  {Ù(    CheckMutex *pCheck = (CheckMutex*)p;Ù3    pGlobalMutexMethods->xMutexFree(pCheck->mutex);¹    sqlite3_free(pCheck);£  }¾#ifdef SQLITE_ENABLE_API_ARMOR§  else{½    (void)SQLITE_MISUSE_BKPT;£  }¦#endif¡} ¢/*³** Enter the mutex.¢*/Ù.static void checkMutexEnter(sqlite3_mutex *p){Ù&  CheckMutex *pCheck = (CheckMutex*)p;Ù5  if( pCheck->iType==SQLITE_MUTEX_WARNONCONTENTION ){ÙC    if( SQLITE_OK==pGlobalMutexMethods->xMutexTry(pCheck->mutex) ){­      return;¥    }¿    sqlite3_log(SQLITE_MISUSE, Ù>        "illegal multi-threaded access to database connection"¦    );£  }Ù2  pGlobalMutexMethods->xMutexEnter(pCheck->mutex);¡} ¢/*Ù"** Enter the mutex (do not block).¢*/Ù+static int checkMutexTry(sqlite3_mutex *p){Ù&  CheckMutex *pCheck = (CheckMutex*)p;Ù7  return pGlobalMutexMethods->xMutexTry(pCheck->mutex);¡} ¢/*³** Leave the mutex.¢*/Ù.static void checkMutexLeave(sqlite3_mutex *p){Ù&  CheckMutex *pCheck = (CheckMutex*)p;Ù2  pGlobalMutexMethods->xMutexLeave(pCheck->mutex);¡} Ù;sqlite3_mutex_methods const *multiThreadedCheckMutex(void){Ù/  static const sqlite3_mutex_methods sMutex = {³    checkMutexInit,²    checkMutexEnd,´    checkMutexAlloc,³    checkMutexFree,´    checkMutexEnter,²    checkMutexTry,´    checkMutexLeave,³#ifdef SQLITE_DEBUG³    checkMutexHeld,µ    checkMutexNotheld¥#else¦    0,¥    0¦#endif¤  };±  return &sMutex;¡} ¢/*ÙG** Mark the SQLITE_MUTEX_RECURSIVE mutex passed as the only argument asÙ.** one on which there should be no contention.¢*/ÙCSQLITE_PRIVATE void sqlite3MutexWarnOnContention(sqlite3_mutex *p){Ù?  if( sqlite3GlobalConfig.mutex.xMutexAlloc==checkMutexAlloc ){Ù(    CheckMutex *pCheck = (CheckMutex*)p;Ù4    assert( pCheck->iType==SQLITE_MUTEX_RECURSIVE );Ù2    pCheck->iType = SQLITE_MUTEX_WARNONCONTENTION;£  }¡}Ù7#endif   /* ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS */ ¢/*¿** Initialize the mutex system.¢*/Ù+SQLITE_PRIVATE int sqlite3MutexInit(void){ µ  int rc = SQLITE_OK;Ù/  if( !sqlite3GlobalConfig.mutex.xMutexAlloc ){ÙH    /* If the xMutexAlloc method has not been set, then the user did notÙD    ** install a mutex implementation via sqlite3_config() prior to ÙG    ** sqlite3_initialize() being called. This block copies pointers toÙI    ** the default implementation into the sqlite3GlobalConfig structure.¦    */Ù'    sqlite3_mutex_methods const *pFrom;Ù<    sqlite3_mutex_methods *pTo = &sqlite3GlobalConfig.mutex; Ù)    if( sqlite3GlobalConfig.bCoreMutex ){Ù)#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKSÙ(      pFrom = multiThreadedCheckMutex();¥#elseÙ$      pFrom = sqlite3DefaultMutex();¦#endifª    }else{Ù!      pFrom = sqlite3NoopMutex();¥    }Ù(    pTo->xMutexInit = pFrom->xMutexInit;Ù&    pTo->xMutexEnd = pFrom->xMutexEnd;Ù(    pTo->xMutexFree = pFrom->xMutexFree;Ù*    pTo->xMutexEnter = pFrom->xMutexEnter;Ù&    pTo->xMutexTry = pFrom->xMutexTry;Ù*    pTo->xMutexLeave = pFrom->xMutexLeave;Ù(    pTo->xMutexHeld = pFrom->xMutexHeld;Ù.    pTo->xMutexNotheld = pFrom->xMutexNotheld;»    sqlite3MemoryBarrier();Ù*    pTo->xMutexAlloc = pFrom->xMutexAlloc;£  }Ù1  assert( sqlite3GlobalConfig.mutex.xMutexInit );Ù.  rc = sqlite3GlobalConfig.mutex.xMutexInit(); ³#ifdef SQLITE_DEBUG¿  GLOBAL(int, mutexIsInit) = 1;¦#endif ¬  return rc;¡} ¢/*ÙD** Shutdown the mutex system. This call frees resources allocated by¶** sqlite3MutexInit().¢*/Ù)SQLITE_PRIVATE int sqlite3MutexEnd(void){µ  int rc = SQLITE_OK;Ù,  if( sqlite3GlobalConfig.mutex.xMutexEnd ){Ù/    rc = sqlite3GlobalConfig.mutex.xMutexEnd();£  } ³#ifdef SQLITE_DEBUG¿  GLOBAL(int, mutexIsInit) = 0;¦#endif ¬  return rc;¡} ¢/*ÙF** Retrieve a pointer to a static mutex or allocate a new dynamic one.¢*/Ù6SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){¼#ifndef SQLITE_OMIT_AUTOINITÙD  if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;ÙA  if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;¦#endifÙ2  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );Ù3  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);¡} Ù8SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){Ù(  if( !sqlite3GlobalConfig.bCoreMutex ){­    return 0;£  }Ù%  assert( GLOBAL(int, mutexIsInit) );Ù2  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );Ù3  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);¡} ¢/*¸** Free a dynamic mutex.¢*/Ù5SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){ª  if( p ){Ù3    assert( sqlite3GlobalConfig.mutex.xMutexFree );Ù,    sqlite3GlobalConfig.mutex.xMutexFree(p);£  }¡} ¢/*ÙH** Obtain the mutex p. If some other thread already has the mutex, block¼** until it can be obtained.¢*/Ù6SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){ª  if( p ){Ù4    assert( sqlite3GlobalConfig.mutex.xMutexEnter );Ù-    sqlite3GlobalConfig.mutex.xMutexEnter(p);£  }¡} ¢/*ÙM** Obtain the mutex p. If successful, return SQLITE_OK. Otherwise, if anotherÙH** thread holds the mutex and it cannot be obtained, return SQLITE_BUSY.¢*/Ù3SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){µ  int rc = SQLITE_OK;ª  if( p ){Ù2    assert( sqlite3GlobalConfig.mutex.xMutexTry );Ù2    return sqlite3GlobalConfig.mutex.xMutexTry(p);£  }¬  return rc;¡} ¢/*ÙF** The sqlite3_mutex_leave() routine exits a mutex that was previouslyÙG** entered by the same thread.  The behavior is undefined if the mutex ÙG** is not currently entered. If a NULL pointer is passed as an argument¼** this function is a no-op.¢*/Ù6SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){ª  if( p ){Ù4    assert( sqlite3GlobalConfig.mutex.xMutexLeave );Ù-    sqlite3GlobalConfig.mutex.xMutexLeave(p);£  }¡} ®#ifndef NDEBUG¢/*ÙC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areÙ/** intended for use inside assert() statements.¢*/Ù4SQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p){Ù9  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexHeld );Ù9  return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p);¡}Ù7SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p){Ù<  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld );Ù<  return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p);¡}¦#endif Ù(#endif /* !defined(SQLITE_MUTEX_OMIT) */  ÙO/************** End of mutex.c ***********************************************/ÙO/************** Begin file mutex_noop.c **************************************/¢/*²** 2008 October 07¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù=** This file contains the C functions that implement mutexes.¢**Ù?** This implementation in this file does not provide any mutualÙ>** exclusion and is thus suitable for use only in applicationsÙ<** that use SQLite in a single thread.  The routines definedÙ?** here are place-holders.  Applications can substitute workingÙ)** mutex routines at start-time using the¢**Ù.**     sqlite3_config(SQLITE_CONFIG_MUTEX,...)¢**­** interface.¢**ÙC** If compiled with SQLITE_DEBUG, then additional logic is insertedÙB** that does error checking on mutexes to make sure they are being´** called correctly.¢*/¼/* #include "sqliteInt.h" */ ¹#ifndef SQLITE_MUTEX_OMIT ´#ifndef SQLITE_DEBUG¢/*Ù'** Stub routines for all mutex methods.¢**Ù?** This routines provide no mutual exclusion or error checking.¢*/Ù3static int noopMutexInit(void){ return SQLITE_OK; }Ù2static int noopMutexEnd(void){ return SQLITE_OK; }Ù.static sqlite3_mutex *noopMutexAlloc(int id){ ·  UNUSED_PARAMETER(id);¼  return (sqlite3_mutex*)8; ¡}ÙKstatic void noopMutexFree(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }ÙLstatic void noopMutexEnter(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }Ù*static int noopMutexTry(sqlite3_mutex *p){¶  UNUSED_PARAMETER(p);³  return SQLITE_OK;¡}ÙLstatic void noopMutexLeave(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; } ÙCSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){Ù/  static const sqlite3_mutex_methods sMutex = {²    noopMutexInit,±    noopMutexEnd,³    noopMutexAlloc,²    noopMutexFree,³    noopMutexEnter,±    noopMutexTry,³    noopMutexLeave, ¦    0,¦    0,¤  }; ±  return &sMutex;¡}º#endif /* !SQLITE_DEBUG */ ³#ifdef SQLITE_DEBUG¢/*ÙA** In this implementation, error checking is provided for testingÙ@** and debugging purposes.  The mutexes still do not provide any´** mutual exclusion.¢*/ ¢/*³** The mutex object¢*/Ù$typedef struct sqlite3_debug_mutex {Ù"  int id;     /* The mutex type */Ù>  int cnt;    /* Number of entries without a matching leave */¶} sqlite3_debug_mutex; ¢/*ÙC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areÙ/** intended for use inside assert() statements.¢*/Ù-static int debugMutexHeld(sqlite3_mutex *pX){Ù4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;º  return p==0 || p->cnt>0;¡}Ù0static int debugMutexNotheld(sqlite3_mutex *pX){Ù4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;»  return p==0 || p->cnt==0;¡} ¢/*Ù3** Initialize and deinitialize the mutex subsystem.¢*/Ù4static int debugMutexInit(void){ return SQLITE_OK; }Ù3static int debugMutexEnd(void){ return SQLITE_OK; } ¢/*Ù4** The sqlite3_mutex_alloc() routine allocates a newÙ9** mutex and returns a pointer to it.  If it returns NULLÙ3** that means that a mutex could not be allocated. ¢*/Ù.static sqlite3_mutex *debugMutexAlloc(int id){ÙC  static sqlite3_debug_mutex aStatic[SQLITE_MUTEX_STATIC_VFS3 - 1];Ù   sqlite3_debug_mutex *pNew = 0;¯  switch( id ){»    case SQLITE_MUTEX_FAST:Ù"    case SQLITE_MUTEX_RECURSIVE: {Ù*      pNew = sqlite3Malloc(sizeof(*pNew));±      if( pNew ){¶        pNew->id = id;¶        pNew->cnt = 0;§      }¬      break;¥    }®    default: {¾#ifdef SQLITE_ENABLE_API_ARMORÙ/      if( id-2<0 || id-2>=ArraySize(aStatic) ){Ù!        (void)SQLITE_MISUSE_BKPT;±        return 0;§      }¦#endif¼      pNew = &aStatic[id-2];´      pNew->id = id;¬      break;¥    }£  }¾  return (sqlite3_mutex*)pNew;¡} ¢/*Ù9** This routine deallocates a previously allocated mutex.¢*/Ù.static void debugMutexFree(sqlite3_mutex *pX){Ù4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;¶  assert( p->cnt==0 );ÙB  if( p->id==SQLITE_MUTEX_RECURSIVE || p->id==SQLITE_MUTEX_FAST ){´    sqlite3_free(p);¨  }else{¾#ifdef SQLITE_ENABLE_API_ARMOR½    (void)SQLITE_MISUSE_BKPT;¦#endif£  }¡} ¢/*ÙE** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptÙD** to enter a mutex.  If another thread is already within the mutex,ÙG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnÙD** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OKÙK** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE canÙD** be entered multiple times by the same thread.  In such cases the,ÙF** mutex must be exited an equal number of times before another threadÙH** can enter.  If the same thread tries to enter any other kind of mutexÙ-** more than once, the behavior is undefined.¢*/Ù/static void debugMutexEnter(sqlite3_mutex *pX){Ù4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;ÙC  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );«  p->cnt++;¡}Ù,static int debugMutexTry(sqlite3_mutex *pX){Ù4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;ÙC  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );«  p->cnt++;³  return SQLITE_OK;¡} ¢/*Ù;** The sqlite3_mutex_leave() routine exits a mutex that wasÙ7** previously entered by the same thread.  The behaviorÙ8** is undefined if the mutex is not currently entered orÙ<** is not currently allocated.  SQLite will never do either.¢*/Ù/static void debugMutexLeave(sqlite3_mutex *pX){Ù4  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;¿  assert( debugMutexHeld(pX) );«  p->cnt--;ÙC  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );¡} ÙCSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){Ù/  static const sqlite3_mutex_methods sMutex = {³    debugMutexInit,²    debugMutexEnd,´    debugMutexAlloc,³    debugMutexFree,´    debugMutexEnter,²    debugMutexTry,´    debugMutexLeave, ³    debugMutexHeld,µ    debugMutexNotheld¤  }; ±  return &sMutex;¡}¹#endif /* SQLITE_DEBUG */ ¢/*ÙJ** If compiled with SQLITE_MUTEX_NOOP, then the no-op mutex implementationÙ;** is used regardless of the run-time threadsafety setting.¢*/¸#ifdef SQLITE_MUTEX_NOOPÙFSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){¼  return sqlite3NoopMutex();¡}Ù'#endif /* defined(SQLITE_MUTEX_NOOP) */Ù(#endif /* !defined(SQLITE_MUTEX_OMIT) */ ÙO/************** End of mutex_noop.c ******************************************/ÙO/************** Begin file mutex_unix.c **************************************/¢/*±** 2007 August 28¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙI** This file contains the C functions that implement mutexes for pthreads¢*/¼/* #include "sqliteInt.h" */ ¢/*ÙD** The code in this file is only used if we are compiling threadsafe¼** under unix with pthreads.¢**ÙD** Note that this implementation requires a version of pthreads that¾** supports recursive mutexes.¢*/¼#ifdef SQLITE_MUTEX_PTHREADS ´#include <pthread.h> ¢/*ÙK** The sqlite3_mutex.id, sqlite3_mutex.nRef, and sqlite3_mutex.owner fieldsÙG** are necessary under two condidtions:  (1) Debug builds and (2) usingÙK** home-grown mutexes.  Encapsulate these conditions into a single #define.¢*/ÙF#if defined(SQLITE_DEBUG) || defined(SQLITE_HOMEGROWN_RECURSIVE_MUTEX)¼# define SQLITE_MUTEX_NREF 1¥#else¼# define SQLITE_MUTEX_NREF 0¦#endif ¢/*ÙB** Each recursive mutex is an instance of the following structure.¢*/¶struct sqlite3_mutex {Ù=  pthread_mutex_t mutex;     /* Mutex controlling the lock */Ù9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ù-  int id;                    /* Mutex type */¦#endifµ#if SQLITE_MUTEX_NREFÙ6  volatile int nRef;         /* Number of entrances */ÙC  volatile pthread_t owner;  /* Thread that is within this mutex */Ù8  int trace;                 /* True to trace changes */¦#endif¢};µ#if SQLITE_MUTEX_NREFÙ(# define SQLITE3_MUTEX_INITIALIZER(id) \Ù4     {PTHREAD_MUTEX_INITIALIZER,id,0,(pthread_t)0,0}Ù&#elif defined(SQLITE_ENABLE_API_ARMOR)ÙH# define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER, id }¥#elseÙC#define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER }¦#endif ¢/*ÙC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areÙH** intended for use only inside assert() statements.  On some platforms,ÙB** there might be race conditions that can cause these routines toÙC** deliver incorrect results.  In particular, if pthread_equal() isÙ>** not an atomic operation, then these routines might deliveryÙ?** incorrect results.  On most platforms, pthread_equal() is a ÙB** comparison of two integers and is therefore atomic.  But we areÙE** told that HPUX is not such a platform.  If so, then these routinesÙ*** will not always work correctly on HPUX.¢**ÙA** On those platforms where pthread_equal() is not atomic, SQLiteÙA** should be compiled without -DSQLITE_DEBUG and with -DNDEBUG toÙA** make sure no assert() statements are evaluated and hence these½** routines are never called.¢*/Ù-#if !defined(NDEBUG) || defined(SQLITE_DEBUG)Ù.static int pthreadMutexHeld(sqlite3_mutex *p){ÙA  return (p->nRef!=0 && pthread_equal(p->owner, pthread_self()));¡}Ù1static int pthreadMutexNotheld(sqlite3_mutex *p){ÙB  return p->nRef==0 || pthread_equal(p->owner, pthread_self())==0;¡}¦#endif ¢/*ÙG** Try to provide a memory barrier operation, needed for initializationÙE** and also for the implementation of xShmBarrier in the VFS in casesÙ,** where SQLite is compiled without mutexes.¢*/Ù/SQLITE_PRIVATE void sqlite3MemoryBarrier(void){Ù"#if defined(SQLITE_MEMORY_BARRIER)¸  SQLITE_MEMORY_BARRIER;Ù/#elif defined(__GNUC__) && GCC_VERSION>=4001000·  __sync_synchronize();¦#endif¡} ¢/*Ù3** Initialize and deinitialize the mutex subsystem.¢*/Ù6static int pthreadMutexInit(void){ return SQLITE_OK; }Ù5static int pthreadMutexEnd(void){ return SQLITE_OK; } ¢/*Ù4** The sqlite3_mutex_alloc() routine allocates a newÙ9** mutex and returns a pointer to it.  If it returns NULLÙ:** that means that a mutex could not be allocated.  SQLiteÙ;** will unwind its stack and return an error.  The argumentÙ>** to sqlite3_mutex_alloc() is one of these integer constants:¢**§** <ul>º** <li>  SQLITE_MUTEX_FAST¿** <li>  SQLITE_MUTEX_RECURSIVEÙ#** <li>  SQLITE_MUTEX_STATIC_MASTERÙ ** <li>  SQLITE_MUTEX_STATIC_MEMÙ!** <li>  SQLITE_MUTEX_STATIC_OPENÙ!** <li>  SQLITE_MUTEX_STATIC_PRNGÙ ** <li>  SQLITE_MUTEX_STATIC_LRUÙ!** <li>  SQLITE_MUTEX_STATIC_PMEMÙ!** <li>  SQLITE_MUTEX_STATIC_APP1Ù!** <li>  SQLITE_MUTEX_STATIC_APP2Ù!** <li>  SQLITE_MUTEX_STATIC_APP3Ù!** <li>  SQLITE_MUTEX_STATIC_VFS1Ù!** <li>  SQLITE_MUTEX_STATIC_VFS2Ù!** <li>  SQLITE_MUTEX_STATIC_VFS3¨** </ul>¢**Ù@** The first two constants cause sqlite3_mutex_alloc() to createÙG** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVEÙA** is used but not necessarily so when SQLITE_MUTEX_FAST is used.Ù?** The mutex implementation does not need to make a distinctionÙB** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it doesÙB** not want to.  But SQLite will only request a recursive mutex inÙD** cases where it really needs one.  If a faster non-recursive mutexÙH** implementation is available on the host platform, the mutex subsystemÙ>** might return such a mutex in response to SQLITE_MUTEX_FAST.¢**ÙD** The other allowed parameters to sqlite3_mutex_alloc() each returnÙC** a pointer to a static preexisting mutex.  Six static mutexes areÙD** used by the current version of SQLite.  Future versions of SQLiteÙF** may add additional static mutexes.  Static mutexes are for internalÙC** use by SQLite only.  Applications that use SQLite mutexes shouldÙ@** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST orº** SQLITE_MUTEX_RECURSIVE.¢**ÙF** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FASTÙ@** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()Ù@** returns a different mutex on every call.  But for the static ÙA** mutex types, the same mutex is returned on every call that has¸** the same type number.¢*/Ù3static sqlite3_mutex *pthreadMutexAlloc(int iType){Ù*  static sqlite3_mutex staticMutexes[] = {Ù!    SQLITE3_MUTEX_INITIALIZER(2),Ù!    SQLITE3_MUTEX_INITIALIZER(3),Ù!    SQLITE3_MUTEX_INITIALIZER(4),Ù!    SQLITE3_MUTEX_INITIALIZER(5),Ù!    SQLITE3_MUTEX_INITIALIZER(6),Ù!    SQLITE3_MUTEX_INITIALIZER(7),Ù!    SQLITE3_MUTEX_INITIALIZER(8),Ù!    SQLITE3_MUTEX_INITIALIZER(9),Ù"    SQLITE3_MUTEX_INITIALIZER(10),Ù"    SQLITE3_MUTEX_INITIALIZER(11),Ù"    SQLITE3_MUTEX_INITIALIZER(12),Ù!    SQLITE3_MUTEX_INITIALIZER(13)¤  };³  sqlite3_mutex *p;²  switch( iType ){Ù"    case SQLITE_MUTEX_RECURSIVE: {Ù*      p = sqlite3MallocZero( sizeof(*p) );®      if( p ){Ù'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEXÙB        /* If recursive mutexes are not available, we will have toÙ(        ** build our own.  See below. */Ù)        pthread_mutex_init(&p->mutex, 0);¥#elseÙ6        /* Use a recursive mutex if it is available */Ù*        pthread_mutexattr_t recursiveAttr;Ù/        pthread_mutexattr_init(&recursiveAttr);ÙK        pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);Ù6        pthread_mutex_init(&p->mutex, &recursiveAttr);Ù2        pthread_mutexattr_destroy(&recursiveAttr);¦#endifÙ9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ù'        p->id = SQLITE_MUTEX_RECURSIVE;¦#endif§      }¬      break;¥    }½    case SQLITE_MUTEX_FAST: {Ù*      p = sqlite3MallocZero( sizeof(*p) );®      if( p ){Ù)        pthread_mutex_init(&p->mutex, 0);Ù9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ù"        p->id = SQLITE_MUTEX_FAST;¦#endif§      }¬      break;¥    }®    default: {¾#ifdef SQLITE_ENABLE_API_ARMORÙ;      if( iType-2<0 || iType-2>=ArraySize(staticMutexes) ){Ù!        (void)SQLITE_MISUSE_BKPT;±        return 0;§      }¦#endifÙ"      p = &staticMutexes[iType-2];¬      break;¥    }£  }Ù9#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)Ù!  assert( p==0 || p->id==iType );¦#endif«  return p;¡}  ¢/*Ù(** This routine deallocates a previouslyÙ:** allocated mutex.  SQLite is careful to deallocate every»** mutex that it allocates.¢*/Ù/static void pthreadMutexFree(sqlite3_mutex *p){·  assert( p->nRef==0 );»#if SQLITE_ENABLE_API_ARMORÙA  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE )¦#endif£  {Ù%    pthread_mutex_destroy(&p->mutex);´    sqlite3_free(p);£  }¾#ifdef SQLITE_ENABLE_API_ARMOR§  else{½    (void)SQLITE_MISUSE_BKPT;£  }¦#endif¡} ¢/*ÙE** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptÙD** to enter a mutex.  If another thread is already within the mutex,ÙG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnÙD** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OKÙK** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE canÙD** be entered multiple times by the same thread.  In such cases the,ÙF** mutex must be exited an equal number of times before another threadÙH** can enter.  If the same thread tries to enter any other kind of mutexÙ-** more than once, the behavior is undefined.¢*/Ù0static void pthreadMutexEnter(sqlite3_mutex *p){ÙD  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) ); Ù'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEXÙA  /* If recursive mutexes are not available, then we have to growÙ?  ** our own.  This implementation assumes that pthread_equal()Ù>  ** is atomic - that it cannot be deceived into thinking selfÙB  ** and p->owner are equal if p->owner changes between two valuesÙE  ** that are not equal to self while the comparison is taking place.Ù>  ** This implementation also assumes a coherent cache - that ÙB  ** separate processes cannot read different values from the sameÙA  ** address at the same time.  If either of these two conditionsÙF  ** are not met, then the mutexes will fail and problems will result.¤  */£  {Ù$    pthread_t self = pthread_self();Ù5    if( p->nRef>0 && pthread_equal(p->owner, self) ){°      p->nRef++;ª    }else{Ù$      pthread_mutex_lock(&p->mutex);»      assert( p->nRef==0 );¶      p->owner = self;²      p->nRef = 1;¥    }£  }¥#elseÙ>  /* Use the built-in recursive mutexes if they are available.¤  */Ù   pthread_mutex_lock(&p->mutex);µ#if SQLITE_MUTEX_NREFÙ%  assert( p->nRef>0 || p->owner==0 );¼  p->owner = pthread_self();¬  p->nRef++;¦#endif¦#endif ³#ifdef SQLITE_DEBUG±  if( p->trace ){ÙG    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);£  }¦#endif¡}Ù-static int pthreadMutexTry(sqlite3_mutex *p){©  int rc;ÙD  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) ); Ù'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEXÙA  /* If recursive mutexes are not available, then we have to growÙ?  ** our own.  This implementation assumes that pthread_equal()Ù>  ** is atomic - that it cannot be deceived into thinking selfÙB  ** and p->owner are equal if p->owner changes between two valuesÙE  ** that are not equal to self while the comparison is taking place.Ù>  ** This implementation also assumes a coherent cache - that ÙB  ** separate processes cannot read different values from the sameÙA  ** address at the same time.  If either of these two conditionsÙF  ** are not met, then the mutexes will fail and problems will result.¤  */£  {Ù$    pthread_t self = pthread_self();Ù5    if( p->nRef>0 && pthread_equal(p->owner, self) ){°      p->nRef++;µ      rc = SQLITE_OK;Ù4    }else if( pthread_mutex_trylock(&p->mutex)==0 ){»      assert( p->nRef==0 );¶      p->owner = self;²      p->nRef = 1;µ      rc = SQLITE_OK;ª    }else{·      rc = SQLITE_BUSY;¥    }£  }¥#elseÙ>  /* Use the built-in recursive mutexes if they are available.¤  */Ù,  if( pthread_mutex_trylock(&p->mutex)==0 ){µ#if SQLITE_MUTEX_NREF¾    p->owner = pthread_self();®    p->nRef++;¦#endif³    rc = SQLITE_OK;¨  }else{µ    rc = SQLITE_BUSY;£  }¦#endif ³#ifdef SQLITE_DEBUGÙ"  if( rc==SQLITE_OK && p->trace ){ÙG    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);£  }¦#endif¬  return rc;¡} ¢/*Ù;** The sqlite3_mutex_leave() routine exits a mutex that wasÙ7** previously entered by the same thread.  The behaviorÙ8** is undefined if the mutex is not currently entered orÙ<** is not currently allocated.  SQLite will never do either.¢*/Ù0static void pthreadMutexLeave(sqlite3_mutex *p){Ù   assert( pthreadMutexHeld(p) );µ#if SQLITE_MUTEX_NREF¬  p->nRef--;Ù   if( p->nRef==0 ) p->owner = 0;¦#endifÙ8  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE ); Ù'#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX³  if( p->nRef==0 ){Ù$    pthread_mutex_unlock(&p->mutex);£  }¥#elseÙ"  pthread_mutex_unlock(&p->mutex);¦#endif ³#ifdef SQLITE_DEBUG±  if( p->trace ){ÙG    printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);£  }¦#endif¡} ÙFSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){Ù/  static const sqlite3_mutex_methods sMutex = {µ    pthreadMutexInit,´    pthreadMutexEnd,¶    pthreadMutexAlloc,µ    pthreadMutexFree,¶    pthreadMutexEnter,´    pthreadMutexTry,¶    pthreadMutexLeave,³#ifdef SQLITE_DEBUGµ    pthreadMutexHeld,·    pthreadMutexNotheld¥#else¦    0,¥    0¦#endif¤  }; ±  return &sMutex;¡} Ù"#endif /* SQLITE_MUTEX_PTHREADS */ ÙO/************** End of mutex_unix.c ******************************************/ÙO/************** Begin file mutex_w32.c ***************************************/¢/*±** 2007 August 14¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙG** This file contains the C functions that implement mutexes for Win32.¢*/¼/* #include "sqliteInt.h" */ ±#if SQLITE_OS_WIN¢/*Ù2** Include code that is common to all os_*.c files¢*/ÙO/************** Include os_common.h in the middle of mutex_w32.c *************/ÙO/************** Begin file os_common.h ***************************************/¢/*®** 2004 May 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙG** This file contains macros and a little bit of code that is common toÙJ** all of the platform-specific files (os_*.c) and is #included into those©** files.¢**ÙG** This file should be #included by the os_*.c files only.  It is not a¿** general purpose header file.¢*/µ#ifndef _OS_COMMON_H_µ#define _OS_COMMON_H_ ¢/*ÙH** At least two bugs have slipped in because we changed the MEMORY_DEBUGÙG** macro to SQLITE_DEBUG and some older makefiles have not yet made theÙI** switch.  The following code should catch this problem at compile-time.¢*/³#ifdef MEMORY_DEBUGÙH# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."¦#endif ¢/*ÙD** Macros for performance tracing.  Normally turned off.  Only works´** on i486 hardware.¢*/¿#ifdef SQLITE_PERFORMANCE_TRACE ¢/*Ù;** hwtime.h contains inline assembler code for implementingÙ$** high-performance timing routines.¢*/ÙO/************** Include hwtime.h in the middle of os_common.h ****************/ÙO/************** Begin file hwtime.h ******************************************/¢/*®** 2008 May 27¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙG** This file contains inline asm code for retrieving "high-performance"¿** counters for x86 class CPUs.¢*/·#ifndef SQLITE_HWTIME_H·#define SQLITE_HWTIME_H ¢/*ÙK** The following routine only works on pentium-class (or newer) processors.ÙD** It uses the RDTSC opcode to read the cycle count value out of theÙC** processor and returns that value.  This can be used for high-res­** profiling.¢*/Ù1#if (defined(__GNUC__) || defined(_MSC_VER)) && \Ù>      (defined(i386) || defined(__i386__) || defined(_M_IX86)) ·  #if defined(__GNUC__) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){¹     unsigned int lo, hi;Ù;     __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));Ù)     return (sqlite_uint64)hi << 32 | lo;£  } ¹  #elif defined(_MSC_VER) ÙG  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){¬     __asm {­        rdtscÙ+        ret       ; return value at EDX:EAX¦     }£  } ¨  #endif Ù0#elif (defined(__GNUC__) && defined(__x86_64__)) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){¸      unsigned long val;Ù2      __asm__ __volatile__ ("rdtsc" : "=A" (val));±      return val;£  }¡ Ù-#elif (defined(__GNUC__) && defined(__ppc__)) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){Ù       unsigned long long retval;¹      unsigned long junk;Ù       __asm__ __volatile__ ("\n\¿          1:      mftbu   %1\n\Ù                   mftb    %L0\n\¿                  mftbu   %0\n\Ù"                  cmpw    %0,%1\n\½                  bne     1b"Ù0                  : "=r" (retval), "=r" (junk));´      return retval;£  } ¥#else ÙB  #error Need implementation of sqlite3Hwtime() for your platform. ¤  /*ÙG  ** To compile without implementing sqlite3Hwtime() for your platform,Ù:  ** you can remove the above #error and use the followingÙ:  ** stub function.  You will lose timing support for manyÙ=  ** of the debugging and testing utilities, but it should at»  ** least compile and run.¤  */ÙPSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } ¦#endif Ù&#endif /* !defined(SQLITE_HWTIME_H) */ ÙO/************** End of hwtime.h **********************************************/ÙO/************** Continuing where we left off in os_common.h ******************/ ½static sqlite_uint64 g_start;¿static sqlite_uint64 g_elapsed;Ù1#define TIMER_START       g_start=sqlite3Hwtime()Ù;#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_startÙ##define TIMER_ELAPSED     g_elapsed¥#else³#define TIMER_START±#define TIMER_ENDÙ,#define TIMER_ELAPSED     ((sqlite_uint64)0)¦#endif ¢/*ÙI** If we compile with the SQLITE_TEST macro set, then the following blockÙG** of code will give us the ability to simulate a disk I/O error.  ThisÙ.** is used for testing the I/O recovery logic.¢*/¸#if defined(SQLITE_TEST)Ù+SQLITE_API extern int sqlite3_io_error_hit;Ù/SQLITE_API extern int sqlite3_io_error_hardhit;Ù/SQLITE_API extern int sqlite3_io_error_pending;Ù/SQLITE_API extern int sqlite3_io_error_persist;Ù.SQLITE_API extern int sqlite3_io_error_benign;Ù/SQLITE_API extern int sqlite3_diskfull_pending;Ù'SQLITE_API extern int sqlite3_diskfull;Ù<#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)Ù #define SimulateIOError(CODE)  \Ù:  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \Ù.       || sqlite3_io_error_pending-- == 1 )  \Ù&              { local_ioerr(); CODE; }ºstatic void local_ioerr(){·  IOTRACE(("IOERR\n"));¹  sqlite3_io_error_hit++;Ù<  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;¡}Ù%#define SimulateDiskfullError(CODE) \Ù$   if( sqlite3_diskfull_pending ){ \Ù+     if( sqlite3_diskfull_pending == 1 ){ \·       local_ioerr(); \¾       sqlite3_diskfull = 1; \Ù"       sqlite3_io_error_hit = 1; \®       CODE; \­     }else{ \Ù$       sqlite3_diskfull_pending--; \¨     } \¤   }¥#elseÙ #define SimulateIOErrorBenign(X)º#define SimulateIOError(A)Ù #define SimulateDiskfullError(A)Ù!#endif /* defined(SQLITE_TEST) */ ¢/*Ù:** When testing, keep a count of the number of open files.¢*/¸#if defined(SQLITE_TEST)Ù.SQLITE_API extern int sqlite3_open_file_count;Ù4#define OpenCounter(X)  sqlite3_open_file_count+=(X)¥#else¶#define OpenCounter(X)Ù!#endif /* defined(SQLITE_TEST) */ Ù$#endif /* !defined(_OS_COMMON_H_) */ ÙO/************** End of os_common.h *******************************************/ÙO/************** Continuing where we left off in mutex_w32.c ******************/ ¢/*Ù/** Include the header file for the Windows VFS.¢*/ÙO/************** Include os_win.h in the middle of mutex_w32.c ****************/ÙO/************** Begin file os_win.h ******************************************/¢/*³** 2013 November 25¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**Ù7** This file contains code that is specific to Windows.¢*/·#ifndef SQLITE_OS_WIN_H·#define SQLITE_OS_WIN_H ¢/*Ù/** Include the primary Windows SDK header file.¢*/´#include "windows.h" ±#ifdef __CYGWIN__¸# include <sys/cygwin.h>Ù0# include <errno.h> /* amalgamator: dontcache */¦#endif ¢/*Ù/** Determine if we are dealing with Windows NT.¢**ÙI** We ought to be able to determine if we are compiling for Windows 9x orÙ6** Windows NT using the _WIN32_WINNT macro as follows:¢**¼** #if defined(_WIN32_WINNT)½** # define SQLITE_OS_WINNT 1¨** #else½** # define SQLITE_OS_WINNT 0©** #endif¢**ÙG** However, Visual Studio 2005 does not set _WIN32_WINNT by default, asÙH** it ought to, so the above test does not work.  We'll just assume thatÙK** everything is Windows NT unless the programmer explicitly says otherwiseÙ#** by setting SQLITE_OS_WINNT to 0.¢*/Ù.#if SQLITE_OS_WIN && !defined(SQLITE_OS_WINNT)º# define SQLITE_OS_WINNT 1¦#endif ¢/*ÙI** Determine if we are dealing with Windows CE - which has a much reduced§** API.¢*/·#if defined(_WIN32_WCE)º# define SQLITE_OS_WINCE 1¥#elseº# define SQLITE_OS_WINCE 0¦#endif ¢/*ÙJ** Determine if we are dealing with WinRT, which provides only a subset of¶** the full Win32 API.¢*/½#if !defined(SQLITE_OS_WINRT)º# define SQLITE_OS_WINRT 0¦#endif ¢/*ÙJ** For WinCE, some API function parameters do not appear to be declared as¬** volatile.¢*/³#if SQLITE_OS_WINCE¾# define SQLITE_WIN32_VOLATILE¥#elseÙ'# define SQLITE_WIN32_VOLATILE volatile¦#endif ¢/*ÙH** For some Windows sub-platforms, the _beginthreadex() / _endthreadex()ÙH** functions are not available (e.g. those not using MSVC, Cygwin, etc).¢*/Ù>#if SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \Ù/    SQLITE_THREADSAFE>0 && !defined(__CYGWIN__)Ù # define SQLITE_OS_WIN_THREADS 1¥#elseÙ # define SQLITE_OS_WIN_THREADS 0¦#endif ¼#endif /* SQLITE_OS_WIN_H */ ÙO/************** End of os_win.h **********************************************/ÙO/************** Continuing where we left off in mutex_w32.c ******************/¦#endif ¢/*ÙG** The code in this file is only used if we are compiling multithreadedµ** on a Win32 system.¢*/·#ifdef SQLITE_MUTEX_W32 ¢/*ÙB** Each recursive mutex is an instance of the following structure.¢*/¶struct sqlite3_mutex {Ù=  CRITICAL_SECTION mutex;    /* Mutex controlling the lock */Ù-  int id;                    /* Mutex type */³#ifdef SQLITE_DEBUGÙ7  volatile int nRef;         /* Number of enterances */Ù<  volatile DWORD owner;      /* Thread holding this mutex */Ù8  volatile LONG trace;       /* True to trace changes */¦#endif¢}; ¢/*ÙH** These are the initializer values used when declaring a "static" mutexÙH** on Win32.  It should be noted that all mutexes require initialization¹** on the Win32 platform.¢*/Ù*#define SQLITE_W32_MUTEX_INITIALIZER { 0 } ³#ifdef SQLITE_DEBUGÙK#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id, \Ù5                                    0L, (DWORD)0, 0 }¥#elseÙJ#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id }¦#endif ³#ifdef SQLITE_DEBUG¢/*ÙC** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine areÙ4** intended for use only inside assert() statements.¢*/Ù*static int winMutexHeld(sqlite3_mutex *p){Ù6  return p->nRef!=0 && p->owner==GetCurrentThreadId();¡} Ù9static int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){Ù%  return p->nRef==0 || p->owner!=tid;¡} Ù-static int winMutexNotheld(sqlite3_mutex *p){Ù#  DWORD tid = GetCurrentThreadId();Ù"  return winMutexNotheld2(p, tid);¡}¦#endif ¢/*ÙG** Try to provide a memory barrier operation, needed for initializationÙI** and also for the xShmBarrier method of the VFS in cases when SQLite isÙ2** compiled without mutexes (SQLITE_THREADSAFE=0).¢*/Ù/SQLITE_PRIVATE void sqlite3MemoryBarrier(void){Ù"#if defined(SQLITE_MEMORY_BARRIER)¸  SQLITE_MEMORY_BARRIER;·#elif defined(__GNUC__)·  __sync_synchronize();¸#elif MSVC_VERSION>=1300¶  _ReadWriteBarrier();¼#elif defined(MemoryBarrier)²  MemoryBarrier();¦#endif¡} ¢/*Ù3** Initialize and deinitialize the mutex subsystem.¢*/Ù1static sqlite3_mutex winMutex_staticMutexes[] = {¿  SQLITE3_MUTEX_INITIALIZER(2),¿  SQLITE3_MUTEX_INITIALIZER(3),¿  SQLITE3_MUTEX_INITIALIZER(4),¿  SQLITE3_MUTEX_INITIALIZER(5),¿  SQLITE3_MUTEX_INITIALIZER(6),¿  SQLITE3_MUTEX_INITIALIZER(7),¿  SQLITE3_MUTEX_INITIALIZER(8),¿  SQLITE3_MUTEX_INITIALIZER(9),Ù   SQLITE3_MUTEX_INITIALIZER(10),Ù   SQLITE3_MUTEX_INITIALIZER(11),Ù   SQLITE3_MUTEX_INITIALIZER(12),¿  SQLITE3_MUTEX_INITIALIZER(13)¢}; ¿static int winMutex_isInit = 0;Ù=static int winMutex_isNt = -1; /* <0 means "need to query" */ ÙG/* As the winMutexInit() and winMutexEnd() functions are called as partÙE** of the sqlite3_initialize() and sqlite3_shutdown() processing, theÙD** "interlocked" magic used here is probably not strictly necessary.¢*/Ù4static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0; Ù8SQLITE_API int sqlite3_win32_is_nt(void); /* os_win.c */ÙGSQLITE_API void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */ ¾static int winMutexInit(void){Ù>  /* The first to increment to 1 does actual initialization */Ù<  if( InterlockedCompareExchange(&winMutex_lock, 1, 0)==0 ){ª    int i;Ù7    for(i=0; i<ArraySize(winMutex_staticMutexes); i++){³#if SQLITE_OS_WINRTÙJ      InitializeCriticalSectionEx(&winMutex_staticMutexes[i].mutex, 0, 0);¥#elseÙB      InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);¦#endif¥    }¸    winMutex_isInit = 1;¨  }else{ÙD    /* Another thread is (in the process of) initializing the static±    ** mutexes */¾    while( !winMutex_isInit ){½      sqlite3_win32_sleep(1);¥    }£  }³  return SQLITE_OK;¡} ½static int winMutexEnd(void){Ù5  /* The first to decrement to 0 does actual shutdownÙ/  ** (which should be the last to shutdown.) */Ù<  if( InterlockedCompareExchange(&winMutex_lock, 0, 1)==1 ){½    if( winMutex_isInit==1 ){¬      int i;Ù9      for(i=0; i<ArraySize(winMutex_staticMutexes); i++){Ù@        DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);§      }º      winMutex_isInit = 0;¥    }£  }³  return SQLITE_OK;¡} ¢/*Ù4** The sqlite3_mutex_alloc() routine allocates a newÙ9** mutex and returns a pointer to it.  If it returns NULLÙ:** that means that a mutex could not be allocated.  SQLiteÙ;** will unwind its stack and return an error.  The argumentÙ>** to sqlite3_mutex_alloc() is one of these integer constants:¢**§** <ul>º** <li>  SQLITE_MUTEX_FAST¿** <li>  SQLITE_MUTEX_RECURSIVEÙ#** <li>  SQLITE_MUTEX_STATIC_MASTERÙ ** <li>  SQLITE_MUTEX_STATIC_MEMÙ!** <li>  SQLITE_MUTEX_STATIC_OPENÙ!** <li>  SQLITE_MUTEX_STATIC_PRNGÙ ** <li>  SQLITE_MUTEX_STATIC_LRUÙ!** <li>  SQLITE_MUTEX_STATIC_PMEMÙ!** <li>  SQLITE_MUTEX_STATIC_APP1Ù!** <li>  SQLITE_MUTEX_STATIC_APP2Ù!** <li>  SQLITE_MUTEX_STATIC_APP3Ù!** <li>  SQLITE_MUTEX_STATIC_VFS1Ù!** <li>  SQLITE_MUTEX_STATIC_VFS2Ù!** <li>  SQLITE_MUTEX_STATIC_VFS3¨** </ul>¢**Ù@** The first two constants cause sqlite3_mutex_alloc() to createÙG** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVEÙA** is used but not necessarily so when SQLITE_MUTEX_FAST is used.Ù?** The mutex implementation does not need to make a distinctionÙB** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it doesÙB** not want to.  But SQLite will only request a recursive mutex inÙD** cases where it really needs one.  If a faster non-recursive mutexÙH** implementation is available on the host platform, the mutex subsystemÙ>** might return such a mutex in response to SQLITE_MUTEX_FAST.¢**ÙD** The other allowed parameters to sqlite3_mutex_alloc() each returnÙC** a pointer to a static preexisting mutex.  Six static mutexes areÙD** used by the current version of SQLite.  Future versions of SQLiteÙF** may add additional static mutexes.  Static mutexes are for internalÙC** use by SQLite only.  Applications that use SQLite mutexes shouldÙ@** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST orº** SQLITE_MUTEX_RECURSIVE.¢**ÙF** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FASTÙ@** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()Ù?** returns a different mutex on every call.  But for the staticÙA** mutex types, the same mutex is returned on every call that has¸** the same type number.¢*/Ù/static sqlite3_mutex *winMutexAlloc(int iType){³  sqlite3_mutex *p; ²  switch( iType ){»    case SQLITE_MUTEX_FAST:Ù"    case SQLITE_MUTEX_RECURSIVE: {Ù*      p = sqlite3MallocZero( sizeof(*p) );®      if( p ){¶        p->id = iType;³#ifdef SQLITE_DEBUGÙ'#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMICµ        p->trace = 1;¦#endif¦#endif³#if SQLITE_OS_WINRTÙ5        InitializeCriticalSectionEx(&p->mutex, 0, 0);¥#elseÙ-        InitializeCriticalSection(&p->mutex);¦#endif§      }¬      break;¥    }®    default: {¾#ifdef SQLITE_ENABLE_API_ARMORÙD      if( iType-2<0 || iType-2>=ArraySize(winMutex_staticMutexes) ){Ù!        (void)SQLITE_MISUSE_BKPT;±        return 0;§      }¦#endifÙ+      p = &winMutex_staticMutexes[iType-2];³#ifdef SQLITE_DEBUGÙ&#ifdef SQLITE_WIN32_MUTEX_TRACE_STATICÙ2      InterlockedCompareExchange(&p->trace, 1, 0);¦#endif¦#endif¬      break;¥    }£  }Ù!  assert( p==0 || p->id==iType );«  return p;¡}  ¢/*Ù(** This routine deallocates a previouslyÙ:** allocated mutex.  SQLite is careful to deallocate every»** mutex that it allocates.¢*/Ù+static void winMutexFree(sqlite3_mutex *p){®  assert( p );Ù&  assert( p->nRef==0 && p->owner==0 );ÙB  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){Ù%    DeleteCriticalSection(&p->mutex);´    sqlite3_free(p);¨  }else{¾#ifdef SQLITE_ENABLE_API_ARMOR½    (void)SQLITE_MISUSE_BKPT;¦#endif£  }¡} ¢/*ÙE** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attemptÙD** to enter a mutex.  If another thread is already within the mutex,ÙG** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will returnÙD** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OKÙK** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE canÙD** be entered multiple times by the same thread.  In such cases the,ÙF** mutex must be exited an equal number of times before another threadÙH** can enter.  If the same thread tries to enter any other kind of mutexÙ-** more than once, the behavior is undefined.¢*/Ù,static void winMutexEnter(sqlite3_mutex *p){Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ù#  DWORD tid = GetCurrentThreadId();¦#endif³#ifdef SQLITE_DEBUG®  assert( p );ÙF  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );¥#else®  assert( p );¦#endif¿  assert( winMutex_isInit==1 );Ù"  EnterCriticalSection(&p->mutex);³#ifdef SQLITE_DEBUGÙ%  assert( p->nRef>0 || p->owner==0 );±  p->owner = tid;¬  p->nRef++;±  if( p->trace ){ÙA    OSTRACE(("ENTER-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",Ù0             tid, p->id, p, p->trace, p->nRef));£  }¦#endif¡} Ù)static int winMutexTry(sqlite3_mutex *p){Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ù#  DWORD tid = GetCurrentThreadId();¦#endif·  int rc = SQLITE_BUSY;®  assert( p );ÙF  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );¤  /*ÙE  ** The sqlite3_mutex_try() routine is very rarely used, and when itÙH  ** is used it is merely an optimization.  So it is OK for it to alwaysª  ** fail.¤  **ÙH  ** The TryEnterCriticalSection() interface is only available on WinNT.ÙE  ** And some windows compilers complain if you try to use it withoutÙJ  ** first doing some #defines that prevent SQLite from building on Win98.ÙB  ** For that reason, we will omit this optimization for now.  See²  ** ticket #2685.¤  */Ù3#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400¿  assert( winMutex_isInit==1 );Ù2  assert( winMutex_isNt>=-1 && winMutex_isNt<=1 );¸  if( winMutex_isNt<0 ){Ù*    winMutex_isNt = sqlite3_win32_is_nt();£  }Ù1  assert( winMutex_isNt==0 || winMutex_isNt==1 );Ù<  if( winMutex_isNt && TryEnterCriticalSection(&p->mutex) ){³#ifdef SQLITE_DEBUG³    p->owner = tid;®    p->nRef++;¦#endif³    rc = SQLITE_OK;£  }¥#else¶  UNUSED_PARAMETER(p);¦#endif³#ifdef SQLITE_DEBUG±  if( p->trace ){ÙQ    OSTRACE(("TRY-MUTEX tid=%lu, mutex(%d)=%p (%d), owner=%lu, nRef=%d, rc=%s\n",ÙN             tid, p->id, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));£  }¦#endif¬  return rc;¡} ¢/*Ù;** The sqlite3_mutex_leave() routine exits a mutex that wasÙ7** previously entered by the same thread.  The behaviorÙ8** is undefined if the mutex is not currently entered orÙ<** is not currently allocated.  SQLite will never do either.¢*/Ù,static void winMutexLeave(sqlite3_mutex *p){Ù1#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)Ù#  DWORD tid = GetCurrentThreadId();¦#endif®  assert( p );³#ifdef SQLITE_DEBUG¶  assert( p->nRef>0 );º  assert( p->owner==tid );¬  p->nRef--;Ù   if( p->nRef==0 ) p->owner = 0;Ù8  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );¦#endif¿  assert( winMutex_isInit==1 );Ù"  LeaveCriticalSection(&p->mutex);³#ifdef SQLITE_DEBUG±  if( p->trace ){ÙA    OSTRACE(("LEAVE-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",Ù0             tid, p->id, p, p->trace, p->nRef));£  }¦#endif¡} ÙFSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){Ù/  static const sqlite3_mutex_methods sMutex = {±    winMutexInit,°    winMutexEnd,²    winMutexAlloc,±    winMutexFree,²    winMutexEnter,°    winMutexTry,²    winMutexLeave,³#ifdef SQLITE_DEBUG±    winMutexHeld,³    winMutexNotheld¥#else¦    0,¥    0¦#endif¤  };±  return &sMutex;¡} ½#endif /* SQLITE_MUTEX_W32 */ ÙO/************** End of mutex_w32.c *******************************************/ÙO/************** Begin file malloc.c ******************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**Ù6** Memory allocation functions used throughout sqlite.¢*/¼/* #include "sqliteInt.h" */¹/* #include <stdarg.h> */ ¢/*ÙE** Attempt to release up to n bytes of non-essential memory currentlyÙG** held by SQLite. An example of non-essential memory is memory used toÙ6** cache database pages that are not currently in use.¢*/Ù-SQLITE_API int sqlite3_release_memory(int n){Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTÙ'  return sqlite3PcacheReleaseMemory(n);¥#elseÙJ  /* IMPLEMENTATION-OF: R-34391-24921 The sqlite3_release_memory() routineÙ=  ** is a no-op returning zero if SQLite is not compiled withÙ(  ** SQLITE_ENABLE_MEMORY_MANAGEMENT. */¶  UNUSED_PARAMETER(n);«  return 0;¦#endif¡} ¢/*Ù>** State information local to the memory allocation subsystem.¢*/Ù%static SQLITE_WSD struct Mem0Global {Ù?  sqlite3_mutex *mutex;         /* Mutex to serialize access */Ù9  sqlite3_int64 alarmThreshold; /* The soft heap limit */ ¤  /*ÙA  ** True if heap is nearly "full" where "full" is defined by theÙ'  ** sqlite3_soft_heap_limit() setting.¤  */±  int nearlyFull;µ} mem0 = { 0, 0, 0 }; Ù,#define mem0 GLOBAL(struct Mem0Global, mem0) ¢/*Ù@** Return the memory allocator mutex. sqlite3_status() needs it.¢*/Ù7SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void){´  return mem0.mutex;¡} ¾#ifndef SQLITE_OMIT_DEPRECATED¢/*ÙC** Deprecated external interface.  It used to set an alarm callbackÙB** that was invoked when memory usage grew too large.  Now it is a©** no-op.¢*/Ù$SQLITE_API int sqlite3_memory_alarm(Ù9  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),­  void *pArg,º  sqlite3_int64 iThreshold¢){²  (void)xCallback;­  (void)pArg;³  (void)iThreshold;³  return SQLITE_OK;¡}¦#endif ¢/*ÙC** Set the soft heap-size limit for the library. Passing a zero or Ù%** negative value indicates no limit.¢*/ÙDSQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){»  sqlite3_int64 priorLimit;·  sqlite3_int64 excess;¶  sqlite3_int64 nUsed;¼#ifndef SQLITE_OMIT_AUTOINITÙ   int rc = sqlite3_initialize();µ  if( rc ) return -1;¦#endifÙ"  sqlite3_mutex_enter(mem0.mutex);Ù#  priorLimit = mem0.alarmThreshold;¬  if( n<0 ){Ù$    sqlite3_mutex_leave(mem0.mutex);¶    return priorLimit;£  }º  mem0.alarmThreshold = n;Ù8  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);Ù&  mem0.nearlyFull = (n>0 && n<=nUsed);Ù"  sqlite3_mutex_leave(mem0.mutex);Ù%  excess = sqlite3_memory_used() - n;ÙD  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));´  return priorLimit;¡}Ù/SQLITE_API void sqlite3_soft_heap_limit(int n){²  if( n<0 ) n = 0;¿  sqlite3_soft_heap_limit64(n);¡} ¢/*Ù.** Initialize the memory allocation subsystem.¢*/Ù+SQLITE_PRIVATE int sqlite3MallocInit(void){©  int rc;Ù)  if( sqlite3GlobalConfig.m.xMalloc==0 ){»    sqlite3MemSetDefault();£  }Ù!  memset(&mem0, 0, sizeof(mem0));Ù:  mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);ÙD  if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512Ù(      || sqlite3GlobalConfig.nPage<=0 ){Ù"    sqlite3GlobalConfig.pPage = 0;Ù#    sqlite3GlobalConfig.szPage = 0;£  }ÙC  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);Ù5  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));¬  return rc;¡} ¢/*ÙH** Return true if the heap is currently under memory pressure - in otherÙ@** words if the amount of heap used is close to the limit set by½** sqlite3_soft_heap_limit().¢*/Ù/SQLITE_PRIVATE int sqlite3HeapNearlyFull(void){¹  return mem0.nearlyFull;¡} ¢/*Ù0** Deinitialize the memory allocation subsystem.¢*/Ù+SQLITE_PRIVATE void sqlite3MallocEnd(void){Ù(  if( sqlite3GlobalConfig.m.xShutdown ){ÙD    sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData);£  }Ù!  memset(&mem0, 0, sizeof(mem0));¡} ¢/*Ù5** Return the amount of memory currently checked out.¢*/Ù3SQLITE_API sqlite3_int64 sqlite3_memory_used(void){¸  sqlite3_int64 res, mx;Ù<  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);­  return res;¡} ¢/*Ù9** Return the maximum amount of memory that has ever beenÙ9** checked out since either the beginning of this processÙ"** or since the most recent reset.¢*/ÙASQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){¸  sqlite3_int64 res, mx;ÙD  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);¬  return mx;¡} ¢/*µ** Trigger the alarm ¢*/Ù*static void sqlite3MallocAlarm(int nByte){Ù&  if( mem0.alarmThreshold<=0 ) return;Ù"  sqlite3_mutex_leave(mem0.mutex);Ù   sqlite3_release_memory(nByte);Ù"  sqlite3_mutex_enter(mem0.mutex);¡} ¢/*ÙA** Do a memory allocation with statistics and alarms.  Assume the¸** lock is already held.¢*/Ù.static void mallocWithAlarm(int n, void **pp){ª  void *p;¬  int nFull;Ù+  assert( sqlite3_mutex_held(mem0.mutex) );°  assert( n>0 ); ÙI  /* In Firefox (circa 2017-02-08), xRoundup() is remapped to an internalÙH  ** implementation of malloc_good_size(), which must be called in debugÙI  ** mode and specifically when the DMD "Dark Matter Detector" is enabledÙH  ** or else a crash results.  Hence, do not attempt to optimize out theÙ"  ** following xRoundup() call. */Ù,  nFull = sqlite3GlobalConfig.m.xRoundup(n); ¸#ifdef SQLITE_MAX_MEMORYÙN  if( sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)+nFull>SQLITE_MAX_MEMORY ){¬    *pp = 0;«    return;£  }¦#endif Ù7  sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);¾  if( mem0.alarmThreshold>0 ){ÙH    sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);Ù/    if( nUsed >= mem0.alarmThreshold - nFull ){º      mem0.nearlyFull = 1;Ù       sqlite3MallocAlarm(nFull);ª    }else{º      mem0.nearlyFull = 0;¥    }£  }Ù+  p = sqlite3GlobalConfig.m.xMalloc(nFull);Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTÙ&  if( p==0 && mem0.alarmThreshold>0 ){¾    sqlite3MallocAlarm(nFull);Ù-    p = sqlite3GlobalConfig.m.xMalloc(nFull);£  }¦#endifª  if( p ){Ù!    nFull = sqlite3MallocSize(p);Ù6    sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);Ù3    sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);£  }ª  *pp = p;¡} ¢/*ÙI** Allocate memory.  This routine is like sqlite3_malloc() except that itÙ=** assumes the memory subsystem has already been initialized.¢*/Ù*SQLITE_PRIVATE void *sqlite3Malloc(u64 n){ª  void *p;¾  if( n==0 || n>=0x7fffff00 ){ÙI    /* A memory allocation of a number of bytes which is near the maximumÙI    ** signed integer value might cause an integer overflow inside of theÙH    ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, givingÙI    ** 255 bytes of overhead.  SQLite itself will never use anything nearÙP    ** this amount.  The only way to reach the limit is with sqlite3_malloc() */ª    p = 0;Ù+  }else if( sqlite3GlobalConfig.bMemstat ){Ù$    sqlite3_mutex_enter(mem0.mutex);Ù     mallocWithAlarm((int)n, &p);Ù$    sqlite3_mutex_leave(mem0.mutex);¨  }else{Ù.    p = sqlite3GlobalConfig.m.xMalloc((int)n);£  }Ù>  assert( EIGHT_BYTE_ALIGNMENT(p) );  /* IMP: R-11148-40995 */«  return p;¡} ¢/*ÙG** This version of the memory allocation is for use by the application.ÙC** First make sure the memory subsystem is initialized, then do the®** allocation.¢*/Ù'SQLITE_API void *sqlite3_malloc(int n){¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ%  return n<=0 ? 0 : sqlite3Malloc(n);¡}Ù4SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n){¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifº  return sqlite3Malloc(n);¡} ¢/*Ù5** TRUE if p is a lookaside memory allocation from db¢*/½#ifndef SQLITE_OMIT_LOOKASIDEÙ-static int isLookaside(sqlite3 *db, void *p){ÙD  return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pEnd);¡}¥#elseº#define isLookaside(A,B) 0¦#endif ¢/*ÙB** Return the size of a memory allocation previously obtained fromÙ'** sqlite3Malloc() or sqlite3_malloc().¢*/Ù.SQLITE_PRIVATE int sqlite3MallocSize(void *p){Ù4  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );Ù(  return sqlite3GlobalConfig.m.xSize(p);¡}Ù=SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){±  assert( p!=0 );Ù$  if( db==0 || !isLookaside(db,p) ){³#ifdef SQLITE_DEBUG°    if( db==0 ){Ù<      assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );Ù8      assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );ª    }else{ÙL      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ÙP      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );¥    }¦#endifÙ*    return sqlite3GlobalConfig.m.xSize(p);¨  }else{Ù,    assert( sqlite3_mutex_held(db->mutex) );¼    return db->lookaside.sz;£  }¡}Ù1SQLITE_API sqlite3_uint64 sqlite3_msize(void *p){Ù8  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );Ù4  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );Ù0  return p ? sqlite3GlobalConfig.m.xSize(p) : 0;¡} ¢/*Ù8** Free memory previously obtained from sqlite3Malloc().¢*/Ù&SQLITE_API void sqlite3_free(void *p){Ù.  if( p==0 ) return;  /* IMP: R-49053-54554 */Ù4  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );Ù8  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );Ù%  if( sqlite3GlobalConfig.bMemstat ){Ù$    sqlite3_mutex_enter(mem0.mutex);ÙG    sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));Ù5    sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);Ù#    sqlite3GlobalConfig.m.xFree(p);Ù$    sqlite3_mutex_leave(mem0.mutex);¨  }else{Ù#    sqlite3GlobalConfig.m.xFree(p);£  }¡} ¢/*Ù8** Add the size of memory allocation "p" to the count inµ** *db->pnBytesFreed.¢*/ÙHstatic SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){Ù1  *db->pnBytesFreed += sqlite3DbMallocSize(db,p);¡} ¢/*ÙB** Free memory that might be associated with a particular databaseÙH** connection.  Calling sqlite3DbFree(D,X) for X==0 is a harmless no-op.Ù@** The sqlite3DbFreeNN(D,X) version requires that X be non-NULL.¢*/Ù:SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3 *db, void *p){Ù3  assert( db==0 || sqlite3_mutex_held(db->mutex) );±  assert( p!=0 );«  if( db ){»    if( db->pnBytesFreed ){Ù#      measureAllocationSize(db, p);­      return;¥    }½    if( isLookaside(db, p) ){Ù.      LookasideSlot *pBuf = (LookasideSlot*)p;³#ifdef SQLITE_DEBUGÙ7      /* Trash all content in the buffer being freed */Ù(      memset(p, 0xaa, db->lookaside.sz);¦#endifÙ(      pBuf->pNext = db->lookaside.pFree;Ù!      db->lookaside.pFree = pBuf;­      return;¥    }£  }ÙH  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ÙL  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ÙA  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );Ù*  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);²  sqlite3_free(p);¡}Ù8SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){Ù3  assert( db==0 || sqlite3_mutex_held(db->mutex) );Ù!  if( p ) sqlite3DbFreeNN(db, p);¡} ¢/*Ù3** Change the size of an existing memory allocation¢*/Ù<SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){¸  int nOld, nNew, nDiff;­  void *pNew;Ù7  assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );Ù;  assert( sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP) );°  if( pOld==0 ){Ù:    return sqlite3Malloc(nBytes); /* IMP: R-04300-56712 */£  }²  if( nBytes==0 ){Ù0    sqlite3_free(pOld); /* IMP: R-26507-47431 */­    return 0;£  }»  if( nBytes>=0x7fffff00 ){ÙN    /* The 0x7ffff00 limit term is explained in comments on sqlite3Malloc() */­    return 0;£  }Ù!  nOld = sqlite3MallocSize(pOld);ÙG  /* IMPLEMENTATION-OF: R-46199-30249 SQLite guarantees that the secondÙG  ** argument to xRealloc is always a value returned by a prior call to±  ** xRoundup. */Ù5  nNew = sqlite3GlobalConfig.m.xRoundup((int)nBytes);³  if( nOld==nNew ){°    pNew = pOld;Ù+  }else if( sqlite3GlobalConfig.bMemstat ){Ù$    sqlite3_mutex_enter(mem0.mutex);ÙC    sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, (int)nBytes);¸    nDiff = nNew - nOld;ÙD    if( nDiff>0 && sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED) >= Ù&          mem0.alarmThreshold-nDiff ){Ù       sqlite3MallocAlarm(nDiff);¥    }Ù6    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);Ù+    if( pNew==0 && mem0.alarmThreshold>0 ){Ù&      sqlite3MallocAlarm((int)nBytes);Ù8      pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);¥    }¯    if( pNew ){Ù%      nNew = sqlite3MallocSize(pNew);Ù<      sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew-nOld);¥    }Ù$    sqlite3_mutex_leave(mem0.mutex);¨  }else{Ù6    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);£  }Ù@  assert( EIGHT_BYTE_ALIGNMENT(pNew) ); /* IMP: R-11148-40995 */®  return pNew;¡} ¢/*ÙE** The public interface to sqlite3Realloc.  Make sure that the memoryÙ<** subsystem is initialized prior to invoking sqliteRealloc.¢*/Ù4SQLITE_API void *sqlite3_realloc(void *pOld, int n){¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ,  if( n<0 ) n = 0;  /* IMP: R-26507-47431 */Ù!  return sqlite3Realloc(pOld, n);¡}ÙASQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ!  return sqlite3Realloc(pOld, n);¡}  ¢/*¼** Allocate and zero memory.£*/ Ù.SQLITE_PRIVATE void *sqlite3MallocZero(u64 n){½  void *p = sqlite3Malloc(n);ª  if( p ){¼    memset(p, 0, (size_t)n);£  }«  return p;¡} ¢/*Ù;** Allocate and zero memory.  If the allocation fails, makeÙ3** the mallocFailed flag in the connection pointer.¢*/Ù=SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n){ª  void *p;´  testcase( db==0 );Ù   p = sqlite3DbMallocRaw(db, n);Ù"  if( p ) memset(p, 0, (size_t)n);«  return p;¡}  Ù>/* Finish the work of sqlite3DbMallocRawNN for the unusual andÙG** slower case when the allocation cannot be fulfilled using lookaside.¢*/ÙCstatic SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){ª  void *p;²  assert( db!=0 );·  p = sqlite3Malloc(n);¿  if( !p ) sqlite3OomFault(db);¼  sqlite3MemdebugSetType(p, ÙI         (db->lookaside.bDisable==0) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP);«  return p;¡} ¢/*Ù=** Allocate memory, either lookaside (if possible) or heap.  Ù8** If the allocation fails, set the mallocFailed flag inº** the connection pointer.¢**ÙC** If db!=0 and db->mallocFailed is true (indicating a prior mallocÙA** failure on the same database connection) then always return 0.ÙA** Hence for a particular database connection, once malloc startsÙ>** failing, it fails consistently until mallocFailed is reset.ÙA** This is an important assumption.  There are many places in theÙ!** code that do things like this:¢**Ù6**         int *a = (int*)sqlite3DbMallocRaw(db, 100);Ù6**         int *b = (int*)sqlite3DbMallocRaw(db, 200);½**         if( b ) a[10] = 9;¢**ÙI** In other words, if a subsequent malloc (ex: "b") worked, it is assumedÙ/** that all prior mallocs (ex: "a") worked too.¢**ÙI** The sqlite3MallocRawNN() variant guarantees that the "db" parameter is¶** not a NULL pointer.¢*/Ù<SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){ª  void *p;Ù.  if( db ) return sqlite3DbMallocRawNN(db, n);·  p = sqlite3Malloc(n);Ù*  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);«  return p;¡}Ù>SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){½#ifndef SQLITE_OMIT_LOOKASIDE¶  LookasideSlot *pBuf;²  assert( db!=0 );Ù*  assert( sqlite3_mutex_held(db->mutex) );Ù   assert( db->pnBytesFreed==0 );Ù"  if( db->lookaside.bDisable==0 ){Ù"    assert( db->mallocFailed==0 );½    if( n>db->lookaside.sz ){Ù       db->lookaside.anStat[1]++;Ù0    }else if( (pBuf = db->lookaside.pFree)!=0 ){Ù(      db->lookaside.pFree = pBuf->pNext;Ù       db->lookaside.anStat[0]++;¹      return (void*)pBuf;Ù0    }else if( (pBuf = db->lookaside.pInit)!=0 ){Ù(      db->lookaside.pInit = pBuf->pNext;Ù       db->lookaside.anStat[0]++;¹      return (void*)pBuf;ª    }else{Ù       db->lookaside.anStat[2]++;¥    }¿  }else if( db->mallocFailed ){­    return 0;£  }¥#else²  assert( db!=0 );Ù*  assert( sqlite3_mutex_held(db->mutex) );Ù   assert( db->pnBytesFreed==0 );¹  if( db->mallocFailed ){­    return 0;£  }¦#endifÙ"  return dbMallocRawFinish(db, n);¡} ¹/* Forward declaration */ÙJstatic SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n); ¢/*Ù@** Resize the block of memory pointed to by p to n bytes. If theÙD** resize fails, set the mallocFailed flag in the connection object.¢*/ÙCSQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){²  assert( db!=0 );Ù0  if( p==0 ) return sqlite3DbMallocRawNN(db, n);Ù*  assert( sqlite3_mutex_held(db->mutex) );Ù:  if( isLookaside(db,p) && n<=db->lookaside.sz ) return p;Ù#  return dbReallocFinish(db, p, n);¡}ÙJstatic SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){±  void *pNew = 0;²  assert( db!=0 );±  assert( p!=0 );¼  if( db->mallocFailed==0 ){½    if( isLookaside(db, p) ){Ù)      pNew = sqlite3DbMallocRawNN(db, n);±      if( pNew ){Ù*        memcpy(pNew, p, db->lookaside.sz);½        sqlite3DbFree(db, p);§      }ª    }else{ÙL      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );ÙP      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );Ù.      sqlite3MemdebugSetType(p, MEMTYPE_HEAP);Ù%      pNew = sqlite3_realloc64(p, n);²      if( !pNew ){¼        sqlite3OomFault(db);§      }Ù"      sqlite3MemdebugSetType(pNew,ÙL            (db->lookaside.bDisable==0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));¥    }£  }®  return pNew;¡} ¢/*ÙC** Attempt to reallocate p.  If the reallocation fails, then free pÙ<** and set the mallocFailed flag in the database connection.¢*/ÙISQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){­  void *pNew;Ù$  pNew = sqlite3DbRealloc(db, p, n);®  if( !pNew ){¹    sqlite3DbFree(db, p);£  }®  return pNew;¡} ¢/*ÙI** Make a copy of a string in memory obtained from sqliteMalloc(). These ÙM** functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). ThisÙJ** is because when memory debugging is turned on, these two functions are ÙH** called via macros that record the current file and line number in the¸** ThreadData structure.¢*/ÙASQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){­  char *zNew;«  size_t n;­  if( z==0 ){­    return 0;£  }´  n = strlen(z) + 1;Ù#  zNew = sqlite3DbMallocRaw(db, n);­  if( zNew ){·    memcpy(zNew, z, n);£  }®  return zNew;¡}ÙISQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){­  char *zNew;²  assert( db!=0 );­  if( z==0 ){­    return 0;£  }¾  assert( (n&0x7fffffff)==n );Ù'  zNew = sqlite3DbMallocRawNN(db, n+1);­  if( zNew ){¿    memcpy(zNew, z, (size_t)n);°    zNew[n] = 0;£  }®  return zNew;¡} ¢/*ÙG** The text between zStart and zEnd represents a phrase within a largerÙD** SQL statement.  Make a copy of this phrase in space obtained formÙ<** sqlite3DbMalloc().  Omit leading and trailing whitespace.¢*/ÙYSQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){¨  int n;Ù.  while( sqlite3Isspace(zStart[0]) ) zStart++;»  n = (int)(zEnd - zStart);Ù:  while( ALWAYS(n>0) && sqlite3Isspace(zStart[n-1]) ) n--;Ù)  return sqlite3DbStrNDup(db, zStart, n);¡} ¢/*ÙD** Free any prior content in *pz and replace it with a copy of zNew.¢*/ÙOSQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){¹  sqlite3DbFree(db, *pz);Ù"  *pz = sqlite3DbStrDup(db, zNew);¡} ¢/*ÙI** Call this routine to record the fact that an OOM (out-of-memory) errorÙB** has happened.  This routine will set db->mallocFailed, and alsoÙC** temporarily disable the lookaside memory allocator and interruptµ** any running VDBEs.¢*/Ù1SQLITE_PRIVATE void sqlite3OomFault(sqlite3 *db){Ù4  if( db->mallocFailed==0 && db->bBenignMalloc==0 ){¹    db->mallocFailed = 1;º    if( db->nVdbeExec>0 ){¿      db->u1.isInterrupted = 1;¥    }½    db->lookaside.bDisable++;£  }¡} ¢/*Ù?** This routine reactivates the memory allocator and clears theÙ&** db->mallocFailed flag as necessary.¢**Ù=** The memory allocator is not restarted if there are running©** VDBEs.¢*/Ù1SQLITE_PRIVATE void sqlite3OomClear(sqlite3 *db){Ù-  if( db->mallocFailed && db->nVdbeExec==0 ){¹    db->mallocFailed = 0;½    db->u1.isInterrupted = 0;Ù'    assert( db->lookaside.bDisable>0 );½    db->lookaside.bDisable--;£  }¡} ¢/*ÙB** Take actions at the end of an API call to indicate an OOM error¢*/Ù4static SQLITE_NOINLINE int apiOomError(sqlite3 *db){¶  sqlite3OomClear(db);Ù!  sqlite3Error(db, SQLITE_NOMEM);»  return SQLITE_NOMEM_BKPT;¡} ¢/*ÙF** This function must be called before exiting any API function (i.e. ÙC** returning control to the user) that has called sqlite3_malloc or³** sqlite3_realloc.¢**ÙG** The returned value is normally a copy of the second argument to thisÙK** function. However, if a malloc() failure has occurred since the previousÙ0** invocation SQLITE_NOMEM is returned instead. ¢**ÙC** If an OOM as occurred, then the connection error-code (the valueÙ9** returned by sqlite3_errcode()) is set to SQLITE_NOMEM.¢*/Ù7SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){ÙA  /* If the db handle must hold the connection handle mutex here.ÙA  ** Otherwise the read (and possible write) of db->mallocFailed Ù1  ** is unsafe, as is the call to sqlite3Error().¤  */²  assert( db!=0 );Ù*  assert( sqlite3_mutex_held(db->mutex) );Ù3  if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){»    return apiOomError(db);£  }º  return rc & db->errMask;¡} ÙO/************** End of malloc.c **********************************************/ÙO/************** Begin file printf.c ******************************************/¢/*ÙB** The "printf" code that follows dates from the 1980's.  It is in¶** the public domain. ¢**ÙJ**************************************************************************¢**ÙF** This file contains code for a set of "printf"-like routines.  TheseÙE** routines format strings much like the printf() from the standard CÙF** library, though the implementation here has enhancements to supportª** SQLite.¢*/¼/* #include "sqliteInt.h" */ ¢/*ÙB** Conversion types fall into various categories as defined by the¹** following enumeration.¢*/Ù?#define etRADIX       0 /* non-decimal integer types.  %x %o */Ù1#define etFLOAT       1 /* Floating point.  %f */Ù?#define etEXP         2 /* Exponentional notation. %e and %E */ÙP#define etGENERIC     3 /* Floating or exponential, depending on exponent. %g */ÙN#define etSIZE        4 /* Return number of characters processed so far. %n */Ù)#define etSTRING      5 /* Strings. %s */Ù?#define etDYNSTRING   6 /* Dynamically allocated strings. %z */Ù0#define etPERCENT     7 /* Percent symbol. %% */Ù,#define etCHARX       8 /* Characters. %c */Ù=/* The rest are extensions, not normally found in printf() */Ù<#define etSQLESCAPE   9 /* Strings with '\'' doubled.  %q */ÙH#define etSQLESCAPE2 10 /* Strings with '\'' doubled and enclosed in '',ÙD                          NULL pointers replaced by SQL NULL.  %Q */Ù<#define etTOKEN      11 /* a pointer to a Token structure */Ù4#define etSRCLIST    12 /* a pointer to a SrcList */Ù/#define etPOINTER    13 /* The %p conversion */Ù=#define etSQLESCAPE3 14 /* %w -> Strings with '\"' doubled */ÙJ#define etORDINAL    15 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */Ù6#define etDECIMAL    16 /* %d or %u, but not %x, %o */ Ù>#define etINVALID    17 /* Any unrecognized conversion type */  ¢/*Ù*** An "etByte" is an 8-bit unsigned value.¢*/½typedef unsigned char etByte; ¢/*ÙG** Each builtin conversion character (ex: the 'd' in "%d") is describedÙ,** by an instance of the following structure¢*/ÙDtypedef struct et_info {   /* Information about each format field */Ù=  char fmttype;            /* The format field code letter */Ù>  etByte base;             /* The base for radix conversion */ÙE  etByte flags;            /* One or more of FLAG_ constants below */Ù4  etByte type;             /* Conversion paradigm */ÙK  etByte charset;          /* Offset into aDigits[] of the digits string */ÙK  etByte prefix;           /* Offset into aPrefix[] of the prefix string */ª} et_info; ¢/*Ù#** Allowed values for et_info.flags¢*/ÙI#define FLAG_SIGNED    1     /* True if the value to convert is signed */Ù;#define FLAG_STRING    4     /* Allow infinite precision */  ¢/*ÙE** The following table is searched linearly, so it is good to put theÙ/** most frequently used conversion types first.¢*/ÙAstatic const char aDigits[] = "0123456789ABCDEF0123456789abcdef";Ù*static const char aPrefix[] = "-x0\000X0";Ù"static const et_info fmtinfo[] = {Ù'  {  'd', 10, 1, etDECIMAL,    0,  0 },Ù'  {  's',  0, 4, etSTRING,     0,  0 },Ù'  {  'g',  0, 1, etGENERIC,    30, 0 },Ù'  {  'z',  0, 4, etDYNSTRING,  0,  0 },Ù'  {  'q',  0, 4, etSQLESCAPE,  0,  0 },Ù'  {  'Q',  0, 4, etSQLESCAPE2, 0,  0 },Ù'  {  'w',  0, 4, etSQLESCAPE3, 0,  0 },Ù'  {  'c',  0, 0, etCHARX,      0,  0 },Ù'  {  'o',  8, 0, etRADIX,      0,  2 },Ù'  {  'u', 10, 0, etDECIMAL,    0,  0 },Ù'  {  'x', 16, 0, etRADIX,      16, 1 },Ù'  {  'X', 16, 0, etRADIX,      0,  4 },Ù"#ifndef SQLITE_OMIT_FLOATING_POINTÙ'  {  'f',  0, 1, etFLOAT,      0,  0 },Ù'  {  'e',  0, 1, etEXP,        30, 0 },Ù'  {  'E',  0, 1, etEXP,        14, 0 },Ù'  {  'G',  0, 1, etGENERIC,    14, 0 },¦#endifÙ'  {  'i', 10, 1, etDECIMAL,    0,  0 },Ù'  {  'n',  0, 0, etSIZE,       0,  0 },Ù'  {  '%',  0, 0, etPERCENT,    0,  0 },Ù'  {  'p', 16, 0, etPOINTER,    0,  1 }, ÙC  /* All the rest are undocumented and are for internal use only */Ù'  {  'T',  0, 0, etTOKEN,      0,  0 },Ù'  {  'S',  0, 0, etSRCLIST,    0,  0 },Ù'  {  'r', 10, 1, etORDINAL,    0,  0 },¢}; ¢/*ÙL** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point¹** conversions will work.¢*/Ù"#ifndef SQLITE_OMIT_FLOATING_POINT¢/*Ù2** "*val" is a double such that 0.1 <= *val < 10.0Ù<** Return the ascii code for the leading digit of *val, thenÙ*** multiply "*val" by 10.0 to renormalize.¢**«** Example:Ù **     input:     *val = 3.14159Ù8**     output:    *val = 1.4159    function return = '3'¢**ÙD** The counter *cnt is incremented each time.  After counter exceedsÙA** 16 (the number of significant digits in a 64-bit float) '0' is³** always returned.¢*/Ù8static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){¬  int digit;´  LONGDOUBLE_TYPE d;½  if( (*cnt)<=0 ) return '0';«  (*cnt)--;´  digit = (int)*val;¬  d = digit;¯  digit += '0';¹  *val = (*val - d)*10.0;µ  return (char)digit;¡}Ù'#endif /* SQLITE_OMIT_FLOATING_POINT */ ¢/*Ù,** Set the StrAccum object to an error mode.¢*/Ù5static void setStrAccumError(StrAccum *p, u8 eError){Ù>  assert( eError==STRACCUM_NOMEM || eError==STRACCUM_TOOBIG );·  p->accError = eError;°  p->nAlloc = 0;¡} ¢/*Ù6** Extra argument values from a PrintfArguments object¢*/Ù3static sqlite3_int64 getIntArg(PrintfArguments *p){Ù#  if( p->nArg<=p->nUsed ) return 0;Ù3  return sqlite3_value_int64(p->apArg[p->nUsed++]);¡}Ù/static double getDoubleArg(PrintfArguments *p){Ù%  if( p->nArg<=p->nUsed ) return 0.0;Ù4  return sqlite3_value_double(p->apArg[p->nUsed++]);¡}Ù,static char *getTextArg(PrintfArguments *p){Ù#  if( p->nArg<=p->nUsed ) return 0;Ù9  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);¡}  ¢/*Ù<** On machines with a small stack size, you can redefine theÙ=** SQLITE_PRINT_BUF_SIZE to be something smaller, if desired.¢*/½#ifndef SQLITE_PRINT_BUF_SIZEÙ!# define SQLITE_PRINT_BUF_SIZE 70¦#endifÙH#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */ ¢/*Ù;** Render a string given by "fmt" into the StrAccum object.¢*/Ù$SQLITE_PRIVATE void sqlite3VXPrintf(Ù:  StrAccum *pAccum,          /* Accumulate results here */Ù0  const char *fmt,           /* Format string */Ù,  va_list ap                 /* arguments */¢){ÙF  int c;                     /* Next character in the format string */ÙC  char *bufpt;               /* Pointer to the conversion buffer */ÙA  int precision;             /* Precision of the current field */Ù6  int length;                /* Length of the field */ÙA  int idx;                   /* A general purpose loop counter */Ù=  int width;                 /* Width of the current field */Ù>  etByte flag_leftjustify;   /* True if "-" flag is present */Ù=  etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */Ù>  etByte flag_alternateform; /* True if "#" flag is present */Ù>  etByte flag_altform2;      /* True if "!" flag is present */ÙP  etByte flag_zeropad;       /* True if field width constant starts with zero */ÙO  etByte flag_long;          /* 1 for the "l" flag, 2 for "ll", 0 by default */Ù8  etByte done;               /* Loop termination flag */ÙD  etByte cThousand;          /* Thousands separator for %d and %u */Ù6  etByte xtype = etINVALID;  /* Conversion paradigm */ÙA  u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */ÙP  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */Ù:  sqlite_uint64 longvalue;   /* Value for integer types */Ù7  LONGDOUBLE_TYPE realvalue; /* Value for real types */ÙL  const et_info *infop;      /* Pointer to the appropriate info structure */Ù3  char *zOut;                /* Rendering buffer */Ù?  int nOut;                  /* Size of the rendering buffer */ÙJ  char *zExtra = 0;          /* Malloced memory used by some conversion */Ù"#ifndef SQLITE_OMIT_FLOATING_POINTÙ;  int  exp, e2;              /* exponent of real numbers */ÙH  int nsd;                   /* Number of significant digits returned */ÙJ  double rounder;            /* Used for rounding floating point values */ÙH  etByte flag_dp;            /* True if decimal point should be shown */ÙK  etByte flag_rtz;           /* True if trailing zeros should be removed */¦#endifÙJ  PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */Ù4  char buf[etBUFSIZE];       /* Conversion buffer */ ÙI  /* pAccum never starts out with an empty buffer that was obtained from ÙE  ** malloc().  This precondition is required by the mprintf("%z...")µ  ** optimization. */ÙO  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 ); ¬  bufpt = 0;Ù9  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){Ù,    pArgList = va_arg(ap, PrintfArguments*);±    bArgList = 1;¨  }else{±    bArgList = 0;£  }¾  for(; (c=(*fmt))!=0; ++fmt){±    if( c!='%' ){º      bufpt = (char *)fmt;²#if HAVE_STRCHRNULÙ       fmt = strchrnul(fmt, '%');¥#elseÙ/      do{ fmt++; }while( *fmt && *fmt != '%' );¦#endifÙ?      sqlite3StrAccumAppend(pAccum, bufpt, (int)(fmt - bufpt));º      if( *fmt==0 ) break;¥    }º    if( (c=(*++fmt))==0 ){Ù,      sqlite3StrAccumAppend(pAccum, "%", 1);¬      break;¥    }Ù)    /* Find out what flags are present */Ù0    flag_leftjustify = flag_prefix = cThousand =Ù;     flag_alternateform = flag_altform2 = flag_zeropad = 0;­    done = 0;§    do{²      switch( c ){Ù4        case '-':   flag_leftjustify = 1;     break;Ù4        case '+':   flag_prefix = '+';        break;Ù4        case ' ':   flag_prefix = ' ';        break;Ù4        case '#':   flag_alternateform = 1;   break;Ù4        case '!':   flag_altform2 = 1;        break;Ù4        case '0':   flag_zeropad = 1;         break;Ù4        case ',':   cThousand = ',';          break;Ù4        default:    done = 1;                 break;§      }Ù'    }while( !done && (c=(*++fmt))!=0 );½    /* Get the field width */±    if( c=='*' ){µ      if( bArgList ){Ù)        width = (int)getIntArg(pArgList);¬      }else{¿        width = va_arg(ap,int);§      }´      if( width<0 ){½        flag_leftjustify = 1;Ù2        width = width >= -2147483647 ? -width : 0;§      }±      c = *++fmt;ª    }else{¶      unsigned wx = 0;Ù       while( c>='0' && c<='9' ){½        wx = wx*10 + c - '0';³        c = *++fmt;§      }Ù       testcase( wx>0x7fffffff );¾      width = wx & 0x7fffffff;¥    }·    assert( width>=0 );Ù$#ifdef SQLITE_PRINTF_PRECISION_LIMITÙ.    if( width>SQLITE_PRINTF_PRECISION_LIMIT ){Ù,      width = SQLITE_PRINTF_PRECISION_LIMIT;¥    }¦#endif »    /* Get the precision */±    if( c=='.' ){±      c = *++fmt;³      if( c=='*' ){·        if( bArgList ){Ù/          precision = (int)getIntArg(pArgList);®        }else{Ù%          precision = va_arg(ap,int);©        }³        c = *++fmt;º        if( precision<0 ){ÙA          precision = precision >= -2147483647 ? -precision : -1;©        }¬      }else{¸        unsigned px = 0;Ù"        while( c>='0' && c<='9' ){¿          px = px*10 + c - '0';µ          c = *++fmt;©        }Ù"        testcase( px>0x7fffffff );Ù$        precision = px & 0x7fffffff;§      }ª    }else{µ      precision = -1;¥    }¾    assert( precision>=(-1) );Ù$#ifdef SQLITE_PRINTF_PRECISION_LIMITÙ2    if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){Ù0      precision = SQLITE_PRINTF_PRECISION_LIMIT;¥    }¦#endif  Ù*    /* Get the conversion type modifier */±    if( c=='l' ){´      flag_long = 1;±      c = *++fmt;³      if( c=='l' ){¶        flag_long = 2;³        c = *++fmt;§      }ª    }else{´      flag_long = 0;¥    }Ù,    /* Fetch the info entry for the field */¸    infop = &fmtinfo[0];¶    xtype = etINVALID;Ù.    for(idx=0; idx<ArraySize(fmtinfo); idx++){Ù$      if( c==fmtinfo[idx].fmttype ){¾        infop = &fmtinfo[idx];¼        xtype = infop->type;®        break;§      }¥    } ¦    /*Ù;    ** At this point, variables are initialized as follows:¦    **Ù>    **   flag_alternateform          TRUE if a '#' is present.Ù>    **   flag_altform2               TRUE if a '!' is present.Ù7    **   flag_prefix                 '+' or ' ' or zeroÙG    **   flag_leftjustify            TRUE if a '-' is present or if theÙ>    **                               field width was negative.ÙD    **   flag_zeropad                TRUE if the width began with 0.Ù:    **   flag_long                   1 for "l", 2 for "ll"ÙH    **   width                       The specified field width.  This isÙO    **                               always non-negative.  Zero is the default.ÙJ    **   precision                   The specified precision.  The defaultÙ+    **                               is -1.ÙA    **   xtype                       The class of the conversion.ÙL    **   infop                       Pointer to the appropriate info struct.¦    */´    switch( xtype ){µ      case etPOINTER:Ù4        flag_long = sizeof(char*)==sizeof(i64) ? 2 :Ù=                     sizeof(char*)==sizeof(long int) ? 1 : 0;Ù-        /* Fall through into the next case */µ      case etORDINAL:¹      case etRADIX:      ¶        cThousand = 0;Ù-        /* Fall through into the next case */µ      case etDECIMAL:Ù)        if( infop->flags & FLAG_SIGNED ){°          i64 v;¹          if( bArgList ){Ù$            v = getIntArg(pArgList);Ù           }else if( flag_long ){¿            if( flag_long==2 ){Ù"              v = va_arg(ap,i64) ;²            }else{Ù&              v = va_arg(ap,long int);­            }°          }else{¿            v = va_arg(ap,int);«          }´          if( v<0 ){Ù$            if( v==SMALLEST_INT64 ){Ù'              longvalue = ((u64)1)<<63;²            }else{½              longvalue = -v;­            }¹            prefix = '-';°          }else{º            longvalue = v;Ù!            prefix = flag_prefix;«          }®        }else{¹          if( bArgList ){Ù1            longvalue = (u64)getIntArg(pArgList);Ù           }else if( flag_long ){¿            if( flag_long==2 ){Ù)              longvalue = va_arg(ap,u64);²            }else{Ù7              longvalue = va_arg(ap,unsigned long int);­            }°          }else{Ù0            longvalue = va_arg(ap,unsigned int);«          }µ          prefix = 0;©        }Ù2        if( longvalue==0 ) flag_alternateform = 0;Ù:        if( flag_zeropad && precision<width-(prefix!=0) ){Ù(          precision = width-(prefix!=0);©        }Ù1        if( precision<etBUFSIZE-10-etBUFSIZE/3 ){»          nOut = etBUFSIZE;µ          zOut = buf;®        }else{Ù4          u64 n = (u64)precision + 10 + precision/3;Ù-          zOut = zExtra = sqlite3Malloc( n );¸          if( zOut==0 ){Ù5            setStrAccumError(pAccum, STRACCUM_NOMEM);³            return;«          }¸          nOut = (int)n;©        }¾        bufpt = &zOut[nOut-1];¿        if( xtype==etORDINAL ){Ù0          static const char zOrd[] = "thstndrd";Ù(          int x = (int)(longvalue % 10);Ù-          if( x>=4 || (longvalue/10)%10==1 ){²            x = 0;«          }Ù#          *(--bufpt) = zOrd[x*2+1];Ù!          *(--bufpt) = zOrd[x*2];©        }©        {Ù6          const char *cset = &aDigits[infop->charset];Ù           u8 base = infop->base;ÙN          do{                                           /* Convert to ascii */Ù.            *(--bufpt) = cset[longvalue%base];Ù'            longvalue = longvalue/base;Ù           }while( longvalue>0 );©        }Ù,        length = (int)(&zOut[nOut-1]-bufpt);Ù"        while( precision>length ){ÙF          *(--bufpt) = '0';                             /* Zero pad */³          length++;©        }¸        if( cThousand ){ÙA          int nn = (length - 1)/3;  /* Number of "," to insert */Ù&          int ix = (length - 1)%3 + 1;¶          bufpt -= nn;Ù"          for(idx=0; nn>0; idx++){Ù'            bufpt[idx] = bufpt[idx+nn];±            ix--;¸            if( ix==0 ){Ù'              bufpt[++idx] = cThousand;³              nn--;µ              ix = 3;­            }«          }©        }ÙF        if( prefix ) *(--bufpt) = prefix;               /* Add sign */ÙM        if( flag_alternateform && infop->prefix ){      /* Add "0" or "0x" */º          const char *pre;±          char x;Ù(          pre = &aPrefix[infop->prefix];Ù5          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;©        }Ù,        length = (int)(&zOut[nOut-1]-bufpt);®        break;³      case etFLOAT:±      case etEXP:µ      case etGENERIC:·        if( bArgList ){Ù-          realvalue = getDoubleArg(pArgList);®        }else{Ù(          realvalue = va_arg(ap,double);©        }Ù!#ifdef SQLITE_OMIT_FLOATING_POINT³        length = 0;¥#elseÙL        if( precision<0 ) precision = 6;         /* Set default precision */¼        if( realvalue<0.0 ){Ù!          realvalue = -realvalue;·          prefix = '-';®        }else{¿          prefix = flag_prefix;©        }Ù:        if( xtype==etGENERIC && precision>0 ) precision--;Ù$        testcase( precision>0xfff );ÙK        for(idx=precision&0xfff, rounder=0.5; idx>0; idx--, rounder*=0.1){}Ù2        if( xtype==etFLOAT ) realvalue += rounder;ÙC        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */°        exp = 0;Ù.        if( sqlite3IsNaN((double)realvalue) ){¸          bufpt = "NaN";µ          length = 3;°          break;©        }¼        if( realvalue>0.0 ){Ù&          LONGDOUBLE_TYPE scale = 1.0;ÙP          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}ÙO          while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }ÙM          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }½          realvalue /= scale;Ù>          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }Ù=          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }¸          if( exp>350 ){¸            bufpt = buf;¼            buf[0] = prefix;Ù,            memcpy(buf+(prefix!=0),"Inf",4);Ù#            length = 3+(prefix!=0);²            break;«          }©        }´        bufpt = buf;ª        /*ÙG        ** If the field type is etGENERIC, then convert to either etEXPÙ&        ** or etFLOAT, as appropriate.ª        */½        if( xtype!=etFLOAT ){¿          realvalue += rounder;Ù;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }©        }¿        if( xtype==etGENERIC ){Ù)          flag_rtz = !flag_alternateform;Ù(          if( exp<-4 || exp>precision ){º            xtype = etEXP;°          }else{Ù(            precision = precision - exp;¼            xtype = etFLOAT;«          }®        }else{Ù#          flag_rtz = flag_altform2;©        }»        if( xtype==etEXP ){±          e2 = 0;®        }else{³          e2 = exp;©        }ÙC        if( MAX(e2,0)+(i64)precision+(i64)width > etBUFSIZE - 15 ){¹          bufpt = zExtra ÙH              = sqlite3Malloc( MAX(e2,0)+(i64)precision+(i64)width+15 );¹          if( bufpt==0 ){Ù5            setStrAccumError(pAccum, STRACCUM_NOMEM);³            return;«          }©        }µ        zOut = bufpt;Ù$        nsd = 16 + flag_altform2*10;ÙJ        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;Ù-        /* The sign in front of the number */µ        if( prefix ){¾          *(bufpt++) = prefix;©        }Ù/        /* Digits prior to the decimal point */³        if( e2<0 ){»          *(bufpt++) = '0';®        }else{½          for(; e2>=0; e2--){Ù6            *(bufpt++) = et_getdigit(&realvalue,&nsd);«          }©        }¿        /* The decimal point */¶        if( flag_dp ){»          *(bufpt++) = '.';©        }ÙB        /* "0" digits after the decimal point but before the firstÙ-        ** significant digit of the number */Ù+        for(e2++; e2<0; precision--, e2++){Ù           assert( precision>0 );»          *(bufpt++) = '0';©        }Ù8        /* Significant digits after the decimal point */Ù!        while( (precision--)>0 ){Ù4          *(bufpt++) = et_getdigit(&realvalue,&nsd);©        }ÙK        /* Remove trailing zeros and the "." if no digits follow the "." */Ù"        if( flag_rtz && flag_dp ){Ù1          while( bufpt[-1]=='0' ) *(--bufpt) = 0;¿          assert( bufpt>zOut );¿          if( bufpt[-1]=='.' ){Ù             if( flag_altform2 ){¿              *(bufpt++) = '0';²            }else{½              *(--bufpt) = 0;­            }«          }©        }Ù#        /* Add the "eNNN" suffix */»        if( xtype==etEXP ){Ù/          *(bufpt++) = aDigits[infop->charset];¶          if( exp<0 ){Ù)            *(bufpt++) = '-'; exp = -exp;°          }else{½            *(bufpt++) = '+';«          }¹          if( exp>=100 ){ÙH            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */·            exp %= 100;«          }ÙG          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */ÙF          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */©        }³        *bufpt = 0; ÙK        /* The converted number is in buf[] and zero terminated. Output it.ÙK        ** Note that the number is in the usual order, not reversed as withÙ"        ** integer conversions. */Ù#        length = (int)(bufpt-zOut);µ        bufpt = zOut; ÙG        /* Special case:  Add leading zeros if the flag_zeropad flag isÙ/        ** set and we are not left justified */ÙA        if( flag_zeropad && !flag_leftjustify && length < width){°          int i;Ù$          int nPad = width - length;Ù%          for(i=width; i>=nPad; i--){Ù%            bufpt[i] = bufpt[i-nPad];«          }¸          i = prefix!=0;Ù+          while( nPad-- ) bufpt[i++] = '0';¹          length = width;©        }Ù1#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */®        break;²      case etSIZE:¸        if( !bArgList ){Ù-          *(va_arg(ap,int*)) = pAccum->nChar;©        }»        length = width = 0;®        break;µ      case etPERCENT:µ        buf[0] = '%';´        bufpt = buf;³        length = 1;®        break;³      case etCHARX:·        if( bArgList ){Ù'          bufpt = getTextArg(pArgList);µ          length = 1;¶          if( bufpt ){Ù$            buf[0] = c = *(bufpt++);Ù!            if( (c&0xc0)==0xc0 ){Ù9              while( length<4 && (bufpt[0]&0xc0)==0x80 ){Ù+                buf[length++] = *(bufpt++);¯              }­            }°          }else{·            buf[0] = 0;«          }®        }else{Ù4          unsigned int ch = va_arg(ap,unsigned int);»          if( ch<0x00080 ){¿            buf[0] = ch & 0xff;·            length = 1;Ù!          }else if( ch<0x00800 ){Ù/            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);Ù,            buf[1] = 0x80 + (u8)(ch & 0x3f);·            length = 2;Ù!          }else if( ch<0x10000 ){Ù0            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);Ù1            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);Ù,            buf[2] = 0x80 + (u8)(ch & 0x3f);·            length = 3;°          }else{Ù2            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);Ù2            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);Ù1            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);Ù,            buf[3] = 0x80 + (u8)(ch & 0x3f);·            length = 4;«          }©        }º        if( precision>1 ){¿          width -= precision-1;Ù-          if( width>1 && !flag_leftjustify ){Ù4            sqlite3AppendChar(pAccum, width-1, ' ');¶            width = 0;«          }Ù#          while( precision-- > 1 ){Ù7            sqlite3StrAccumAppend(pAccum, buf, length);«          }©        }´        bufpt = buf;º        flag_altform2 = 1;Ù#        goto adjust_width_for_utf8;´      case etSTRING:·      case etDYNSTRING:·        if( bArgList ){Ù'          bufpt = getTextArg(pArgList);»          xtype = etSTRING;®        }else{Ù#          bufpt = va_arg(ap,char*);©        }·        if( bufpt==0 ){µ          bufpt = "";Ù'        }else if( xtype==etDYNSTRING ){ÙO          if( pAccum->nChar==0 && pAccum->mxAlloc && width==0 && precision<0 ){ÙA            /* Special optimization for sqlite3_mprintf("%z..."):ÙH            ** Extend an existing memory allocation rather than creating¼            ** a new one. */ÙF            assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );Ù"            pAccum->zText = bufpt;ÙD            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);Ù<            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);Ù:            pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;·            length = 0;²            break;«          }¹          zExtra = bufpt;©        }»        if( precision>=0 ){¾          if( flag_altform2 ){ÙK            /* Set length to the number of bytes needed in order to displayÙ&            ** precision characters */Ù5            unsigned char *z = (unsigned char*)bufpt;Ù-            while( precision-- > 0 && z[0] ){Ù"              SQLITE_SKIP_UTF8(z);­            }Ù6            length = (int)(z - (unsigned char*)bufpt);°          }else{ÙH            for(length=0; length<precision && bufpt[length]; length++){}«          }®        }else{Ù3          length = 0x7fffffff & (int)strlen(bufpt);©        }¼      adjust_width_for_utf8:Ù'        if( flag_altform2 && width>0 ){ÙK          /* Adjust width to account for extra bytes in UTF-8 characters */¾          int ii = length - 1;ÙB          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;©        }®        break;Ù?      case etSQLESCAPE:           /* %q: Escape ' characters */ÙI      case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */Ù?      case etSQLESCAPE3: {        /* %w: Escape " characters */¿        int i, j, k, n, isnull;¶        int needQuote;°        char ch;ÙJ        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */µ        char *escarg; ·        if( bArgList ){Ù(          escarg = getTextArg(pArgList);®        }else{Ù$          escarg = va_arg(ap,char*);©        }»        isnull = escarg==0;ÙH        if( isnull ) escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");ÙF        /* For %q, %Q, and %w, the precision is the number of byte (orÙG        ** characters if the ! flags is present) to use from the input.ÙG        ** Because of the extra quoting characters inserted, the numberÙA        ** of output characters may be larger than the precision.ª        */¶        k = precision;Ù8        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){»          if( ch==q )  n++;Ù1          if( flag_altform2 && (ch&0xc0)==0xc0 ){Ù5            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }«          }©        }Ù3        needQuote = !isnull && xtype==etSQLESCAPE2;³        n += i + 3;º        if( n>etBUFSIZE ){Ù.          bufpt = zExtra = sqlite3Malloc( n );¹          if( bufpt==0 ){Ù5            setStrAccumError(pAccum, STRACCUM_NOMEM);³            return;«          }®        }else{¶          bufpt = buf;©        }®        j = 0;Ù'        if( needQuote ) bufpt[j++] = q;®        k = i;»        for(i=0; i<k; i++){Ù&          bufpt[j++] = ch = escarg[i];Ù&          if( ch==q ) bufpt[j++] = ch;©        }Ù'        if( needQuote ) bufpt[j++] = q;µ        bufpt[j] = 0;³        length = j;Ù#        goto adjust_width_for_utf8;§      }µ      case etTOKEN: {¶        Token *pToken;ÙG        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;Ù$        pToken = va_arg(ap, Token*);¾        assert( bArgList==0 );Ù"        if( pToken && pToken->n ){ÙK          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);©        }»        length = width = 0;®        break;§      }·      case etSRCLIST: {¶        SrcList *pSrc;®        int k;Ù#        struct SrcList_item *pItem;ÙG        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;Ù$        pSrc = va_arg(ap, SrcList*);¼        k = va_arg(ap, int);¼        pItem = &pSrc->a[k];¾        assert( bArgList==0 );Ù'        assert( k>=0 && k<pSrc->nSrc );¿        if( pItem->zDatabase ){Ù=          sqlite3StrAccumAppendAll(pAccum, pItem->zDatabase);Ù0          sqlite3StrAccumAppend(pAccum, ".", 1);©        }Ù7        sqlite3StrAccumAppendAll(pAccum, pItem->zName);»        length = width = 0;®        break;§      }°      default: {Ù#        assert( xtype==etINVALID );¯        return;§      }Ù*    }/* End switch over the format type */¦    /*ÙA    ** The text of the conversion is pointed to by "bufpt" and isÙA    ** "length" characters long.  The field width is "width".  DoÙG    ** the output.  Both length and width are in bytes, not characters,ÙH    ** at this point.  If the "!" flag was present on string conversionsÙM    ** indicating that width and precision should be expressed in characters,ÙI    ** then the values have been translated prior to reaching this point.¦    */´    width -= length;²    if( width>0 ){ÙD      if( !flag_leftjustify ) sqlite3AppendChar(pAccum, width, ' ');Ù3      sqlite3StrAccumAppend(pAccum, bufpt, length);ÙC      if( flag_leftjustify ) sqlite3AppendChar(pAccum, width, ' ');ª    }else{Ù3      sqlite3StrAccumAppend(pAccum, bufpt, length);¥    } ±    if( zExtra ){Ù(      sqlite3DbFree(pAccum->db, zExtra);±      zExtra = 0;¥    }Ù,  }/* End for loop over the format string */·} /* End of function */ ¢/*ÙC** Enlarge the memory allocation on a StrAccum object so that it isÙ0** able to accept at least N more bytes of text.¢**ÙE** Return the number of bytes of text that StrAccum is able to acceptÙF** after the attempted enlargement.  The value returned might be zero.¢*/Ù6static int sqlite3StrAccumEnlarge(StrAccum *p, int N){­  char *zNew;ÙL  assert( p->nChar+(i64)N >= p->nAlloc ); /* Only called if really needed */´  if( p->accError ){Ù+    testcase(p->accError==STRACCUM_TOOBIG);Ù*    testcase(p->accError==STRACCUM_NOMEM);­    return 0;£  }¶  if( p->mxAlloc==0 ){Ù!    N = p->nAlloc - p->nChar - 1;Ù)    setStrAccumError(p, STRACCUM_TOOBIG);­    return N;¨  }else{Ù.    char *zOld = isMalloced(p) ? p->zText : 0;¹    i64 szNew = p->nChar;³    szNew += N + 1;Ù%    if( szNew+p->nChar<=p->mxAlloc ){ÙN      /* Force exponential buffer size growth as long as it does not overflow,Ù:      ** to avoid having to call this routine too often */¸      szNew += p->nChar;¥    }½    if( szNew > p->mxAlloc ){¾      sqlite3StrAccumReset(p);Ù+      setStrAccumError(p, STRACCUM_TOOBIG);¯      return 0;ª    }else{½      p->nAlloc = (int)szNew;¥    }°    if( p->db ){Ù6      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);ª    }else{Ù0      zNew = sqlite3_realloc64(zOld, p->nAlloc);¥    }¯    if( zNew ){Ù+      assert( p->zText!=0 || p->nChar==0 );ÙJ      if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);¶      p->zText = zNew;Ù3      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);Ù/      p->printfFlags |= SQLITE_PRINTF_MALLOCED;ª    }else{¾      sqlite3StrAccumReset(p);Ù*      setStrAccumError(p, STRACCUM_NOMEM);¯      return 0;¥    }£  }«  return N;¡} ¢/*Ù=** Append N copies of character c to the given string buffer.¢*/ÙBSQLITE_PRIVATE void sqlite3AppendChar(StrAccum *p, int N, char c){Ù-  testcase( p->nChar + (i64)N > 0x7fffffff );ÙN  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){«    return;£  }Ù,  while( (N--)>0 ) p->zText[p->nChar++] = c;¡} ¢/*ÙE** The StrAccum "p" is not large enough to accept N new bytes of z[].Ù+** So enlarge if first, then do the append.¢**ÙM** This is a helper routine to sqlite3StrAccumAppend() that does special-caseÙ@** work (enlarging the buffer) using tail recursion, so that theÙB** sqlite3StrAccumAppend() routine can use fast calling semantics.¢*/ÙPstatic void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){Ù#  N = sqlite3StrAccumEnlarge(p, N);¬  if( N>0 ){Ù&    memcpy(&p->zText[p->nChar], z, N);²    p->nChar += N;£  }¡} ¢/*ÙF** Append N bytes of text from z to the StrAccum object.  Increase theÙ;** size of the memory allocation for StrAccum if necessary.¢*/ÙMSQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){¹  assert( z!=0 || N==0 );Ù6  assert( p->zText!=0 || p->nChar==0 || p->accError );±  assert( N>=0 );Ù+  assert( p->accError==0 || p->nAlloc==0 );Ù   if( p->nChar+N >= p->nAlloc ){¼    enlargeAndAppend(p,z,N);°  }else if( N ){·    assert( p->zText );²    p->nChar += N;Ù(    memcpy(&p->zText[p->nChar-N], z, N);£  }¡} ¢/*ÙJ** Append the complete text of zero-terminated string z[] to the p string.¢*/ÙISQLITE_PRIVATE void sqlite3StrAccumAppendAll(StrAccum *p, const char *z){Ù2  sqlite3StrAccumAppend(p, z, sqlite3Strlen30(z));¡}  ¢/*Ù<** Finish off a string by making sure it is zero-terminated.Ù;** Return a pointer to the resulting string.  Return a NULLÙ0** pointer if any kind of error was encountered.¢*/Ù@static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){®  char *zText;Ù+  assert( p->mxAlloc>0 && !isMalloced(p) );Ù1  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );®  if( zText ){Ù(    memcpy(zText, p->zText, p->nChar+1);Ù-    p->printfFlags |= SQLITE_PRINTF_MALLOCED;¨  }else{Ù(    setStrAccumError(p, STRACCUM_NOMEM);£  }³  p->zText = zText;¯  return zText;¡}Ù8SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){±  if( p->zText ){»    p->zText[p->nChar] = 0;Ù)    if( p->mxAlloc>0 && !isMalloced(p) ){Ù&      return strAccumFinishRealloc(p);¥    }£  }²  return p->zText;¡} ¢/*Ù:** Reset an StrAccum string.  Reclaim all malloced memory.¢*/Ù6SQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum *p){¶  if( isMalloced(p) ){Ù#    sqlite3DbFree(p->db, p->zText);Ù.    p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;£  }¯  p->zText = 0;¡} ¢/*Ù#** Initialize a string accumulator.¢**Ù,** p:     The accumulator to be initialized.ÙD** db:    Pointer to a database connection.  May be NULL.  LookasideÙK**        memory is used if not NULL. db->mallocFailed is set appropriately¸**        when not NULL.ÙJ** zBase: An initial buffer.  May be NULL in which case the initial buffer¶**        is malloced.ÙK** n:     Size of zBase in bytes.  If total space requirements never exceedÙ2**        n then no memory allocations ever occur.ÙI** mx:    Maximum number of bytes to accumulate.  If mx==0 then no memoryÙ&**        allocations will ever occur.¢*/Ù^SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){³  p->zText = zBase;­  p->db = db;°  p->nAlloc = n;²  p->mxAlloc = mx;¯  p->nChar = 0;²  p->accError = 0;µ  p->printfFlags = 0;¡} ¢/*ÙD** Print into memory obtained from sqliteMalloc().  Use the internal»** %-conversion extensions.¢*/ÙSSQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){ª  char *z;Ù$  char zBase[SQLITE_PRINT_BUF_SIZE];¯  StrAccum acc;²  assert( db!=0 );Ù5  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),Ù7                      db->aLimit[SQLITE_LIMIT_LENGTH]);Ù+  acc.printfFlags = SQLITE_PRINTF_INTERNAL;Ù%  sqlite3VXPrintf(&acc, zFormat, ap);Ù"  z = sqlite3StrAccumFinish(&acc);Ù%  if( acc.accError==STRACCUM_NOMEM ){¸    sqlite3OomFault(db);£  }«  return z;¡} ¢/*ÙD** Print into memory obtained from sqliteMalloc().  Use the internal»** %-conversion extensions.¢*/ÙKSQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){­  va_list ap;ª  char *z;¸  va_start(ap, zFormat);Ù'  z = sqlite3VMPrintf(db, zFormat, ap);­  va_end(ap);«  return z;¡} ¢/*ÙG** Print into memory obtained from sqlite3_malloc().  Omit the internal»** %-conversion extensions.¢*/ÙCSQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){ª  char *z;Ù$  char zBase[SQLITE_PRINT_BUF_SIZE];¯  StrAccum acc; Ù #ifdef SQLITE_ENABLE_API_ARMOR  ³  if( zFormat==0 ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙH  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);Ù%  sqlite3VXPrintf(&acc, zFormat, ap);Ù"  z = sqlite3StrAccumFinish(&acc);«  return z;¡} ¢/*ÙI** Print into memory obtained from sqlite3_malloc()().  Omit the internal»** %-conversion extensions.¢*/Ù;SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){­  va_list ap;ª  char *z;¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endif¸  va_start(ap, zFormat);Ù$  z = sqlite3_vmprintf(zFormat, ap);­  va_end(ap);«  return z;¡} ¢/*ÙF** sqlite3_snprintf() works like snprintf() except that it ignores theÙD** current locale settings.  This is important for SQLite because weÙD** are not able to use a "," as the decimal point in place of "." as½** specified by some locales.¢**ÙE** Oops:  The first two arguments of sqlite3_snprintf() are backwardsÙI** from the snprintf() standard.  Unfortunately, it is too late to changeÙH** this without breaking compatibility, so we just have to live with the«** mistake.¢**Ù.** sqlite3_vsnprintf() is the varargs version.¢*/ÙWSQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){¯  StrAccum acc;¹  if( n<=0 ) return zBuf;¾#ifdef SQLITE_ENABLE_API_ARMOR¿  if( zBuf==0 || zFormat==0 ) {½    (void)SQLITE_MISUSE_BKPT;»    if( zBuf ) zBuf[0] = 0;°    return zBuf;£  }¦#endifÙ+  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);Ù%  sqlite3VXPrintf(&acc, zFormat, ap);¶  zBuf[acc.nChar] = 0;®  return zBuf;¡}ÙOSQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){ª  char *z;­  va_list ap;·  va_start(ap,zFormat);Ù.  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);­  va_end(ap);«  return z;¡} ¢/*ÙG** This is the routine that actually formats the sqlite3_log() message.ÙF** We house it in a separate routine from sqlite3_log() to avoid usingÙ?** stack space on small-stack systems when logging is disabled.¢**ÙI** sqlite3_log() must render into a static buffer.  It cannot dynamicallyÙH** allocate memory because it might be called while the memory allocator±** mutex is held.¢**ÙE** sqlite3VXPrintf() might ask for *temporary* memory allocations forÙI** certain format characters (%q) or for very large precisions or widths.ÙG** Care must be taken that any sqlite3_log() calls that occur while theÙ4** memory mutex is held do not use these mechanisms.¢*/ÙHstatic void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){ÙA  StrAccum acc;                          /* String accumulator */ÙC  char zMsg[SQLITE_PRINT_BUF_SIZE*3];    /* Complete log message */ Ù6  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);Ù%  sqlite3VXPrintf(&acc, zFormat, ap);ÙA  sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,Ù8                           sqlite3StrAccumFinish(&acc));¡} ¢/*Ù?** Format and write a message to the log if logging is enabled.¢*/ÙDSQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){Ù;  va_list ap;                             /* Vararg list */Ù!  if( sqlite3GlobalConfig.xLog ){º    va_start(ap, zFormat);Ù(    renderLogMsg(iErrCode, zFormat, ap);¯    va_end(ap);£  }¡} Ù:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)¢/*ÙD** A version of printf() that understands %lld.  Used for debugging.ÙL** The printf() built into some versions of windows does not understand %lldÙ0** and segfaults if you give it a long long int.¢*/ÙASQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){­  va_list ap;¯  StrAccum acc;±  char zBuf[500];Ù6  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);·  va_start(ap,zFormat);Ù%  sqlite3VXPrintf(&acc, zFormat, ap);­  va_end(ap);¾  sqlite3StrAccumFinish(&acc);»#ifdef SQLITE_OS_TRACE_PROC£  {ÙA    extern void SQLITE_OS_TRACE_PROC(const char *zBuf, int nBuf);Ù-    SQLITE_OS_TRACE_PROC(zBuf, sizeof(zBuf));£  }¥#else½  fprintf(stdout,"%s", zBuf);±  fflush(stdout);¦#endif¡}¦#endif  ¢/*ÙK** variable-argument wrapper around sqlite3VXPrintf().  The bFlags argumentÙF** can contain the bit SQLITE_PRINTF_INTERNAL enable internal formats.¢*/ÙJSQLITE_PRIVATE void sqlite3XPrintf(StrAccum *p, const char *zFormat, ...){­  va_list ap;·  va_start(ap,zFormat);Ù"  sqlite3VXPrintf(p, zFormat, ap);­  va_end(ap);¡} ÙO/************** End of printf.c **********************************************/ÙO/************** Begin file treeview.c ****************************************/¢/*­** 2015-06-08¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙJ** This file contains C code to implement the TreeView debugging routines.ÙI** These routines print a parse tree to standard output for debugging and­** analysis. ¢**Ù?** The interfaces in this file is only available when compilingµ** with SQLITE_DEBUG.¢*/¼/* #include "sqliteInt.h" */³#ifdef SQLITE_DEBUG ¢/*ÙL** Add a new subitem to the tree.  The moreToFollow flag indicates that thisÙ$** is not the last item in the tree.¢*/ÙCstatic TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow){­  if( p==0 ){Ù'    p = sqlite3_malloc64( sizeof(*p) );¸    if( p==0 ) return 0;½    memset(p, 0, sizeof(*p));¨  }else{°    p->iLevel++;£  }Ù/  assert( moreToFollow==0 || moreToFollow==1 );ÙF  if( p->iLevel<sizeof(p->bLine) ) p->bLine[p->iLevel] = moreToFollow;«  return p;¡} ¢/*Ù&** Finished with one layer of the tree¢*/Ù,static void sqlite3TreeViewPop(TreeView *p){´  if( p==0 ) return;®  p->iLevel--;Ù$  if( p->iLevel<0 ) sqlite3_free(p);¡} ¢/*ÙM** Generate a single line of output for the tree, with a prefix that containsÙ!** all the appropriate tree lines¢*/ÙGstatic void sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...){­  va_list ap;¨  int i;¯  StrAccum acc;±  char zBuf[500];Ù6  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);ª  if( p ){Ù7    for(i=0; i<p->iLevel && i<sizeof(p->bLine)-1; i++){ÙD      sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|   " : "    ", 4);¥    }ÙB    sqlite3StrAccumAppend(&acc, p->bLine[i] ? "|-- " : "'-- ", 4);£  }¸  va_start(ap, zFormat);Ù%  sqlite3VXPrintf(&acc, zFormat, ap);­  va_end(ap);¸  assert( acc.nChar>0 );ÙE  if( zBuf[acc.nChar-1]!='\n' ) sqlite3StrAccumAppend(&acc, "\n", 1);¾  sqlite3StrAccumFinish(&acc);½  fprintf(stdout,"%s", zBuf);±  fflush(stdout);¡} ¢/*ÙI** Shorthand for starting a new tree item that consists of a single label¢*/ÙPstatic void sqlite3TreeViewItem(TreeView *p, const char *zLabel,u8 moreFollows){Ù*  p = sqlite3TreeViewPush(p, moreFollows);Ù'  sqlite3TreeViewLine(p, "%s", zLabel);¡} ¢/*Ù:** Generate a human-readable description of a WITH clause.¢*/Ù]SQLITE_PRIVATE void sqlite3TreeViewWith(TreeView *pView, const With *pWith, u8 moreToFollow){¨  int i;¸  if( pWith==0 ) return;¾  if( pWith->nCte==0 ) return;¶  if( pWith->pOuter ){ÙO    sqlite3TreeViewLine(pView, "WITH (0x%p, pOuter=0x%p)",pWith,pWith->pOuter);¨  }else{Ù5    sqlite3TreeViewLine(pView, "WITH (0x%p)", pWith);£  }¶  if( pWith->nCte>0 ){Ù*    pView = sqlite3TreeViewPush(pView, 1);Ù!    for(i=0; i<pWith->nCte; i++){±      StrAccum x;·      char zLine[1000];Ù,      const struct Cte *pCte = &pWith->a[i];Ù:      sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);Ù,      sqlite3XPrintf(&x, "%s", pCte->zName);Ù0      if( pCte->pCols && pCte->pCols->nExpr>0 ){¸        char cSep = '(';®        int j;Ù,        for(j=0; j<pCte->pCols->nExpr; j++){ÙD          sqlite3XPrintf(&x, "%c%s", cSep, pCte->pCols->a[j].zName);µ          cSep = ',';©        }Ù         sqlite3XPrintf(&x, ")");§      }Ù       sqlite3XPrintf(&x, " AS");Ù       sqlite3StrAccumFinish(&x);Ù9      sqlite3TreeViewItem(pView, zLine, i<pWith->nCte-1);Ù5      sqlite3TreeViewSelect(pView, pCte->pSelect, 0);Ù       sqlite3TreeViewPop(pView);¥    }¾    sqlite3TreeViewPop(pView);£  }¡}  ¢/*Ù<** Generate a human-readable description of a Select object.¢*/Ù]SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){¬  int n = 0;®  int cnt = 0;­  if( p==0 ){Ù-    sqlite3TreeViewLine(pView, "nil-SELECT");«    return;¤  } Ù3  pView = sqlite3TreeViewPush(pView, moreToFollow);±  if( p->pWith ){Ù,    sqlite3TreeViewWith(pView, p->pWith, 1);¬    cnt = 1;Ù"    sqlite3TreeViewPush(pView, 1);£  }¥  do{·#if SELECTTRACE_ENABLED¾    sqlite3TreeViewLine(pView,Ù7      "SELECT%s%s (%s/%p) selFlags=0x%x nSelectRow=%d",Ù7      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),Ù8      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""),Ù"      p->zSelName, p, p->selFlags,¸      (int)p->nSelectRow¦    );¥#elseÙO    sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p) selFlags=0x%x nSelectRow=%d",Ù7      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),ÙH      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p, p->selFlags,¸      (int)p->nSelectRow¦    );¦#endifÙ*    if( cnt++ ) sqlite3TreeViewPop(pView);´    if( p->pPrior ){¯      n = 1000;ª    }else{¬      n = 0;Ù)      if( p->pSrc && p->pSrc->nSrc ) n++;º      if( p->pWhere ) n++;¼      if( p->pGroupBy ) n++;»      if( p->pHaving ) n++;¼      if( p->pOrderBy ) n++;º      if( p->pLimit ) n++;¥    }ÙE    sqlite3TreeViewExprList(pView, p->pEList, (n--)>0, "result-set");Ù#    if( p->pSrc && p->pSrc->nSrc ){¬      int i;Ù2      pView = sqlite3TreeViewPush(pView, (n--)>0);Ù)      sqlite3TreeViewLine(pView, "FROM");Ù%      for(i=0; i<p->pSrc->nSrc; i++){Ù4        struct SrcList_item *pItem = &p->pSrc->a[i];³        StrAccum x;¸        char zLine[100];Ù<        sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);Ù5        sqlite3XPrintf(&x, "{%d,*}", pItem->iCursor);¿        if( pItem->zDatabase ){ÙG          sqlite3XPrintf(&x, " %s.%s", pItem->zDatabase, pItem->zName);Ù!        }else if( pItem->zName ){Ù2          sqlite3XPrintf(&x, " %s", pItem->zName);©        }º        if( pItem->pTab ){Ù@          sqlite3XPrintf(&x, " tabname=%Q", pItem->pTab->zName);©        }¼        if( pItem->zAlias ){Ù8          sqlite3XPrintf(&x, " (AS %s)", pItem->zAlias);©        }Ù+        if( pItem->fg.jointype & JT_LEFT ){Ù+          sqlite3XPrintf(&x, " LEFT-JOIN");©        }Ù"        sqlite3StrAccumFinish(&x);Ù>        sqlite3TreeViewItem(pView, zLine, i<p->pSrc->nSrc-1); ½        if( pItem->pSelect ){Ù:          sqlite3TreeViewSelect(pView, pItem->pSelect, 0);©        }Ù"        if( pItem->fg.isTabFunc ){ÙN          sqlite3TreeViewExprList(pView, pItem->u1.pFuncArg, 0, "func-args:");©        }Ù"        sqlite3TreeViewPop(pView);§      }Ù       sqlite3TreeViewPop(pView);¥    }´    if( p->pWhere ){Ù3      sqlite3TreeViewItem(pView, "WHERE", (n--)>0);Ù/      sqlite3TreeViewExpr(pView, p->pWhere, 0);Ù       sqlite3TreeViewPop(pView);¥    }¶    if( p->pGroupBy ){ÙF      sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, "GROUPBY");¥    }µ    if( p->pHaving ){Ù4      sqlite3TreeViewItem(pView, "HAVING", (n--)>0);Ù0      sqlite3TreeViewExpr(pView, p->pHaving, 0);Ù       sqlite3TreeViewPop(pView);¥    }¶    if( p->pOrderBy ){ÙF      sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, "ORDERBY");¥    }´    if( p->pLimit ){Ù3      sqlite3TreeViewItem(pView, "LIMIT", (n--)>0);ÙI      sqlite3TreeViewExpr(pView, p->pLimit->pLeft, p->pLimit->pRight!=0);¾      if( p->pLimit->pRight ){Ù6        sqlite3TreeViewItem(pView, "OFFSET", (n--)>0);Ù9        sqlite3TreeViewExpr(pView, p->pLimit->pRight, 0);Ù"        sqlite3TreeViewPop(pView);§      }Ù       sqlite3TreeViewPop(pView);¥    }´    if( p->pPrior ){Ù       const char *zOp = "UNION";¶      switch( p->op ){Ù7        case TK_ALL:         zOp = "UNION ALL";  break;Ù7        case TK_INTERSECT:   zOp = "INTERSECT";  break;Ù7        case TK_EXCEPT:      zOp = "EXCEPT";     break;§      }Ù)      sqlite3TreeViewItem(pView, zOp, 1);¥    }²    p = p->pPrior;±  }while( p!=0 );¼  sqlite3TreeViewPop(pView);¡} ¢/*Ù?** Generate a human-readable explanation of an expression tree.¢*/Ù]SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){Ù1  const char *zBinOp = 0;   /* Binary operator */Ù0  const char *zUniOp = 0;   /* Unary operator */±  char zFlgs[60];Ù3  pView = sqlite3TreeViewPush(pView, moreToFollow);±  if( pExpr==0 ){Ù&    sqlite3TreeViewLine(pView, "nil");¾    sqlite3TreeViewPop(pView);«    return;£  }µ  if( pExpr->flags ){Ù.    if( ExprHasProperty(pExpr, EP_FromJoin) ){ÙB      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x iRJT=%d",Ù=                       pExpr->flags, pExpr->iRightJoinTable);ª    }else{ÙH      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x",pExpr->flags);¥    }¨  }else{±    zFlgs[0] = 0;£  }¶  switch( pExpr->op ){¹    case TK_AGG_COLUMN: {Ù0      sqlite3TreeViewLine(pView, "AGG{%d:%d}%s",Ù2            pExpr->iTable, pExpr->iColumn, zFlgs);¬      break;¥    }µ    case TK_COLUMN: {¼      if( pExpr->iTable<0 ){Ù=        /* This only happens when coding check constraints */ÙJ        sqlite3TreeViewLine(pView, "COLUMN(%d)%s", pExpr->iColumn, zFlgs);¬      }else{Ù/        sqlite3TreeViewLine(pView, "{%d:%d}%s",ÙC                             pExpr->iTable, pExpr->iColumn, zFlgs);§      }¬      break;¥    }¶    case TK_INTEGER: {Ù'      if( pExpr->flags & EP_IntValue ){Ù:        sqlite3TreeViewLine(pView, "%d", pExpr->u.iValue);¬      }else{Ù:        sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);§      }¬      break;¥    }Ù"#ifndef SQLITE_OMIT_FLOATING_POINT´    case TK_FLOAT: {Ù7      sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);¬      break;¥    }¦#endifµ    case TK_STRING: {Ù7      sqlite3TreeViewLine(pView,"%Q", pExpr->u.zToken);¬      break;¥    }³    case TK_NULL: {Ù(      sqlite3TreeViewLine(pView,"NULL");¬      break;¥    }¸    case TK_TRUEFALSE: {Ù       sqlite3TreeViewLine(pView,Ù:         sqlite3ExprTruthValue(pExpr) ? "TRUE" : "FALSE");¬      break;¥    }Ù #ifndef SQLITE_OMIT_BLOB_LITERAL³    case TK_BLOB: {Ù7      sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);¬      break;¥    }¦#endif·    case TK_VARIABLE: {Ù2      sqlite3TreeViewLine(pView,"VARIABLE(%s,%d)",Ù;                          pExpr->u.zToken, pExpr->iColumn);¬      break;¥    }·    case TK_REGISTER: {Ù?      sqlite3TreeViewLine(pView,"REGISTER(%d)", pExpr->iTable);¬      break;¥    }±    case TK_ID: {Ù>      sqlite3TreeViewLine(pView,"ID \"%w\"", pExpr->u.zToken);¬      break;¥    }¸#ifndef SQLITE_OMIT_CAST³    case TK_CAST: {Ù;      /* Expressions of the form:   CAST(pLeft AS token) */Ù<      sqlite3TreeViewLine(pView,"CAST %Q", pExpr->u.zToken);Ù2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¬      break;¥    }½#endif /* SQLITE_OMIT_CAST */Ù.    case TK_LT:      zBinOp = "LT";     break;Ù.    case TK_LE:      zBinOp = "LE";     break;Ù.    case TK_GT:      zBinOp = "GT";     break;Ù.    case TK_GE:      zBinOp = "GE";     break;Ù.    case TK_NE:      zBinOp = "NE";     break;Ù.    case TK_EQ:      zBinOp = "EQ";     break;Ù.    case TK_IS:      zBinOp = "IS";     break;Ù.    case TK_ISNOT:   zBinOp = "ISNOT";  break;Ù.    case TK_AND:     zBinOp = "AND";    break;Ù.    case TK_OR:      zBinOp = "OR";     break;Ù.    case TK_PLUS:    zBinOp = "ADD";    break;Ù.    case TK_STAR:    zBinOp = "MUL";    break;Ù.    case TK_MINUS:   zBinOp = "SUB";    break;Ù.    case TK_REM:     zBinOp = "REM";    break;Ù.    case TK_BITAND:  zBinOp = "BITAND"; break;Ù.    case TK_BITOR:   zBinOp = "BITOR";  break;Ù.    case TK_SLASH:   zBinOp = "DIV";    break;Ù.    case TK_LSHIFT:  zBinOp = "LSHIFT"; break;Ù.    case TK_RSHIFT:  zBinOp = "RSHIFT"; break;Ù.    case TK_CONCAT:  zBinOp = "CONCAT"; break;Ù.    case TK_DOT:     zBinOp = "DOT";    break; Ù.    case TK_UMINUS:  zUniOp = "UMINUS"; break;Ù.    case TK_UPLUS:   zUniOp = "UPLUS";  break;Ù.    case TK_BITNOT:  zUniOp = "BITNOT"; break;Ù.    case TK_NOT:     zUniOp = "NOT";    break;Ù.    case TK_ISNULL:  zUniOp = "ISNULL"; break;Ù/    case TK_NOTNULL: zUniOp = "NOTNULL"; break; ´    case TK_TRUTH: {¬      int x;¼      const char *azOp[] = {Ù=         "IS-FALSE", "IS-TRUE", "IS-NOT-FALSE", "IS-NOT-TRUE"¨      };Ù:      assert( pExpr->op2==TK_IS || pExpr->op2==TK_ISNOT );¾      assert( pExpr->pRight );Ù0      assert( pExpr->pRight->op==TK_TRUEFALSE );ÙJ      x = (pExpr->op2==TK_ISNOT)*2 + sqlite3ExprTruthValue(pExpr->pRight);·      zUniOp = azOp[x];¬      break;¥    } ³    case TK_SPAN: {Ù=      sqlite3TreeViewLine(pView, "SPAN %Q", pExpr->u.zToken);Ù2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¬      break;¥    } ¶    case TK_COLLATE: {Ù@      sqlite3TreeViewLine(pView, "COLLATE %Q", pExpr->u.zToken);Ù2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¬      break;¥    } ¹    case TK_AGG_FUNCTION:·    case TK_FUNCTION: {Ù=      ExprList *pFarg;       /* List of function arguments */Ù1      if( ExprHasProperty(pExpr, EP_TokenOnly) ){²        pFarg = 0;¬      }else{¿        pFarg = pExpr->x.pList;§      }Ù'      if( pExpr->op==TK_AGG_FUNCTION ){Ù7        sqlite3TreeViewLine(pView, "AGG_FUNCTION%d %Q",Ù:                             pExpr->op2, pExpr->u.zToken);¬      }else{ÙC        sqlite3TreeViewLine(pView, "FUNCTION %Q", pExpr->u.zToken);§      }²      if( pFarg ){Ù4        sqlite3TreeViewExprList(pView, pFarg, 0, 0);§      }¬      break;¥    }¼#ifndef SQLITE_OMIT_SUBQUERYµ    case TK_EXISTS: {ÙI      sqlite3TreeViewLine(pView, "EXISTS-expr flags=0x%x", pExpr->flags);Ù8      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);¬      break;¥    }µ    case TK_SELECT: {ÙI      sqlite3TreeViewLine(pView, "SELECT-expr flags=0x%x", pExpr->flags);Ù8      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);¬      break;¥    }±    case TK_IN: {Ù@      sqlite3TreeViewLine(pView, "IN flags=0x%x", pExpr->flags);Ù2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);Ù1      if( ExprHasProperty(pExpr, EP_xIsSelect) ){Ù:        sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);¬      }else{Ù=        sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);§      }¬      break;¥    }Ù!#endif /* SQLITE_OMIT_SUBQUERY */ ¦    /*»    **    x BETWEEN y AND z¦    **¼    ** This is equivalent to¦    **·    **    x>=y AND x<=z¦    **Ù#    ** X is stored in pExpr->pLeft.Ù/    ** Y is stored in pExpr->pList->a[0].pExpr.Ù/    ** Z is stored in pExpr->pList->a[1].pExpr.¦    */¶    case TK_BETWEEN: {¾      Expr *pX = pExpr->pLeft;Ù,      Expr *pY = pExpr->x.pList->a[0].pExpr;Ù,      Expr *pZ = pExpr->x.pList->a[1].pExpr;Ù,      sqlite3TreeViewLine(pView, "BETWEEN");Ù(      sqlite3TreeViewExpr(pView, pX, 1);Ù(      sqlite3TreeViewExpr(pView, pY, 1);Ù(      sqlite3TreeViewExpr(pView, pZ, 0);¬      break;¥    }¶    case TK_TRIGGER: {ÙH      /* If the opcode is TK_TRIGGER, then the expression is a referenceÙE      ** to a column in the new.* or old.* pseudo-tables available toÙG      ** trigger programs. In this case Expr.iTable is set to 1 for theÙJ      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumnÙF      ** is set to the column of the pseudo-table to read, or to -1 to¾      ** read the rowid field.¨      */Ù+      sqlite3TreeViewLine(pView, "%s(%d)", Ù9          pExpr->iTable ? "NEW" : "OLD", pExpr->iColumn);¬      break;¥    }³    case TK_CASE: {Ù)      sqlite3TreeViewLine(pView, "CASE");Ù2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);Ù;      sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);¬      break;¥    }»#ifndef SQLITE_OMIT_TRIGGER´    case TK_RAISE: {Ù       const char *zType = "unk";Ù       switch( pExpr->affinity ){Ù7        case OE_Rollback:   zType = "rollback";  break;Ù7        case OE_Abort:      zType = "abort";     break;Ù7        case OE_Fail:       zType = "fail";      break;Ù7        case OE_Ignore:     zType = "ignore";    break;§      }ÙI      sqlite3TreeViewLine(pView, "RAISE %s(%Q)", zType, pExpr->u.zToken);¬      break;¥    }¦#endif´    case TK_MATCH: {Ù3      sqlite3TreeViewLine(pView, "MATCH {%d:%d}%s",Ù@                          pExpr->iTable, pExpr->iColumn, zFlgs);Ù3      sqlite3TreeViewExpr(pView, pExpr->pRight, 0);¬      break;¥    }µ    case TK_VECTOR: {ÙC      sqlite3TreeViewBareExprList(pView, pExpr->x.pList, "VECTOR");¬      break;¥    }¼    case TK_SELECT_COLUMN: {ÙE      sqlite3TreeViewLine(pView, "SELECT-COLUMN %d", pExpr->iColumn);Ù?      sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);¬      break;¥    }º    case TK_IF_NULL_ROW: {ÙB      sqlite3TreeViewLine(pView, "IF-NULL-ROW %d", pExpr->iTable);Ù2      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);¬      break;¥    }®    default: {Ù5      sqlite3TreeViewLine(pView, "op=%d", pExpr->op);¬      break;¥    }£  }¯  if( zBinOp ){Ù6    sqlite3TreeViewLine(pView, "%s%s", zBinOp, zFlgs);Ù0    sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);Ù1    sqlite3TreeViewExpr(pView, pExpr->pRight, 0);µ  }else if( zUniOp ){Ù6    sqlite3TreeViewLine(pView, "%s%s", zUniOp, zFlgs);Ù0    sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);£  }¼  sqlite3TreeViewPop(pView);¡}  ¢/*Ù?** Generate a human-readable explanation of an expression list.¢*/Ù0SQLITE_PRIVATE void sqlite3TreeViewBareExprList(²  TreeView *pView,¸  const ExprList *pList,´  const char *zLabel¢){Ù2  if( zLabel==0 || zLabel[0]==0 ) zLabel = "LIST";±  if( pList==0 ){Ù5    sqlite3TreeViewLine(pView, "%s (empty)", zLabel);¨  }else{ª    int i;Ù-    sqlite3TreeViewLine(pView, "%s", zLabel);Ù"    for(i=0; i<pList->nExpr; i++){Ù*      int j = pList->a[i].u.x.iOrderByCol;Ù&      char *zName = pList->a[i].zName;·      if( j || zName ){Ù&        sqlite3TreeViewPush(pView, 0);§      }²      if( zName ){Ù3        sqlite3TreeViewLine(pView, "AS %s", zName);§      }®      if( j ){Ù8        sqlite3TreeViewLine(pView, "iOrderByCol=%d", j);§      }ÙF      sqlite3TreeViewExpr(pView, pList->a[i].pExpr, i<pList->nExpr-1);·      if( j || zName ){Ù"        sqlite3TreeViewPop(pView);§      }¥    }£  }¡}Ù,SQLITE_PRIVATE void sqlite3TreeViewExprList(²  TreeView *pView,¸  const ExprList *pList,²  u8 moreToFollow,´  const char *zLabel¢){Ù3  pView = sqlite3TreeViewPush(pView, moreToFollow);Ù4  sqlite3TreeViewBareExprList(pView, pList, zLabel);¼  sqlite3TreeViewPop(pView);¡} ¹#endif /* SQLITE_DEBUG */ ÙO/************** End of treeview.c ********************************************/ÙO/************** Begin file random.c ******************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù>** This file contains code to implement a pseudo-random number¿** generator (PRNG) for SQLite.¢**ÙD** Random numbers are used by some of the database backends in orderÙB** to generate random integer keys for tables or random filenames.¢*/¼/* #include "sqliteInt.h" */  Ù6/* All threads share a single random number generator.Ù8** This structure is the current state of the generator.¢*/Ù*static SQLITE_WSD struct sqlite3PrngType {Ù:  unsigned char isInit;          /* True if initialized */Ù6  unsigned char i, j;            /* State variables */Ù6  unsigned char s[256];          /* State variables */®} sqlite3Prng; ¢/*¹** Return N random bytes.¢*/Ù6SQLITE_API void sqlite3_randomness(int N, void *pBuf){²  unsigned char t;½  unsigned char *zBuf = pBuf; ÙK  /* The "wsdPrng" macro will resolve to the pseudo-random number generatorÙI  ** state vector.  If writable static data is unsupported on the target,ÙH  ** we have to locate the state vector at run-time.  In the more commonÙM  ** case where writable static data is supported, wsdPrng can refer directlyÙ6  ** to the "sqlite3Prng" state vector declared above.¤  */¶#ifdef SQLITE_OMIT_WSDÙK  struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);µ# define wsdPrng p[0]¥#else¼# define wsdPrng sqlite3Prng¦#endif µ#if SQLITE_THREADSAFE·  sqlite3_mutex *mutex;¦#endif ¼#ifndef SQLITE_OMIT_AUTOINITÙ$  if( sqlite3_initialize() ) return;¦#endif µ#if SQLITE_THREADSAFEÙ6  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);¦#endif ½  sqlite3_mutex_enter(mutex);¸  if( N<=0 || pBuf==0 ){·    wsdPrng.isInit = 0;¿    sqlite3_mutex_leave(mutex);«    return;£  } Ù>  /* Initialize the state of the random number generator once,Ù@  ** the first time this routine is called.  The seed value doesÙ=  ** not need to contain a lot of randomness since we are notÙ<  ** trying to do secure encryption or anything like that...¤  **ÙE  ** Nothing in this file or anywhere else in SQLite does any kind ofÙJ  ** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-randomÙ3  ** number generator) not as an encryption device.¤  */¸  if( !wsdPrng.isInit ){ª    int i;°    char k[256];²    wsdPrng.j = 0;²    wsdPrng.i = 0;Ù5    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);¹    for(i=0; i<256; i++){»      wsdPrng.s[i] = (u8)i;¥    }¹    for(i=0; i<256; i++){Ù'      wsdPrng.j += wsdPrng.s[i] + k[i];¿      t = wsdPrng.s[wsdPrng.j];Ù*      wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];·      wsdPrng.s[i] = t;¥    }·    wsdPrng.isInit = 1;£  } °  assert( N>0 );¥  do{°    wsdPrng.i++;½    t = wsdPrng.s[wsdPrng.i];³    wsdPrng.j += t;Ù0    wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];½    wsdPrng.s[wsdPrng.j] = t;¾    t += wsdPrng.s[wsdPrng.i];½    *(zBuf++) = wsdPrng.s[t];°  }while( --N );½  sqlite3_mutex_leave(mutex);¡} ¹#ifndef SQLITE_UNTESTABLE¢/*ÙC** For testing purposes, we sometimes want to preserve the state ofÙC** PRNG and restore the PRNG to its saved state at a later time, orÙE** to reset the PRNG to its initial state.  These routines accomplish¯** those tasks.¢**Ù?** The sqlite3_test_control() interface calls these routines to´** control the PRNG.¢*/Ù:static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;Ù/SQLITE_PRIVATE void sqlite3PrngSaveState(void){©  memcpy(Ù6    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),Ù1    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),·    sizeof(sqlite3Prng)¤  );¡}Ù2SQLITE_PRIVATE void sqlite3PrngRestoreState(void){©  memcpy(Ù1    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),Ù6    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),·    sizeof(sqlite3Prng)¤  );¡}¾#endif /* SQLITE_UNTESTABLE */ ÙO/************** End of random.c **********************************************/ÙO/************** Begin file threads.c *****************************************/¢/*¯** 2012 July 21¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙE** This file presents a simple cross-platform threading interface for¼** use internally by SQLite.¢**ÙF** A "thread" can be created using sqlite3ThreadCreate().  This threadÙ=** runs independently of its creator until it is joined usingÙ5** sqlite3ThreadJoin(), at which point it terminates.¢**ÙD** Threads do not have to be real.  It could be that the work of theÙJ** "thread" is done by the main thread at either the sqlite3ThreadCreate()ÙB** or sqlite3ThreadJoin() call.  This is, in fact, what happens inÙI** single threaded systems.  Nothing in SQLite requires multiple threads.ÙI** This interface exists so that applications that want to take advantageÙH** of multiple cores can do so, while also allowing applications to stay¾** single-threaded if desired.¢*/¼/* #include "sqliteInt.h" */±#if SQLITE_OS_WIN»/* #  include "os_win.h" */¦#endif ¿#if SQLITE_MAX_WORKER_THREADS>0 ÙN/********************************* Unix Pthreads ****************************/ÙK#if SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) && SQLITE_THREADSAFE>0 ÙP#define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */º/* #include <pthread.h> */ ¶/* A running thread */µstruct SQLiteThread {Ù0  pthread_t tid;                 /* Thread ID */ÙG  int done;                      /* Set to true when thread finishes */ÙD  void *pOut;                    /* Result returned by the thread */Ù9  void *(*xTask)(void*);         /* The thread routine */Ù=  void *pIn;                     /* Argument to the thread */¢}; ¹/* Create a new thread */Ù'SQLITE_PRIVATE int sqlite3ThreadCreate(ÙC  SQLiteThread **ppThread,  /* OUT: Write the thread object here */ÙE  void *(*xTask)(void*),    /* Routine to run in a separate thread */Ù>  void *pIn                 /* Argument passed into xTask() */¢){²  SQLiteThread *p;©  int rc; ¸  assert( ppThread!=0 );µ  assert( xTask!=0 );Ù:  /* This routine is never used in single-threaded mode */Ù.  assert( sqlite3GlobalConfig.bCoreMutex!=0 ); °  *ppThread = 0;Ù   p = sqlite3Malloc(sizeof(*p));Ù&  if( p==0 ) return SQLITE_NOMEM_BKPT;»  memset(p, 0, sizeof(*p));³  p->xTask = xTask;¯  p->pIn = pIn;ÙF  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a ÙJ  ** function that returns SQLITE_ERROR when passed the argument 200, thatÙE  ** forces worker threads to run sequentially and deterministically ½  ** for testing purposes. */½  if( sqlite3FaultSim(200) ){«    rc = 1;¬  }else{    Ù0    rc = pthread_create(&p->tid, 0, xTask, pIn);£  }«  if( rc ){°    p->done = 1;¹    p->pOut = xTask(pIn);£  }°  *ppThread = p;³  return SQLITE_OK;¡} Ù#/* Get the results of the thread */ÙDSQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){©  int rc; µ  assert( ppOut!=0 );Ù-  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;°  if( p->done ){µ    *ppOut = p->pOut;³    rc = SQLITE_OK;¨  }else{Ù@    rc = pthread_join(p->tid, ppOut) ? SQLITE_ERROR : SQLITE_OK;£  }²  sqlite3_free(p);¬  return rc;¡} Ù=#endif /* SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) */ÙN/******************************** End Unix Pthreads *************************/  ÙN/********************************* Win32 Threads ****************************/¹#if SQLITE_OS_WIN_THREADS ÙP#define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */´#include <process.h> ¶/* A running thread */µstruct SQLiteThread {Ù2  void *tid;               /* The thread handle */Ù6  unsigned id;             /* The thread identifier */Ù?  void *(*xTask)(void*);   /* The routine to run as a thread */Ù2  void *pIn;               /* Argument to xTask */Ù0  void *pResult;           /* Result of xTask */¢}; Ù//* Thread procedure Win32 compatibility shim */Ù,static unsigned __stdcall sqlite3ThreadProc(Ù=  void *pArg  /* IN: Pointer to the SQLiteThread structure */¢){Ù)  SQLiteThread *p = (SQLiteThread *)pArg; ±  assert( p!=0 );¥#if 0¤  /*Ù9  ** This assert appears to trigger spuriously on certainÙ:  ** versions of Windows, possibly due to _beginthreadex()Ù9  ** and/or CreateThread() not fully setting their threadÙ-  ** ID parameter before starting the thread.¤  */Ù(  assert( p->id==GetCurrentThreadId() );¦#endif¸  assert( p->xTask!=0 );Ù   p->pResult = p->xTask(p->pIn); ²  _endthreadex(0);½  return 0; /* NOT REACHED */¡} ¹/* Create a new thread */Ù'SQLITE_PRIVATE int sqlite3ThreadCreate(ÙC  SQLiteThread **ppThread,  /* OUT: Write the thread object here */ÙE  void *(*xTask)(void*),    /* Routine to run in a separate thread */Ù>  void *pIn                 /* Argument passed into xTask() */¢){²  SQLiteThread *p; ¸  assert( ppThread!=0 );µ  assert( xTask!=0 );°  *ppThread = 0;Ù   p = sqlite3Malloc(sizeof(*p));Ù&  if( p==0 ) return SQLITE_NOMEM_BKPT;ÙF  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a ÙJ  ** function that returns SQLITE_ERROR when passed the argument 200, thatÙE  ** forces worker threads to run sequentially and deterministically ÙD  ** (via the sqlite3FaultSim() term of the conditional) for testing±  ** purposes. */ÙB  if( sqlite3GlobalConfig.bCoreMutex==0 || sqlite3FaultSim(200) ){½    memset(p, 0, sizeof(*p));¨  }else{µ    p->xTask = xTask;±    p->pIn = pIn;ÙJ    p->tid = (void*)_beginthreadex(0, 0, sqlite3ThreadProc, p, 0, &p->id);´    if( p->tid==0 ){¿      memset(p, 0, sizeof(*p));¥    }£  }´  if( p->xTask==0 ){Ù!    p->id = GetCurrentThreadId();¼    p->pResult = xTask(pIn);£  }°  *ppThread = p;³  return SQLITE_OK;¡} ÙESQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject); /* os_win.c */ Ù#/* Get the results of the thread */ÙDSQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){«  DWORD rc;«  BOOL bRc; µ  assert( ppOut!=0 );Ù-  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;´  if( p->xTask==0 ){Ù0    /* assert( p->id==GetCurrentThreadId() ); */·    rc = WAIT_OBJECT_0;¸    assert( p->tid==0 );¨  }else{Ù6    assert( p->id!=0 && p->id!=GetCurrentThreadId() );Ù*    rc = sqlite3Win32Wait((HANDLE)p->tid);Ù%    assert( rc!=WAIT_IO_COMPLETION );Ù&    bRc = CloseHandle((HANDLE)p->tid);²    assert( bRc );£  }Ù.  if( rc==WAIT_OBJECT_0 ) *ppOut = p->pResult;²  sqlite3_free(p);Ù8  return (rc==WAIT_OBJECT_0) ? SQLITE_OK : SQLITE_ERROR;¡} Ù"#endif /* SQLITE_OS_WIN_THREADS */ÙN/******************************** End Win32 Threads *************************/  ÙN/********************************* Single-Threaded **************************/Ù"#ifndef SQLITE_THREADS_IMPLEMENTED¢/*ÙJ** This implementation does not actually create a new thread.  It does theÙK** work of the thread in the main thread, when either the thread is created·** or when it is joined¢*/ ¶/* A running thread */µstruct SQLiteThread {Ù?  void *(*xTask)(void*);   /* The routine to run as a thread */Ù2  void *pIn;               /* Argument to xTask */Ù0  void *pResult;           /* Result of xTask */¢}; ¹/* Create a new thread */Ù'SQLITE_PRIVATE int sqlite3ThreadCreate(ÙC  SQLiteThread **ppThread,  /* OUT: Write the thread object here */ÙE  void *(*xTask)(void*),    /* Routine to run in a separate thread */Ù>  void *pIn                 /* Argument passed into xTask() */¢){²  SQLiteThread *p; ¸  assert( ppThread!=0 );µ  assert( xTask!=0 );°  *ppThread = 0;Ù   p = sqlite3Malloc(sizeof(*p));Ù&  if( p==0 ) return SQLITE_NOMEM_BKPT;Ù$  if( (SQLITE_PTR_TO_INT(p)/17)&1 ){µ    p->xTask = xTask;±    p->pIn = pIn;¨  }else{±    p->xTask = 0;¼    p->pResult = xTask(pIn);£  }°  *ppThread = p;³  return SQLITE_OK;¡} Ù#/* Get the results of the thread */ÙDSQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){ µ  assert( ppOut!=0 );Ù-  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;±  if( p->xTask ){¾    *ppOut = p->xTask(p->pIn);¨  }else{¸    *ppOut = p->pResult;£  }²  sqlite3_free(p); ¸#if defined(SQLITE_TEST)£  {Ù(    void *pTstAlloc = sqlite3Malloc(10);Ù-    if (!pTstAlloc) return SQLITE_NOMEM_BKPT;¼    sqlite3_free(pTstAlloc);£  }¦#endif ³  return SQLITE_OK;¡} Ù1#endif /* !defined(SQLITE_THREADS_IMPLEMENTED) */ÙN/****************************** End Single-Threaded *************************/Ù(#endif /* SQLITE_MAX_WORKER_THREADS>0 */ ÙO/************** End of threads.c *********************************************/ÙO/************** Begin file utf.c *********************************************/¢/*°** 2004 April 13¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù@** This file contains routines used to translate between UTF-8, Ù"** UTF-16, UTF-16BE, and UTF-16LE.¢**²** Notes on UTF-8:¢**Ù2**   Byte-0    Byte-1    Byte-2    Byte-3    ValueÙG**  0xxxxxxx                                 00000000 00000000 0xxxxxxxÙG**  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxxÙG**  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxxÙG**  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx¢**¢**Ù)** Notes on UTF-16:  (with wwww+1==uuuuu)¢**Ù2**      Word-0               Word-1          ValueÙG**  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxxÙG**  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx¢**¢**º** BOM or Byte Order Mark:Ù/**     0xff 0xfe   little-endian utf-16 followsÙ,**     0xfe 0xff   big-endian utf-16 follows¢**¢*/¼/* #include "sqliteInt.h" */¹/* #include <assert.h> */º/* #include "vdbeInt.h" */ Ù8#if !defined(SQLITE_AMALGAMATION) && SQLITE_BYTEORDER==0¢/*ÙC** The following constant value is used by the SQLITE_BIGENDIAN and¾** SQLITE_LITTLEENDIAN macros.¢*/Ù(SQLITE_PRIVATE const int sqlite3one = 1;Ù7#endif /* SQLITE_AMALGAMATION && SQLITE_BYTEORDER==0 */ ¢/*Ù=** This lookup table is used to help decode the first byte of¿** a multi-byte UTF8 character.¢*/Ù2static const unsigned char sqlite3Utf8Trans1[] = {Ù1  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,Ù1  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,Ù1  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,Ù1  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,Ù1  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,Ù1  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,Ù1  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,Ù1  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,¢};  Ù8#define WRITE_UTF8(zOut, c) {                          \Ù8  if( c<0x00080 ){                                     \Ù8    *zOut++ = (u8)(c&0xFF);                            \Ù8  }                                                    \Ù8  else if( c<0x00800 ){                                \Ù8    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \Ù8    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \Ù8  }                                                    \Ù8  else if( c<0x10000 ){                                \Ù8    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \Ù8    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \Ù8    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \Ù8  }else{                                               \Ù8    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \Ù8    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \Ù8    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \Ù8    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \Ù8  }                                                    \¡} ÙE#define WRITE_UTF16LE(zOut, c) {                                    \ÙE  if( c<=0xFFFF ){                                                  \ÙE    *zOut++ = (u8)(c&0x00FF);                                       \ÙE    *zOut++ = (u8)((c>>8)&0x00FF);                                  \ÙE  }else{                                                            \ÙE    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \ÙE    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \ÙE    *zOut++ = (u8)(c&0x00FF);                                       \ÙE    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \ÙE  }                                                                 \¡} ÙE#define WRITE_UTF16BE(zOut, c) {                                    \ÙE  if( c<=0xFFFF ){                                                  \ÙE    *zOut++ = (u8)((c>>8)&0x00FF);                                  \ÙE    *zOut++ = (u8)(c&0x00FF);                                       \ÙE  }else{                                                            \ÙE    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \ÙE    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \ÙE    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \ÙE    *zOut++ = (u8)(c&0x00FF);                                       \ÙE  }                                                                 \¡} ÙG#define READ_UTF16LE(zIn, TERM, c){                                   \ÙG  c = (*zIn++);                                                       \ÙG  c += ((*zIn++)<<8);                                                 \ÙG  if( c>=0xD800 && c<0xE000 && TERM ){                                \ÙG    int c2 = (*zIn++);                                                \ÙG    c2 += ((*zIn++)<<8);                                              \ÙG    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \ÙG  }                                                                   \¡} ÙG#define READ_UTF16BE(zIn, TERM, c){                                   \ÙG  c = ((*zIn++)<<8);                                                  \ÙG  c += (*zIn++);                                                      \ÙG  if( c>=0xD800 && c<0xE000 && TERM ){                                \ÙG    int c2 = ((*zIn++)<<8);                                           \ÙG    c2 += (*zIn++);                                                   \ÙG    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \ÙG  }                                                                   \¡} ¢/*ÙA** Translate a single UTF-8 character.  Return the unicode value.¢**Ù=** During translation, assume that the byte that zTerm points­** is a 0x00.¢**Ù=** Write a pointer to the next unread byte back into *pzNext.¢**º** Notes On Invalid UTF-8:¢**ÙI**  *  This routine never allows a 7-bit character (0x00 through 0x7f) toÙK**     be encoded as a multi-byte character.  Any multi-byte character thatÙN**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.¢**ÙG**  *  This routine never allows a UTF16 surrogate value to be encoded.ÙC**     If a multi-byte character attempts to encode a value betweenÙ7**     0xd800 and 0xe000 then it is rendered as 0xfffd.¢**ÙG**  *  Bytes in the range of 0x80 through 0xbf which occur as the firstÙD**     byte of a character are interpreted as single-byte charactersÙB**     and rendered as themselves even though they are technicallyº**     invalid characters.¢**Ù6**  *  This routine accepts over-length UTF8 encodingsÙK**     for unicode values 0x80 and greater.  It does not change over-lengthÙ5**     encodings to 0xfffd as some systems recommend.¢*/Ù<#define READ_UTF8(zIn, zTerm, c)                           \Ù<  c = *(zIn++);                                            \Ù<  if( c>=0xc0 ){                                           \Ù<    c = sqlite3Utf8Trans1[c-0xc0];                         \Ù<    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \Ù<      c = (c<<6) + (0x3f & *(zIn++));                      \Ù<    }                                                      \Ù<    if( c<0x80                                             \Ù<        || (c&0xFFFFF800)==0xD800                          \Ù<        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \£  }Ù#SQLITE_PRIVATE u32 sqlite3Utf8Read(ÙM  const unsigned char **pz    /* Pointer to string from which to read char */¢){±  unsigned int c; Ù?  /* Same as READ_UTF8() above but without the zTerm parameter.ÙK  ** For this routine, we assume the UTF8 string is always zero-terminated.¤  */±  c = *((*pz)++);°  if( c>=0xc0 ){Ù"    c = sqlite3Utf8Trans1[c-0xc0];Ù#    while( (*(*pz) & 0xc0)==0x80 ){Ù'      c = (c<<6) + (0x3f & *((*pz)++));¥    }®    if( c<0x80Ù!        || (c&0xFFFFF800)==0xD800Ù3        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }£  }«  return c;¡}    ¢/*ÙD** If the TRANSLATE_TRACE macro is defined, the value of each Mem isÙJ** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().£*/ ¿/* #define TRANSLATE_TRACE 1 */ ¹#ifndef SQLITE_OMIT_UTF16¢/*ÙE** This routine transforms the internal text encoding used by pMem toÙE** desiredEnc. It is an error if the string is already of the desiredÙ9** encoding, or if *pMem does not contain a string value.¢*/ÙUSQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){ÙL  int len;                    /* Maximum length of output string in bytes */Ù;  unsigned char *zOut;                  /* Output buffer */Ù<  unsigned char *zIn;                   /* Input iterator */Ù:  unsigned char *zTerm;                 /* End of input */Ù=  unsigned char *z;                     /* Output iterator */±  unsigned int c; Ù?  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );Ù   assert( pMem->flags&MEM_Str );Ù"  assert( pMem->enc!=desiredEnc );¹  assert( pMem->enc!=0 );·  assert( pMem->n>=0 ); Ù5#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)£  {³    char zBuf[100];Ù*    sqlite3VdbeMemPrettyPrint(pMem, zBuf);Ù*    fprintf(stderr, "INPUT:  %s\n", zBuf);£  }¦#endif ÙF  /* If the translation is between UTF-16 little and big endian, then ÙI  ** all that is required is to swap the byte order. This case is handledÙ!  ** differently from the others.¤  */Ù:  if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){¬    u8 temp;«    int rc;Ù+    rc = sqlite3VdbeMemMakeWriteable(pMem);¸    if( rc!=SQLITE_OK ){Ù!      assert( rc==SQLITE_NOMEM );¿      return SQLITE_NOMEM_BKPT;¥    }·    zIn = (u8*)pMem->z;½    zTerm = &zIn[pMem->n&~1];·    while( zIn<zTerm ){²      temp = *zIn;¶      *zIn = *(zIn+1);¬      zIn++;´      *zIn++ = temp;¥    }»    pMem->enc = desiredEnc;·    goto translate_out;£  } ÙM  /* Set len to the maximum number of bytes required in the output buffer. */Ù   if( desiredEnc==SQLITE_UTF8 ){ÙC    /* When converting from UTF-16, the maximum growth results fromÙB    ** translating a 2-byte character to a 4-byte UTF-8 character.Ù6    ** A single byte is required for the output string¶    ** nul-terminator.¦    */²    pMem->n &= ~1;º    len = pMem->n * 2 + 1;¨  }else{ÙH    /* When converting from UTF-8 to UTF-16 the maximum growth is causedÙG    ** when a 1-byte UTF-8 character is translated into a 2-byte UTF-16ÙE    ** character. Two bytes are required in the output buffer for the¶    ** nul-terminator.¦    */º    len = pMem->n * 2 + 2;£  } ÙK  /* Set zIn to point at the start of the input buffer and zTerm to point 1·  ** byte past the end.¤  **ÙG  ** Variable zOut is set to point at the output buffer, space obtained»  ** from sqlite3_malloc().¤  */µ  zIn = (u8*)pMem->z;¸  zTerm = &zIn[pMem->n];Ù+  zOut = sqlite3DbMallocRaw(pMem->db, len);®  if( !zOut ){½    return SQLITE_NOMEM_BKPT;£  }«  z = zOut; ¿  if( pMem->enc==SQLITE_UTF8 ){Ù%    if( desiredEnc==SQLITE_UTF16LE ){Ù)      /* UTF-8 -> UTF-16 Little-endian */¹      while( zIn<zTerm ){Ù!        READ_UTF8(zIn, zTerm, c);¼        WRITE_UTF16LE(z, c);§      }ª    }else{Ù+      assert( desiredEnc==SQLITE_UTF16BE );Ù&      /* UTF-8 -> UTF-16 Big-endian */¹      while( zIn<zTerm ){Ù!        READ_UTF8(zIn, zTerm, c);¼        WRITE_UTF16BE(z, c);§      }¥    }¾    pMem->n = (int)(z - zOut);­    *z++ = 0;¨  }else{Ù&    assert( desiredEnc==SQLITE_UTF8 );Ù$    if( pMem->enc==SQLITE_UTF16LE ){Ù)      /* UTF-16 Little-endian -> UTF-8 */¹      while( zIn<zTerm ){Ù)        READ_UTF16LE(zIn, zIn<zTerm, c); ¹        WRITE_UTF8(z, c);§      }ª    }else{Ù&      /* UTF-16 Big-endian -> UTF-8 */¹      while( zIn<zTerm ){Ù)        READ_UTF16BE(zIn, zIn<zTerm, c); ¹        WRITE_UTF8(z, c);§      }¥    }¾    pMem->n = (int)(z - zOut);£  }©  *z = 0;Ù9  assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len ); ²  c = pMem->flags;¾  sqlite3VdbeMemRelease(pMem);Ù?  pMem->flags = MEM_Str|MEM_Term|(c&(MEM_AffMask|MEM_Subtype));¹  pMem->enc = desiredEnc;¸  pMem->z = (char*)zOut;º  pMem->zMalloc = pMem->z;Ù:  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z); ®translate_out:Ù5#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)£  {³    char zBuf[100];Ù*    sqlite3VdbeMemPrettyPrint(pMem, zBuf);Ù*    fprintf(stderr, "OUTPUT: %s\n", zBuf);£  }¦#endif³  return SQLITE_OK;¡}¾#endif /* SQLITE_OMIT_UTF16 */ ¹#ifndef SQLITE_OMIT_UTF16¢/*ÙE** This routine checks for a byte-order mark at the beginning of the ÙF** UTF-16 string stored in *pMem. If one is present, it is removed andÙA** the encoding of the Mem adjusted. This routine does not do anyÙ5** byte-swapping, it just sets Mem.enc appropriately.¢**ÙG** The allocation (static, dynamic etc.) and encoding of the Mem may be¼** changed by this function.¢*/Ù6SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem){µ  int rc = SQLITE_OK;­  u8 bom = 0; ·  assert( pMem->n>=0 );²  if( pMem->n>1 ){»    u8 b1 = *(u8 *)pMem->z;Ù#    u8 b2 = *(((u8 *)pMem->z) + 1);¿    if( b1==0xFE && b2==0xFF ){»      bom = SQLITE_UTF16BE;¥    }¿    if( b1==0xFF && b2==0xFE ){»      bom = SQLITE_UTF16LE;¥    }£  }¢  ¬  if( bom ){Ù+    rc = sqlite3VdbeMemMakeWriteable(pMem);¸    if( rc==SQLITE_OK ){³      pMem->n -= 2;Ù-      memmove(pMem->z, &pMem->z[2], pMem->n);¾      pMem->z[pMem->n] = '\0';Ù       pMem->z[pMem->n+1] = '\0';¾      pMem->flags |= MEM_Term;¶      pMem->enc = bom;¥    }£  }¬  return rc;¡}¾#endif /* SQLITE_OMIT_UTF16 */ ¢/*ÙD** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,ÙJ** return the number of unicode characters in pZ up to (but not including)ÙB** the first 0x00 byte. If nByte is not less than zero, return theÙC** number of unicode characters in the first nByte of pZ (or up to Ù*** the first 0x00, whichever comes first).¢*/ÙBSQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){¬  int r = 0;¿  const u8 *z = (const u8*)zIn;²  const u8 *zTerm;±  if( nByte>=0 ){¶    zTerm = &z[nByte];¨  }else{¼    zTerm = (const u8*)(-1);£  }µ  assert( z<=zTerm );¼  while( *z!=0 && z<zTerm ){¸    SQLITE_SKIP_UTF8(z);¨    r++;£  }«  return r;¡} ÙI/* This test function is not currently used by the automated test-suite. Ù.** Hence it is only available in debug builds.¢*/Ù1#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)¢/*¼** Translate UTF-8 to UTF-8.¢**ÙD** This has the effect of making sure that the string is well-formedÙ+** UTF-8.  Miscoded characters are removed.¢**Ù=** The translation is done in-place and aborted if the output¶** overruns the input.¢*/Ù6SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn){¼  unsigned char *zOut = zIn;¾  unsigned char *zStart = zIn;¨  u32 c; ¿  while( zIn[0] && zOut<=zIn ){Ù*    c = sqlite3Utf8Read((const u8**)&zIn);´    if( c!=0xfffd ){º      WRITE_UTF8(zOut, c);¥    }£  }¬  *zOut = 0;¾  return (int)(zOut - zStart);¡}¦#endif ¹#ifndef SQLITE_OMIT_UTF16¢/*ÙF** Convert a UTF-16 string in the native encoding into a UTF-8 string.ÙK** Memory to hold the UTF-8 string is obtained from sqlite3_malloc and mustÙ$** be freed by the calling function.¢**Ù4** NULL is returned if there is an allocation error.¢*/ÙTSQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){¨  Mem m;»  memset(&m, 0, sizeof(m));¬  m.db = db;Ù9  sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);Ù-  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);¹  if( db->mallocFailed ){¾    sqlite3VdbeMemRelease(&m);¬    m.z = 0;£  }Ù8  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );Ù7  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );Ù$  assert( m.z || db->mallocFailed );­  return m.z;¡} ¢/*ÙI** zIn is a UTF-16 encoded unicode string at least nChar characters long.ÙC** Return the number of bytes in the first nChar unicode charactersÙ&** in pZ.  nChar must be non-negative.¢*/ÙCSQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){¨  int c;¿  unsigned char const *z = zIn;¬  int n = 0;¢  Ù+  if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){µ    while( n<nChar ){¼      READ_UTF16BE(z, 1, c);ª      n++;¥    }¨  }else{µ    while( n<nChar ){¼      READ_UTF16LE(z, 1, c);ª      n++;¥    }£  }Ù-  return (int)(z-(unsigned char const *)zIn);¡} ¸#if defined(SQLITE_TEST)¢/*ÙJ** This routine is called from the TCL test function "translate_selftest".ÙB** It checks that the primitives for serializing and deserializingÙ:** characters in each encoding are inverses of each other.¢*/Ù-SQLITE_PRIVATE void sqlite3UtfSelfTest(void){´  unsigned int i, t;¹  unsigned char zBuf[20];³  unsigned char *z;¨  int n;±  unsigned int c; ¾  for(i=0; i<0x00110000; i++){­    z = zBuf;µ    WRITE_UTF8(z, i);¶    n = (int)(z-zBuf);º    assert( n>0 && n<=4 );­    z[0] = 0;­    z = zBuf;Ù(    c = sqlite3Utf8Read((const u8**)&z);ª    t = i;Ù,    if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;Ù,    if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;³    assert( c==t );º    assert( (z-zBuf)==n );£  }¾  for(i=0; i<0x00110000; i++){Ù)    if( i>=0xD800 && i<0xE000 ) continue;­    z = zBuf;¸    WRITE_UTF16LE(z, i);¶    n = (int)(z-zBuf);º    assert( n>0 && n<=4 );­    z[0] = 0;­    z = zBuf;º    READ_UTF16LE(z, 1, c);³    assert( c==i );º    assert( (z-zBuf)==n );£  }¾  for(i=0; i<0x00110000; i++){Ù)    if( i>=0xD800 && i<0xE000 ) continue;­    z = zBuf;¸    WRITE_UTF16BE(z, i);¶    n = (int)(z-zBuf);º    assert( n>0 && n<=4 );­    z[0] = 0;­    z = zBuf;º    READ_UTF16BE(z, 1, c);³    assert( c==i );º    assert( (z-zBuf)==n );£  }¡}¸#endif /* SQLITE_TEST */¾#endif /* SQLITE_OMIT_UTF16 */ ÙO/************** End of utf.c *************************************************/ÙO/************** Begin file util.c ********************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù,** Utility functions used throughout sqlite.¢**Ù@** This file contains functions for allocating memory, comparingÙ ** strings, and stuff like that.¢**¢*/¼/* #include "sqliteInt.h" */¹/* #include <stdarg.h> */Ù##if HAVE_ISNAN || SQLITE_HAVE_ISNAN²# include <math.h>¦#endif ¢/*Ù2** Routine needed to support the testcase() macro.¢*/»#ifdef SQLITE_COVERAGE_TESTÙ+SQLITE_PRIVATE void sqlite3Coverage(int x){¼  static unsigned dummy = 0;·  dummy += (unsigned)x;¡}¦#endif ¢/*ÙJ** Give a callback to the test harness that can be used to simulate faultsÙH** in places where it is difficult or expensive to do so purely by means­** of inputs.¢**ÙH** The intent of the integer argument is to let the fault simulator knowÙ:** which of multiple sqlite3FaultSim() calls has been hit.¢**ÙE** Return whatever integer value the test callback returns, or returnÙ.** SQLITE_OK if no test callback is installed.¢*/¹#ifndef SQLITE_UNTESTABLEÙ.SQLITE_PRIVATE int sqlite3FaultSim(int iTest){Ù<  int (*xCallback)(int) = sqlite3GlobalConfig.xTestCallback;Ù2  return xCallback ? xCallback(iTest) : SQLITE_OK;¡}¦#endif Ù"#ifndef SQLITE_OMIT_FLOATING_POINT¢/*ÙA** Return true if the floating point value is Not a Number (NaN).¢**ÙL** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.ÙH** Otherwise, we have our own implementation that works on most systems.¢*/Ù*SQLITE_PRIVATE int sqlite3IsNaN(double x){Ù"  int rc;   /* The value return */Ù%#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN¤  /*ÙF  ** Systems that support the isnan() library function should probablyÙG  ** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we haveÙF  ** found that many systems do not have a working isnan() function soÙ7  ** this implementation is provided as an alternative.¤  **ÙG  ** This NaN test sometimes fails if compiled on GCC with -ffast-math.ÙG  ** On the other hand, the use of -ffast-math comes with the following­  ** warning:¤  **ÙD  **      This option [-ffast-math] should never be turned on by anyÙH  **      -O option since it can result in incorrect output for programsÙA  **      which depend on an exact implementation of IEEE or ISO Ù2  **      rules/specifications for math functions.¤  **ÙD  ** Under MSVC, this NaN test may fail if compiled with a floating-ÙA  ** point precision mode other than /fp:precise.  From the MSDN ³  ** documentation:¤  **ÙK  **      The compiler [with /fp:precise] will properly handle comparisons ÙK  **      involving NaN. For example, x != x evaluates to true if x is NaN ­  **      ...¤  */´#ifdef __FAST_MATH__ÙJ# error SQLite will not work correctly with the -ffast-math option of GCC.¦#endif¸  volatile double y = x;¸  volatile double z = y;®  rc = (y!=z);º#else  /* if HAVE_ISNAN */°  rc = isnan(x);·#endif /* HAVE_ISNAN */±  testcase( rc );¬  return rc;¡}Ù'#endif /* SQLITE_OMIT_FLOATING_POINT */ ¢/*ÙC** Compute a string length that is limited to what can be stored inÙ,** lower 30 bits of a 32-bit signed integer.¢**ÙJ** The value returned will never be negative.  Nor will it ever be greaterÙH** than the actual length of the string.  For very long strings (greaterÙK** than 1GiB) the value returned might be less than the true string length.¢*/Ù2SQLITE_PRIVATE int sqlite3Strlen30(const char *z){¶  if( z==0 ) return 0;Ù%  return 0x3fffffff & (int)strlen(z);¡} ¢/*ÙH** Return the declared type of a column.  Or return zDflt if the column ¸** has no declared type.¢**ÙI** The column type is an extra string stored after the zero-terminator onÙB** the column name if and only if the COLFLAG_HASTYPE flag is set.¢*/ÙBSQLITE_PRIVATE char *sqlite3ColumnType(Column *pCol, char *zDflt){Ù;  if( (pCol->colFlags & COLFLAG_HASTYPE)==0 ) return zDflt;Ù/  return pCol->zName + strlen(pCol->zName) + 1;¡} ¢/*ÙG** Helper function for sqlite3Error() - called rarely.  Broken out intoÙE** a separate routine to avoid unnecessary register saves on entry to²** sqlite3Error().¢*/ÙKstatic SQLITE_NOINLINE void  sqlite3ErrorFinish(sqlite3 *db, int err_code){Ù/  if( db->pErr ) sqlite3ValueSetNull(db->pErr);Ù#  sqlite3SystemError(db, err_code);¡} ¢/*ÙL** Set the current error code to err_code and clear any prior error message.ÙJ** Also set iSysErrno (by calling sqlite3System) if the err_code indicates½** that would be appropriate.¢*/Ù<SQLITE_PRIVATE void sqlite3Error(sqlite3 *db, int err_code){²  assert( db!=0 );¹  db->errCode = err_code;Ù>  if( err_code || db->pErr ) sqlite3ErrorFinish(db, err_code);¡} ¢/*ÙC** Load the sqlite3.iSysErrno field if that is an appropriate thingÙ.** to do based on the SQLite error code in rc.¢*/Ù<SQLITE_PRIVATE void sqlite3SystemError(sqlite3 *db, int rc){Ù&  if( rc==SQLITE_IOERR_NOMEM ) return;­  rc &= 0xff;Ù0  if( rc==SQLITE_CANTOPEN || rc==SQLITE_IOERR ){Ù4    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);£  }¡} ¢/*ÙA** Set the most recent error code and error string for the sqliteÙ4** handle "db". The error code is set to "err_code".¢**Ù@** If it is not NULL, string zFormat specifies the format of theÙC** error string in the style of the printf functions: The followingÙ!** format characters are allowed:¢**¿**      %s      Insert a stringÙ7**      %z      A string that should be freed after useÙ!**      %d      Insert an integer¾**      %T      Insert a tokenÙ5**      %S      Insert the first element of a SrcList¢**ÙA** zFormat and any string tokens that follow it are assumed to be´** encoded in UTF-8.¢**ÙF** To clear the most recent error for sqlite handle "db", sqlite3ErrorÙB** should be called with err_code set to SQLITE_OK and zFormat set«** to NULL.¢*/Ù]SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){²  assert( db!=0 );¹  db->errCode = err_code;Ù#  sqlite3SystemError(db, err_code);³  if( zFormat==0 ){¿    sqlite3Error(db, err_code);Ù>  }else if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){¬    char *z;¯    va_list ap;º    va_start(ap, zFormat);Ù)    z = sqlite3VMPrintf(db, zFormat, ap);¯    va_end(ap);ÙE    sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC);£  }¡} ¢/*ÙF** Add an error message to pParse->zErrMsg and increment pParse->nErr.Ù3** The following formatting characters are allowed:¢**¿**      %s      Insert a stringÙ7**      %z      A string that should be freed after useÙ!**      %d      Insert an integer¾**      %T      Insert a tokenÙ5**      %S      Insert the first element of a SrcList¢**ÙE** This function should be used to report any error that occurs whileÙB** compiling an SQL statement (i.e. within sqlite3_prepare()). TheÙC** last thing the sqlite3_prepare() function does is copy the errorÙI** stored by this function into the database handle using sqlite3Error().ÙC** Functions sqlite3Error() or sqlite3ErrorWithMsg() should be usedÙ4** during statement execution (sqlite3_step() etc.).¢*/ÙMSQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){­  char *zMsg;­  va_list ap;»  sqlite3 *db = pParse->db;¸  va_start(ap, zFormat);Ù*  zMsg = sqlite3VMPrintf(db, zFormat, ap);­  va_end(ap);¸  if( db->suppressErr ){¼    sqlite3DbFree(db, zMsg);¨  }else{³    pParse->nErr++;Ù'    sqlite3DbFree(db, pParse->zErrMsg);»    pParse->zErrMsg = zMsg;¾    pParse->rc = SQLITE_ERROR;£  }¡} ¢/*ÙF** Convert an SQL-style quoted string into a normal string by removingÙB** the quote characters.  The conversion is done in-place.  If theÙA** input does not begin with a quote character, then this routine®** is a no-op.¢**ÙC** The input string must be zero-terminated.  A new zero-terminatorÙ#** is added to the dequoted string.¢**ÙE** The return value is -1 if no dequoting occurs or the length of theÙG** dequoted string, exclusive of the zero terminator, if dequoting does©** occur.¢**ÙB** 2002-Feb-14: This routine is extended to remove MS-Access styleÙE** brackets from around identifiers.  For example:  "[a-b-c]" becomes«** "a-b-c".¢*/Ù,SQLITE_PRIVATE void sqlite3Dequote(char *z){­  char quote;«  int i, j;´  if( z==0 ) return;¯  quote = z[0];Ù&  if( !sqlite3Isquote(quote) ) return;¿  if( quote=='[' ) quote = ']';¶  for(i=1, j=0;; i++){³    assert( z[i] );¶    if( z[i]==quote ){º      if( z[i+1]==quote ){·        z[j++] = quote;¬        i++;¬      }else{®        break;§      }ª    }else{´      z[j++] = z[i];¥    }£  }«  z[j] = 0;¡} ¢/*Ù(** Generate a Token object from a string¢*/Ù8SQLITE_PRIVATE void sqlite3TokenInit(Token *p, char *z){«  p->z = z;¼  p->n = sqlite3Strlen30(z);¡} »/* Convenient short-hand */Ù(#define UpperToLower sqlite3UpperToLower ¢/*ÙC** Some systems have stricmp().  Others have strcasecmp().  BecauseÙ3** there is no consistency, we will define our own.¢**Ù=** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() andÙG** sqlite3_strnicmp() APIs allow applications and extensions to compareÙ<** the contents of two buffers containing UTF-8 strings in aÙ?** case-independent fashion, using the same definition of "caseÙH** independence" that SQLite uses internally when comparing identifiers.¢*/ÙFSQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){±  if( zLeft==0 ){»    return zRight ? -1 : 0;¸  }else if( zRight==0 ){­    return 1;£  }Ù'  return sqlite3StrICmp(zLeft, zRight);¡}ÙISQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){·  unsigned char *a, *b;¨  int c;½  a = (unsigned char *)zLeft;¾  b = (unsigned char *)zRight;ª  for(;;){Ù6    c = (int)UpperToLower[*a] - (int)UpperToLower[*b];»    if( c || *a==0 ) break;¨    a++;¨    b++;£  }«  return c;¡}ÙNSQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){Ù   register unsigned char *a, *b;±  if( zLeft==0 ){»    return zRight ? -1 : 0;¸  }else if( zRight==0 ){­    return 1;£  }½  a = (unsigned char *)zLeft;¾  b = (unsigned char *)zRight;ÙM  while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }Ù7  return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];¡} ¢/*Ù@** Compute 10 to the E-th power.  Examples:  E==1 results in 10.Ù1** E==2 results in 100.  E==50 results in 1.0e50.¢**Ù=** This routine only works for values of E between 1 and 341.¢*/Ù+static LONGDOUBLE_TYPE sqlite3Pow10(int E){µ#if defined(_MSC_VER)Ù&  static const LONGDOUBLE_TYPE x[] = {­    1.0e+001,­    1.0e+002,­    1.0e+004,­    1.0e+008,­    1.0e+016,­    1.0e+032,­    1.0e+064,­    1.0e+128,¬    1.0e+256¤  };º  LONGDOUBLE_TYPE r = 1.0;¨  int i;»  assert( E>=0 && E<=307 );¾  for(i=0; E!=0; i++, E >>=1){º    if( E & 1 ) r *= x[i];£  }«  return r;¥#else»  LONGDOUBLE_TYPE x = 10.0;º  LONGDOUBLE_TYPE r = 1.0;«  while(1){·    if( E & 1 ) r *= x;¬    E >>= 1;µ    if( E==0 ) break;«    x *= x;£  }¬  return r; ¦#endif¡} ¢/*Ù=** The string z[] is an text representation of a real number.Ù>** Convert this string to a double and write it into *pResult.¢**ÙG** The string z[] is length bytes in length (bytes, not characters) andÙI** uses the encoding enc.  The string is not necessarily zero-terminated.¢**ÙJ** Return TRUE if the result is a valid real number (or integer) and FALSEÙE** if the string is empty or contains extraneous text.  Valid numbers¿** are in one of these formats:¢**½**    [+-]digits[E[+-]digits]Ù&**    [+-]digits.[digits][E[+-]digits]¾**    [+-].digits[E[+-]digits]¢**ÙL** Leading and trailing whitespace is ignored for the purpose of determining¬** validity.¢**ÙE** If some prefix of the input string is a valid number, this routineÙG** returns FALSE but it still converts the prefix and writes the result±** into *pResult.¢*/ÙSSQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){Ù"#ifndef SQLITE_OMIT_FLOATING_POINT«  int incr;Ù   const char *zEnd = z + length;Ù6  /* sign * significand * (10 ^ (esign * exponent)) */Ù,  int sign = 1;    /* sign of significand */Ù$  i64 s = 0;       /* significand */ÙC  int d = 0;       /* adjust exponent for shifting decimal point */Ù)  int esign = 1;   /* sign of exponent */Ù!  int e = 0;       /* exponent */ÙK  int eValid = 1;  /* True exponent is either not used or is well-formed */°  double result;²  int nDigits = 0;ÙM  int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */ ÙK  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );ÙC  *pResult = 0.0;   /* Default return value, in case of an error */ ¹  if( enc==SQLITE_UTF8 ){­    incr = 1;¨  }else{ª    int i;­    incr = 2;Ù5    assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );Ù-    for(i=3-enc; i<length && z[i]==0; i+=2){}¶    nonNum = i<length;³    zEnd = &z[i^1];±    z += (enc&1);£  } »  /* skip leading spaces */Ù0  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;¹  if( z>=zEnd ) return 0; ¿  /* get sign of significand */°  if( *z=='-' ){®    sign = -1;¬    z+=incr;¶  }else if( *z=='+' ){¬    z+=incr;£  } Ù2  /* copy max significant digits to significand */ÙD  while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){º    s = s*10 + (*z - '0');·    z+=incr; nDigits++;£  } Ù,  /* skip non-significant significand digitsÙ6  ** (increase exponent by d to shift decimal left) */ÙC  while( z<zEnd && sqlite3Isdigit(*z) ){ z+=incr; nDigits++; d++; }Ù"  if( z>=zEnd ) goto do_atof_calc; Ù#  /* if decimal point is present */°  if( *z=='.' ){¬    z+=incr;Ù4    /* copy digits from after decimal to significandÙ9    ** (decrease exponent by d to shift decimal right) */Ù*    while( z<zEnd && sqlite3Isdigit(*z) ){Ù%      if( s<((LARGEST_INT64-9)/10) ){¾        s = s*10 + (*z - '0');¬        d--;§      }¹      z+=incr; nDigits++;¥    }£  }Ù"  if( z>=zEnd ) goto do_atof_calc; ¾  /* if exponent is present */»  if( *z=='e' || *z=='E' ){¬    z+=incr;¯    eValid = 0; ÙI    /* This branch is needed to avoid a (harmless) buffer overread.  The ÙI    ** special comment alerts the mutation tester that the correct answerÙ3    ** is obtained even if the branch is omitted */ÙP    if( z>=zEnd ) goto do_atof_calc;              /*PREVENTS-HARMLESS-OVERREAD*/ ¾    /* get sign of exponent */²    if( *z=='-' ){±      esign = -1;®      z+=incr;¸    }else if( *z=='+' ){®      z+=incr;¥    }Ù!    /* copy digits to exponent */Ù*    while( z<zEnd && sqlite3Isdigit(*z) ){Ù0      e = e<10000 ? (e*10 + (*z - '0')) : 10000;®      z+=incr;±      eValid = 1;¥    }£  } ¼  /* skip trailing spaces */Ù0  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr; ­do_atof_calc:Ù-  /* adjust exponent by d, and update sign */´  e = (e*esign) + d;­  if( e<0 ) {¯    esign = -1;¬    e *= -1;ª  } else {®    esign = 1;£  } ®  if( s==0 ) {Ù3    /* In the IEEE 754 standard, zero is signed. */Ù-    result = sign<0 ? -(double)0 : (double)0;ª  } else {Ù"    /* Attempt to reduce exponent.¦    **ÙK    ** Branches that are not required for the correct answer but which onlyÙG    ** help to obtain the correct answer faster are marked with specialÙ2    ** comments, as a hint to the mutation tester.¦    */ÙP    while( e>0 ){                                       /*OPTIMIZATION-IF-TRUE*/´      if( esign>0 ){ÙP        if( s>=(LARGEST_INT64/10) ) break;             /*OPTIMIZATION-IF-FALSE*/°        s *= 10;¬      }else{ÙP        if( s%10!=0 ) break;                           /*OPTIMIZATION-IF-FALSE*/°        s /= 10;§      }ª      e--;¥    } Ù(    /* adjust the sign of significand */¸    s = sign<0 ? -s : s; ÙP    if( e==0 ){                                         /*OPTIMIZATION-IF-TRUE*/¹      result = (double)s;ª    }else{ÙB      /* attempt to handle extremely small/large numbers better */ÙP      if( e>307 ){                                      /*OPTIMIZATION-IF-TRUE*/ÙP        if( e<342 ){                                    /*OPTIMIZATION-IF-TRUE*/Ù6          LONGDOUBLE_TYPE scale = sqlite3Pow10(e-308);¸          if( esign<0 ){¿            result = s / scale;¿            result /= 1.0e+308;°          }else{¿            result = s * scale;¿            result *= 1.0e+308;«          }Ù         }else{ assert( e>=342 );¸          if( esign<0 ){»            result = 0.0*s;°          }else{¯#ifdef INFINITYÙ             result = INFINITY*s;¥#elseÙ3            result = 1e308*1e308*s;  /* Infinity */¦#endif«          }©        }¬      }else{Ù0        LONGDOUBLE_TYPE scale = sqlite3Pow10(e);¶        if( esign<0 ){½          result = s / scale;®        }else{½          result = s * scale;©        }§      }¥    }£  } ¸  /* store the result */´  *pResult = result; ÙI  /* return true if number and no extra non-whitespace chracters after */Ù5  return z==zEnd && nDigits>0 && eValid && nonNum==0;¥#elseÙ1  return !sqlite3Atoi64(z, pResult, length, enc);Ù'#endif /* SQLITE_OMIT_FLOATING_POINT */¡} ¢/*ÙG** Compare the 19-character string zNum against the text representationÙH** value 2^63:  9223372036854775808.  Return negative, zero, or positiveÙ>** if zNum is less than, equal to, or greater than the string.Ù5** Note that zNum must contain exactly 19 characters.¢**ÙF** Unlike memcmp() this routine is guaranteed to return the differenceÙC** in the values of the last digit if the only difference is in theÙ ** last digit.  So, for example,¢**Ù/**      compare2pow63("9223372036854775800", 1)¢**²** will return -8.¢*/Ù5static int compare2pow63(const char *zNum, int incr){¬  int c = 0;¨  int i;Ù,                    /* 012345678901234567 */Ù+  const char *pow63 = "922337203685477580";¾  for(i=0; c==0 && i<18; i++){Ù#    c = (zNum[i*incr]-pow63[i])*10;£  }­  if( c==0 ){¼    c = zNum[18*incr] - '8';¸    testcase( c==(-1) );µ    testcase( c==0 );¸    testcase( c==(+1) );£  }«  return c;¡} ¢/*ÙG** Convert zNum to a 64-bit signed integer.  zNum must be decimal. ThisÙ2** routine does *not* accept hexadecimal notation.¢**«** Returns:¢**ÙH**     0    Successful transformation.  Fits in a 64-bit signed integer.Ù9**     1    Excess non-space text after the integer valueÙI**     2    Integer too large for a 64-bit signed integer or is malformedÙ/**     3    Special case of 9223372036854775808¢**ÙG** length is the number of bytes in the string (bytes, not characters).ÙB** The string is not necessarily zero-terminated.  The encoding is°** given by enc.¢*/ÙRSQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){«  int incr;¬  u64 u = 0;Ù$  int neg = 0; /* assume positive */¨  int i;¬  int c = 0;ÙM  int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */Ù-  int rc;          /* Baseline return code */µ  const char *zStart;Ù#  const char *zEnd = zNum + length;ÙK  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );¹  if( enc==SQLITE_UTF8 ){­    incr = 1;¨  }else{­    incr = 2;Ù5    assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );Ù0    for(i=3-enc; i<length && zNum[i]==0; i+=2){}¶    nonNum = i<length;¶    zEnd = &zNum[i^1];´    zNum += (enc&1);£  }Ù9  while( zNum<zEnd && sqlite3Isspace(*zNum) ) zNum+=incr;²  if( zNum<zEnd ){µ    if( *zNum=='-' ){®      neg = 1;±      zNum+=incr;»    }else if( *zNum=='+' ){±      zNum+=incr;¥    }£  }°  zStart = zNum;ÙM  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; } /* Skip leading zeros. */ÙA  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){·    u = u*10 + c - '0';£  }¹  testcase( i==18*incr );¹  testcase( i==19*incr );¹  testcase( i==20*incr );¸  if( u>LARGEST_INT64 ){ÙF    /* This test and assignment is needed only to suppress UB warningsÙJ    ** from clang and -fsanitize=undefined.  This test and assignment makeÙK    ** the code a little larger and slower, and no harm comes from omittingÙE    ** them, but we must appaise the undefined-behavior pharisees. */Ù1    *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;²  }else if( neg ){´    *pNum = -(i64)u;¨  }else{³    *pNum = (i64)u;£  }©  rc = 0;Ù0  if( (i==0 && zStart==zNum)     /* No digits */ÙK   || nonNum                     /* UTF16 with high-order bytes non-zero */¤  ){«    rc = 1;Ù=  }else if( &zNum[i]<zEnd ){     /* Extra bytes at the end */¯    int jj = i;§    do{Ù&      if( !sqlite3Isspace(zNum[jj]) ){ÙE        rc = 1;          /* Extra non-space text after the integer */®        break;§      }±      jj += incr;½    }while( &zNum[jj]<zEnd );£  }²  if( i<19*incr ){ÙA    /* Less than 19 digits, so we know that it fits in 64 bits */¿    assert( u<=LARGEST_INT64 );®    return rc;¨  }else{ÙN    /* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */Ù2    c = i>19*incr ? 1 : compare2pow63(zNum, incr);®    if( c<0 ){Ù<      /* zNum is less than 9223372036854775808 so it fits */Ù!      assert( u<=LARGEST_INT64 );°      return rc;ª    }else{Ù3      *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;°      if( c>0 ){ÙF        /* zNum is greater than 9223372036854775808 so it overflows */±        return 2;¬      }else{ÙG        /* zNum is exactly 9223372036854775808.  Fits if negative.  TheÙ1        ** special case 2 overflow if positive */Ù%        assert( u-1==LARGEST_INT64 );¼        return neg ? rc : 3;§      }¥    }£  }¡} ¢/*ÙG** Transform a UTF-8 integer literal, in either decimal or hexadecimal,ÙL** into a 64-bit signed integer.  This routine accepts hexadecimal literals,Ù$** whereas sqlite3Atoi64() does not.¢**«** Returns:¢**ÙH**     0    Successful transformation.  Fits in a 64-bit signed integer.Ù/**     1    Excess text after the integer valueÙI**     2    Integer too large for a 64-bit signed integer or is malformedÙ/**     3    Special case of 9223372036854775808¢*/ÙBSQLITE_PRIVATE int sqlite3DecOrHexToI64(const char *z, i64 *pOut){¿#ifndef SQLITE_OMIT_HEX_INTEGER¯  if( z[0]=='0'¾   && (z[1]=='x' || z[1]=='X')¤  ){®    u64 u = 0;­    int i, k;¾    for(i=2; z[i]=='0'; i++){}Ù)    for(k=i; sqlite3Isxdigit(z[k]); k++){Ù'      u = u*16 + sqlite3HexToInt(z[k]);¥    }¸    memcpy(pOut, &u, 8);Ù(    return (z[k]==0 && k-i<=16) ? 0 : 2;§  }elseÙ$#endif /* SQLITE_OMIT_HEX_INTEGER */£  {ÙC    return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), SQLITE_UTF8);£  }¡} ¢/*ÙC** If zNum represents an integer that will fit in 32-bits, then setÙD** *pValue to that integer and return true.  Otherwise return false.¢**ÙK** This routine accepts both decimal and hexadecimal notation for integers.¢**Ù>** Any non-numeric characters that following zNum are ignored.Ù<** This is different from sqlite3Atoi64() which requires theÙ&** input number to be zero-terminated.¢*/ÙBSQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){µ  sqlite_int64 v = 0;«  int i, c;®  int neg = 0;µ  if( zNum[0]=='-' ){¬    neg = 1;«    zNum++;»  }else if( zNum[0]=='+' ){«    zNum++;£  }¿#ifndef SQLITE_OMIT_HEX_INTEGER·  else if( zNum[0]=='0'Ù)        && (zNum[1]=='x' || zNum[1]=='X')Ù#        && sqlite3Isxdigit(zNum[2])¤  ){®    u32 u = 0;®    zNum += 2;Ù!    while( zNum[0]=='0' ) zNum++;Ù3    for(i=0; sqlite3Isxdigit(zNum[i]) && i<8; i++){Ù*      u = u*16 + sqlite3HexToInt(zNum[i]);¥    }Ù;    if( (u&0x80000000)==0 && sqlite3Isxdigit(zNum[i])==0 ){¼      memcpy(pValue, &u, 4);¯      return 1;ª    }else{¯      return 0;¥    }£  }¦#endifÙ*  if( !sqlite3Isdigit(zNum[0]) ) return 0;¿  while( zNum[0]=='0' ) zNum++;Ù8  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){±    v = v*10 + c;£  } ÙI  /* The longest decimal representation of a 32 bit integer is 10 digits:¤  **»  **             1234567890»  **     2^31 -> 2147483648¤  */´  testcase( i==10 );­  if( i>10 ){­    return 0;£  }Ù   testcase( v-neg==2147483647 );¹  if( v-neg>2147483647 ){­    return 0;£  }¬  if( neg ){«    v = -v;£  }³  *pValue = (int)v;«  return 1;¡} ¢/*ÙA** Return a 32-bit integer value extracted from a string.  If theÙ+** string is not an integer, just return 0.¢*/Ù.SQLITE_PRIVATE int sqlite3Atoi(const char *z){¬  int x = 0;Ù!  if( z ) sqlite3GetInt32(z, &x);«  return x;¡} ¢/*Ù6** The variable-length integer encoding is as follows:¢**§** KEY:Ù:**         A = 0xxxxxxx    7 bits of data and one flag bitÙ:**         B = 1xxxxxxx    7 bits of data and one flag bitÙ)**         C = xxxxxxxx    8 bits of data¢**®**  7 bits - A¯** 14 bits - BA°** 21 bits - BBA±** 28 bits - BBBA²** 35 bits - BBBBA³** 42 bits - BBBBBA´** 49 bits - BBBBBBAµ** 56 bits - BBBBBBBA¶** 64 bits - BBBBBBBBC¢*/ ¢/*ÙE** Write a 64-bit variable-length integer to memory starting at p[0].ÙF** The length of data write will be between 1 and 9 bytes.  The numberÙ ** of bytes written is returned.¢**ÙF** A variable-length integer consists of the lower 7 bits of each byteÙD** for all bytes that have the 8th bit set and one byte with the 8thÙD** bit clear.  Except, if we get to the 9th byte, it stores the full¿** 8 bits and is the last byte.¢*/Ù@static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){®  int i, j, n;­  u8 buf[10];Ù$  if( v & (((u64)0xff000000)<<32) ){±    p[8] = (u8)v;¬    v >>= 8;¸    for(i=7; i>=0; i--){Ù%      p[i] = (u8)((v & 0x7f) | 0x80);®      v >>= 7;¥    }­    return 9;§  }    ¨  n = 0;¥  do{Ù'    buf[n++] = (u8)((v & 0x7f) | 0x80);¬    v >>= 7;±  }while( v!=0 );±  buf[0] &= 0x7f;±  assert( n<=9 );Ù"  for(i=0, j=n-1; j>=0; j--, i++){²    p[i] = buf[j];£  }«  return n;¡}Ù=SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){°  if( v<=0x7f ){²    p[0] = v&0x7f;­    return 1;£  }²  if( v<=0x3fff ){¾    p[0] = ((v>>7)&0x7f)|0x80;²    p[1] = v&0x7f;­    return 2;£  }º  return putVarint64(p,v);¡} ¢/*ÙD** Bitmasks used by sqlite3GetVarint().  These precomputed constantsÙG** are defined here rather than simply putting the constant expressionsÙ;** inline in order to work around bugs in the RVT compiler.¢**Ù-** SLOT_2_0     A mask for  (0x7f<<14) | 0x7f¢**Ù1** SLOT_4_2_0   A mask for  (0x7f<<28) | SLOT_2_0¢*/¿#define SLOT_2_0     0x001fc07f¿#define SLOT_4_2_0   0xf01fc07f  ¢/*ÙF** Read a 64-bit variable-length integer from memory starting at p[0].Ù?** Return the number of bytes read.  The value is stored in *v.¢*/ÙCSQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){¬  u32 a,b,s; ©  a = *p;¸  /* a: p0 (unmasked) */°  if (!(a&0x80))£  {«    *v = a;­    return 1;£  } ¦  p++;©  b = *p;¸  /* b: p1 (unmasked) */°  if (!(b&0x80))£  {®    a &= 0x7f;­    a = a<<7;«    a |= b;«    *v = a;­    return 2;£  } Ù7  /* Verify that constants are precomputed correctly */Ù.  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );Ù=  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) ); ¦  p++;¬  a = a<<14;ª  a |= *p;Ù!  /* a: p0<<14 | p2 (unmasked) */°  if (!(a&0x80))£  {²    a &= SLOT_2_0;®    b &= 0x7f;­    b = b<<7;«    a |= b;«    *v = a;­    return 3;£  } ·  /* CSE1 from below */°  a &= SLOT_2_0;¦  p++;¬  b = b<<14;ª  b |= *p;Ù!  /* b: p1<<14 | p3 (unmasked) */°  if (!(b&0x80))£  {²    b &= SLOT_2_0;·    /* moved CSE1 up */Ù!    /* a &= (0x7f<<14)|(0x7f); */­    a = a<<7;«    a |= b;«    *v = a;­    return 4;£  } ¿  /* a: p0<<14 | p2 (masked) */Ù!  /* b: p1<<14 | p3 (unmasked) */Ù8  /* 1:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */µ  /* moved CSE1 up */¿  /* a &= (0x7f<<14)|(0x7f); */°  b &= SLOT_2_0;¨  s = a;¿  /* s: p0<<14 | p2 (masked) */ ¦  p++;¬  a = a<<14;ª  a |= *p;Ù*  /* a: p0<<28 | p2<<14 | p4 (unmasked) */°  if (!(a&0x80))£  {ÙA    /* we can skip these cause they were (effectively) done above½    ** while calculating s */Ù,    /* a &= (0x7f<<28)|(0x7f<<14)|(0x7f); */Ù!    /* b &= (0x7f<<14)|(0x7f); */­    b = b<<7;«    a |= b;®    s = s>>18;º    *v = ((u64)s)<<32 | a;­    return 5;£  } Ù8  /* 2:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */«  s = s<<7;©  s |= b;Ù0  /* s: p0<<21 | p1<<14 | p2<<7 | p3 (masked) */ ¦  p++;¬  b = b<<14;ª  b |= *p;Ù*  /* b: p1<<28 | p3<<14 | p5 (unmasked) */°  if (!(b&0x80))£  {ÙN    /* we can skip this cause it was (effectively) done above in calc'ing s */Ù,    /* b &= (0x7f<<28)|(0x7f<<14)|(0x7f); */²    a &= SLOT_2_0;­    a = a<<7;«    a |= b;®    s = s>>18;º    *v = ((u64)s)<<32 | a;­    return 6;£  } ¦  p++;¬  a = a<<14;ª  a |= *p;Ù*  /* a: p2<<28 | p4<<14 | p6 (unmasked) */°  if (!(a&0x80))£  {´    a &= SLOT_4_2_0;²    b &= SLOT_2_0;­    b = b<<7;«    a |= b;®    s = s>>11;º    *v = ((u64)s)<<32 | a;­    return 7;£  } ·  /* CSE2 from below */°  a &= SLOT_2_0;¦  p++;¬  b = b<<14;ª  b |= *p;Ù*  /* b: p3<<28 | p5<<14 | p7 (unmasked) */°  if (!(b&0x80))£  {´    b &= SLOT_4_2_0;·    /* moved CSE2 up */Ù!    /* a &= (0x7f<<14)|(0x7f); */­    a = a<<7;«    a |= b;­    s = s>>4;º    *v = ((u64)s)<<32 | a;­    return 8;£  } ¦  p++;¬  a = a<<15;ª  a |= *p;Ù*  /* a: p4<<29 | p6<<15 | p8 (unmasked) */ µ  /* moved CSE2 up */Ù*  /* a &= (0x7f<<29)|(0x7f<<15)|(0xff); */°  b &= SLOT_2_0;«  b = b<<8;©  a |= b; «  s = s<<4;¬  b = p[-4];¬  b &= 0x7f;«  b = b>>3;©  s |= b; ¸  *v = ((u64)s)<<32 | a; «  return 9;¡} ¢/*ÙF** Read a 32-bit variable-length integer from memory starting at p[0].Ù?** Return the number of bytes read.  The value is stored in *v.¢**ÙK** If the varint stored in p[0] is larger than can fit in a 32-bit unsignedÙ&** integer, then set *v to 0xffffffff.¢**Ù?** A MACRO version, getVarint32, is provided which inlines the Ù?** single-byte case.  All code should use the MACRO version as ÙG** this function assumes the single-byte case has already been handled.¢*/ÙESQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){ª  u32 a,b; ÙF  /* The 1-byte case.  Overwhelmingly the most common.  Handled inlineÙ!  ** by the getVarin32() macro */©  a = *p;¸  /* a: p0 (unmasked) */³#ifndef getVarint32°  if (!(a&0x80))£  {Ù"    /* Values between 0 and 127 */«    *v = a;­    return 1;£  }¦#endif ·  /* The 2-byte case */¦  p++;©  b = *p;¸  /* b: p1 (unmasked) */°  if (!(b&0x80))£  {Ù&    /* Values between 128 and 16383 */®    a &= 0x7f;­    a = a<<7;¯    *v = a | b;­    return 2;£  } ·  /* The 3-byte case */¦  p++;¬  a = a<<14;ª  a |= *p;Ù!  /* a: p0<<14 | p2 (unmasked) */°  if (!(a&0x80))£  {Ù*    /* Values between 16384 and 2097151 */»    a &= (0x7f<<14)|(0x7f);®    b &= 0x7f;­    b = b<<7;¯    *v = a | b;­    return 3;£  } ÙA  /* A 32-bit varint is used to store size information in btrees.ÙB  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.ÙC  ** A 3-byte varint is sufficient, for example, to record the sizeÙ&  ** of a 1048569-byte BLOB or string.¤  **ÙB  ** We only unroll the first 1-, 2-, and 3- byte cases.  The veryÙA  ** rare larger cases can be handled by the slower 64-bit varint­  ** routine.¤  */¥#if 1£  {¬    u64 v64;©    u8 n; «    p -= 2;Ù"    n = sqlite3GetVarint(p, &v64);º    assert( n>3 && n<=9 );Ù&    if( (v64 & SQLITE_MAX_U32)!=v64 ){¶      *v = 0xffffffff;ª    }else{´      *v = (u32)v64;¥    }­    return n;£  } ¥#elseÙB  /* For following code (kept for historical record only) shows anÙ@  ** unrolling for the 3- and 4-byte varint cases.  This code isÙD  ** slightly faster, but it is also larger and much harder to test.¤  */¦  p++;¬  b = b<<14;ª  b |= *p;Ù!  /* b: p1<<14 | p3 (unmasked) */°  if (!(b&0x80))£  {Ù.    /* Values between 2097152 and 268435455 */»    b &= (0x7f<<14)|(0x7f);»    a &= (0x7f<<14)|(0x7f);­    a = a<<7;¯    *v = a | b;­    return 4;£  } ¦  p++;¬  a = a<<14;ª  a |= *p;Ù*  /* a: p0<<28 | p2<<14 | p4 (unmasked) */°  if (!(a&0x80))£  {Ù3    /* Values  between 268435456 and 34359738367 */´    a &= SLOT_4_2_0;´    b &= SLOT_4_2_0;­    b = b<<7;¯    *v = a | b;­    return 5;£  } ÙA  /* We can only reach this point when reading a corrupt databaseÙF  ** file.  In that case we are not in any hurry.  Use the (relativelyÙD  ** slow) general-purpose sqlite3GetVarint() routine to extract the®  ** value. */£  {¬    u64 v64;©    u8 n; «    p -= 4;Ù"    n = sqlite3GetVarint(p, &v64);º    assert( n>5 && n<=9 );²    *v = (u32)v64;­    return n;£  }¦#endif¡} ¢/*ÙD** Return the number of bytes that will be needed to store the given²** 64-bit integer.¢*/Ù+SQLITE_PRIVATE int sqlite3VarintLen(u64 v){¨  int i;Ù0  for(i=1; (v >>= 7)!=0; i++){ assert( i<10 ); }«  return i;¡}  ¢/*Ù6** Read or write a four-byte big-endian integer value.¢*/Ù0SQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p){º#if SQLITE_BYTEORDER==4321¨  u32 x;±  memcpy(&x,p,4);«  return x;Ù4#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000¨  u32 x;±  memcpy(&x,p,4);¾  return __builtin_bswap32(x);Ù2#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300¨  u32 x;±  memcpy(&x,p,4);¼  return _byteswap_ulong(x);¥#else¸  testcase( p[0]&0x80 );Ù>  return ((unsigned)p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];¦#endif¡}Ù=SQLITE_PRIVATE void sqlite3Put4byte(unsigned char *p, u32 v){º#if SQLITE_BYTEORDER==4321±  memcpy(p,&v,4);Ù4#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000¿  u32 x = __builtin_bswap32(v);±  memcpy(p,&x,4);Ù2#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300½  u32 x = _byteswap_ulong(v);±  memcpy(p,&x,4);¥#elseµ  p[0] = (u8)(v>>24);µ  p[1] = (u8)(v>>16);´  p[2] = (u8)(v>>8);¯  p[3] = (u8)v;¦#endif¡}   ¢/*Ù2** Translate a single byte of Hex into an integer.Ù=** This routine only works if h really is a valid hexadecimal»** character:  0..9a..fA..F¢*/Ù)SQLITE_PRIVATE u8 sqlite3HexToInt(int h){ÙM  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );³#ifdef SQLITE_ASCII´  h += 9*(1&(h>>6));¦#endif´#ifdef SQLITE_EBCDICµ  h += 9*(1&~(h>>4));¦#endif·  return (u8)(h & 0xf);¡} ÙC#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC)¢/*ÙA** Convert a BLOB literal of the form "x'hhhhhh'" into its binaryÙC** value.  Return a pointer to its binary value.  Space to hold theÙB** binary value has been obtained from malloc and must be freed by·** the calling routine.¢*/ÙISQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){®  char *zBlob;¨  int i; Ù4  zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);¦  n--;®  if( zBlob ){¸    for(i=0; i<n; i+=2){ÙH      zBlob[i/2] = (sqlite3HexToInt(z[i])<<4) | sqlite3HexToInt(z[i+1]);¥    }³    zBlob[i/2] = 0;£  }¯  return zBlob;¡}Ù:#endif /* !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */ ¢/*ÙG** Log an error that is an API call on a connection pointer that shouldÙH** not have been used.  The "type" of connection pointer is given as theÙG** argument.  The zType is a word like "NULL" or "closed" or "invalid".¢*/Ù0static void logBadConnection(const char *zType){½  sqlite3_log(SQLITE_MISUSE, Ù4     "API call with %s database connection pointer",ª     zType¤  );¡} ¢/*ÙC** Check to make sure we have a valid db pointer.  This test is notÙC** foolproof but it does provide some measure of protection againstÙB** misuse of the interface such as passing in db pointers that areÙF** NULL or which have been previously closed.  If this routine returnsÙD** 1 it means that the db pointer is valid and 0 if it should not beÙC** dereferenced for any reason.  The calling function should invoke½** SQLITE_MISUSE immediately.¢**ÙC** sqlite3SafetyCheckOk() requires that the db pointer be valid forÙH** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed toÙ@** open properly and is not fit for general use but which can beÙ>** used as an argument to sqlite3_errmsg() or sqlite3_close().¢*/Ù5SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db){¬  u32 magic;®  if( db==0 ){½    logBadConnection("NULL");­    return 0;£  }´  magic = db->magic;Ù!  if( magic!=SQLITE_MAGIC_OPEN ){Ù)    if( sqlite3SafetyCheckSickOrOk(db) ){Ù.      testcase( sqlite3GlobalConfig.xLog!=0 );Ù#      logBadConnection("unopened");¥    }­    return 0;¨  }else{­    return 1;£  }¡}Ù;SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db){¬  u32 magic;´  magic = db->magic;Ù!  if( magic!=SQLITE_MAGIC_SICK &&Ù!      magic!=SQLITE_MAGIC_OPEN &&Ù!      magic!=SQLITE_MAGIC_BUSY ){Ù,    testcase( sqlite3GlobalConfig.xLog!=0 );Ù     logBadConnection("invalid");­    return 0;¨  }else{­    return 1;£  }¡} ¢/*ÙL** Attempt to add, substract, or multiply the 64-bit signed value iB againstÙF** the other 64-bit signed integer at *pA and store the result in *pA.ÙF** Return 0 on success.  Or if the operation would have resulted in anÙ.** overflow, leave *pA unchanged and return 1.¢*/Ù4SQLITE_PRIVATE int sqlite3AddInt64(i64 *pA, i64 iB){Ù6#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)Ù-  return __builtin_add_overflow(*pA, iB, pA);¥#else¯  i64 iA = *pA;Ù'  testcase( iA==0 ); testcase( iA==1 );Ù(  testcase( iB==-1 ); testcase( iB==0 );®  if( iB>=0 ){Ù1    testcase( iA>0 && LARGEST_INT64 - iA == iB );Ù5    testcase( iA>0 && LARGEST_INT64 - iA == iB - 1 );Ù3    if( iA>0 && LARGEST_INT64 - iA < iB ) return 1;¨  }else{Ù8    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 1 );Ù8    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 2 );Ù:    if( iA<0 && -(iA + LARGEST_INT64) > iB + 1 ) return 1;£  }¬  *pA += iB;¬  return 0; ¦#endif¡}Ù4SQLITE_PRIVATE int sqlite3SubInt64(i64 *pA, i64 iB){Ù6#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)Ù-  return __builtin_sub_overflow(*pA, iB, pA);¥#elseÙ#  testcase( iB==SMALLEST_INT64+1 );»  if( iB==SMALLEST_INT64 ){Ù2    testcase( (*pA)==(-1) ); testcase( (*pA)==0 );¼    if( (*pA)>=0 ) return 1;®    *pA -= iB;­    return 0;¨  }else{Ù$    return sqlite3AddInt64(pA, -iB);£  }¦#endif¡}Ù4SQLITE_PRIVATE int sqlite3MulInt64(i64 *pA, i64 iB){Ù6#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)Ù-  return __builtin_mul_overflow(*pA, iB, pA);¥#else¯  i64 iA = *pA;­  if( iB>0 ){Ù'    if( iA>LARGEST_INT64/iB ) return 1;Ù(    if( iA<SMALLEST_INT64/iB ) return 1;³  }else if( iB<0 ){¯    if( iA>0 ){Ù*      if( iB<SMALLEST_INT64/iA ) return 1;µ    }else if( iA<0 ){Ù(      if( iB==SMALLEST_INT64 ) return 1;Ù(      if( iA==SMALLEST_INT64 ) return 1;Ù+      if( -iA>LARGEST_INT64/-iB ) return 1;¥    }£  }®  *pA = iA*iB;«  return 0;¦#endif¡} ¢/*ÙK** Compute the absolute value of a 32-bit signed integer, of possible.  Or Ù@** if the integer has a value of -2147483648, return +2147483647¢*/Ù*SQLITE_PRIVATE int sqlite3AbsInt32(int x){¶  if( x>=0 ) return x;Ù-  if( x==(int)0x80000000 ) return 0x7fffffff;¬  return -x;¡} ¾#ifdef SQLITE_ENABLE_8_3_NAMES¢/*ÙH** If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the databaseÙJ** filename in zBaseFilename is a URI with the "8_3_names=1" parameter andÙK** if filename in z[] has a suffix (a.k.a. "extension") that is longer thanÙH** three characters, then shorten the suffix on z[] to be the last threeÙ%** characters of the original suffix.¢**ÙF** If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then alwaysÙ8** do the suffix shortening regardless of URI parameter.¢**¬** Examples:¢**Ù'**     test.db-journal    =>   test.nalÙ'**     test.db-wal        =>   test.walÙ'**     test.db-shm        =>   test.shmÙ'**     test.db-mj7f3319fa =>   test.9fa¢*/ÙKSQLITE_PRIVATE void sqlite3FileSuffix3(const char *zBaseFilename, char *z){½#if SQLITE_ENABLE_8_3_NAMES<2Ù:  if( sqlite3_uri_boolean(zBaseFilename, "8_3_names", 0) )¦#endif£  {®    int i, sz;¼    sz = sqlite3Strlen30(z);Ù5    for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}ÙD    if( z[i]=='.' && ALWAYS(sz>i+4) ) memmove(&z[i+1], &z[sz-3], 4);£  }¡}¦#endif £/* ÙG** Find (an approximate) sum of two LogEst values.  This computation isÙF** not a simple "+" operator because LogEst is stored as a logarithmic©** value.£** ¢*/Ù;SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst a, LogEst b){Ù$  static const unsigned char x[] = {Ù.     10, 10,                         /* 0,1 */Ù.      9, 9,                          /* 2,3 */Ù.      8, 8,                          /* 4,5 */Ù0      7, 7, 7,                       /* 6,7,8 */Ù2      6, 6, 6,                       /* 9,10,11 */Ù0      5, 5, 5,                       /* 12-14 */Ù0      4, 4, 4, 4,                    /* 15-18 */Ù0      3, 3, 3, 3, 3, 3,              /* 19-24 */Ù0      2, 2, 2, 2, 2, 2, 2,           /* 25-31 */¤  };­  if( a>=b ){º    if( a>b+49 ) return a;¼    if( a>b+31 ) return a+1;´    return a+x[a-b];¨  }else{º    if( b>a+49 ) return b;¼    if( b>a+31 ) return b+1;´    return b+x[b-a];£  }¡} ¢/*Ù@** Convert an integer into a LogEst.  In other words, compute anÙ ** approximation for 10*log2(x).¢*/Ù+SQLITE_PRIVATE LogEst sqlite3LogEst(u64 x){Ù1  static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };°  LogEst y = 40;¬  if( x<8 ){·    if( x<2 ) return 0;Ù&    while( x<8 ){  y -= 10; x <<= 1; }¨  }else{¸#if GCC_VERSION>=5004000Ù$    int i = 60 - __builtin_clzll(x);®    y += i*10;¬    x >>= i;¥#elseÙA    while( x>255 ){ y += 40; x >>= 4; }  /*OPTIMIZATION-IF-TRUE*/Ù'    while( x>15 ){  y += 10; x >>= 1; }¦#endif£  }¹  return a[x&7] + y - 10;¡} Ù #ifndef SQLITE_OMIT_VIRTUALTABLE¢/*Ù!** Convert a double into a LogEstÙ;** In other words, compute an approximation for 10*log2(x).¢*/Ù8SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x){¨  u64 a;«  LogEst e;Ù)  assert( sizeof(x)==8 && sizeof(a)==8 );¶  if( x<=1 ) return 0;Ù3  if( x<=2000000000 ) return sqlite3LogEst((u64)x);´  memcpy(&a, &x, 8);µ  e = (a>>52) - 1022;®  return e*10;¡}Ù%#endif /* SQLITE_OMIT_VIRTUALTABLE */ Ù/#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \Ù.    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \Ù*    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)¢/*Ù$** Convert a LogEst into an integer.¢**ÙB** Note that this routine is only used when one or more of variousÙ0** non-standard compile-time options is enabled.¢*/Ù0SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst x){¨  u64 n;«  n = x%10;ª  x /= 10;´  if( n>=5 ) n -= 2;¹  else if( n>=1 ) n -= 1;Ù/#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \Ù*    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)Ù'  if( x>60 ) return (u64)LARGEST_INT64;¥#elseÙG  /* If only SQLITE_ENABLE_STAT3_OR_STAT4 is on, then the largest inputÙG  ** possible to this routine is 310, resulting in a maximum x of 31 */²  assert( x<=60 );¦#endifÙ,  return x>=3 ? (n+8)<<(x-3) : (n+8)>>(3-x);¡}Ù8#endif /* defined SCANSTAT or STAT4 or ESTIMATED_ROWS */ ¢/*ÙF** Add a new name/number pair to a VList.  This might require that theÙC** VList object be reallocated, so return the new VList.  If an OOMÙ4** error occurs, the original VList returned and theÙ ** db->mallocFailed flag is set.¢**ÙD** A VList is really just an array of integers.  To destroy a VList,Ù%** simply pass it to sqlite3DbFree().¢**ÙF** The first integer is the number of integers allocated for the wholeÙF** VList.  The second integer is the number of integers actually used.ÙE** Each name/number pair is encoded by subsequent groups of 3 or more¬** integers.¢**ÙG** Each name/number pair starts with two integers which are the numericÙI** value for the pair and the size of the name/number pair, respectively.ÙH** The text name overlays one or more following integers.  The text name½** is always zero-terminated.¢**°** Conceptually:¢**´**    struct VList {Ù3**      int nAlloc;   // Number of allocated slots Ù.**      int nUsed;    // Number of used slots »**      struct VListEntry {Ù0**        int iValue;    // Value for this entryÙ4**        int nSlot;     // Slots used by this entryÙ(**        // ... variable name goes here¯**      } a[0];§**    }¢**ÙD** During code generation, pointers to the variable names within theÙD** VList are taken.  When that happens, nAlloc is set to zero as an ÙC** indication that the VList may never again be enlarged, since theÙ8** accompanying realloc() would invalidate the pointers.¢*/Ù&SQLITE_PRIVATE VList *sqlite3VListAdd(ÙH  sqlite3 *db,           /* The database connection used for malloc() */Ù>  VList *pIn,            /* The input VList.  Might be NULL */Ù4  const char *zName,     /* Name of symbol to add */Ù5  int nName,             /* Bytes of text in zName */Ù<  int iVal               /* Value to associate with zName */¢){ÙM  int nInt;              /* number of sizeof(int) objects needed for zName */ÙD  char *z;               /* Pointer to where zName will be stored */ÙC  int i;                 /* Index in pIn[] where zName is stored */ µ  nInt = nName/4 + 3;ÙE  assert( pIn==0 || pIn[0]>=3 );  /* Verify ok to add new elements */Ù'  if( pIn==0 || pIn[1]+nInt > pIn[0] ){Ù     /* Enlarge the allocation */Ù.    int nAlloc = (pIn ? pIn[0]*2 : 10) + nInt;Ù@    VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));½    if( pOut==0 ) return pIn;½    if( pIn==0 ) pOut[1] = 2;¯    pIn = pOut;´    pIn[0] = nAlloc;£  }­  i = pIn[1];°  pIn[i] = iVal;²  pIn[i+1] = nInt;·  z = (char*)&pIn[i+2];²  pIn[1] = i+nInt;»  assert( pIn[1]<=pIn[0] );º  memcpy(z, zName, nName);¯  z[nName] = 0;­  return pIn;¡} ¢/*ÙE** Return a pointer to the name of a variable in the given VList thatÙH** has the value iVal.  Or return a NULL if there is no such variable in«** the list¢*/ÙGSQLITE_PRIVATE const char *sqlite3VListNumToName(VList *pIn, int iVal){¬  int i, mx;¸  if( pIn==0 ) return 0;®  mx = pIn[1];¨  i = 2;¥  do{Ù/    if( pIn[i]==iVal ) return (char*)&pIn[i+2];²    i += pIn[i+1];±  }while( i<mx );«  return 0;¡} ¢/*ÙD** Return the number of the variable named zName, if it is in VList.Ù,** or return 0 if there is no such variable.¢*/ÙSSQLITE_PRIVATE int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){¬  int i, mx;¸  if( pIn==0 ) return 0;®  mx = pIn[1];¨  i = 2;¥  do{Ù+    const char *z = (const char*)&pIn[i+2];ÙA    if( strncmp(z,zName,nName)==0 && z[nName]==0 ) return pIn[i];²    i += pIn[i+1];±  }while( i<mx );«  return 0;¡} ÙO/************** End of util.c ************************************************/ÙO/************** Begin file hash.c ********************************************/¢/*´** 2001 September 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù4** This is the implementation of generic hash-tables²** used in SQLite.¢*/¼/* #include "sqliteInt.h" */¹/* #include <assert.h> */ Ù@/* Turn bulk memory into a hash table object by initializing theÙ ** fields of the Hash structure.¢**ÙC** "pNew" is a pointer to the hash table that is to be initialized.¢*/Ù0SQLITE_PRIVATE void sqlite3HashInit(Hash *pNew){´  assert( pNew!=0 );²  pNew->first = 0;²  pNew->count = 0;³  pNew->htsize = 0;¯  pNew->ht = 0;¡} Ù=/* Remove all entries from a hash table.  Reclaim all memory.ÙD** Call this routine to delete a hash table or to reset a hash table¶** to the empty state.¢*/Ù/SQLITE_PRIVATE void sqlite3HashClear(Hash *pH){ÙJ  HashElem *elem;         /* For looping over all elements of the table */ ²  assert( pH!=0 );³  elem = pH->first;°  pH->first = 0;·  sqlite3_free(pH->ht);­  pH->ht = 0;±  pH->htsize = 0;°  while( elem ){Ù%    HashElem *next_elem = elem->next;·    sqlite3_free(elem);µ    elem = next_elem;£  }°  pH->count = 0;¡} ¢/*¸** The hashing function.¢*/Ù+static unsigned int strHash(const char *z){µ  unsigned int h = 0;²  unsigned char c;ÙE  while( (c = (unsigned char)*z++)!=0 ){     /*OPTIMIZATION-IF-TRUE*/ÙD    /* Knuth multiplicative hashing.  (Sorting & Searching, p. 510).ÙD    ** 0x9e3779b1 is 2654435761 which is the closest prime number toÙE    ** (2**32)*golden_ratio, where golden_ratio = (sqrt(5) - 1)/2. */Ù     h += sqlite3UpperToLower[c];´    h *= 0x9e3779b1;£  }«  return h;¡}  ÙD/* Link pNew element into the hash table pH.  If pEntry!=0 then alsoÙ+** insert pNew into the pEntry hash bucket.¢*/ºstatic void insertElement(Ù6  Hash *pH,              /* The complete hash table */ÙD  struct _ht *pEntry,    /* The entry into which pNew is inserted */Ù9  HashElem *pNew         /* The element to be inserted */¢){Ù>  HashElem *pHead;       /* First element already in pEntry */¯  if( pEntry ){Ù.    pHead = pEntry->count ? pEntry->chain : 0;´    pEntry->count++;¹    pEntry->chain = pNew;¨  }else{®    pHead = 0;£  }®  if( pHead ){·    pNew->next = pHead;½    pNew->prev = pHead->prev;Ù2    if( pHead->prev ){ pHead->prev->next = pNew; }Ù*    else             { pH->first = pNew; }·    pHead->prev = pNew;¨  }else{»    pNew->next = pH->first;Ù.    if( pH->first ){ pH->first->prev = pNew; }³    pNew->prev = 0;µ    pH->first = pNew;£  }¡}  Ù@/* Resize the hash table so that it cantains "new_size" buckets.¢**ÙC** The hash table might fail to resize if sqlite3_malloc() fails orÙ1** if the new size is the same as the prior size.Ù5** Return TRUE if the resize occurs and false if not.¢*/Ù3static int rehash(Hash *pH, unsigned int new_size){Ù9  struct _ht *new_ht;            /* The new hash table */ÙI  HashElem *elem, *next_elem;    /* For looping over existing elements */ ¾#if SQLITE_MALLOC_SOFT_LIMIT>0Ù=  if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){Ù;    new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht);£  }Ù&  if( new_size==pH->htsize ) return 0;¦#endif Ù@  /* The inability to allocates space for a larger hash table isÙ@  ** a performance hit but it is not a fatal error.  So mark theÙF  ** allocation as a benign. Use sqlite3Malloc()/memset(0) instead of ÙG  ** sqlite3MallocZero() to make the allocation, as sqlite3MallocZero()ÙG  ** only zeroes the requested number of bytes whereas this module willÙG  ** use the actual amount of space allocated for the hash table (whichÙ.  ** may be larger than the requested amount).¤  */½  sqlite3BeginBenignMalloc();ÙF  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );»  sqlite3EndBenignMalloc(); »  if( new_ht==0 ) return 0;·  sqlite3_free(pH->ht);²  pH->ht = new_ht;ÙG  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);Ù1  memset(new_ht, 0, new_size*sizeof(struct _ht));Ù;  for(elem=pH->first, pH->first=0; elem; elem = next_elem){Ù4    unsigned int h = strHash(elem->pKey) % new_size;»    next_elem = elem->next;Ù(    insertElement(pH, &new_ht[h], elem);£  }«  return 1;¡} ÙA/* This function (for internal use only) locates an element in anÙB** hash table that matches the given key.  If no element is found,ÙH** a pointer to a static null element with HashElem.data==0 is returned.ÙC** If pH is not NULL, then the hash for this key is written to *pH.¢*/Ù%static HashElem *findElementWithHash(Ù1  const Hash *pH,     /* The pH to be searched */Ù8  const char *pKey,   /* The key we are searching for */Ù5  unsigned int *pHash /* Write the hash value here */¢){ÙI  HashElem *elem;                /* Used to loop thru the element list */ÙF  int count;                     /* Number of elements left to test */Ù8  unsigned int h;                /* The computed hash */Ù/  static HashElem nullElement = { 0, 0, 0, 0 }; Ù*  if( pH->ht ){   /*OPTIMIZATION-IF-TRUE*/·    struct _ht *pEntry;Ù#    h = strHash(pKey) % pH->htsize;¸    pEntry = &pH->ht[h];¹    elem = pEntry->chain;º    count = pEntry->count;¨  }else{ª    h = 0;µ    elem = pH->first;¶    count = pH->count;£  }¹  if( pHash ) *pHash = h;³  while( count-- ){¶    assert( elem!=0 );Ù.    if( sqlite3StrICmp(elem->pKey,pKey)==0 ){ ²      return elem;¥    }¶    elem = elem->next;£  }¶  return &nullElement;¡} ÙD/* Remove a single entry from the hash table given a pointer to thatÙ+** element and a hash on the element's key.¢*/Ù#static void removeElementGivenHash(Ù2  Hash *pH,         /* The pH containing "elem" */Ù?  HashElem* elem,   /* The element to be removed from the pH */Ù4  unsigned int h    /* Hash value for the element */¢){µ  struct _ht *pEntry;³  if( elem->prev ){Ù#    elem->prev->next = elem->next; ¨  }else{»    pH->first = elem->next;£  }³  if( elem->next ){Ù"    elem->next->prev = elem->prev;£  }¯  if( pH->ht ){¸    pEntry = &pH->ht[h];¾    if( pEntry->chain==elem ){Ù!      pEntry->chain = elem->next;¥    }´    pEntry->count--;¿    assert( pEntry->count>=0 );£  }·  sqlite3_free( elem );®  pH->count--;µ  if( pH->count==0 ){»    assert( pH->first==0 );»    assert( pH->count==0 );¹    sqlite3HashClear(pH);£  }¡} Ù?/* Attempt to locate an element of the hash table pH with a keyÙ@** that matches pKey.  Return the data for this element if it isÙ'** found, or NULL if there is no match.¢*/ÙGSQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey){²  assert( pH!=0 );´  assert( pKey!=0 );Ù0  return findElementWithHash(pH, pKey, 0)->data;¡} Ù=/* Insert an element into the hash table pH.  The key is pKeyº** and the data is "data".¢**Ù7** If no element exists with a matching key, then a newÙ+** element is created and NULL is returned.¢**Ù@** If another element already exists with the same key, then theÙ?** new data replaces the old data and the old data is returned.ÙC** The key is not copied in this instance.  If a malloc fails, thenÙ<** the new data is returned and the hash table is unchanged.¢**Ù=** If the "data" parameter to this function is NULL, then theÙA** element corresponding to "key" is removed from the hash table.¢*/ÙOSQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){ÙH  unsigned int h;       /* the hash of the key modulo hash table size */Ù@  HashElem *elem;       /* Used to loop thru the element list */Ù9  HashElem *new_elem;   /* New element added to the pH */ ²  assert( pH!=0 );´  assert( pKey!=0 );Ù)  elem = findElementWithHash(pH,pKey,&h);³  if( elem->data ){Ù     void *old_data = elem->data;²    if( data==0 ){Ù(      removeElementGivenHash(pH,elem,h);ª    }else{¸      elem->data = data;¸      elem->pKey = pKey;¥    }´    return old_data;£  }¹  if( data==0 ) return 0;Ù:  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );Ù   if( new_elem==0 ) return data;¸  new_elem->pKey = pKey;¸  new_elem->data = data;®  pH->count++;Ù2  if( pH->count>=10 && pH->count > 2*pH->htsize ){Ù"    if( rehash(pH, pH->count*2) ){½      assert( pH->htsize>0 );Ù%      h = strHash(pKey) % pH->htsize;¥    }£  }Ù7  insertElement(pH, pH->ht ? &pH->ht[h] : 0, new_elem);«  return 0;¡} ÙO/************** End of hash.c ************************************************/ÙO/************** Begin file opcodes.c *****************************************/Ù+/* Automatically generated.  Do not edit */Ù4/* See the tool/mkopcodec.tcl script for details. */Ù##if !defined(SQLITE_OMIT_EXPLAIN) \» || defined(VDBE_PROFILE) \¹ || defined(SQLITE_DEBUG)ÙD#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) || defined(SQLITE_DEBUG)¹# define OpHelp(X) "\0" X¥#else²# define OpHelp(X)¦#endifÙ4SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){Ù& static const char *const azName[] = {Ù,    /*   0 */ "Savepoint"        OpHelp(""),Ù,    /*   1 */ "AutoCommit"       OpHelp(""),Ù,    /*   2 */ "Transaction"      OpHelp(""),Ù,    /*   3 */ "SorterNext"       OpHelp(""),Ù,    /*   4 */ "PrevIfOpen"       OpHelp(""),Ù,    /*   5 */ "NextIfOpen"       OpHelp(""),Ù,    /*   6 */ "Prev"             OpHelp(""),Ù,    /*   7 */ "Next"             OpHelp(""),Ù,    /*   8 */ "Checkpoint"       OpHelp(""),Ù,    /*   9 */ "JournalMode"      OpHelp(""),Ù,    /*  10 */ "Vacuum"           OpHelp(""),ÙB    /*  11 */ "VFilter"          OpHelp("iplan=r[P3] zplan='P4'"),Ù9    /*  12 */ "VUpdate"          OpHelp("data=r[P3@P2]"),Ù,    /*  13 */ "Goto"             OpHelp(""),Ù,    /*  14 */ "Gosub"            OpHelp(""),Ù,    /*  15 */ "InitCoroutine"    OpHelp(""),Ù,    /*  16 */ "Yield"            OpHelp(""),Ù,    /*  17 */ "MustBeInt"        OpHelp(""),Ù,    /*  18 */ "Jump"             OpHelp(""),Ù9    /*  19 */ "Not"              OpHelp("r[P2]= !r[P1]"),Ù,    /*  20 */ "Once"             OpHelp(""),Ù,    /*  21 */ "If"               OpHelp(""),Ù,    /*  22 */ "IfNot"            OpHelp(""),ÙR    /*  23 */ "IfNullRow"        OpHelp("if P1.nullRow then r[P3]=NULL, goto P2"),Ù8    /*  24 */ "SeekLT"           OpHelp("key=r[P3@P4]"),Ù8    /*  25 */ "SeekLE"           OpHelp("key=r[P3@P4]"),Ù8    /*  26 */ "SeekGE"           OpHelp("key=r[P3@P4]"),Ù8    /*  27 */ "SeekGT"           OpHelp("key=r[P3@P4]"),Ù8    /*  28 */ "NoConflict"       OpHelp("key=r[P3@P4]"),Ù8    /*  29 */ "NotFound"         OpHelp("key=r[P3@P4]"),Ù8    /*  30 */ "Found"            OpHelp("key=r[P3@P4]"),Ù8    /*  31 */ "SeekRowid"        OpHelp("intkey=r[P3]"),Ù8    /*  32 */ "NotExists"        OpHelp("intkey=r[P3]"),Ù,    /*  33 */ "Last"             OpHelp(""),Ù,    /*  34 */ "IfSmaller"        OpHelp(""),Ù,    /*  35 */ "SorterSort"       OpHelp(""),Ù,    /*  36 */ "Sort"             OpHelp(""),Ù,    /*  37 */ "Rewind"           OpHelp(""),Ù8    /*  38 */ "IdxLE"            OpHelp("key=r[P3@P4]"),Ù8    /*  39 */ "IdxGT"            OpHelp("key=r[P3@P4]"),Ù8    /*  40 */ "IdxLT"            OpHelp("key=r[P3@P4]"),Ù8    /*  41 */ "IdxGE"            OpHelp("key=r[P3@P4]"),Ù<    /*  42 */ "RowSetRead"       OpHelp("r[P3]=rowset(P1)"),ÙB    /*  43 */ "Or"               OpHelp("r[P3]=(r[P1] || r[P2])"),ÙB    /*  44 */ "And"              OpHelp("r[P3]=(r[P1] && r[P2])"),ÙJ    /*  45 */ "RowSetTest"       OpHelp("if r[P3] in rowset(P1) goto P2"),Ù,    /*  46 */ "Program"          OpHelp(""),ÙC    /*  47 */ "FkIfZero"         OpHelp("if fkctr[P1]==0 goto P2"),ÙN    /*  48 */ "IfPos"            OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),ÙM    /*  49 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]--, goto P2"),ÙB    /*  50 */ "IsNull"           OpHelp("if r[P1]==NULL goto P2"),ÙB    /*  51 */ "NotNull"          OpHelp("if r[P1]!=NULL goto P2"),Ù;    /*  52 */ "Ne"               OpHelp("IF r[P3]!=r[P1]"),Ù;    /*  53 */ "Eq"               OpHelp("IF r[P3]==r[P1]"),Ù:    /*  54 */ "Gt"               OpHelp("IF r[P3]>r[P1]"),Ù;    /*  55 */ "Le"               OpHelp("IF r[P3]<=r[P1]"),Ù:    /*  56 */ "Lt"               OpHelp("IF r[P3]<r[P1]"),Ù;    /*  57 */ "Ge"               OpHelp("IF r[P3]>=r[P1]"),Ù,    /*  58 */ "ElseNotEq"        OpHelp(""),ÙC    /*  59 */ "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),Ù,    /*  60 */ "IncrVacuum"       OpHelp(""),Ù,    /*  61 */ "VNext"            OpHelp(""),Ù7    /*  62 */ "Init"             OpHelp("Start at P2"),Ù,    /*  63 */ "Return"           OpHelp(""),Ù,    /*  64 */ "EndCoroutine"     OpHelp(""),Ù>    /*  65 */ "HaltIfNull"       OpHelp("if r[P3]=null halt"),Ù,    /*  66 */ "Halt"             OpHelp(""),Ù4    /*  67 */ "Integer"          OpHelp("r[P2]=P1"),Ù4    /*  68 */ "Int64"            OpHelp("r[P2]=P4"),Ù?    /*  69 */ "String"           OpHelp("r[P2]='P4' (len=P1)"),Ù:    /*  70 */ "Null"             OpHelp("r[P2..P3]=NULL"),Ù6    /*  71 */ "SoftNull"         OpHelp("r[P1]=NULL"),Ù=    /*  72 */ "Blob"             OpHelp("r[P2]=P4 (len=P1)"),ÙB    /*  73 */ "Variable"         OpHelp("r[P2]=parameter(P1,P4)"),Ù=    /*  74 */ "Move"             OpHelp("r[P2@P3]=r[P1@P3]"),ÙA    /*  75 */ "Copy"             OpHelp("r[P2@P3+1]=r[P1@P3+1]"),Ù7    /*  76 */ "SCopy"            OpHelp("r[P2]=r[P1]"),Ù7    /*  77 */ "IntCopy"          OpHelp("r[P2]=r[P1]"),Ù;    /*  78 */ "ResultRow"        OpHelp("output=r[P1@P2]"),Ù,    /*  79 */ "CollSeq"          OpHelp(""),Ù:    /*  80 */ "AddImm"           OpHelp("r[P1]=r[P1]+P2"),Ù,    /*  81 */ "RealAffinity"     OpHelp(""),Ù;    /*  82 */ "Cast"             OpHelp("affinity(r[P1])"),Ù,    /*  83 */ "Permutation"      OpHelp(""),Ù=    /*  84 */ "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),Ù=    /*  85 */ "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),Ù>    /*  86 */ "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),Ù>    /*  87 */ "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),Ù=    /*  88 */ "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),Ù=    /*  89 */ "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),Ù=    /*  90 */ "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),Ù=    /*  91 */ "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),Ù=    /*  92 */ "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),Ù=    /*  93 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),ÙA    /*  94 */ "Compare"          OpHelp("r[P1@P3] <-> r[P2@P3]"),Ù9    /*  95 */ "BitNot"           OpHelp("r[P1]= ~r[P1]"),ÙQ    /*  96 */ "IsTrue"           OpHelp("r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4"),Ù6    /*  97 */ "String8"          OpHelp("r[P2]='P4'"),ÙE    /*  98 */ "Offset"           OpHelp("r[P3] = sqlite_offset(P1)"),Ù4    /*  99 */ "Column"           OpHelp("r[P3]=PX"),Ù>    /* 100 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),ÙA    /* 101 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),Ù9    /* 102 */ "Count"            OpHelp("r[P2]=count()"),Ù,    /* 103 */ "ReadCookie"       OpHelp(""),Ù,    /* 104 */ "SetCookie"        OpHelp(""),Ù:    /* 105 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),Ù:    /* 106 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),Ù:    /* 107 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),Ù,    /* 108 */ "OpenDup"          OpHelp(""),Ù6    /* 109 */ "OpenAutoindex"    OpHelp("nColumn=P2"),Ù6    /* 110 */ "OpenEphemeral"    OpHelp("nColumn=P2"),Ù,    /* 111 */ "SorterOpen"       OpHelp(""),ÙJ    /* 112 */ "SequenceTest"     OpHelp("if( cursor[P1].ctr++ ) pc = P2"),Ù?    /* 113 */ "OpenPseudo"       OpHelp("P3 columns in r[P2]"),Ù,    /* 114 */ "Close"            OpHelp(""),Ù,    /* 115 */ "ColumnsUsed"      OpHelp(""),ÙB    /* 116 */ "Sequence"         OpHelp("r[P2]=cursor[P1].ctr++"),Ù7    /* 117 */ "NewRowid"         OpHelp("r[P2]=rowid"),ÙC    /* 118 */ "Insert"           OpHelp("intkey=r[P3] data=r[P2]"),Ù@    /* 119 */ "InsertInt"        OpHelp("intkey=P3 data=r[P2]"),Ù,    /* 120 */ "Delete"           OpHelp(""),Ù,    /* 121 */ "ResetCount"       OpHelp(""),ÙN    /* 122 */ "SorterCompare"    OpHelp("if key(P1)!=trim(r[P3],P4) goto P2"),Ù6    /* 123 */ "SorterData"       OpHelp("r[P2]=data"),Ù6    /* 124 */ "RowData"          OpHelp("r[P2]=data"),Ù7    /* 125 */ "Rowid"            OpHelp("r[P2]=rowid"),Ù,    /* 126 */ "NullRow"          OpHelp(""),Ù,    /* 127 */ "SeekEnd"          OpHelp(""),Ù5    /* 128 */ "SorterInsert"     OpHelp("key=r[P2]"),Ù5    /* 129 */ "IdxInsert"        OpHelp("key=r[P2]"),Ù8    /* 130 */ "IdxDelete"        OpHelp("key=r[P2@P3]"),ÙI    /* 131 */ "DeferredSeek"     OpHelp("Move P3 to P1.rowid if needed"),Ù4    /* 132 */ "Real"             OpHelp("r[P2]=P4"),Ù7    /* 133 */ "IdxRowid"         OpHelp("r[P2]=rowid"),Ù,    /* 134 */ "Destroy"          OpHelp(""),Ù,    /* 135 */ "Clear"            OpHelp(""),Ù,    /* 136 */ "ResetSorter"      OpHelp(""),ÙF    /* 137 */ "CreateBtree"      OpHelp("r[P2]=root iDb=P1 flags=P3"),Ù,    /* 138 */ "SqlExec"          OpHelp(""),Ù,    /* 139 */ "ParseSchema"      OpHelp(""),Ù,    /* 140 */ "LoadAnalysis"     OpHelp(""),Ù,    /* 141 */ "DropTable"        OpHelp(""),Ù,    /* 142 */ "DropIndex"        OpHelp(""),Ù,    /* 143 */ "DropTrigger"      OpHelp(""),Ù,    /* 144 */ "IntegrityCk"      OpHelp(""),Ù<    /* 145 */ "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),Ù,    /* 146 */ "Param"            OpHelp(""),Ù9    /* 147 */ "FkCounter"        OpHelp("fkctr[P1]+=P2"),ÙB    /* 148 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),Ùd    /* 149 */ "OffsetLimit"      OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),ÙF    /* 150 */ "AggStep0"         OpHelp("accum=r[P3] step(r[P2@P5])"),ÙF    /* 151 */ "AggStep"          OpHelp("accum=r[P3] step(r[P2@P5])"),Ù<    /* 152 */ "AggFinal"         OpHelp("accum=r[P1] N=P2"),Ù,    /* 153 */ "Expire"           OpHelp(""),ÙC    /* 154 */ "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),Ù,    /* 155 */ "VBegin"           OpHelp(""),Ù,    /* 156 */ "VCreate"          OpHelp(""),Ù,    /* 157 */ "VDestroy"         OpHelp(""),Ù,    /* 158 */ "VOpen"            OpHelp(""),Ù=    /* 159 */ "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),Ù,    /* 160 */ "VRename"          OpHelp(""),Ù,    /* 161 */ "Pagecount"        OpHelp(""),Ù,    /* 162 */ "MaxPgcnt"         OpHelp(""),Ù,    /* 163 */ "PureFunc0"        OpHelp(""),Ù@    /* 164 */ "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),Ù,    /* 165 */ "PureFunc"         OpHelp(""),Ù@    /* 166 */ "Function"         OpHelp("r[P3]=func(r[P2@P5])"),Ù,    /* 167 */ "Trace"            OpHelp(""),Ù,    /* 168 */ "CursorHint"       OpHelp(""),Ù,    /* 169 */ "Noop"             OpHelp(""),Ù,    /* 170 */ "Explain"          OpHelp(""),¤  };³  return azName[i];¡}¦#endif ÙO/************** End of opcodes.c *********************************************/ÙO/************** Begin file os_unix.c *****************************************/¢/*®** 2004 May 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙL** This file contains the VFS implementation for unix-like operating systemsÙD** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.¢**ÙI** There are actually several different VFS implementations in this file.ÙI** The differences are in the way that file locking is done.  The defaultÙI** implementation uses Posix Advisory Locks.  Alternative implementationsÙI** use flock(), dot-files, various proprietary locking schemas, or simply½** skip locking all together.¢**ÙK** This source file is organized into divisions where the logic for variousÙE** subfunctions is contained within the appropriate division.  PLEASEÙE** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placedÙ9** in the correct division and should be clearly labeled.¢**Ù)** The layout of divisions is as follows:¢**Ù;**   *  General-purpose declarations and utility functions.Ù-**   *  Unique file ID logic used by VxWorks.ÙM**   *  Various locking primitive implementations (all except proxy locking):Ù"**      + for Posix Advisory Locks¹**      + for no-op locks¼**      + for dot-file locks½**      + for flock() lockingÙ2**      + for named semaphore locks (VxWorks only)Ù0**      + for AFP filesystem locks (MacOSX only)Ù9**   *  sqlite3_file methods not associated with locking.ÙA**   *  Definitions of sqlite3_io_methods objects for all lockingÙ@**      methods plus "finder" functions for each locking method.Ù+**   *  sqlite3_vfs method implementations.ÙK**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)ÙB**   *  Definitions of sqlite3_vfs objects for all locking methodsÙG**      plus implementations of sqlite3_os_init() and sqlite3_os_end().¢*/¼/* #include "sqliteInt.h" */ÙD#if SQLITE_OS_UNIX              /* This file is used on unix only */ ¢/*ÙB** There are various methods for file locking used for concurrency«** control:¢**Ù$**   1. POSIX locking (the default),³**   2. No locking,¹**   3. Dot-file locking,¸**   4. flock() locking,¿**   5. AFP locking (OSX only),Ù.**   6. Named POSIX semaphores (VXWorks only),Ù!**   7. proxy locking. (OSX only)¢**ÙG** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLEÙK** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automaticÙE** selection of the appropriate locking style based on the filesystemÙ#** where the database is located.  ¢*/Ù)#if !defined(SQLITE_ENABLE_LOCKING_STYLE)¸#  if defined(__APPLE__)Ù)#    define SQLITE_ENABLE_LOCKING_STYLE 1§#  elseÙ)#    define SQLITE_ENABLE_LOCKING_STYLE 0¨#  endif¦#endif Ù4/* Use pread() and pwrite() if they are available */¶#if defined(__APPLE__)µ# define HAVE_PREAD 1¶# define HAVE_PWRITE 1¦#endifÙ3#if defined(HAVE_PREAD64) && defined(HAVE_PWRITE64)±# undef USE_PREAD¶# define USE_PREAD64 1Ù1#elif defined(HAVE_PREAD) && defined(HAVE_PWRITE)³# undef USE_PREAD64´# define USE_PREAD 1¦#endif ¢/*º** standard include files.¢*/¶#include <sys/types.h>µ#include <sys/stat.h>²#include <fcntl.h>¶#include <sys/ioctl.h>³#include <unistd.h>·/* #include <time.h> */µ#include <sys/time.h>²#include <errno.h>Ù7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0¶# include <sys/mman.h>¦#endif ¿#if SQLITE_ENABLE_LOCKING_STYLE½/* # include <sys/ioctl.h> */¶# include <sys/file.h>·# include <sys/param.h>Ù(#endif /* SQLITE_ENABLE_LOCKING_STYLE */ ÙH#if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \ÙE                           (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))ÙA#  if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \ÙM       && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))¾#    define HAVE_GETHOSTUUID 1§#  elseÙ)#    warning "gethostuuid() is disabled."¨#  endif¦#endif  ®#if OS_VXWORKS½/* # include <sys/ioctl.h> */·# include <semaphore.h>´# include <limits.h>·#endif /* OS_VXWORKS */ Ù5#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE·# include <sys/mount.h>¦#endif ±#ifdef HAVE_UTIME³# include <utime.h>¦#endif ¢/*Ù%** Allowed values of unixFile.fsFlags¢*/Ù'#define SQLITE_FSFLAGS_IS_MSDOS     0x1 ¢/*ÙF** If we are to be thread-safe, include the pthreads header and defineÙ!** the SQLITE_UNIX_THREADS macro.¢*/µ#if SQLITE_THREADSAFE»/* # include <pthread.h> */¾# define SQLITE_UNIX_THREADS 1¦#endif ¢/*Ù/** Default permissions when creating a new file¢*/Ù'#ifndef SQLITE_DEFAULT_FILE_PERMISSIONSÙ-# define SQLITE_DEFAULT_FILE_PERMISSIONS 0644¦#endif ¢/*Ù3** Default permissions when creating auto proxy dir¢*/Ù+#ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONSÙ1# define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755¦#endif ¢/*Ù!** Maximum supported path-length.¢*/¸#define MAX_PATHNAME 512 ¢/*Ù#** Maximum supported symbolic links¢*/¿#define SQLITE_MAX_SYMLINKS 100 Ù>/* Always cast the getpid() return type for compatibility withÙ ** kernel modules in VxWorks. */Ù##define osGetpid(X) (pid_t)getpid() ¢/*ÙD** Only set the lastErrno if the error code is a real error and not Ù<** a normal expected return code of SQLITE_BUSY or SQLITE_OK¢*/ÙB#define IS_LOCK_ERROR(x)  ((x != SQLITE_OK) && (x != SQLITE_BUSY)) ¸/* Forward references */ÙLtypedef struct unixShm unixShm;               /* Connection shared memory */ÙJtypedef struct unixShmNode unixShmNode;       /* Shared memory instance */Ù=typedef struct unixInodeInfo unixInodeInfo;   /* An i-node */ÙMtypedef struct UnixUnusedFd UnixUnusedFd;     /* An unused file descriptor */ ¢/*ÙJ** Sometimes, after a file handle is closed by SQLite, the file descriptorÙK** cannot be closed immediately. In these cases, instances of the followingÙG** structure are used to store the file descriptor while waiting for anÙ+** opportunity to either close or reuse it.¢*/µstruct UnixUnusedFd {Ù:  int fd;                   /* File descriptor to close */ÙL  int flags;                /* Flags this file descriptor was opened with */ÙJ  UnixUnusedFd *pNext;      /* Next unused file descriptor on same file */¢}; ¢/*ÙJ** The unixFile structure is subclass of sqlite3_file specific to the unix·** VFS implementations.¢*/Ù!typedef struct unixFile unixFile;±struct unixFile {ÙB  sqlite3_io_methods const *pMethod;  /* Always the first entry */ÙN  sqlite3_vfs *pVfs;                  /* The VFS that created this unixFile */ÙJ  unixInodeInfo *pInode;              /* Info about locks on this inode */Ù?  int h;                              /* The file descriptor */ÙL  unsigned char eFileLock;            /* The type of lock held on this fd */ÙN  unsigned short int ctrlFlags;       /* Behavioral bits.  UNIXFILE_* flags */ÙN  int lastErrno;                      /* The unix errno from last I/O error */ÙH  void *lockingContext;               /* Locking style specific state */ÙF  UnixUnusedFd *pPreallocatedUnused;  /* Pre-allocated UnixUnusedFd */Ù<  const char *zPath;                  /* Name of the file */ÙM  unixShm *pShm;                      /* Shared memory segment information */ÙJ  int szChunk;                        /* Configured by FCNTL_CHUNK_SIZE */º#if SQLITE_MAX_MMAP_SIZE>0ÙM  int nFetchOut;                      /* Number of outstanding xFetch refs */ÙP  sqlite3_int64 mmapSize;             /* Usable size of mapping at pMapRegion */ÙP  sqlite3_int64 mmapSizeActual;       /* Actual size of mapping at pMapRegion */ÙL  sqlite3_int64 mmapSizeMax;          /* Configured FCNTL_MMAP_SIZE value */Ù@  void *pMapRegion;                   /* Memory mapped region */¦#endifÙ>  int sectorSize;                     /* Device sector size */ÙN  int deviceCharacteristics;          /* Precomputed device characteristics */¿#if SQLITE_ENABLE_LOCKING_STYLEÙI  int openFlags;                      /* The flags specified at open() */¦#endifÙ5#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)ÙH  unsigned fsFlags;                   /* cached details from statfs() */¦#endifÙ"#ifdef SQLITE_ENABLE_SETLK_TIMEOUTÙL  unsigned iBusyTimeout;              /* Wait this many millisec on locks */¦#endif®#if OS_VXWORKSÙ:  struct vxworksFileId *pId;          /* Unique file ID */¦#endif³#ifdef SQLITE_DEBUGÙE  /* The next group of variables are used to track whether or not theÙE  ** transaction counter in bytes 24-27 of database files are updatedÙH  ** whenever any part of the database changes.  An assertion fault willÙE  ** occur if a file is updated without also updating the transactionÙE  ** counter.  This test is made to avoid new problems similar to theÙ$  ** one described by ticket #3584. ¤  */ÙN  unsigned char transCntrChng;   /* True if the transaction counter changed */ÙP  unsigned char dbUpdate;        /* True if any part of database file changed */ÙJ  unsigned char inNormalWrite;   /* True if in a normal write operation */ ¦#endif ²#ifdef SQLITE_TESTÙE  /* In test mode, increase the size of this structure a bit so that Ù?  ** it is larger than the struct CrashFile defined in test6.c.¤  */´  char aPadding[32];¦#endif¢}; ÙG/* This variable holds the process id (pid) from when the xRandomness()ÙH** method was called.  If xOpen() is called from a different process id,ÙA** indicating that a fork() has occurred, the PRNG will be reset.¢*/¿static pid_t randomnessPid = 0; ¢/*Ù5** Allowed values for the unixFile.ctrlFlags bitmask:¢*/ÙM#define UNIXFILE_EXCL        0x01     /* Connections from one process only */ÙC#define UNIXFILE_RDONLY      0x02     /* Connection is read only */Ù?#define UNIXFILE_PERSIST_WAL 0x04     /* Persistent WAL mode */¾#ifndef SQLITE_DISABLE_DIRSYNCÙA# define UNIXFILE_DIRSYNC    0x08     /* Directory sync needed */¥#elseÙ!# define UNIXFILE_DIRSYNC    0x00¦#endifÙL#define UNIXFILE_PSOW        0x10     /* SQLITE_IOCAP_POWERSAFE_OVERWRITE */Ù;#define UNIXFILE_DELETE      0x20     /* Delete on close */ÙP#define UNIXFILE_URI         0x40     /* Filename might have query parameters */Ù>#define UNIXFILE_NOLOCK      0x80     /* Do no file locking */ ¢/*Ù2** Include code that is common to all os_*.c files¢*/ÙO/************** Include os_common.h in the middle of os_unix.c ***************/ÙO/************** Begin file os_common.h ***************************************/¢/*®** 2004 May 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙG** This file contains macros and a little bit of code that is common toÙJ** all of the platform-specific files (os_*.c) and is #included into those©** files.¢**ÙG** This file should be #included by the os_*.c files only.  It is not a¿** general purpose header file.¢*/µ#ifndef _OS_COMMON_H_µ#define _OS_COMMON_H_ ¢/*ÙH** At least two bugs have slipped in because we changed the MEMORY_DEBUGÙG** macro to SQLITE_DEBUG and some older makefiles have not yet made theÙI** switch.  The following code should catch this problem at compile-time.¢*/³#ifdef MEMORY_DEBUGÙH# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."¦#endif ¢/*ÙD** Macros for performance tracing.  Normally turned off.  Only works´** on i486 hardware.¢*/¿#ifdef SQLITE_PERFORMANCE_TRACE ¢/*Ù;** hwtime.h contains inline assembler code for implementingÙ$** high-performance timing routines.¢*/ÙO/************** Include hwtime.h in the middle of os_common.h ****************/ÙO/************** Begin file hwtime.h ******************************************/¢/*®** 2008 May 27¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙG** This file contains inline asm code for retrieving "high-performance"¿** counters for x86 class CPUs.¢*/·#ifndef SQLITE_HWTIME_H·#define SQLITE_HWTIME_H ¢/*ÙK** The following routine only works on pentium-class (or newer) processors.ÙD** It uses the RDTSC opcode to read the cycle count value out of theÙC** processor and returns that value.  This can be used for high-res­** profiling.¢*/Ù1#if (defined(__GNUC__) || defined(_MSC_VER)) && \Ù>      (defined(i386) || defined(__i386__) || defined(_M_IX86)) ·  #if defined(__GNUC__) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){¹     unsigned int lo, hi;Ù;     __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));Ù)     return (sqlite_uint64)hi << 32 | lo;£  } ¹  #elif defined(_MSC_VER) ÙG  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){¬     __asm {­        rdtscÙ+        ret       ; return value at EDX:EAX¦     }£  } ¨  #endif Ù0#elif (defined(__GNUC__) && defined(__x86_64__)) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){¸      unsigned long val;Ù2      __asm__ __volatile__ ("rdtsc" : "=A" (val));±      return val;£  }¡ Ù-#elif (defined(__GNUC__) && defined(__ppc__)) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){Ù       unsigned long long retval;¹      unsigned long junk;Ù       __asm__ __volatile__ ("\n\¿          1:      mftbu   %1\n\Ù                   mftb    %L0\n\¿                  mftbu   %0\n\Ù"                  cmpw    %0,%1\n\½                  bne     1b"Ù0                  : "=r" (retval), "=r" (junk));´      return retval;£  } ¥#else ÙB  #error Need implementation of sqlite3Hwtime() for your platform. ¤  /*ÙG  ** To compile without implementing sqlite3Hwtime() for your platform,Ù:  ** you can remove the above #error and use the followingÙ:  ** stub function.  You will lose timing support for manyÙ=  ** of the debugging and testing utilities, but it should at»  ** least compile and run.¤  */ÙPSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } ¦#endif Ù&#endif /* !defined(SQLITE_HWTIME_H) */ ÙO/************** End of hwtime.h **********************************************/ÙO/************** Continuing where we left off in os_common.h ******************/ ½static sqlite_uint64 g_start;¿static sqlite_uint64 g_elapsed;Ù1#define TIMER_START       g_start=sqlite3Hwtime()Ù;#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_startÙ##define TIMER_ELAPSED     g_elapsed¥#else³#define TIMER_START±#define TIMER_ENDÙ,#define TIMER_ELAPSED     ((sqlite_uint64)0)¦#endif ¢/*ÙI** If we compile with the SQLITE_TEST macro set, then the following blockÙG** of code will give us the ability to simulate a disk I/O error.  ThisÙ.** is used for testing the I/O recovery logic.¢*/¸#if defined(SQLITE_TEST)Ù+SQLITE_API extern int sqlite3_io_error_hit;Ù/SQLITE_API extern int sqlite3_io_error_hardhit;Ù/SQLITE_API extern int sqlite3_io_error_pending;Ù/SQLITE_API extern int sqlite3_io_error_persist;Ù.SQLITE_API extern int sqlite3_io_error_benign;Ù/SQLITE_API extern int sqlite3_diskfull_pending;Ù'SQLITE_API extern int sqlite3_diskfull;Ù<#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)Ù #define SimulateIOError(CODE)  \Ù:  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \Ù.       || sqlite3_io_error_pending-- == 1 )  \Ù&              { local_ioerr(); CODE; }ºstatic void local_ioerr(){·  IOTRACE(("IOERR\n"));¹  sqlite3_io_error_hit++;Ù<  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;¡}Ù%#define SimulateDiskfullError(CODE) \Ù$   if( sqlite3_diskfull_pending ){ \Ù+     if( sqlite3_diskfull_pending == 1 ){ \·       local_ioerr(); \¾       sqlite3_diskfull = 1; \Ù"       sqlite3_io_error_hit = 1; \®       CODE; \­     }else{ \Ù$       sqlite3_diskfull_pending--; \¨     } \¤   }¥#elseÙ #define SimulateIOErrorBenign(X)º#define SimulateIOError(A)Ù #define SimulateDiskfullError(A)Ù!#endif /* defined(SQLITE_TEST) */ ¢/*Ù:** When testing, keep a count of the number of open files.¢*/¸#if defined(SQLITE_TEST)Ù.SQLITE_API extern int sqlite3_open_file_count;Ù4#define OpenCounter(X)  sqlite3_open_file_count+=(X)¥#else¶#define OpenCounter(X)Ù!#endif /* defined(SQLITE_TEST) */ Ù$#endif /* !defined(_OS_COMMON_H_) */ ÙO/************** End of os_common.h *******************************************/ÙO/************** Continuing where we left off in os_unix.c ********************/ ¢/*Ù<** Define various macros that are missing from some systems.¢*/³#ifndef O_LARGEFILE¶# define O_LARGEFILE 0¦#endif¹#ifdef SQLITE_DISABLE_LFS³# undef O_LARGEFILE¶# define O_LARGEFILE 0¦#endif²#ifndef O_NOFOLLOWµ# define O_NOFOLLOW 0¦#endif°#ifndef O_BINARY³# define O_BINARY 0¦#endif ¢/*ÙB** The threadid macro resolves to the thread-id or to 0.  Used for¾** testing and debugging only.¢*/µ#if SQLITE_THREADSAFE¿#define threadid pthread_self()¥#else²#define threadid 0¦#endif ¢/*ÙC** HAVE_MREMAP defaults to true on Linux and false everywhere else.¢*/¹#if !defined(HAVE_MREMAP)Ù/# if defined(__linux__) && defined(_GNU_SOURCE)·#  define HAVE_MREMAP 1¦# else·#  define HAVE_MREMAP 0§# endif¦#endif ¢/*ÙO** Explicitly call the 64-bit version of lseek() on Android. Otherwise, lseek()ÙB** is the 32-bit version, even if _FILE_OFFSET_BITS=64 is defined.¢*/²#ifdef __ANDROID__¶# define lseek lseek64¦#endif °#ifdef __linux__¢/*Ù?** Linux-specific IOCTL magic numbers used for controlling F2FS¢*/Ù$#define F2FS_IOCTL_MAGIC        0xf5Ù@#define F2FS_IOC_START_ATOMIC_WRITE     _IO(F2FS_IOCTL_MAGIC, 1)Ù@#define F2FS_IOC_COMMIT_ATOMIC_WRITE    _IO(F2FS_IOCTL_MAGIC, 2)Ù@#define F2FS_IOC_START_VOLATILE_WRITE   _IO(F2FS_IOCTL_MAGIC, 3)Ù@#define F2FS_IOC_ABORT_VOLATILE_WRITE   _IO(F2FS_IOCTL_MAGIC, 5)ÙG#define F2FS_IOC_GET_FEATURES           _IOR(F2FS_IOCTL_MAGIC, 12, u32)Ù(#define F2FS_FEATURE_ATOMIC_WRITE 0x0004¶#endif /* __linux__ */  ¢/*ÙE** Different Unix systems declare open() in different ways.  Same useÙG** open(const char*,int,mode_t).  Others use open(const char*,int,...).ÙD** The difference is important when using a pointer to the function.¢**ÙH** The safest way to deal with the problem is to always use this wrapperÙ4** which always has the same well-defined interface.¢*/Ù=static int posixOpen(const char *zFile, int flags, int mode){Ù"  return open(zFile, flags, mode);¡} ·/* Forward reference */Ù,static int openDirectory(const char*, int*);Ù!static int unixGetpagesize(void); ¢/*ÙF** Many system calls are accessed through pointer-to-functions so thatÙI** they may be overridden at runtime to facilitate fault injection duringÙL** testing and sandboxing.  The following array holds the names and pointersÙ$** to all overrideable system calls.¢*/¼static struct unix_syscall {Ù=  const char *zName;            /* Name of the system call */ÙF  sqlite3_syscall_ptr pCurrent; /* Current value of the system call */Ù3  sqlite3_syscall_ptr pDefault; /* Default value */°} aSyscall[] = {Ù:  { "open",         (sqlite3_syscall_ptr)posixOpen,  0  },ÙG#define osOpen      ((int(*)(const char*,int,int))aSyscall[0].pCurrent) Ù:  { "close",        (sqlite3_syscall_ptr)close,      0  },Ù7#define osClose     ((int(*)(int))aSyscall[1].pCurrent) Ù:  { "access",       (sqlite3_syscall_ptr)access,     0  },ÙC#define osAccess    ((int(*)(const char*,int))aSyscall[2].pCurrent) Ù:  { "getcwd",       (sqlite3_syscall_ptr)getcwd,     0  },ÙB#define osGetcwd    ((char*(*)(char*,size_t))aSyscall[3].pCurrent) Ù:  { "stat",         (sqlite3_syscall_ptr)stat,       0  },ÙL#define osStat      ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent) ¢/*Ù@** The DJGPP compiler environment looks mostly like Unix, but itÙF** lacks the fcntl() system call.  So redefine fcntl() to be somethingÙF** that always succeeds.  This means that locking does not occur underÙ/** DJGPP.  But it is DOS - what did you expect?¢*/°#ifdef __DJGPP__Ù,  { "fstat",        0,                 0  },»#define osFstat(a,b,c)    0ª#else     Ù:  { "fstat",        (sqlite3_syscall_ptr)fstat,      0  },ÙD#define osFstat     ((int(*)(int,struct stat*))aSyscall[5].pCurrent)¦#endif Ù:  { "ftruncate",    (sqlite3_syscall_ptr)ftruncate,  0  },Ù=#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent) Ù:  { "fcntl",        (sqlite3_syscall_ptr)fcntl,      0  },Ù?#define osFcntl     ((int(*)(int,int,...))aSyscall[7].pCurrent) Ù:  { "read",         (sqlite3_syscall_ptr)read,       0  },ÙH#define osRead      ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent) Ù5#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLEÙ:  { "pread",        (sqlite3_syscall_ptr)pread,      0  },¥#elseÙ:  { "pread",        (sqlite3_syscall_ptr)0,          0  },¦#endifÙN#define osPread     ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent) ¸#if defined(USE_PREAD64)Ù:  { "pread64",      (sqlite3_syscall_ptr)pread64,    0  },¥#elseÙ:  { "pread64",      (sqlite3_syscall_ptr)0,          0  },¦#endifÙO#define osPread64 ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent) Ù:  { "write",        (sqlite3_syscall_ptr)write,      0  },ÙO#define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent) Ù5#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLEÙ:  { "pwrite",       (sqlite3_syscall_ptr)pwrite,     0  },¥#elseÙ:  { "pwrite",       (sqlite3_syscall_ptr)0,          0  },¦#endifÙ@#define osPwrite    ((ssize_t(*)(int,const void*,size_t,off_t))\Ù*                    aSyscall[12].pCurrent) ¸#if defined(USE_PREAD64)Ù:  { "pwrite64",     (sqlite3_syscall_ptr)pwrite64,   0  },¥#elseÙ:  { "pwrite64",     (sqlite3_syscall_ptr)0,          0  },¦#endifÙB#define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off64_t))\Ù*                    aSyscall[13].pCurrent) Ù?  { "fchmod",       (sqlite3_syscall_ptr)fchmod,          0  },Ù?#define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent) Ù9#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATEÙ?  { "fallocate",    (sqlite3_syscall_ptr)posix_fallocate,  0 },¥#elseÙ?  { "fallocate",    (sqlite3_syscall_ptr)0,                0 },¦#endifÙD#define osFallocate ((int(*)(int,off_t,off_t))aSyscall[15].pCurrent) Ù?  { "unlink",       (sqlite3_syscall_ptr)unlink,           0 },Ù@#define osUnlink    ((int(*)(const char*))aSyscall[16].pCurrent) ÙE  { "openDirectory",    (sqlite3_syscall_ptr)openDirectory,      0 },ÙI#define osOpenDirectory ((int(*)(const char*,int*))aSyscall[17].pCurrent) Ù>  { "mkdir",        (sqlite3_syscall_ptr)mkdir,           0 },ÙG#define osMkdir     ((int(*)(const char*,mode_t))aSyscall[18].pCurrent) Ù>  { "rmdir",        (sqlite3_syscall_ptr)rmdir,           0 },Ù@#define osRmdir     ((int(*)(const char*))aSyscall[19].pCurrent) ¸#if defined(HAVE_FCHOWN)Ù>  { "fchown",       (sqlite3_syscall_ptr)fchown,          0 },¥#elseÙ>  { "fchown",       (sqlite3_syscall_ptr)0,               0 },¦#endifÙD#define osFchown    ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent) ¸#if defined(HAVE_FCHOWN)Ù>  { "geteuid",      (sqlite3_syscall_ptr)geteuid,         0 },¥#elseÙ>  { "geteuid",      (sqlite3_syscall_ptr)0,               0 },¦#endifÙ;#define osGeteuid   ((uid_t(*)(void))aSyscall[21].pCurrent) Ù7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0Ù>  { "mmap",         (sqlite3_syscall_ptr)mmap,            0 },¥#elseÙ>  { "mmap",         (sqlite3_syscall_ptr)0,               0 },¦#endifÙP#define osMmap ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent) Ù7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0Ù>  { "munmap",       (sqlite3_syscall_ptr)munmap,          0 },¥#elseÙ>  { "munmap",       (sqlite3_syscall_ptr)0,               0 },¦#endifÙ>#define osMunmap ((int(*)(void*,size_t))aSyscall[23].pCurrent) ÙH#if HAVE_MREMAP && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)Ù>  { "mremap",       (sqlite3_syscall_ptr)mremap,          0 },¥#elseÙ>  { "mremap",       (sqlite3_syscall_ptr)0,               0 },¦#endifÙO#define osMremap ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent) Ù7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0Ù>  { "getpagesize",  (sqlite3_syscall_ptr)unixGetpagesize, 0 },¥#elseÙ>  { "getpagesize",  (sqlite3_syscall_ptr)0,               0 },¦#endifÙ;#define osGetpagesize ((int(*)(void))aSyscall[25].pCurrent) º#if defined(HAVE_READLINK)Ù>  { "readlink",     (sqlite3_syscall_ptr)readlink,        0 },¥#elseÙ>  { "readlink",     (sqlite3_syscall_ptr)0,               0 },¦#endifÙP#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent) ·#if defined(HAVE_LSTAT)Ù>  { "lstat",         (sqlite3_syscall_ptr)lstat,          0 },¥#elseÙ>  { "lstat",         (sqlite3_syscall_ptr)0,              0 },¦#endifÙN#define osLstat      ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent) ÙC#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ù>  { "ioctl",         (sqlite3_syscall_ptr)ioctl,          0 },¥#elseÙ>  { "ioctl",         (sqlite3_syscall_ptr)0,              0 },¦#endifÙ<#define osIoctl ((int(*)(int,int,...))aSyscall[28].pCurrent) Ù-}; /* End of the overrideable system calls */  ¢/*ÙJ** On some systems, calls to fchown() will trigger a message in a securityÙJ** log if they come from non-root processes.  So avoid calling fchown() if¾** we are not running as root.¢*/Ù6static int robustFchown(int fd, uid_t uid, gid_t gid){¸#if defined(HAVE_FCHOWN)Ù0  return osGeteuid() ? 0 : osFchown(fd,uid,gid);¥#else«  return 0;¦#endif¡} ¢/*ÙD** This is the xSetSystemCall() method of sqlite3_vfs for all of theÙA** "unix" VFSes.  Return SQLITE_OK opon successfully updating theÙF** system call pointer, or SQLITE_NOTFOUND if there is no configurable»** system call named zName.¢*/½static int unixSetSystemCall(Ù@  sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */ÙE  const char *zName,            /* Name of system call to override */ÙF  sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */¢){±  unsigned int i;»  int rc = SQLITE_NOTFOUND; ½  UNUSED_PARAMETER(pNotUsed);±  if( zName==0 ){ÙF    /* If no zName is given, restore all system calls to their default¿    ** settings and return NULL¦    */³    rc = SQLITE_OK;Ù:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ù!      if( aSyscall[i].pDefault ){Ù4        aSyscall[i].pCurrent = aSyscall[i].pDefault;§      }¥    }¨  }else{ÙA    /* If zName is specified, operate on only the one system call±    ** specified.¦    */Ù:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ù0      if( strcmp(zName, aSyscall[i].zName)==0 ){Ù&        if( aSyscall[i].pDefault==0 ){Ù6          aSyscall[i].pDefault = aSyscall[i].pCurrent;©        }·        rc = SQLITE_OK;Ù:        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;Ù(        aSyscall[i].pCurrent = pNewFunc;®        break;§      }¥    }£  }¬  return rc;¡} ¢/*ÙD** Return the value of a system call.  Return NULL if zName is not aÙI** recognized system call name.  NULL is also returned if the system callº** is currently undefined.¢*/Ù-static sqlite3_syscall_ptr unixGetSystemCall(¸  sqlite3_vfs *pNotUsed,³  const char *zName¢){±  unsigned int i; ½  UNUSED_PARAMETER(pNotUsed);Ù8  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){ÙJ    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;£  }«  return 0;¡} ¢/*ÙH** Return the name of the first system call after zName.  If zName==NULLÙG** then return the name of the first system call.  Return NULL if zNameÙA** is the last system call or if zName is not the name of a valid¯** system call.¢*/ÙIstatic const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){­  int i = -1; ¶  UNUSED_PARAMETER(p);®  if( zName ){Ù+    for(i=0; i<ArraySize(aSyscall)-1; i++){Ù6      if( strcmp(zName, aSyscall[i].zName)==0 ) break;¥    }£  }Ù'  for(i++; i<ArraySize(aSyscall); i++){Ù;    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;£  }«  return 0;¡} ¢/*ÙL** Do not accept any file descriptor less than this value, in order to avoidÙK** opening database file using file descriptors that are commonly used for Ù%** standard input, output, and error.¢*/Ù&#ifndef SQLITE_MINIMUM_FILE_DESCRIPTORÙ)# define SQLITE_MINIMUM_FILE_DESCRIPTOR 3¦#endif ¢/*ÙD** Invoke open().  Do so multiple times, until it either succeeds orÙ*** fails for some reason other than EINTR.¢**ÙD** If the file creation mode "m" is 0 then set it to the default forÙD** SQLite.  The default is SQLITE_DEFAULT_FILE_PERMISSIONS (normallyÙ>** 0644) as modified by the system umask.  If m is not 0, thenÙ?** make the file creation mode be exactly m ignoring the umask.¢**ÙF** The m parameter will be non-zero only when creating -wal, -journal,ÙB** and -shm files.  We want those files to have *exactly* the sameÙF** permissions as their original database, unadulterated by the umask.ÙC** In that way, if a database file is -rw-rw-rw or -rw-rw-r-, and aÙ?** transaction crashes and leaves behind hot journals, then anyÙE** process that is able to write to the database will also be able to¼** recover the hot journals.¢*/Ù7static int robust_open(const char *z, int f, mode_t m){©  int fd;Ù6  mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;«  while(1){¶#if defined(O_CLOEXEC)Ù"    fd = osOpen(z,f|O_CLOEXEC,m2);¥#else¸    fd = osOpen(z,f,m2);¦#endif¯    if( fd<0 ){Ù"      if( errno==EINTR ) continue;¬      break;¥    }Ù3    if( fd>=SQLITE_MINIMUM_FILE_DESCRIPTOR ) break;°    osClose(fd);Ù     sqlite3_log(SQLITE_WARNING, ÙG                "attempt to open \"%s\" as file descriptor %d", z, fd);¬    fd = -1;Ù,    if( osOpen("/dev/null", f, m)<0 ) break;£  }®  if( fd>=0 ){¯    if( m!=0 ){º      struct stat statbuf;Ù#      if( osFstat(fd, &statbuf)==0 ¼       && statbuf.st_size==0Ù$       && (statbuf.st_mode&0777)!=m ¨      ){¸        osFchmod(fd, m);§      }¥    }Ù@#if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)Ù?    osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);¦#endif£  }¬  return fd;¡} ¢/*ÙB** Helper functions to obtain and relinquish the global mutex. TheÙ8** global mutex is used to protect the unixInodeInfo andÙ@** vxworksFileId objects used by this file, all of which may be ¾** shared by multiple threads.¢**ÙF** Function unixMutexHeld() is used to assert() that the global mutex ÙI** is held when required. This function is only used as part of assert() ³** statements. e.g.¢**µ**   unixEnterMutex()Ù!**     assert( unixMutexHeld() );µ**   unixEnterLeave()¢*/Ù&static sqlite3_mutex *unixBigLock = 0;Ù!static void unixEnterMutex(void){Ù#  sqlite3_mutex_enter(unixBigLock);¡}Ù!static void unixLeaveMutex(void){Ù#  sqlite3_mutex_leave(unixBigLock);¡}³#ifdef SQLITE_DEBUGÙ static int unixMutexHeld(void) {Ù)  return sqlite3_mutex_held(unixBigLock);¡}¦#endif  »#ifdef SQLITE_HAVE_OS_TRACE¢/*ÙD** Helper function for printing out trace information from debuggingÙC** binaries. This returns the string representation of the suppliedµ** integer lock-type.¢*/Ù-static const char *azFileLock(int eFileLock){¶  switch( eFileLock ){Ù     case NO_LOCK: return "NONE";Ù&    case SHARED_LOCK: return "SHARED";Ù*    case RESERVED_LOCK: return "RESERVED";Ù(    case PENDING_LOCK: return "PENDING";Ù,    case EXCLUSIVE_LOCK: return "EXCLUSIVE";£  }±  return "ERROR";¡}¦#endif ¸#ifdef SQLITE_LOCK_TRACE¢/*Ù6** Print out information about all locking operations.¢**ÙB** This routine is used for troubleshooting locks on multithreadedÙ?** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACEÙ>** command-line option on the compiler.  This code is normally®** turned off.¢*/Ù6static int lockTrace(int fd, int op, struct flock *p){¸  char *zOpName, *zType;¨  int s;±  int savedErrno;´  if( op==F_GETLK ){¶    zOpName = "GETLK";º  }else if( op==F_SETLK ){¶    zOpName = "SETLK";¨  }else{»    s = osFcntl(fd, op, p);Ù>    sqlite3DebugPrintf("fcntl unknown %d %d %d\n", fd, op, s);­    return s;£  }»  if( p->l_type==F_RDLCK ){´    zType = "RDLCK";Ù!  }else if( p->l_type==F_WRLCK ){´    zType = "WRLCK";Ù!  }else if( p->l_type==F_UNLCK ){´    zType = "UNLCK";¨  }else{°    assert( 0 );£  }Ù"  assert( p->l_whence==SEEK_SET );¹  s = osFcntl(fd, op, p);µ  savedErrno = errno;Ù7  sqlite3DebugPrintf("fcntl %d %d %s %s %d %d %d %d\n",ÙB     threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,·     (int)p->l_pid, s);ÙM  if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){´    struct flock l2;¬    l2 = *p;¾    osFcntl(fd, F_GETLK, &l2);½    if( l2.l_type==F_RDLCK ){¶      zType = "RDLCK";Ù#    }else if( l2.l_type==F_WRLCK ){¶      zType = "WRLCK";Ù#    }else if( l2.l_type==F_UNLCK ){¶      zType = "UNLCK";ª    }else{²      assert( 0 );¥    }Ù=    sqlite3DebugPrintf("fcntl-failure-reason: %s %d %d %d\n",Ù=       zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);£  }µ  errno = savedErrno;«  return s;¡}®#undef osFcntl¹#define osFcntl lockTrace¾#endif /* SQLITE_LOCK_TRACE */ ¢/*Ù1** Retry ftruncate() calls that fail due to EINTR¢**ÙC** All calls to ftruncate() within this file should be made throughÙD** this wrapper.  On the Android platform, bypassing the logic belowÙ$** could lead to a corrupt database.¢*/Ù5static int robust_ftruncate(int h, sqlite3_int64 sz){©  int rc;²#ifdef __ANDROID__ÙA  /* On Android, ftruncate() always uses 32-bit offsets, even if ÙK  ** _FILE_OFFSET_BITS=64 is defined. This means it is unsafe to attempt toÙF  ** truncate a file to any size larger than 2GiB. Silently ignore any·  ** such attempts.  */Ù%  if( sz>(sqlite3_int64)0x7FFFFFFF ){³    rc = SQLITE_OK;§  }else¦#endifÙ=  do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );¬  return rc;¡} ¢/*ÙE** This routine translates a standard POSIX errno code into somethingÙG** useful to the clients of the sqlite3 functions.  Specifically, it isÙI** intended to translate a variety of "try again" errors into SQLITE_BUSYÙG** and a variety of "please close the file descriptor NOW" errors into ¯** SQLITE_IOERR£** ÙK** Errors during initialization of locks, or file system support for locks,Ù8** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.¢*/ÙGstatic int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {Ù0  assert( (sqliteIOErr == SQLITE_IOERR_LOCK) || Ù2          (sqliteIOErr == SQLITE_IOERR_UNLOCK) || Ù1          (sqliteIOErr == SQLITE_IOERR_RDLOCK) ||Ù<          (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) );·  switch (posixError) {¯  case EACCES: ®  case EAGAIN:±  case ETIMEDOUT:­  case EBUSY:­  case EINTR:°  case ENOLCK:  ÙA    /* random NFS retry error, unless during file system support Ù@     * introspection, in which it actually means what it says */·    return SQLITE_BUSY;¤    ®  case EPERM: ·    return SQLITE_PERM;¤    «  default: ·    return sqliteIOErr;£  }¡}  ÙO/******************************************************************************ÙO****************** Begin Unique File ID Utility Used By VxWorks ***************¢**ÙO** On most versions of unix, we can get a unique ID for a file by concatenatingÙN** the device number and the inode number.  But this does not work on VxWorks.ÙH** On VxWorks, a unique file id must be based on the canonical filename.¢**ÙG** A pointer to an instance of the following structure can be used as aÙG** unique file ID in VxWorks.  Each instance of this structure containsÙH** a copy of the canonical filename.  There is also a reference count.  ÙH** The structure is reclaimed when the number of pointers to it drops to¨** zero.¢**ÙG** There are never very many files open at one time and lookups are notÙ@** a performance-critical path, so it is sufficient to put these¿** structures on a linked list.¢*/¶struct vxworksFileId {Ù@  struct vxworksFileId *pNext;  /* Next in a list of them all */ÙF  int nRef;                     /* Number of references to this one */ÙK  int nName;                    /* Length of the zCanonicalName[] string */Ù8  char *zCanonicalName;         /* Canonical filename */¢}; ®#if OS_VXWORKS£/* Ù@** All unique filenames are held on a linked list headed by this¬** variable:¢*/Ù1static struct vxworksFileId *vxworksFileList = 0; ¢/*Ù.** Simplify a filename into its canonical formÙ#** by making the following changes:¢**Ù+**  * removing any trailing and duplicate /½**  * convert /./ into just /Ù;**  * convert /A/../ where A is any simple name into just /¢**Ù:** Changes are made in-place.  Return the new name length.¢**Ù?** The original filename is in z[0..n-1].  Return the number ofÙ%** characters in the simplified name.¢*/Ù/static int vxworksSimplifyName(char *z, int n){«  int i, j;Ù%  while( n>1 && z[n-1]=='/' ){ n--; }·  for(i=j=0; i<n; i++){´    if( z[i]=='/' ){Ù!      if( z[i+1]=='/' ) continue;Ù0      if( z[i+1]=='.' && i+2<n && z[i+2]=='/' ){¯        i += 1;±        continue;§      }Ù?      if( z[i+1]=='.' && i+3<n && z[i+2]=='.' && z[i+3]=='/' ){Ù+        while( j>0 && z[j-1]!='/' ){ j--; }¹        if( j>0 ){ j--; }¯        i += 2;±        continue;§      }¥    }²    z[j++] = z[i];£  }«  z[j] = 0;«  return j;¡} ¢/*ÙA** Find a unique file ID for the given absolute pathname.  ReturnÙE** a pointer to the vxworksFileId object.  This pointer is the unique«** file ID.¢**ÙC** The nRef field of the vxworksFileId object is incremented beforeÙA** the object is returned.  A new vxworksFileId object is createdÙ-** and added to the global list if necessary.¢**Ù4** If a memory allocation error occurs, return NULL.¢*/ÙJstatic struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){ÙF  struct vxworksFileId *pNew;         /* search key and new file ID */ÙN  struct vxworksFileId *pCandidate;   /* For looping over existing file IDs */ÙJ  int n;                              /* Length of zAbsoluteName string */ Ù"  assert( zAbsoluteName[0]=='/' );Ù!  n = (int)strlen(zAbsoluteName);Ù3  pNew = sqlite3_malloc64( sizeof(*pNew) + (n+1) );¹  if( pNew==0 ) return 0;Ù)  pNew->zCanonicalName = (char*)&pNew[1];Ù3  memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);Ù3  n = vxworksSimplifyName(pNew->zCanonicalName, n); ÙC  /* Search for an existing entry that matching the canonical name.ÙD  ** If found, increment the reference count and return a pointer toº  ** the existing file ID.¤  */³  unixEnterMutex();ÙL  for(pCandidate=vxworksFileList; pCandidate; pCandidate=pCandidate->pNext){½    if( pCandidate->nName==n ÙF     && memcmp(pCandidate->zCanonicalName, pNew->zCanonicalName, n)==0¦    ){º       sqlite3_free(pNew);º       pCandidate->nRef++;¸       unixLeaveMutex();¹       return pCandidate;¥    }£  } Ù7  /* No match was found.  We will make a new file ID */±  pNew->nRef = 1;²  pNew->nName = n;Ù   pNew->pNext = vxworksFileList;¹  vxworksFileList = pNew;³  unixLeaveMutex();®  return pNew;¡} ¢/*ÙA** Decrement the reference count on a vxworksFileId object.  FreeÙ4** the object when the reference count reaches zero.¢*/Ù<static void vxworksReleaseFileId(struct vxworksFileId *pId){³  unixEnterMutex();¸  assert( pId->nRef>0 );®  pId->nRef--;µ  if( pId->nRef==0 ){¾    struct vxworksFileId **pp;ÙE    for(pp=&vxworksFileList; *pp && *pp!=pId; pp = &((*pp)->pNext)){}·    assert( *pp==pId );µ    *pp = pId->pNext;¶    sqlite3_free(pId);£  }³  unixLeaveMutex();¡}·#endif /* OS_VXWORKS */ÙO/*************** End of Unique File ID Utility Used By VxWorks ****************ÙO******************************************************************************/  ÙO/******************************************************************************ÙO*************************** Posix Advisory Locking ****************************¢**ÙE** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)ÙD** section 6.5.2.2 lines 483 through 490 specify that when a processÙF** sets or clears a lock, that operation overrides any prior locks setÙH** by the same process.  It does not explicitly say so, but this impliesÙD** that it overrides locks set by the same process using a differentÙ-** file descriptor.  Consider this test case:¢**Ù9**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);Ù9**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);¢**Ù@** Suppose ./file1 and ./file2 are really the same file (becauseÙ?** one is a hard or symbolic link to the other) then if you setÙ>** an exclusive lock on fd1, then try to get an exclusive lockÙ>** on fd2, it works.  I would have expected the second lock toÙ>** fail since there was already a lock on the file due to fd1.Ù@** But not so.  Since both locks came from the same process, theÙA** second overrides the first, even though they were on differentÙ3** file descriptors opened on different file names.¢**ÙG** This means that we cannot use POSIX locks to synchronize file accessÙK** among competing threads of the same process.  POSIX locks will work fineÙC** to synchronize access for threads in separate processes, but notÙ#** threads within the same process.¢**ÙI** To work around the problem, SQLite has to manage file locks internallyÙF** on its own.  Whenever a new database is opened, we have to find theÙF** specific inode of the database file (the inode is determined by theÙH** st_dev and st_ino fields of the stat structure that fstat() fills in)ÙF** and check for locks already existing on that inode.  When locks areÙH** created or removed, we have to look at our own internal record of theÙH** locks to see if another thread has previously set a lock on that same©** inode.¢**ÙK** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.ÙH** For VxWorks, we have to use the alternative unique ID system based onÙ@** canonical filename and implemented in the previous division.)¢**ÙI** The sqlite3_file structure for POSIX is no longer just an integer fileÙA** descriptor.  It is now a structure that holds the integer fileÙF** descriptor and a pointer to a structure that describes the internalÙD** locks on the corresponding inode.  There is one locking structureÙL** per inode, so if the same inode is opened twice, both unixFile structuresÙD** point to the same locking structure.  The locking structure keepsÙD** a reference count (so we will know when to delete it) and a "cnt"ÙB** field that tells us its internal lock status.  cnt==0 means theÙC** file is unlocked.  cnt==-1 means the file has an exclusive lock.Ù6** cnt>0 means there are cnt shared locks on the file.¢**Ù@** Any attempt to lock or unlock a file first checks the lockingÙ@** structure.  The fcntl() system call is only invoked to set a Ù@** POSIX lock if the internal lock structure transitions betweenÙ"** a locked and an unlocked state.¢**ÙD** But wait:  there are yet more problems with POSIX advisory locks.¢**ÙG** If you close a file descriptor that points to a file that has locks,ÙC** all locks on that file that are owned by the current process areÙD** released.  To work around this problem, each unixInodeInfo objectÙA** maintains a count of the number of pending locks on tha inode.Ù=** When an attempt is made to close an unixFile, if there areÙI** other unixFile open on the same inode that are holding locks, the callÙK** to close() the file descriptor is deferred until all of the locks clear.ÙL** The unixInodeInfo structure keeps a list of file descriptors that need toÙE** be closed and that list is walked (and cleared) when the last lockª** clears.¢**ÙH** Yet another problem:  LinuxThreads do not play well with posix locks.¢**ÙE** Many older versions of linux use the LinuxThreads library which isÙE** not posix compliant.  Under LinuxThreads, a lock created by threadÙ>** A cannot be modified or overridden by a different thread B.ÙB** Only thread A can modify the lock.  Locking behavior is correctÙF** if the appliation uses the newer Native Posix Thread Library (NPTL)ÙE** on linux - with NPTL a lock created by thread A can override locksÙB** in thread B.  But there is no way to know at compile-time whichÙB** threading library is being used.  So there is no way to know atÙG** compile-time whether or not thread A can override locks on thread B.ÙA** One has to do a run-time check to discover the behavior of the³** current process.¢**ÙE** SQLite used to support LinuxThreads.  But support for LinuxThreadsÙI** was dropped beginning with version 3.7.0.  SQLite will still work withÙG** LinuxThreads provided that (1) there is no more than one connection ÙE** per database file in the same process and (2) database connections¾** do not move across threads.¢*/ ¢/*Ù@** An instance of the following structure serves as the key usedÙ/** to locate a particular unixInodeInfo object.¢*/³struct unixFileId {Ù1  dev_t dev;                  /* Device number */®#if OS_VXWORKSÙ?  struct vxworksFileId *pId;  /* Unique file ID for vxworks. */¥#elseÙA  /* We are told that some versions of Android contain a bug thatÙ9  ** sizes ino_t at only 32-bits instead of 64-bits. (SeeÙI  ** https://android-review.googlesource.com/#/c/115351/3/dist/sqlite3.c)ÙI  ** To work around this, always allocate 64-bits for the inode number.  ÙI  ** On small machines that only have 32-bit inodes, this wastes 4 bytes,Ù*  ** but that should not be a big deal. */º  /* WAS:  ino_t ino;   */Ù/  u64 ino;                   /* Inode number */¦#endif¢}; ¢/*ÙD** An instance of the following structure is allocated for each openÙD** inode.  Or, on LinuxThreads, there is one of these structures forÙ$** each inode opened by each thread.¢**ÙF** A single inode can have multiple file descriptors, so each unixFileÙF** structure contains a pointer to an instance of this object and thisÙA** object keeps a count of the number of unixFile pointing to it.¢*/¶struct unixInodeInfo {Ù6  struct unixFileId fileId;       /* The lookup key */ÙC  int nShared;                    /* Number of SHARED locks held */ÙN  unsigned char eFileLock;        /* One of SHARED_LOCK, RESERVED_LOCK etc. */ÙI  unsigned char bProcessLock;     /* An exclusive process lock is held */ÙL  int nRef;                       /* Number of pointers to this structure */ÙP  unixShmNode *pShmNode;          /* Shared memory associated with this inode */ÙH  int nLock;                      /* Number of outstanding file locks */ÙH  UnixUnusedFd *pUnused;          /* Unused file descriptors to close */ÙI  unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */Ù=  unixInodeInfo *pPrev;           /*    .... doubly linked */¿#if SQLITE_ENABLE_LOCKING_STYLEÙE  unsigned long long sharedByte;  /* for AFP simulated shared lock */¦#endif®#if OS_VXWORKSÙ=  sem_t *pSem;                    /* Named POSIX semaphore */Ù>  char aSemName[MAX_PATHNAME+2];  /* Name of that semaphore */¦#endif¢}; ¢/*Ù(** A lists of all unixInodeInfo objects.¢*/ÙEstatic unixInodeInfo *inodeList = 0;  /* All unixInodeInfo objects */ÙIstatic unsigned int nUnusedFd = 0;    /* Total unused file descriptors */ ¢/*¢**ÙJ** This function - unixLogErrorAtLine(), is only ever called via the macro²** unixLogError().¢**ÙK** It is invoked after an error occurs in an OS function and errno has beenÙM** set. It logs a message using sqlite3_log() containing the current value ofÙK** errno and, if possible, the human-readable equivalent from strerror() or°** strerror_r().¢**ÙG** The first argument passed to the macro should be the error code thatÙK** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN). ÙJ** The two subsequent arguments should be the name of the OS function thatÙF** failed (e.g. "unlink", "open") and the associated file-system path,ª** if any.¢*/ÙB#define unixLogError(a,b,c)     unixLogErrorAtLine(a,b,c,__LINE__)¾static int unixLogErrorAtLine(Ù9  int errcode,                    /* SQLite error code */ÙG  const char *zFunc,              /* Name of OS function that failed */ÙG  const char *zPath,              /* File path associated with error */ÙO  int iLine                       /* Source line number where error occurred */¢){ÙM  char *zErr;                     /* Message from strerror() or equivalent */ÙB  int iErrno = errno;             /* Saved syscall error number */ ÙG  /* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then useÙG  ** the strerror() function to obtain the human-readable error messageÙ6  ** equivalent to errno. Otherwise, use strerror_r().¥  */ Ù1#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)°  char aErr[80];Ù   memset(aErr, 0, sizeof(aErr));®  zErr = aErr; ÙL  /* If STRERROR_R_CHAR_P (set by autoconf scripts) or __USE_GNU is defined,ÙI  ** assume that the system provides the GNU version of strerror_r() thatÙN  ** returns a pointer to a buffer containing the error message. That pointer ÙL  ** may point to aErr[], or it may point to some static storage somewhere. ÙE  ** Otherwise, assume that the system provides the POSIX version of ÙD  ** strerror_r(), which always writes an error message into aErr[].¤  **ÙI  ** If the code incorrectly assumes that it is the POSIX version that isÙF  ** available, the error message will often be an empty string. Not aÙL  ** huge problem. Incorrectly concluding that the GNU version is available Ù%  ** could lead to a segfault though.¤  */Ù4#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)©  zErr = §# endifÙ+  strerror_r(iErrno, aErr, sizeof(aErr)-1); ·#elif SQLITE_THREADSAFEÙF  /* This is a threadsafe build, but strerror_r() is not available. */¬  zErr = "";¥#elseÙ-  /* Non-threadsafe build, use strerror(). */º  zErr = strerror(iErrno);¦#endif ¼  if( zPath==0 ) zPath = "";¶  sqlite3_log(errcode,Ù'      "os_unix.c:%d: (%d) %s(%s) - %s",Ù'      iLine, iErrno, zFunc, zPath, zErr¤  ); ±  return errcode;¡} ¢/*»** Close a file descriptor.¢**ÙD** We assume that close() almost always works, since it is only in aÙG** very sick application or on a very sick platform that it might fail.ÙC** If it does fail, simply leak the file descriptor, but do log the©** error.¢**ÙB** Note that it is not safe to retry close() after EINTR since theÙD** file descriptor might have already been reused by another thread.ÙE** So we don't even try to recover from an EINTR.  Just log the error¯** and move on.¢*/Ù=static void robust_close(unixFile *pFile, int h, int lineno){³  if( osClose(h) ){Ù3    unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",Ù9                       pFile ? pFile->zPath : 0, lineno);£  }¡} ¢/*ÙF** Set the pFile->lastErrno.  Do this in a subroutine as that providesÙ*** a convenient place to set a breakpoint.¢*/Ù7static void storeLastErrno(unixFile *pFile, int error){»  pFile->lastErrno = error;¡} ¢/*ÙL** Close all file descriptors accumuated in the unixInodeInfo->pUnused list.£*/ Ù-static void closePendingFds(unixFile *pFile){Ù(  unixInodeInfo *pInode = pFile->pInode;²  UnixUnusedFd *p;¶  UnixUnusedFd *pNext;Ù%  for(p=pInode->pUnused; p; p=pNext){µ    pNext = p->pNext;Ù)    robust_close(pFile, p->fd, __LINE__);´    sqlite3_free(p);°    nUnusedFd--;£  }¶  pInode->pUnused = 0;¡} ¢/*ÙM** Release a unixInodeInfo structure previously allocated by findInodeInfo().¢**ÙE** The mutex entered using the unixEnterMutex() function must be heldÙ ** when this function is called.¢*/Ù.static void releaseInodeInfo(unixFile *pFile){Ù(  unixInodeInfo *pInode = pFile->pInode;¼  assert( unixMutexHeld() );·  if( ALWAYS(pInode) ){³    pInode->nRef--;º    if( pInode->nRef==0 ){Ù$      assert( pInode->pShmNode==0 );½      closePendingFds(pFile);º      if( pInode->pPrev ){Ù/        assert( pInode->pPrev->pNext==pInode );Ù-        pInode->pPrev->pNext = pInode->pNext;¬      }else{Ù$        assert( inodeList==pInode );Ù"        inodeList = pInode->pNext;§      }º      if( pInode->pNext ){Ù/        assert( pInode->pNext->pPrev==pInode );Ù-        pInode->pNext->pPrev = pInode->pPrev;§      }»      sqlite3_free(pInode);¥    }£  }Ù)  assert( inodeList!=0 || nUnusedFd==0 );¡} ¢/*Ù@** Given a file descriptor, locate the unixInodeInfo object thatÙG** describes that file descriptor.  Create a new one if necessary.  TheÙ:** return value might be uninitialized if an error occurs.¢**ÙE** The mutex entered using the unixEnterMutex() function must be heldÙ ** when this function is called.¢**Ù$** Return an appropriate error code.¢*/¹static int findInodeInfo(ÙO  unixFile *pFile,               /* Unix file with file desc used in the key */ÙK  unixInodeInfo **ppInode        /* Return the unixInodeInfo object here */¢){Ù>  int rc;                        /* System call return code */ÙD  int fd;                        /* The file descriptor for pFile */ÙG  struct unixFileId fileId;      /* Lookup key for the unixInodeInfo */ÙA  struct stat statbuf;           /* Low-level file information */ÙE  unixInodeInfo *pInode = 0;     /* Candidate unixInodeInfo object */ ¼  assert( unixMutexHeld() ); ÙA  /* Get low-level information about the file that we can used toÙ'  ** create a unique name for the file.¤  */°  fd = pFile->h;½  rc = osFstat(fd, &statbuf);®  if( rc!=0 ){Ù!    storeLastErrno(pFile, errno);Ù5#if defined(EOVERFLOW) && defined(SQLITE_DISABLE_LFS)Ù:    if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;¦#endif¸    return SQLITE_IOERR;£  } °#ifdef __APPLE__ÙA  /* On OS X on an msdos filesystem, the inode number is reportedÙA  ** incorrectly for zero-size files.  See ticket #3260.  To workÙC  ** around this problem (we consider it a bug in OS X, not SQLite)ÙC  ** we always increase the file size to 1 by writing a single byteÙB  ** prior to accessing the inode number.  The one byte written isÙC  ** an ASCII 'S' character which also happens to be the first byteÙC  ** in the header of every SQLite database.  In this way, if thereÙG  ** is a race condition such that another thread has already populatedÙ7  ** the first page of the database, no damage is done.¤  */ÙL  if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){ÙA    do{ rc = osWrite(fd, "S", 1); }while( rc<0 && errno==EINTR );°    if( rc!=1 ){Ù#      storeLastErrno(pFile, errno);º      return SQLITE_IOERR;¥    }¿    rc = osFstat(fd, &statbuf);°    if( rc!=0 ){Ù#      storeLastErrno(pFile, errno);º      return SQLITE_IOERR;¥    }£  }¦#endif Ù%  memset(&fileId, 0, sizeof(fileId));¾  fileId.dev = statbuf.st_dev;®#if OS_VXWORKSº  fileId.pId = pFile->pId;¥#elseÙ#  fileId.ino = (u64)statbuf.st_ino;¦#endifÙ)  assert( inodeList!=0 || nUnusedFd==0 );µ  pInode = inodeList;ÙF  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){»    pInode = pInode->pNext;£  }²  if( pInode==0 ){Ù1    pInode = sqlite3_malloc64( sizeof(*pInode) );´    if( pInode==0 ){¿      return SQLITE_NOMEM_BKPT;¥    }Ù'    memset(pInode, 0, sizeof(*pInode));Ù5    memcpy(&pInode->fileId, &fileId, sizeof(fileId));µ    pInode->nRef = 1;¾    pInode->pNext = inodeList;¶    pInode->pPrev = 0;Ù.    if( inodeList ) inodeList->pPrev = pInode;·    inodeList = pInode;¨  }else{³    pInode->nRef++;£  }´  *ppInode = pInode;³  return SQLITE_OK;¡} ¢/*ÙO** Return TRUE if pFile has been renamed or unlinked since it was first opened.¢*/Ù)static int fileHasMoved(unixFile *pFile){®#if OS_VXWORKSÙC  return pFile->pInode!=0 && pFile->pId!=pFile->pInode->fileId.pId;¥#else²  struct stat buf;¼  return pFile->pInode!=0 &&Ù%      (osStat(pFile->zPath, &buf)!=0 Ù8         || (u64)buf.st_ino!=pFile->pInode->fileId.ino);¦#endif¡}  ¢/*Ù>** Check a unixFile that is a database.  Verify the following:¢**Ù1** (1) There is exactly one hard link on the fileÙ&** (2) The file is not a symbolic linkÙ0** (3) The file has not been renamed or unlinked¢**ÙK** Issue sqlite3_log(SQLITE_WARNING,...) messages if anything is not right.¢*/Ù*static void verifyDbFile(unixFile *pFile){²  struct stat buf;©  int rc; Ù=  /* These verifications occurs for the main database only */Ù2  if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) return; ¿  rc = osFstat(pFile->h, &buf);®  if( rc!=0 ){ÙI    sqlite3_log(SQLITE_WARNING, "cannot fstat db file %s", pFile->zPath);«    return;£  }¸  if( buf.st_nlink==0 ){ÙN    sqlite3_log(SQLITE_WARNING, "file unlinked while open: %s", pFile->zPath);«    return;£  }·  if( buf.st_nlink>1 ){ÙL    sqlite3_log(SQLITE_WARNING, "multiple links to file: %s", pFile->zPath);«    return;£  }¼  if( fileHasMoved(pFile) ){ÙM    sqlite3_log(SQLITE_WARNING, "file renamed while open: %s", pFile->zPath);«    return;£  }¡}  ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙJ** file by this or any other process. If such a lock is held, set *pResOutÙK** to a non-zero value otherwise *pResOut is set to zero.  The return valueÙG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ÙAstatic int unixCheckReservedLock(sqlite3_file *id, int *pResOut){µ  int rc = SQLITE_OK;³  int reserved = 0;Ù"  unixFile *pFile = (unixFile*)id; Ù<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; ); ²  assert( pFile );Ù*  assert( pFile->eFileLock<=SHARED_LOCK );ÙH  unixEnterMutex(); /* Because pFile->pInode is shared across threads */ Ù;  /* Check if a thread in this process holds such a lock */Ù-  if( pFile->pInode->eFileLock>SHARED_LOCK ){±    reserved = 1;£  } Ù2  /* Otherwise see if some other process holds it.¤  */±#ifndef __DJGPP__Ù2  if( !reserved && !pFile->pInode->bProcessLock ){¶    struct flock lock;½    lock.l_whence = SEEK_SET;Ù!    lock.l_start = RESERVED_BYTE;³    lock.l_len = 1;º    lock.l_type = F_WRLCK;Ù,    if( osFcntl(pFile->h, F_GETLK, &lock) ){Ù*      rc = SQLITE_IOERR_CHECKRESERVEDLOCK;Ù#      storeLastErrno(pFile, errno);Ù&    } else if( lock.l_type!=F_UNLCK ){³      reserved = 1;¥    }£  }¦#endif¢  ³  unixLeaveMutex();ÙF  OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved)); ¶  *pResOut = reserved;¬  return rc;¡} ¢/*½** Set a posix-advisory-lock.¢**Ù<** There are two versions of this routine.  If compiled withÙF** SQLITE_ENABLE_SETLK_TIMEOUT then the routine has an extra parameterÙC** which is a pointer to a unixFile.  If the unixFile->iBusyTimeoutÙE** value is set, then it is the number of milliseconds to wait beforeÙD** failing the lock.  The iBusyTimeout value is always reset back toµ** zero on each call.¢**ÙH** If SQLITE_ENABLE_SETLK_TIMEOUT is not defined, then do a non-blocking»** attempt to set the lock.¢*/Ù##ifndef SQLITE_ENABLE_SETLK_TIMEOUTÙ;# define osSetPosixAdvisoryLock(h,x,t) osFcntl(h,F_SETLK,x)¥#elseÙ"static int osSetPosixAdvisoryLock(ÙK  int h,                /* The file descriptor on which to take the lock */Ù9  struct flock *pLock,  /* The description of the lock */Ù=  unixFile *pFile       /* Structure holding timeout value */¢){Ù$  int rc = osFcntl(h,F_SETLK,pLock);Ù)  while( rc<0 && pFile->iBusyTimeout>0 ){ÙN    /* On systems that support some kind of blocking file lock with a timeout,ÙK    ** make appropriate changes here to invoke that blocking file lock.  OnÙJ    ** generic posix, however, there is no such API.  So we simply try theÙM    ** lock once every millisecond until either the timeout expires, or until¿    ** the lock is obtained. */±    usleep(1000);Ù"    rc = osFcntl(h,F_SETLK,pLock);º    pFile->iBusyTimeout--;£  }¬  return rc;¡}Ù(#endif /* SQLITE_ENABLE_SETLK_TIMEOUT */  ¢/*Ù@** Attempt to set a system-lock on the file pFile.  The lock is ¶** described by pLock.¢**ÙH** If the pFile was opened read/write from unix-excl, then the only lockÙF** ever obtained is an exclusive lock, and it is obtained exactly onceÙG** the first time any lock is attempted.  All subsequent system lockingÙI** operations become no-ops.  Locking operations still happen internally,ÙF** in order to coordinate access between separate database connectionsÙD** within this process, but all of that is handled in memory and theÙ)** operating system does not participate.¢**ÙF** This function is a pass-through to fcntl(F_SETLK) if pFile is usingÙF** any VFS other than "unix-excl" or if pFile is opened on "unix-excl"´** and is read-only.¢**ÙG** Zero is returned if the call completes successfully, or -1 if a callÙK** to fcntl() fails. In this case, errno is set appropriately (by fcntl()).¢*/Ù>static int unixFileLock(unixFile *pFile, struct flock *pLock){©  int rc;Ù(  unixInodeInfo *pInode = pFile->pInode;¼  assert( unixMutexHeld() );¶  assert( pInode!=0 );ÙL  if( (pFile->ctrlFlags & (UNIXFILE_EXCL|UNIXFILE_RDONLY))==UNIXFILE_EXCL ){Ù"    if( pInode->bProcessLock==0 ){¸      struct flock lock;Ù!      assert( pInode->nLock==0 );¿      lock.l_whence = SEEK_SET;Ù"      lock.l_start = SHARED_FIRST;¿      lock.l_len = SHARED_SIZE;¼      lock.l_type = F_WRLCK;Ù:      rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);»      if( rc<0 ) return rc;¿      pInode->bProcessLock = 1;¶      pInode->nLock++;ª    }else{­      rc = 0;¥    }¨  }else{Ù8    rc = osSetPosixAdvisoryLock(pFile->h, pLock, pFile);£  }¬  return rc;¡} ¢/*ÙE** Lock the file with the lock specified by parameter eFileLock - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ù$** routine to lower a locking level.¢*/Ù5static int unixLock(sqlite3_file *id, int eFileLock){ÙH  /* The following describes the implementation of the various locks andÙI  ** lock transitions in terms of the POSIX advisory shared and exclusiveÙG  ** lock primitives (called read-locks and write-locks below, to avoidÙF  ** confusion with SQLite lock names). The algorithms are complicatedÙM  ** slightly in order to be compatible with Windows95 systems simultaneouslyÙE  ** accessing the same database file, in case that is ever required.¤  **ÙK  ** Symbols defined in os.h indentify the 'pending byte' and the 'reservedÙI  ** byte', each single bytes at well known offsets, and the 'shared byteÙ9  ** range', a range of 510 bytes at a well known offset.¤  **ÙE  ** To obtain a SHARED lock, a read-lock is obtained on the 'pendingÙF  ** byte'.  If this is successful, 'shared byte range' is read-lockedÙF  ** and the lock on the 'pending byte' released.  (Legacy note:  WhenÙJ  ** SQLite was first developed, Windows95 systems were still very common,ÙF  ** and Widnows95 lacks a shared-lock capability.  So on Windows95, aÙH  ** single randomly selected by from the 'shared byte range' is locked.ÙG  ** Windows95 is now pretty much extinct, but this work-around for theÙ>  ** lack of shared-locks on Windows95 lives on, for backwards´  ** compatibility.)¤  **ÙJ  ** A process may only obtain a RESERVED lock after it has a SHARED lock.ÙC  ** A RESERVED lock is implemented by grabbing a write-lock on the¶  ** 'reserved byte'. ¤  **ÙE  ** A process may only obtain a PENDING lock after it has obtained aÙI  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lockÙH  ** on the 'pending byte'. This ensures that no new SHARED locks can beÙJ  ** obtained, but existing SHARED locks are allowed to persist. A processÙJ  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.ÙK  ** This property is used by the algorithm for rolling back a journal file³  ** after a crash.¤  **ÙA  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, isÙE  ** implemented by obtaining a write-lock on the entire 'shared byteÙJ  ** range'. Since all other locks require a read-lock on one of the bytesÙH  ** within this range, this ensures that no other locks are held on the¯  ** database. ¤  */µ  int rc = SQLITE_OK;Ù"  unixFile *pFile = (unixFile*)id;¸  unixInodeInfo *pInode;´  struct flock lock;±  int tErrno = 0; ²  assert( pFile );ÙC  OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,Ù:      azFileLock(eFileLock), azFileLock(pFile->eFileLock),ÙC      azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,´      osGetpid(0))); ÙG  /* If there is already a lock of this type or more restrictive on theÙ@  ** unixFile, do nothing. Don't use the end_lock: exit path, asÙ-  ** unixEnterMutex() hasn't been called yet.¤  */Ù$  if( pFile->eFileLock>=eFileLock ){ÙB    OSTRACE(("LOCK    %d %s ok (already held) (unix)\n", pFile->h,Ù$            azFileLock(eFileLock)));µ    return SQLITE_OK;£  } Ù/  /* Make sure the locking sequence is correct.ÙJ  **  (1) We never move from unlocked to anything higher than shared lock.Ù9  **  (2) SQLite never explicitly requests a pendig lock.ÙH  **  (3) A shared lock is always held when a reserve lock is requested.¤  */Ù@  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );Ù$  assert( eFileLock!=PENDING_LOCK );ÙF  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK ); ÙH  /* This mutex is needed because pFile->pInode is shared across threads¤  */³  unixEnterMutex();¹  pInode = pFile->pInode; ÙG  /* If some thread using this PID has a lock via a different unixFile*Ù;  ** handle that precludes the requested lock, return BUSY.¤  */Ù.  if( (pFile->eFileLock!=pInode->eFileLock && ÙE          (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))¤  ){µ    rc = SQLITE_BUSY;²    goto end_lock;£  } ÙJ  /* If a SHARED lock is requested, and some thread using this PID alreadyÙG  ** has a SHARED or RESERVED lock, then increment reference counts and¶  ** return SQLITE_OK.¤  */Ù   if( eFileLock==SHARED_LOCK && ÙM      (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){Ù%    assert( eFileLock==SHARED_LOCK );Ù"    assert( pFile->eFileLock==0 );Ù     assert( pInode->nShared>0 );Ù#    pFile->eFileLock = SHARED_LOCK;¶    pInode->nShared++;´    pInode->nLock++;²    goto end_lock;£  }  ÙG  /* A PENDING lock is needed before acquiring a SHARED lock and beforeÙH  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will±  ** be released.¤  */²  lock.l_len = 1L;»  lock.l_whence = SEEK_SET;½  if( eFileLock==SHARED_LOCK ÙE      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)¤  ){Ù;    lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);Ù     lock.l_start = PENDING_BYTE;Ù%    if( unixFileLock(pFile, &lock) ){µ      tErrno = errno;Ù@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);¼      if( rc!=SQLITE_BUSY ){Ù&        storeLastErrno(pFile, tErrno);§      }´      goto end_lock;¥    }£  }  ÙC  /* If control gets to this point, then actually go ahead and makeÙ3  ** operating system calls for the specified lock.¤  */¿  if( eFileLock==SHARED_LOCK ){Ù!    assert( pInode->nShared==0 );Ù#    assert( pInode->eFileLock==0 );¼    assert( rc==SQLITE_OK ); ¿    /* Now get the read-lock */Ù     lock.l_start = SHARED_FIRST;½    lock.l_len = SHARED_SIZE;Ù%    if( unixFileLock(pFile, &lock) ){µ      tErrno = errno;Ù@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);¥    } Ù)    /* Drop the temporary PENDING lock */Ù     lock.l_start = PENDING_BYTE;´    lock.l_len = 1L;º    lock.l_type = F_UNLCK;Ù6    if( unixFileLock(pFile, &lock) && rc==SQLITE_OK ){Ù2      /* This could happen with a network mount */µ      tErrno = errno;Ù       rc = SQLITE_IOERR_UNLOCK; ¥    } ­    if( rc ){¼      if( rc!=SQLITE_BUSY ){Ù&        storeLastErrno(pFile, tErrno);§      }´      goto end_lock;ª    }else{Ù%      pFile->eFileLock = SHARED_LOCK;¶      pInode->nLock++;º      pInode->nShared = 1;¥    }Ù=  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){ÙE    /* We are trying for an exclusive lock but another thread in thisÙ6    ** same process is still holding a shared lock. */µ    rc = SQLITE_BUSY;¨  }else{Ù?    /* The request was for a RESERVED or EXCLUSIVE lock.  It isÙA    ** assumed that there is a SHARED or greater lock on the file¯    ** already.¦    */Ù"    assert( 0!=pFile->eFileLock );º    lock.l_type = F_WRLCK; ÙD    assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );Ù#    if( eFileLock==RESERVED_LOCK ){Ù#      lock.l_start = RESERVED_BYTE;¶      lock.l_len = 1L;ª    }else{Ù"      lock.l_start = SHARED_FIRST;¿      lock.l_len = SHARED_SIZE;¥    } Ù%    if( unixFileLock(pFile, &lock) ){µ      tErrno = errno;Ù@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);¼      if( rc!=SQLITE_BUSY ){Ù&        storeLastErrno(pFile, tErrno);§      }¥    }£  }¢   ³#ifdef SQLITE_DEBUGÙ>  /* Set up the transaction-counter change checking flags whenÙ@  ** transitioning from a SHARED to a RESERVED lock.  The changeÙ<  ** from SHARED to RESERVED marks the beginning of a normalÙ2  ** write operation (not a hot journal rollback).¤  */³  if( rc==SQLITE_OKÙ#   && pFile->eFileLock<=SHARED_LOCK¾   && eFileLock==RESERVED_LOCK¤  ){½    pFile->transCntrChng = 0;¸    pFile->dbUpdate = 0;½    pFile->inNormalWrite = 1;£  }¦#endif  ¶  if( rc==SQLITE_OK ){Ù!    pFile->eFileLock = eFileLock;Ù"    pInode->eFileLock = eFileLock;Ù(  }else if( eFileLock==EXCLUSIVE_LOCK ){Ù$    pFile->eFileLock = PENDING_LOCK;Ù%    pInode->eFileLock = PENDING_LOCK;£  } ©end_lock:³  unixLeaveMutex();ÙI  OSTRACE(("LOCK    %d %s %s (unix)\n", pFile->h, azFileLock(eFileLock), Ù(      rc==SQLITE_OK ? "ok" : "failed"));¬  return rc;¡} ¢/*ÙI** Add the file descriptor used by file handle pFile to the corresponding°** pUnused list.¢*/Ù*static void setPendingFd(unixFile *pFile){Ù(  unixInodeInfo *pInode = pFile->pInode;Ù/  UnixUnusedFd *p = pFile->pPreallocatedUnused;½  p->pNext = pInode->pUnused;¶  pInode->pUnused = p;°  pFile->h = -1;Ù!  pFile->pPreallocatedUnused = 0;®  nUnusedFd++;¡} ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.£** ÙN** If handleNFSUnlock is true, then on downgrading an EXCLUSIVE_LOCK to SHAREDÙM** the byte range is divided into 2 parts and the first part is unlocked thenÙK** set to a read lock, then the other part is simply unlocked.  This works ÙK** around a bug in BSD NFS lockd (also seen on MacOSX 10.3+) that fails to Ù=** remove the write lock on a region when a read lock is set.¢*/ÙMstatic int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){Ù"  unixFile *pFile = (unixFile*)id;¸  unixInodeInfo *pInode;´  struct flock lock;µ  int rc = SQLITE_OK; ²  assert( pFile );ÙN  OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,ÙI      pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,´      osGetpid(0))); Ù#  assert( eFileLock<=SHARED_LOCK );Ù$  if( pFile->eFileLock<=eFileLock ){µ    return SQLITE_OK;£  }³  unixEnterMutex();¹  pInode = pFile->pInode;¿  assert( pInode->nShared!=0 );Ù%  if( pFile->eFileLock>SHARED_LOCK ){Ù2    assert( pInode->eFileLock==pFile->eFileLock ); ³#ifdef SQLITE_DEBUGÙ?    /* When reducing a lock such that other processes can startÙ:    ** reading the database file again, make sure that theÙB    ** transaction counter was updated if any part of the databaseÙ@    ** file changed.  If the transaction counter is not updated,Ù@    ** other connections to the same file might not realize thatÙC    ** the file has changed and hence might not know to flush theirÙH    ** cache.  The use of a stale cache can lead to database corruption.¦    */½    pFile->inNormalWrite = 0;¦#endif ÙK    /* downgrading to a shared lock on NFS involves clearing the write lockÙP    ** before establishing the readlock - to avoid a race condition we downgradeÙL    ** the lock in 2 blocks, so that part of the range will be covered by a Ù;    ** write lock until the rest is covered by a read lock:´    **  1:   [WWWWW]´    **  2:   [....W]´    **  3:   [RRRRW]´    **  4:   [RRRR.]¦    */Ù!    if( eFileLock==SHARED_LOCK ){Ù7#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE¼      (void)handleNFSUnlock;Ù#      assert( handleNFSUnlock==0 );¦#endifÙ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE¼      if( handleNFSUnlock ){ÙJ        int tErrno;               /* Error code from system call errors */Ù(        off_t divSize = SHARED_SIZE - 1;¨        ¾        lock.l_type = F_UNLCK;Ù!        lock.l_whence = SEEK_SET;Ù$        lock.l_start = SHARED_FIRST;½        lock.l_len = divSize;Ù/        if( unixFileLock(pFile, &lock)==(-1) ){¹          tErrno = errno;Ù#          rc = SQLITE_IOERR_UNLOCK;Ù(          storeLastErrno(pFile, tErrno);º          goto end_unlock;©        }¾        lock.l_type = F_RDLCK;Ù!        lock.l_whence = SEEK_SET;Ù$        lock.l_start = SHARED_FIRST;½        lock.l_len = divSize;Ù/        if( unixFileLock(pFile, &lock)==(-1) ){¹          tErrno = errno;ÙF          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);Ù"          if( IS_LOCK_ERROR(rc) ){Ù*            storeLastErrno(pFile, tErrno);«          }º          goto end_unlock;©        }¾        lock.l_type = F_UNLCK;Ù!        lock.l_whence = SEEK_SET;Ù,        lock.l_start = SHARED_FIRST+divSize;Ù)        lock.l_len = SHARED_SIZE-divSize;Ù/        if( unixFileLock(pFile, &lock)==(-1) ){¹          tErrno = errno;Ù#          rc = SQLITE_IOERR_UNLOCK;Ù(          storeLastErrno(pFile, tErrno);º          goto end_unlock;©        }«      }elseÙ>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */§      {¾        lock.l_type = F_RDLCK;Ù!        lock.l_whence = SEEK_SET;Ù$        lock.l_start = SHARED_FIRST;Ù!        lock.l_len = SHARED_SIZE;Ù)        if( unixFileLock(pFile, &lock) ){ÙN          /* In theory, the call to unixFileLock() cannot fail because anotherÙG          ** process is holding an incompatible lock. If it does, this ÙJ          ** indicates that the other process is not following the lockingÙM          ** protocol. If this happens, return SQLITE_IOERR_RDLOCK. ReturningÙN          ** SQLITE_BUSY would confuse the upper layer (in practice it causes Ù$          ** an assert to fail). */ Ù#          rc = SQLITE_IOERR_RDLOCK;Ù'          storeLastErrno(pFile, errno);º          goto end_unlock;©        }§      }¥    }º    lock.l_type = F_UNLCK;½    lock.l_whence = SEEK_SET;Ù     lock.l_start = PENDING_BYTE;Ù>    lock.l_len = 2L;  assert( PENDING_BYTE+1==RESERVED_BYTE );Ù(    if( unixFileLock(pFile, &lock)==0 ){Ù&      pInode->eFileLock = SHARED_LOCK;ª    }else{¿      rc = SQLITE_IOERR_UNLOCK;Ù#      storeLastErrno(pFile, errno);¶      goto end_unlock;¥    }£  }»  if( eFileLock==NO_LOCK ){ÙD    /* Decrement the shared lock counter.  Release the lock using anÙG    ** OS call only when all threads in this same process have released°    ** the lock.¦    */¶    pInode->nShared--;½    if( pInode->nShared==0 ){¼      lock.l_type = F_UNLCK;¿      lock.l_whence = SEEK_SET;Ù%      lock.l_start = lock.l_len = 0L;Ù*      if( unixFileLock(pFile, &lock)==0 ){Ù$        pInode->eFileLock = NO_LOCK;¬      }else{Ù!        rc = SQLITE_IOERR_UNLOCK;Ù%        storeLastErrno(pFile, errno);Ù$        pInode->eFileLock = NO_LOCK;Ù#        pFile->eFileLock = NO_LOCK;§      }¥    } ÙE    /* Decrement the count of locks against this same file.  When theÙG    ** count reaches zero, close any other file descriptors whose closeÙ1    ** was deferred because of outstanding locks.¦    */´    pInode->nLock--;¿    assert( pInode->nLock>=0 );»    if( pInode->nLock==0 ){½      closePendingFds(pFile);¥    }£  } «end_unlock:³  unixLeaveMutex();Ù3  if( rc==SQLITE_OK ) pFile->eFileLock = eFileLock;¬  return rc;¡} ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢*/Ù7static int unixUnlock(sqlite3_file *id, int eFileLock){º#if SQLITE_MAX_MMAP_SIZE>0ÙE  assert( eFileLock==SHARED_LOCK || ((unixFile *)id)->nFetchOut==0 );¦#endifÙ'  return posixUnlock(id, eFileLock, 0);¡} º#if SQLITE_MAX_MMAP_SIZE>0Ù1static int unixMapfile(unixFile *pFd, i64 nByte);Ù)static void unixUnmapfile(unixFile *pFd);¦#endif ¢/*ÙB** This function performs the parts of the "close file" operation ÙB** common to all locking schemes. It closes the directory and fileÙB** handles, if they are valid, and sets all fields of the unixFile²** structure to 0.¢**ÙG** It is *not* necessary to hold the mutex when this routine is called,Ù?** even on VxWorks.  A mutex will be acquired on VxWorks by theÙ"** vxworksReleaseFileId() routine.¢*/Ù+static int closeUnixFile(sqlite3_file *id){Ù"  unixFile *pFile = (unixFile*)id;º#if SQLITE_MAX_MMAP_SIZE>0·  unixUnmapfile(pFile);¦#endif´  if( pFile->h>=0 ){Ù,    robust_close(pFile, pFile->h, __LINE__);²    pFile->h = -1;£  }®#if OS_VXWORKS³  if( pFile->pId ){Ù-    if( pFile->ctrlFlags & UNIXFILE_DELETE ){Ù+      osUnlink(pFile->pId->zCanonicalName);¥    }Ù%    vxworksReleaseFileId(pFile->pId);³    pFile->pId = 0;£  }¦#endifÙ #ifdef SQLITE_UNLINK_AFTER_CLOSEÙ+  if( pFile->ctrlFlags & UNIXFILE_DELETE ){»    osUnlink(pFile->zPath);Ù)    sqlite3_free(*(char**)&pFile->zPath);µ    pFile->zPath = 0;£  }¦#endifÙ(  OSTRACE(("CLOSE   %-3d\n", pFile->h));²  OpenCounter(-1);Ù+  sqlite3_free(pFile->pPreallocatedUnused);Ù%  memset(pFile, 0, sizeof(unixFile));³  return SQLITE_OK;¡} ¢/*°** Close a file.¢*/Ù'static int unixClose(sqlite3_file *id){µ  int rc = SQLITE_OK;Ù#  unixFile *pFile = (unixFile *)id;¶  verifyDbFile(pFile);º  unixUnlock(id, NO_LOCK);³  unixEnterMutex(); ÙG  /* unixFile.pInode is always valid here. Otherwise, a different closeÙ:  ** routine (e.g. nolockClose()) would be called instead.¤  */ÙE  assert( pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 );Ù6  if( ALWAYS(pFile->pInode) && pFile->pInode->nLock ){ÙJ    /* If there are outstanding locks, do not actually close the file justÙG    ** yet because that would clear those locks.  Instead, add the fileÙL    ** descriptor to pInode->pUnused list.  It will be automatically closed Ù%    ** when the last lock is cleared.¦    */¸    setPendingFd(pFile);£  }º  releaseInodeInfo(pFile);¹  rc = closeUnixFile(id);³  unixLeaveMutex();¬  return rc;¡} ÙO/************** End of the posix advisory lock implementation *****************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO****************************** No-op Locking **********************************¢**ÙG** Of the various locking implementations available, this is by far theÙJ** simplest:  locking is ignored.  No attempt is made to lock the database¿** file for reading or writing.¢**ÙB** This locking mode is appropriate for use on read-only databasesÙD** (ex: databases that are burned into CD-ROM, for example.)  It canÙE** also be used if the application employs some external mechanism toÙB** prevent simultaneous access of the same database by two or moreÙA** database connections.  But there is a serious risk of databaseÙG** corruption if this locking mode is used in situations where multipleÙH** database connections are accessing the same database file at the sameÙ9** time and one or more of those connections are writing.¢*/ ÙHstatic int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){¼  UNUSED_PARAMETER(NotUsed);¯  *pResOut = 0;³  return SQLITE_OK;¡}Ù;static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){Ù'  UNUSED_PARAMETER2(NotUsed, NotUsed2);³  return SQLITE_OK;¡}Ù=static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){Ù'  UNUSED_PARAMETER2(NotUsed, NotUsed2);³  return SQLITE_OK;¡} ¢/*²** Close the file.¢*/Ù*static int nolockClose(sqlite3_file *id) {»  return closeUnixFile(id);¡} ÙO/******************* End of the no-op lock implementation *********************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO************************* Begin dot-file Locking ******************************¢**ÙI** The dotfile locking implementation uses the existence of separate lockÙL** files (really a directory) to control access to the database.  This worksÙO** on just about every filesystem imaginable.  But there are serious downsides:¢**ÙG**    (1)  There is zero concurrency.  A single reader blocks all otherÙ<**         connections from reading or writing the database.¢**ÙH**    (2)  An application crash or power loss can leave stale lock filesÙ;**         sitting around that need to be cleared manually.¢**ÙG** Nevertheless, a dotlock is an appropriate locking mode for use if noÙ'** other locking strategy is available.¢**ÙL** Dotfile locking works by creating a subdirectory in the same directory asÙJ** the database and with the same name but with a ".lock" extension added.ÙJ** The existence of a lock directory implies an EXCLUSIVE lock.  All otherÙD** lock types (SHARED, RESERVED, PENDING) are mapped into EXCLUSIVE.¢*/ ¢/*ÙI** The file suffix added to the data base filename in order to create the²** lock directory.¢*/¾#define DOTLOCK_SUFFIX ".lock" ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙJ** file by this or any other process. If such a lock is held, set *pResOutÙK** to a non-zero value otherwise *pResOut is set to zero.  The return valueÙG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢**ÙG** In dotfile locking, either a lock exists or it does not.  So in thisÙH** variation of CheckReservedLock(), *pResOut is set to true if any lockÙ9** is held on the file and false if the file is unlocked.¢*/ÙEstatic int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {µ  int rc = SQLITE_OK;³  int reserved = 0;Ù"  unixFile *pFile = (unixFile*)id; Ù<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ²  assert( pFile );Ù@  reserved = osAccess((const char*)pFile->lockingContext, 0)==0;ÙI  OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, rc, reserved));¶  *pResOut = reserved;¬  return rc;¡} ¢/*ÙE** Lock the file with the lock specified by parameter eFileLock - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ù$** routine to lower a locking level.¢**ÙE** With dotfile locking, we really only support state (4): EXCLUSIVE.Ù4** But we track the other locking levels internally.¢*/Ù9static int dotlockLock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;Ù2  char *zLockFile = (char *)pFile->lockingContext;µ  int rc = SQLITE_OK;  ÙI  /* If we have any lock, then the lock file already exists.  All we haveÙ;  ** to do is adjust our internal record of the lock level.¤  */Ù#  if( pFile->eFileLock > NO_LOCK ){Ù!    pFile->eFileLock = eFileLock;Ù5    /* Always update the timestamp on the old file */±#ifdef HAVE_UTIME»    utime(zLockFile, NULL);¥#else¼    utimes(zLockFile, NULL);¦#endifµ    return SQLITE_OK;£  }¢  ¾  /* grab an exclusive lock */Ù   rc = osMkdir(zLockFile, 0777);­  if( rc<0 ){Ù2    /* failed to open/create the lock directory */·    int tErrno = errno;»    if( EEXIST == tErrno ){·      rc = SQLITE_BUSY;¬    } else {Ù@      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);¼      if( rc!=SQLITE_BUSY ){Ù&        storeLastErrno(pFile, tErrno);§      }¥    }®    return rc;¤  } ¢  Ù*  /* got it, set the type and return ok */¿  pFile->eFileLock = eFileLock;¬  return rc;¡} ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢**Ù@** When the locking level reaches NO_LOCK, delete the lock file.¢*/Ù;static int dotlockUnlock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;Ù2  char *zLockFile = (char *)pFile->lockingContext;©  int rc; ²  assert( pFile );ÙJ  OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,Ù+           pFile->eFileLock, osGetpid(0)));Ù#  assert( eFileLock<=SHARED_LOCK );¢  ¹  /* no-op if possible */Ù$  if( pFile->eFileLock==eFileLock ){µ    return SQLITE_OK;£  } ÙE  /* To downgrade to shared, simply update our internal notion of theÙ8  ** lock state.  No need to mess with the file on disk.¤  */¿  if( eFileLock==SHARED_LOCK ){Ù#    pFile->eFileLock = SHARED_LOCK;µ    return SQLITE_OK;£  }¢  Ù:  /* To fully unlock the database, delete the lock file */¿  assert( eFileLock==NO_LOCK );º  rc = osRmdir(zLockFile);­  if( rc<0 ){·    int tErrno = errno;¹    if( tErrno==ENOENT ){µ      rc = SQLITE_OK;ª    }else{¿      rc = SQLITE_IOERR_UNLOCK;Ù$      storeLastErrno(pFile, tErrno);¥    }¯    return rc; £  }½  pFile->eFileLock = NO_LOCK;³  return SQLITE_OK;¡} ¢/*ÙF** Close a file.  Make sure the lock has been released before closing.¢*/Ù+static int dotlockClose(sqlite3_file *id) {Ù"  unixFile *pFile = (unixFile*)id;²  assert( id!=0 );½  dotlockUnlock(id, NO_LOCK);Ù&  sqlite3_free(pFile->lockingContext);»  return closeUnixFile(id);¡}ÙO/****************** End of the dot-file lock implementation *******************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO************************** Begin flock Locking ********************************¢**Ù2** Use the flock() system call to do file locking.¢**Ù?** flock() locking is like dot-file locking in that the variousÙC** fine-grain locking levels supported by SQLite are collapsed intoÙB** a single exclusive lock.  In other words, SHARED, RESERVED, andÙA** PENDING locks are the same thing as an EXCLUSIVE lock.  SQLiteÙA** still works when you do this, but concurrency is reduced sinceÙ?** only a single process can be reading the database at a time.¢**ÙA** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off¢*/¿#if SQLITE_ENABLE_LOCKING_STYLE ¢/*Ù+** Retry flock() calls that fail with EINTR¢*/¬#ifdef EINTRÙ(static int robust_flock(int fd, int op){©  int rc;Ù8  do{ rc = flock(fd,op); }while( rc<0 && errno==EINTR );¬  return rc;¡}¥#elseÙ%# define robust_flock(a,b) flock(a,b)¦#endif¥      ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙJ** file by this or any other process. If such a lock is held, set *pResOutÙK** to a non-zero value otherwise *pResOut is set to zero.  The return valueÙG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ÙBstatic int flockCheckReservedLock(sqlite3_file *id, int *pResOut){µ  int rc = SQLITE_OK;³  int reserved = 0;Ù"  unixFile *pFile = (unixFile*)id;¢  Ù<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ²  assert( pFile );¢  Ù;  /* Check if a thread in this process holds such a lock */Ù%  if( pFile->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }¢  Ù5  /* Otherwise see if some other process holds it. */²  if( !reserved ){Ù!    /* attempt to get the lock */Ù8    int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);¯    if( !lrc ){Ù#      /* got the lock, unlock it */Ù,      lrc = robust_flock(pFile->h, LOCK_UN);²      if ( lrc ) {»        int tErrno = errno;Ù)        /* unlock failed with an error */Ù#        lrc = SQLITE_IOERR_UNLOCK; Ù&        storeLastErrno(pFile, tErrno);±        rc = lrc;§      }¬    } else {¹      int tErrno = errno;³      reserved = 1;Ù/      /* someone else might have it reserved */ÙB      lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); ¿      if( IS_LOCK_ERROR(lrc) ){Ù&        storeLastErrno(pFile, tErrno);±        rc = lrc;§      }¥    }£  }ÙG  OSTRACE(("TEST WR-LOCK %d %d %d (flock)\n", pFile->h, rc, reserved)); Ù&#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORSÙ$  if( (rc & 0xff) == SQLITE_IOERR ){³    rc = SQLITE_OK;¯    reserved=1;£  }Ù,#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */¶  *pResOut = reserved;¬  return rc;¡} ¢/*ÙE** Lock the file with the lock specified by parameter eFileLock - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙF** flock() only really support EXCLUSIVE locks.  We track intermediateÙE** lock states in the sqlite3_file structure, but all locks SHARED orÙH** above are really EXCLUSIVE locks and exclude all other processes from³** access the file.¢**ÙE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ù$** routine to lower a locking level.¢*/Ù7static int flockLock(sqlite3_file *id, int eFileLock) {µ  int rc = SQLITE_OK;Ù"  unixFile *pFile = (unixFile*)id; ²  assert( pFile ); Ù2  /* if we already have a lock, it is exclusive.  Ù1  ** Just adjust level and punt on outta here. */Ù#  if (pFile->eFileLock > NO_LOCK) {Ù!    pFile->eFileLock = eFileLock;µ    return SQLITE_OK;£  }¢  ¾  /* grab an exclusive lock */¢  Ù2  if (robust_flock(pFile->h, LOCK_EX | LOCK_NB)) {·    int tErrno = errno;Ù"    /* didn't get, must be busy */Ù>    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);¼    if( IS_LOCK_ERROR(rc) ){Ù$      storeLastErrno(pFile, tErrno);¥    }ª  } else {Ù,    /* got it, set the type and return ok */Ù!    pFile->eFileLock = eFileLock;£  }ÙJ  OSTRACE(("LOCK    %d %s %s (flock)\n", pFile->h, azFileLock(eFileLock), Ù-           rc==SQLITE_OK ? "ok" : "failed"));Ù&#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORSÙ$  if( (rc & 0xff) == SQLITE_IOERR ){µ    rc = SQLITE_BUSY;£  }Ù,#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */¬  return rc;¡}  ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢*/Ù9static int flockUnlock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;¢  ²  assert( pFile );ÙH  OSTRACE(("UNLOCK  %d %d was %d pid=%d (flock)\n", pFile->h, eFileLock,Ù+           pFile->eFileLock, osGetpid(0)));Ù#  assert( eFileLock<=SHARED_LOCK );¢  ¹  /* no-op if possible */Ù$  if( pFile->eFileLock==eFileLock ){µ    return SQLITE_OK;£  }¢  ÙB  /* shared can just be set because we always have an exclusive */¿  if (eFileLock==SHARED_LOCK) {Ù!    pFile->eFileLock = eFileLock;µ    return SQLITE_OK;£  }¢  »  /* no, really, unlock. */Ù(  if( robust_flock(pFile->h, LOCK_UN) ){Ù&#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORSµ    return SQLITE_OK;Ù,#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */¿    return SQLITE_IOERR_UNLOCK;¨  }else{¿    pFile->eFileLock = NO_LOCK;µ    return SQLITE_OK;£  }¡} ¢/*°** Close a file.¢*/Ù)static int flockClose(sqlite3_file *id) {²  assert( id!=0 );»  flockUnlock(id, NO_LOCK);»  return closeUnixFile(id);¡} Ù6#endif /* SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORK */ ÙO/******************* End of the flock lock implementation *********************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO************************ Begin Named Semaphore Locking ************************¢**Ù8** Named semaphore locking is only supported on VxWorks.¢**ÙF** Semaphore locking is like dot-lock and flock in that it really onlyÙG** supports EXCLUSIVE locking.  Only a single process can read or writeÙH** the database file at a time.  This reduces potential concurrency, butÙ-** makes the lock implementation much easier.¢*/®#if OS_VXWORKS ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙJ** file by this or any other process. If such a lock is held, set *pResOutÙK** to a non-zero value otherwise *pResOut is set to zero.  The return valueÙG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ÙBstatic int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {µ  int rc = SQLITE_OK;³  int reserved = 0;Ù"  unixFile *pFile = (unixFile*)id; Ù<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ²  assert( pFile ); Ù;  /* Check if a thread in this process holds such a lock */Ù%  if( pFile->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }¢  Ù5  /* Otherwise see if some other process holds it. */²  if( !reserved ){Ù&    sem_t *pSem = pFile->pInode->pSem; Ù     if( sem_trywait(pSem)==-1 ){¹      int tErrno = errno;½      if( EAGAIN != tErrno ){ÙO        rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);Ù&        storeLastErrno(pFile, tErrno);®      } else {Ù>        /* someone else has the lock when we are in NO_LOCK */Ù4        reserved = (pFile->eFileLock < SHARED_LOCK);§      }ª    }else{Ù*      /* we could have it if we want it */µ      sem_post(pSem);¥    }£  }ÙE  OSTRACE(("TEST WR-LOCK %d %d %d (sem)\n", pFile->h, rc, reserved)); ¶  *pResOut = reserved;¬  return rc;¡} ¢/*ÙE** Lock the file with the lock specified by parameter eFileLock - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙN** Semaphore locks only really support EXCLUSIVE locks.  We track intermediateÙE** lock states in the sqlite3_file structure, but all locks SHARED orÙH** above are really EXCLUSIVE locks and exclude all other processes from³** access the file.¢**ÙE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ù$** routine to lower a locking level.¢*/Ù6static int semXLock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;Ù$  sem_t *pSem = pFile->pInode->pSem;µ  int rc = SQLITE_OK; Ù2  /* if we already have a lock, it is exclusive.  Ù1  ** Just adjust level and punt on outta here. */Ù#  if (pFile->eFileLock > NO_LOCK) {Ù!    pFile->eFileLock = eFileLock;³    rc = SQLITE_OK;¶    goto sem_end_lock;£  }¢  Ù<  /* lock semaphore now but bail out when already locked. */¾  if( sem_trywait(pSem)==-1 ){µ    rc = SQLITE_BUSY;¶    goto sem_end_lock;£  } Ù*  /* got it, set the type and return ok */¿  pFile->eFileLock = eFileLock; ® sem_end_lock:¬  return rc;¡} ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢*/Ù8static int semXUnlock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;Ù$  sem_t *pSem = pFile->pInode->pSem; ²  assert( pFile );±  assert( pSem );ÙF  OSTRACE(("UNLOCK  %d %d was %d pid=%d (sem)\n", pFile->h, eFileLock,Ù+           pFile->eFileLock, osGetpid(0)));Ù#  assert( eFileLock<=SHARED_LOCK );¢  ¹  /* no-op if possible */Ù$  if( pFile->eFileLock==eFileLock ){µ    return SQLITE_OK;£  }¢  ÙB  /* shared can just be set because we always have an exclusive */¿  if (eFileLock==SHARED_LOCK) {Ù!    pFile->eFileLock = eFileLock;µ    return SQLITE_OK;£  }¢  º  /* no, really unlock. */½  if ( sem_post(pSem)==-1 ) {»    int rc, tErrno = errno;Ù@    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);¼    if( IS_LOCK_ERROR(rc) ){Ù$      storeLastErrno(pFile, tErrno);¥    }¯    return rc; £  }½  pFile->eFileLock = NO_LOCK;³  return SQLITE_OK;¡} ¢/*± ** Close a file.£ */Ù(static int semXClose(sqlite3_file *id) {«  if( id ){Ù$    unixFile *pFile = (unixFile*)id;¼    semXUnlock(id, NO_LOCK);´    assert( pFile );µ    unixEnterMutex();¼    releaseInodeInfo(pFile);µ    unixLeaveMutex();¶    closeUnixFile(id);£  }³  return SQLITE_OK;¡} ·#endif /* OS_VXWORKS */¢/*Ù8** Named semaphore locking is only available on VxWorks.¢**ÙO*************** End of the named semaphore lock implementation ****************ÙO******************************************************************************/  ÙO/******************************************************************************ÙO*************************** Begin AFP Locking *********************************¢**ÙG** AFP is the Apple Filing Protocol.  AFP is a network filesystem foundÙ3** on Apple Macintosh computers - both OS9 and OSX.¢**ÙH** Third-party implementations of AFP are available.  But this code hereµ** only works on OSX.¢*/ Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE¢/*ÙG** The afpLockingContext structure contains all afp lock specific state¢*/Ù3typedef struct afpLockingContext afpLockingContext;ºstruct afpLockingContext {¯  int reserved;Ù=  const char *dbPath;             /* Name of the open file */¢}; ·struct ByteRangeLockPB2¡{ÙF  unsigned long long offset;        /* offset to first byte to lock */Ù>  unsigned long long length;        /* nbr of bytes to lock */ÙN  unsigned long long retRangeStart; /* nbr of 1st byte locked if successful */Ù>  unsigned char unLockFlag;         /* 1 = unlock, 0 = lock */ÙN  unsigned char startEndFlag;       /* 1=rel to end of fork, 0=rel to start */ÙK  int fd;                           /* file desc to assoc this lock with */¢}; ÙO#define afpfsByteRangeLock2FSCTL        _IOWR('z', 23, struct ByteRangeLockPB2) ¢/*ÙC** This is a utility for setting or clearing a bit-range lock on an²** AFP filesystem.£** Ù7** Return SQLITE_OK on success, SQLITE_BUSY on failure.¢*/¶static int afpSetLock(ÙP  const char *path,              /* Name of the file to be locked or unlocked */ÙC  unixFile *pFile,               /* Open file descriptor on path */Ù>  unsigned long long offset,     /* First byte to be locked */Ù>  unsigned long long length,     /* Number of bytes to lock */ÙM  int setLockFlag                /* True to set lock.  False to clear lock */¢){½  struct ByteRangeLockPB2 pb;ª  int err;¢  Ù&  pb.unLockFlag = setLockFlag ? 0 : 1;¶  pb.startEndFlag = 0;µ  pb.offset = offset;¶  pb.length = length; ³  pb.fd = pFile->h;¢  Ù<  OSTRACE(("AFPSETLOCK [%s] for %d%s in range %llx:%llx\n", ÙE    (setLockFlag?"ON":"OFF"), pFile->h, (pb.fd==-1?"[testval-1]":""),µ    offset, length));Ù6  err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0);²  if ( err==-1 ) {«    int rc;·    int tErrno = errno;Ù9    OSTRACE(("AFPSETLOCK failed to fsctl() '%s' %d %s\n",Ù.             path, tErrno, strerror(tErrno)));Ù$#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORSµ    rc = SQLITE_BUSY;¥#elseÙ*    rc = sqliteErrorFromPosixError(tErrno,ÙK                    setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);Ù*#endif /* SQLITE_IGNORE_AFP_LOCK_ERRORS */¼    if( IS_LOCK_ERROR(rc) ){Ù$      storeLastErrno(pFile, tErrno);¥    }®    return rc;ª  } else {µ    return SQLITE_OK;£  }¡} ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙJ** file by this or any other process. If such a lock is held, set *pResOutÙK** to a non-zero value otherwise *pResOut is set to zero.  The return valueÙG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/Ù@static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){µ  int rc = SQLITE_OK;³  int reserved = 0;Ù"  unixFile *pFile = (unixFile*)id;½  afpLockingContext *context;¢  Ù<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );¢  ²  assert( pFile );Ù8  context = (afpLockingContext *) pFile->lockingContext;º  if( context->reserved ){±    *pResOut = 1;µ    return SQLITE_OK;£  }ÙH  unixEnterMutex(); /* Because pFile->pInode is shared across threads */¢  Ù;  /* Check if a thread in this process holds such a lock */Ù-  if( pFile->pInode->eFileLock>SHARED_LOCK ){±    reserved = 1;£  }¢  Ù2  /* Otherwise see if some other process holds it.¥   */²  if( !reserved ){Ù     /* lock the RESERVED byte */ÙG    int lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);  ¹    if( SQLITE_OK==lrc ){ÙJ      /* if we succeeded in taking the reserved lock, unlock it to restore¾      ** the original state */ÙD      lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);¬    } else {ÙG      /* if we failed to get the lock then someone else must have it */³      reserved = 1;¥    }½    if( IS_LOCK_ERROR(lrc) ){­      rc=lrc;¥    }£  }¢  ³  unixLeaveMutex();ÙE  OSTRACE(("TEST WR-LOCK %d %d %d (afp)\n", pFile->h, rc, reserved));¢  ¶  *pResOut = reserved;¬  return rc;¡} ¢/*ÙE** Lock the file with the lock specified by parameter eFileLock - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ù$** routine to lower a locking level.¢*/Ù4static int afpLock(sqlite3_file *id, int eFileLock){µ  int rc = SQLITE_OK;Ù"  unixFile *pFile = (unixFile*)id;Ù(  unixInodeInfo *pInode = pFile->pInode;ÙK  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;¢  ²  assert( pFile );ÙB  OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (afp)\n", pFile->h,Ù?           azFileLock(eFileLock), azFileLock(pFile->eFileLock),ÙJ           azFileLock(pInode->eFileLock), pInode->nShared , osGetpid(0))); ÙG  /* If there is already a lock of this type or more restrictive on theÙD  ** unixFile, do nothing. Don't use the afp_end_lock: exit path, asÙ-  ** unixEnterMutex() hasn't been called yet.¤  */Ù$  if( pFile->eFileLock>=eFileLock ){ÙA    OSTRACE(("LOCK    %d %s ok (already held) (afp)\n", pFile->h,Ù#           azFileLock(eFileLock)));µ    return SQLITE_OK;£  } Ù.  /* Make sure the locking sequence is correctÙJ  **  (1) We never move from unlocked to anything higher than shared lock.Ù9  **  (2) SQLite never explicitly requests a pendig lock.ÙH  **  (3) A shared lock is always held when a reserve lock is requested.¤  */Ù@  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );Ù$  assert( eFileLock!=PENDING_LOCK );ÙF  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );¢  ÙH  /* This mutex is needed because pFile->pInode is shared across threads¤  */³  unixEnterMutex();¹  pInode = pFile->pInode; ÙG  /* If some thread using this PID has a lock via a different unixFile*Ù;  ** handle that precludes the requested lock, return BUSY.¤  */Ù.  if( (pFile->eFileLock!=pInode->eFileLock && ÙB       (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))§     ){µ    rc = SQLITE_BUSY;¶    goto afp_end_lock;£  }¢  ÙJ  /* If a SHARED lock is requested, and some thread using this PID alreadyÙG  ** has a SHARED or RESERVED lock, then increment reference counts and¶  ** return SQLITE_OK.¤  */Ù   if( eFileLock==SHARED_LOCK && ÙL     (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){Ù%    assert( eFileLock==SHARED_LOCK );Ù"    assert( pFile->eFileLock==0 );Ù     assert( pInode->nShared>0 );Ù#    pFile->eFileLock = SHARED_LOCK;¶    pInode->nShared++;´    pInode->nLock++;¶    goto afp_end_lock;£  }¤    ÙG  /* A PENDING lock is needed before acquiring a SHARED lock and beforeÙH  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will±  ** be released.¤  */½  if( eFileLock==SHARED_LOCK ÙE      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)¤  ){¯    int failed;ÙD    failed = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 1);±    if (failed) {²      rc = failed;¸      goto afp_end_lock;¥    }£  }¢  ÙC  /* If control gets to this point, then actually go ahead and makeÙ3  ** operating system calls for the specified lock.¤  */¿  if( eFileLock==SHARED_LOCK ){Ù"    int lrc1, lrc2, lrc1Errno = 0;²    long lk, mask;¤    Ù!    assert( pInode->nShared==0 );Ù#    assert( pInode->eFileLock==0 );¨        Ù:    mask = (sizeof(long)==8) ? LARGEST_INT64 : 0x7fffffff;Ù+    /* Now get the read-lock SHARED_LOCK */ÙJ    /* note that the quality of the randomness doesn't matter that much */³    lk = random(); Ù7    pInode->sharedByte = (lk & mask)%(SHARED_SIZE - 1);Ù.    lrc1 = afpSetLock(context->dbPath, pFile, Ù1          SHARED_FIRST+pInode->sharedByte, 1, 1);¾    if( IS_LOCK_ERROR(lrc1) ){Ù#      lrc1Errno = pFile->lastErrno;¥    }Ù)    /* Drop the temporary PENDING lock */ÙB    lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);¤    ¿    if( IS_LOCK_ERROR(lrc1) ) {Ù'      storeLastErrno(pFile, lrc1Errno);°      rc = lrc1;¸      goto afp_end_lock;Ù%    } else if( IS_LOCK_ERROR(lrc2) ){°      rc = lrc2;¸      goto afp_end_lock;Ù$    } else if( lrc1 != SQLITE_OK ) {°      rc = lrc1;¬    } else {Ù%      pFile->eFileLock = SHARED_LOCK;¶      pInode->nLock++;º      pInode->nShared = 1;¥    }Ù=  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){ÙE    /* We are trying for an exclusive lock but another thread in thisÙ7     ** same process is still holding a shared lock. */µ    rc = SQLITE_BUSY;¨  }else{Ù?    /* The request was for a RESERVED or EXCLUSIVE lock.  It isÙA    ** assumed that there is a SHARED or greater lock on the file¯    ** already.¦    */³    int failed = 0;Ù"    assert( 0!=pFile->eFileLock );ÙI    if (eFileLock >= RESERVED_LOCK && pFile->eFileLock < RESERVED_LOCK) {Ù%        /* Acquire a RESERVED lock */ÙH        failed = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);´      if( !failed ){¾        context->reserved = 1;§      }¥    }Ù1    if (!failed && eFileLock == EXCLUSIVE_LOCK) {Ù%      /* Acquire an EXCLUSIVE lock */¨        ÙH      /* Remove the shared lock before trying the range.  we'll need to ÙC      ** reestablish the shared lock if we can't get the  afpUnlock¨      */ÙF      if( !(failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST +Ù6                         pInode->sharedByte, 1, 0)) ){Ù         int failed2 = SQLITE_OK;Ù:        /* now attemmpt to get the exclusive lock range */ÙB        failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST, Ù/                               SHARED_SIZE, 1);ÙD        if( failed && (failed2 = afpSetLock(context->dbPath, pFile, ÙC                       SHARED_FIRST + pInode->sharedByte, 1, 1)) ){ÙK          /* Can't reestablish the shared lock.  Sqlite can't deal, this isÙ!          ** a critical I/O error¬          */Ù=          rc = ((failed & 0xff) == SQLITE_IOERR) ? failed2 : Ù!               SQLITE_IOERR_LOCK;¼          goto afp_end_lock;ª        } ¬      }else{µ        rc = failed; §      }¥    }±    if( failed ){²      rc = failed;¥    }£  }¢  ¶  if( rc==SQLITE_OK ){Ù!    pFile->eFileLock = eFileLock;Ù"    pInode->eFileLock = eFileLock;Ù(  }else if( eFileLock==EXCLUSIVE_LOCK ){Ù$    pFile->eFileLock = PENDING_LOCK;Ù%    pInode->eFileLock = PENDING_LOCK;£  }¢  ­afp_end_lock:³  unixLeaveMutex();ÙH  OSTRACE(("LOCK    %d %s %s (afp)\n", pFile->h, azFileLock(eFileLock), Ù+         rc==SQLITE_OK ? "ok" : "failed"));¬  return rc;¡} ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢*/Ù7static int afpUnlock(sqlite3_file *id, int eFileLock) {µ  int rc = SQLITE_OK;Ù"  unixFile *pFile = (unixFile*)id;¸  unixInodeInfo *pInode;ÙK  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;µ  int skipShared = 0;²#ifdef SQLITE_TEST³  int h = pFile->h;¦#endif ²  assert( pFile );ÙM  OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\n", pFile->h, eFileLock,ÙN           pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,¹           osGetpid(0))); Ù#  assert( eFileLock<=SHARED_LOCK );Ù$  if( pFile->eFileLock<=eFileLock ){µ    return SQLITE_OK;£  }³  unixEnterMutex();¹  pInode = pFile->pInode;¿  assert( pInode->nShared!=0 );Ù%  if( pFile->eFileLock>SHARED_LOCK ){Ù2    assert( pInode->eFileLock==pFile->eFileLock );½    SimulateIOErrorBenign(1);½    SimulateIOError( h=(-1) )½    SimulateIOErrorBenign(0);¤    ³#ifdef SQLITE_DEBUGÙ?    /* When reducing a lock such that other processes can startÙ:    ** reading the database file again, make sure that theÙB    ** transaction counter was updated if any part of the databaseÙ@    ** file changed.  If the transaction counter is not updated,Ù@    ** other connections to the same file might not realize thatÙC    ** the file has changed and hence might not know to flush theirÙH    ** cache.  The use of a stale cache can lead to database corruption.¦    */Ù#    assert( pFile->inNormalWrite==0Ù            || pFile->dbUpdate==0Ù(           || pFile->transCntrChng==1 );½    pFile->inNormalWrite = 0;¦#endif¤    Ù+    if( pFile->eFileLock==EXCLUSIVE_LOCK ){ÙL      rc = afpSetLock(context->dbPath, pFile, SHARED_FIRST, SHARED_SIZE, 0);ÙK      if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1) ){Ù<        /* only re-establish the shared lock if necessary */Ù=        int sharedLockByte = SHARED_FIRST+pInode->sharedByte;ÙF        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);®      } else {·        skipShared = 1;§      }¥    }Ù:    if( rc==SQLITE_OK && pFile->eFileLock>=PENDING_LOCK ){ÙB      rc = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);¦    } ÙP    if( rc==SQLITE_OK && pFile->eFileLock>=RESERVED_LOCK && context->reserved ){ÙC      rc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);±      if( !rc ){ ¿        context->reserved = 0; §      }¥    }ÙH    if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1)){Ù&      pInode->eFileLock = SHARED_LOCK;¥    }£  }Ù,  if( rc==SQLITE_OK && eFileLock==NO_LOCK ){ ÙD    /* Decrement the shared lock counter.  Release the lock using anÙG    ** OS call only when all threads in this same process have released°    ** the lock.¦    */ÙH    unsigned long long sharedLockByte = SHARED_FIRST+pInode->sharedByte;¶    pInode->nShared--;½    if( pInode->nShared==0 ){¿      SimulateIOErrorBenign(1);¿      SimulateIOError( h=(-1) )¿      SimulateIOErrorBenign(0);¸      if( !skipShared ){ÙF        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);§      }°      if( !rc ){Ù$        pInode->eFileLock = NO_LOCK;Ù#        pFile->eFileLock = NO_LOCK;§      }¥    }¸    if( rc==SQLITE_OK ){¶      pInode->nLock--;Ù!      assert( pInode->nLock>=0 );½      if( pInode->nLock==0 ){¿        closePendingFds(pFile);§      }¥    }£  }¢  ³  unixLeaveMutex();Ù3  if( rc==SQLITE_OK ) pFile->eFileLock = eFileLock;¬  return rc;¡} ¢/*Ù7** Close a file & cleanup AFP specific locking context ¢*/Ù'static int afpClose(sqlite3_file *id) {µ  int rc = SQLITE_OK;Ù"  unixFile *pFile = (unixFile*)id;²  assert( id!=0 );¹  afpUnlock(id, NO_LOCK);³  unixEnterMutex();Ù.  if( pFile->pInode && pFile->pInode->nLock ){ÙJ    /* If there are outstanding locks, do not actually close the file justÙG    ** yet because that would clear those locks.  Instead, add the fileÙL    ** descriptor to pInode->aPending.  It will be automatically closed whenÙ     ** the last lock is cleared.¦    */¸    setPendingFd(pFile);£  }º  releaseInodeInfo(pFile);Ù&  sqlite3_free(pFile->lockingContext);¹  rc = closeUnixFile(id);³  unixLeaveMutex();¬  return rc;¡} Ù>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */¢/*ÙG** The code above is the AFP lock implementation.  The code is specificÙG** to MacOSX and does not work on other unix platforms.  No alternativeÙE** is available.  If you don't compile for a mac, then the "unix-afp"¸** VFS is not available.¢**ÙO********************* End of the AFP lock implementation **********************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO*************************** Begin NFS Locking ********************************/ Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE¢/*ÙM ** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ* ** must be either NO_LOCK or SHARED_LOCK.£ **ÙF ** If the locking level of the file descriptor is already at or belowÙ9 ** the requested locking level, this routine is a no-op.£ */Ù6static int nfsUnlock(sqlite3_file *id, int eFileLock){Ù'  return posixUnlock(id, eFileLock, 1);¡} Ù>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */¢/*ÙG** The code above is the NFS lock implementation.  The code is specificÙG** to MacOSX and does not work on other unix platforms.  No alternative²** is available.  ¢**ÙO********************* End of the NFS lock implementation **********************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO**************** Non-locking sqlite3_file methods *****************************¢**ÙE** The next division contains implementations for all methods of the ÙC** sqlite3_file object other than the locking methods.  The lockingÙB** methods were defined in divisions above (one locking method perÙA** division).  Those methods that are common to all locking modesÙ*** are gather together into this division.¢*/ ¢/*ÙC** Seek to the offset passed as the second argument, then read cnt Ù=** bytes into pBuf. Return the number of bytes actually read.¢**ÙB** NB:  If you define USE_PREAD or USE_PREAD64, then it might alsoÙD** be necessary to define _XOPEN_SOURCE to be 500.  This varies fromÙA** one system to another.  Since SQLite does not define USE_PREADÙG** in any form by default, we will not attempt to define _XOPEN_SOURCE.¿** See tickets #2741 and #2681.¢**ÙI** To avoid stomping the errno value on a failed read the lastErrno value»** is set before returning.¢*/ÙPstatic int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){ª  int got;°  int prior = 0;Ù2#if (!defined(USE_PREAD) && !defined(USE_PREAD64))°  i64 newOffset;¦#endif®  TIMER_START;¿  assert( cnt==(cnt&0x1ffff) );´  assert( id->h>2 );¥  do{¶#if defined(USE_PREAD)Ù,    got = osPread(id->h, pBuf, cnt, offset);Ù     SimulateIOError( got = -1 );º#elif defined(USE_PREAD64)Ù.    got = osPread64(id->h, pBuf, cnt, offset);Ù     SimulateIOError( got = -1 );¥#elseÙ/    newOffset = lseek(id->h, offset, SEEK_SET);Ù&    SimulateIOError( newOffset = -1 );¶    if( newOffset<0 ){Ù+      storeLastErrno((unixFile*)id, errno);°      return -1;¥    }Ù#    got = osRead(id->h, pBuf, cnt);¦#endif¹    if( got==cnt ) break;°    if( got<0 ){Ù.      if( errno==EINTR ){ got = 1; continue; }°      prior = 0;Ù,      storeLastErrno((unixFile*)id,  errno);¬      break;¶    }else if( got>0 ){±      cnt -= got;´      offset += got;³      prior += got;Ù(      pBuf = (void*)(got + (char*)pBuf);¥    }²  }while( got>0 );¬  TIMER_END;Ù+  OSTRACE(("READ    %-3d %5d %7lld %llu\n",Ù<            id->h, got+prior, offset-prior, TIMER_ELAPSED));³  return got+prior;¡} ¢/*Ù@** Read data from a file into a buffer.  Return SQLITE_OK if allÙA** bytes were read successfully and SQLITE_IOERR if anything goes©** wrong.¢*/´static int unixRead(´  sqlite3_file *id, ®  void *pBuf, ª  int amt,¶  sqlite3_int64 offset¢){Ù#  unixFile *pFile = (unixFile *)id;ª  int got;¯  assert( id );¶  assert( offset>=0 );²  assert( amt>0 ); ÙF  /* If this is a database file (not a journal, master-journal or tempÙN  ** file), the bytes in the locking range should never be read or written. */¥#if 0Ù'  assert( pFile->pPreallocatedUnused==0Ù"       || offset>=PENDING_BYTE+512Ù#       || offset+amt<=PENDING_BYTE ¤  );¦#endif º#if SQLITE_MAX_MMAP_SIZE>0ÙF  /* Deal with as much of this read request as possible by transferingÙ5  ** data from the memory mapping using memcpy().  */¿  if( offset<pFile->mmapSize ){Ù(    if( offset+amt <= pFile->mmapSize ){Ù>      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);·      return SQLITE_OK;ª    }else{Ù+      int nCopy = pFile->mmapSize - offset;Ù@      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);Ù"      pBuf = &((u8 *)pBuf)[nCopy];³      amt -= nCopy;¶      offset += nCopy;¥    }£  }¦#endif Ù.  got = seekAndRead(pFile, offset, pBuf, amt);±  if( got==amt ){µ    return SQLITE_OK;´  }else if( got<0 ){Ù&    /* lastErrno set by seekAndRead */½    return SQLITE_IOERR_READ;¨  }else{Ù8    storeLastErrno(pFile, 0);   /* not a system error */Ù8    /* Unread parts of the buffer must be zero-filled */Ù,    memset(&((char*)pBuf)[got], 0, amt-got);Ù#    return SQLITE_IOERR_SHORT_READ;£  }¡} ¢/*ÙF** Attempt to seek the file-descriptor passed as the first argument toÙF** absolute offset iOff, then attempt to write nBuf bytes of data fromÙJ** pBuf to it. If an error occurs, return -1 and set *piErrno. Otherwise, ÙD** return the actual number of bytes written (which may be less than©** nBuf).¢*/ºstatic int seekAndWriteFd(ÙC  int fd,                         /* File descriptor to write to */ÙG  i64 iOff,                       /* File offset to begin writing at */ÙN  const void *pBuf,               /* Copy data from this buffer to the file */ÙD  int nBuf,                       /* Size of buffer pBuf in bytes */ÙI  int *piErrno                    /* OUT: Error number if error occurs */¢){ÙE  int rc = 0;                     /* Value returned by system call */ Ù!  assert( nBuf==(nBuf&0x1ffff) );±  assert( fd>2 );·  assert( piErrno!=0 );²  nBuf &= 0x1ffff;®  TIMER_START; ¶#if defined(USE_PREAD)ÙO  do{ rc = (int)osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );º#elif defined(USE_PREAD64)ÙO  do{ rc = (int)osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);¥#else¥  do{Ù*    i64 iSeek = lseek(fd, iOff, SEEK_SET);Ù"    SimulateIOError( iSeek = -1 );²    if( iSeek<0 ){®      rc = -1;¬      break;¥    }Ù!    rc = osWrite(fd, pBuf, nBuf);Ù!  }while( rc<0 && errno==EINTR );¦#endif ¬  TIMER_END;ÙJ  OSTRACE(("WRITE   %-3d %5d %7lld %llu\n", fd, rc, iOff, TIMER_ELAPSED)); ¾  if( rc<0 ) *piErrno = errno;¬  return rc;¡}  ¢/*ÙB** Seek to the offset in id->offset then read cnt bytes into pBuf.Ù@** Return the number of bytes actually read.  Update the offset.¢**ÙJ** To avoid stomping the errno value on a failed write the lastErrno value»** is set before returning.¢*/ÙMstatic int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){ÙB  return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);¡}  ¢/*ÙE** Write data from a buffer into a file.  Return SQLITE_OK on successÙ'** or some other error code on failure.¢*/µstatic int unixWrite(´  sqlite3_file *id, ´  const void *pBuf, ª  int amt,·  sqlite3_int64 offset ¢){Ù"  unixFile *pFile = (unixFile*)id;°  int wrote = 0;¯  assert( id );²  assert( amt>0 ); ÙF  /* If this is a database file (not a journal, master-journal or tempÙN  ** file), the bytes in the locking range should never be read or written. */¥#if 0Ù'  assert( pFile->pPreallocatedUnused==0Ù"       || offset>=PENDING_BYTE+512Ù#       || offset+amt<=PENDING_BYTE ¤  );¦#endif ³#ifdef SQLITE_DEBUGÙE  /* If we are doing a normal write to a database file (as opposed toÙF  ** doing a hot-journal rollback or a write to some file other than aÙA  ** normal database file) then record the fact that the databaseÙF  ** has changed.  If the transaction counter is modified, record that®  ** fact too.¤  */½  if( pFile->inNormalWrite ){Ù>    pFile->dbUpdate = 1;  /* The database has been modified */Ù'    if( offset<=24 && offset+amt>=27 ){­      int rc;¶      char oldCntr[4];¿      SimulateIOErrorBenign(1);Ù.      rc = seekAndRead(pFile, 24, oldCntr, 4);¿      SimulateIOErrorBenign(0);ÙF      if( rc!=4 || memcmp(oldCntr, &((char*)pBuf)[24-offset], 4)!=0 ){ÙL        pFile->transCntrChng = 1;  /* The transaction counter has changed */§      }¥    }£  }¦#endif Ù<#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0ÙG  /* Deal with as much of this write request as possible by transferingÙ5  ** data from the memory mapping using memcpy().  */¿  if( offset<pFile->mmapSize ){Ù(    if( offset+amt <= pFile->mmapSize ){Ù>      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);·      return SQLITE_OK;ª    }else{Ù+      int nCopy = pFile->mmapSize - offset;Ù@      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);Ù"      pBuf = &((u8 *)pBuf)[nCopy];³      amt -= nCopy;¶      offset += nCopy;¥    }£  }¦#endif¡ ÙK  while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){±    amt -= wrote;´    offset += wrote;Ù!    pBuf = &((char*)pBuf)[wrote];£  }Ù)  SimulateIOError(( wrote=(-1), amt=1 ));Ù,  SimulateDiskfullError(( wrote=0, amt=1 )); ²  if( amt>wrote ){Ù.    if( wrote<0 && pFile->lastErrno!=ENOSPC ){Ù)      /* lastErrno set by seekAndWrite */Ù       return SQLITE_IOERR_WRITE;ª    }else{Ù8      storeLastErrno(pFile, 0); /* not a system error */¹      return SQLITE_FULL;¥    }£  } ³  return SQLITE_OK;¡} ²#ifdef SQLITE_TEST¢/*ÙH** Count the number of fullsyncs and normal syncs.  This is used to testÙ=** that syncs and fullsyncs are occurring at the right times.¢*/Ù&SQLITE_API int sqlite3_sync_count = 0;Ù*SQLITE_API int sqlite3_fullsync_count = 0;¦#endif ¢/*ÙF** We do not trust systems to provide a working fdatasync().  Some do.ÙF** Others do no.  To be safe, we will stick with the (slightly slower)ÙL** fsync(). If you know that your system does support fdatasync() correctly,ÙE** then simply compile with -Dfdatasync=fdatasync or -DHAVE_FDATASYNC¢*/Ù*#if !defined(fdatasync) && !HAVE_FDATASYNC¸# define fdatasync fsync¦#endif ¢/*Ù>** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or notÙ>** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currentlyÙ6** only available on Mac OS X.  But that could change.¢*/²#ifdef F_FULLFSYNC¹# define HAVE_FULLFSYNC 1¥#else¹# define HAVE_FULLFSYNC 0¦#endif  ¢/*Ù>** The fsync() system call does not work as advertised on manyÙ?** unix systems.  The following procedure is an attempt to make²** it work better.¢**ÙB** The SQLITE_NO_SYNC macro disables all fsync()s.  This is usefulÙB** for testing when we want to run through the test suite quickly.Ù?** You are strongly advised *not* to deploy with SQLITE_NO_SYNCÙC** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crashÙ:** or power failure will likely corrupt the database file.¢**ÙF** SQLite sets the dataOnly flag if the size of the file is unchanged.ÙI** The idea behind dataOnly is that it should only write the file contentÙE** to disk, not the inode.  We only set dataOnly if the file size is ÙA** unchanged since the file size is part of the inode.  However, ÙF** Ted Ts'o tells us that fdatasync() will also write the inode if theÙG** file size has changed.  The only real difference between fdatasync()ÙD** and fsync(), Ted tells us, is that fdatasync() will not flush theÙF** inode if the mtime or owner or other inode attributes have changed.ÙF** We only care about the file size, not the other file attributes, soÙD** as far as SQLite is concerned, an fdatasync() is always adequate.ÙB** So, we always use fdatasync() if it is available, regardless ofÙ"** the value of the dataOnly flag.¢*/Ù:static int full_fsync(int fd, int fullSync, int dataOnly){©  int rc; ÙE  /* The following "ifdef/elif/else/" block has the same structure asÙE  ** the one below. It is replicated here solely to avoid cluttering Ù9  ** up the real code with the UNUSED_PARAMETER() macros.¤  */µ#ifdef SQLITE_NO_SYNC·  UNUSED_PARAMETER(fd);½  UNUSED_PARAMETER(fullSync);½  UNUSED_PARAMETER(dataOnly);´#elif HAVE_FULLFSYNC½  UNUSED_PARAMETER(dataOnly);¥#else½  UNUSED_PARAMETER(fullSync);½  UNUSED_PARAMETER(dataOnly);¦#endif Ù@  /* Record the number of times that we do a normal fsync() and ÙI  ** FULLSYNC.  This is used during testing to verify that this procedureÙ,  ** gets called with the correct arguments.¤  */²#ifdef SQLITE_TESTÙ*  if( fullSync ) sqlite3_fullsync_count++;·  sqlite3_sync_count++;¦#endif ÙC  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is aÙ?  ** no-op.  But go ahead and call fstat() to validate the fileÙ?  ** descriptor as we need a method to provoke a failure during¶  ** coverate testing.¤  */µ#ifdef SQLITE_NO_SYNC£  {´    struct stat buf;»    rc = osFstat(fd, &buf);£  }´#elif HAVE_FULLFSYNC±  if( fullSync ){Ù%    rc = osFcntl(fd, F_FULLFSYNC, 0);¨  }else{«    rc = 1;£  }ÙA  /* If the FULLFSYNC failed, fall back to attempting an fsync().ÙA  ** It shouldn't be possible for fullfsync to fail on the local Ù>  ** file system (on OSX), so failure indicates that FULLFSYNCÙ@  ** isn't supported for this file system. So, attempt an fsync ÙE  ** and (for now) ignore the overhead of a superfluous fcntl call.  Ù?  ** It'd be better to detect fullfsync support once and avoid Ù.  ** the fcntl call every time sync is called.¤  */º  if( rc ) rc = fsync(fd); ¸#elif defined(__APPLE__)ÙP  /* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctlyÙK  ** so currently we default to the macro that redefines fdatasync to fsync¤  */±  rc = fsync(fd);¦#else µ  rc = fdatasync(fd);®#if OS_VXWORKSÙ!  if( rc==-1 && errno==ENOTSUP ){³    rc = fsync(fd);£  }·#endif /* OS_VXWORKS */Ù5#endif /* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */ ¾  if( OS_VXWORKS && rc!= -1 ){«    rc = 0;£  }¬  return rc;¡} ¢/*ÙE** Open a file descriptor to the directory containing file zFilename.Ù?** If successful, *pFd is set to the opened file descriptor andÙA** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEMÙA** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined©** value.¢**Ù@** The directory file descriptor is used for only one thing - toÙE** fsync() a directory to make sure file creation and deletion eventsÙ<** are flushed to disk.  Such fsyncs are not needed on newerÙA** journaling filesystems, but are required on older filesystems.¢**ÙB** This routine can be overridden using the xSetSysCall interface.ÙC** The ability to override this routine was added in support of theÙD** chromium sandbox.  Opening a directory is a security risk (we areÙA** told) so making it overrideable allows the chromium sandbox toÙD** replace this routine with a harmless no-op.  To make this routineÙD** a no-op, replace it with a stub that returns SQLITE_OK but leavesÙ!** *pFd set to a negative number.¢**ÙB** If SQLITE_OK is returned, the caller is responsible for closingÙ*** the file descriptor *pFd using close().¢*/Ù:static int openDirectory(const char *zFilename, int *pFd){©  int ii;®  int fd = -1;Ù   char zDirname[MAX_PATHNAME+1]; Ù<  sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename);ÙA  for(ii=(int)strlen(zDirname); ii>0 && zDirname[ii]!='/'; ii--);­  if( ii>0 ){¸    zDirname[ii] = '\0';¨  }else{Ù-    if( zDirname[0]!='/' ) zDirname[0] = '.';´    zDirname[1] = 0;£  }Ù3  fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);®  if( fd>=0 ){Ù1    OSTRACE(("OPENDIR %-3d %s\n", fd, zDirname));£  }¬  *pFd = fd;¿  if( fd>=0 ) return SQLITE_OK;ÙG  return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname);¡} ¢/*ÙC** Make sure all writes to a particular file are committed to disk.¢**ÙB** If dataOnly==0 then both the file itself and its metadata (fileÙD** size, access time, etc) are synced.  If dataOnly!=0 then only the·** file data is synced.¢**ÙC** Under Unix, also make sure that the directory entry for the fileÙF** has been created by fsync-ing the directory that contains the file.ÙG** If we do not do this and we encounter a power failure, the directoryÙC** entry for the journal might not exist after we reboot.  The nextÙK** SQLite to access the file will not know that the journal exists (becauseÙM** the directory entry for the journal was never created) and the transactionÙ@** will not roll back - possibly leading to database corruption.¢*/Ù1static int unixSync(sqlite3_file *id, int flags){©  int rc;Ù"  unixFile *pFile = (unixFile*)id; Ù0  int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);Ù2  int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL; Ù?  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */Ù)  assert((flags&0x0F)==SQLITE_SYNC_NORMALÙ'      || (flags&0x0F)==SQLITE_SYNC_FULL¤  ); ÙI  /* Unix cannot, but some systems may return SQLITE_FULL from here. ThisÙ?  ** line is to test that doing so does not cause any problems.¤  */Ù.  SimulateDiskfullError( return SQLITE_FULL ); ²  assert( pFile );Ù(  OSTRACE(("SYNC    %-3d\n", pFile->h));Ù4  rc = full_fsync(pFile->h, isFullsync, isDataOnly);º  SimulateIOError( rc=1 );«  if( rc ){Ù!    storeLastErrno(pFile, errno);ÙH    return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);£  } ÙE  /* Also fsync the directory containing the file if the DIRSYNC flagÙJ  ** is set.  This is a one-time occurrence.  Many systems (examples: AIX)ÙD  ** are unable to fsync a directory, so ignore errors on the fsync.¤  */Ù,  if( pFile->ctrlFlags & UNIXFILE_DIRSYNC ){®    int dirfd;ÙJ    OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,Ù)            HAVE_FULLFSYNC, isFullsync));Ù/    rc = osOpenDirectory(pFile->zPath, &dirfd);¸    if( rc==SQLITE_OK ){¾      full_fsync(dirfd, 0, 0);Ù+      robust_close(pFile, dirfd, __LINE__);ª    }else{Ù$      assert( rc==SQLITE_CANTOPEN );µ      rc = SQLITE_OK;¥    }Ù*    pFile->ctrlFlags &= ~UNIXFILE_DIRSYNC;£  }¬  return rc;¡} ¢/*Ù,** Truncate an open file to a specified size¢*/Ù5static int unixTruncate(sqlite3_file *id, i64 nByte){Ù#  unixFile *pFile = (unixFile *)id;©  int rc;²  assert( pFile );Ù2  SimulateIOError( return SQLITE_IOERR_TRUNCATE ); ÙH  /* If the user has configured a chunk-size for this file, truncate theÙF  ** file so that it consists of an integer number of chunks (i.e. theÙJ  ** actual file size after the operation may be larger than the requested«  ** size).¤  */¹  if( pFile->szChunk>0 ){ÙK    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;£  } Ù)  rc = robust_ftruncate(pFile->h, nByte);«  if( rc ){Ù!    storeLastErrno(pFile, errno);ÙJ    return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);¨  }else{³#ifdef SQLITE_DEBUGÙG    /* If we are doing a normal write to a database file (as opposed toÙH    ** doing a hot-journal rollback or a write to some file other than aÙE    ** normal database file) and we truncate the file to zero length,ÙF    ** that effectively updates the change counter.  This might happenÙH    ** when restoring a database using the backup API from a zero-length®    ** source.¦    */Ù+    if( pFile->inNormalWrite && nByte==0 ){¿      pFile->transCntrChng = 1;¥    }¦#endif º#if SQLITE_MAX_MMAP_SIZE>0ÙJ    /* If the file was just truncated to a size smaller than the currentlyÙL    ** mapped region, reduce the effective mapping size as well. SQLite willÙM    ** use read() and write() to access data beyond this point from now on.  ¦    */Ù     if( nByte<pFile->mmapSize ){¾      pFile->mmapSize = nByte;¥    }¦#endif µ    return SQLITE_OK;£  }¡} ¢/*Ù0** Determine the current size of a file in bytes¢*/Ù6static int unixFileSize(sqlite3_file *id, i64 *pSize){©  int rc;²  struct stat buf;¯  assert( id );Ù)  rc = osFstat(((unixFile*)id)->h, &buf);º  SimulateIOError( rc=1 );®  if( rc!=0 ){Ù)    storeLastErrno((unixFile*)id, errno);¾    return SQLITE_IOERR_FSTAT;£  }·  *pSize = buf.st_size; ÙE  /* When opening a zero-size database, the findInodeInfo() procedureÙF  ** writes a single byte into that file in order to work around a bugÙI  ** in the OS-X msdos filesystem.  In order to avoid problems with upperÙG  ** layers, we need to report this file size as zero even though it is¾  ** really 1.   Ticket #3260.¤  */½  if( *pSize==1 ) *pSize = 0;  ³  return SQLITE_OK;¡} Ù5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)¢/*ÙF** Handler for proxy-locking file-control verbs.  Defined below in the½** proxying locking division.¢*/Ù5static int proxyFileControl(sqlite3_file*,int,void*);¦#endif £/* Ù@** This function is called to handle the SQLITE_FCNTL_SIZE_HINT ÙB** file-control operation.  Enlarge the database to nBytes in sizeÙC** (rounded up to the next chunk-size).  If the database is alreadyÙ-** nBytes or larger, this routine is a no-op.¢*/Ù5static int fcntlSizeHint(unixFile *pFile, i64 nByte){¹  if( pFile->szChunk>0 ){Ù:    i64 nSize;                    /* Required file size */ÙM    struct stat buf;              /* Used to hold return values of fstat() */£   Ù"    if( osFstat(pFile->h, &buf) ){Ù       return SQLITE_IOERR_FSTAT;¥    } ÙI    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;Ù!    if( nSize>(i64)buf.st_size ){ Ù9#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATEÙF      /* The code below is handling the return value of osFallocate() ÙN      ** correctly. posix_fallocate() is defined to "returns zero on success, ÙI      ** or an error number on  failure". See the manpage for details. */®      int err;©      do{ÙD        err = osFallocate(pFile->h, buf.st_size, nSize-buf.st_size);»      }while( err==EINTR );Ù*      if( err ) return SQLITE_IOERR_WRITE;¥#elseÙE      /* If the OS does not have posix_fallocate(), fake it. Write a ÙG      ** single byte to the last byte in each block that falls entirelyÙE      ** within the extended region. Then, if required, a single byteÙD      ** at offset (nSize-1), to set the size of the file correctly.ÙE      ** This is a similar technique to that used by glibc on systemsÙ2      ** that do not have a real fallocate() call.¨      */Ù>      int nBlk = buf.st_blksize;  /* File-system block size */ÙO      int nWrite = 0;             /* Number of bytes written by seekAndWrite */Ù?      i64 iWrite;                 /* Next offset to write to */ Ù2      iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;Ù$      assert( iWrite>=buf.st_size );Ù%      assert( ((iWrite+1)%nBlk)==0 );Ù9      for(/*no-op*/; iWrite<nSize+nBlk-1; iWrite+=nBlk ){Ù/        if( iWrite>=nSize ) iWrite = nSize - 1;Ù4        nWrite = seekAndWrite(pFile, iWrite, "", 1);Ù2        if( nWrite!=1 ) return SQLITE_IOERR_WRITE;§      }¦#endif¥    }£  } º#if SQLITE_MAX_MMAP_SIZE>0Ù6  if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){«    int rc;¼    if( pFile->szChunk<=0 ){Ù.      if( robust_ftruncate(pFile->h, nByte) ){Ù%        storeLastErrno(pFile, errno);ÙN        return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);§      }¥    } Ù#    rc = unixMapfile(pFile, nByte);®    return rc;£  }¦#endif ³  return SQLITE_OK;¡} ¢/*ÙE** If *pArg is initially negative then this is a query.  Set *pArg toÙJ** 1 or 0 depending on whether or not bit mask of pFile->ctrlFlags is set.¢**ÙJ** If *pArg is 0 or 1, then clear or set the mask bit of pFile->ctrlFlags.¢*/ÙHstatic void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){°  if( *pArg<0 ){Ù)    *pArg = (pFile->ctrlFlags & mask)!=0;¹  }else if( (*pArg)==0 ){¾    pFile->ctrlFlags &= ~mask;¨  }else{½    pFile->ctrlFlags |= mask;£  }¡} ¹/* Forward declaration */Ù1static int unixGetTempname(int nBuf, char *zBuf); ¢/*Ù2** Information and control of an open file handle.¢*/ÙAstatic int unixFileControl(sqlite3_file *id, int op, void *pArg){Ù"  unixFile *pFile = (unixFile*)id;¯  switch( op ){ÙC#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ù+    case SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: {Ù>      int rc = osIoctl(pFile->h, F2FS_IOC_START_ATOMIC_WRITE);Ù8      return rc ? SQLITE_IOERR_BEGIN_ATOMIC : SQLITE_OK;¥    }Ù,    case SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: {Ù?      int rc = osIoctl(pFile->h, F2FS_IOC_COMMIT_ATOMIC_WRITE);Ù9      return rc ? SQLITE_IOERR_COMMIT_ATOMIC : SQLITE_OK;¥    }Ù.    case SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: {Ù@      int rc = osIoctl(pFile->h, F2FS_IOC_ABORT_VOLATILE_WRITE);Ù;      return rc ? SQLITE_IOERR_ROLLBACK_ATOMIC : SQLITE_OK;¥    }Ù:#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */ Ù"    case SQLITE_FCNTL_LOCKSTATE: {Ù%      *(int*)pArg = pFile->eFileLock;·      return SQLITE_OK;¥    }Ù#    case SQLITE_FCNTL_LAST_ERRNO: {Ù%      *(int*)pArg = pFile->lastErrno;·      return SQLITE_OK;¥    }Ù#    case SQLITE_FCNTL_CHUNK_SIZE: {Ù$      pFile->szChunk = *(int *)pArg;·      return SQLITE_OK;¥    }Ù"    case SQLITE_FCNTL_SIZE_HINT: {­      int rc;¿      SimulateIOErrorBenign(1);Ù.      rc = fcntlSizeHint(pFile, *(i64 *)pArg);¿      SimulateIOErrorBenign(0);°      return rc;¥    }Ù$    case SQLITE_FCNTL_PERSIST_WAL: {Ù;      unixModeBit(pFile, UNIXFILE_PERSIST_WAL, (int*)pArg);·      return SQLITE_OK;¥    }Ù,    case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {Ù4      unixModeBit(pFile, UNIXFILE_PSOW, (int*)pArg);·      return SQLITE_OK;¥    }Ù     case SQLITE_FCNTL_VFSNAME: {Ù@      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);·      return SQLITE_OK;¥    }Ù%    case SQLITE_FCNTL_TEMPFILENAME: {ÙA      char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );³      if( zTFile ){Ù9        unixGetTempname(pFile->pVfs->mxPathname, zTFile);¿        *(char**)pArg = zTFile;§      }·      return SQLITE_OK;¥    }Ù"    case SQLITE_FCNTL_HAS_MOVED: {Ù(      *(int*)pArg = fileHasMoved(pFile);·      return SQLITE_OK;¥    }Ù"#ifdef SQLITE_ENABLE_SETLK_TIMEOUTÙ%    case SQLITE_FCNTL_LOCK_TIMEOUT: {Ù(      pFile->iBusyTimeout = *(int*)pArg;·      return SQLITE_OK;¥    }¦#endifº#if SQLITE_MAX_MMAP_SIZE>0Ù"    case SQLITE_FCNTL_MMAP_SIZE: {Ù!      i64 newLimit = *(i64*)pArg;¹      int rc = SQLITE_OK;Ù0      if( newLimit>sqlite3GlobalConfig.mxMmap ){Ù.        newLimit = sqlite3GlobalConfig.mxMmap;§      } ÙL      /* The value of newLimit may be eventually cast to (size_t) and passedÙK      ** to mmap(). Restrict its value to 2GB if (size_t) is not at least a¸      ** 64-bit type. */Ù+      if( newLimit>0 && sizeof(size_t)<8 ){Ù+        newLimit = (newLimit & 0x7FFFFFFF);§      } Ù'      *(i64*)pArg = pFile->mmapSizeMax;ÙO      if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){Ù&        pFile->mmapSizeMax = newLimit;Ù         if( pFile->mmapSize>0 ){¿          unixUnmapfile(pFile);Ù&          rc = unixMapfile(pFile, -1);©        }§      }°      return rc;¥    }¦#endif³#ifdef SQLITE_DEBUGÙ=    /* The pager calls this method to signal that it has doneÙB    ** a rollback and that the database is therefore unchanged andÙA    ** it hence it is OK for the transaction change counter to be±    ** unchanged.¦    */Ù%    case SQLITE_FCNTL_DB_UNCHANGED: {Ù$      ((unixFile*)id)->dbUpdate = 0;·      return SQLITE_OK;¥    }¦#endifÙ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ù(    case SQLITE_FCNTL_SET_LOCKPROXYFILE:Ù*    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {Ù*      return proxyFileControl(id,op,pArg);¥    }Ù>#endif /* SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__) */£  }¹  return SQLITE_NOTFOUND;¡} ¢/*ÙG** If pFd->sectorSize is non-zero when this function is called, it is aÙ7** no-op. Otherwise, the values of pFd->sectorSize and ÙC** pFd->deviceCharacteristics are set according to the file-system ´** characteristics. ¢**ÙG** There are two versions of this function. One for QNX and one for all±** other systems.¢*/²#ifndef __QNXNTO__Ù4static void setDeviceCharacteristics(unixFile *pFd){Ù@  assert( pFd->deviceCharacteristics==0 || pFd->sectorSize!=0 );»  if( pFd->sectorSize==0 ){ÙC#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)¬    int res;®    u32 f = 0; Ù9    /* Check for support for F2FS atomic batch writes. */Ù5    res = osIoctl(pFd->h, F2FS_IOC_GET_FEATURES, &f);Ù4    if( res==0 && (f & F2FS_FEATURE_ATOMIC_WRITE) ){Ù=      pFd->deviceCharacteristics = SQLITE_IOCAP_BATCH_ATOMIC;¥    }Ù:#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */ Ù8    /* Set the POWERSAFE_OVERWRITE flag if requested. */Ù)    if( pFd->ctrlFlags & UNIXFILE_PSOW ){ÙE      pFd->deviceCharacteristics |= SQLITE_IOCAP_POWERSAFE_OVERWRITE;¥    } Ù1    pFd->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;£  }¡}¥#else¹#include <sys/dcmd_blk.h>¸#include <sys/statvfs.h>Ù6static void setDeviceCharacteristics(unixFile *pFile){¿  if( pFile->sectorSize == 0 ){º    struct statvfs fsInfo;§       Ù4    /* Set defaults for non-supported filesystems */Ù3    pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;Ù%    pFile->deviceCharacteristics = 0;Ù-    if( fstatvfs(pFile->h, &fsInfo) == -1 ) {­      return;¥    } Ù-    if( !strcmp(fsInfo.f_basetype, "tmp") ) {Ù)      pFile->sectorSize = fsInfo.f_bsize;Ù$      pFile->deviceCharacteristics =ÙP        SQLITE_IOCAP_ATOMIC4K |       /* All ram filesystem writes are atomic */ÙN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilÙ>                                      ** the write succeeds */ÙO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindÙ<                                      ** so it is ordered */ª        0;Ù2    }else if( strstr(fsInfo.f_basetype, "etfs") ){Ù)      pFile->sectorSize = fsInfo.f_bsize;Ù$      pFile->deviceCharacteristics =Ù1        /* etfs cluster size writes are atomic */Ù<        (pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) |ÙN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilÙ>                                      ** the write succeeds */ÙO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindÙ<                                      ** so it is ordered */ª        0;Ù3    }else if( !strcmp(fsInfo.f_basetype, "qnx6") ){Ù)      pFile->sectorSize = fsInfo.f_bsize;Ù$      pFile->deviceCharacteristics =ÙL        SQLITE_IOCAP_ATOMIC |         /* All filesystem writes are atomic */ÙN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilÙ>                                      ** the write succeeds */ÙO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindÙ<                                      ** so it is ordered */ª        0;Ù3    }else if( !strcmp(fsInfo.f_basetype, "qnx4") ){Ù)      pFile->sectorSize = fsInfo.f_bsize;Ù$      pFile->deviceCharacteristics =ÙE        /* full bitset of atomics from max sector size and smaller */ÙG        ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |ÙO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindÙ<                                      ** so it is ordered */ª        0;Ù1    }else if( strstr(fsInfo.f_basetype, "dos") ){Ù)      pFile->sectorSize = fsInfo.f_bsize;Ù$      pFile->deviceCharacteristics =ÙE        /* full bitset of atomics from max sector size and smaller */ÙG        ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |ÙO        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behindÙ<                                      ** so it is ordered */ª        0;ª    }else{Ù$      pFile->deviceCharacteristics =Ù=        SQLITE_IOCAP_ATOMIC512 |      /* blocks are atomic */ÙN        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur untilÙ>                                      ** the write succeeds */ª        0;¥    }£  }ÙJ  /* Last chance verification.  If the sector size isn't a multiple of 512»  ** then it isn't valid.*/Ù%  if( pFile->sectorSize % 512 != 0 ){Ù%    pFile->deviceCharacteristics = 0;Ù3    pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;£  }¡}¦#endif ¢/*ÙE** Return the sector size in bytes of the underlying block device forÙB** the specified file. This is almost always 512 bytes, but may be»** larger for some devices.¢**ÙF** SQLite code assumes this function cannot fail. It also assumes thatÙC** if two files are created in the same file-system directory (i.e.ÙD** a database and its journal file) that the sector size will be the±** same for both.¢*/Ù,static int unixSectorSize(sqlite3_file *id){Ù   unixFile *pFd = (unixFile*)id;Ù   setDeviceCharacteristics(pFd);¹  return pFd->sectorSize;¡} ¢/*Ù2** Return the device characteristics for the file.¢**ÙL** This VFS is set up to return SQLITE_IOCAP_POWERSAFE_OVERWRITE by default.ÙI** However, that choice is controversial since technically the underlyingÙG** file system does not always provide powersafe overwrites.  (In otherÙE** words, after a power-loss event, parts of the file that were neverÙL** written might end up being altered.)  However, non-PSOW behavior is very,ÙG** very rare.  And asserting PSOW makes a large reduction in the amountÙH** of required I/O for journaling, since a lot of padding is eliminated.ÙN**  Hence, while POWERSAFE_OVERWRITE is on by default, there is a file-controlÙM** available to turn it off and URI query parameter available to turn it off.¢*/Ù7static int unixDeviceCharacteristics(sqlite3_file *id){Ù   unixFile *pFd = (unixFile*)id;Ù   setDeviceCharacteristics(pFd);Ù$  return pFd->deviceCharacteristics;¡} Ù7#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0 ¢/*¿** Return the system page size.¢**ÙK** This function should not be called directly by other code in this file. Ù:** Instead, it should be called via macro osGetpagesize().¢*/Ù!static int unixGetpagesize(void){®#if OS_VXWORKS®  return 1024;º#elif defined(_BSD_SOURCE)·  return getpagesize();¥#elseÙ$  return (int)sysconf(_SC_PAGESIZE);¦#endif¡} Ù@#endif /* !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0 */ ·#ifndef SQLITE_OMIT_WAL ¢/*Ù6** Object used to represent an shared memory buffer.  ¢**ÙF** When multiple threads all reference the same wal-index, each threadÙF** has its own unixShm object, but they all point to a single instanceÙH** of this unixShmNode object.  In other words, each wal-index is opened¹** only once per process.¢**ÙI** Each unixShmNode object is connected to a single unixInodeInfo object.ÙH** We could coalesce this object into unixInodeInfo, but that would meanÙH** every open file that does not use shared memory (in other words, mostÙE** open files) would have to carry around this extra information.  SoÙI** the unixInodeInfo object contains a pointer to this unixShmNode objectÙ:** and the unixShmNode object is created only when needed.¢**Ù;** unixMutexHeld() must be true when creating or destroyingÙ@** this object or while reading or writing the following fields:¢**¬**      nRef¢**ÙB** The following fields are read-only after the object is created:£** «**      fid±**      zFilename¢**ÙC** Either unixShmNode.mutex must be held or unixShmNode.nRef==0 andÙB** unixMutexHeld() is true when reading or writing any other fieldµ** in this structure.¢*/´struct unixShmNode {ÙH  unixInodeInfo *pInode;     /* unixInodeInfo that owns this SHM node */Ù>  sqlite3_mutex *mutex;      /* Mutex to access this object */Ù;  char *zFilename;           /* Name of the mmapped file */Ù7  int h;                     /* Open file descriptor */Ù@  int szRegion;              /* Size of shared-memory regions */Ù9  u16 nRegion;               /* Size of array apRegion */Ù4  u8 isReadonly;             /* True if read-only */Ù;  u8 isUnlocked;             /* True if no DMS lock held */ÙH  char **apRegion;           /* Array of mapped shared-memory regions */ÙM  int nRef;                  /* Number of unixShm objects pointing to this */ÙG  unixShm *pFirst;           /* All unixShm objects pointing to this */³#ifdef SQLITE_DEBUGÙ?  u8 exclMask;               /* Mask of exclusive locks held */Ù<  u8 sharedMask;             /* Mask of shared locks held */ÙB  u8 nextShmId;              /* Next available unixShm.id value */¦#endif¢}; ¢/*ÙB** Structure used internally by this VFS to record the state of anÙ!** open shared memory connection.¢**ÙG** The following fields are initialized when this object is created and¼** are read-only thereafter:¢**³**    unixShm.pFile°**    unixShm.id¢**ÙJ** All other fields are read/write.  The unixShm.pFile->mutex must be heldÙ)** while accessing any read/write fields.¢*/°struct unixShm {ÙD  unixShmNode *pShmNode;     /* The underlying unixShmNode object */ÙI  unixShm *pNext;            /* Next unixShm with the same unixShmNode */ÙH  u8 hasMutex;               /* True if holding the unixShmNode mutex */ÙO  u8 id;                     /* Id of this connection within its unixShmNode */Ù<  u16 sharedMask;            /* Mask of shared locks held */Ù?  u16 exclMask;              /* Mask of exclusive locks held */¢}; ¢/*½** Constants used for locking¢*/ÙO#define UNIX_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)         /* first lock byte */ÙN#define UNIX_SHM_DMS    (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */ ¢/*ÙG** Apply posix advisory locks for all bytes from ofst through ofst+n-1.¢**ÙE** Locks block if the mask is exactly UNIX_SHM_C and are non-blocking­** otherwise.¢*/½static int unixShmSystemLock(Ù>  unixFile *pFile,       /* Open connection to the WAL file */Ù;  int lockType,          /* F_UNLCK, F_RDLCK, or F_WRLCK */Ù>  int ofst,              /* First byte of the locking range */Ù6  int n                  /* Number of bytes to lock */¢){ÙM  unixShmNode *pShmNode; /* Apply locks to this open shared-memory segment */ÙC  struct flock f;        /* The posix advisory locking structure */Ù7  int rc = SQLITE_OK;    /* Result code form fcntl() */ ÙD  /* Access to the unixShmNode object is serialized by the caller */Ù%  pShmNode = pFile->pInode->pShmNode;ÙE  assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->mutex) ); Ù2  /* Shared locks never span more than one byte */Ù&  assert( n==1 || lockType!=F_RDLCK ); ¾  /* Locks are within range */Ù(  assert( n>=1 && n<=SQLITE_SHM_NLOCK ); ·  if( pShmNode->h>=0 ){Ù+    /* Initialize the locking parameters */¸    f.l_type = lockType;º    f.l_whence = SEEK_SET;µ    f.l_start = ofst;°    f.l_len = n;Ù8    rc = osSetPosixAdvisoryLock(pShmNode->h, &f, pFile);Ù.    rc = (rc!=(-1)) ? SQLITE_OK : SQLITE_BUSY;£  } Ù9  /* Update the global lock state and do debug tracing */³#ifdef SQLITE_DEBUG­  { u16 mask;¹  OSTRACE(("SHM-LOCK "));Ù6  mask = ofst>31 ? 0xffff : (1<<(ofst+n)) - (1<<ofst);¶  if( rc==SQLITE_OK ){¼    if( lockType==F_UNLCK ){Ù&      OSTRACE(("unlock %d ok", ofst));Ù"      pShmNode->exclMask &= ~mask;Ù$      pShmNode->sharedMask &= ~mask;Ù"    }else if( lockType==F_RDLCK ){Ù)      OSTRACE(("read-lock %d ok", ofst));Ù"      pShmNode->exclMask &= ~mask;Ù#      pShmNode->sharedMask |= mask;ª    }else{Ù"      assert( lockType==F_WRLCK );Ù*      OSTRACE(("write-lock %d ok", ofst));Ù!      pShmNode->exclMask |= mask;Ù$      pShmNode->sharedMask &= ~mask;¥    }¨  }else{¼    if( lockType==F_UNLCK ){Ù*      OSTRACE(("unlock %d failed", ofst));Ù"    }else if( lockType==F_RDLCK ){Ù$      OSTRACE(("read-lock failed"));ª    }else{Ù"      assert( lockType==F_WRLCK );Ù.      OSTRACE(("write-lock %d failed", ofst));¥    }£  }Ù'  OSTRACE((" - afterwards %03x,%03x\n",Ù6           pShmNode->sharedMask, pShmNode->exclMask));£  }¦#endif ´  return rc;        ¡} ¢/*ÙI** Return the minimum number of 32KB shm regions that should be mapped atÙH** a time, assuming that each mapping must be an integer multiple of the¼** current system page-size.¢**ÙL** Usually, this is 1. The exception seems to be systems that are configuredÙH** to use 64KB pages - in this case each mapping must cover at least two¯** shm regions.¢*/Ù%static int unixShmRegionPerMap(void){Ù7  int shmsz = 32*1024;            /* SHM region size */Ù6  int pgsz = osGetpagesize();   /* System page size */ÙF  assert( ((pgsz-1)&pgsz)==0 );   /* Page size must be a power of 2 */¼  if( pgsz<shmsz ) return 1;´  return pgsz/shmsz;¡} ¢/*ÙJ** Purge the unixShmNodeList list of all entries with unixShmNode.nRef==0.¢**ÙJ** This is not a VFS shared-memory method; it is a utility function calledÙ ** by VFS shared-memory methods.¢*/Ù(static void unixShmPurge(unixFile *pFd){Ù)  unixShmNode *p = pFd->pInode->pShmNode;¼  assert( unixMutexHeld() );Ù   if( p && ALWAYS(p->nRef==0) ){Ù+    int nShmPerMap = unixShmRegionPerMap();ª    int i;Ù%    assert( p->pInode==pFd->pInode );Ù!    sqlite3_mutex_free(p->mutex);Ù*    for(i=0; i<p->nRegion; i+=nShmPerMap){´      if( p->h>=0 ){Ù.        osMunmap(p->apRegion[i], p->szRegion);¬      }else{Ù%        sqlite3_free(p->apRegion[i]);§      }¥    }¾    sqlite3_free(p->apRegion);²    if( p->h>=0 ){Ù(      robust_close(pFd, p->h, __LINE__);°      p->h = -1;¥    }¼    p->pInode->pShmNode = 0;´    sqlite3_free(p);£  }¡} ¢/*ÙG** The DMS lock has not yet been taken on shm file pShmNode. Attempt toÙB** take it now. Return SQLITE_OK if successful, or an SQLite error²** code otherwise.¢**Ù@** If the DMS cannot be locked because this is a readonly_shm=1 Ù?** connection and no other process already holds a lock, returnÙ;** SQLITE_READONLY_CANTINIT and set pShmNode->isUnlocked=1.¢*/ÙHstatic int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){´  struct flock lock;µ  int rc = SQLITE_OK; ÙC  /* Use F_GETLK to determine the locks other processes are holdingÙE  ** on the DMS byte. If it indicates that another process is holdingÙA  ** a SHARED lock, then this process may also take a SHARED lockÙ.  ** and proceed with opening the *-shm file. ¤  **ÙC  ** Or, if no other process is holding any lock, then this processÙH  ** is the first to open it. In this case take an EXCLUSIVE lock on theÙE  ** DMS byte and truncate the *-shm file to zero bytes in size. ThenÙ0  ** downgrade to a SHARED lock on the DMS byte.¤  **ÙE  ** If another process is holding an EXCLUSIVE lock on the DMS byte,ÙE  ** return SQLITE_BUSY to the caller (it will try again). An earlierÙF  ** version of this code attempted the SHARED lock at this point. ButÙD  ** this introduced a subtle race condition: if the process holdingÙF  ** EXCLUSIVE failed just before truncating the *-shm file, then thisÙE  ** process might open and use the *-shm file without truncating it.ÙC  ** And if the *-shm file has been corrupted by a power failure orÙC  ** system crash, the database itself may also become corrupt.  */»  lock.l_whence = SEEK_SET;¾  lock.l_start = UNIX_SHM_DMS;±  lock.l_len = 1;¸  lock.l_type = F_WRLCK;Ù1  if( osFcntl(pShmNode->h, F_GETLK, &lock)!=0 ) {»    rc = SQLITE_IOERR_LOCK;Ù#  }else if( lock.l_type==F_UNLCK ){¿    if( pShmNode->isReadonly ){¿      pShmNode->isUnlocked = 1;Ù$      rc = SQLITE_READONLY_CANTINIT;ª    }else{Ù>      rc = unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1);Ù>      if( rc==SQLITE_OK && robust_ftruncate(pShmNode->h, 0) ){ÙP        rc = unixLogError(SQLITE_IOERR_SHMOPEN,"ftruncate",pShmNode->zFilename);§      }¥    }Ù#  }else if( lock.l_type==F_WRLCK ){µ    rc = SQLITE_BUSY;£  } ¶  if( rc==SQLITE_OK ){Ù;    assert( lock.l_type==F_UNLCK || lock.l_type==F_RDLCK );Ù<    rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);£  }¬  return rc;¡} ¢/*ÙH** Open a shared-memory area associated with open database file pDbFd.  Ù5** This particular implementation uses mmapped files.¢**ÙD** The file used to implement shared-memory is in the same directoryÙG** as the open database file and has the same name as the open databaseÙH** file with the "-shm" suffix added.  For example, if the database fileÙG** is "/home/user1/config.db" then the file that is created and mmappedÙB** for shared memory will be called "/home/user1/config.db-shm".  ¢**ÙD** Another approach to is to use files in /dev/shm or /dev/tmp or anÙA** some other tmpfs mount. But if a file in a different directoryÙD** from the database file is used, then differing access permissionsÙ@** or a chroot() might cause two different processes on the sameÙ@** database to end up using different files for shared memory - ÙC** meaning that their memory would not really be shared - resultingÙ?** in database corruption.  Nevertheless, this tmpfs file usageÙI** can be enabled at compile-time using -DSQLITE_SHM_DIRECTORY="/dev/shm"ÙG** or the equivalent.  The use of the SQLITE_SHM_DIRECTORY compile-timeÙG** option results in an incompatible build of SQLite;  builds of SQLiteÙG** that with differing SQLITE_SHM_DIRECTORY settings attempt to use theÙG** same database file at the same time, database corruption will likelyÙE** result. The SQLITE_SHM_DIRECTORY compile-time option is consideredÙ<** "unsupported" and may go away in a future SQLite release.¢**ÙG** When opening a new shared-memory file, if no other instances of thatÙG** file are currently open, in this process or in other processes, thenÙH** the file must be truncated to zero length or have its header cleared.¢**ÙE** If the original database file (pDbFd) is using the "unix-excl" VFSÙE** that means that an exclusive lock is held on the database file andÙF** that no other processes are able to read or write the database.  InÙD** that case, we do not really need shared memory.  No shared memoryÙJ** file is created.  The shared memory will be simulated with heap memory.¢*/Ù1static int unixOpenSharedMemory(unixFile *pDbFd){ÙC  struct unixShm *p = 0;          /* The connection to be opened */ÙC  struct unixShmNode *pShmNode;   /* The underlying mmapped file */Ù3  int rc = SQLITE_OK;             /* Result code */Ù7  unixInodeInfo *pInode;          /* The inode of fd */Ù=  char *zShm;             /* Name of the file used for SHM */ÙI  int nShmFilename;               /* Size of the SHM filename in bytes */ Ù2  /* Allocate space for the new unixShm object. */Ù%  p = sqlite3_malloc64( sizeof(*p) );Ù&  if( p==0 ) return SQLITE_NOMEM_BKPT;»  memset(p, 0, sizeof(*p));»  assert( pDbFd->pShm==0 ); ÙK  /* Check to see if a unixShmNode object already exists. Reuse an existingÙ3  ** one if present. Create a new one if necessary.¤  */³  unixEnterMutex();¹  pInode = pDbFd->pInode;¾  pShmNode = pInode->pShmNode;´  if( pShmNode==0 ){ÙK    struct stat sStat;                 /* fstat() info for database file */¼#ifndef SQLITE_SHM_DIRECTORYÙ)    const char *zBasePath = pDbFd->zPath;¦#endif ÙJ    /* Call fstat() to figure out the permissions on the database file. IfÙH    ** a new *-shm file is created, an attempt will be made to create itÙ!    ** with the same permissions.¦    */Ù$    if( osFstat(pDbFd->h, &sStat) ){¾      rc = SQLITE_IOERR_FSTAT;¸      goto shm_open_err;¥    } »#ifdef SQLITE_SHM_DIRECTORYÙ5    nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;¥#elseÙ.    nShmFilename = 6 + (int)strlen(zBasePath);¦#endifÙD    pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );¶    if( pShmNode==0 ){½      rc = SQLITE_NOMEM_BKPT;¸      goto shm_open_err;¥    }Ù8    memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);Ù5    zShm = pShmNode->zFilename = (char*)&pShmNode[1];»#ifdef SQLITE_SHM_DIRECTORYÙ)    sqlite3_snprintf(nShmFilename, zShm, Ù>                     SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",Ù;                     (u32)sStat.st_ino, (u32)sStat.st_dev);¥#elseÙ>    sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);Ù+    sqlite3FileSuffix3(pDbFd->zPath, zShm);¦#endifµ    pShmNode->h = -1;Ù'    pDbFd->pInode->pShmNode = pShmNode;Ù%    pShmNode->pInode = pDbFd->pInode;Ù)    if( sqlite3GlobalConfig.bCoreMutex ){Ù?      pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);¿      if( pShmNode->mutex==0 ){¿        rc = SQLITE_NOMEM_BKPT;º        goto shm_open_err;§      }¥    } Ù"    if( pInode->bProcessLock==0 ){ÙD      if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){ÙN        pShmNode->h = robust_open(zShm, O_RDWR|O_CREAT, (sStat.st_mode&0777));§      }º      if( pShmNode->h<0 ){ÙH        pShmNode->h = robust_open(zShm, O_RDONLY, (sStat.st_mode&0777));¼        if( pShmNode->h<0 ){Ù@          rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zShm);¼          goto shm_open_err;©        }Ù!        pShmNode->isReadonly = 1;§      } ÙH      /* If this process is running as root, make sure that the SHM fileÙO      ** is owned by the same user that owns the original database.  Otherwise,Ù8      ** the original owner will not be able to connect.¨      */Ù<      robustFchown(pShmNode->h, sStat.st_uid, sStat.st_gid); Ù1      rc = unixLockSharedMemory(pDbFd, pShmNode);ÙL      if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;¥    }£  } Ù:  /* Make the new connection a child of the unixShmNode */¹  p->pShmNode = pShmNode;³#ifdef SQLITE_DEBUGÙ   p->id = pShmNode->nextShmId++;¦#endif³  pShmNode->nRef++;²  pDbFd->pShm = p;³  unixLeaveMutex(); ÙG  /* The reference count on pShmNode has already been incremented underÙE  ** the cover of the unixEnterMutex() mutex and the pointer from theÙJ  ** new (struct unixShm) object to the pShmNode has been set. All that isÙG  ** left to do is to link the new object into the linked list startingÙN  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex «  ** mutex.¤  */Ù'  sqlite3_mutex_enter(pShmNode->mutex);¾  p->pNext = pShmNode->pFirst;·  pShmNode->pFirst = p;Ù'  sqlite3_mutex_leave(pShmNode->mutex);¬  return rc; ¾  /* Jump here on any error */­shm_open_err:ÙG  unixShmPurge(pDbFd);       /* This call frees pShmNode if required */²  sqlite3_free(p);³  unixLeaveMutex();¬  return rc;¡} ¢/*ÙH** This function is called to obtain a pointer to region iRegion of the ÙM** shared-memory associated with the database file fd. Shared-memory regions ÙJ** are numbered starting from zero. Each shared-memory region is szRegion ±** bytes in size.¢**ÙH** If an error occurs, an error code is returned and *pp is set to NULL.¢**ÙK** Otherwise, if the bExtend parameter is 0 and the requested shared-memoryÙK** region has not been allocated (by any client, including one running in aÙI** separate process), then *pp is set to NULL and SQLITE_OK returned. If ÙJ** bExtend is non-zero and the requested shared-memory region has not yet Ù4** been allocated, it is allocated by this function.¢**ÙL** If the shared-memory region has already been allocated or is allocated byÙG** this call as described above, then it is mapped into this processes ÙK** address space (if it is not already), *pp is set to point to the mapped Ù!** memory and SQLITE_OK returned.¢*/¶static int unixShmMap(ÙD  sqlite3_file *fd,               /* Handle open on database file */Ù:  int iRegion,                    /* Region to retrieve */Ù7  int szRegion,                   /* Size of regions */ÙH  int bExtend,                    /* True to extend file if necessary */Ù:  void volatile **pp              /* OUT: Mapped memory */¢){Ù"  unixFile *pDbFd = (unixFile*)fd;­  unixShm *p;¸  unixShmNode *pShmNode;µ  int rc = SQLITE_OK;Ù)  int nShmPerMap = unixShmRegionPerMap();±  int nReqRegion; ÙG  /* If the shared-memory file has not yet been opened, open it now. */·  if( pDbFd->pShm==0 ){Ù%    rc = unixOpenSharedMemory(pDbFd);Ù"    if( rc!=SQLITE_OK ) return rc;£  } ²  p = pDbFd->pShm;¹  pShmNode = p->pShmNode;Ù'  sqlite3_mutex_enter(pShmNode->mutex);½  if( pShmNode->isUnlocked ){Ù/    rc = unixLockSharedMemory(pDbFd, pShmNode);Ù)    if( rc!=SQLITE_OK ) goto shmpage_out;½    pShmNode->isUnlocked = 0;£  }ÙA  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );Ù,  assert( pShmNode->pInode==pDbFd->pInode );Ù=  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );Ù<  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 ); Ù8  /* Minimum number of regions required to be mapped. */Ù@  nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap; Ù%  if( pShmNode->nRegion<nReqRegion ){ÙA    char **apNew;                      /* New apRegion[] array */ÙG    int nByte = nReqRegion*szRegion;   /* Minimum required file size */Ù<    struct stat sStat;                 /* Used by fstat() */ Ù"    pShmNode->szRegion = szRegion; ¹    if( pShmNode->h>=0 ){ÙN      /* The requested region is not mapped into this processes address space.ÙM      ** Check to see if it has been allocated (i.e. if the wal-index file isÙ7      ** large enough to contain the requested region).¨      */Ù)      if( osFstat(pShmNode->h, &sStat) ){Ù"        rc = SQLITE_IOERR_SHMSIZE;¹        goto shmpage_out;§      }¢  Ù       if( sStat.st_size<nByte ){ÙK        /* The requested memory region does not exist. If bExtend is set toÙM        ** false, exit early. *pp will be set to NULL and SQLITE_OK returned.ª        */·        if( !bExtend ){»          goto shmpage_out;©        } ÙI        /* Alternatively, if bExtend is true, extend the file. Do this byÙC        ** writing a single byte to the end of each (OS) page beingÙH        ** allocated or extended. Technically, we need only write to theÙH        ** last page in order to extend the file. But writing to all newÙJ        ** pages forces the OS to allocate them immediately, which reducesÙL        ** the chances of SIGBUS while accessing the mapped region later on.ª        */­        else{Ù'          static const int pgsz = 4096;²          int iPg; ÙO          /* Write to the last byte of each newly allocated or extended page */Ù&          assert( (nByte % pgsz)==0 );ÙA          for(iPg=(sStat.st_size/pgsz); iPg<(nByte/pgsz); iPg++){¶            int x = 0;ÙO            if( seekAndWriteFd(pShmNode->h, iPg*pgsz + pgsz-1, "", 1, &x)!=1 ){Ù6              const char *zFile = pShmNode->zFilename;ÙF              rc = unixLogError(SQLITE_IOERR_SHMSIZE, "write", zFile);¿              goto shmpage_out;­            }«          }©        }§      }¥    } ÙL    /* Map the requested memory region into this processes address space. */Ù%    apNew = (char **)sqlite3_realloc(Ù5        pShmNode->apRegion, nReqRegion*sizeof(char *)¦    );±    if( !apNew ){Ù#      rc = SQLITE_IOERR_NOMEM_BKPT;·      goto shmpage_out;¥    }¿    pShmNode->apRegion = apNew;Ù*    while( pShmNode->nRegion<nReqRegion ){Ù%      int nMap = szRegion*nShmPerMap;¬      int i;±      void *pMem;»      if( pShmNode->h>=0 ){¾        pMem = osMmap(0, nMap,ÙE            pShmNode->isReadonly ? PROT_READ : PROT_READ|PROT_WRITE, ÙD            MAP_SHARED, pShmNode->h, szRegion*(i64)pShmNode->nRegionª        );¿        if( pMem==MAP_FAILED ){ÙN          rc = unixLogError(SQLITE_IOERR_SHMMAP, "mmap", pShmNode->zFilename);»          goto shmpage_out;©        }¬      }else{Ù*        pMem = sqlite3_malloc64(szRegion);¶        if( pMem==0 ){Ù!          rc = SQLITE_NOMEM_BKPT;»          goto shmpage_out;©        }Ù"        memset(pMem, 0, szRegion);§      } Ù"      for(i=0; i<nShmPerMap; i++){ÙM        pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];§      }Ù&      pShmNode->nRegion += nShmPerMap;¥    }£  } ¬shmpage_out:Ù"  if( pShmNode->nRegion>iRegion ){Ù&    *pp = pShmNode->apRegion[iRegion];¨  }else{¬    *pp = 0;£  }ÙC  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;Ù'  sqlite3_mutex_leave(pShmNode->mutex);¬  return rc;¡} ¢/*Ù5** Change the lock state for a shared-memory segment.¢**ÙL** Note that the relationship between SHAREd and EXCLUSIVE locks is a littleÙI** different here than in posix.  In xShmLock(), one can go from unlockedÙJ** to shared and back or from unlocked to exclusive and back.  But one mayÙ?** not go from shared to exclusive or from exclusive to shared.¢*/·static int unixShmLock(ÙJ  sqlite3_file *fd,          /* Database file holding the shared memory */ÙC  int ofst,                  /* First lock to acquire or release */ÙH  int n,                     /* Number of locks to acquire or release */Ù;  int flags                  /* What to do with the lock */¢){ÙN  unixFile *pDbFd = (unixFile*)fd;      /* Connection holding shared memory */ÙL  unixShm *p = pDbFd->pShm;             /* The shared memory being locked */ÙK  unixShm *pX;                          /* For looping over all siblings */ÙG  unixShmNode *pShmNode = p->pShmNode;  /* The underlying file iNode */Ù9  int rc = SQLITE_OK;                   /* Result code */ÙN  u16 mask;                             /* Mask of locks to take or release */ Ù.  assert( pShmNode==pDbFd->pInode->pShmNode );Ù,  assert( pShmNode->pInode==pDbFd->pInode );Ù0  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );±  assert( n>=1 );Ù6  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)Ù9       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)Ù8       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)Ù>       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );Ù6  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );Ù=  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );Ù<  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 ); Ù#  mask = (1<<(ofst+n)) - (1<<ofst);Ù#  assert( n>1 || mask==(1<<ofst) );Ù'  sqlite3_mutex_enter(pShmNode->mutex);Ù"  if( flags & SQLITE_SHM_UNLOCK ){Ù9    u16 allMask = 0; /* Mask of locks held by siblings */ Ù1    /* See if any siblings hold this same lock */Ù/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){»      if( pX==p ) continue;Ù@      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );Ù       allMask |= pX->sharedMask;¥    } Ù'    /* Unlock the system-level locks */¾    if( (mask & allMask)==0 ){ÙD      rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);ª    }else{µ      rc = SQLITE_OK;¥    } ¾    /* Undo the local locks */¸    if( rc==SQLITE_OK ){»      p->exclMask &= ~mask;½      p->sharedMask &= ~mask;¦    } Ù(  }else if( flags & SQLITE_SHM_SHARED ){ÙO    u16 allShared = 0;  /* Union of locks held by connections other than "p" */ ÙK    /* Find out which shared locks are already held by sibling connections.ÙJ    ** If any sibling already holds an exclusive lock, go ahead and return³    ** SQLITE_BUSY.¦    */Ù/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){Ù%      if( (pX->exclMask & mask)!=0 ){¹        rc = SQLITE_BUSY;®        break;§      }Ù"      allShared |= pX->sharedMask;¥    } Ù<    /* Get shared locks at the system level, if necessary */¸    if( rc==SQLITE_OK ){Ù"      if( (allShared & mask)==0 ){ÙF        rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);¬      }else{·        rc = SQLITE_OK;§      }¥    } Ù$    /* Get the local shared locks */¸    if( rc==SQLITE_OK ){¼      p->sharedMask |= mask;¥    }¨  }else{ÙG    /* Make sure no sibling connections hold locks that will block thisÙ7    ** lock.  If any do, return SQLITE_BUSY right away.¦    */Ù/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){ÙC      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){¹        rc = SQLITE_BUSY;®        break;§      }¥    }¢  ÙG    /* Get the exclusive locks at the system level.  Then if successfulÙ6    ** also mark the local connection as being locked.¦    */¸    if( rc==SQLITE_OK ){ÙD      rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);º      if( rc==SQLITE_OK ){Ù,        assert( (p->sharedMask & mask)==0 );¼        p->exclMask |= mask;§      }¥    }£  }Ù'  sqlite3_mutex_leave(pShmNode->mutex);Ù7  OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",Ù<           p->id, osGetpid(0), p->sharedMask, p->exclMask));¬  return rc;¡} ¢/*ÙA** Implement a memory barrier or memory fence on shared memory.  ¢**ÙE** All loads and stores begun before the barrier must complete beforeÙ-** any load or store begun after the barrier.¢*/»static void unixShmBarrier(ÙO  sqlite3_file *fd                /* Database file holding the shared memory */¢){·  UNUSED_PARAMETER(fd);ÙG  sqlite3MemoryBarrier();         /* compiler-defined memory barrier */ÙB  unixEnterMutex();               /* Also mutex, for redundancy */³  unixLeaveMutex();¡} ¢/*Ù?** Close a connection to shared-memory.  Delete the underlying Ù!** storage if deleteFlag is true.¢**ÙH** If there is no shared memory associated with the connection then this¿** routine is a harmless no-op.¢*/¸static int unixShmUnmap(ÙD  sqlite3_file *fd,               /* The underlying database file */ÙD  int deleteFlag                  /* Delete shared-memory if true */¢){ÙC  unixShm *p;                     /* The connection to be closed */ÙI  unixShmNode *pShmNode;          /* The underlying shared-memory file */ÙL  unixShm **pp;                   /* For looping over sibling connections */ÙD  unixFile *pDbFd;                /* The underlying database file */ ¸  pDbFd = (unixFile*)fd;²  p = pDbFd->pShm;¾  if( p==0 ) return SQLITE_OK;¹  pShmNode = p->pShmNode; Ù.  assert( pShmNode==pDbFd->pInode->pShmNode );Ù,  assert( pShmNode->pInode==pDbFd->pInode ); Ù?  /* Remove connection p from the set of connections associatedµ  ** with pShmNode */Ù'  sqlite3_mutex_enter(pShmNode->mutex);Ù;  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}±  *pp = p->pNext; ½  /* Free the connection p */²  sqlite3_free(p);²  pDbFd->pShm = 0;Ù'  sqlite3_mutex_leave(pShmNode->mutex); Ù?  /* If pShmNode->nRef has reached 0, then close the underlying¿  ** shared-memory file, too */³  unixEnterMutex();½  assert( pShmNode->nRef>0 );³  pShmNode->nRef--;º  if( pShmNode->nRef==0 ){Ù'    if( deleteFlag && pShmNode->h>=0 ){Ù$      osUnlink(pShmNode->zFilename);¥    }¸    unixShmPurge(pDbFd);£  }³  unixLeaveMutex(); ³  return SQLITE_OK;¡}  ¥#else¹# define unixShmMap     0¹# define unixShmLock    0¹# define unixShmBarrier 0¹# define unixShmUnmap   0Ù$#endif /* #ifndef SQLITE_OMIT_WAL */ º#if SQLITE_MAX_MMAP_SIZE>0¢/*Ù4** If it is currently memory mapped, unmap file pFd.¢*/Ù)static void unixUnmapfile(unixFile *pFd){¾  assert( pFd->nFetchOut==0 );¸  if( pFd->pMapRegion ){Ù3    osMunmap(pFd->pMapRegion, pFd->mmapSizeActual);¸    pFd->pMapRegion = 0;¶    pFd->mmapSize = 0;¼    pFd->mmapSizeActual = 0;£  }¡} ¢/*ÙD** Attempt to set the size of the memory mapping maintained by file ÙC** descriptor pFd to nNew bytes. Any existing mapping is discarded.¢**Ù=** If successful, this function sets the following variables:¢**¼**       unixFile.pMapRegionº**       unixFile.mmapSizeÙ **       unixFile.mmapSizeActual¢**ÙD** If unsuccessful, an error message is logged via sqlite3_log() andÙC** the three variables above are zeroed. In this case SQLite shouldÙA** continue accessing the database using the xRead() and xWrite()«** methods.¢*/ºstatic void unixRemapfile(Ù>  unixFile *pFd,                  /* File descriptor object */Ù=  i64 nNew                        /* Required mapping size */¢){¼  const char *zErr = "mmap";ÙL  int h = pFd->h;                      /* File descriptor open on db file */ÙL  u8 *pOrig = (u8 *)pFd->pMapRegion;   /* Pointer to current file mapping */ÙJ  i64 nOrig = pFd->mmapSizeActual;     /* Size of pOrig region in bytes */ÙD  u8 *pNew = 0;                        /* Location of new mapping */ÙD  int flags = PROT_READ;               /* Flags to pass to mmap() */ ¾  assert( pFd->nFetchOut==0 );¿  assert( nNew>pFd->mmapSize );Ù#  assert( nNew<=pFd->mmapSizeMax );³  assert( nNew>0 );Ù/  assert( pFd->mmapSizeActual>=pFd->mmapSize );º  assert( MAP_FAILED!=0 ); ¼#ifdef SQLITE_MMAP_READWRITEÙB  if( (pFd->ctrlFlags & UNIXFILE_RDONLY)==0 ) flags |= PROT_WRITE;¦#endif ®  if( pOrig ){¯#if HAVE_MREMAP¿    i64 nReuse = pFd->mmapSize;¥#elseÙ*    const int szSyspage = osGetpagesize();Ù2    i64 nReuse = (pFd->mmapSize & ~(szSyspage-1));¦#endif¾    u8 *pReq = &pOrig[nReuse]; ÙH    /* Unmap any pages of the existing mapping that cannot be reused. */¸    if( nReuse!=nOrig ){Ù#      osMunmap(pReq, nOrig-nReuse);¥    } ¯#if HAVE_MREMAPÙ9    pNew = osMremap(pOrig, nReuse, nNew, MREMAP_MAYMOVE);´    zErr = "mremap";¥#elseÙC    pNew = osMmap(pReq, nNew-nReuse, flags, MAP_SHARED, h, nReuse);»    if( pNew!=MAP_FAILED ){·      if( pNew!=pReq ){Ù&        osMunmap(pNew, nNew - nReuse);±        pNew = 0;¬      }else{µ        pNew = pOrig;§      }¥    }¦#endif ÙE    /* The attempt to extend the existing mapping failed. Free it. */Ù&    if( pNew==MAP_FAILED || pNew==0 ){¾      osMunmap(pOrig, nReuse);¥    }£  } ÙE  /* If pNew is still NULL, try to create an entirely new mapping. */°  if( pNew==0 ){Ù4    pNew = osMmap(0, nNew, flags, MAP_SHARED, h, 0);£  } ¹  if( pNew==MAP_FAILED ){­    pNew = 0;­    nNew = 0;Ù.    unixLogError(SQLITE_OK, zErr, pFd->zPath); ÙJ    /* If the mmap() above failed, assume that all subsequent mmap() callsÙJ    ** will probably fail too. Fall back to using xRead/xWrite exclusively¸    ** in this case.  */¹    pFd->mmapSizeMax = 0;£  }Ù!  pFd->pMapRegion = (void *)pNew;Ù-  pFd->mmapSize = pFd->mmapSizeActual = nNew;¡} ¢/*ÙJ** Memory map or remap the file opened by file-descriptor pFd (if the fileÙK** is already mapped, the existing mapping is replaced by the new). Or, if ÙE** there already exists a mapping for this file, and there are still ÙC** outstanding xFetch() references to it, this function is a no-op.¢**ÙH** If parameter nByte is non-negative, then it is the requested size of ÙJ** the mapping to create. Otherwise, if nByte is less than zero, then the ÙI** requested size is the size of the file on disk. The actual size of theÙH** created mapping is either the requested size or the value configured Ù7** using SQLITE_FCNTL_MMAP_LIMIT, whichever is smaller.¢**ÙG** SQLITE_OK is returned if no error occurs (even if the mapping is notÙF** recreated as a result of outstanding references) or an SQLite error²** code otherwise.¢*/Ù0static int unixMapfile(unixFile *pFd, i64 nMap){Ù)  assert( nMap>=0 || pFd->nFetchOut==0 );Ù?  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );Ù*  if( pFd->nFetchOut>0 ) return SQLITE_OK; ¯  if( nMap<0 ){ÙB    struct stat statbuf;          /* Low-level file information */Ù$    if( osFstat(pFd->h, &statbuf) ){Ù       return SQLITE_IOERR_FSTAT;¥    }»    nMap = statbuf.st_size;£  }¾  if( nMap>pFd->mmapSizeMax ){¼    nMap = pFd->mmapSizeMax;£  } Ù?  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );¼  if( nMap!=pFd->mmapSize ){½    unixRemapfile(pFd, nMap);£  } ³  return SQLITE_OK;¡}Ù##endif /* SQLITE_MAX_MMAP_SIZE>0 */ ¢/*ÙK** If possible, return a pointer to a mapping of file fd starting at offsetÙ;** iOff. The mapping must be valid for at least nAmt bytes.¢**ÙK** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.ÙL** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.ÙJ** Finally, if an error does occur, return an SQLite error code. The finalÙ*** value of *pp is undefined in this case.¢**ÙF** If this function does return a pointer, the caller must eventually Ù2** release the reference by calling unixUnfetch().¢*/ÙFstatic int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){º#if SQLITE_MAX_MMAP_SIZE>0ÙF  unixFile *pFd = (unixFile *)fd;   /* The underlying database file */¦#endifª  *pp = 0; º#if SQLITE_MAX_MMAP_SIZE>0»  if( pFd->mmapSizeMax>0 ){½    if( pFd->pMapRegion==0 ){Ù$      int rc = unixMapfile(pFd, -1);Ù$      if( rc!=SQLITE_OK ) return rc;¥    }Ù%    if( pFd->mmapSize >= iOff+nAmt ){Ù+      *pp = &((u8 *)pFd->pMapRegion)[iOff];·      pFd->nFetchOut++;¥    }£  }¦#endif³  return SQLITE_OK;¡} ¢/*ÙD** If the third argument is non-NULL, then this function releases a ÙC** reference obtained by an earlier call to unixFetch(). The secondÙI** argument passed to this function must be the same as the correspondingÙ;** argument that was passed to the unixFetch() invocation. ¢**ÙI** Or, if the third argument is NULL, then this function is being called ÙJ** to inform the VFS layer that, according to POSIX, any existing mapping Ù-** may now be invalid and should be unmapped.¢*/Ù<static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){º#if SQLITE_MAX_MMAP_SIZE>0ÙF  unixFile *pFd = (unixFile *)fd;   /* The underlying database file */¹  UNUSED_PARAMETER(iOff); ÙG  /* If p==0 (unmap the entire file) then there must be no outstanding ÙH  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),Ù5  ** then there must be at least one outstanding.  */Ù(  assert( (p==0)==(pFd->nFetchOut==0) ); Ù.  /* If p!=0, it must match the iOff value. */Ù6  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] ); ª  if( p ){µ    pFd->nFetchOut--;¨  }else{·    unixUnmapfile(pFd);£  } ¾  assert( pFd->nFetchOut>=0 );¥#else·  UNUSED_PARAMETER(fd);¶  UNUSED_PARAMETER(p);¹  UNUSED_PARAMETER(iOff);¦#endif³  return SQLITE_OK;¡} ¢/*Ù<** Here ends the implementation of all sqlite3_file methods.¢**ÙO********************** End sqlite3_file Methods *******************************ÙO******************************************************************************/ ¢/*ÙH** This division contains definitions of sqlite3_io_methods objects thatÙK** implement various file locking strategies.  It also contains definitionsÙN** of "finder" functions.  A finder-function is used to locate the appropriateÙJ** sqlite3_io_methods object for a particular database file.  The pAppDataÙI** field of the sqlite3_vfs VFS objects are initialized to be pointers toÙ,** the correct finder-function for that VFS.¢**ÙG** Most finder functions return a pointer to a fixed sqlite3_io_methodsÙK** object.  The only interesting finder-function is autolockIoFinder, whichÙC** looks at the filesystem type and tries to guess the best locking¶** strategy from that.¢**Ù2** For finder-function F, two objects are created:¢**Ù3**    (1) The real finder-function named "FImpt()".¢**Ù=**    (2) A constant pointer to this function named just "F".¢**¢**ÙC** A pointer to the F pointer is used as the pAppData value for VFSÙA** objects.  We have to do this instead of letting pAppData pointÙB** directly at the finder-function since C90 rules prevent a void*Ù(** from be cast into a function pointer.¢**¢**Ù5** Each instance of this macro generates two objects:¢**ÙI**   *  A constant sqlite3_io_methods object call METHOD that has lockingÙ/**      methods CLOSE, LOCK, UNLOCK, CKRESLOCK.¢**ÙJ**   *  An I/O method finder function called FINDER that returns a pointerÙ4**      to the METHOD object in the previous bullet.¢*/ÙN#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP)     \ÙNstatic const sqlite3_io_methods METHOD = {                                   \ÙN   VERSION,                    /* iVersion */                                \ÙN   CLOSE,                      /* xClose */                                  \ÙN   unixRead,                   /* xRead */                                   \ÙN   unixWrite,                  /* xWrite */                                  \ÙN   unixTruncate,               /* xTruncate */                               \ÙN   unixSync,                   /* xSync */                                   \ÙN   unixFileSize,               /* xFileSize */                               \ÙN   LOCK,                       /* xLock */                                   \ÙN   UNLOCK,                     /* xUnlock */                                 \ÙN   CKLOCK,                     /* xCheckReservedLock */                      \ÙN   unixFileControl,            /* xFileControl */                            \ÙN   unixSectorSize,             /* xSectorSize */                             \ÙN   unixDeviceCharacteristics,  /* xDeviceCapabilities */                     \ÙN   SHMMAP,                     /* xShmMap */                                 \ÙN   unixShmLock,                /* xShmLock */                                \ÙN   unixShmBarrier,             /* xShmBarrier */                             \ÙN   unixShmUnmap,               /* xShmUnmap */                               \ÙN   unixFetch,                  /* xFetch */                                  \ÙN   unixUnfetch,                /* xUnfetch */                                \ÙN};                                                                           \ÙNstatic const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   \ÙN  UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);                                  \ÙN  return &METHOD;                                                            \ÙN}                                                                            \ÙNstatic const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)    \³    = FINDER##Impl; ¢/*ÙA** Here are all of the sqlite3_io_methods objects for each of theÙG** locking strategies.  Functions that return pointers to these methods´** are also created.¢*/ªIOMETHODS(Ù6  posixIoFinder,            /* Finder function name */Ù@  posixIoMethods,           /* sqlite3_io_methods object name */ÙD  3,                        /* shared memory and mmap are enabled */Ù/  unixClose,                /* xClose method */Ù.  unixLock,                 /* xLock method */Ù0  unixUnlock,               /* xUnlock method */Ù;  unixCheckReservedLock,    /* xCheckReservedLock method */Ù0  unixShmMap                /* xShmMap method */¡)ªIOMETHODS(Ù6  nolockIoFinder,           /* Finder function name */Ù@  nolockIoMethods,          /* sqlite3_io_methods object name */Ù;  3,                        /* shared memory is disabled */Ù/  nolockClose,              /* xClose method */Ù.  nolockLock,               /* xLock method */Ù0  nolockUnlock,             /* xUnlock method */Ù;  nolockCheckReservedLock,  /* xCheckReservedLock method */Ù0  0                         /* xShmMap method */¡)ªIOMETHODS(Ù6  dotlockIoFinder,          /* Finder function name */Ù@  dotlockIoMethods,         /* sqlite3_io_methods object name */Ù;  1,                        /* shared memory is disabled */Ù/  dotlockClose,             /* xClose method */Ù.  dotlockLock,              /* xLock method */Ù0  dotlockUnlock,            /* xUnlock method */Ù;  dotlockCheckReservedLock, /* xCheckReservedLock method */Ù0  0                         /* xShmMap method */¡) ¿#if SQLITE_ENABLE_LOCKING_STYLEªIOMETHODS(Ù6  flockIoFinder,            /* Finder function name */Ù@  flockIoMethods,           /* sqlite3_io_methods object name */Ù;  1,                        /* shared memory is disabled */Ù/  flockClose,               /* xClose method */Ù.  flockLock,                /* xLock method */Ù0  flockUnlock,              /* xUnlock method */Ù;  flockCheckReservedLock,   /* xCheckReservedLock method */Ù0  0                         /* xShmMap method */¡)¦#endif ®#if OS_VXWORKSªIOMETHODS(Ù6  semIoFinder,              /* Finder function name */Ù@  semIoMethods,             /* sqlite3_io_methods object name */Ù;  1,                        /* shared memory is disabled */Ù/  semXClose,                /* xClose method */Ù.  semXLock,                 /* xLock method */Ù0  semXUnlock,               /* xUnlock method */Ù;  semXCheckReservedLock,    /* xCheckReservedLock method */Ù0  0                         /* xShmMap method */¡)¦#endif Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEªIOMETHODS(Ù6  afpIoFinder,              /* Finder function name */Ù@  afpIoMethods,             /* sqlite3_io_methods object name */Ù;  1,                        /* shared memory is disabled */Ù/  afpClose,                 /* xClose method */Ù.  afpLock,                  /* xLock method */Ù0  afpUnlock,                /* xUnlock method */Ù;  afpCheckReservedLock,     /* xCheckReservedLock method */Ù0  0                         /* xShmMap method */¡)¦#endif ¢/*ÙD** The proxy locking method is a "super-method" in the sense that itÙD** opens secondary file descriptors for the conch and lock files andÙE** it uses proxy, dot-file, AFP, and flock() locking methods on thoseÙB** secondary files.  For this reason, the division that implementsÙG** proxy locking is located much further down in the file.  But we needÙD** to go ahead and define the sqlite3_io_methods and finder functionÙB** for proxy locking here.  So we forward declare the I/O methods.¢*/Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEÙ%static int proxyClose(sqlite3_file*);Ù)static int proxyLock(sqlite3_file*, int);Ù+static int proxyUnlock(sqlite3_file*, int);Ù7static int proxyCheckReservedLock(sqlite3_file*, int*);ªIOMETHODS(Ù6  proxyIoFinder,            /* Finder function name */Ù@  proxyIoMethods,           /* sqlite3_io_methods object name */Ù;  1,                        /* shared memory is disabled */Ù/  proxyClose,               /* xClose method */Ù.  proxyLock,                /* xLock method */Ù0  proxyUnlock,              /* xUnlock method */Ù;  proxyCheckReservedLock,   /* xCheckReservedLock method */Ù0  0                         /* xShmMap method */¡)¦#endif ÙN/* nfs lockd on OSX 10.3+ doesn't clear write locks when a read lock is set */Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEªIOMETHODS(Ù7  nfsIoFinder,               /* Finder function name */ÙA  nfsIoMethods,              /* sqlite3_io_methods object name */Ù<  1,                         /* shared memory is disabled */Ù0  unixClose,                 /* xClose method */Ù/  unixLock,                  /* xLock method */Ù1  nfsUnlock,                 /* xUnlock method */Ù<  unixCheckReservedLock,     /* xCheckReservedLock method */Ù1  0                          /* xShmMap method */¡)¦#endif Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE£/* ÙJ** This "finder" function attempts to determine the best locking strategy ÙL** for the database file "filePath".  It then returns the sqlite3_io_methodsÙ(** object that implements that strategy.¢**»** This is for MacOSX only.¢*/Ù6static const sqlite3_io_methods *autolockIoFinderImpl(Ù:  const char *filePath,    /* name of the database file */ÙG  unixFile *pNew           /* open file object for the database file */¢){¿  static const struct Mapping {ÙD    const char *zFilesystem;              /* Filesystem type name */ÙJ    const sqlite3_io_methods *pMethods;   /* Appropriate locking method */®  } aMap[] = {Ù"    { "hfs",    &posixIoMethods },Ù"    { "ufs",    &posixIoMethods },Ù     { "afpfs",  &afpIoMethods },Ù     { "smbfs",  &afpIoMethods },Ù#    { "webdav", &nolockIoMethods },¬    { 0, 0 }¤  };¨  int i;·  struct statfs fsInfo;¸  struct flock lockInfo; ²  if( !filePath ){ÙH    /* If filePath==NULL that means we are dealing with a transient fileÙ*    ** that does not need to be locked. */¼    return &nolockIoMethods;£  }Ù(  if( statfs(filePath, &fsInfo) != -1 ){Ù&    if( fsInfo.f_flags & MNT_RDONLY ){¾      return &nolockIoMethods;¥    }Ù'    for(i=0; aMap[i].zFilesystem; i++){Ù@      if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){Ù         return aMap[i].pMethods;§      }¥    }£  } Ù2  /* Default case. Handles, amongst others, "nfs".Ù?  ** Test byte-range lock using fcntl(). If the call succeeds, Ù=  ** assume that the file-system supports POSIX style locks. ¤  */µ  lockInfo.l_len = 1;·  lockInfo.l_start = 0;¿  lockInfo.l_whence = SEEK_SET;¼  lockInfo.l_type = F_RDLCK;Ù2  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {Ù0    if( strcmp(fsInfo.f_fstypename, "nfs")==0 ){»      return &nfsIoMethods;¬    } else {½      return &posixIoMethods;¥    }¨  }else{½    return &dotlockIoMethods;£  }¡}Ù static const sqlite3_io_methods ÙK  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl; Ù>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */ ®#if OS_VXWORKS¢/*ÙE** This "finder" function for VxWorks checks to see if posix advisoryÙI** locking works.  If it does, then that is what is used.  If it does notÙ2** work, then fallback to named semaphore locking.¢*/Ù5static const sqlite3_io_methods *vxworksIoFinderImpl(Ù:  const char *filePath,    /* name of the database file */Ù5  unixFile *pNew           /* the open file object */¢){¸  struct flock lockInfo; ²  if( !filePath ){ÙH    /* If filePath==NULL that means we are dealing with a transient fileÙ*    ** that does not need to be locked. */¼    return &nolockIoMethods;£  } Ù<  /* Test if fcntl() is supported and use POSIX style locks.Ù7  ** Otherwise fall back to the named semaphore method.¤  */µ  lockInfo.l_len = 1;·  lockInfo.l_start = 0;¿  lockInfo.l_whence = SEEK_SET;¼  lockInfo.l_type = F_RDLCK;Ù2  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {»    return &posixIoMethods;¨  }else{¹    return &semIoMethods;£  }¡}Ù static const sqlite3_io_methods ÙI  *(*const vxworksIoFinder)(const char*,unixFile*) = vxworksIoFinderImpl; ·#endif /* OS_VXWORKS */ ¢/*ÙB** An abstract type for a pointer to an IO method finder function:¢*/ÙHtypedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);  ÙM/****************************************************************************ÙM**************************** sqlite3_vfs methods ****************************¢**Ù>** This division contains the implementation of methods on the¶** sqlite3_vfs object.¢*/ ¢/*ÙG** Initialize the contents of the unixFile structure pointed to by pId.¢*/ºstatic int fillInUnixFile(Ù5  sqlite3_vfs *pVfs,      /* Pointer to vfs object */ÙI  int h,                  /* Open file descriptor of file being opened */ÙD  sqlite3_file *pId,      /* Write to the unixFile structure here */Ù=  const char *zFilename,  /* Name of the file being opened */Ù>  int ctrlFlags           /* Zero or more UNIXFILE_* values */¢){Ù*  const sqlite3_io_methods *pLockingStyle;Ù#  unixFile *pNew = (unixFile *)pId;µ  int rc = SQLITE_OK; ¿  assert( pNew->pInode==NULL ); Ù,  /* No locking occurs in temporary files */Ù=  assert( zFilename!=0 || (ctrlFlags & UNIXFILE_NOLOCK)!=0 ); Ù/  OSTRACE(("OPEN    %-3d %s\n", h, zFilename));®  pNew->h = h;´  pNew->pVfs = pVfs;º  pNew->zPath = zFilename;Ù"  pNew->ctrlFlags = (u8)ctrlFlags;º#if SQLITE_MAX_MMAP_SIZE>0Ù1  pNew->mmapSizeMax = sqlite3GlobalConfig.szMmap;¦#endifÙG  if( sqlite3_uri_boolean(((ctrlFlags & UNIXFILE_URI) ? zFilename : 0),ÙA                           "psow", SQLITE_POWERSAFE_OVERWRITE) ){Ù%    pNew->ctrlFlags |= UNIXFILE_PSOW;£  }Ù+  if( strcmp(pVfs->zName,"unix-excl")==0 ){Ù%    pNew->ctrlFlags |= UNIXFILE_EXCL;£  } ®#if OS_VXWORKSÙ+  pNew->pId = vxworksFindFileId(zFilename);µ  if( pNew->pId==0 ){Ù!    ctrlFlags |= UNIXFILE_NOLOCK;»    rc = SQLITE_NOMEM_BKPT;£  }¦#endif Ù$  if( ctrlFlags & UNIXFILE_NOLOCK ){Ù%    pLockingStyle = &nolockIoMethods;¨  }else{ÙF    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);¿#if SQLITE_ENABLE_LOCKING_STYLEÙL    /* Cache zFilename in the locking context (AFP and dotlock override) forÙJ    ** proxyLock activation is possible (remote proxy is based on db name)ÙB    ** zFilename remains valid until file is closed, to support */Ù,    pNew->lockingContext = (void*)zFilename;¦#endif£  } Ù&  if( pLockingStyle == &posixIoMethodsÙ5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLEÙ%    || pLockingStyle == &nfsIoMethods¦#endif¤  ){µ    unixEnterMutex();Ù,    rc = findInodeInfo(pNew, &pNew->pInode);¸    if( rc!=SQLITE_OK ){ÙK      /* If an error occurred in findInodeInfo(), close the file descriptorÙJ      ** immediately, before releasing the mutex. findInodeInfo() may failº      ** in two scenarios:¨      **Ù(      **   (a) A call to fstat() failed.¿      **   (b) A malloc failed.¨      **ÙG      ** Scenario (b) may only occur if the process is holding no otherÙI      ** file descriptors open on the same file. If there were other fileÙF      ** descriptors on this file, then no malloc would be required byÙH      ** findInodeInfo(). If this is the case, it is quite safe to closeÙL      ** handle h - as it is guaranteed that no posix locks will be releasedµ      ** by doing so.¨      **ÙJ      ** If scenario (a) caused the error then things are not so safe. TheÙI      ** implicit assumption here is that if fstat() fails, things are inÙH      ** such bad shape that dropping a lock or two doesn't matter much.¨      */Ù&      robust_close(pNew, h, __LINE__);­      h = -1;¥    }µ    unixLeaveMutex();£  } Ù5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ù,  else if( pLockingStyle == &afpIoMethods ){ÙC    /* AFP locking uses the file path so it needs to be included in½    ** the afpLockingContext.¦    */¼    afpLockingContext *pCtx;ÙD    pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );²    if( pCtx==0 ){½      rc = SQLITE_NOMEM_BKPT;ª    }else{ÙH      /* NB: zFilename exists and remains valid until the file is closedÙF      ** according to requirement F11141.  So we do not need to make aÙ!      ** copy of the filename. */¿      pCtx->dbPath = zFilename;¹      pCtx->reserved = 0;³      srandomdev();·      unixEnterMutex();Ù.      rc = findInodeInfo(pNew, &pNew->pInode);º      if( rc!=SQLITE_OK ){Ù+        sqlite3_free(pNew->lockingContext);Ù(        robust_close(pNew, h, __LINE__);¯        h = -1;§      }¿      unixLeaveMutex();        ¥    }£  }¦#endif Ù0  else if( pLockingStyle == &dotlockIoMethods ){ÙG    /* Dotfile locking uses the file path so it needs to be included inÙ!    ** the dotlockLockingContext ¦    */´    char *zLockFile;²    int nFilename;»    assert( zFilename!=0 );Ù+    nFilename = (int)strlen(zFilename) + 6;Ù4    zLockFile = (char *)sqlite3_malloc64(nFilename);·    if( zLockFile==0 ){½      rc = SQLITE_NOMEM_BKPT;ª    }else{ÙM      sqlite3_snprintf(nFilename, zLockFile, "%s" DOTLOCK_SUFFIX, zFilename);¥    }Ù%    pNew->lockingContext = zLockFile;£  } ®#if OS_VXWORKSÙ,  else if( pLockingStyle == &semIoMethods ){ÙC    /* Named semaphore locking uses the file path so it needs to beÙ(    ** included in the semLockingContext¦    */µ    unixEnterMutex();Ù,    rc = findInodeInfo(pNew, &pNew->pInode);Ù8    if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){Ù.      char *zSemName = pNew->pInode->aSemName;¬      int n;Ù9      sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",Ù2                       pNew->pId->zCanonicalName);Ù"      for( n=1; zSemName[n]; n++ )Ù1        if( zSemName[n]=='/' ) zSemName[n] = '_';Ù@      pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);Ù-      if( pNew->pInode->pSem == SEM_FAILED ){¿        rc = SQLITE_NOMEM_BKPT;Ù)        pNew->pInode->aSemName[0] = '\0';§      }¥    }µ    unixLeaveMutex();£  }¦#endif¢  º  storeLastErrno(pNew, 0);®#if OS_VXWORKS¶  if( rc!=SQLITE_OK ){Ù/    if( h>=0 ) robust_close(pNew, h, __LINE__);«    h = -1;¸    osUnlink(zFilename);Ù'    pNew->ctrlFlags |= UNIXFILE_DELETE;£  }¦#endif¶  if( rc!=SQLITE_OK ){Ù/    if( h>=0 ) robust_close(pNew, h, __LINE__);¨  }else{Ù"    pNew->pMethod = pLockingStyle;´    OpenCounter(+1);·    verifyDbFile(pNew);£  }¬  return rc;¡} ¢/*ÙB** Return the name of a directory in which to put temporary files.ÙE** If no suitable temporary file directory can be found, return NULL.¢*/Ù)static const char *unixTempFileDir(void){Ù!  static const char *azDirs[] = {§     0,§     0,°     "/var/tmp",°     "/usr/tmp",¬     "/tmp",¨     "."¤  };µ  unsigned int i = 0;²  struct stat buf;Ù,  const char *zDir = sqlite3_temp_directory; Ù7  if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");Ù0  if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");«  while(1){¯    if( zDir!=0½     && osStat(zDir, &buf)==0¼     && S_ISDIR(buf.st_mode)½     && osAccess(zDir, 03)==0¦    ){²      return zDir;¥    }Ù4    if( i>=sizeof(azDirs)/sizeof(azDirs[0]) ) break;·    zDir = azDirs[i++];£  }«  return 0;¡} ¢/*Ù@** Create a temporary file name in zBuf.  zBuf must be allocatedÙA** by the calling process and must be big enough to hold at leastº** pVfs->mxPathname bytes.¢*/Ù1static int unixGetTempname(int nBuf, char *zBuf){³  const char *zDir;±  int iLimit = 0; ÙC  /* It's odd to simulate an io-error here, but really this is justÙG  ** using the io-error infrastructure to test that SQLite handles this·  ** function failing. ¤  */®  zBuf[0] = 0;Ù)  SimulateIOError( return SQLITE_IOERR ); »  zDir = unixTempFileDir();Ù0  if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;¥  do{ª    u64 r;Ù&    sqlite3_randomness(sizeof(r), &r);µ    assert( nBuf>2 );µ    zBuf[nBuf-2] = 0;ÙF    sqlite3_snprintf(nBuf, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX"%llx%c",Ù!                     zDir, r, 0);Ù?    if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ) return SQLITE_ERROR;Ù   }while( osAccess(zBuf,0)==0 );³  return SQLITE_OK;¡} Ù5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)¢/*ÙA** Routine to transform a unixFile into a proxy-locking unixFile.ÙD** Implementation in the proxy-lock division, but used by unixOpen()Ù-** if SQLITE_PREFER_PROXY_LOCKING is defined.¢*/Ù:static int proxyTransformUnixFile(unixFile*, const char*);¦#endif ¢/*ÙH** Search for an unused file descriptor that was opened on the database ÙE** file (not a journal or master-journal file) identified by pathnameÙG** zPath with SQLITE_OPEN_XXX flags matching those passed as the second½** argument to this function.¢**ÙG** Such a file descriptor may exist if a database connection was closedÙF** but the associated file descriptor could not be closed because someÙF** other file descriptor open on the same file is holding a file-lock.ÙH** Refer to comments in the unixClose() function and the lengthy commentÙE** describing "Posix Advisory Locking" at the start of this file for Ù'** further details. Also, ticket #4018.¢**ÙE** If a suitable file descriptor is found, then it is returned. If noÙ3** such file descriptor is located, -1 is returned.¢*/ÙBstatic UnixUnusedFd *findReusableFd(const char *zPath, int flags){¼  UnixUnusedFd *pUnused = 0; ÙH  /* Do not search for an unused file descriptor on vxworks. Not becauseÙJ  ** vxworks would not benefit from the change (it might, we're not sure),ÙH  ** but because no way to test it is currently available. It is better ÙJ  ** not to risk breaking vxworks support for the sake of such an obscure ±  ** feature.  */¯#if !OS_VXWORKSÙC  struct stat sStat;                   /* Results of stat() call */ ³  unixEnterMutex(); ÙG  /* A stat() call may fail for various reasons. If this happens, it isÙH  ** almost certain that an open() call on the same path will also fail.ÙG  ** For this reason, if an error occurs in the stat() call here, it isÙG  ** ignored and -1 is returned. The caller will try to open a new fileÙF  ** descriptor on the same path, fail, and return an error to SQLite.¤  **ÙG  ** Even if a subsequent open() call does succeed, the consequences ofÙC  ** not searching for a reusable file descriptor are not dire.  */Ù0  if( nUnusedFd>0 && 0==osStat(zPath, &sStat) ){º    unixInodeInfo *pInode; ·    pInode = inodeList;Ù6    while( pInode && (pInode->fileId.dev!=sStat.st_devÙA                     || pInode->fileId.ino!=(u64)sStat.st_ino) ){¾       pInode = pInode->pNext;¥    }±    if( pInode ){¸      UnixUnusedFd **pp;ÙO      for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));´      pUnused = *pp;´      if( pUnused ){´        nUnusedFd--;½        *pp = pUnused->pNext;§      }¥    }£  }³  unixLeaveMutex();¾#endif    /* if !OS_VXWORKS */±  return pUnused;¡} ¢/*Ù-** Find the mode, uid and gid of file zFile. ¢*/·static int getFileMode(Ù1  const char *zFile,              /* File name */ÙA  mode_t *pMode,                  /* OUT: Permissions of zFile */Ù:  uid_t *pUid,                    /* OUT: uid of zFile. */Ù:  gid_t *pGid                     /* OUT: gid of zFile. */¢){ÙI  struct stat sStat;              /* Output of stat() on database file */µ  int rc = SQLITE_OK;Ù!  if( 0==osStat(zFile, &sStat) ){Ù"    *pMode = sStat.st_mode & 0777;¹    *pUid = sStat.st_uid;¹    *pGid = sStat.st_gid;¨  }else{¼    rc = SQLITE_IOERR_FSTAT;£  }¬  return rc;¡} ¢/*ÙJ** This function is called by unixOpen() to determine the unix permissionsÙK** to create new files with. If no error occurs, then SQLITE_OK is returnedÙG** and a value suitable for passing as the third argument to open(2) isÙE** written to *pMode. If an IO error occurs, an SQLite error code is Ù4** returned and the value of *pMode is not modified.¢**ÙB** In most cases, this routine sets *pMode to 0, which will becomeÙ:** an indication to robust_open() to create the file usingÙ9** SQLITE_DEFAULT_FILE_PERMISSIONS adjusted by the umask.ÙG** But if the file being opened is a WAL or regular journal file, then ÙD** this function queries the file-system for the permissions on the ÙG** corresponding database file and sets *pMode to this value. Whenever ÙJ** possible, WAL and journal files are created using the same permissions Ù#** as the associated database file.¢**Ù=** If the SQLITE_ENABLE_8_3_NAMES option is enabled, then theÙD** original filename is unavailable.  But 8_3_NAMES is only used forÙC** FAT filesystems and permissions do not matter there, so just use»** the default permissions.¢*/¾static int findCreateFileMode(ÙM  const char *zPath,              /* Path of file (possibly) being created */ÙO  int flags,                      /* Flags passed as 4th argument to xOpen() */ÙJ  mode_t *pMode,                  /* OUT: Permissions to open file with */ÙC  uid_t *pUid,                    /* OUT: uid to set on the file */ÙC  gid_t *pGid                     /* OUT: gid to set on the file */¢){Ù3  int rc = SQLITE_OK;             /* Return Code */­  *pMode = 0;¬  *pUid = 0;¬  *pGid = 0;Ù;  if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){Ù:    char zDb[MAX_PATHNAME+1];     /* Database file path */ÙD    int nDb;                      /* Number of valid bytes in zDb */ ÙL    /* zPath is a path to a WAL or journal file. The following block derivesÙN    ** the path to the associated database file from zPath. This block handlesÙ(    ** the following naming conventions:¦    **¿    **   "<path to db>-journal"»    **   "<path to db>-wal"Ù!    **   "<path to db>-journalNN"½    **   "<path to db>-walNN"¦    **Ù?    ** where NN is a decimal number. The NN naming schemes are Ù+    ** used by the test_multiplex.c module.¦    */Ù&    nDb = sqlite3Strlen30(zPath) - 1; ½    while( zPath[nDb]!='-' ){ÙG      /* In normal operation, the journal file name will always containÙH      ** a '-' character.  However in 8+3 filename mode, or if a corruptÙL      ** rollback journal specifies a master journal with a goofy name, thenÙ%      ** the '-' might be missing. */Ù7      if( nDb==0 || zPath[nDb]=='.' ) return SQLITE_OK;¬      nDb--;¥    }¼    memcpy(zDb, zPath, nDb);´    zDb[nDb] = '\0'; Ù-    rc = getFileMode(zDb, pMode, pUid, pGid);Ù0  }else if( flags & SQLITE_OPEN_DELETEONCLOSE ){²    *pMode = 0600;Ù&  }else if( flags & SQLITE_OPEN_URI ){ÙJ    /* If this is a main database file and the file was opened using a URIÙH    ** filename, check for the "modeof" parameter. If present, interpretÙI    ** its value as a filename and try to copy the mode, uid and gid fromµ    ** that file.  */Ù;    const char *z = sqlite3_uri_parameter(zPath, "modeof");¬    if( z ){Ù-      rc = getFileMode(z, pMode, pUid, pGid);¥    }£  }¬  return rc;¡} ¢/*·** Open the file zPath.£** ÙH** Previously, the SQLite OS layer used three functions in place of this§** one:¢**Ù **     sqlite3OsOpenReadWrite();¿**     sqlite3OsOpenReadOnly();Ù **     sqlite3OsOpenExclusive();¢**ÙA** These calls correspond to the following combinations of flags:¢**Ù.**     ReadWrite() ->     (READWRITE | CREATE)Ù%**     ReadOnly()  ->     (READONLY) Ù:**     OpenExclusive() -> (READWRITE | CREATE | EXCLUSIVE)¢**ÙF** The old OpenExclusive() accepted a boolean argument - "delFlag". IfÙE** true, the file was configured to be automatically deleted when theÙA** file handle closed. To achieve the same effect using this new ÙF** interface, add the DELETEONCLOSE flag to those specified above for ³** OpenExclusive().¢*/´static int unixOpen(ÙO  sqlite3_vfs *pVfs,           /* The VFS for which this is the xOpen method */ÙB  const char *zPath,           /* Pathname of file to be opened */ÙH  sqlite3_file *pFile,         /* The file descriptor to be filled in */ÙG  int flags,                   /* Input flags to control the opening */ÙI  int *pOutFlags               /* Output flags returned to SQLite core */¢){Ù"  unixFile *p = (unixFile *)pFile;ÙI  int fd = -1;                   /* File descriptor returned by open() */Ù>  int openFlags = 0;             /* Flags to pass to open() */Ù;  int eType = flags&0xFFFFFF00;  /* Type of file to open */ÙF  int noLock;                    /* True to omit locking primitives */Ù;  int rc = SQLITE_OK;            /* Function Return Code */Ù7  int ctrlFlags = 0;             /* UNIXFILE_* flags */ Ù5  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);Ù9  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);Ù2  int isCreate     = (flags & SQLITE_OPEN_CREATE);Ù4  int isReadonly   = (flags & SQLITE_OPEN_READONLY);Ù5  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);¿#if SQLITE_ENABLE_LOCKING_STYLEÙ5  int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);¦#endifÙ5#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE·  struct statfs fsInfo;¦#endif ÙG  /* If creating a master or main-file journal, this function will openÙF  ** a file-descriptor on the directory too. The first time unixSync()ÙL  ** is called the directory file descriptor will be fsync()ed and close()d.¤  */Ù   int isNewJrnl = (isCreate && (Ù*        eType==SQLITE_OPEN_MASTER_JOURNAL Ù(     || eType==SQLITE_OPEN_MAIN_JOURNAL ¾     || eType==SQLITE_OPEN_WAL¥  )); ÙK  /* If argument zPath is a NULL pointer, this function is required to openÙA  ** a temporary file. Use this buffer to store the file name in.¤  */Ù   char zTmpname[MAX_PATHNAME+2];¼  const char *zName = zPath; Ù.  /* Check the following statements are true: ¤  **ÙL  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and ÙA  **   (b) if CREATE is set, then READWRITE must also be set, andÙ=  **   (c) if EXCLUSIVE is set, then CREATE must also be set.ÙA  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.¤  */ÙK  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));Ù%  assert(isCreate==0 || isReadWrite);Ù%  assert(isExclusive==0 || isCreate);Ù"  assert(isDelete==0 || isCreate); ÙF  /* The main DB, main journal, WAL file and master journal are never ÙB  ** automatically deleted. Nor are they ever temporary files.  */Ù?  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );ÙD  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );ÙF  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );Ù;  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL ); ÙI  /* Assert that the upper layer has set one of the "file-type" flags. */ÙH  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB ÙM       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL ÙO       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL ÙC       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL¤  ); ÙG  /* Detect a pid change and reset the PRNG.  There is a race conditionÙG  ** here such that two or more threads all trying to open databases atÙD  ** the same instant might all reset the PRNG.  But multiple resets²  ** are harmless.¤  */Ù#  if( randomnessPid!=osGetpid(0) ){Ù     randomnessPid = osGetpid(0);¼    sqlite3_randomness(0,0);£  }Ù!  memset(p, 0, sizeof(unixFile)); Ù#  if( eType==SQLITE_OPEN_MAIN_DB ){º    UnixUnusedFd *pUnused;Ù+    pUnused = findReusableFd(zName, flags);²    if( pUnused ){·      fd = pUnused->fd;ª    }else{Ù3      pUnused = sqlite3_malloc64(sizeof(*pUnused));µ      if( !pUnused ){Ù!        return SQLITE_NOMEM_BKPT;§      }¥    }Ù%    p->pPreallocatedUnused = pUnused; ÙD    /* Database filenames are double-zero terminated if they are notÙC    ** URIs with parameters.  Hence, they can always be passed intoÙ"    ** sqlite3_uri_parameter(). */ÙE    assert( (flags & SQLITE_OPEN_URI) || zName[strlen(zName)+1]==0 ); µ  }else if( !zName ){ÙF    /* If zName is NULL, the upper layer is requesting a temp file. */Ù#    assert(isDelete && !isNewJrnl);Ù5    rc = unixGetTempname(pVfs->mxPathname, zTmpname);¸    if( rc!=SQLITE_OK ){°      return rc;¥    }µ    zName = zTmpname; ÙF    /* Generated temporary filenames are always double-zero terminatedÙ-    ** for use by sqlite3_uri_parameter(). */Ù(    assert( zName[strlen(zName)+1]==0 );£  } ÙH  /* Determine the value of the flags parameter passed to POSIX functionÙF  ** open(). These must be calculated even if open() is not called, asÙC  ** they may be stored as part of the file handle and used by the Ù1  ** 'conch file' locking functions later on.  */Ù*  if( isReadonly )  openFlags |= O_RDONLY;Ù(  if( isReadWrite ) openFlags |= O_RDWR;Ù)  if( isCreate )    openFlags |= O_CREAT;Ù5  if( isExclusive ) openFlags |= (O_EXCL|O_NOFOLLOW);Ù&  openFlags |= (O_LARGEFILE|O_BINARY); ­  if( fd<0 ){ÙG    mode_t openMode;              /* Permissions to create file with */Ù;    uid_t uid;                    /* Userid for the file */Ù<    gid_t gid;                    /* Groupid for the file */ÙA    rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);¸    if( rc!=SQLITE_OK ){Ù(      assert( !p->pPreallocatedUnused );ÙJ      assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );°      return rc;¥    }Ù1    fd = robust_open(zName, openFlags, openMode);Ù=    OSTRACE(("OPENX   %-3d %s 0%o\n", fd, zName, openFlags));Ù7    assert( !isExclusive || (openFlags & O_CREAT)!=0 );¯    if( fd<0 ){Ù@      if( isNewJrnl && errno==EACCES && osAccess(zName, F_OK) ){ÙE        /* If unable to create a journal because the directory is notÙ?        ** writable, change the error code to indicate that. */Ù'        rc = SQLITE_READONLY_DIRECTORY;Ù/      }else if( errno!=EISDIR && isReadWrite ){ÙK        /* Failed to open the file for read/write access. Try read-only. */Ù=        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);Ù'        openFlags &= ~(O_RDWR|O_CREAT);Ù&        flags |= SQLITE_OPEN_READONLY;¾        openFlags |= O_RDONLY;·        isReadonly = 1;Ù5        fd = robust_open(zName, openFlags, openMode);§      }¥    }¯    if( fd<0 ){ÙB      int rc2 = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);Ù#      if( rc==SQLITE_OK ) rc = rc2;¹      goto open_finished;¥    } ÙH    /* If this process is running as root and if creating a new rollbackÙI    ** journal or WAL file, set the ownership of the journal or WAL to beÙ)    ** the same as the original database.¦    */Ù=    if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){Ù!      robustFchown(fd, uid, gid);¥    }£  }²  assert( fd>=0 );²  if( pOutFlags ){·    *pOutFlags = flags;£  } ¿  if( p->pPreallocatedUnused ){Ù$    p->pPreallocatedUnused->fd = fd;Ù*    p->pPreallocatedUnused->flags = flags;£  } ±  if( isDelete ){®#if OS_VXWORKS²    zPath = zName;Ù(#elif defined(SQLITE_UNLINK_AFTER_CLOSE)Ù)    zPath = sqlite3_mprintf("%s", zName);³    if( zPath==0 ){Ù$      robust_close(p, fd, __LINE__);¿      return SQLITE_NOMEM_BKPT;¥    }¥#else´    osUnlink(zName);¦#endif£  }¿#if SQLITE_ENABLE_LOCKING_STYLE§  else{½    p->openFlags = openFlags;£  }¦#endif¢  Ù5#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLEÙ#  if( fstatfs(fd, &fsInfo) == -1 ){½    storeLastErrno(p, errno);Ù"    robust_close(p, fd, __LINE__);¿    return SQLITE_IOERR_ACCESS;£  }Ù6  if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {Ù;    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;£  }Ù6  if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {Ù;    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;£  }¦#endif Ù$  /* Set up appropriate ctrlFlags */Ù=  if( isDelete )                ctrlFlags |= UNIXFILE_DELETE;Ù=  if( isReadonly )              ctrlFlags |= UNIXFILE_RDONLY;Ù&  noLock = eType!=SQLITE_OPEN_MAIN_DB;Ù=  if( noLock )                  ctrlFlags |= UNIXFILE_NOLOCK;Ù>  if( isNewJrnl )               ctrlFlags |= UNIXFILE_DIRSYNC;Ù:  if( flags & SQLITE_OPEN_URI ) ctrlFlags |= UNIXFILE_URI; ¿#if SQLITE_ENABLE_LOCKING_STYLE¿#if SQLITE_PREFER_PROXY_LOCKING²  isAutoProxy = 1;¦#endifÙA  if( isAutoProxy && (zPath!=NULL) && (!noLock) && pVfs->xOpen ){Ù:    char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");µ    int useProxy = 0; ÙK    /* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 0 means ÙJ    ** never use proxy, NULL means use proxy for non-local files only.  */¹    if( envforce!=NULL ){Ù"      useProxy = atoi(envforce)>0;ª    }else{Ù-      useProxy = !(fsInfo.f_flags&MNT_LOCAL);¥    }³    if( useProxy ){Ù=      rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);º      if( rc==SQLITE_OK ){Ù@        rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");¼        if( rc!=SQLITE_OK ){ÙM          /* Use unixClose to clean up the resources added in fillInUnixFile ÙF          ** and clear all the structure's references.  Specifically, ÙL          ** pFile->pMethods will be NULL so sqlite3OsClose will be a no-op ¬          */»          unixClose(pFile);´          return rc;©        }§      }¹      goto open_finished;¥    }£  }¦#endif¢  Ù$  assert( zPath==0 || zPath[0]=='/' ÙN      || eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL ¤  );Ù9  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags); ®open_finished:¶  if( rc!=SQLITE_OK ){Ù)    sqlite3_free(p->pPreallocatedUnused);£  }¬  return rc;¡}  ¢/*ÙE** Delete the file at zPath. If the dirSync argument is true, fsync()Ù)** the directory after deleting the file.¢*/¶static int unixDelete(ÙK  sqlite3_vfs *NotUsed,     /* VFS containing this as the xDelete method */Ù<  const char *zPath,        /* Name of file to be deleted */ÙP  int dirSync               /* If true, fsync() directory after deleting file */¢){µ  int rc = SQLITE_OK;¼  UNUSED_PARAMETER(NotUsed);Ù.  SimulateIOError(return SQLITE_IOERR_DELETE);¾  if( osUnlink(zPath)==(-1) ){µ    if( errno==ENOENT®#if OS_VXWORKS¿        || osAccess(zPath,0)!=0¦#endif¦    ){Ù%      rc = SQLITE_IOERR_DELETE_NOENT;ª    }else{Ù>      rc = unixLogError(SQLITE_IOERR_DELETE, "unlink", zPath);¥    }®    return rc;£  }¾#ifndef SQLITE_DISABLE_DIRSYNC¹  if( (dirSync & 1)!=0 ){«    int fd;Ù%    rc = osOpenDirectory(zPath, &fd);¸    if( rc==SQLITE_OK ){¿      if( full_fsync(fd,0,0) ){ÙB        rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, "fsync", zPath);§      }Ù$      robust_close(0, fd, __LINE__);ª    }else{Ù$      assert( rc==SQLITE_CANTOPEN );µ      rc = SQLITE_OK;¥    }£  }¦#endif¬  return rc;¡} ¢/*ÙA** Test the existence of or access permissions of file zPath. TheÙ0** test performed depends on the value of flags:¢**Ù8**     SQLITE_ACCESS_EXISTS: Return 1 if the file existsÙJ**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.Ù@**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.¢**¶** Otherwise return 0.¢*/¶static int unixAccess(ÙF  sqlite3_vfs *NotUsed,   /* The VFS containing this xAccess method */Ù;  const char *zPath,      /* Path of the file to examine */ÙN  int flags,              /* What do we want to learn about the zPath file? */Ù9  int *pResOut            /* Write result boolean here */¢){¼  UNUSED_PARAMETER(NotUsed);Ù1  SimulateIOError( return SQLITE_IOERR_ACCESS; );·  assert( pResOut!=0 ); ÙG  /* The spec says there are three possible values for flags.  But onlyÙ%  ** two of them are actually used */ÙJ  assert( flags==SQLITE_ACCESS_EXISTS || flags==SQLITE_ACCESS_READWRITE ); Ù$  if( flags==SQLITE_ACCESS_EXISTS ){´    struct stat buf;Ù9    *pResOut = (0==osStat(zPath, &buf) && buf.st_size>0);¨  }else{Ù-    *pResOut = osAccess(zPath, W_OK|R_OK)==0;£  }³  return SQLITE_OK;¡} ¢/*¢**¢*/ºstatic int mkFullPathname(Ù2  const char *zPath,              /* Input path */Ù5  char *zOut,                     /* Output buffer */ÙE  int nOut                        /* Allocated size of buffer zOut */¢){Ù%  int nPath = sqlite3Strlen30(zPath);¯  int iOff = 0;¶  if( zPath[0]!='/' ){Ù$    if( osGetcwd(zOut, nOut-2)==0 ){ÙA      return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);¥    }Ù!    iOff = sqlite3Strlen30(zOut);·    zOut[iOff++] = '/';£  }¼  if( (iOff+nPath+1)>nOut ){ÙK    /* SQLite assumes that xFullPathname() nul-terminates the output bufferÙ'    ** even if it returns an error.  */¶    zOut[iOff] = '\0';Ù     return SQLITE_CANTOPEN_BKPT;£  }Ù8  sqlite3_snprintf(nOut-iOff, &zOut[iOff], "%s", zPath);³  return SQLITE_OK;¡} ¢/*ÙC** Turn a relative pathname into a full pathname. The relative pathÙC** is stored as a nul-terminated string in the buffer pointed to byª** zPath. ¢**ÙD** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes ÙB** (in this case, MAX_PATHNAME bytes). The full-path is written toÙ ** this buffer before returning.¢*/¼static int unixFullPathname(Ù;  sqlite3_vfs *pVfs,            /* Pointer to vfs object */ÙB  const char *zPath,            /* Possibly relative input path */ÙD  int nOut,                     /* Size of output buffer in bytes */Ù3  char *zOut                    /* Output buffer */¢){Ù3#if !defined(HAVE_READLINK) || !defined(HAVE_LSTAT)Ù+  return mkFullPathname(zPath, zOut, nOut);¥#elseµ  int rc = SQLITE_OK;¬  int nByte;ÙN  int nLink = 1;                /* Number of symbolic links followed so far */ÙK  const char *zIn = zPath;      /* Input path for each iteration of loop */±  char *zDel = 0; Ù+  assert( pVfs->mxPathname==MAX_PATHNAME );¹  UNUSED_PARAMETER(pVfs); ÙC  /* It's odd to simulate an io-error here, but really this is justÙG  ** using the io-error infrastructure to test that SQLite handles thisÙD  ** function failing. This function could fail if, for example, theÙ1  ** current working directory has been unlinked.¤  */Ù)  SimulateIOError( return SQLITE_ERROR ); ¦  do { ÙK    /* Call stat() on path zIn. Set bLink to true if the path is a symbolicÙ$    ** link, or false otherwise.  */²    int bLink = 0;´    struct stat buf;Ù     if( osLstat(zIn, &buf)!=0 ){º      if( errno!=ENOENT ){Ù>        rc = unixLogError(SQLITE_CANTOPEN_BKPT, "lstat", zIn);§      }ª    }else{Ù#      bLink = S_ISLNK(buf.st_mode);¥    } °    if( bLink ){´      if( zDel==0 ){Ù$        zDel = sqlite3_malloc(nOut);Ù-        if( zDel==0 ) rc = SQLITE_NOMEM_BKPT;Ù.      }else if( ++nLink>SQLITE_MAX_SYMLINKS ){Ù"        rc = SQLITE_CANTOPEN_BKPT;§      } º      if( rc==SQLITE_OK ){Ù.        nByte = osReadlink(zIn, zDel, nOut-1);¶        if( nByte<0 ){ÙC          rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);®        }else{½          if( zDel[0]!='/' ){²            int n;ÙE            for(n = sqlite3Strlen30(zIn); n>0 && zIn[n-1]!='/'; n--);Ù!            if( nByte+n+1>nOut ){Ù(              rc = SQLITE_CANTOPEN_BKPT;²            }else{Ù/              memmove(&zDel[n], zDel, nByte+1);Ù#              memcpy(zDel, zIn, n);¹              nByte += n;­            }«          }½          zDel[nByte] = '\0';©        }§      } ±      zIn = zDel;¥    } Ù8    assert( rc!=SQLITE_OK || zIn!=zOut || zIn[0]=='/' );Ù%    if( rc==SQLITE_OK && zIn!=zOut ){Ù+      rc = mkFullPathname(zIn, zOut, nOut);¥    }¹    if( bLink==0 ) break;¯    zIn = zOut;º  }while( rc==SQLITE_OK ); µ  sqlite3_free(zDel);¬  return rc;Ù*#endif   /* HAVE_READLINK && HAVE_LSTAT */¡}  Ù"#ifndef SQLITE_OMIT_LOAD_EXTENSION¢/*Ù@** Interfaces for opening a shared library, finding entry pointsÙ=** within the shared library, and closing the shared library.¢*/²#include <dlfcn.h>ÙEstatic void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){¼  UNUSED_PARAMETER(NotUsed);Ù3  return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);¡} ¢/*ÙH** SQLite calls this function immediately after a call to unixDlSym() orÙH** unixDlOpen() fails (returns a null pointer). If a more detailed errorÙF** message is available, it is written to zBufOut. If no error messageÙE** is available, zBufOut is left unmodified and SQLite uses a default±** error message.¢*/ÙGstatic void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){³  const char *zErr;¼  UNUSED_PARAMETER(NotUsed);³  unixEnterMutex();³  zErr = dlerror();­  if( zErr ){Ù0    sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);£  }³  unixLeaveMutex();¡}ÙOstatic void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){¥  /* ÙI  ** GCC with -pedantic-errors says that C90 does not allow a void* to beÙL  ** cast into a pointer to a function.  And yet the library dlsym() routineÙK  ** returns a void* which is really a pointer to a function.  So how do weÙ'  ** use dlsym() with -pedantic-errors?¤  **ÙE  ** Variable x below is defined to be a pointer to a function takingÙL  ** parameters void* and const char* and returning a pointer to a function.ÙG  ** We initialize x by assigning it a pointer to the dlsym() function.ÙG  ** (That assignment requires a cast.)  Then we call the function that³  ** x points to.  ¤  **ÙG  ** This work-around is unlikely to work correctly on any system whereÙL  ** you really cannot cast a function pointer into void*.  But then, on theÙJ  ** other hand, dlsym() will not work on such a system either, so we have¾  ** not really lost anything.¤  */Ù(  void (*(*x)(void*,const char*))(void);¼  UNUSED_PARAMETER(NotUsed);Ù1  x = (void(*(*)(void*,const char*))(void))dlsym;·  return (*x)(p, zSym);¡}Ù=static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){¼  UNUSED_PARAMETER(NotUsed);³  dlclose(pHandle);¡}Ù5#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */·  #define unixDlOpen  0·  #define unixDlError 0·  #define unixDlSym   0·  #define unixDlClose 0¦#endif ¢/*Ù?** Write nBuf bytes of random data to the supplied buffer zBuf.¢*/ÙFstatic int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){¼  UNUSED_PARAMETER(NotUsed);Ù5  assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int))); ÙB  /* We have to initialize zBuf to prevent valgrind from reportingÙE  ** errors.  The reports issued by valgrind are incorrect - we wouldÙA  ** prefer that the randomness be increased by making use of theÙD  ** uninitialized space in zBuf - but valgrind errors tend to worryÙG  ** some users.  Rather than argue, it seems easier just to initializeÙM  ** the whole array and silence valgrind, even if that means less randomness¸  ** in the random seed.¤  **ÙH  ** When testing, initializing zBuf[] to zero is all we do.  That meansÙH  ** that we always use the same random number sequence.  This makes the¶  ** tests repeatable.¤  */¸  memset(zBuf, 0, nBuf);Ù   randomnessPid = osGetpid(0);  Ù=#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)£  {°    int fd, got;Ù2    fd = robust_open("/dev/urandom", O_RDONLY, 0);¯    if( fd<0 ){¯      time_t t;¯      time(&t);Ù"      memcpy(zBuf, &t, sizeof(t));ÙF      memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));Ù>      assert( sizeof(t)+sizeof(randomnessPid)<=(size_t)nBuf );Ù/      nBuf = sizeof(t) + sizeof(randomnessPid);ª    }else{ÙH      do{ got = osRead(fd, zBuf, nBuf); }while( got<0 && errno==EINTR );Ù$      robust_close(0, fd, __LINE__);¥    }£  }¦#endif®  return nBuf;¡}  ¢/*Ù>** Sleep for a little while.  Return the amount of time slept.Ù?** The argument is the number of microseconds we want to sleep.ÙC** The return value is the number of microseconds of sleep actuallyÙA** requested from the underlying operating system, a number whichÙ?** might be greater than or equal to the argument, but not lessµ** than the argument.¢*/Ù=static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){®#if OS_VXWORKSµ  struct timespec sp; Ù%  sp.tv_sec = microseconds / 1000000;Ù/  sp.tv_nsec = (microseconds % 1000000) * 1000;·  nanosleep(&sp, NULL);¼  UNUSED_PARAMETER(NotUsed);¶  return microseconds;Ù)#elif defined(HAVE_USLEEP) && HAVE_USLEEP·  usleep(microseconds);¼  UNUSED_PARAMETER(NotUsed);¶  return microseconds;¥#elseÙ.  int seconds = (microseconds+999999)/1000000;±  sleep(seconds);¼  UNUSED_PARAMETER(NotUsed);¹  return seconds*1000000;¦#endif¡} ¢/*ÙH** The following variable, if set to a non-zero value, is interpreted asÙD** the number of seconds since 1970 and is used to set the result ofÙ)** sqlite3OsCurrentTime() during testing.¢*/²#ifdef SQLITE_TESTÙWSQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */¦#endif ¢/*ÙL** Find the current time (in Universal Coordinated Time).  Write into *piNowÙI** the current time and date as a Julian Day number times 86_400_000.  InÙM** other words, write into *piNow the number of milliseconds since the JulianÙG** epoch of noon in Greenwich on November 24, 4714 B.C according to theÙ ** proleptic Gregorian calendar.¢**ÙK** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date ³** cannot be found.¢*/ÙLstatic int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){ÙI  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;µ  int rc = SQLITE_OK;¶#if defined(NO_GETTOD)«  time_t t;«  time(&t);Ù/  *piNow = ((sqlite3_int64)t)*1000 + unixEpoch;°#elif OS_VXWORKS·  struct timespec sNow;Ù'  clock_gettime(CLOCK_REALTIME, &sNow);ÙN  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_nsec/1000000;¥#else¶  struct timeval sNow;ÙH  (void)gettimeofday(&sNow, 0);  /* Cannot fail given valid arguments */ÙK  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;¦#endif ²#ifdef SQLITE_TEST½  if( sqlite3_current_time ){ÙB    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;£  }¦#endif¼  UNUSED_PARAMETER(NotUsed);¬  return rc;¡} ¾#ifndef SQLITE_OMIT_DEPRECATED¢/*ÙD** Find the current time (in Universal Coordinated Time).  Write theÙ?** current time and date as a Julian Day number into *prNow andÙ<** return 0.  Return 1 if the time and date cannot be found.¢*/Ù@static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){¶  sqlite3_int64 i = 0;©  int rc;¼  UNUSED_PARAMETER(NotUsed);Ù#  rc = unixCurrentTimeInt64(0, &i);¸  *prNow = i/86400000.0;¬  return rc;¡}¥#elseº# define unixCurrentTime 0¦#endif ¢/*Ù<** The xGetLastError() method is designed to return a betterÙA** low-level error message when operating-system problems come upÙF** during SQLite operation.  Only the integer return code is currently¨** used.¢*/ÙPstatic int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){¼  UNUSED_PARAMETER(NotUsed);½  UNUSED_PARAMETER(NotUsed2);½  UNUSED_PARAMETER(NotUsed3);¯  return errno;¡}  ¢/*ÙO************************ End of sqlite3_vfs methods ***************************ÙO******************************************************************************/ ÙO/******************************************************************************ÙO************************** Begin Proxy Locking ********************************¢**ÙG** Proxy locking is a "uber-locking-method" in this sense:  It uses theÙE** other locking methods on secondary lock files.  Proxy locking is aÙG** meta-layer over top of the primitive locking implemented above.  ForÙI** this reason, the division that implements of proxy locking is deferredÙH** until late in the file (here) after all of the other I/O methods haveÙE** been defined - so that the primitive locking methods are availableÙ@** as services to help with the implementation of proxy locking.¢**¤****¢**ÙD** The default locking schemes in SQLite use byte-range locks on theÙJ** database file to coordinate safe, concurrent access by multiple readersÙI** and writers [http://sqlite.org/lockingv3.html].  The five file lockingÙJ** states (UNLOCKED, PENDING, SHARED, RESERVED, EXCLUSIVE) are implementedÙG** as POSIX read & write locks over fixed set of locations (via fsctl),ÙI** on AFP and SMB only exclusive byte-range locks are available via fsctlÙK** with _IOWR('z', 23, struct ByteRangeLockPB2) to track the same 5 states.ÙH** To simulate a F_RDLCK on the shared range, on AFP a randomly selectedÙE** address in the shared range is taken for a SHARED lock, the entireÙ0** shared range is taken for an EXCLUSIVE lock):¢**Ù&**      PENDING_BYTE        0x40000000Ù&**      RESERVED_BYTE       0x40000001Ù4**      SHARED_RANGE        0x40000002 -> 0x40000200¢**ÙD** This works well on the local file system, but shows a nearly 100xÙF** slowdown in read performance on AFP because the AFP client disablesÙG** the read cache when byte-range locks are present.  Enabling the readÙF** cache exposes a cache coherency problem that is present on all OS XÙ@** supported network file systems.  NFS and AFP both observe theÙ7** close-to-open semantics for ensuring cache coherencyÙC** [http://nfs.sourceforge.net/#faq_a8], which does not effectivelyÙF** address the requirements for concurrent database access by multiple¶** readers and writersÙI** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].¢**ÙL** To address the performance and cache coherency issues, proxy file lockingÙH** changes the way database access is controlled by limiting access to aÙG** single host at a time and moving file locks off of the database fileÙ4** and onto a proxy file on the local file system.  ¢**¢**´** Using proxy locks´** -----------------¢**©** C APIs¢**ÙD**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_SET_LOCKPROXYFILE,Ù2**                       <proxy_path> | ":auto:");ÙD**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_GET_LOCKPROXYFILE,Ù(**                       &<proxy_path>);¢**¢**®** SQL pragmas¢**Ù;**  PRAGMA [database.]lock_proxy_file=<proxy_path> | :auto:Ù%**  PRAGMA [database.]lock_proxy_file¢**ÙJ** Specifying ":auto:" means that if there is a conch file with a matchingÙJ** host ID in it, the proxy path in the conch file will be used, otherwiseÙ,** a proxy path based on the user's temp dirÙC** (via confstr(_CS_DARWIN_USER_TEMP_DIR,...)) will be used and theÙD** actual proxy file name is generated from the name and path of the¿** database file.  For example:¢**Ù.**       For database path "/Users/me/foo.db" ÙN**       The lock path will be "<tmpdir>/sqliteplocks/_Users_me_foo.db:auto:")¢**ÙH** Once a lock proxy is configured for a database connection, it can notÙG** be removed, however it may be switched to a different proxy path viaÙG** the above APIs (assuming the conch file is not being held by another»** connection or process). ¢**¢**º** How proxy locking worksº** -----------------------¢**ÙD** Proxy file locking relies primarily on two new supporting files: ¢**ÙH**   *  conch file to limit access to the database file to a single host±**      at a time¢**ÙD**   *  proxy file to act as a proxy for the advisory locks normally½**      taken on the database¢**ÙK** The conch file - to use a proxy file, sqlite must first "hold the conch"ÙG** by taking an sqlite-style shared lock on the conch file, reading theÙH** contents and comparing the host's unique host ID (see below) and lockÙH** proxy path against the values stored in the conch.  The conch file isÙF** stored in the same directory as the database file and the file nameÙH** is patterned after the database file name as ".<databasename>-conch".ÙE** If the conch file does not exist, or its contents do not match theÙH** host ID and/or proxy path, then the lock is escalated to an exclusiveÙI** lock and the conch file contents is updated with the host ID and proxyÙH** path and the lock is downgraded to a shared lock again.  If the conchÙF** is held by another process (with a shared lock), the exclusive lockÙ)** will fail and SQLITE_BUSY is returned.¢**ÙG** The proxy file - a single-byte file used for all advisory file locksÙF** normally taken on the database file.   This allows for safe sharingÙD** of the database file for multiple readers and writers on the sameÙG** host (the conch ensures that they all use the same local lock file).¢**ÙG** Requesting the lock proxy does not immediately take the conch, it isÙE** only taken when the first request to lock database file is made.  ÙH** This matches the semantics of the traditional locking behavior, whereÙF** opening a connection to a database file does not take a lock on it.ÙD** The shared lock and an open file descriptor are maintained until Ù-** the connection to the database is closed. ¢**ÙG** The proxy file and the lock file are never deleted so they only needÙ.** to be created the first time they are used.¢**¸** Configuration options¸** ---------------------¢**¿**  SQLITE_PREFER_PROXY_LOCKING¢**Ù>**       Database files accessed on non-local file systems areÙC**       automatically configured for proxy locking, lock files areÙ4**       named automatically using the same logic asÙ(**       PRAGMA lock_proxy_file=":auto:"¦**    ¶**  SQLITE_PROXY_DEBUG¢**ÙB**       Enables the logging of error messages during host id file¿**       retrieval and creation¢**°**  LOCKPROXYDIR¢**ÙG**       Overrides the default directory used for lock proxy files thatÙ9**       are named automatically via the ":auto:" setting¢**Ù'**  SQLITE_DEFAULT_PROXYDIR_PERMISSIONS¢**ÙE**       Permissions to use when creating a directory for storing theÙB**       lock proxy files, only used when LOCKPROXYDIR is not set.¦**    ¦**    ÙF** As mentioned above, when compiled with SQLITE_PREFER_PROXY_LOCKING,ÙH** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 willÙG** force proxy locking to be used for every database file opened, and 0ÙE** will force automatic proxy locking to be disabled for all databaseÙI** files (explicitly calling the SQLITE_FCNTL_SET_LOCKPROXYFILE pragma orÙJ** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).¢*/ ¢/*Ù-** Proxy locking is only available on MacOSX ¢*/Ù5#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE ¢/*ÙK** The proxyLockingContext has the path and file structures for the remote ¾** and local proxy files in it¢*/Ù7typedef struct proxyLockingContext proxyLockingContext;¼struct proxyLockingContext {Ù4  unixFile *conchFile;         /* Open conch file */Ù;  char *conchFilePath;         /* Name of the conch file */Ù9  unixFile *lockProxy;         /* Open proxy lock file */Ù@  char *lockProxyPath;         /* Name of the proxy lock file */Ù:  char *dbPath;                /* Name of the open file */ÙK  int conchHeld;               /* 1 if the conch is held, -1 if lockless */ÙD  int nFails;                  /* Number of conch taking failures */ÙP  void *oldLockingContext;     /* Original lockingcontext to restore on close */ÙP  sqlite3_io_methods const *pOldMethod;     /* Original I/O methods for close */¢}; £/* ÙN** The proxy lock file path for the database at dbPath is written into lPath, ÙN** which must point to valid, writable memory large enough for a maxLen length®** file path. ¢*/ÙLstatic int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){ª  int len;¬  int dbLen;¨  int i; ³#ifdef LOCKPROXYDIRÙ-  len = strlcpy(lPath, LOCKPROXYDIR, maxLen);¥#elseÙ # ifdef _CS_DARWIN_USER_TEMP_DIR£  {Ù<    if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){Ù:      OSTRACE(("GETLOCKPATH  failed %s errno=%d pid=%d\n",Ù+               lPath, errno, osGetpid(0)));¿      return SQLITE_IOERR_LOCK;¥    }Ù5    len = strlcat(lPath, "sqliteplocks", maxLen);    £  }¦# elseÙ(  len = strlcpy(lPath, "/tmp/", maxLen);§# endif¦#endif º  if( lPath[len-1]!='/' ){Ù&    len = strlcat(lPath, "/", maxLen);£  }¢  Ù4  /* transform the db path to a unique cache name */¾  dbLen = (int)strlen(dbPath);Ù3  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){·    char c = dbPath[i];Ù"    lPath[i+len] = (c=='/')?'_':c;£  }´  lPath[i+len]='\0';Ù#  strlcat(lPath, ":auto:", maxLen);ÙL  OSTRACE(("GETLOCKPATH  proxy lock path=%s pid=%d\n", lPath, osGetpid(0)));³  return SQLITE_OK;¡} £/* ÙA ** Creates the lock file and any missing directories in lockPath£ */Ù5static int proxyCreateLockPath(const char *lockPath){­  int i, len;·  char buf[MAXPATHLEN];°  int start = 0;¢  ¹  assert(lockPath!=NULL);Ù6  /* try to create all the intermediate directories */¾  len = (int)strlen(lockPath);·  buf[0] = lockPath[0];¹  for( i=1; i<len; i++ ){Ù0    if( lockPath[i] == '/' && (i - start > 0) ){Ù8      /* only mkdir if leaf dir != "." or "/" or ".." */ÙN      if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/') ÙG         || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){´        buf[i]='\0';Ù@        if( osMkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS) ){¸          int err=errno;½          if( err!=EEXIST ) {Ù;            OSTRACE(("CREATELOCKPATH  FAILED creating %s, "Ù8                     "'%s' proxy lock path=%s pid=%d\n",ÙA                     buf, strerror(err), lockPath, osGetpid(0)));·            return err;«          }©        }§      }°      start=i+1;¥    }¹    buf[i] = lockPath[i];£  }ÙP  OSTRACE(("CREATELOCKPATH  proxy lock path=%s pid=%d\n",lockPath,osGetpid(0)));«  return 0;¡} ¢/*ÙC** Create a new VFS file descriptor (stored in memory obtained fromÙI** sqlite3_malloc) and open the file named "path" in the file descriptor.¢**ÙE** The caller is responsible not only for closing the file descriptorÙG** but also for freeing the memory associated with the file descriptor.¢*/¿static int proxyCreateUnixFile(Ù<    const char *path,        /* path for the new unixFile */ÙG    unixFile **ppFile,       /* unixFile created and returned by ref */ÙK    int islockfile           /* if non zero missing dirs will be created */£) {®  int fd = -1;±  unixFile *pNew;µ  int rc = SQLITE_OK;Ù#  int openFlags = O_RDWR | O_CREAT;·  sqlite3_vfs dummyVfs;±  int terrno = 0;¿  UnixUnusedFd *pUnused = NULL; Ù)  /* 1. first try to open/create the fileÙH  ** 2. if that fails, and this is a lock file (not-conch), try creatingÙ/  ** the parent directories and then try again.Ù5  ** 3. if that fails, try to open the file read-onlyÙH  ** otherwise return BUSY (if lock file) or CANTOPEN for the conch file¤  */Ù,  pUnused = findReusableFd(path, openFlags);°  if( pUnused ){µ    fd = pUnused->fd;¨  }else{Ù1    pUnused = sqlite3_malloc64(sizeof(*pUnused));³    if( !pUnused ){¿      return SQLITE_NOMEM_BKPT;¥    }£  }­  if( fd<0 ){Ù)    fd = robust_open(path, openFlags, 0);³    terrno = errno;Ù.    if( fd<0 && errno==ENOENT && islockfile ){Ù3      if( proxyCreateLockPath(path) == SQLITE_OK ){Ù-        fd = robust_open(path, openFlags, 0);§      }¥    }£  }­  if( fd<0 ){¹    openFlags = O_RDONLY;Ù)    fd = robust_open(path, openFlags, 0);³    terrno = errno;£  }­  if( fd<0 ){µ    if( islockfile ){¹      return SQLITE_BUSY;¥    }µ    switch (terrno) {²      case EACCES:»        return SQLITE_PERM;°      case EIO: ÙC        return SQLITE_IOERR_LOCK; /* even though it is the conch */®      default:Ù$        return SQLITE_CANTOPEN_BKPT;¥    }£  }¢  Ù5  pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));³  if( pNew==NULL ){»    rc = SQLITE_NOMEM_BKPT;º    goto end_create_proxy;£  }Ù$  memset(pNew, 0, sizeof(unixFile));¾  pNew->openFlags = openFlags;Ù)  memset(&dummyVfs, 0, sizeof(dummyVfs));Ù/  dummyVfs.pAppData = (void*)&autolockIoFinder;»  dummyVfs.zName = "dummy";³  pUnused->fd = fd;½  pUnused->flags = openFlags;Ù&  pNew->pPreallocatedUnused = pUnused;¢  ÙC  rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file*)pNew, path, 0);¶  if( rc==SQLITE_OK ){³    *ppFile = pNew;µ    return SQLITE_OK;£  }µend_create_proxy:    Ù#  robust_close(pNew, fd, __LINE__);µ  sqlite3_free(pNew);¸  sqlite3_free(pUnused);¬  return rc;¡} ²#ifdef SQLITE_TESTÙB/* simulate multiple hosts by creating unique hostid file paths */Ù&SQLITE_API int sqlite3_hostid_num = 0;¦#endif Ù>#define PROXY_HOSTIDLEN    16  /* conch file host id length */ ·#ifdef HAVE_GETHOSTUUIDÙ9/* Not always defined in the headers as it ought to be */Ù?extern int gethostuuid(uuid_t id, const struct timespec *wait);¦#endif ÙL/* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN ¼** bytes of writable memory.¢*/Ù?static int proxyGetHostID(unsigned char *pHostID, int *pError){Ù,  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));Ù&  memset(pHostID, 0, PROXY_HOSTIDLEN);·#ifdef HAVE_GETHOSTUUID£  {Ù9    struct timespec timeout = {1, 0}; /* 1 sec timeout */Ù)    if( gethostuuid(pHostID, &timeout) ){¶      int err = errno;³      if( pError ){¶        *pError = err;§      }º      return SQLITE_IOERR;¥    }£  }¥#else»  UNUSED_PARAMETER(pError);¦#endif²#ifdef SQLITE_TESTÙD  /* simulate multiple hosts by creating unique hostid file paths */¿  if( sqlite3_hostid_num != 0){ÙH    pHostID[0] = (char)(pHostID[0] + (char)(sqlite3_hostid_num & 0xFF));£  }¦#endif¢  ³  return SQLITE_OK;¡} ÙA/* The conch file contains the header, host id and lock file path£ */ÙI#define PROXY_CONCHVERSION 2   /* 1-byte header, 16-byte host id, path */Ù=#define PROXY_HEADERLEN    1   /* conch file header length */Ù<#define PROXY_PATHINDEX    (PROXY_HEADERLEN+PROXY_HOSTIDLEN)ÙG#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN) £/* ÙN** Takes an open conch file, copies the contents to a new path and then moves ÙH** it back.  The newly created file's file descriptor is assigned to theÙJ** conch file structure and finally the original conch file descriptor is Ù'** closed.  Returns zero if successful.¢*/ÙAstatic int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){ÙL  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; Ù(  unixFile *conchFile = pCtx->conchFile;¹  char tPath[MAXPATHLEN];¾  char buf[PROXY_MAXCONCHLEN];Ù$  char *cPath = pCtx->conchFilePath;µ  size_t readLen = 0;µ  size_t pathLen = 0;·  char errmsg[64] = "";®  int fd = -1;®  int rc = -1;½  UNUSED_PARAMETER(myHostID); ÙH  /* create a new path by replace the trailing '-conch' with '-break' */Ù.  pathLen = strlcpy(tPath, cPath, MAXPATHLEN);Ù)  if( pathLen>MAXPATHLEN || pathLen<6 || Ù5     (strlcpy(&tPath[pathLen-5], "break", 6) != 5) ){ÙO    sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);·    goto end_breaklock;£  }¾  /* read the conch content */Ù=  readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);Ù   if( readLen<PROXY_PATHINDEX ){ÙO    sqlite3_snprintf(sizeof(errmsg),errmsg,"read error (len %d)",(int)readLen);·    goto end_breaklock;£  }Ù0  /* write it out to the temporary break file */Ù6  fd = robust_open(tPath, (O_RDWR|O_CREAT|O_EXCL), 0);­  if( fd<0 ){ÙJ    sqlite3_snprintf(sizeof(errmsg), errmsg, "create failed (%d)", errno);·    goto end_breaklock;£  }Ù:  if( osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen ){ÙI    sqlite3_snprintf(sizeof(errmsg), errmsg, "write failed (%d)", errno);·    goto end_breaklock;£  }½  if( rename(tPath, cPath) ){ÙJ    sqlite3_snprintf(sizeof(errmsg), errmsg, "rename failed (%d)", errno);·    goto end_breaklock;£  }©  rc = 0;Ù5  fprintf(stderr, "broke stale lock on %s\n", cPath);Ù.  robust_close(pFile, conchFile->h, __LINE__);´  conchFile->h = fd;Ù*  conchFile->openFlags = O_RDWR | O_CREAT; ®end_breaklock:«  if( rc ){°    if( fd>=0 ){¶      osUnlink(tPath);Ù(      robust_close(pFile, fd, __LINE__);¥    }ÙM    fprintf(stderr, "failed to break stale lock on %s, %s\n", cPath, errmsg);£  }¬  return rc;¡} ÙK/* Take the requested lock on the conch file and break a stale lock if the ³** host id matches.¢*/ÙJstatic int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){ÙL  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; Ù(  unixFile *conchFile = pCtx->conchFile;µ  int rc = SQLITE_OK;±  int nTries = 0;¿  struct timespec conchModTime;¢  Ù1  memset(&conchModTime, 0, sizeof(conchModTime));¦  do {ÙG    rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);®    nTries ++;º    if( rc==SQLITE_BUSY ){Ù#      /* If the lock failed (busy):ÙJ       * 1st try: get the mod time of the conch, wait 0.5s and try again. ÙM       * 2nd try: fail if the mod time changed or host id is different, wait Ù'       *           10 sec and try againÙA       * 3rd try: break the lock unless the mod time has changed.©       */¶      struct stat buf;Ù(      if( osFstat(conchFile->h, &buf) ){Ù%        storeLastErrno(pFile, errno);Ù!        return SQLITE_IOERR_LOCK;§      }¦      ¶      if( nTries==1 ){Ù(        conchModTime = buf.st_mtimespec;Ù@        usleep(500000); /* wait 0.5 sec and try the lock again*/³        continue;  §      } ¹      assert( nTries>1 );Ù<      if( conchModTime.tv_sec != buf.st_mtimespec.tv_sec || Ù<         conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec ){»        return SQLITE_BUSY;§      }¦      ¸      if( nTries==2 ){  Ù%        char tBuf[PROXY_MAXCONCHLEN];ÙD        int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);´        if( len<0 ){Ù'          storeLastErrno(pFile, errno);Ù#          return SQLITE_IOERR_LOCK;©        }ÙF        if( len>PROXY_PATHINDEX && tBuf[0]==(char)PROXY_CONCHVERSION){ÙA          /* don't break the lock if the host id doesn't match */ÙM          if( 0!=memcmp(&tBuf[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN) ){¿            return SQLITE_BUSY;«          }®        }else{ÙH          /* don't break the lock on short read or a version mismatch */½          return SQLITE_BUSY;©        }ÙB        usleep(10000000); /* wait 10 sec and try the lock again */²        continue; §      }¦      º      assert( nTries==3 );Ù4      if( 0==proxyBreakConchLock(pFile, myHostID) ){·        rc = SQLITE_OK;Ù'        if( lockType==EXCLUSIVE_LOCK ){ÙP          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);©        }²        if( !rc ){ÙM          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);©        }§      }¥    }Ù)  } while( rc==SQLITE_BUSY && nTries<3 );¢  ¬  return rc;¡} ÙK/* Takes the conch by taking a shared lock and read the contents conch, if ÙL** lockPath is non-NULL, the host ID and lock file path must match.  A NULL ÙJ** lockPath means that the lockPath in the conch file will be used if the ÙF** host IDs match, or a new lock path will be generated automatically Ù!** and written to the conch file.¢*/Ù+static int proxyTakeConch(unixFile *pFile){ÙL  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; ¢  »  if( pCtx->conchHeld!=0 ){µ    return SQLITE_OK;¨  }else{Ù*    unixFile *conchFile = pCtx->conchFile;´    uuid_t myHostID;³    int pError = 0;Ù$    char readBuf[PROXY_MAXCONCHLEN];¾    char lockPath[MAXPATHLEN];¾    char *tempLockPath = NULL;·    int rc = SQLITE_OK;¸    int createConch = 0;¸    int hostIdMatch = 0;´    int readLen = 0;»    int tryOldLockPath = 0;½    int forceNewLockPath = 0;¤    Ù;    OSTRACE(("TAKECONCH  %d for %s pid=%d\n", conchFile->h,ÙD             (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),»             osGetpid(0))); Ù+    rc = proxyGetHostID(myHostID, &pError);Ù"    if( (rc&0xff)==SQLITE_IOERR ){Ù$      storeLastErrno(pFile, pError);¹      goto end_takeconch;¥    }Ù6    rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);¸    if( rc!=SQLITE_OK ){¹      goto end_takeconch;¥    }Ù&    /* read the existing conch file */ÙO    readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);´    if( readLen<0 ){Ù3      /* I/O error: lastErrno set by seekAndRead */Ù2      storeLastErrno(pFile, conchFile->lastErrno);½      rc = SQLITE_IOERR_READ;¹      goto end_takeconch;Ù<    }else if( readLen<=(PROXY_HEADERLEN+PROXY_HOSTIDLEN) || Ù4             readBuf[0]!=(char)PROXY_CONCHVERSION ){ÙO      /* a short read or version format mismatch means we need to create a new µ      ** conch file. ¨      */¶      createConch = 1;¥    }ÙK    /* if the host id matches and the lock path already exists in the conchÙJ    ** we'll try to use the path there, if we can't open that path, we'll Ù,    ** retry with a new auto-generated path ¦    */ÙI    do { /* in case we need to try again for an :auto: named lock file */ Ù.      if( !createConch && !forceNewLockPath ){ÙC        hostIdMatch = !memcmp(&readBuf[PROXY_HEADERLEN], myHostID, Ù3                                  PROXY_HOSTIDLEN);Ù8        /* if the conch has data compare the contents */Ù#        if( !pCtx->lockProxyPath ){ÙM          /* for auto-named local lock file, just check the host ID and we'llÙB           ** use the local lock file path that's already in there­           */¼          if( hostIdMatch ){Ù9            size_t pathLen = (readLen - PROXY_PATHINDEX);¬            Ù&            if( pathLen>=MAXPATHLEN ){Ù#              pathLen=MAXPATHLEN-1;­            }ÙA            memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);Ù"            lockPath[pathLen] = 0;Ù$            tempLockPath = lockPath;¿            tryOldLockPath = 1;ÙF            /* create a copy of the lock path if the conch is taken */¿            goto end_takeconch;«          }½        }else if( hostIdMatchÙJ               && !strncmp(pCtx->lockProxyPath, &readBuf[PROXY_PATHINDEX],Ù3                           readLen-PROXY_PATHINDEX)ª        ){Ù.          /* conch host and lock path match */¾          goto end_takeconch; ©        }§      }¦      ÙK      /* if the conch isn't writable and doesn't match, we can't take it */Ù/      if( (conchFile->openFlags&O_RDWR) == 0 ){¹        rc = SQLITE_BUSY;»        goto end_takeconch;§      }¦      ÙH      /* either the conch didn't match or we need to create a new one */Ù!      if( !pCtx->lockProxyPath ){Ù=        proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);Ù         tempLockPath = lockPath;ÙI        /* create a copy of the lock path _only_ if the conch is taken */§      }¦      ÙI      /* update conch with host and path (this will fail if other processÙH      ** has a shared lock already), if the host id matches, use the big¯      ** stick.¨      */Ù"      futimes(conchFile->h, NULL);Ù(      if( hostIdMatch && !createConch ){Ù@        if( conchFile->pInode && conchFile->pInode->nShared>1 ){ÙK          /* We are trying for an exclusive lock but another thread in thisÙ=           ** same process is still holding a shared lock. */»          rc = SQLITE_BUSY;º        } else {          Ù?          rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);©        }¬      }else{Ù=        rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);§      }º      if( rc==SQLITE_OK ){Ù,        char writeBuffer[PROXY_MAXCONCHLEN];º        int writeSize = 0;¨        Ù2        writeBuffer[0] = (char)PROXY_CONCHVERSION;ÙI        memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);Ù(        if( pCtx->lockProxyPath!=NULL ){ÙE          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath,¾                  MAXPATHLEN);®        }else{ÙK          strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);©        }ÙL        writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);Ù2        robust_ftruncate(conchFile->h, writeSize);ÙM        rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);Ù%        full_fsync(conchFile->h,0,0);ÙN        /* If we created a new conch file (not just updated the contents of a ÙL         ** valid conch file), try to match the permissions of the database «         */Ù+        if( rc==SQLITE_OK && createConch ){º          struct stat buf;Ù,          int err = osFstat(pFile->h, &buf);·          if( err==0 ){ÙK            mode_t cmode = buf.st_mode&(S_IRUSR|S_IWUSR | S_IRGRP|S_IWGRP |Ù9                                        S_IROTH|S_IWOTH);ÙP            /* try to match the database file R/W permissions, ignore failure */º#ifndef SQLITE_PROXY_DEBUGÙ*            osFchmod(conchFile->h, cmode);¥#else¯            do{Ù1              rc = osFchmod(conchFile->h, cmode);Ù/            }while( rc==(-1) && errno==EINTR );¸            if( rc!=0 ){¿              int code = errno;Ù>              fprintf(stderr, "fchmod %o FAILED with %d %s\n",Ù3                      cmode, code, strerror(code));´            } else {Ù<              fprintf(stderr, "fchmod %o SUCCEDED\n",cmode);­            }°          }else{½            int code = errno;Ù<            fprintf(stderr, "STAT FAILED[%d] with %d %s\n", Ù/                    err, code, strerror(code));¦#endif«          }©        }§      }ÙI      conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, SHARED_LOCK);¦      ²    end_takeconch:Ù5      OSTRACE(("TRANSPROXY: CLOSE  %d\n", pFile->h));Ù.      if( rc==SQLITE_OK && pFile->openFlags ){¯        int fd;º        if( pFile->h>=0 ){Ù2          robust_close(pFile, pFile->h, __LINE__);©        }¶        pFile->h = -1;Ù<        fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);Ù0        OSTRACE(("TRANSPROXY: OPEN  %d\n", fd));´        if( fd>=0 ){¸          pFile->h = fd;®        }else{ÙH          rc=SQLITE_CANTOPEN_BKPT; /* SQLITE_BUSY? proxyTakeConch called¼           during locking */©        }§      }Ù.      if( rc==SQLITE_OK && !pCtx->lockProxy ){ÙG        char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;Ù<        rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);ÙB        if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM && tryOldLockPath ){ÙO          /* we couldn't create the proxy lock file with the old lock file pathÙ+           ** so try again via auto-naming ­           */¿          forceNewLockPath = 1;½          tryOldLockPath = 0;ÙK          continue; /* go back to the do {} while start point, try again */©        }§      }º      if( rc==SQLITE_OK ){Ù@        /* Need to make a copy of path if we extracted the valueÙF         ** from the conch file or the path was allocated on the stack«         */»        if( tempLockPath ){ÙA          pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);Ù%          if( !pCtx->lockProxyPath ){Ù#            rc = SQLITE_NOMEM_BKPT;«          }©        }§      }º      if( rc==SQLITE_OK ){¼        pCtx->conchHeld = 1;¨        Ù8        if( pCtx->lockProxy->pMethod == &afpIoMethods ){Ù$          afpLockingContext *afpCtx;ÙH          afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;Ù/          afpCtx->dbPath = pCtx->lockProxyPath;©        }®      } else {ÙG        conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);§      }Ù2      OSTRACE(("TAKECONCH  %d %s\n", conchFile->h,Ù-               rc==SQLITE_OK?"ok":"failed"));°      return rc;ÙD    } while (1); /* in case we need to retry the :auto: lock file - ÙO                 ** we should never get here except via the 'continue' call. */£  }¡} ¢/*ÙA** If pFile holds a lock on a conch file, then release that lock.¢*/Ù.static int proxyReleaseConch(unixFile *pFile){Ù:  int rc = SQLITE_OK;         /* Subroutine return code */ÙJ  proxyLockingContext *pCtx;  /* The locking context for the proxy lock */Ù:  unixFile *conchFile;        /* Name of the conch file */ Ù6  pCtx = (proxyLockingContext *)pFile->lockingContext;¾  conchFile = pCtx->conchFile;Ù<  OSTRACE(("RELEASECONCH  %d for %s pid=%d\n", conchFile->h,ÙC           (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"), ¹           osGetpid(0)));º  if( pCtx->conchHeld>0 ){ÙH    rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);£  }¶  pCtx->conchHeld = 0;Ù1  OSTRACE(("RELEASECONCH  %d %s\n", conchFile->h,Ù/           (rc==SQLITE_OK ? "ok" : "failed")));¬  return rc;¡} ¢/*ÙI** Given the name of a database file, compute the name of its conch file.ÙG** Store the conch filename in memory obtained from sqlite3_malloc64().ÙG** Make *pConchPath point to the new name.  Return SQLITE_OK on successÙ.** or SQLITE_NOMEM if unable to obtain memory.¢**ÙC** The caller is responsible for ensuring that the allocated memory½** space is eventually freed.¢**ÙB** *pConchPath is set to NULL if a memory allocation error occurs.¢*/ÙEstatic int proxyCreateConchPathname(char *dbPath, char **pConchPath){Ù2  int i;                        /* Loop counter */ÙK  int len = (int)strlen(dbPath); /* Length of database filename - dbPath */ÙM  char *conchPath;              /* buffer in which to construct conch name */ ÙE  /* Allocate space for the conch filename and initialize the name toÙ1  ** the name of the original database file. */  Ù>  *pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);µ  if( conchPath==0 ){½    return SQLITE_NOMEM_BKPT;£  }Ù#  memcpy(conchPath, dbPath, len+1);¢  Ù4  /* now insert a "." before the last / character */¾  for( i=(len-1); i>=0; i-- ){¼    if( conchPath[i]=='/' ){ª      i++;¬      break;¥    }£  }³  conchPath[i]='.';²  while ( i<len ){½    conchPath[i+1]=dbPath[i];¨    i++;£  } Ù.  /* append the "-conch" suffix to the file */Ù'  memcpy(&conchPath[i+1], "-conch", 7);Ù,  assert( (int)strlen(conchPath) == len+7 ); ³  return SQLITE_OK;¡}  ÙF/* Takes a fully configured proxy locking-style unix file and switches¼** the local lock file path ¢*/ÙCstatic int switchLockProxyPath(unixFile *pFile, const char *path) {ÙJ  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;Ù&  char *oldPath = pCtx->lockProxyPath;µ  int rc = SQLITE_OK; Ù"  if( pFile->eFileLock!=NO_LOCK ){·    return SQLITE_BUSY;¥  }   ÙN  /* nothing to do if the path is NULL, :auto: or matches the existing path */Ù:  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ||Ù7    (oldPath && !strncmp(oldPath, path, MAXPATHLEN)) ){µ    return SQLITE_OK;¨  }else{Ù*    unixFile *lockProxy = pCtx->lockProxy;¹    pCtx->lockProxy=NULL;¸    pCtx->conchHeld = 0;º    if( lockProxy!=NULL ){Ù?      rc=lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);¹      if( rc ) return rc;¾      sqlite3_free(lockProxy);¥    }º    sqlite3_free(oldPath);Ù3    pCtx->lockProxyPath = sqlite3DbStrDup(0, path);£  }¢  ¬  return rc;¡} ¢/*ÙF** pFile is a file that has been opened by a prior xOpen call.  dbPathÙ?** is a string buffer at least MAXPATHLEN+1 characters in size.¢**ÙE** This routine find the filename associated with pFile and writes it®** int dbPath.¢*/ÙDstatic int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){¶#if defined(__APPLE__)Ù(  if( pFile->pMethod == &afpIoMethods ){ÙH    /* afp style keeps a reference to the db path in the filePath field ·    ** of the struct */ÙD    assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );ÙI    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,¸            MAXPATHLEN);¨  } else¦#endifÙ,  if( pFile->pMethod == &dotlockIoMethods ){ÙD    /* dot lock style uses the locking context to store the dot lock³    ** file path */ÙM    int len = strlen((char *)pFile->lockingContext) - strlen(DOTLOCK_SUFFIX);Ù;    memcpy(dbPath, (char *)pFile->lockingContext, len + 1);¨  }else{ÙL    /* all other styles use the locking context to store the db file path */Ù?    assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );Ù?    strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);£  }³  return SQLITE_OK;¡} ¢/*ÙJ** Takes an already filled in unix file and alters it so all file locking ÙH** will be performed on the local proxy lock file.  The following fieldsÙI** are preserved in the locking context so that they can be restored and Ù8** the unix structure properly cleaned up at close time:´**  ->lockingContext­**  ->pMethod¢*/ÙFstatic int proxyTransformUnixFile(unixFile *pFile, const char *path) {¼  proxyLockingContext *pCtx;ÙB  char dbPath[MAXPATHLEN+1];       /* Name of the database file */¶  char *lockPath=NULL;µ  int rc = SQLITE_OK;¢  Ù"  if( pFile->eFileLock!=NO_LOCK ){·    return SQLITE_BUSY;£  }Ù+  proxyGetDbPathForUnixFile(pFile, dbPath);Ù:  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ){²    lockPath=NULL;¨  }else{º    lockPath=(char *)path;£  }¢  Ù6  OSTRACE(("TRANSPROXY  %d for %s pid=%d\n", pFile->h,Ù;           (lockPath ? lockPath : ":auto:"), osGetpid(0))); Ù+  pCtx = sqlite3_malloc64( sizeof(*pCtx) );°  if( pCtx==0 ){½    return SQLITE_NOMEM_BKPT;£  }Ù!  memset(pCtx, 0, sizeof(*pCtx)); Ù>  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);¶  if( rc==SQLITE_OK ){ÙG    rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);ÙB    if( rc==SQLITE_CANTOPEN && ((pFile->openFlags&O_RDWR) == 0) ){ÙM      /* if (a) the open flags are not O_RDWR, (b) the conch isn't there, andÙI      ** (c) the file system is read-only, then enable no-locking access.ÙO      ** Ugh, since O_RDONLY==0x0000 we test for !O_RDWR since unixOpen assertsÙA      ** that openFlags will have only one of O_RDONLY or O_RDWR.¨      */»      struct statfs fsInfo;¼      struct stat conchInfo;¹      int goLockless = 0; Ù;      if( osStat(pCtx->conchFilePath, &conchInfo) == -1 ) {¸        int err = errno;Ù?        if( (err==ENOENT) && (statfs(dbPath, &fsInfo) != -1) ){ÙA          goLockless = (fsInfo.f_flags&MNT_RDONLY) == MNT_RDONLY;©        }§      }·      if( goLockless ){Ù:        pCtx->conchHeld = -1; /* read only FS/ lockless */·        rc = SQLITE_OK;§      }¥    }¥  }  Ù"  if( rc==SQLITE_OK && lockPath ){Ù7    pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);£  } ¶  if( rc==SQLITE_OK ){Ù.    pCtx->dbPath = sqlite3DbStrDup(0, dbPath);½    if( pCtx->dbPath==NULL ){½      rc = SQLITE_NOMEM_BKPT;¥    }£  }¶  if( rc==SQLITE_OK ){ÙA    /* all memory is allocated, proxys are created and assigned, Ù:    ** switch the locking context and pMethod then return.¦    */Ù4    pCtx->oldLockingContext = pFile->lockingContext;Ù!    pFile->lockingContext = pCtx;Ù&    pCtx->pOldMethod = pFile->pMethod;Ù%    pFile->pMethod = &proxyIoMethods;¨  }else{»    if( pCtx->conchFile ){ ÙH      pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);Ù$      sqlite3_free(pCtx->conchFile);¥    }Ù*    sqlite3DbFree(0, pCtx->lockProxyPath);Ù'    sqlite3_free(pCtx->conchFilePath); ·    sqlite3_free(pCtx);£  }Ù+  OSTRACE(("TRANSPROXY  %d %s\n", pFile->h,Ù/           (rc==SQLITE_OK ? "ok" : "failed")));¬  return rc;¡}  ¢/*ÙF** This routine handles sqlite3_file_control() calls that are specific´** to proxy locking.¢*/ÙBstatic int proxyFileControl(sqlite3_file *id, int op, void *pArg){¯  switch( op ){Ù*    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {Ù&      unixFile *pFile = (unixFile*)id;Ù.      if( pFile->pMethod == &proxyIoMethods ){ÙP        proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;¾        proxyTakeConch(pFile);Ù"        if( pCtx->lockProxyPath ){Ù5          *(const char **)pArg = pCtx->lockProxyPath;®        }else{Ù5          *(const char **)pArg = ":auto: (not held)";©        }®      } else {Ù$        *(const char **)pArg = NULL;§      }·      return SQLITE_OK;¥    }Ù*    case SQLITE_FCNTL_SET_LOCKPROXYFILE: {Ù&      unixFile *pFile = (unixFile*)id;¹      int rc = SQLITE_OK;Ù=      int isProxyStyle = (pFile->pMethod == &proxyIoMethods);Ù0      if( pArg==NULL || (const char *)pArg==0 ){»        if( isProxyStyle ){ÙM          /* turn off proxy locking - not supported.  If support is added forÙJ          ** switching proxy locking mode off then it will need to fail ifÙ+          ** the journal mode is WAL mode. ¬          */Ù@          rc = SQLITE_ERROR /*SQLITE_PROTOCOL? SQLITE_MISUSE?*/;®        }else{Ù;          /* turn off proxy locking - already off - NOOP */¹          rc = SQLITE_OK;©        }¬      }else{Ù3        const char *proxyPath = (const char *)pArg;»        if( isProxyStyle ){Ù&          proxyLockingContext *pCtx = Ù8            (proxyLockingContext*)pFile->lockingContext;Ù&          if( !strcmp(pArg, ":auto:") Ù%           || (pCtx->lockProxyPath &&ÙD               !strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))¬          ){»            rc = SQLITE_OK;°          }else{Ù7            rc = switchLockProxyPath(pFile, proxyPath);«          }®        }else{Ù*          /* turn on proxy file locking */Ù8          rc = proxyTransformUnixFile(pFile, proxyPath);©        }§      }°      return rc;¥    }®    default: {ÙK      assert( 0 );  /* The call assures that only valid opcodes are sent */¥    }£  }°  /*NOTREACHED*/¶  return SQLITE_ERROR;¡} ¢/*ÙL** Within this division (the proxying locking implementation) the proceduresÙG** above this point are all utilities.  The lock-related methods of theÙ1** proxy-locking sqlite3_io_method object follow.¢*/  ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙJ** file by this or any other process. If such a lock is held, set *pResOutÙK** to a non-zero value otherwise *pResOut is set to zero.  The return valueÙG** is set to SQLITE_OK unless an I/O error occurs during lock checking.¢*/ÙCstatic int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {Ù"  unixFile *pFile = (unixFile*)id;Ù!  int rc = proxyTakeConch(pFile);¶  if( rc==SQLITE_OK ){ÙM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;¼    if( pCtx->conchHeld>0 ){Ù(      unixFile *proxy = pCtx->lockProxy;ÙO      return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);Ù*    }else{ /* conchHeld < 0 is lockless */°      pResOut=0;¥    }£  }¬  return rc;¡} ¢/*ÙE** Lock the file with the lock specified by parameter eFileLock - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙE** This routine will only increase a lock.  Use the sqlite3OsUnlock()Ù$** routine to lower a locking level.¢*/Ù7static int proxyLock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;Ù!  int rc = proxyTakeConch(pFile);¶  if( rc==SQLITE_OK ){ÙM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;¼    if( pCtx->conchHeld>0 ){Ù(      unixFile *proxy = pCtx->lockProxy;ÙB      rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);Ù*      pFile->eFileLock = proxy->eFileLock;ª    }else{Ù%      /* conchHeld < 0 is lockless */¥    }£  }¬  return rc;¡}  ¢/*ÙL** Lower the locking level on file descriptor pFile to eFileLock.  eFileLockÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢*/Ù9static int proxyUnlock(sqlite3_file *id, int eFileLock) {Ù"  unixFile *pFile = (unixFile*)id;Ù!  int rc = proxyTakeConch(pFile);¶  if( rc==SQLITE_OK ){ÙM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;¼    if( pCtx->conchHeld>0 ){Ù(      unixFile *proxy = pCtx->lockProxy;ÙD      rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);Ù*      pFile->eFileLock = proxy->eFileLock;ª    }else{Ù%      /* conchHeld < 0 is lockless */¥    }£  }¬  return rc;¡} ¢/*Ù&** Close a file that uses proxy locks.¢*/Ù)static int proxyClose(sqlite3_file *id) {³  if( ALWAYS(id) ){Ù$    unixFile *pFile = (unixFile*)id;ÙM    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;Ù*    unixFile *lockProxy = pCtx->lockProxy;Ù*    unixFile *conchFile = pCtx->conchFile;·    int rc = SQLITE_OK;¤    ´    if( lockProxy ){ÙJ      rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, NO_LOCK);¹      if( rc ) return rc;Ù@      rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);¹      if( rc ) return rc;¾      sqlite3_free(lockProxy);º      pCtx->lockProxy = 0;¥    }´    if( conchFile ){¼      if( pCtx->conchHeld ){Ù&        rc = proxyReleaseConch(pFile);»        if( rc ) return rc;§      }Ù@      rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);¹      if( rc ) return rc;¾      sqlite3_free(conchFile);¥    }Ù*    sqlite3DbFree(0, pCtx->lockProxyPath);Ù&    sqlite3_free(pCtx->conchFilePath);Ù#    sqlite3DbFree(0, pCtx->dbPath);ÙH    /* restore the original locking context and pMethod then close it */Ù4    pFile->lockingContext = pCtx->oldLockingContext;Ù&    pFile->pMethod = pCtx->pOldMethod;·    sqlite3_free(pCtx);Ù&    return pFile->pMethod->xClose(id);£  }³  return SQLITE_OK;¡}   Ù>#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */¢/*ÙD** The proxy locking style is intended for use with AFP filesystems.ÙG** And since AFP is only supported on MacOSX, the proxy locking is also¸** restricted to MacOSX.£** ¢**ÙO******************* End of the proxy lock implementation **********************ÙO******************************************************************************/ ¢/*Ù-** Initialize the operating system interface.¢**ÙI** This routine registers all VFS implementations for unix-like operatingÙI** systems.  This routine, and the sqlite3_os_end() routine that follows,ÙG** should be the only routines in this file that are visible from other©** files.¢**ÙD** This routine is called once during SQLite initialization and by aÙF** single thread.  The memory allocation and mutex subsystems have notÙH** necessarily been initialized when this routine is called, and so they¶** should not be used.¢*/Ù&SQLITE_API int sqlite3_os_init(void){ ¥  /* ÙJ  ** The following macro defines an initializer for an sqlite3_vfs object.ÙI  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointerÙK  ** to the "finder" function.  (pAppData is a pointer to a pointer becauseÙK  ** silly C90 rules prohibit a void* from being cast to a function pointerÙL  ** and so we have to go through the intermediate pointer to avoid problemsÙ2  ** when compiling with -pedantic-errors on GCC.)¤  **ÙI  ** The FINDER parameter to this macro is the name of the pointer to theÙC  ** finder-function.  The finder-function returns a pointer to theÙA  ** sqlite_io_methods object that implements the desired lockingÙC  ** behaviors.  See the division above that contains the IOMETHODSÙ8  ** macro for addition information on finder-functions.¤  **ÙG  ** Most finders simply return a pointer to a fixed sqlite3_io_methodsÙJ  ** object.  But the "autolockIoFinder" available on MacOSX does a littleÙD  ** more than that; it looks at the filesystem type that hosts the ÙH  ** database file and tries to choose an locking method appropriate forº  ** that filesystem time.¤  */Ù=  #define UNIXVFS(VFSNAME, FINDER) {                        \Ù=    3,                    /* iVersion */                    \Ù=    sizeof(unixFile),     /* szOsFile */                    \Ù=    MAX_PATHNAME,         /* mxPathname */                  \Ù=    0,                    /* pNext */                       \Ù=    VFSNAME,              /* zName */                       \Ù=    (void*)&FINDER,       /* pAppData */                    \Ù=    unixOpen,             /* xOpen */                       \Ù=    unixDelete,           /* xDelete */                     \Ù=    unixAccess,           /* xAccess */                     \Ù=    unixFullPathname,     /* xFullPathname */               \Ù=    unixDlOpen,           /* xDlOpen */                     \Ù=    unixDlError,          /* xDlError */                    \Ù=    unixDlSym,            /* xDlSym */                      \Ù=    unixDlClose,          /* xDlClose */                    \Ù=    unixRandomness,       /* xRandomness */                 \Ù=    unixSleep,            /* xSleep */                      \Ù=    unixCurrentTime,      /* xCurrentTime */                \Ù=    unixGetLastError,     /* xGetLastError */               \Ù=    unixCurrentTimeInt64, /* xCurrentTimeInt64 */           \Ù=    unixSetSystemCall,    /* xSetSystemCall */              \Ù=    unixGetSystemCall,    /* xGetSystemCall */              \Ù=    unixNextSystemCall,   /* xNextSystemCall */             \£  } ¤  /*ÙE  ** All default VFSes for unix are contained in the following array.¤  **ÙH  ** Note that the sqlite3_vfs.pNext field of the VFS object is modifiedÙE  ** by the SQLite core when the VFS is registered.  So the following»  ** array cannot be const.¤  */¿  static sqlite3_vfs aVfs[] = {Ù5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ù0    UNIXVFS("unix",          autolockIoFinder ),°#elif OS_VXWORKSÙ/    UNIXVFS("unix",          vxworksIoFinder ),¥#elseÙ-    UNIXVFS("unix",          posixIoFinder ),¦#endifÙ.    UNIXVFS("unix-none",     nolockIoFinder ),Ù/    UNIXVFS("unix-dotfile",  dotlockIoFinder ),Ù-    UNIXVFS("unix-excl",     posixIoFinder ),®#if OS_VXWORKSÙ+    UNIXVFS("unix-namedsem", semIoFinder ),¦#endifÙ-#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKSÙ-    UNIXVFS("unix-posix",    posixIoFinder ),¦#endif¿#if SQLITE_ENABLE_LOCKING_STYLEÙ-    UNIXVFS("unix-flock",    flockIoFinder ),¦#endifÙ5#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)Ù+    UNIXVFS("unix-afp",      afpIoFinder ),Ù+    UNIXVFS("unix-nfs",      nfsIoFinder ),Ù-    UNIXVFS("unix-proxy",    proxyIoFinder ),¦#endif¤  };Ù-  unsigned int i;          /* Loop counter */ Ù@  /* Double-check that the aSyscall[] array has been constructedÙ2  ** correctly.  See ticket [bb3a86e890c8e96ab] */Ù$  assert( ArraySize(aSyscall)==29 ); Ù6  /* Register all VFSes defined in the aVfs[] array */Ù6  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){Ù)    sqlite3_vfs_register(&aVfs[i], i==0);£  }Ù<  unixBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);´  return SQLITE_OK; ¡} ¢/*Ù+** Shutdown the operating system interface.¢**ÙH** Some operating systems might need to do some cleanup in this routine,Ù>** to release dynamically allocated objects.  But not on unix.Ù$** This routine is a no-op for unix.¢*/Ù%SQLITE_API int sqlite3_os_end(void){ ²  unixBigLock = 0;´  return SQLITE_OK; ¡}¡ »#endif /* SQLITE_OS_UNIX */ ÙO/************** End of os_unix.c *********************************************/ÙO/************** Begin file os_win.c ******************************************/¢/*®** 2004 May 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**Ù7** This file contains code that is specific to Windows.¢*/¼/* #include "sqliteInt.h" */ÙH#if SQLITE_OS_WIN               /* This file is used for Windows only */ ¢/*Ù2** Include code that is common to all os_*.c files¢*/ÙO/************** Include os_common.h in the middle of os_win.c ****************/ÙO/************** Begin file os_common.h ***************************************/¢/*®** 2004 May 22¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙG** This file contains macros and a little bit of code that is common toÙJ** all of the platform-specific files (os_*.c) and is #included into those©** files.¢**ÙG** This file should be #included by the os_*.c files only.  It is not a¿** general purpose header file.¢*/µ#ifndef _OS_COMMON_H_µ#define _OS_COMMON_H_ ¢/*ÙH** At least two bugs have slipped in because we changed the MEMORY_DEBUGÙG** macro to SQLITE_DEBUG and some older makefiles have not yet made theÙI** switch.  The following code should catch this problem at compile-time.¢*/³#ifdef MEMORY_DEBUGÙH# error "The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."¦#endif ¢/*ÙD** Macros for performance tracing.  Normally turned off.  Only works´** on i486 hardware.¢*/¿#ifdef SQLITE_PERFORMANCE_TRACE ¢/*Ù;** hwtime.h contains inline assembler code for implementingÙ$** high-performance timing routines.¢*/ÙO/************** Include hwtime.h in the middle of os_common.h ****************/ÙO/************** Begin file hwtime.h ******************************************/¢/*®** 2008 May 27¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙG** This file contains inline asm code for retrieving "high-performance"¿** counters for x86 class CPUs.¢*/·#ifndef SQLITE_HWTIME_H·#define SQLITE_HWTIME_H ¢/*ÙK** The following routine only works on pentium-class (or newer) processors.ÙD** It uses the RDTSC opcode to read the cycle count value out of theÙC** processor and returns that value.  This can be used for high-res­** profiling.¢*/Ù1#if (defined(__GNUC__) || defined(_MSC_VER)) && \Ù>      (defined(i386) || defined(__i386__) || defined(_M_IX86)) ·  #if defined(__GNUC__) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){¹     unsigned int lo, hi;Ù;     __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));Ù)     return (sqlite_uint64)hi << 32 | lo;£  } ¹  #elif defined(_MSC_VER) ÙG  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){¬     __asm {­        rdtscÙ+        ret       ; return value at EDX:EAX¦     }£  } ¨  #endif Ù0#elif (defined(__GNUC__) && defined(__x86_64__)) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){¸      unsigned long val;Ù2      __asm__ __volatile__ ("rdtsc" : "=A" (val));±      return val;£  }¡ Ù-#elif (defined(__GNUC__) && defined(__ppc__)) Ù/  __inline__ sqlite_uint64 sqlite3Hwtime(void){Ù       unsigned long long retval;¹      unsigned long junk;Ù       __asm__ __volatile__ ("\n\¿          1:      mftbu   %1\n\Ù                   mftb    %L0\n\¿                  mftbu   %0\n\Ù"                  cmpw    %0,%1\n\½                  bne     1b"Ù0                  : "=r" (retval), "=r" (junk));´      return retval;£  } ¥#else ÙB  #error Need implementation of sqlite3Hwtime() for your platform. ¤  /*ÙG  ** To compile without implementing sqlite3Hwtime() for your platform,Ù:  ** you can remove the above #error and use the followingÙ:  ** stub function.  You will lose timing support for manyÙ=  ** of the debugging and testing utilities, but it should at»  ** least compile and run.¤  */ÙPSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); } ¦#endif Ù&#endif /* !defined(SQLITE_HWTIME_H) */ ÙO/************** End of hwtime.h **********************************************/ÙO/************** Continuing where we left off in os_common.h ******************/ ½static sqlite_uint64 g_start;¿static sqlite_uint64 g_elapsed;Ù1#define TIMER_START       g_start=sqlite3Hwtime()Ù;#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_startÙ##define TIMER_ELAPSED     g_elapsed¥#else³#define TIMER_START±#define TIMER_ENDÙ,#define TIMER_ELAPSED     ((sqlite_uint64)0)¦#endif ¢/*ÙI** If we compile with the SQLITE_TEST macro set, then the following blockÙG** of code will give us the ability to simulate a disk I/O error.  ThisÙ.** is used for testing the I/O recovery logic.¢*/¸#if defined(SQLITE_TEST)Ù+SQLITE_API extern int sqlite3_io_error_hit;Ù/SQLITE_API extern int sqlite3_io_error_hardhit;Ù/SQLITE_API extern int sqlite3_io_error_pending;Ù/SQLITE_API extern int sqlite3_io_error_persist;Ù.SQLITE_API extern int sqlite3_io_error_benign;Ù/SQLITE_API extern int sqlite3_diskfull_pending;Ù'SQLITE_API extern int sqlite3_diskfull;Ù<#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)Ù #define SimulateIOError(CODE)  \Ù:  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \Ù.       || sqlite3_io_error_pending-- == 1 )  \Ù&              { local_ioerr(); CODE; }ºstatic void local_ioerr(){·  IOTRACE(("IOERR\n"));¹  sqlite3_io_error_hit++;Ù<  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;¡}Ù%#define SimulateDiskfullError(CODE) \Ù$   if( sqlite3_diskfull_pending ){ \Ù+     if( sqlite3_diskfull_pending == 1 ){ \·       local_ioerr(); \¾       sqlite3_diskfull = 1; \Ù"       sqlite3_io_error_hit = 1; \®       CODE; \­     }else{ \Ù$       sqlite3_diskfull_pending--; \¨     } \¤   }¥#elseÙ #define SimulateIOErrorBenign(X)º#define SimulateIOError(A)Ù #define SimulateDiskfullError(A)Ù!#endif /* defined(SQLITE_TEST) */ ¢/*Ù:** When testing, keep a count of the number of open files.¢*/¸#if defined(SQLITE_TEST)Ù.SQLITE_API extern int sqlite3_open_file_count;Ù4#define OpenCounter(X)  sqlite3_open_file_count+=(X)¥#else¶#define OpenCounter(X)Ù!#endif /* defined(SQLITE_TEST) */ Ù$#endif /* !defined(_OS_COMMON_H_) */ ÙO/************** End of os_common.h *******************************************/ÙO/************** Continuing where we left off in os_win.c *********************/ ¢/*Ù/** Include the header file for the Windows VFS.¢*/¹/* #include "os_win.h" */ ¢/*ÙC** Compiling and using WAL mode requires several APIs that are onlyÙ9** available in Windows platforms based on the NT kernel.¢*/Ù1#if !SQLITE_OS_WINNT && !defined(SQLITE_OMIT_WAL)ÙH#  error "WAL mode requires support from the Windows NT kernel, compile\· with SQLITE_OMIT_WAL."¦#endif Ù.#if !SQLITE_OS_WINNT && SQLITE_MAX_MMAP_SIZE>0ÙJ#  error "Memory mapped files require support from the Windows NT kernel,\Ù& compile with SQLITE_MAX_MMAP_SIZE=0."¦#endif ¢/*ÙJ** Are most of the Win32 ANSI APIs available (i.e. with certain exceptions¾** based on the sub-platform)?¢*/ÙJ#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(SQLITE_WIN32_NO_ANSI)¿#  define SQLITE_WIN32_HAS_ANSI¦#endif ¢/*ÙM** Are most of the Win32 Unicode APIs available (i.e. with certain exceptions¾** based on the sub-platform)?¢*/Ù@#if (SQLITE_OS_WINCE || SQLITE_OS_WINNT || SQLITE_OS_WINRT) && \Ù"    !defined(SQLITE_WIN32_NO_WIDE)¿#  define SQLITE_WIN32_HAS_WIDE¦#endif ¢/*Ù9** Make sure at least one set of Win32 APIs is available.¢*/ÙF#if !defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_WIN32_HAS_WIDE)ÙJ#  error "At least one of SQLITE_WIN32_HAS_ANSI and SQLITE_WIN32_HAS_WIDE\² must be defined."¦#endif ¢/*ÙD** Define the required Windows SDK version constants if they are notµ** already available.¢*/²#ifndef NTDDI_WIN8Ù6#  define NTDDI_WIN8                        0x06020000¦#endif µ#ifndef NTDDI_WINBLUEÙ6#  define NTDDI_WINBLUE                     0x06030000¦#endif º#ifndef NTDDI_WINTHRESHOLDÙ6#  define NTDDI_WINTHRESHOLD                0x06040000¦#endif ¢/*ÙG** Check to see if the GetVersionEx[AW] functions are deprecated on theÙ?** target system.  GetVersionEx was first deprecated in Win8.1.¢*/Ù!#ifndef SQLITE_WIN32_GETVERSIONEXÙ>#  if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINBLUEÙN#    define SQLITE_WIN32_GETVERSIONEX   0   /* GetVersionEx() is deprecated */§#  elseÙK#    define SQLITE_WIN32_GETVERSIONEX   1   /* GetVersionEx() is current */¨#  endif¦#endif ¢/*ÙF** Check to see if the CreateFileMappingA function is supported on theÙG** target system.  It is unavailable when using "mincore.lib" on Win10.ÙH** When compiling for Windows 10, always assume "mincore.lib" is in use.¢*/Ù'#ifndef SQLITE_WIN32_CREATEFILEMAPPINGAÙC#  if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINTHRESHOLDÙ/#    define SQLITE_WIN32_CREATEFILEMAPPINGA   0§#  elseÙ/#    define SQLITE_WIN32_CREATEFILEMAPPINGA   1¨#  endif¦#endif ¢/*ÙH** This constant should already be defined (in the "WinDef.h" SDK file).¢*/°#ifndef MAX_PATHÙ-#  define MAX_PATH                      (260)¦#endif ¢/*ÙI** Maximum pathname length (in chars) for Win32.  This should normally be¬** MAX_PATH.¢*/Ù##ifndef SQLITE_WIN32_MAX_PATH_CHARSÙ2#  define SQLITE_WIN32_MAX_PATH_CHARS   (MAX_PATH)¦#endif ¢/*ÙG** This constant should already be defined (in the "WinNT.h" SDK file).¢*/Ù #ifndef UNICODE_STRING_MAX_CHARSÙ/#  define UNICODE_STRING_MAX_CHARS      (32767)¦#endif ¢/*ÙI** Maximum pathname length (in chars) for WinNT.  This should normally be¼** UNICODE_STRING_MAX_CHARS.¢*/Ù##ifndef SQLITE_WINNT_MAX_PATH_CHARSÙB#  define SQLITE_WINNT_MAX_PATH_CHARS   (UNICODE_STRING_MAX_CHARS)¦#endif ¢/*ÙJ** Maximum pathname length (in bytes) for Win32.  The MAX_PATH macro is inÙJ** characters, so we allocate 4 bytes per character assuming worst-case ofÙ"** 4-bytes-per-character for UTF8.¢*/Ù##ifndef SQLITE_WIN32_MAX_PATH_BYTESÙG#  define SQLITE_WIN32_MAX_PATH_BYTES   (SQLITE_WIN32_MAX_PATH_CHARS*4)¦#endif ¢/*ÙI** Maximum pathname length (in bytes) for WinNT.  This should normally beÙ,** UNICODE_STRING_MAX_CHARS * sizeof(WCHAR).¢*/Ù##ifndef SQLITE_WINNT_MAX_PATH_BYTESÙ)#  define SQLITE_WINNT_MAX_PATH_BYTES   \ÙI                            (sizeof(WCHAR) * SQLITE_WINNT_MAX_PATH_CHARS)¦#endif ¢/*Ù5** Maximum error message length (in chars) for WinRT.¢*/Ù%#ifndef SQLITE_WIN32_MAX_ERRMSG_CHARSÙ.#  define SQLITE_WIN32_MAX_ERRMSG_CHARS (1024)¦#endif ¢/*ÙE** Returns non-zero if the character should be treated as a directory­** separator.¢*/³#ifndef winIsDirSepÙG#  define winIsDirSep(a)                (((a) == '/') || ((a) == '\\'))¦#endif ¢/*ÙE** This macro is used when a local variable is set to a value that isÙG** [sometimes] not used by the code (e.g. via conditional compilation).¢*/½#ifndef UNUSED_VARIABLE_VALUEÙ1#  define UNUSED_VARIABLE_VALUE(x)      (void)(x)¦#endif ¢/*ÙH** Returns the character that should be used as the directory separator.¢*/´#ifndef winGetDirSepÙ,#  define winGetDirSep()                '\\'¦#endif ¢/*ÙM** Do we need to manually define the Win32 file mapping APIs for use with WALÙL** mode or memory mapped files (e.g. these APIs are available in the WindowsÙ=** CE SDK; however, they are not present in the header file)?¢*/Ù%#if SQLITE_WIN32_FILEMAPPING_API && \Ù=        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)¢/*ÙL** Two of the file mapping APIs are different under WinRT.  Figure out which¯** set we need.¢*/³#if SQLITE_OS_WINRTÙ;WINBASEAPI HANDLE WINAPI CreateFileMappingFromApp(HANDLE, \Ù8        LPSECURITY_ATTRIBUTES, ULONG, ULONG64, LPCWSTR); ÙNWINBASEAPI LPVOID WINAPI MapViewOfFileFromApp(HANDLE, ULONG, ULONG64, SIZE_T);¥#elseÙ"#if defined(SQLITE_WIN32_HAS_ANSI)ÙLWINBASEAPI HANDLE WINAPI CreateFileMappingA(HANDLE, LPSECURITY_ATTRIBUTES, \Ù%        DWORD, DWORD, DWORD, LPCSTR);Ù+#endif /* defined(SQLITE_WIN32_HAS_ANSI) */ Ù"#if defined(SQLITE_WIN32_HAS_WIDE)ÙLWINBASEAPI HANDLE WINAPI CreateFileMappingW(HANDLE, LPSECURITY_ATTRIBUTES, \Ù&        DWORD, DWORD, DWORD, LPCWSTR);Ù+#endif /* defined(SQLITE_WIN32_HAS_WIDE) */ ÙLWINBASEAPI LPVOID WINAPI MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, SIZE_T);¼#endif /* SQLITE_OS_WINRT */ ¢/*Ù>** These file mapping APIs are common to both Win32 and WinRT.¢*/ Ù8WINBASEAPI BOOL WINAPI FlushViewOfFile(LPCVOID, SIZE_T);Ù0WINBASEAPI BOOL WINAPI UnmapViewOfFile(LPCVOID);Ù)#endif /* SQLITE_WIN32_FILEMAPPING_API */ ¢/*Ù1** Some Microsoft compilers lack this definition.¢*/¿#ifndef INVALID_FILE_ATTRIBUTESÙ,# define INVALID_FILE_ATTRIBUTES ((DWORD)-1)¦#endif ¶#ifndef FILE_FLAG_MASKÙ-# define FILE_FLAG_MASK          (0xFF3C0000)¦#endif »#ifndef FILE_ATTRIBUTE_MASKÙ-# define FILE_ATTRIBUTE_MASK     (0x0003FFF7)¦#endif ·#ifndef SQLITE_OMIT_WALÙ3/* Forward references to structures used for WAL */ÙKtypedef struct winShm winShm;           /* A connection to shared-memory */ÙGtypedef struct winShmNode winShmNode;   /* A region of shared-memory */¦#endif ¢/*ÙD** WinCE lacks native support for file locking so we have to fake it½** with some code of our own.¢*/³#if SQLITE_OS_WINCEºtypedef struct winceLock {Ù;  int nReaders;       /* Number of reader locks obtained */ÙF  BOOL bPending;      /* Indicates a pending lock has been obtained */ÙG  BOOL bReserved;     /* Indicates a reserved lock has been obtained */ÙI  BOOL bExclusive;    /* Indicates an exclusive lock has been obtained */¬} winceLock;¦#endif ¢/*ÙM** The winFile structure is a subclass of sqlite3_file* specific to the win32µ** portability layer.¢*/¿typedef struct winFile winFile;°struct winFile {Ù<  const sqlite3_io_methods *pMethod; /*** Must be first ***/Ù>  sqlite3_vfs *pVfs;      /* The VFS used to open this file */Ù=  HANDLE h;               /* Handle for accessing the file */ÙH  u8 locktype;            /* Type of lock currently held on this file */ÙJ  short sharedLockByte;   /* Randomly chosen byte used as a shared lock */Ù;  u8 ctrlFlags;           /* Flags.  See WINFILE_* below */ÙI  DWORD lastErrno;        /* The Windows errno from the last I/O error */·#ifndef SQLITE_OMIT_WALÙF  winShm *pShm;           /* Instance of shared memory on this file */¦#endifÙ:  const char *zPath;      /* Full pathname of this file */ÙI  int szChunk;            /* Chunk size configured by FCNTL_CHUNK_SIZE */³#if SQLITE_OS_WINCEÙC  LPWSTR zDeleteOnClose;  /* Name of file to delete when closing */ÙK  HANDLE hMutex;          /* Mutex used to control access to shared lock */ÙF  HANDLE hShared;         /* Shared memory segment used for locking */ÙJ  winceLock local;        /* Locks obtained by this instance of winFile */ÙG  winceLock *shared;      /* Global shared lock memory for the file  */¦#endifº#if SQLITE_MAX_MMAP_SIZE>0ÙM  int nFetchOut;                /* Number of outstanding xFetch references */ÙI  HANDLE hMap;                  /* Handle for accessing memory mapping */Ù8  void *pMapRegion;             /* Area memory mapped */ÙB  sqlite3_int64 mmapSize;       /* Usable size of mapped region */ÙB  sqlite3_int64 mmapSizeActual; /* Actual size of mapped region */ÙF  sqlite3_int64 mmapSizeMax;    /* Configured FCNTL_MMAP_SIZE value */¦#endif¢}; ¢/*ÙM** The winVfsAppData structure is used for the pAppData member for all of the¶** Win32 VFS variants.¢*/Ù+typedef struct winVfsAppData winVfsAppData;¶struct winVfsAppData {ÙG  const sqlite3_io_methods *pMethod; /* The file I/O methods to use. */ÙF  void *pAppData;                    /* The extra pAppData, if any. */ÙK  BOOL bNoLock;                      /* Non-zero if locking is disabled. */¢}; ¢/*Ù'** Allowed values for winFile.ctrlFlags¢*/ÙD#define WINFILE_RDONLY          0x02   /* Connection is read only */Ù@#define WINFILE_PERSIST_WAL     0x04   /* Persistent WAL mode */ÙM#define WINFILE_PSOW            0x10   /* SQLITE_IOCAP_POWERSAFE_OVERWRITE */ ¢/*Ù> * The size of the buffer used by sqlite3_win32_write_debug().£ */Ù!#ifndef SQLITE_WIN32_DBG_BUF_SIZEÙA#  define SQLITE_WIN32_DBG_BUF_SIZE   ((int)(4096-sizeof(DWORD)))¦#endif ¢/*ÙD * The value used with sqlite3_win32_set_directory() to specify thatÙ( * the data directory should be changed.£ */Ù(#ifndef SQLITE_WIN32_DATA_DIRECTORY_TYPEÙ.#  define SQLITE_WIN32_DATA_DIRECTORY_TYPE (1)¦#endif ¢/*ÙD * The value used with sqlite3_win32_set_directory() to specify thatÙ- * the temporary directory should be changed.£ */Ù(#ifndef SQLITE_WIN32_TEMP_DIRECTORY_TYPEÙ.#  define SQLITE_WIN32_TEMP_DIRECTORY_TYPE (2)¦#endif ¢/*ÙC * If compiled with SQLITE_WIN32_MALLOC on Windows, we will use theÙ7 * various Win32 API heap functions instead of our own.£ */º#ifdef SQLITE_WIN32_MALLOC ¢/*ÙL * If this is non-zero, an isolated heap will be created by the native Win32ÙO * allocator subsystem; otherwise, the default process heap will be used.  ThisÙO * setting has no effect when compiling for WinRT.  By default, this is enabledÙD * and an isolated heap will be created to store all allocated data.¢ *ÙO ******************************************************************************ÙN * WARNING: It is important to note that when this setting is non-zero and theÙK *          winMemShutdown function is called (e.g. by the sqlite3_shutdownÙO *          function), all data that was allocated using the isolated heap willÙL *          be freed immediately and any attempt to access any of that freedÙO *          data will almost certainly result in an immediate access violation.ÙO ******************************************************************************£ */Ù #ifndef SQLITE_WIN32_HEAP_CREATEÙ0#  define SQLITE_WIN32_HEAP_CREATE        (TRUE)¦#endif ¢/*ÙK * This is the maximum possible initial size of the Win32-specific heap, in© * bytes.£ */Ù'#ifndef SQLITE_WIN32_HEAP_MAX_INIT_SIZEÙ7#  define SQLITE_WIN32_HEAP_MAX_INIT_SIZE (4294967295U)¦#endif ¢/*ÙK * This is the extra space for the initial size of the Win32-specific heap,Ù% * in bytes.  This value may be zero.£ */Ù$#ifndef SQLITE_WIN32_HEAP_INIT_EXTRAÙ1#  define SQLITE_WIN32_HEAP_INIT_EXTRA  (4194304)¦#endif ¢/*ÙI * Calculate the maximum legal cache size, in pages, based on the maximumÙJ * possible initial heap size and the default page size, setting aside the¶ * needed extra space.£ */Ù##ifndef SQLITE_WIN32_MAX_CACHE_SIZEÙO#  define SQLITE_WIN32_MAX_CACHE_SIZE   (((SQLITE_WIN32_HEAP_MAX_INIT_SIZE) - \ÙM                                          (SQLITE_WIN32_HEAP_INIT_EXTRA)) / \ÙD                                         (SQLITE_DEFAULT_PAGE_SIZE))¦#endif ¢/*ÙH * This is cache size used in the calculation of the initial size of theÙ/ * Win32-specific heap.  It cannot be negative.£ */¿#ifndef SQLITE_WIN32_CACHE_SIZEÙ"#  if SQLITE_DEFAULT_CACHE_SIZE>=0ÙC#    define SQLITE_WIN32_CACHE_SIZE     (SQLITE_DEFAULT_CACHE_SIZE)§#  elseÙF#    define SQLITE_WIN32_CACHE_SIZE     (-(SQLITE_DEFAULT_CACHE_SIZE))¨#  endif¦#endif ¢/*ÙG * Make sure that the calculated cache size, in pages, cannot cause theÙG * initial size of the Win32-specific heap to exceed the maximum amountÙ= * of memory that can be specified in the call to HeapCreate.£ */Ù7#if SQLITE_WIN32_CACHE_SIZE>SQLITE_WIN32_MAX_CACHE_SIZEÙ #  undef SQLITE_WIN32_CACHE_SIZEÙ.#  define SQLITE_WIN32_CACHE_SIZE       (2000)¦#endif ¢/*ÙH * The initial size of the Win32-specific heap.  This value may be zero.£ */Ù##ifndef SQLITE_WIN32_HEAP_INIT_SIZEÙF#  define SQLITE_WIN32_HEAP_INIT_SIZE   ((SQLITE_WIN32_CACHE_SIZE) * \ÙG                                         (SQLITE_DEFAULT_PAGE_SIZE) + \ÙH                                         (SQLITE_WIN32_HEAP_INIT_EXTRA))¦#endif ¢/*ÙH * The maximum size of the Win32-specific heap.  This value may be zero.£ */Ù"#ifndef SQLITE_WIN32_HEAP_MAX_SIZEÙ+#  define SQLITE_WIN32_HEAP_MAX_SIZE    (0)¦#endif ¢/*ÙM * The extra flags to use in calls to the Win32 heap APIs.  This value may beÙ! * zero for the default behavior.£ */¿#ifndef SQLITE_WIN32_HEAP_FLAGSÙ+#  define SQLITE_WIN32_HEAP_FLAGS       (0)¦#endif  ¢/*ÙM** The winMemData structure stores information required by the Win32-specificÙ&** sqlite3_mem_methods implementation.¢*/Ù%typedef struct winMemData winMemData;³struct winMemData {®#ifndef NDEBUGÙB  u32 magic1;   /* Magic number to detect structure corruption. */¦#endifÙ-  HANDLE hHeap; /* The handle to our heap. */ÙG  BOOL bOwned;  /* Do we own the heap (i.e. destroy it on shutdown)? */®#ifndef NDEBUGÙB  u32 magic2;   /* Magic number to detect structure corruption. */¦#endif¢}; ®#ifndef NDEBUGÙ$#define WINMEM_MAGIC1     0x42b2830bÙ$#define WINMEM_MAGIC2     0xbd4d7cf4¦#endif Ù)static struct winMemData win_mem_data = {®#ifndef NDEBUG°  WINMEM_MAGIC1,¦#endif­  NULL, FALSE®#ifndef NDEBUG°  ,WINMEM_MAGIC2¦#endif¢}; ®#ifndef NDEBUGÙI#define winMemAssertMagic1() assert( win_mem_data.magic1==WINMEM_MAGIC1 )ÙI#define winMemAssertMagic2() assert( win_mem_data.magic2==WINMEM_MAGIC2 )ÙH#define winMemAssertMagic()  winMemAssertMagic1(); winMemAssertMagic2();¥#else»#define winMemAssertMagic()¦#endif Ù)#define winMemGetDataPtr()  &win_mem_dataÙ.#define winMemGetHeap()     win_mem_data.hHeapÙ/#define winMemGetOwned()    win_mem_data.bOwned Ù&static void *winMemMalloc(int nBytes);Ù%static void winMemFree(void *pPrior);Ù5static void *winMemRealloc(void *pPrior, int nBytes);¿static int winMemSize(void *p);Ù static int winMemRoundup(int n);Ù&static int winMemInit(void *pAppData);Ù+static void winMemShutdown(void *pAppData); ÙCSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void);Ù #endif /* SQLITE_WIN32_MALLOC */ ¢/*ÙB** The following variable is (normally) set once and never changesÙ@** thereafter.  It records whether the operating system is Win9x¬** or WinNT.¢**Ù!** 0:   Operating system unknown.Ù"** 1:   Operating system is Win9x.Ù"** 2:   Operating system is WinNT.¢**ÙE** In order to facilitate testing on a WinNT system, the test fixtureÙ>** can manually set this value to 1 to emulate Win98 behavior.¢*/²#ifdef SQLITE_TESTÙ:SQLITE_API LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;¥#elseÙ6static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;¦#endif ¯#ifndef SYSCALLÙ%#  define SYSCALL sqlite3_syscall_ptr¦#endif ¢/*Ù9** This function is not available on Windows CE or WinRT.£ */ Ù&#if SQLITE_OS_WINCE || SQLITE_OS_WINRTÙ%#  define osAreFileApisANSI()       1¦#endif ¢/*ÙF** Many system calls are accessed through pointer-to-functions so thatÙI** they may be overridden at runtime to facilitate fault injection duringÙL** testing and sandboxing.  The following array holds the names and pointersÙ$** to all overrideable system calls.¢*/»static struct win_syscall {Ù=  const char *zName;            /* Name of the system call */ÙF  sqlite3_syscall_ptr pCurrent; /* Current value of the system call */Ù3  sqlite3_syscall_ptr pDefault; /* Default value */°} aSyscall[] = {Ù(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTÙE  { "AreFileApisANSI",         (SYSCALL)AreFileApisANSI,         0 },¥#elseÙE  { "AreFileApisANSI",         (SYSCALL)0,                       0 },¦#endif ¹#ifndef osAreFileApisANSIÙE#define osAreFileApisANSI ((BOOL(WINAPI*)(VOID))aSyscall[0].pCurrent)¦#endif Ù5#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "CharLowerW",              (SYSCALL)CharLowerW,              0 },¥#elseÙE  { "CharLowerW",              (SYSCALL)0,                       0 },¦#endif ÙD#define osCharLowerW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[1].pCurrent) Ù5#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "CharUpperW",              (SYSCALL)CharUpperW,              0 },¥#elseÙE  { "CharUpperW",              (SYSCALL)0,                       0 },¦#endif ÙD#define osCharUpperW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[2].pCurrent) ÙE  { "CloseHandle",             (SYSCALL)CloseHandle,             0 }, ÙC#define osCloseHandle ((BOOL(WINAPI*)(HANDLE))aSyscall[3].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "CreateFileA",             (SYSCALL)CreateFileA,             0 },¥#elseÙE  { "CreateFileA",             (SYSCALL)0,                       0 },¦#endif Ù=#define osCreateFileA ((HANDLE(WINAPI*)(LPCSTR,DWORD,DWORD, \ÙG        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[4].pCurrent) Ù6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "CreateFileW",             (SYSCALL)CreateFileW,             0 },¥#elseÙE  { "CreateFileW",             (SYSCALL)0,                       0 },¦#endif Ù>#define osCreateFileW ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD, \ÙG        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[5].pCurrent) Ù;#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_ANSI) && \ÙB        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) && \Ù'        SQLITE_WIN32_CREATEFILEMAPPINGAÙE  { "CreateFileMappingA",      (SYSCALL)CreateFileMappingA,      0 },¥#elseÙE  { "CreateFileMappingA",      (SYSCALL)0,                       0 },¦#endif ÙN#define osCreateFileMappingA ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \Ù7        DWORD,DWORD,DWORD,LPCSTR))aSyscall[6].pCurrent) ÙO#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \Ù>        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))ÙE  { "CreateFileMappingW",      (SYSCALL)CreateFileMappingW,      0 },¥#elseÙE  { "CreateFileMappingW",      (SYSCALL)0,                       0 },¦#endif ÙN#define osCreateFileMappingW ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \Ù8        DWORD,DWORD,DWORD,LPCWSTR))aSyscall[7].pCurrent) Ù6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "CreateMutexW",            (SYSCALL)CreateMutexW,            0 },¥#elseÙE  { "CreateMutexW",            (SYSCALL)0,                       0 },¦#endif ÙF#define osCreateMutexW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,BOOL, \Ù&        LPCWSTR))aSyscall[8].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "DeleteFileA",             (SYSCALL)DeleteFileA,             0 },¥#elseÙE  { "DeleteFileA",             (SYSCALL)0,                       0 },¦#endif ÙC#define osDeleteFileA ((BOOL(WINAPI*)(LPCSTR))aSyscall[9].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "DeleteFileW",             (SYSCALL)DeleteFileW,             0 },¥#elseÙE  { "DeleteFileW",             (SYSCALL)0,                       0 },¦#endif ÙE#define osDeleteFileW ((BOOL(WINAPI*)(LPCWSTR))aSyscall[10].pCurrent) ³#if SQLITE_OS_WINCEÙE  { "FileTimeToLocalFileTime", (SYSCALL)FileTimeToLocalFileTime, 0 },¥#elseÙE  { "FileTimeToLocalFileTime", (SYSCALL)0,                       0 },¦#endif ÙD#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(CONST FILETIME*, \Ù*        LPFILETIME))aSyscall[11].pCurrent) ³#if SQLITE_OS_WINCEÙE  { "FileTimeToSystemTime",    (SYSCALL)FileTimeToSystemTime,    0 },¥#elseÙE  { "FileTimeToSystemTime",    (SYSCALL)0,                       0 },¦#endif ÙA#define osFileTimeToSystemTime ((BOOL(WINAPI*)(CONST FILETIME*, \Ù,        LPSYSTEMTIME))aSyscall[12].pCurrent) ÙE  { "FlushFileBuffers",        (SYSCALL)FlushFileBuffers,        0 }, ÙI#define osFlushFileBuffers ((BOOL(WINAPI*)(HANDLE))aSyscall[13].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "FormatMessageA",          (SYSCALL)FormatMessageA,          0 },¥#elseÙE  { "FormatMessageA",          (SYSCALL)0,                       0 },¦#endif ÙL#define osFormatMessageA ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPSTR, \Ù.        DWORD,va_list*))aSyscall[14].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "FormatMessageW",          (SYSCALL)FormatMessageW,          0 },¥#elseÙE  { "FormatMessageW",          (SYSCALL)0,                       0 },¦#endif ÙM#define osFormatMessageW ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPWSTR, \Ù.        DWORD,va_list*))aSyscall[15].pCurrent) Ù(#if !defined(SQLITE_OMIT_LOAD_EXTENSION)ÙE  { "FreeLibrary",             (SYSCALL)FreeLibrary,             0 },¥#elseÙE  { "FreeLibrary",             (SYSCALL)0,                       0 },¦#endif ÙE#define osFreeLibrary ((BOOL(WINAPI*)(HMODULE))aSyscall[16].pCurrent) ÙE  { "GetCurrentProcessId",     (SYSCALL)GetCurrentProcessId,     0 }, ÙK#define osGetCurrentProcessId ((DWORD(WINAPI*)(VOID))aSyscall[17].pCurrent) Ù6#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "GetDiskFreeSpaceA",       (SYSCALL)GetDiskFreeSpaceA,       0 },¥#elseÙE  { "GetDiskFreeSpaceA",       (SYSCALL)0,                       0 },¦#endif ÙM#define osGetDiskFreeSpaceA ((BOOL(WINAPI*)(LPCSTR,LPDWORD,LPDWORD,LPDWORD, \Ù'        LPDWORD))aSyscall[18].pCurrent) ÙJ#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "GetDiskFreeSpaceW",       (SYSCALL)GetDiskFreeSpaceW,       0 },¥#elseÙE  { "GetDiskFreeSpaceW",       (SYSCALL)0,                       0 },¦#endif ÙN#define osGetDiskFreeSpaceW ((BOOL(WINAPI*)(LPCWSTR,LPDWORD,LPDWORD,LPDWORD, \Ù'        LPDWORD))aSyscall[19].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "GetFileAttributesA",      (SYSCALL)GetFileAttributesA,      0 },¥#elseÙE  { "GetFileAttributesA",      (SYSCALL)0,                       0 },¦#endif ÙL#define osGetFileAttributesA ((DWORD(WINAPI*)(LPCSTR))aSyscall[20].pCurrent) Ù6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "GetFileAttributesW",      (SYSCALL)GetFileAttributesW,      0 },¥#elseÙE  { "GetFileAttributesW",      (SYSCALL)0,                       0 },¦#endif ÙM#define osGetFileAttributesW ((DWORD(WINAPI*)(LPCWSTR))aSyscall[21].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "GetFileAttributesExW",    (SYSCALL)GetFileAttributesExW,    0 },¥#elseÙE  { "GetFileAttributesExW",    (SYSCALL)0,                       0 },¦#endif ÙP#define osGetFileAttributesExW ((BOOL(WINAPI*)(LPCWSTR,GET_FILEEX_INFO_LEVELS, \Ù&        LPVOID))aSyscall[22].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "GetFileSize",             (SYSCALL)GetFileSize,             0 },¥#elseÙE  { "GetFileSize",             (SYSCALL)0,                       0 },¦#endif ÙM#define osGetFileSize ((DWORD(WINAPI*)(HANDLE,LPDWORD))aSyscall[23].pCurrent) Ù6#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "GetFullPathNameA",        (SYSCALL)GetFullPathNameA,        0 },¥#elseÙE  { "GetFullPathNameA",        (SYSCALL)0,                       0 },¦#endif ÙA#define osGetFullPathNameA ((DWORD(WINAPI*)(LPCSTR,DWORD,LPSTR, \Ù&        LPSTR*))aSyscall[24].pCurrent) ÙJ#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "GetFullPathNameW",        (SYSCALL)GetFullPathNameW,        0 },¥#elseÙE  { "GetFullPathNameW",        (SYSCALL)0,                       0 },¦#endif ÙC#define osGetFullPathNameW ((DWORD(WINAPI*)(LPCWSTR,DWORD,LPWSTR, \Ù'        LPWSTR*))aSyscall[25].pCurrent) ÙE  { "GetLastError",            (SYSCALL)GetLastError,            0 }, ÙD#define osGetLastError ((DWORD(WINAPI*)(VOID))aSyscall[26].pCurrent) Ù(#if !defined(SQLITE_OMIT_LOAD_EXTENSION)³#if SQLITE_OS_WINCEÙF  /* The GetProcAddressA() routine is only available on Windows CE. */ÙE  { "GetProcAddressA",         (SYSCALL)GetProcAddressA,         0 },¥#elseÙ@  /* All other Windows platforms expect GetProcAddress() to takeÙ9  ** an ANSI string regardless of the _UNICODE setting */ÙE  { "GetProcAddressA",         (SYSCALL)GetProcAddress,          0 },¦#endif¥#elseÙE  { "GetProcAddressA",         (SYSCALL)0,                       0 },¦#endif Ù7#define osGetProcAddressA ((FARPROC(WINAPI*)(HMODULE, \Ù&        LPCSTR))aSyscall[27].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "GetSystemInfo",           (SYSCALL)GetSystemInfo,           0 },¥#elseÙE  { "GetSystemInfo",           (SYSCALL)0,                       0 },¦#endif ÙM#define osGetSystemInfo ((VOID(WINAPI*)(LPSYSTEM_INFO))aSyscall[28].pCurrent) ÙE  { "GetSystemTime",           (SYSCALL)GetSystemTime,           0 }, ÙL#define osGetSystemTime ((VOID(WINAPI*)(LPSYSTEMTIME))aSyscall[29].pCurrent) ´#if !SQLITE_OS_WINCEÙE  { "GetSystemTimeAsFileTime", (SYSCALL)GetSystemTimeAsFileTime, 0 },¥#elseÙE  { "GetSystemTimeAsFileTime", (SYSCALL)0,                       0 },¦#endif Ù4#define osGetSystemTimeAsFileTime ((VOID(WINAPI*)( \Ù*        LPFILETIME))aSyscall[30].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "GetTempPathA",            (SYSCALL)GetTempPathA,            0 },¥#elseÙE  { "GetTempPathA",            (SYSCALL)0,                       0 },¦#endif ÙK#define osGetTempPathA ((DWORD(WINAPI*)(DWORD,LPSTR))aSyscall[31].pCurrent) Ù6#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "GetTempPathW",            (SYSCALL)GetTempPathW,            0 },¥#elseÙE  { "GetTempPathW",            (SYSCALL)0,                       0 },¦#endif ÙL#define osGetTempPathW ((DWORD(WINAPI*)(DWORD,LPWSTR))aSyscall[32].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "GetTickCount",            (SYSCALL)GetTickCount,            0 },¥#elseÙE  { "GetTickCount",            (SYSCALL)0,                       0 },¦#endif ÙD#define osGetTickCount ((DWORD(WINAPI*)(VOID))aSyscall[33].pCurrent) Ù?#if defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_GETVERSIONEXÙE  { "GetVersionExA",           (SYSCALL)GetVersionExA,           0 },¥#elseÙE  { "GetVersionExA",           (SYSCALL)0,                       0 },¦#endif Ù*#define osGetVersionExA ((BOOL(WINAPI*)( \Ù0        LPOSVERSIONINFOA))aSyscall[34].pCurrent) Ù;#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \Ù!        SQLITE_WIN32_GETVERSIONEXÙE  { "GetVersionExW",           (SYSCALL)GetVersionExW,           0 },¥#elseÙE  { "GetVersionExW",           (SYSCALL)0,                       0 },¦#endif Ù*#define osGetVersionExW ((BOOL(WINAPI*)( \Ù0        LPOSVERSIONINFOW))aSyscall[35].pCurrent) ÙE  { "HeapAlloc",               (SYSCALL)HeapAlloc,               0 }, Ù5#define osHeapAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD, \Ù&        SIZE_T))aSyscall[36].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "HeapCreate",              (SYSCALL)HeapCreate,              0 },¥#elseÙE  { "HeapCreate",              (SYSCALL)0,                       0 },¦#endif Ù6#define osHeapCreate ((HANDLE(WINAPI*)(DWORD,SIZE_T, \Ù&        SIZE_T))aSyscall[37].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "HeapDestroy",             (SYSCALL)HeapDestroy,             0 },¥#elseÙE  { "HeapDestroy",             (SYSCALL)0,                       0 },¦#endif ÙD#define osHeapDestroy ((BOOL(WINAPI*)(HANDLE))aSyscall[38].pCurrent) ÙE  { "HeapFree",                (SYSCALL)HeapFree,                0 }, ÙN#define osHeapFree ((BOOL(WINAPI*)(HANDLE,DWORD,LPVOID))aSyscall[39].pCurrent) ÙE  { "HeapReAlloc",             (SYSCALL)HeapReAlloc,             0 }, Ù>#define osHeapReAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD,LPVOID, \Ù&        SIZE_T))aSyscall[40].pCurrent) ÙE  { "HeapSize",                (SYSCALL)HeapSize,                0 }, Ù4#define osHeapSize ((SIZE_T(WINAPI*)(HANDLE,DWORD, \Ù'        LPCVOID))aSyscall[41].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "HeapValidate",            (SYSCALL)HeapValidate,            0 },¥#elseÙE  { "HeapValidate",            (SYSCALL)0,                       0 },¦#endif Ù6#define osHeapValidate ((BOOL(WINAPI*)(HANDLE,DWORD, \Ù'        LPCVOID))aSyscall[42].pCurrent) Ù(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTÙE  { "HeapCompact",             (SYSCALL)HeapCompact,             0 },¥#elseÙE  { "HeapCompact",             (SYSCALL)0,                       0 },¦#endif ÙJ#define osHeapCompact ((UINT(WINAPI*)(HANDLE,DWORD))aSyscall[43].pCurrent) ÙJ#if defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_OMIT_LOAD_EXTENSION)ÙE  { "LoadLibraryA",            (SYSCALL)LoadLibraryA,            0 },¥#elseÙE  { "LoadLibraryA",            (SYSCALL)0,                       0 },¦#endif ÙH#define osLoadLibraryA ((HMODULE(WINAPI*)(LPCSTR))aSyscall[44].pCurrent) Ù;#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \Ù,        !defined(SQLITE_OMIT_LOAD_EXTENSION)ÙE  { "LoadLibraryW",            (SYSCALL)LoadLibraryW,            0 },¥#elseÙE  { "LoadLibraryW",            (SYSCALL)0,                       0 },¦#endif ÙI#define osLoadLibraryW ((HMODULE(WINAPI*)(LPCWSTR))aSyscall[45].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "LocalFree",               (SYSCALL)LocalFree,               0 },¥#elseÙE  { "LocalFree",               (SYSCALL)0,                       0 },¦#endif ÙD#define osLocalFree ((HLOCAL(WINAPI*)(HLOCAL))aSyscall[46].pCurrent) Ù(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTÙE  { "LockFile",                (SYSCALL)LockFile,                0 },¥#elseÙE  { "LockFile",                (SYSCALL)0,                       0 },¦#endif ²#ifndef osLockFileÙ>#define osLockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ù%        DWORD))aSyscall[47].pCurrent)¦#endif ´#if !SQLITE_OS_WINCEÙE  { "LockFileEx",              (SYSCALL)LockFileEx,              0 },¥#elseÙE  { "LockFileEx",              (SYSCALL)0,                       0 },¦#endif ´#ifndef osLockFileExÙF#define osLockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,DWORD, \Ù,        LPOVERLAPPED))aSyscall[48].pCurrent)¦#endif Ù-#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && \Ù>        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))ÙE  { "MapViewOfFile",           (SYSCALL)MapViewOfFile,           0 },¥#elseÙE  { "MapViewOfFile",           (SYSCALL)0,                       0 },¦#endif ÙE#define osMapViewOfFile ((LPVOID(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ù&        SIZE_T))aSyscall[49].pCurrent) ÙE  { "MultiByteToWideChar",     (SYSCALL)MultiByteToWideChar,     0 }, ÙL#define osMultiByteToWideChar ((int(WINAPI*)(UINT,DWORD,LPCSTR,int,LPWSTR, \Ù#        int))aSyscall[50].pCurrent) ÙE  { "QueryPerformanceCounter", (SYSCALL)QueryPerformanceCounter, 0 }, Ù4#define osQueryPerformanceCounter ((BOOL(WINAPI*)( \Ù.        LARGE_INTEGER*))aSyscall[51].pCurrent) ÙE  { "ReadFile",                (SYSCALL)ReadFile,                0 }, ÙA#define osReadFile ((BOOL(WINAPI*)(HANDLE,LPVOID,DWORD,LPDWORD, \Ù,        LPOVERLAPPED))aSyscall[52].pCurrent) ÙE  { "SetEndOfFile",            (SYSCALL)SetEndOfFile,            0 }, ÙE#define osSetEndOfFile ((BOOL(WINAPI*)(HANDLE))aSyscall[53].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "SetFilePointer",          (SYSCALL)SetFilePointer,          0 },¥#elseÙE  { "SetFilePointer",          (SYSCALL)0,                       0 },¦#endif Ù>#define osSetFilePointer ((DWORD(WINAPI*)(HANDLE,LONG,PLONG, \Ù%        DWORD))aSyscall[54].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "Sleep",                   (SYSCALL)Sleep,                   0 },¥#elseÙE  { "Sleep",                   (SYSCALL)0,                       0 },¦#endif Ù=#define osSleep ((VOID(WINAPI*)(DWORD))aSyscall[55].pCurrent) ÙE  { "SystemTimeToFileTime",    (SYSCALL)SystemTimeToFileTime,    0 }, ÙC#define osSystemTimeToFileTime ((BOOL(WINAPI*)(CONST SYSTEMTIME*, \Ù*        LPFILETIME))aSyscall[56].pCurrent) Ù(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTÙE  { "UnlockFile",              (SYSCALL)UnlockFile,              0 },¥#elseÙE  { "UnlockFile",              (SYSCALL)0,                       0 },¦#endif ´#ifndef osUnlockFileÙ@#define osUnlockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ù%        DWORD))aSyscall[57].pCurrent)¦#endif ´#if !SQLITE_OS_WINCEÙE  { "UnlockFileEx",            (SYSCALL)UnlockFileEx,            0 },¥#elseÙE  { "UnlockFileEx",            (SYSCALL)0,                       0 },¦#endif ÙB#define osUnlockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \Ù,        LPOVERLAPPED))aSyscall[58].pCurrent) ÙJ#if SQLITE_OS_WINCE || !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0ÙE  { "UnmapViewOfFile",         (SYSCALL)UnmapViewOfFile,         0 },¥#elseÙE  { "UnmapViewOfFile",         (SYSCALL)0,                       0 },¦#endif ÙI#define osUnmapViewOfFile ((BOOL(WINAPI*)(LPCVOID))aSyscall[59].pCurrent) ÙE  { "WideCharToMultiByte",     (SYSCALL)WideCharToMultiByte,     0 }, ÙP#define osWideCharToMultiByte ((int(WINAPI*)(UINT,DWORD,LPCWSTR,int,LPSTR,int, \Ù-        LPCSTR,LPBOOL))aSyscall[60].pCurrent) ÙE  { "WriteFile",               (SYSCALL)WriteFile,               0 }, ÙC#define osWriteFile ((BOOL(WINAPI*)(HANDLE,LPCVOID,DWORD,LPDWORD, \Ù,        LPOVERLAPPED))aSyscall[61].pCurrent) ³#if SQLITE_OS_WINRTÙE  { "CreateEventExW",          (SYSCALL)CreateEventExW,          0 },¥#elseÙE  { "CreateEventExW",          (SYSCALL)0,                       0 },¦#endif ÙK#define osCreateEventExW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,LPCWSTR, \Ù+        DWORD,DWORD))aSyscall[62].pCurrent) ´#if !SQLITE_OS_WINRTÙE  { "WaitForSingleObject",     (SYSCALL)WaitForSingleObject,     0 },¥#elseÙE  { "WaitForSingleObject",     (SYSCALL)0,                       0 },¦#endif Ù8#define osWaitForSingleObject ((DWORD(WINAPI*)(HANDLE, \Ù%        DWORD))aSyscall[63].pCurrent) ´#if !SQLITE_OS_WINCEÙE  { "WaitForSingleObjectEx",   (SYSCALL)WaitForSingleObjectEx,   0 },¥#elseÙE  { "WaitForSingleObjectEx",   (SYSCALL)0,                       0 },¦#endif Ù@#define osWaitForSingleObjectEx ((DWORD(WINAPI*)(HANDLE,DWORD, \Ù$        BOOL))aSyscall[64].pCurrent) ³#if SQLITE_OS_WINRTÙE  { "SetFilePointerEx",        (SYSCALL)SetFilePointerEx,        0 },¥#elseÙE  { "SetFilePointerEx",        (SYSCALL)0,                       0 },¦#endif ÙB#define osSetFilePointerEx ((BOOL(WINAPI*)(HANDLE,LARGE_INTEGER, \Ù4        PLARGE_INTEGER,DWORD))aSyscall[65].pCurrent) ³#if SQLITE_OS_WINRTÙO  { "GetFileInformationByHandleEx", (SYSCALL)GetFileInformationByHandleEx, 0 },¥#elseÙE  { "GetFileInformationByHandleEx", (SYSCALL)0,                  0 },¦#endif Ù@#define osGetFileInformationByHandleEx ((BOOL(WINAPI*)(HANDLE, \ÙF        FILE_INFO_BY_HANDLE_CLASS,LPVOID,DWORD))aSyscall[66].pCurrent) ÙL#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)ÙE  { "MapViewOfFileFromApp",    (SYSCALL)MapViewOfFileFromApp,    0 },¥#elseÙE  { "MapViewOfFileFromApp",    (SYSCALL)0,                       0 },¦#endif ÙH#define osMapViewOfFileFromApp ((LPVOID(WINAPI*)(HANDLE,ULONG,ULONG64, \Ù&        SIZE_T))aSyscall[67].pCurrent) ³#if SQLITE_OS_WINRTÙE  { "CreateFile2",             (SYSCALL)CreateFile2,             0 },¥#elseÙE  { "CreateFile2",             (SYSCALL)0,                       0 },¦#endif ÙD#define osCreateFile2 ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD,DWORD, \ÙA        LPCREATEFILE2_EXTENDED_PARAMETERS))aSyscall[68].pCurrent) Ù;#if SQLITE_OS_WINRT && !defined(SQLITE_OMIT_LOAD_EXTENSION)ÙE  { "LoadPackagedLibrary",     (SYSCALL)LoadPackagedLibrary,     0 },¥#elseÙE  { "LoadPackagedLibrary",     (SYSCALL)0,                       0 },¦#endif Ù;#define osLoadPackagedLibrary ((HMODULE(WINAPI*)(LPCWSTR, \Ù%        DWORD))aSyscall[69].pCurrent) ³#if SQLITE_OS_WINRTÙE  { "GetTickCount64",          (SYSCALL)GetTickCount64,          0 },¥#elseÙE  { "GetTickCount64",          (SYSCALL)0,                       0 },¦#endif ÙJ#define osGetTickCount64 ((ULONGLONG(WINAPI*)(VOID))aSyscall[70].pCurrent) ³#if SQLITE_OS_WINRTÙE  { "GetNativeSystemInfo",     (SYSCALL)GetNativeSystemInfo,     0 },¥#elseÙE  { "GetNativeSystemInfo",     (SYSCALL)0,                       0 },¦#endif Ù0#define osGetNativeSystemInfo ((VOID(WINAPI*)( \Ù-        LPSYSTEM_INFO))aSyscall[71].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_ANSI)ÙE  { "OutputDebugStringA",      (SYSCALL)OutputDebugStringA,      0 },¥#elseÙE  { "OutputDebugStringA",      (SYSCALL)0,                       0 },¦#endif ÙK#define osOutputDebugStringA ((VOID(WINAPI*)(LPCSTR))aSyscall[72].pCurrent) Ù"#if defined(SQLITE_WIN32_HAS_WIDE)ÙE  { "OutputDebugStringW",      (SYSCALL)OutputDebugStringW,      0 },¥#elseÙE  { "OutputDebugStringW",      (SYSCALL)0,                       0 },¦#endif ÙL#define osOutputDebugStringW ((VOID(WINAPI*)(LPCWSTR))aSyscall[73].pCurrent) ÙE  { "GetProcessHeap",          (SYSCALL)GetProcessHeap,          0 }, ÙG#define osGetProcessHeap ((HANDLE(WINAPI*)(VOID))aSyscall[74].pCurrent) ÙL#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)ÙG  { "CreateFileMappingFromApp", (SYSCALL)CreateFileMappingFromApp, 0 },¥#elseÙE  { "CreateFileMappingFromApp", (SYSCALL)0,                      0 },¦#endif Ù>#define osCreateFileMappingFromApp ((HANDLE(WINAPI*)(HANDLE, \ÙK        LPSECURITY_ATTRIBUTES,ULONG,ULONG64,LPCWSTR))aSyscall[75].pCurrent) ¢/*ÙI** NOTE: On some sub-platforms, the InterlockedCompareExchange "function"ÙJ**       is really just a macro that uses a compiler intrinsic (e.g. x64).ÙD**       So do not try to make this is into a redefinable interface.¢*/Ù'#if defined(InterlockedCompareExchange)ÙE  { "InterlockedCompareExchange", (SYSCALL)0,                    0 }, Ù?#define osInterlockedCompareExchange InterlockedCompareExchange¥#elseÙK  { "InterlockedCompareExchange", (SYSCALL)InterlockedCompareExchange, 0 }, Ù;#define osInterlockedCompareExchange ((LONG(WINAPI*)(LONG \ÙA        SQLITE_WIN32_VOLATILE*, LONG,LONG))aSyscall[76].pCurrent)Ù0#endif /* defined(InterlockedCompareExchange) */ ÙA#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUIDÙE  { "UuidCreate",               (SYSCALL)UuidCreate,             0 },¥#elseÙE  { "UuidCreate",               (SYSCALL)0,                      0 },¦#endif ÙK#define osUuidCreate ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[77].pCurrent) ÙA#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUIDÙE  { "UuidCreateSequential",     (SYSCALL)UuidCreateSequential,   0 },¥#elseÙE  { "UuidCreateSequential",     (SYSCALL)0,                      0 },¦#endif Ù #define osUuidCreateSequential \Ù>        ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[78].pCurrent) Ù6#if !defined(SQLITE_NO_SYNC) && SQLITE_MAX_MMAP_SIZE>0ÙE  { "FlushViewOfFile",          (SYSCALL)FlushViewOfFile,        0 },¥#elseÙE  { "FlushViewOfFile",          (SYSCALL)0,                      0 },¦#endif »#define osFlushViewOfFile \Ù>        ((BOOL(WINAPI*)(LPCVOID,SIZE_T))aSyscall[79].pCurrent) Ù-}; /* End of the overrideable system calls */ ¢/*ÙD** This is the xSetSystemCall() method of sqlite3_vfs for all of theÙB** "win32" VFSes.  Return SQLITE_OK opon successfully updating theÙF** system call pointer, or SQLITE_NOTFOUND if there is no configurable»** system call named zName.¢*/¼static int winSetSystemCall(Ù@  sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */ÙE  const char *zName,            /* Name of system call to override */ÙF  sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */¢){±  unsigned int i;»  int rc = SQLITE_NOTFOUND; ½  UNUSED_PARAMETER(pNotUsed);±  if( zName==0 ){ÙF    /* If no zName is given, restore all system calls to their default¿    ** settings and return NULL¦    */³    rc = SQLITE_OK;Ù:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ù!      if( aSyscall[i].pDefault ){Ù4        aSyscall[i].pCurrent = aSyscall[i].pDefault;§      }¥    }¨  }else{ÙA    /* If zName is specified, operate on only the one system call±    ** specified.¦    */Ù:    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){Ù0      if( strcmp(zName, aSyscall[i].zName)==0 ){Ù&        if( aSyscall[i].pDefault==0 ){Ù6          aSyscall[i].pDefault = aSyscall[i].pCurrent;©        }·        rc = SQLITE_OK;Ù:        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;Ù(        aSyscall[i].pCurrent = pNewFunc;®        break;§      }¥    }£  }¬  return rc;¡} ¢/*ÙD** Return the value of a system call.  Return NULL if zName is not aÙI** recognized system call name.  NULL is also returned if the system callº** is currently undefined.¢*/Ù,static sqlite3_syscall_ptr winGetSystemCall(¸  sqlite3_vfs *pNotUsed,³  const char *zName¢){±  unsigned int i; ½  UNUSED_PARAMETER(pNotUsed);Ù8  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){ÙJ    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;£  }«  return 0;¡} ¢/*ÙH** Return the name of the first system call after zName.  If zName==NULLÙG** then return the name of the first system call.  Return NULL if zNameÙA** is the last system call or if zName is not the name of a valid¯** system call.¢*/ÙHstatic const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){­  int i = -1; ¶  UNUSED_PARAMETER(p);®  if( zName ){Ù+    for(i=0; i<ArraySize(aSyscall)-1; i++){Ù6      if( strcmp(zName, aSyscall[i].zName)==0 ) break;¥    }£  }Ù'  for(i++; i<ArraySize(aSyscall); i++){Ù;    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;£  }«  return 0;¡} º#ifdef SQLITE_WIN32_MALLOC¢/*ÙL** If a Win32 native heap has been configured, this function will attempt toÙL** compact it.  Upon success, SQLITE_OK will be returned.  Upon failure, oneÙK** of SQLITE_NOMEM, SQLITE_ERROR, or SQLITE_NOTFOUND will be returned.  TheÙL** "pnLargest" argument, if non-zero, will be used to return the size of theÙ6** largest committed free block in the heap, in bytes.¢*/Ù<SQLITE_API int sqlite3_win32_compact_heap(LPUINT pnLargest){µ  int rc = SQLITE_OK;´  UINT nLargest = 0;¯  HANDLE hHeap; ¶  winMemAssertMagic();º  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ù(  assert( hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ÙA  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¦#endifÙ(#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRTÙD  if( (nLargest=osHeapCompact(hHeap, SQLITE_WIN32_HEAP_FLAGS))==0 ){Ù'    DWORD lastErrno = osGetLastError();¾    if( lastErrno==NO_ERROR ){ÙL      sqlite3_log(SQLITE_NOMEM, "failed to HeapCompact (no space), heap=%p",Ù                   (void*)hHeap);½      rc = SQLITE_NOMEM_BKPT;ª    }else{ÙG      sqlite3_log(SQLITE_ERROR, "failed to HeapCompact (%lu), heap=%p",Ù2                  osGetLastError(), (void*)hHeap);¸      rc = SQLITE_ERROR;¥    }£  }¥#elseÙ@  sqlite3_log(SQLITE_NOTFOUND, "failed to HeapCompact, heap=%p",¼              (void*)hHeap);·  rc = SQLITE_NOTFOUND;¦#endifÙ(  if( pnLargest ) *pnLargest = nLargest;¬  return rc;¡} ¢/*ÙL** If a Win32 native heap has been configured, this function will attempt toÙL** destroy and recreate it.  If the Win32 native heap is not isolated and/orÙL** the sqlite3_memory_used() function does not return zero, SQLITE_BUSY willÙD** be returned and no changes will be made to the Win32 native heap.¢*/Ù*SQLITE_API int sqlite3_win32_reset_heap(){©  int rc;ÙD  MUTEX_LOGIC( sqlite3_mutex *pMaster; ) /* The main static mutex */ÙF  MUTEX_LOGIC( sqlite3_mutex *pMem; )    /* The memsys static mutex */ÙI  MUTEX_LOGIC( pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER); )ÙC  MUTEX_LOGIC( pMem = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); )¿  sqlite3_mutex_enter(pMaster);¼  sqlite3_mutex_enter(pMem);¶  winMemAssertMagic();ÙN  if( winMemGetHeap()!=NULL && winMemGetOwned() && sqlite3_memory_used()==0 ){¦    /*ÙJ    ** At this point, there should be no outstanding memory allocations onÙL    ** the heap.  Also, since both the master and memsys locks are currentlyÙL    ** being held by us, no other function (i.e. from another thread) shouldÙL    ** be able to even access the heap.  Attempt to destroy and recreate ourÙ&    ** isolated Win32 native heap now.¦    */Ù$    assert( winMemGetHeap()!=NULL );¿    assert( winMemGetOwned() );Ù'    assert( sqlite3_memory_used()==0 );Ù'    winMemShutdown(winMemGetDataPtr());Ù$    assert( winMemGetHeap()==NULL );Ù     assert( !winMemGetOwned() );Ù'    assert( sqlite3_memory_used()==0 );Ù(    rc = winMemInit(winMemGetDataPtr());Ù5    assert( rc!=SQLITE_OK || winMemGetHeap()!=NULL );Ù0    assert( rc!=SQLITE_OK || winMemGetOwned() );Ù8    assert( rc!=SQLITE_OK || sqlite3_memory_used()==0 );¨  }else{¦    /*ÙI    ** The Win32 native heap cannot be modified because it may be in use.¦    */µ    rc = SQLITE_BUSY;£  }¼  sqlite3_mutex_leave(pMem);¿  sqlite3_mutex_leave(pMaster);¬  return rc;¡}Ù #endif /* SQLITE_WIN32_MALLOC */ ¢/*ÙJ** This function outputs the specified (ANSI) string to the Win32 debugger²** (if available).¢*/ ÙFSQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf){Ù*  char zDbgBuf[SQLITE_WIN32_DBG_BUF_SIZE];ÙO  int nMin = MIN(nBuf, (SQLITE_WIN32_DBG_BUF_SIZE - 1)); /* may be negative. */Ù?  if( nMin<-1 ) nMin = -1; /* all negative values become -1. */ÙB  assert( nMin==-1 || nMin==0 || nMin<SQLITE_WIN32_DBG_BUF_SIZE );¾#ifdef SQLITE_ENABLE_API_ARMOR®  if( !zBuf ){½    (void)SQLITE_MISUSE_BKPT;«    return;£  }¦#endifÙ"#if defined(SQLITE_WIN32_HAS_ANSI)¯  if( nMin>0 ){Ù2    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);Ù     memcpy(zDbgBuf, zBuf, nMin);Ù"    osOutputDebugStringA(zDbgBuf);¨  }else{¿    osOutputDebugStringA(zBuf);£  }Ù$#elif defined(SQLITE_WIN32_HAS_WIDE)Ù0  memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);½  if ( osMultiByteToWideChar(Ù;          osAreFileApisANSI() ? CP_ACP : CP_OEMCP, 0, zBuf,ÙO          nMin, (LPWSTR)zDbgBuf, SQLITE_WIN32_DBG_BUF_SIZE/sizeof(WCHAR))<=0 ){«    return;£  }Ù)  osOutputDebugStringW((LPCWSTR)zDbgBuf);¥#else¯  if( nMin>0 ){Ù2    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);Ù     memcpy(zDbgBuf, zBuf, nMin);Ù#    fprintf(stderr, "%s", zDbgBuf);¨  }else{Ù     fprintf(stderr, "%s", zBuf);£  }¦#endif¡} ¢/*ÙD** The following routine suspends the current thread for at least msÙD** milliseconds.  This is equivalent to the Win32 Sleep() interface.¢*/³#if SQLITE_OS_WINRT¾static HANDLE sleepObj = NULL;¦#endif Ù8SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds){³#if SQLITE_OS_WINRT¸  if ( sleepObj==NULL ){ÙF    sleepObj = osCreateEventExW(NULL, NULL, CREATE_EVENT_MANUAL_RESET,Ù-                                SYNCHRONIZE);£  }»  assert( sleepObj!=NULL );Ù9  osWaitForSingleObjectEx(sleepObj, milliseconds, FALSE);¥#else¸  osSleep(milliseconds);¦#endif¡} ÙL#if SQLITE_MAX_WORKER_THREADS>0 && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && \»        SQLITE_THREADSAFE>0Ù6SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject){«  DWORD rc;Ù9  while( (rc = osWaitForSingleObjectEx(hObject, INFINITE,ÙE                                       TRUE))==WAIT_IO_COMPLETION ){}¬  return rc;¡}¦#endif ¢/*ÙF** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,Ù=** or WinCE.  Return false (zero) for Win95, Win98, or WinME.¢**ÙD** Here is an interesting observation:  Win95, Win98, and WinME lackÙG** the LockFileEx() API.  But we can still statically link against thatÙG** API as long as we don't call it when running Win95/98/ME.  A call toÙB** this routine is used to determine if the host is Win95/98/ME orÙE** WinNT/2K/XP so that we will know whether or not we can safely call¸** the LockFileEx() API.¢*/ ¾#if !SQLITE_WIN32_GETVERSIONEX¶# define osIsNT()  (1)ÙK#elif SQLITE_OS_WINCE || SQLITE_OS_WINRT || !defined(SQLITE_WIN32_HAS_ANSI)¶# define osIsNT()  (1)Ù%#elif !defined(SQLITE_WIN32_HAS_WIDE)¶# define osIsNT()  (0)¥#elseÙB# define osIsNT()  ((sqlite3_os_type==2) || sqlite3_win32_is_nt())¦#endif ¢/*ÙJ** This function determines if the machine is running a version of Windowsº** based on the NT kernel.¢*/Ù)SQLITE_API int sqlite3_win32_is_nt(void){³#if SQLITE_OS_WINRT¤  /*ÙI  ** NOTE: The WinRT sub-platform is always assumed to be based on the NT²  **       kernel.¤  */«  return 1;¿#elif SQLITE_WIN32_GETVERSIONEXÙ@  if( osInterlockedCompareExchange(&sqlite3_os_type, 0, 0)==0 ){Ù"#if defined(SQLITE_WIN32_HAS_ANSI)¹    OSVERSIONINFOA sInfo;Ù.    sInfo.dwOSVersionInfoSize = sizeof(sInfo);¼    osGetVersionExA(&sInfo);Ù2    osInterlockedCompareExchange(&sqlite3_os_type,ÙB        (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);Ù$#elif defined(SQLITE_WIN32_HAS_WIDE)¹    OSVERSIONINFOW sInfo;Ù.    sInfo.dwOSVersionInfoSize = sizeof(sInfo);¼    osGetVersionExW(&sInfo);Ù2    osInterlockedCompareExchange(&sqlite3_os_type,ÙB        (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);¦#endif£  }ÙA  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;±#elif SQLITE_TESTÙA  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;¥#else¤  /*ÙE  ** NOTE: All sub-platforms where the GetVersionEx[AW] functions areÙF  **       deprecated are always assumed to be based on the NT kernel.¤  */«  return 1;¦#endif¡} º#ifdef SQLITE_WIN32_MALLOC¢/*½** Allocate nBytes of memory.¢*/Ù&static void *winMemMalloc(int nBytes){¯  HANDLE hHeap;ª  void *p; ¶  winMemAssertMagic();º  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ù(  assert( hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ÙA  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¦#endif¶  assert( nBytes>=0 );ÙB  p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);«  if( !p ){ÙL    sqlite3_log(SQLITE_NOMEM, "failed to HeapAlloc %u bytes (%lu), heap=%p",Ù8                nBytes, osGetLastError(), (void*)hHeap);£  }«  return p;¡} ¢/*¯** Free memory.¢*/Ù%static void winMemFree(void *pPrior){¯  HANDLE hHeap; ¶  winMemAssertMagic();º  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ù(  assert( hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ÙC  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );¦#endifÙD  if( !pPrior ) return; /* Passing NULL to HeapFree is undefined. */Ù<  if( !osHeapFree(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) ){ÙK    sqlite3_log(SQLITE_NOMEM, "failed to HeapFree block %p (%lu), heap=%p",Ù8                pPrior, osGetLastError(), (void*)hHeap);£  }¡} ¢/*Ù3** Change the size of an existing memory allocation¢*/Ù5static void *winMemRealloc(void *pPrior, int nBytes){¯  HANDLE hHeap;ª  void *p; ¶  winMemAssertMagic();º  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ù(  assert( hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ÙC  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );¦#endif¶  assert( nBytes>=0 );°  if( !pPrior ){ÙD    p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);¨  }else{ÙN    p = osHeapReAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior, (SIZE_T)nBytes);£  }«  if( !p ){ÙE    sqlite3_log(SQLITE_NOMEM, "failed to %s %u bytes (%lu), heap=%p",ÙO                pPrior ? "HeapReAlloc" : "HeapAlloc", nBytes, osGetLastError(),¾                (void*)hHeap);£  }«  return p;¡} ¢/*Ù:** Return the size of an outstanding allocation, in bytes.¢*/¿static int winMemSize(void *p){¯  HANDLE hHeap;«  SIZE_T n; ¶  winMemAssertMagic();º  hHeap = winMemGetHeap();µ  assert( hHeap!=0 );Ù(  assert( hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)Ù>  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, p) );¦#endif´  if( !p ) return 0;Ù4  n = osHeapSize(hHeap, SQLITE_WIN32_HEAP_FLAGS, p);¶  if( n==(SIZE_T)-1 ){ÙK    sqlite3_log(SQLITE_NOMEM, "failed to HeapSize block %p (%lu), heap=%p",Ù3                p, osGetLastError(), (void*)hHeap);­    return 0;£  }°  return (int)n;¡} ¢/*Ù=** Round up a request size to the next valid allocation size.¢*/Ù static int winMemRoundup(int n){«  return n;¡} ¢/*º** Initialize this module.¢*/Ù&static int winMemInit(void *pAppData){Ù3  winMemData *pWinMemData = (winMemData *)pAppData; Ù)  if( !pWinMemData ) return SQLITE_ERROR;Ù/  assert( pWinMemData->magic1==WINMEM_MAGIC1 );Ù/  assert( pWinMemData->magic2==WINMEM_MAGIC2 ); Ù0#if !SQLITE_OS_WINRT && SQLITE_WIN32_HEAP_CREATE¼  if( !pWinMemData->hHeap ){Ù6    DWORD dwInitialSize = SQLITE_WIN32_HEAP_INIT_SIZE;Ù;    DWORD dwMaximumSize = (DWORD)sqlite3GlobalConfig.nHeap;»    if( dwMaximumSize==0 ){Ù1      dwMaximumSize = SQLITE_WIN32_HEAP_MAX_SIZE;Ù,    }else if( dwInitialSize>dwMaximumSize ){Ù$      dwInitialSize = dwMaximumSize;¥    }Ù>    pWinMemData->hHeap = osHeapCreate(SQLITE_WIN32_HEAP_FLAGS,ÙD                                      dwInitialSize, dwMaximumSize);¾    if( !pWinMemData->hHeap ){¿      sqlite3_log(SQLITE_NOMEM,ÙL          "failed to HeapCreate (%lu), flags=%u, initSize=%lu, maxSize=%lu",ÙC          osGetLastError(), SQLITE_WIN32_HEAP_FLAGS, dwInitialSize,¹          dwMaximumSize);¿      return SQLITE_NOMEM_BKPT;¥    }¿    pWinMemData->bOwned = TRUE;Ù"    assert( pWinMemData->bOwned );£  }¥#elseÙ*  pWinMemData->hHeap = osGetProcessHeap();¼  if( !pWinMemData->hHeap ){½    sqlite3_log(SQLITE_NOMEM,Ù<        "failed to GetProcessHeap (%lu)", osGetLastError());½    return SQLITE_NOMEM_BKPT;£  }¾  pWinMemData->bOwned = FALSE;Ù!  assert( !pWinMemData->bOwned );¦#endifÙ"  assert( pWinMemData->hHeap!=0 );Ù5  assert( pWinMemData->hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ÙN  assert( osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¦#endif³  return SQLITE_OK;¡} ¢/*¼** Deinitialize this module.¢*/Ù+static void winMemShutdown(void *pAppData){Ù3  winMemData *pWinMemData = (winMemData *)pAppData; ¼  if( !pWinMemData ) return;Ù/  assert( pWinMemData->magic1==WINMEM_MAGIC1 );Ù/  assert( pWinMemData->magic2==WINMEM_MAGIC2 ); »  if( pWinMemData->hHeap ){Ù7    assert( pWinMemData->hHeap!=INVALID_HANDLE_VALUE );Ù=#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)ÙP    assert( osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );¦#endif¾    if( pWinMemData->bOwned ){Ù/      if( !osHeapDestroy(pWinMemData->hHeap) ){ÙI        sqlite3_log(SQLITE_NOMEM, "failed to HeapDestroy (%lu), heap=%p",ÙA                    osGetLastError(), (void*)pWinMemData->hHeap);§      }Ù"      pWinMemData->bOwned = FALSE;¥    }¾    pWinMemData->hHeap = NULL;£  }¡} ¢/*Ù@** Populate the low-level memory allocation function pointers inÙH** sqlite3GlobalConfig.m with pointers to the routines in this file. TheÙ3** arguments specify the block of memory to manage.¢**ÙA** This routine is only called by sqlite3_config(), and thereforeÙ0** is not required to be threadsafe (it is not).¢*/ÙCSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void){Ù4  static const sqlite3_mem_methods winMemMethods = {±    winMemMalloc,¯    winMemFree,²    winMemRealloc,¯    winMemSize,²    winMemRoundup,¯    winMemInit,³    winMemShutdown,±    &win_mem_data¤  };¸  return &winMemMethods;¡} Ù/SQLITE_PRIVATE void sqlite3MemSetDefault(void){Ù=  sqlite3_config(SQLITE_CONFIG_MALLOC, sqlite3MemGetWin32());¡}Ù #endif /* SQLITE_WIN32_MALLOC */ ¢/*Ù/** Convert a UTF-8 string to Microsoft Unicode.¢**ÙG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ù2static LPWSTR winUtf8ToUnicode(const char *zText){¬  int nChar;³  LPWSTR zWideText; Ù@  nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);±  if( nChar==0 ){­    return 0;£  }Ù7  zWideText = sqlite3MallocZero( nChar*sizeof(WCHAR) );µ  if( zWideText==0 ){­    return 0;£  }ÙA  nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText,Ù'                                nChar);±  if( nChar==0 ){¼    sqlite3_free(zWideText);²    zWideText = 0;£  }³  return zWideText;¡} ¢/*Ù/** Convert a Microsoft Unicode string to UTF-8.¢**ÙG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ù1static char *winUnicodeToUtf8(LPCWSTR zWideText){¬  int nByte;®  char *zText; ÙG  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);³  if( nByte == 0 ){­    return 0;£  }Ù%  zText = sqlite3MallocZero( nByte );±  if( zText==0 ){­    return 0;£  }ÙH  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte,Ù&                                0, 0);³  if( nByte == 0 ){¸    sqlite3_free(zText);®    zText = 0;£  }¯  return zText;¡} ¢/*ÙE** Convert an ANSI string to Microsoft Unicode, using the ANSI or OEM­** code page.¢**ÙG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ù?static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi){¬  int nByte;³  LPWSTR zMbcsText;Ù-  int codepage = useAnsi ? CP_ACP : CP_OEMCP; Ù=  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,Ù1                                0)*sizeof(WCHAR);±  if( nByte==0 ){­    return 0;£  }Ù7  zMbcsText = sqlite3MallocZero( nByte*sizeof(WCHAR) );µ  if( zMbcsText==0 ){­    return 0;£  }ÙB  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,Ù'                                nByte);±  if( nByte==0 ){¼    sqlite3_free(zMbcsText);²    zMbcsText = 0;£  }³  return zMbcsText;¡} ¢/*ÙG** Convert a Microsoft Unicode string to a multi-byte character string,Ù#** using the ANSI or OEM code page.¢**ÙG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ù>static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi){¬  int nByte;®  char *zText;Ù-  int codepage = useAnsi ? CP_ACP : CP_OEMCP; ÙH  nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);³  if( nByte == 0 ){­    return 0;£  }Ù%  zText = sqlite3MallocZero( nByte );±  if( zText==0 ){­    return 0;£  }ÙB  nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, zText,Ù-                                nByte, 0, 0);³  if( nByte == 0 ){¸    sqlite3_free(zText);®    zText = 0;£  }¯  return zText;¡} ¢/*Ù2** Convert a multi-byte character string to UTF-8.¢**ÙG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ù;static char *winMbcsToUtf8(const char *zText, int useAnsi){²  char *zTextUtf8;²  LPWSTR zTmpWide; Ù.  zTmpWide = winMbcsToUnicode(zText, useAnsi);´  if( zTmpWide==0 ){­    return 0;£  }Ù)  zTextUtf8 = winUnicodeToUtf8(zTmpWide);¹  sqlite3_free(zTmpWide);³  return zTextUtf8;¡} ¢/*Ù;** Convert a UTF-8 string to a multi-byte character string.¢**ÙG** Space to hold the returned string is obtained from sqlite3_malloc().¢*/Ù;static char *winUtf8ToMbcs(const char *zText, int useAnsi){²  char *zTextMbcs;²  LPWSTR zTmpWide; Ù%  zTmpWide = winUtf8ToUnicode(zText);´  if( zTmpWide==0 ){­    return 0;£  }Ù2  zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);¹  sqlite3_free(zTmpWide);³  return zTextMbcs;¡} ¢/*Ù@** This is a public wrapper for the winUtf8ToUnicode() function.¢*/ÙCSQLITE_API LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText){¾#ifdef SQLITE_ENABLE_API_ARMOR¯  if( !zText ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ!  return winUtf8ToUnicode(zText);¡} ¢/*Ù@** This is a public wrapper for the winUnicodeToUtf8() function.¢*/ÙBSQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText){¾#ifdef SQLITE_ENABLE_API_ARMOR³  if( !zWideText ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ%  return winUnicodeToUtf8(zWideText);¡} ¢/*Ù=** This is a public wrapper for the winMbcsToUtf8() function.¢*/Ù?SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zText){¾#ifdef SQLITE_ENABLE_API_ARMOR¯  if( !zText ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ3  return winMbcsToUtf8(zText, osAreFileApisANSI());¡} ¢/*Ù=** This is a public wrapper for the winMbcsToUtf8() function.¢*/ÙOSQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi){¾#ifdef SQLITE_ENABLE_API_ARMOR¯  if( !zText ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ'  return winMbcsToUtf8(zText, useAnsi);¡} ¢/*Ù=** This is a public wrapper for the winUtf8ToMbcs() function.¢*/Ù?SQLITE_API char *sqlite3_win32_utf8_to_mbcs(const char *zText){¾#ifdef SQLITE_ENABLE_API_ARMOR¯  if( !zText ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ3  return winUtf8ToMbcs(zText, osAreFileApisANSI());¡} ¢/*Ù=** This is a public wrapper for the winUtf8ToMbcs() function.¢*/ÙOSQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi){¾#ifdef SQLITE_ENABLE_API_ARMOR¯  if( !zText ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif¼#ifndef SQLITE_OMIT_AUTOINITÙ&  if( sqlite3_initialize() ) return 0;¦#endifÙ'  return winUtf8ToMbcs(zText, useAnsi);¡} ¢/*ÙL** This function sets the data directory or the temporary directory based onÙK** the provided arguments.  The type argument must be 1 in order to set theÙK** data directory or 2 in order to set the temporary directory.  The zValueÙJ** argument is the name of the directory to use.  The return value will be»** SQLITE_OK if successful.¢*/ÙGSQLITE_API int sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue){¹  char **ppDirectory = 0;¼#ifndef SQLITE_OMIT_AUTOINITÙ   int rc = sqlite3_initialize();µ  if( rc ) return rc;¦#endifÙ/  if( type==SQLITE_WIN32_DATA_DIRECTORY_TYPE ){Ù*    ppDirectory = &sqlite3_data_directory;Ù5  }else if( type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE ){Ù*    ppDirectory = &sqlite3_temp_directory;£  }Ù@  assert( !ppDirectory || type==SQLITE_WIN32_DATA_DIRECTORY_TYPEÙ3          || type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE¤  );ÙO  assert( !ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP) );´  if( ppDirectory ){¹    char *zValueUtf8 = 0;¾    if( zValue && zValue[0] ){Ù,      zValueUtf8 = winUnicodeToUtf8(zValue);»      if ( zValueUtf8==0 ){Ù!        return SQLITE_NOMEM_BKPT;§      }¥    }¿    sqlite3_free(*ppDirectory);¾    *ppDirectory = zValueUtf8;µ    return SQLITE_OK;£  }¶  return SQLITE_ERROR;¡} ¢/*Ù)** The return value of winGetLastErrorMsgÙ?** is zero if the error message fits in the buffer, or non-zeroÙ,** otherwise (if the message was truncated).¢*/ÙEstatic int winGetLastErrorMsg(DWORD lastErrno, int nBuf, char *zBuf){Ù6  /* FormatMessage returns 0 on failure.  Otherwise itÙ7  ** returns the number of TCHARs written to the outputÙ1  ** buffer, excluding the terminating null char.¤  */²  DWORD dwLen = 0;±  char *zOut = 0; ±  if( osIsNT() ){³#if SQLITE_OS_WINRTÙ5    WCHAR zTempWide[SQLITE_WIN32_MAX_ERRMSG_CHARS+1];Ù9    dwLen = osFormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |Ù;                             FORMAT_MESSAGE_IGNORE_INSERTS,Ù"                             NULL,Ù'                             lastErrno,¿                             0,Ù'                             zTempWide,Ù;                             SQLITE_WIN32_MAX_ERRMSG_CHARS,Ù                              0);¥#else¼    LPWSTR zTempWide = NULL;Ù=    dwLen = osFormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |Ù9                             FORMAT_MESSAGE_FROM_SYSTEM |Ù;                             FORMAT_MESSAGE_IGNORE_INSERTS,Ù"                             NULL,Ù'                             lastErrno,¿                             0,Ù1                             (LPWSTR) &zTempWide,¿                             0,Ù                              0);¦#endif´    if( dwLen > 0 ){Ù1      /* allocate a buffer and convert to UTF8 */Ù!      sqlite3BeginBenignMalloc();Ù)      zOut = winUnicodeToUtf8(zTempWide);¿      sqlite3EndBenignMalloc();´#if !SQLITE_OS_WINRTÙ=      /* free the system buffer allocated by FormatMessage */½      osLocalFree(zTempWide);¦#endif¥    }£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{·    char *zTemp = NULL;Ù=    dwLen = osFormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |Ù9                             FORMAT_MESSAGE_FROM_SYSTEM |Ù;                             FORMAT_MESSAGE_IGNORE_INSERTS,Ù"                             NULL,Ù'                             lastErrno,¿                             0,Ù,                             (LPSTR) &zTemp,¿                             0,Ù                              0);´    if( dwLen > 0 ){Ù1      /* allocate a buffer and convert to UTF8 */Ù!      sqlite3BeginBenignMalloc();Ù7      zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());¿      sqlite3EndBenignMalloc();Ù=      /* free the system buffer allocated by FormatMessage */¹      osLocalFree(zTemp);¥    }£  }¦#endif³  if( 0 == dwLen ){ÙN    sqlite3_snprintf(nBuf, zBuf, "OsError 0x%lx (%lu)", lastErrno, lastErrno);¨  }else{Ù7    /* copy a maximum of nBuf chars to output buffer */Ù-    sqlite3_snprintf(nBuf, zBuf, "%s", zOut);¾    /* free the UTF8 buffer */·    sqlite3_free(zOut);£  }«  return 0;¡} ¢/*¢**ÙJ** This function - winLogErrorAtLine() - is only ever called via the macro±** winLogError().¢**ÙC** This routine is invoked after an error occurs in an OS function.ÙH** It logs a message using sqlite3_log() containing the current value ofÙB** error code and, if possible, the human-readable equivalent from±** FormatMessage.¢**ÙG** The first argument passed to the macro should be the error code thatÙJ** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN).ÙJ** The two subsequent arguments should be the name of the OS function thatÙ6** failed and the associated file-system path, if any.¢*/ÙB#define winLogError(a,b,c,d)   winLogErrorAtLine(a,b,c,d,__LINE__)½static int winLogErrorAtLine(Ù9  int errcode,                    /* SQLite error code */Ù8  DWORD lastErrno,                /* Win32 last error */ÙG  const char *zFunc,              /* Name of OS function that failed */ÙG  const char *zPath,              /* File path associated with error */ÙO  int iLine                       /* Source line number where error occurred */¢){ÙA  char zMsg[500];                 /* Human readable error text */Ù4  int i;                          /* Loop counter */ ®  zMsg[0] = 0;Ù4  winGetLastErrorMsg(lastErrno, sizeof(zMsg), zMsg);¿  assert( errcode!=SQLITE_OK );¼  if( zPath==0 ) zPath = "";Ù<  for(i=0; zMsg[i] && zMsg[i]!='\r' && zMsg[i]!='\n'; i++){}®  zMsg[i] = 0;¶  sqlite3_log(errcode,Ù'      "os_win.c:%d: (%lu) %s(%s) - %s",Ù*      iLine, lastErrno, zFunc, zPath, zMsg¤  ); ±  return errcode;¡} ¢/*ÙG** The number of times that a ReadFile(), WriteFile(), and DeleteFile()ÙA** will be retried following a locking error - probably caused byÙF** antivirus software.  Also the initial delay before the first retry.Ù0** The delay increases linearly with each retry.¢*/Ù #ifndef SQLITE_WIN32_IOERR_RETRYÙ$# define SQLITE_WIN32_IOERR_RETRY 10¦#endifÙ&#ifndef SQLITE_WIN32_IOERR_RETRY_DELAYÙ*# define SQLITE_WIN32_IOERR_RETRY_DELAY 25¦#endifÙ4static int winIoerrRetry = SQLITE_WIN32_IOERR_RETRY;Ù?static int winIoerrRetryDelay = SQLITE_WIN32_IOERR_RETRY_DELAY; ¢/*ÙI** The "winIoerrCanRetry1" macro is used to determine if a particular I/OÙH** error code obtained via GetLastError() is eligible to be retried.  ItÙJ** must accept the error code DWORD as its only argument and should returnÙF** non-zero if the error code is transient in nature and the operationÙI** responsible for generating the original error might succeed upon beingÙ=** retried.  The argument to this macro should be a variable.¢**ÙI** Additionally, a macro named "winIoerrCanRetry2" may be defined.  If itÙK** is defined, it will be consulted only when the macro "winIoerrCanRetry1"ÙJ** returns zero.  The "winIoerrCanRetry2" macro is completely optional andÙG** may be used to include additional error codes in the set that shouldÙG** result in the failing I/O operation being retried by the caller.  IfÙI** defined, the "winIoerrCanRetry2" macro must exhibit external semanticsÙ7** identical to those of the "winIoerrCanRetry1" macro.¢*/¿#if !defined(winIoerrCanRetry1)ÙD#define winIoerrCanRetry1(a) (((a)==ERROR_ACCESS_DENIED)        || \ÙD                              ((a)==ERROR_SHARING_VIOLATION)    || \ÙD                              ((a)==ERROR_LOCK_VIOLATION)       || \ÙD                              ((a)==ERROR_DEV_NOT_EXIST)        || \ÙD                              ((a)==ERROR_NETNAME_DELETED)      || \ÙD                              ((a)==ERROR_SEM_TIMEOUT)          || \Ù?                              ((a)==ERROR_NETWORK_UNREACHABLE))¦#endif ¢/*ÙC** If a ReadFile() or WriteFile() error occurs, invoke this routineÙG** to see if it should be retried.  Return TRUE to retry.  Return FALSE¼** to give up with an error.¢*/Ù6static int winRetryIoerr(int *pnRetry, DWORD *pError){½  DWORD e = osGetLastError();Ù   if( *pnRetry>=winIoerrRetry ){±    if( pError ){²      *pError = e;¥    }­    return 0;£  }½  if( winIoerrCanRetry1(e) ){Ù9    sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));¯    ++*pnRetry;­    return 1;£  }¾#if defined(winIoerrCanRetry2)Ù"  else if( winIoerrCanRetry2(e) ){Ù9    sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));¯    ++*pnRetry;­    return 1;£  }¦#endif¯  if( pError ){°    *pError = e;£  }«  return 0;¡} ¢/*Ù!** Log a I/O error retry episode.¢*/Ù0static void winLogIoerr(int nRetry, int lineno){¯  if( nRetry ){¾    sqlite3_log(SQLITE_NOTICE,Ù:      "delayed %dms for lock/sharing conflict at line %d",Ù4      winIoerrRetryDelay*nRetry*(nRetry+1)/2, lineno¦    );£  }¡} ¢/*ÙC** This #if does not rely on the SQLITE_OS_WINCE define because theÙ3** corresponding section in "date.c" cannot use it.¢*/Ù?#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) && \ÙG    (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)¢/*ÙB** The MSVC CRT on Windows CE may not have a localtime() function.º** So define a substitute.¢*/¹/* #  include <time.h> */Ù-struct tm *__cdecl localtime(const time_t *t)¡{µ  static struct tm y;´  FILETIME uTm, lTm;±  SYSTEMTIME pTm;´  sqlite3_int64 t64;«  t64 = *t;Ù%  t64 = (t64 + 11644473600)*10000000;Ù0  uTm.dwLowDateTime = (DWORD)(t64 & 0xFFFFFFFF);Ù)  uTm.dwHighDateTime= (DWORD)(t64 >> 32);Ù'  osFileTimeToLocalFileTime(&uTm,&lTm);Ù$  osFileTimeToSystemTime(&lTm,&pTm);¿  y.tm_year = pTm.wYear - 1900;¼  y.tm_mon = pTm.wMonth - 1;½  y.tm_wday = pTm.wDayOfWeek;·  y.tm_mday = pTm.wDay;¸  y.tm_hour = pTm.wHour;¹  y.tm_min = pTm.wMinute;¹  y.tm_sec = pTm.wSecond;¬  return &y;¡}¦#endif ³#if SQLITE_OS_WINCEÙJ/*************************************************************************Ù-** This section contains code for WinCE only.¢*/ÙM#define HANDLE_TO_WINFILE(a) (winFile*)&((char*)a)[-(int)offsetof(winFile,h)] ¢/*Ù!** Acquire a lock on the handle h¢*/Ù(static void winceMutexAcquire(HANDLE h){¯   DWORD dwErr;§   do {Ù0     dwErr = osWaitForSingleObject(h, INFINITE);Ù?   } while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED);¡}¢/*Ù1** Release a lock acquired by winceMutexAcquire()¢*/Ù,#define winceMutexRelease(h) ReleaseMutex(h) ¢/*ÙB** Create the mutex and shared memory used for locking in the file³** descriptor pFile¢*/ÙBstatic int winceCreateLock(const char *zFilename, winFile *pFile){®  LPWSTR zTok;¯  LPWSTR zName;²  DWORD lastErrno;·  BOOL bLogged = FALSE;´  BOOL bInit = TRUE; Ù&  zName = winUtf8ToUnicode(zFilename);±  if( zName==0 ){·    /* out of memory */Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  } Ù%  /* Initialize the local lockdata */Ù1  memset(&pFile->local, 0, sizeof(pFile->local)); Ù?  /* Replace the backslashes from the filename and lowercase it¿  ** to derive a mutex name. */½  zTok = osCharLowerW(zName);¶  for (;*zTok;zTok++){Ù#    if (*zTok == '\\') *zTok = '_';£  } Ù#  /* Create/open the named mutex */Ù5  pFile->hMutex = osCreateMutexW(NULL, FALSE, zName);¶  if (!pFile->hMutex){Ù(    pFile->lastErrno = osGetLastError();¸    sqlite3_free(zName);Ù6    return winLogError(SQLITE_IOERR, pFile->lastErrno,Ù6                       "winceCreateLock1", zFilename);£  } Ù+  /* Acquire the mutex before continuing */Ù#  winceMutexAcquire(pFile->hMutex); ÙH  /* Since the names of named mutexes, semaphores, file mappings etc areÙI  ** case-sensitive, take advantage of that by uppercasing the mutex nameÙ3  ** and using that as the shared filemapping name.¤  */¶  osCharUpperW(zName);ÙC  pFile->hShared = osCreateFileMappingW(INVALID_HANDLE_VALUE, NULL,ÙM                                        PAGE_READWRITE, 0, sizeof(winceLock),Ù/                                        zName); ÙI  /* Set a flag that indicates we're the first to create the memory so itÙ   ** must be zero-initialized */¿  lastErrno = osGetLastError();Ù)  if (lastErrno == ERROR_ALREADY_EXISTS){²    bInit = FALSE;£  } ¶  sqlite3_free(zName); ÙC  /* If we succeeded in making the shared memory handle, map it. */·  if( pFile->hShared ){Ù?    pFile->shared = (winceLock*)osMapViewOfFile(pFile->hShared,ÙD             FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, sizeof(winceLock));ÙH    /* If mapping failed, close the shared memory handle and erase it */¹    if( !pFile->shared ){Ù*      pFile->lastErrno = osGetLastError();Ù1      winLogError(SQLITE_IOERR, pFile->lastErrno,Ù1                  "winceCreateLock2", zFilename);µ      bLogged = TRUE;Ù$      osCloseHandle(pFile->hShared);¼      pFile->hShared = NULL;¥    }£  } ÙL  /* If shared memory could not be created, then close the mutex and fail */½  if( pFile->hShared==NULL ){³    if( !bLogged ){Ù#      pFile->lastErrno = lastErrno;Ù1      winLogError(SQLITE_IOERR, pFile->lastErrno,Ù1                  "winceCreateLock3", zFilename);µ      bLogged = TRUE;¥    }Ù%    winceMutexRelease(pFile->hMutex);Ù!    osCloseHandle(pFile->hMutex);¹    pFile->hMutex = NULL;¸    return SQLITE_IOERR;£  } Ù9  /* Initialize the shared memory if we're supposed to */®  if( bInit ){Ù0    memset(pFile->shared, 0, sizeof(winceLock));£  } Ù#  winceMutexRelease(pFile->hMutex);³  return SQLITE_OK;¡} ¢/*Ù:** Destroy the part of winFile that deals with wince locks¢*/Ù-static void winceDestroyLock(winFile *pFile){µ  if (pFile->hMutex){»    /* Acquire the mutex */Ù%    winceMutexAcquire(pFile->hMutex); ÙJ    /* The following blocks should probably assert in debug mode, but theyÙ8       are to cleanup in case any locks remained open */¿    if (pFile->local.nReaders){Ù!      pFile->shared->nReaders --;¥    }Ù     if (pFile->local.bReserved){Ù'      pFile->shared->bReserved = FALSE;¥    }¿    if (pFile->local.bPending){Ù&      pFile->shared->bPending = FALSE;¥    }Ù!    if (pFile->local.bExclusive){Ù(      pFile->shared->bExclusive = FALSE;¥    } ÙE    /* De-reference and close our copy of the shared memory handle */Ù%    osUnmapViewOfFile(pFile->shared);Ù"    osCloseHandle(pFile->hShared); ½    /* Done with the mutex */Ù%    winceMutexRelease(pFile->hMutex);Ù!    osCloseHandle(pFile->hMutex);¹    pFile->hMutex = NULL;£  }¡} ¢/*Ù<** An implementation of the LockFile() API of Windows for CE¢*/ºstatic BOOL winceLockFile(²  LPHANDLE phFile,¸  DWORD dwFileOffsetLow,¹  DWORD dwFileOffsetHigh,Ù   DWORD nNumberOfBytesToLockLow,Ù   DWORD nNumberOfBytesToLockHigh¢){Ù-  winFile *pFile = HANDLE_TO_WINFILE(phFile);·  BOOL bReturn = FALSE; Ù%  UNUSED_PARAMETER(dwFileOffsetHigh);Ù-  UNUSED_PARAMETER(nNumberOfBytesToLockHigh); Ù"  if (!pFile->hMutex) return TRUE;Ù#  winceMutexAcquire(pFile->hMutex); Ù"  /* Wanting an exclusive lock? */Ù,  if (dwFileOffsetLow == (DWORD)SHARED_FIRSTÙ9       && nNumberOfBytesToLockLow == (DWORD)SHARED_SIZE){ÙH    if (pFile->shared->nReaders == 0 && pFile->shared->bExclusive == 0){Ù(       pFile->shared->bExclusive = TRUE;Ù&       pFile->local.bExclusive = TRUE;¶       bReturn = TRUE;¥    }£  } ¾  /* Want a read-only lock? */Ù4  else if (dwFileOffsetLow == (DWORD)SHARED_FIRST &&Ù)           nNumberOfBytesToLockLow == 1){Ù(    if (pFile->shared->bExclusive == 0){¿      pFile->local.nReaders ++;Ù&      if (pFile->local.nReaders == 1){Ù#        pFile->shared->nReaders ++;§      }µ      bReturn = TRUE;¥    }£  } ¼  /* Want a pending lock? */Ù1  else if (dwFileOffsetLow == (DWORD)PENDING_BYTEÙ,           && nNumberOfBytesToLockLow == 1){Ù?    /* If no pending lock has been acquired, then acquire it */Ù'    if (pFile->shared->bPending == 0) {Ù%      pFile->shared->bPending = TRUE;Ù#      pFile->local.bPending = TRUE;µ      bReturn = TRUE;¥    }£  } ½  /* Want a reserved lock? */Ù2  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTEÙ,           && nNumberOfBytesToLockLow == 1){Ù(    if (pFile->shared->bReserved == 0) {Ù&      pFile->shared->bReserved = TRUE;Ù$      pFile->local.bReserved = TRUE;µ      bReturn = TRUE;¥    }£  } Ù#  winceMutexRelease(pFile->hMutex);±  return bReturn;¡} ¢/*Ù<** An implementation of the UnlockFile API of Windows for CE¢*/¼static BOOL winceUnlockFile(²  LPHANDLE phFile,¸  DWORD dwFileOffsetLow,¹  DWORD dwFileOffsetHigh,Ù"  DWORD nNumberOfBytesToUnlockLow,Ù"  DWORD nNumberOfBytesToUnlockHigh¢){Ù-  winFile *pFile = HANDLE_TO_WINFILE(phFile);·  BOOL bReturn = FALSE; Ù%  UNUSED_PARAMETER(dwFileOffsetHigh);Ù/  UNUSED_PARAMETER(nNumberOfBytesToUnlockHigh); Ù"  if (!pFile->hMutex) return TRUE;Ù#  winceMutexAcquire(pFile->hMutex); Ù4  /* Releasing a reader lock or an exclusive lock */Ù.  if (dwFileOffsetLow == (DWORD)SHARED_FIRST){Ù(    /* Did we have an exclusive lock? */Ù!    if (pFile->local.bExclusive){Ù>      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE);Ù&      pFile->local.bExclusive = FALSE;Ù(      pFile->shared->bExclusive = FALSE;µ      bReturn = TRUE;¥    } Ù)    /* Did we just have a reader lock? */Ù$    else if (pFile->local.nReaders){Ù<      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZEÙ0             || nNumberOfBytesToUnlockLow == 1);¿      pFile->local.nReaders --;Ù%      if (pFile->local.nReaders == 0)§      {Ù#        pFile->shared->nReaders --;§      }µ      bReturn = TRUE;¥    }£  } Ù   /* Releasing a pending lock */Ù1  else if (dwFileOffsetLow == (DWORD)PENDING_BYTEÙ.           && nNumberOfBytesToUnlockLow == 1){¿    if (pFile->local.bPending){Ù$      pFile->local.bPending = FALSE;Ù&      pFile->shared->bPending = FALSE;µ      bReturn = TRUE;¥    }£  }Ù!  /* Releasing a reserved lock */Ù2  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTEÙ.           && nNumberOfBytesToUnlockLow == 1){Ù!    if (pFile->local.bReserved) {Ù%      pFile->local.bReserved = FALSE;Ù'      pFile->shared->bReserved = FALSE;µ      bReturn = TRUE;¥    }£  } Ù#  winceMutexRelease(pFile->hMutex);±  return bReturn;¡}¢/*Ù$** End of the special code for winceÙN*****************************************************************************/¼#endif /* SQLITE_OS_WINCE */ ¢/*¶** Lock a file region.¢*/¸static BOOL winLockFile(²  LPHANDLE phFile,®  DWORD flags,²  DWORD offsetLow,³  DWORD offsetHigh,´  DWORD numBytesLow,´  DWORD numBytesHigh¢){³#if SQLITE_OS_WINCE¤  /*ÙK  ** NOTE: Windows CE is handled differently here due its lack of the Win32¸  **       API LockFile.¤  */Ù5  return winceLockFile(phFile, offsetLow, offsetHigh,Ù2                       numBytesLow, numBytesHigh);¥#else±  if( osIsNT() ){´    OVERLAPPED ovlp;Ù)    memset(&ovlp, 0, sizeof(OVERLAPPED));¼    ovlp.Offset = offsetLow;Ù!    ovlp.OffsetHigh = offsetHigh;ÙM    return osLockFileEx(*phFile, flags, 0, numBytesLow, numBytesHigh, &ovlp);¨  }else{ÙB    return osLockFile(*phFile, offsetLow, offsetHigh, numBytesLow,Ù$                      numBytesHigh);£  }¦#endif¡} ¢/*¸** Unlock a file region.£ */ºstatic BOOL winUnlockFile(²  LPHANDLE phFile,²  DWORD offsetLow,³  DWORD offsetHigh,´  DWORD numBytesLow,´  DWORD numBytesHigh¢){³#if SQLITE_OS_WINCE¤  /*ÙK  ** NOTE: Windows CE is handled differently here due its lack of the Win32º  **       API UnlockFile.¤  */Ù7  return winceUnlockFile(phFile, offsetLow, offsetHigh,Ù4                         numBytesLow, numBytesHigh);¥#else±  if( osIsNT() ){´    OVERLAPPED ovlp;Ù)    memset(&ovlp, 0, sizeof(OVERLAPPED));¼    ovlp.Offset = offsetLow;Ù!    ovlp.OffsetHigh = offsetHigh;ÙH    return osUnlockFileEx(*phFile, 0, numBytesLow, numBytesHigh, &ovlp);¨  }else{ÙD    return osUnlockFile(*phFile, offsetLow, offsetHigh, numBytesLow,Ù&                        numBytesHigh);£  }¦#endif¡} ÙN/*****************************************************************************ÙA** The next group of routines implement the I/O methods specifiedÙ$** by the sqlite3_io_methods object.ÙO******************************************************************************/ ¢/*Ù1** Some Microsoft compilers lack this definition.¢*/Ù #ifndef INVALID_SET_FILE_POINTERÙ-# define INVALID_SET_FILE_POINTER ((DWORD)-1)¦#endif ¢/*ÙC** Move the current position of the file handle passed as the firstÙG** argument to offset iOffset within the file. If successful, return 0.Ù7** Otherwise, set pFile->lastErrno and return non-zero.¢*/Ù>static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset){´#if !SQLITE_OS_WINRTÙG  LONG upperBits;                 /* Most sig. 32 bits of new offset */ÙH  LONG lowerBits;                 /* Least sig. 32 bits of new offset */ÙJ  DWORD dwRet;                    /* Value returned by SetFilePointer() */ÙH  DWORD lastErrno;                /* Value returned by GetLastError() */ Ù>  OSTRACE(("SEEK file=%p, offset=%lld\n", pFile->h, iOffset)); Ù1  upperBits = (LONG)((iOffset>>32) & 0x7fffffff);Ù+  lowerBits = (LONG)(iOffset & 0xffffffff); Ù@  /* API oddity: If successful, SetFilePointer() returns a dwordÙJ  ** containing the lower 32-bits of the new file-offset. Or, if it fails,ÙD  ** it returns INVALID_SET_FILE_POINTER. However according to MSDN,ÙM  ** INVALID_SET_FILE_POINTER may also be a valid new offset. So to determineÙI  ** whether an error has actually occurred, it is also necessary to call´  ** GetLastError().¤  */ÙH  dwRet = osSetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN); Ù&  if( (dwRet==INVALID_SET_FILE_POINTERÙ7      && ((lastErrno = osGetLastError())!=NO_ERROR)) ){Ù!    pFile->lastErrno = lastErrno;Ù4    winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,Ù-                "winSeekFile", pFile->zPath);Ù@    OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));­    return 1;£  } Ù6  OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));«  return 0;¥#else¤  /*ÙD  ** Same as above, except that this implementation works for WinRT.¤  */ Ù6  LARGE_INTEGER x;                /* The new offset */ÙL  BOOL bRet;                      /* Value returned by SetFilePointerEx() */ ·  x.QuadPart = iOffset;Ù8  bRet = osSetFilePointerEx(pFile->h, x, 0, FILE_BEGIN); ¬  if(!bRet){Ù(    pFile->lastErrno = osGetLastError();Ù4    winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,Ù-                "winSeekFile", pFile->zPath);Ù@    OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));­    return 1;£  } Ù6  OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));«  return 0;¦#endif¡} º#if SQLITE_MAX_MMAP_SIZE>0ÙK/* Forward references to VFS helper methods used for memory mapped files */Ù/static int winMapfile(winFile*, sqlite3_int64);Ù"static int winUnmapfile(winFile*);¦#endif ¢/*°** Close a file.¢**ÙC** It is reported that an attempt to close a handle might sometimesÙF** fail.  This is a very unreasonable result, but Windows is notoriousÙE** for being unreasonable so I do not doubt that it might happen.  IfÙD** the close fails, we pause for 100 milliseconds and try again.  AsÙH** many as MX_CLOSE_ATTEMPT attempts to close the handle are made beforeÙ$** giving up and returning an error.¢*/º#define MX_CLOSE_ATTEMPT 3Ù&static int winClose(sqlite3_file *id){²  int rc, cnt = 0;Ù   winFile *pFile = (winFile*)id; ²  assert( id!=0 );·#ifndef SQLITE_OMIT_WAL»  assert( pFile->pShm==0 );¦#endifÙ=  assert( pFile->h!=NULL && pFile->h!=INVALID_HANDLE_VALUE );Ù0  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p\n",Ù6           osGetCurrentProcessId(), pFile, pFile->h)); º#if SQLITE_MAX_MMAP_SIZE>0¶  winUnmapfile(pFile);¦#endif ¥  do{Ù!    rc = osCloseHandle(pFile->h);Ù9    /* SimulateIOError( rc=0; cnt=MX_CLOSE_ATTEMPT; ); */ÙO  }while( rc==0 && ++cnt < MX_CLOSE_ATTEMPT && (sqlite3_win32_sleep(100), 1) );³#if SQLITE_OS_WINCEÙ!#define WINCE_DELETION_ATTEMPTS 3£  {ÙD    winVfsAppData *pAppData = (winVfsAppData*)pFile->pVfs->pAppData;Ù/    if( pAppData==NULL || !pAppData->bNoLock ){¾      winceDestroyLock(pFile);¥    }£  }¾  if( pFile->zDeleteOnClose ){°    int cnt = 0;ª    while(Ù2           osDeleteFileW(pFile->zDeleteOnClose)==0ÙB        && osGetFileAttributesW(pFile->zDeleteOnClose)!=0xffffffffÙ*        && cnt++ < WINCE_DELETION_ATTEMPTS¦    ){ÙI       sqlite3_win32_sleep(100);  /* Wait a little before trying again */¥    }Ù(    sqlite3_free(pFile->zDeleteOnClose);£  }¦#endif«  if( rc ){´    pFile->h = NULL;£  }²  OpenCounter(-1);Ù7  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p, rc=%s\n",ÙL           osGetCurrentProcessId(), pFile, pFile->h, rc ? "ok" : "failed"));·  return rc ? SQLITE_OKÙ?            : winLogError(SQLITE_IOERR_CLOSE, osGetLastError(),Ù4                          "winClose", pFile->zPath);¡} ¢/*Ù@** Read data from a file into a buffer.  Return SQLITE_OK if allÙA** bytes were read successfully and SQLITE_IOERR if anything goes©** wrong.¢*/³static int winRead(Ù4  sqlite3_file *id,          /* File to read from */ÙA  void *pBuf,                /* Write content into this buffer */Ù:  int amt,                   /* Number of bytes to read */Ù?  sqlite3_int64 offset       /* Begin reading at this offset */¢){Ù<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)Ù@  OVERLAPPED overlapped;          /* The offset for ReadFile. */¦#endifÙ3  winFile *pFile = (winFile*)id;  /* file handle */ÙO  DWORD nRead;                    /* Number of bytes actually read from file */Ù8  int nRetry = 0;                 /* Number of retrys */ ²  assert( id!=0 );²  assert( amt>0 );¶  assert( offset>=0 );Ù,  SimulateIOError(return SQLITE_IOERR_READ);ÙD  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "ÙD           "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,Ù:           pFile->h, pBuf, amt, offset, pFile->locktype)); º#if SQLITE_MAX_MMAP_SIZE>0ÙF  /* Deal with as much of this read request as possible by transferingÙ5  ** data from the memory mapping using memcpy().  */¿  if( offset<pFile->mmapSize ){Ù(    if( offset+amt <= pFile->mmapSize ){Ù>      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);ÙF      OSTRACE(("READ-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ù:               osGetCurrentProcessId(), pFile, pFile->h));·      return SQLITE_OK;ª    }else{Ù2      int nCopy = (int)(pFile->mmapSize - offset);Ù@      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);Ù"      pBuf = &((u8 *)pBuf)[nCopy];³      amt -= nCopy;¶      offset += nCopy;¥    }£  }¦#endif Ù:#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)Ù#  if( winSeekFile(pFile, offset) ){ÙA    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",Ù8             osGetCurrentProcessId(), pFile, pFile->h));·    return SQLITE_FULL;£  }Ù7  while( !osReadFile(pFile->h, pBuf, amt, &nRead, 0) ){¥#elseÙ-  memset(&overlapped, 0, sizeof(OVERLAPPED));Ù2  overlapped.Offset = (LONG)(offset & 0xffffffff);Ù<  overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);ÙA  while( !osReadFile(pFile->h, pBuf, amt, &nRead, &overlapped) &&Ù.         osGetLastError()!=ERROR_HANDLE_EOF ){¦#endif´    DWORD lastErrno;Ù6    if( winRetryIoerr(&nRetry, &lastErrno) ) continue;Ù!    pFile->lastErrno = lastErrno;ÙG    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_READ\n",Ù8             osGetCurrentProcessId(), pFile, pFile->h));Ù;    return winLogError(SQLITE_IOERR_READ, pFile->lastErrno,Ù0                       "winRead", pFile->zPath);£  }Ù   winLogIoerr(nRetry, __LINE__);¹  if( nRead<(DWORD)amt ){Ù8    /* Unread parts of the buffer must be zero-filled */Ù0    memset(&((char*)pBuf)[nRead], 0, amt-nRead);ÙM    OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n",Ù8             osGetCurrentProcessId(), pFile, pFile->h));Ù#    return SQLITE_IOERR_SHORT_READ;£  } Ù=  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ù6           osGetCurrentProcessId(), pFile, pFile->h));³  return SQLITE_OK;¡} ¢/*ÙE** Write data from a buffer into a file.  Return SQLITE_OK on successÙ'** or some other error code on failure.¢*/´static int winWrite(Ù:  sqlite3_file *id,               /* File to write into */Ù?  const void *pBuf,               /* The bytes to be written */Ù@  int amt,                        /* Number of bytes to write */ÙP  sqlite3_int64 offset            /* Offset into the file to begin writing at */¢){ÙN  int rc = 0;                     /* True if error has occurred, else false */Ù3  winFile *pFile = (winFile*)id;  /* File handle */Ù9  int nRetry = 0;                 /* Number of retries */ ²  assert( amt>0 );²  assert( pFile );Ù-  SimulateIOError(return SQLITE_IOERR_WRITE);Ù,  SimulateDiskfullError(return SQLITE_FULL); ÙE  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "ÙD           "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,Ù:           pFile->h, pBuf, amt, offset, pFile->locktype)); Ù<#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0ÙG  /* Deal with as much of this write request as possible by transferingÙ5  ** data from the memory mapping using memcpy().  */¿  if( offset<pFile->mmapSize ){Ù(    if( offset+amt <= pFile->mmapSize ){Ù>      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);ÙG      OSTRACE(("WRITE-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ù:               osGetCurrentProcessId(), pFile, pFile->h));·      return SQLITE_OK;ª    }else{Ù2      int nCopy = (int)(pFile->mmapSize - offset);Ù@      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);Ù"      pBuf = &((u8 *)pBuf)[nCopy];³      amt -= nCopy;¶      offset += nCopy;¥    }£  }¦#endif Ù:#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)Ù"  rc = winSeekFile(pFile, offset);®  if( rc==0 ){¥#else£  {¦#endifÙ<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)ÙA    OVERLAPPED overlapped;        /* The offset for WriteFile. */¦#endifÙ>    u8 *aRem = (u8 *)pBuf;        /* Data yet to be written */ÙI    int nRem = amt;               /* Number of bytes yet to be written */ÙN    DWORD nWrite;                 /* Bytes written by each WriteFile() call */ÙH    DWORD lastErrno = NO_ERROR;   /* Value returned by GetLastError() */ Ù<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)Ù/    memset(&overlapped, 0, sizeof(OVERLAPPED));Ù4    overlapped.Offset = (LONG)(offset & 0xffffffff);Ù>    overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);¦#endif ´    while( nRem>0 ){Ù:#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)Ù;      if( !osWriteFile(pFile->h, aRem, nRem, &nWrite, 0) ){¥#elseÙE      if( !osWriteFile(pFile->h, aRem, nRem, &nWrite, &overlapped) ){¦#endifÙ:        if( winRetryIoerr(&nRetry, &lastErrno) ) continue;®        break;§      }Ù1      assert( nWrite==0 || nWrite<=(DWORD)nRem );Ù,      if( nWrite==0 || nWrite>(DWORD)nRem ){Ù%        lastErrno = osGetLastError();®        break;§      }Ù<#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)·      offset += nWrite;Ù6      overlapped.Offset = (LONG)(offset & 0xffffffff);Ù@      overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);¦#endifµ      aRem += nWrite;µ      nRem -= nWrite;¥    }±    if( nRem>0 ){Ù#      pFile->lastErrno = lastErrno;­      rc = 1;¥    }£  } «  if( rc ){Ù6    if(   ( pFile->lastErrno==ERROR_HANDLE_DISK_FULL )Ù1       || ( pFile->lastErrno==ERROR_DISK_FULL )){ÙD      OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",Ù:               osGetCurrentProcessId(), pFile, pFile->h));Ù7      return winLogError(SQLITE_FULL, pFile->lastErrno,Ù4                         "winWrite1", pFile->zPath);¥    }ÙI    OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_WRITE\n",Ù8             osGetCurrentProcessId(), pFile, pFile->h));Ù<    return winLogError(SQLITE_IOERR_WRITE, pFile->lastErrno,Ù2                       "winWrite2", pFile->zPath);¨  }else{Ù"    winLogIoerr(nRetry, __LINE__);£  }Ù>  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ù6           osGetCurrentProcessId(), pFile, pFile->h));³  return SQLITE_OK;¡} ¢/*Ù,** Truncate an open file to a specified size¢*/Ù>static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){Ù:  winFile *pFile = (winFile*)id;  /* File handle object */ÙE  int rc = SQLITE_OK;             /* Return code for this function */²  DWORD lastErrno; ²  assert( pFile );Ù0  SimulateIOError(return SQLITE_IOERR_TRUNCATE);ÙG  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, size=%lld, lock=%d\n",ÙN           osGetCurrentProcessId(), pFile, pFile->h, nByte, pFile->locktype)); ÙH  /* If the user has configured a chunk-size for this file, truncate theÙF  ** file so that it consists of an integer number of chunks (i.e. theÙJ  ** actual file size after the operation may be larger than the requested«  ** size).¤  */¹  if( pFile->szChunk>0 ){ÙK    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;£  } ÙO  /* SetEndOfFile() returns non-zero when successful, or zero when it fails. */Ù"  if( winSeekFile(pFile, nByte) ){Ù=    rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,Ù3                     "winTruncate1", pFile->zPath);Ù*  }else if( 0==osSetEndOfFile(pFile->h) &&ÙG            ((lastErrno = osGetLastError())!=ERROR_USER_MAPPED_FILE) ){Ù!    pFile->lastErrno = lastErrno;Ù=    rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,Ù3                     "winTruncate2", pFile->zPath);£  } º#if SQLITE_MAX_MMAP_SIZE>0ÙC  /* If the file was truncated to a size smaller than the currentlyÙJ  ** mapped region, reduce the effective mapping size as well. SQLite willÙI  ** use read() and write() to access data beyond this point from now on.¤  */Ù3  if( pFile->pMapRegion && nByte<pFile->mmapSize ){¼    pFile->mmapSize = nByte;£  }¦#endif Ù:  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, rc=%s\n",ÙJ           osGetCurrentProcessId(), pFile, pFile->h, sqlite3ErrName(rc)));¬  return rc;¡} ²#ifdef SQLITE_TEST¢/*ÙH** Count the number of fullsyncs and normal syncs.  This is used to testÙ<** that syncs and fullsyncs are occuring at the right times.¢*/Ù&SQLITE_API int sqlite3_sync_count = 0;Ù*SQLITE_API int sqlite3_fullsync_count = 0;¦#endif ¢/*ÙC** Make sure all writes to a particular file are committed to disk.¢*/Ù0static int winSync(sqlite3_file *id, int flags){¶#ifndef SQLITE_NO_SYNC¤  /*Ù2  ** Used only when SQLITE_NO_SYNC is not defined.¥   */ª  BOOL rc;¦#endifÙ5#if !defined(NDEBUG) || !defined(SQLITE_NO_SYNC) || \Ù!    defined(SQLITE_HAVE_OS_TRACE)¤  /*ÙG  ** Used when SQLITE_NO_SYNC is not defined and by the assert() and/or¶  ** OSTRACE() macros.¥   */Ù   winFile *pFile = (winFile*)id;¥#else·  UNUSED_PARAMETER(id);¦#endif ²  assert( pFile );Ù?  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */Ù)  assert((flags&0x0F)==SQLITE_SYNC_NORMALÙ'      || (flags&0x0F)==SQLITE_SYNC_FULL¤  ); ÙI  /* Unix cannot, but some systems may return SQLITE_FULL from here. ThisÙ?  ** line is to test that doing so does not cause any problems.¤  */Ù.  SimulateDiskfullError( return SQLITE_FULL ); ÙB  OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, flags=%x, lock=%d\n",Ù;           osGetCurrentProcessId(), pFile, pFile->h, flags,½           pFile->locktype)); ³#ifndef SQLITE_TESTº  UNUSED_PARAMETER(flags);¥#elseÙ'  if( (flags&0x0F)==SQLITE_SYNC_FULL ){½    sqlite3_fullsync_count++;£  }·  sqlite3_sync_count++;¦#endif ÙC  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is aª  ** no-op¤  */µ#ifdef SQLITE_NO_SYNCÙA  OSTRACE(("SYNC-NOP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ù6           osGetCurrentProcessId(), pFile, pFile->h));³  return SQLITE_OK;¥#elseº#if SQLITE_MAX_MMAP_SIZE>0º  if( pFile->pMapRegion ){Ù2    if( osFlushViewOfFile(pFile->pMapRegion, 0) ){Ù=      OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "Ù9               "rc=SQLITE_OK\n", osGetCurrentProcessId(),Ù*               pFile, pFile->pMapRegion));ª    }else{Ù*      pFile->lastErrno = osGetLastError();Ù=      OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "ÙA               "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(),Ù*               pFile, pFile->pMapRegion));Ù=      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,Ù3                         "winSync1", pFile->zPath);¥    }£  }¦#endifÙ$  rc = osFlushFileBuffers(pFile->h);¾  SimulateIOError( rc=FALSE );«  if( rc ){Ù?    OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",Ù8             osGetCurrentProcessId(), pFile, pFile->h));µ    return SQLITE_OK;¨  }else{Ù(    pFile->lastErrno = osGetLastError();ÙH    OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_FSYNC\n",Ù8             osGetCurrentProcessId(), pFile, pFile->h));Ù<    return winLogError(SQLITE_IOERR_FSYNC, pFile->lastErrno,Ù1                       "winSync2", pFile->zPath);£  }¦#endif¡} ¢/*Ù0** Determine the current size of a file in bytes¢*/Ù?static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){Ù   winFile *pFile = (winFile*)id;µ  int rc = SQLITE_OK; ²  assert( id!=0 );µ  assert( pSize!=0 );Ù-  SimulateIOError(return SQLITE_IOERR_FSTAT);Ù9  OSTRACE(("SIZE file=%p, pSize=%p\n", pFile->h, pSize)); ³#if SQLITE_OS_WINRT£  {¼    FILE_STANDARD_INFO info;ÙB    if( osGetFileInformationByHandleEx(pFile->h, FileStandardInfo,Ù<                                     &info, sizeof(info)) ){Ù'      *pSize = info.EndOfFile.QuadPart;ª    }else{Ù*      pFile->lastErrno = osGetLastError();Ù<      rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,Ù4                       "winFileSize", pFile->zPath);¥    }£  }¥#else£  {´    DWORD upperBits;´    DWORD lowerBits;´    DWORD lastErrno; Ù4    lowerBits = osGetFileSize(pFile->h, &upperBits);Ù:    *pSize = (((sqlite3_int64)upperBits)<<32) + lowerBits;Ù*    if(   (lowerBits == INVALID_FILE_SIZE)Ù7       && ((lastErrno = osGetLastError())!=NO_ERROR) ){Ù#      pFile->lastErrno = lastErrno;Ù<      rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,Ù4                       "winFileSize", pFile->zPath);¥    }£  }¦#endifÙ:  OSTRACE(("SIZE file=%p, pSize=%p, *pSize=%lld, rc=%s\n",Ù9           pFile->h, pSize, *pSize, sqlite3ErrName(rc)));¬  return rc;¡} ¢/*ÙB** LOCKFILE_FAIL_IMMEDIATELY is undefined on some Windows systems.¢*/Ù!#ifndef LOCKFILE_FAIL_IMMEDIATELYÙ$# define LOCKFILE_FAIL_IMMEDIATELY 1¦#endif ¿#ifndef LOCKFILE_EXCLUSIVE_LOCKÙ"# define LOCKFILE_EXCLUSIVE_LOCK 2¦#endif ¢/*ÙL** Historically, SQLite has used both the LockFile and LockFileEx functions.ÙF** When the LockFile function was used, it was always expected to failÙN** immediately if the lock could not be obtained.  Also, it always expected toÙO** obtain an exclusive lock.  These flags are used with the LockFileEx functionÙI** and reflect those expectations; therefore, they should not be changed.¢*/½#ifndef SQLITE_LOCKFILE_FLAGSÙ?# define SQLITE_LOCKFILE_FLAGS   (LOCKFILE_FAIL_IMMEDIATELY | \Ù:                                  LOCKFILE_EXCLUSIVE_LOCK)¦#endif ¢/*ÙL** Currently, SQLite never calls the LockFileEx function without wanting theÙ;** call to fail immediately if the lock cannot be obtained.¢*/¿#ifndef SQLITE_LOCKFILEEX_FLAGSÙ<# define SQLITE_LOCKFILEEX_FLAGS (LOCKFILE_FAIL_IMMEDIATELY)¦#endif ¢/*¹** Acquire a reader lock.ÙE** Different API routines are called depending on whether or not thisµ** is Win9x or WinNT.¢*/Ù*static int winGetReadLock(winFile *pFile){ª  int res;ÙG  OSTRACE(("READ-LOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));±  if( osIsNT() ){³#if SQLITE_OS_WINCE¦    /*ÙM    ** NOTE: Windows CE is handled differently here due its lack of the Win32¼    **       API LockFileEx.¦    */Ù:    res = winceLockFile(&pFile->h, SHARED_FIRST, 0, 1, 0);¥#elseÙJ    res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS, SHARED_FIRST, 0,Ù&                      SHARED_SIZE, 0);¦#endif£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{«    int lk;Ù(    sqlite3_randomness(sizeof(lk), &lk);ÙI    pFile->sharedLockByte = (short)((lk & 0x7fffffff)%(SHARED_SIZE - 1));Ù7    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,ÙC                      SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);£  }¦#endif±  if( res == 0 ){Ù(    pFile->lastErrno = osGetLastError();Ù*    /* No need to log a failure to lock */£  }Ù=  OSTRACE(("READ-LOCK file=%p, result=%d\n", pFile->h, res));­  return res;¡} ¢/*²** Undo a readlock¢*/Ù-static int winUnlockReadLock(winFile *pFile){ª  int res;²  DWORD lastErrno;ÙI  OSTRACE(("READ-UNLOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));±  if( osIsNT() ){ÙD    res = winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{ÙP    res = winUnlockFile(&pFile->h, SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);£  }¦#endifÙE  if( res==0 && ((lastErrno = osGetLastError())!=ERROR_NOT_LOCKED) ){Ù!    pFile->lastErrno = lastErrno;Ù6    winLogError(SQLITE_IOERR_UNLOCK, pFile->lastErrno,Ù3                "winUnlockReadLock", pFile->zPath);£  }Ù?  OSTRACE(("READ-UNLOCK file=%p, result=%d\n", pFile->h, res));­  return res;¡} ¢/*ÙD** Lock the file with the lock specified by parameter locktype - one´** of the following:¢**¶**     (1) SHARED_LOCK¸**     (2) RESERVED_LOCK·**     (3) PENDING_LOCK¹**     (4) EXCLUSIVE_LOCK¢**ÙC** Sometimes when requesting one lock state, additional lock statesÙG** are inserted in between.  The locking might fail on one of the laterÙH** transitions leaving the lock state different from what it started butÙB** still short of its goal.  The following chart shows the allowedÙ4** transitions and the inserted intermediate states:¢**¸**    UNLOCKED -> SHARED¸**    SHARED -> RESERVEDÙ&**    SHARED -> (PENDING) -> EXCLUSIVEÙ(**    RESERVED -> (PENDING) -> EXCLUSIVEº**    PENDING -> EXCLUSIVE¢**ÙC** This routine will only increase a lock.  The winUnlock() routineÙJ** erases all locks at once and returns us immediately to locking level 0.ÙI** It is not possible to lower the locking level one step at a time.  YouÙ'** must go straight to locking level 0.¢*/Ù3static int winLock(sqlite3_file *id, int locktype){Ù;  int rc = SQLITE_OK;    /* Return code from subroutines */Ù<  int res = 1;           /* Result of a Windows lock call */ÙO  int newLocktype;       /* Set pFile->locktype to this value before exiting */ÙK  int gotPendingLock = 0;/* True if we acquired a PENDING lock this time */Ù   winFile *pFile = (winFile*)id;½  DWORD lastErrno = NO_ERROR; ²  assert( id!=0 );Ù8  OSTRACE(("LOCK file=%p, oldLock=%d(%d), newLock=%d\n",ÙH           pFile->h, pFile->locktype, pFile->sharedLockByte, locktype)); ÙG  /* If there is already a lock of this type or more restrictive on theÙ>  ** OsFile, do nothing. Don't use the end_lock: exit path, asÙ2  ** sqlite3OsEnterMutex() hasn't been called yet.¤  */Ù"  if( pFile->locktype>=locktype ){Ù=    OSTRACE(("LOCK-HELD file=%p, rc=SQLITE_OK\n", pFile->h));µ    return SQLITE_OK;£  } Ù@  /* Do not allow any kind of write-lock on a read-only database¤  */ÙJ  if( (pFile->ctrlFlags & WINFILE_RDONLY)!=0 && locktype>=RESERVED_LOCK ){½    return SQLITE_IOERR_LOCK;£  } Ù.  /* Make sure the locking sequence is correct¤  */Ù>  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );Ù#  assert( locktype!=PENDING_LOCK );ÙD  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK ); ÙG  /* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock orÙJ  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition ofÙ(  ** the PENDING_LOCK byte is temporary.¤  */Ù   newLocktype = pFile->locktype;¾  if( pFile->locktype==NO_LOCKÙB   || (locktype==EXCLUSIVE_LOCK && pFile->locktype<=RESERVED_LOCK)¤  ){°    int cnt = 3;ÙJ    while( cnt-->0 && (res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,ÙF                                         PENDING_BYTE, 0, 1, 0))==0 ){ÙE      /* Try 3 times to get the pending lock.  This is needed to workÙI      ** around problems caused by indexing and/or anti-virus software on¹      ** Windows systems.ÙL      ** If you are using this code as a model for alternative VFSes, do notÙH      ** copy this retry logic.  It is a hack intended for Windows only.¨      */Ù#      lastErrno = osGetLastError();ÙB      OSTRACE(("LOCK-PENDING-FAIL file=%p, count=%d, result=%d\n",Ù$               pFile->h, cnt, res));Ù,      if( lastErrno==ERROR_INVALID_HANDLE ){Ù%        pFile->lastErrno = lastErrno;¿        rc = SQLITE_IOERR_LOCK;Ù8        OSTRACE(("LOCK-FAIL file=%p, count=%d, rc=%s\n",Ù5                 pFile->h, cnt, sqlite3ErrName(rc)));²        return rc;§      }Ù'      if( cnt ) sqlite3_win32_sleep(1);¥    }¹    gotPendingLock = res;¯    if( !res ){Ù#      lastErrno = osGetLastError();¥    }£  } º  /* Acquire a shared lock¤  */Ù%  if( locktype==SHARED_LOCK && res ){Ù'    assert( pFile->locktype==NO_LOCK );Ù     res = winGetReadLock(pFile);®    if( res ){Ù       newLocktype = SHARED_LOCK;ª    }else{Ù#      lastErrno = osGetLastError();¥    }£  } ¼  /* Acquire a RESERVED lock¤  */Ù'  if( locktype==RESERVED_LOCK && res ){Ù+    assert( pFile->locktype==SHARED_LOCK );ÙP    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, RESERVED_BYTE, 0, 1, 0);®    if( res ){Ù"      newLocktype = RESERVED_LOCK;ª    }else{Ù#      lastErrno = osGetLastError();¥    }£  } »  /* Acquire a PENDING lock¤  */Ù(  if( locktype==EXCLUSIVE_LOCK && res ){¿    newLocktype = PENDING_LOCK;·    gotPendingLock = 0;£  } ¾  /* Acquire an EXCLUSIVE lock¤  */Ù(  if( locktype==EXCLUSIVE_LOCK && res ){Ù+    assert( pFile->locktype>=SHARED_LOCK );Ù#    res = winUnlockReadLock(pFile);ÙH    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, SHARED_FIRST, 0,Ù&                      SHARED_SIZE, 0);®    if( res ){Ù#      newLocktype = EXCLUSIVE_LOCK;ª    }else{Ù#      lastErrno = osGetLastError();¼      winGetReadLock(pFile);¥    }£  } ÙE  /* If we are holding a PENDING lock that ought to be released, then´  ** release it now.¤  */Ù0  if( gotPendingLock && locktype==SHARED_LOCK ){Ù4    winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);£  } ÙF  /* Update the state of the lock has held in the file descriptor thenÙ(  ** return the appropriate result code.¤  */¬  if( res ){³    rc = SQLITE_OK;¨  }else{Ù!    pFile->lastErrno = lastErrno;µ    rc = SQLITE_BUSY;Ù6    OSTRACE(("LOCK-FAIL file=%p, wanted=%d, got=%d\n",Ù/             pFile->h, locktype, newLocktype));£  }Ù$  pFile->locktype = (u8)newLocktype;Ù,  OSTRACE(("LOCK file=%p, lock=%d, rc=%s\n",Ù;           pFile->h, pFile->locktype, sqlite3ErrName(rc)));¬  return rc;¡} ¢/*ÙH** This routine checks if there is a RESERVED lock held on the specifiedÙD** file by this or any other process. If such a lock is held, return¼** non-zero, otherwise zero.¢*/Ù@static int winCheckReservedLock(sqlite3_file *id, int *pResOut){ª  int res;Ù   winFile *pFile = (winFile*)id; Ù<  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );ÙE  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p\n", pFile->h, pResOut)); ²  assert( id!=0 );Ù'  if( pFile->locktype>=RESERVED_LOCK ){¬    res = 1;ÙJ    OSTRACE(("TEST-WR-LOCK file=%p, result=%d (local)\n", pFile->h, res));¨  }else{ÙN    res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS,RESERVED_BYTE,0,1,0);®    if( res ){Ù7      winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);¥    }¯    res = !res;ÙK    OSTRACE(("TEST-WR-LOCK file=%p, result=%d (remote)\n", pFile->h, res));£  }±  *pResOut = res;ÙK  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",Ù)           pFile->h, pResOut, *pResOut));³  return SQLITE_OK;¡} ¢/*ÙG** Lower the locking level on file descriptor id to locktype.  locktypeÙ)** must be either NO_LOCK or SHARED_LOCK.¢**ÙE** If the locking level of the file descriptor is already at or belowÙ8** the requested locking level, this routine is a no-op.¢**ÙE** It is not possible for this routine to fail if the second argumentÙG** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine½** might return SQLITE_IOERR;¢*/Ù5static int winUnlock(sqlite3_file *id, int locktype){«  int type;Ù   winFile *pFile = (winFile*)id;µ  int rc = SQLITE_OK;µ  assert( pFile!=0 );Ù"  assert( locktype<=SHARED_LOCK );Ù:  OSTRACE(("UNLOCK file=%p, oldLock=%d(%d), newLock=%d\n",ÙH           pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));¹  type = pFile->locktype;½  if( type>=EXCLUSIVE_LOCK ){Ù>    winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);Ù:    if( locktype==SHARED_LOCK && !winGetReadLock(pFile) ){Ù?      /* This should never happen.  We should always be able toÙ#      ** reacquire the read lock */Ù=      rc = winLogError(SQLITE_IOERR_UNLOCK, osGetLastError(),Ù2                       "winUnlock", pFile->zPath);¥    }£  }¼  if( type>=RESERVED_LOCK ){Ù5    winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);£  }Ù/  if( locktype==NO_LOCK && type>=SHARED_LOCK ){½    winUnlockReadLock(pFile);£  }»  if( type>=PENDING_LOCK ){Ù4    winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);£  }Ù!  pFile->locktype = (u8)locktype;Ù.  OSTRACE(("UNLOCK file=%p, lock=%d, rc=%s\n",Ù;           pFile->h, pFile->locktype, sqlite3ErrName(rc)));¬  return rc;¡} ÙO/******************************************************************************ÙO****************************** No-op Locking **********************************¢**ÙG** Of the various locking implementations available, this is by far theÙJ** simplest:  locking is ignored.  No attempt is made to lock the database¿** file for reading or writing.¢**ÙB** This locking mode is appropriate for use on read-only databasesÙD** (ex: databases that are burned into CD-ROM, for example.)  It canÙE** also be used if the application employs some external mechanism toÙB** prevent simultaneous access of the same database by two or moreÙA** database connections.  But there is a serious risk of databaseÙG** corruption if this locking mode is used in situations where multipleÙH** database connections are accessing the same database file at the sameÙ9** time and one or more of those connections are writing.¢*/ Ù9static int winNolockLock(sqlite3_file *id, int locktype){·  UNUSED_PARAMETER(id);½  UNUSED_PARAMETER(locktype);³  return SQLITE_OK;¡} ÙFstatic int winNolockCheckReservedLock(sqlite3_file *id, int *pResOut){·  UNUSED_PARAMETER(id);¼  UNUSED_PARAMETER(pResOut);³  return SQLITE_OK;¡} Ù;static int winNolockUnlock(sqlite3_file *id, int locktype){·  UNUSED_PARAMETER(id);½  UNUSED_PARAMETER(locktype);³  return SQLITE_OK;¡} ÙO/******************* End of the no-op lock implementation *********************ÙO******************************************************************************/ ¢/*ÙE** If *pArg is initially negative then this is a query.  Set *pArg toÙJ** 1 or 0 depending on whether or not bit mask of pFile->ctrlFlags is set.¢**ÙJ** If *pArg is 0 or 1, then clear or set the mask bit of pFile->ctrlFlags.¢*/ÙFstatic void winModeBit(winFile *pFile, unsigned char mask, int *pArg){°  if( *pArg<0 ){Ù)    *pArg = (pFile->ctrlFlags & mask)!=0;¹  }else if( (*pArg)==0 ){¾    pFile->ctrlFlags &= ~mask;¨  }else{½    pFile->ctrlFlags |= mask;£  }¡} ÙG/* Forward references to VFS helper methods used for temporary files */Ù2static int winGetTempname(sqlite3_vfs *, char **);Ù"static int winIsDir(const void *);Ù3static BOOL winIsDriveLetterAndColon(const char *); ¢/*Ù-** Control and query of the open file handle.¢*/Ù@static int winFileControl(sqlite3_file *id, int op, void *pArg){Ù   winFile *pFile = (winFile*)id;ÙC  OSTRACE(("FCNTL file=%p, op=%d, pArg=%p\n", pFile->h, op, pArg));¯  switch( op ){Ù"    case SQLITE_FCNTL_LOCKSTATE: {Ù$      *(int*)pArg = pFile->locktype;Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù#    case SQLITE_FCNTL_LAST_ERRNO: {Ù*      *(int*)pArg = (int)pFile->lastErrno;Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù#    case SQLITE_FCNTL_CHUNK_SIZE: {Ù$      pFile->szChunk = *(int *)pArg;Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù"    case SQLITE_FCNTL_SIZE_HINT: {½      if( pFile->szChunk>0 ){¼        sqlite3_int64 oldSz;Ù)        int rc = winFileSize(id, &oldSz);¼        if( rc==SQLITE_OK ){Ù6          sqlite3_int64 newSz = *(sqlite3_int64*)pArg;¼          if( newSz>oldSz ){Ù%            SimulateIOErrorBenign(1);Ù(            rc = winTruncate(id, newSz);Ù%            SimulateIOErrorBenign(0);«          }©        }ÙJ        OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));²        return rc;§      }Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù$    case SQLITE_FCNTL_PERSIST_WAL: {Ù9      winModeBit(pFile, WINFILE_PERSIST_WAL, (int*)pArg);Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù,    case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {Ù2      winModeBit(pFile, WINFILE_PSOW, (int*)pArg);Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù     case SQLITE_FCNTL_VFSNAME: {Ù@      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù'    case SQLITE_FCNTL_WIN32_AV_RETRY: {º      int *a = (int*)pArg;³      if( a[0]>0 ){½        winIoerrRetry = a[0];¬      }else{½        a[0] = winIoerrRetry;§      }³      if( a[1]>0 ){Ù"        winIoerrRetryDelay = a[1];¬      }else{Ù"        a[1] = winIoerrRetryDelay;§      }Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }Ù)    case SQLITE_FCNTL_WIN32_GET_HANDLE: {Ù'      LPHANDLE phFile = (LPHANDLE)pArg;¹      *phFile = pFile->h;Ù;      OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));·      return SQLITE_OK;¥    }²#ifdef SQLITE_TESTÙ)    case SQLITE_FCNTL_WIN32_SET_HANDLE: {Ù'      LPHANDLE phFile = (LPHANDLE)pArg;Ù!      HANDLE hOldFile = pFile->h;¹      pFile->h = *phFile;¹      *phFile = hOldFile;Ù>      OSTRACE(("FCNTL oldFile=%p, newFile=%p, rc=SQLITE_OK\n",Ù$               hOldFile, pFile->h));·      return SQLITE_OK;¥    }¦#endifÙ%    case SQLITE_FCNTL_TEMPFILENAME: {·      char *zTFile = 0;Ù4      int rc = winGetTempname(pFile->pVfs, &zTFile);º      if( rc==SQLITE_OK ){¿        *(char**)pArg = zTFile;§      }ÙH      OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));°      return rc;¥    }º#if SQLITE_MAX_MMAP_SIZE>0Ù"    case SQLITE_FCNTL_MMAP_SIZE: {Ù!      i64 newLimit = *(i64*)pArg;¹      int rc = SQLITE_OK;Ù0      if( newLimit>sqlite3GlobalConfig.mxMmap ){Ù.        newLimit = sqlite3GlobalConfig.mxMmap;§      } ÙL      /* The value of newLimit may be eventually cast to (SIZE_T) and passedÙL      ** to MapViewOfFile(). Restrict its value to 2GB if (SIZE_T) is not atÙ       ** least a 64-bit type. */Ù+      if( newLimit>0 && sizeof(SIZE_T)<8 ){Ù+        newLimit = (newLimit & 0x7FFFFFFF);§      } Ù'      *(i64*)pArg = pFile->mmapSizeMax;ÙO      if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){Ù&        pFile->mmapSizeMax = newLimit;Ù         if( pFile->mmapSize>0 ){¾          winUnmapfile(pFile);Ù%          rc = winMapfile(pFile, -1);©        }§      }ÙH      OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));°      return rc;¥    }¦#endif£  }Ù=  OSTRACE(("FCNTL file=%p, rc=SQLITE_NOTFOUND\n", pFile->h));¹  return SQLITE_NOTFOUND;¡} ¢/*ÙE** Return the sector size in bytes of the underlying block device forÙB** the specified file. This is almost always 512 bytes, but may be»** larger for some devices.¢**ÙF** SQLite code assumes this function cannot fail. It also assumes thatÙC** if two files are created in the same file-system directory (i.e.ÙD** a database and its journal file) that the sector size will be the±** same for both.¢*/Ù+static int winSectorSize(sqlite3_file *id){«  (void)id;Ù$  return SQLITE_DEFAULT_SECTOR_SIZE;¡} ¢/*Ù-** Return a vector of device characteristics.¢*/Ù6static int winDeviceCharacteristics(sqlite3_file *id){¼  winFile *p = (winFile*)id;Ù-  return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN |ÙL         ((p->ctrlFlags & WINFILE_PSOW)?SQLITE_IOCAP_POWERSAFE_OVERWRITE:0);¡} ¢/*Ù6** Windows will only let you create file view mappingsÙ-** on allocation size granularity boundaries.Ù3** During sqlite3_os_init() we do a GetSystemInfo()¿** to get the granularity size.¢*/¾static SYSTEM_INFO winSysInfo; ·#ifndef SQLITE_OMIT_WAL ¢/*ÙB** Helper functions to obtain and relinquish the global mutex. TheÙB** global mutex is used to protect the winLockInfo objects used byÙ=** this file, all of which may be shared by multiple threads.¢**ÙG** Function winShmMutexHeld() is used to assert() that the global mutexÙH** is held when required. This function is only used as part of assert()³** statements. e.g.¢**·**   winShmEnterMutex()Ù#**     assert( winShmMutexHeld() );·**   winShmLeaveMutex()¢*/Ù%static sqlite3_mutex *winBigLock = 0;Ù#static void winShmEnterMutex(void){Ù"  sqlite3_mutex_enter(winBigLock);¡}Ù#static void winShmLeaveMutex(void){Ù"  sqlite3_mutex_leave(winBigLock);¡}®#ifndef NDEBUGÙ"static int winShmMutexHeld(void) {Ù(  return sqlite3_mutex_held(winBigLock);¡}¦#endif ¢/*ÙG** Object used to represent a single file opened and mmapped to provideÙ?** shared memory.  When multiple threads all reference the sameÙD** log-summary, each thread has its own winFile object, but they allÙC** point to a single instance of this object.  In other words, eachÙ/** log-summary is opened only once per process.¢**Ù=** winShmMutexHeld() must be true when creating or destroyingÙ@** this object or while reading or writing the following fields:¢**¬**      nRef­**      pNext¢**ÙB** The following fields are read-only after the object is created:¢**«**      fid±**      zFilename¢**ÙA** Either winShmNode.mutex must be held or winShmNode.nRef==0 andÙD** winShmMutexHeld() is true when reading or writing any other fieldµ** in this structure.¢**¢*/³struct winShmNode {Ù>  sqlite3_mutex *mutex;      /* Mutex to access this object */Ù3  char *zFilename;           /* Name of the file */Ù;  winFile hFile;             /* File handle from winOpen */ Ù@  int szRegion;              /* Size of shared-memory regions */Ù9  int nRegion;               /* Size of array apRegion */Ù4  u8 isReadonly;             /* True if read-only */Ù;  u8 isUnlocked;             /* True if no DMS lock held */ ´  struct ShmRegion {ÙE    HANDLE hMap;             /* File handle from CreateFileMapping */¯    void *pMap;­  } *aRegion;ÙL  DWORD lastErrno;           /* The Windows errno from the last I/O error */ ÙL  int nRef;                  /* Number of winShm objects pointing to this */ÙF  winShm *pFirst;            /* All winShm objects pointing to this */ÙI  winShmNode *pNext;         /* Next in list of all winShmNode objects */Ù:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)ÙA  u8 nextShmId;              /* Next available winShm.id value */¦#endif¢}; ¢/*Ù,** A global array of all winShmNode objects.¢**ÙI** The winShmMutexHeld() must be true while reading or writing this list.¢*/Ù&static winShmNode *winShmNodeList = 0; ¢/*ÙB** Structure used internally by this VFS to record the state of anÙ!** open shared memory connection.¢**ÙG** The following fields are initialized when this object is created and¼** are read-only thereafter:¢**µ**    winShm.pShmNode¯**    winShm.id¢**ÙL** All other fields are read/write.  The winShm.pShmNode->mutex must be heldÙ)** while accessing any read/write fields.¢*/¯struct winShm {ÙC  winShmNode *pShmNode;      /* The underlying winShmNode object */ÙG  winShm *pNext;             /* Next winShm with the same winShmNode */ÙG  u8 hasMutex;               /* True if holding the winShmNode mutex */Ù<  u16 sharedMask;            /* Mask of shared locks held */Ù?  u16 exclMask;              /* Mask of exclusive locks held */Ù:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)ÙL  u8 id;                     /* Id of this connection with its winShmNode */¦#endif¢}; ¢/*½** Constants used for locking¢*/ÙM#define WIN_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)        /* first lock byte */ÙL#define WIN_SHM_DMS    (WIN_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */ ¢/*Ù:** Apply advisory locks for all n bytes beginning at ofst.¢*/·#define WINSHM_UNLCK  1·#define WINSHM_RDLCK  2·#define WINSHM_WRLCK  3¼static int winShmSystemLock(ÙL  winShmNode *pFile,    /* Apply locks to this open shared-memory segment */ÙI  int lockType,         /* WINSHM_UNLCK, WINSHM_RDLCK, or WINSHM_WRLCK */ÙH  int ofst,             /* Offset to first byte to be locked/unlocked */Ù?  int nByte             /* Number of bytes to lock or unlock */¢){ÙB  int rc = 0;           /* Result code form Lock/UnlockFileEx() */ ÙC  /* Access to the winShmNode object is serialized by the caller */Ù?  assert( pFile->nRef==0 || sqlite3_mutex_held(pFile->mutex) ); Ù=  OSTRACE(("SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\n",Ù3           pFile->hFile.h, lockType, ofst, nByte)); Ù-  /* Release/Acquire the system-level lock */¿  if( lockType==WINSHM_UNLCK ){Ù;    rc = winUnlockFile(&pFile->hFile.h, ofst, 0, nByte, 0);¨  }else{Ù+    /* Initialize the locking parameters */Ù.    DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;ÙF    if( lockType == WINSHM_WRLCK ) dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;ÙB    rc = winLockFile(&pFile->hFile.h, dwFlags, ofst, 0, nByte, 0);£  } ¯  if( rc!= 0 ){³    rc = SQLITE_OK;¨  }else{Ù)    pFile->lastErrno =  osGetLastError();µ    rc = SQLITE_BUSY;£  } Ù;  OSTRACE(("SHM-LOCK file=%p, func=%s, errno=%lu, rc=%s\n",ÙI           pFile->hFile.h, (lockType == WINSHM_UNLCK) ? "winUnlockFile" :ÙA           "winLockFile", pFile->lastErrno, sqlite3ErrName(rc))); ¬  return rc;¡} Ù'/* Forward references to VFS methods */ÙDstatic int winOpen(sqlite3_vfs*,const char*,sqlite3_file*,int,int*);Ù4static int winDelete(sqlite3_vfs *,const char*,int); ¢/*ÙH** Purge the winShmNodeList list of all entries with winShmNode.nRef==0.¢**ÙJ** This is not a VFS shared-memory method; it is a utility function calledÙ ** by VFS shared-memory methods.¢*/Ù;static void winShmPurge(sqlite3_vfs *pVfs, int deleteFlag){²  winShmNode **pp;°  winShmNode *p;¾  assert( winShmMutexHeld() );Ù0  OSTRACE(("SHM-PURGE pid=%lu, deleteFlag=%d\n",Ù1           osGetCurrentProcessId(), deleteFlag));·  pp = &winShmNodeList;¸  while( (p = *pp)!=0 ){µ    if( p->nRef==0 ){¬      int i;Ù5      if( p->mutex ){ sqlite3_mutex_free(p->mutex); }Ù"      for(i=0; i<p->nRegion; i++){Ù9        BOOL bRc = osUnmapViewOfFile(p->aRegion[i].pMap);Ù?        OSTRACE(("SHM-PURGE-UNMAP pid=%lu, region=%d, rc=%s\n",ÙE                 osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));Ù#        UNUSED_VARIABLE_VALUE(bRc);Ù0        bRc = osCloseHandle(p->aRegion[i].hMap);Ù?        OSTRACE(("SHM-PURGE-CLOSE pid=%lu, region=%d, rc=%s\n",ÙE                 osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));Ù#        UNUSED_VARIABLE_VALUE(bRc);§      }ÙA      if( p->hFile.h!=NULL && p->hFile.h!=INVALID_HANDLE_VALUE ){Ù!        SimulateIOErrorBenign(1);Ù,        winClose((sqlite3_file *)&p->hFile);Ù!        SimulateIOErrorBenign(0);§      }·      if( deleteFlag ){Ù!        SimulateIOErrorBenign(1);Ù#        sqlite3BeginBenignMalloc();Ù)        winDelete(pVfs, p->zFilename, 0);Ù!        sqlite3EndBenignMalloc();Ù!        SimulateIOErrorBenign(0);§      }µ      *pp = p->pNext;¿      sqlite3_free(p->aRegion);¶      sqlite3_free(p);ª    }else{µ      pp = &p->pNext;¥    }£  }¡} ¢/*ÙG** The DMS lock has not yet been taken on shm file pShmNode. Attempt toÙB** take it now. Return SQLITE_OK if successful, or an SQLite error²** code otherwise.¢**Ù?** If the DMS cannot be locked because this is a readonly_shm=1Ù?** connection and no other process already holds a lock, returnÙ;** SQLITE_READONLY_CANTINIT and set pShmNode->isUnlocked=1.¢*/Ù5static int winLockSharedMemory(winShmNode *pShmNode){ÙD  int rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, WIN_SHM_DMS, 1); ¶  if( rc==SQLITE_OK ){¿    if( pShmNode->isReadonly ){¿      pShmNode->isUnlocked = 1;Ù?      winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);Ù&      return SQLITE_READONLY_CANTINIT;Ù@    }else if( winTruncate((sqlite3_file*)&pShmNode->hFile, 0) ){Ù?      winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);Ù@      return winLogError(SQLITE_IOERR_SHMOPEN, osGetLastError(),ÙE                         "winLockSharedMemory", pShmNode->zFilename);¥    }£  } ¶  if( rc==SQLITE_OK ){Ù=    winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);£  } ÙB  return winShmSystemLock(pShmNode, WINSHM_RDLCK, WIN_SHM_DMS, 1);¡} ¢/*ÙC** Open the shared-memory area associated with database file pDbFd.¢**ÙG** When opening a new shared-memory file, if no other instances of thatÙG** file are currently open, in this process or in other processes, thenÙH** the file must be truncated to zero length or have its header cleared.¢*/Ù/static int winOpenSharedMemory(winFile *pDbFd){ÙF  struct winShm *p;                  /* The connection to be opened */ÙF  winShmNode *pShmNode = 0;          /* The underlying mmapped file */Ù6  int rc = SQLITE_OK;                /* Result code */ÙE  winShmNode *pNew;                  /* Newly allocated winShmNode */ÙA  int nName;                         /* Size of zName in bytes */ Ù:  assert( pDbFd->pShm==0 );    /* Not previously opened */ ÙG  /* Allocate space for the new sqlite3_shm object.  Also speculativelyÙ6  ** allocate space for a new winShmNode and filename.¤  */Ù&  p = sqlite3MallocZero( sizeof(*p) );Ù,  if( p==0 ) return SQLITE_IOERR_NOMEM_BKPT;Ù(  nName = sqlite3Strlen30(pDbFd->zPath);Ù=  pNew = sqlite3MallocZero( sizeof(*pShmNode) + nName + 17 );°  if( pNew==0 ){´    sqlite3_free(p);Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  }Ù$  pNew->zFilename = (char*)&pNew[1];ÙF  sqlite3_snprintf(nName+15, pNew->zFilename, "%s-shm", pDbFd->zPath);Ù4  sqlite3FileSuffix3(pDbFd->zPath, pNew->zFilename); ÙE  /* Look to see if there is an existing winShmNode that can be used.ÙB  ** If no matching winShmNode currently exists, create a new one.¤  */µ  winShmEnterMutex();ÙE  for(pShmNode = winShmNodeList; pShmNode; pShmNode=pShmNode->pNext){Ù;    /* TBD need to come up with better match here.  PerhapsÙ+    ** use FILE_ID_BOTH_DIR_INFO Structure.¦    */ÙH    if( sqlite3StrICmp(pShmNode->zFilename, pNew->zFilename)==0 ) break;£  }±  if( pShmNode ){·    sqlite3_free(pNew);¨  }else{Ù"    int inFlags = SQLITE_OPEN_WAL;µ    int outFlags = 0; ´    pShmNode = pNew;­    pNew = 0;Ù=    ((winFile*)(&pShmNode->hFile))->h = INVALID_HANDLE_VALUE;Ù%    pShmNode->pNext = winShmNodeList;¾    winShmNodeList = pShmNode; Ù)    if( sqlite3GlobalConfig.bCoreMutex ){Ù?      pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);¿      if( pShmNode->mutex==0 ){Ù%        rc = SQLITE_IOERR_NOMEM_BKPT;º        goto shm_open_err;§      }¥    } ÙB    if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){Ù<      inFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;ª    }else{Ù&      inFlags |= SQLITE_OPEN_READONLY;¥    }Ù2    rc = winOpen(pDbFd->pVfs, pShmNode->zFilename,Ù1                 (sqlite3_file*)&pShmNode->hFile,Ù%                 inFlags, &outFlags);¸    if( rc!=SQLITE_OK ){Ù:      rc = winLogError(rc, osGetLastError(), "winOpenShm",Ù,                       pShmNode->zFilename);¸      goto shm_open_err;¥    }ÙB    if( outFlags==SQLITE_OPEN_READONLY ) pShmNode->isReadonly = 1; Ù'    rc = winLockSharedMemory(pShmNode);ÙJ    if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;£  } Ù9  /* Make the new connection a child of the winShmNode */¹  p->pShmNode = pShmNode;Ù:#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)Ù   p->id = pShmNode->nextShmId++;¦#endif³  pShmNode->nRef++;²  pDbFd->pShm = p;µ  winShmLeaveMutex(); ÙG  /* The reference count on pShmNode has already been incremented underÙG  ** the cover of the winShmEnterMutex() mutex and the pointer from theÙI  ** new (struct winShm) object to the pShmNode has been set. All that isÙG  ** left to do is to link the new object into the linked list startingÙM  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex«  ** mutex.¤  */Ù'  sqlite3_mutex_enter(pShmNode->mutex);¾  p->pNext = pShmNode->pFirst;·  pShmNode->pFirst = p;Ù'  sqlite3_mutex_leave(pShmNode->mutex);¬  return rc; ¾  /* Jump here on any error */­shm_open_err:Ù;  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);ÙN  winShmPurge(pDbFd->pVfs, 0);      /* This call frees pShmNode if required */²  sqlite3_free(p);µ  sqlite3_free(pNew);µ  winShmLeaveMutex();¬  return rc;¡} ¢/*Ù>** Close a connection to shared-memory.  Delete the underlyingÙ!** storage if deleteFlag is true.¢*/·static int winShmUnmap(ÙA  sqlite3_file *fd,          /* Database holding shared memory */Ù?  int deleteFlag             /* Delete after closing if true */¢){Ù<  winFile *pDbFd;       /* Database holding shared-memory */Ù9  winShm *p;            /* The connection to be closed */Ù?  winShmNode *pShmNode; /* The underlying shared-memory file */ÙB  winShm **pp;          /* For looping over sibling connections */ ·  pDbFd = (winFile*)fd;²  p = pDbFd->pShm;¾  if( p==0 ) return SQLITE_OK;¹  pShmNode = p->pShmNode; Ù?  /* Remove connection p from the set of connections associatedµ  ** with pShmNode */Ù'  sqlite3_mutex_enter(pShmNode->mutex);Ù;  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}±  *pp = p->pNext; ½  /* Free the connection p */²  sqlite3_free(p);²  pDbFd->pShm = 0;Ù'  sqlite3_mutex_leave(pShmNode->mutex); Ù?  /* If pShmNode->nRef has reached 0, then close the underlying¿  ** shared-memory file, too */µ  winShmEnterMutex();½  assert( pShmNode->nRef>0 );³  pShmNode->nRef--;º  if( pShmNode->nRef==0 ){Ù)    winShmPurge(pDbFd->pVfs, deleteFlag);£  }µ  winShmLeaveMutex(); ³  return SQLITE_OK;¡} ¢/*Ù5** Change the lock state for a shared-memory segment.¢*/¶static int winShmLock(ÙJ  sqlite3_file *fd,          /* Database file holding the shared memory */ÙC  int ofst,                  /* First lock to acquire or release */ÙH  int n,                     /* Number of locks to acquire or release */Ù;  int flags                  /* What to do with the lock */¢){ÙN  winFile *pDbFd = (winFile*)fd;        /* Connection holding shared memory */ÙL  winShm *p = pDbFd->pShm;              /* The shared memory being locked */ÙK  winShm *pX;                           /* For looping over all siblings */Ù%  winShmNode *pShmNode = p->pShmNode;Ù9  int rc = SQLITE_OK;                   /* Result code */ÙN  u16 mask;                             /* Mask of locks to take or release */ Ù0  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );±  assert( n>=1 );Ù6  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)Ù9       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)Ù8       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)Ù>       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );Ù6  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 ); Ù,  mask = (u16)((1U<<(ofst+n)) - (1U<<ofst));Ù#  assert( n>1 || mask==(1<<ofst) );Ù'  sqlite3_mutex_enter(pShmNode->mutex);Ù"  if( flags & SQLITE_SHM_UNLOCK ){Ù9    u16 allMask = 0; /* Mask of locks held by siblings */ Ù1    /* See if any siblings hold this same lock */Ù/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){»      if( pX==p ) continue;Ù@      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );Ù       allMask |= pX->sharedMask;¥    } Ù'    /* Unlock the system-level locks */¾    if( (mask & allMask)==0 ){ÙJ      rc = winShmSystemLock(pShmNode, WINSHM_UNLCK, ofst+WIN_SHM_BASE, n);ª    }else{µ      rc = SQLITE_OK;¥    } ¾    /* Undo the local locks */¸    if( rc==SQLITE_OK ){»      p->exclMask &= ~mask;½      p->sharedMask &= ~mask;¥    }Ù(  }else if( flags & SQLITE_SHM_SHARED ){ÙO    u16 allShared = 0;  /* Union of locks held by connections other than "p" */ ÙK    /* Find out which shared locks are already held by sibling connections.ÙJ    ** If any sibling already holds an exclusive lock, go ahead and return³    ** SQLITE_BUSY.¦    */Ù/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){Ù%      if( (pX->exclMask & mask)!=0 ){¹        rc = SQLITE_BUSY;®        break;§      }Ù"      allShared |= pX->sharedMask;¥    } Ù<    /* Get shared locks at the system level, if necessary */¸    if( rc==SQLITE_OK ){Ù"      if( (allShared & mask)==0 ){ÙL        rc = winShmSystemLock(pShmNode, WINSHM_RDLCK, ofst+WIN_SHM_BASE, n);¬      }else{·        rc = SQLITE_OK;§      }¥    } Ù$    /* Get the local shared locks */¸    if( rc==SQLITE_OK ){¼      p->sharedMask |= mask;¥    }¨  }else{ÙG    /* Make sure no sibling connections hold locks that will block thisÙ7    ** lock.  If any do, return SQLITE_BUSY right away.¦    */Ù/    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){ÙC      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){¹        rc = SQLITE_BUSY;®        break;§      }¥    } ÙG    /* Get the exclusive locks at the system level.  Then if successfulÙ6    ** also mark the local connection as being locked.¦    */¸    if( rc==SQLITE_OK ){ÙJ      rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, ofst+WIN_SHM_BASE, n);º      if( rc==SQLITE_OK ){Ù,        assert( (p->sharedMask & mask)==0 );¼        p->exclMask |= mask;§      }¥    }£  }Ù'  sqlite3_mutex_leave(pShmNode->mutex);ÙN  OSTRACE(("SHM-LOCK pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x, rc=%s\n",ÙF           osGetCurrentProcessId(), p->id, p->sharedMask, p->exclMask,Ù            sqlite3ErrName(rc)));¬  return rc;¡} ¢/*Ù?** Implement a memory barrier or memory fence on shared memory.¢**ÙE** All loads and stores begun before the barrier must complete beforeÙ-** any load or store begun after the barrier.¢*/ºstatic void winShmBarrier(ÙD  sqlite3_file *fd          /* Database holding the shared memory */¢){·  UNUSED_PARAMETER(fd);ÙA  sqlite3MemoryBarrier();   /* compiler-defined memory barrier */Ù<  winShmEnterMutex();       /* Also mutex, for redundancy */µ  winShmLeaveMutex();¡} ¢/*ÙG** This function is called to obtain a pointer to region iRegion of theÙL** shared-memory associated with the database file fd. Shared-memory regionsÙI** are numbered starting from zero. Each shared-memory region is szRegion±** bytes in size.¢**ÙH** If an error occurs, an error code is returned and *pp is set to NULL.¢**ÙK** Otherwise, if the isWrite parameter is 0 and the requested shared-memoryÙK** region has not been allocated (by any client, including one running in aÙH** separate process), then *pp is set to NULL and SQLITE_OK returned. IfÙI** isWrite is non-zero and the requested shared-memory region has not yetÙ4** been allocated, it is allocated by this function.¢**ÙL** If the shared-memory region has already been allocated or is allocated byÙF** this call as described above, then it is mapped into this processesÙJ** address space (if it is not already), *pp is set to point to the mappedÙ!** memory and SQLITE_OK returned.¢*/µstatic int winShmMap(ÙD  sqlite3_file *fd,               /* Handle open on database file */Ù:  int iRegion,                    /* Region to retrieve */Ù7  int szRegion,                   /* Size of regions */ÙH  int isWrite,                    /* True to extend file if necessary */Ù:  void volatile **pp              /* OUT: Mapped memory */¢){Ù   winFile *pDbFd = (winFile*)fd;½  winShm *pShm = pDbFd->pShm;·  winShmNode *pShmNode;Ù!  DWORD protect = PAGE_READWRITE;Ù/  DWORD flags = FILE_MAP_WRITE | FILE_MAP_READ;µ  int rc = SQLITE_OK; ®  if( !pShm ){Ù$    rc = winOpenSharedMemory(pDbFd);Ù"    if( rc!=SQLITE_OK ) return rc;·    pShm = pDbFd->pShm;£  }¼  pShmNode = pShm->pShmNode; Ù'  sqlite3_mutex_enter(pShmNode->mutex);½  if( pShmNode->isUnlocked ){Ù'    rc = winLockSharedMemory(pShmNode);Ù)    if( rc!=SQLITE_OK ) goto shmpage_out;½    pShmNode->isUnlocked = 0;£  }ÙA  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 ); Ù#  if( pShmNode->nRegion<=iRegion ){Ù@    struct ShmRegion *apNew;           /* New aRegion[] array */ÙG    int nByte = (iRegion+1)*szRegion;  /* Minimum required file size */ÙK    sqlite3_int64 sz;                  /* Current size of wal-index file */ Ù"    pShmNode->szRegion = szRegion; ÙL    /* The requested region is not mapped into this processes address space.ÙK    ** Check to see if it has been allocated (i.e. if the wal-index file isÙ5    ** large enough to contain the requested region).¦    */Ù<    rc = winFileSize((sqlite3_file *)&pShmNode->hFile, &sz);¸    if( rc!=SQLITE_OK ){Ù>      rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),Ù3                       "winShmMap1", pDbFd->zPath);·      goto shmpage_out;¥    } ³    if( sz<nByte ){ÙI      /* The requested memory region does not exist. If isWrite is set toÙJ      ** zero, exit early. *pp will be set to NULL and SQLITE_OK returned.¨      **ÙK      ** Alternatively, if isWrite is non-zero, use ftruncate() to allocateÙ%      ** the requested memory region.¨      */Ù&      if( !isWrite ) goto shmpage_out;Ù@      rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);º      if( rc!=SQLITE_OK ){Ù@        rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),Ù5                         "winShmMap2", pDbFd->zPath);¹        goto shmpage_out;§      }¥    } ÙL    /* Map the requested memory region into this processes address space. */Ù2    apNew = (struct ShmRegion *)sqlite3_realloc64(Ù7        pShmNode->aRegion, (iRegion+1)*sizeof(apNew[0])¦    );±    if( !apNew ){Ù#      rc = SQLITE_IOERR_NOMEM_BKPT;·      goto shmpage_out;¥    }¾    pShmNode->aRegion = apNew; ¿    if( pShmNode->isReadonly ){¾      protect = PAGE_READONLY;¼      flags = FILE_MAP_READ;¥    } Ù(    while( pShmNode->nRegion<=iRegion ){Ù;      HANDLE hMap = NULL;         /* file-mapping handle */Ù<      void *pMap = 0;             /* Mapped memory region */ ³#if SQLITE_OS_WINRTÙ:      hMap = osCreateFileMappingFromApp(pShmNode->hFile.h,Ù$          NULL, protect, nByte, NULL¨      );Ù$#elif defined(SQLITE_WIN32_HAS_WIDE)Ù4      hMap = osCreateFileMappingW(pShmNode->hFile.h,Ù'          NULL, protect, 0, nByte, NULL¨      );ÙG#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGAÙ4      hMap = osCreateFileMappingA(pShmNode->hFile.h,Ù'          NULL, protect, 0, nByte, NULL¨      );¦#endifÙE      OSTRACE(("SHM-MAP-CREATE pid=%lu, region=%d, size=%d, rc=%s\n",ÙA               osGetCurrentProcessId(), pShmNode->nRegion, nByte,Ù(               hMap ? "ok" : "failed"));±      if( hMap ){Ù1        int iOffset = pShmNode->nRegion*szRegion;ÙH        int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;³#if SQLITE_OS_WINRTÙ2        pMap = osMapViewOfFileFromApp(hMap, flags,Ù;            iOffset - iOffsetShift, szRegion + iOffsetShiftª        );¥#elseÙ+        pMap = osMapViewOfFile(hMap, flags,Ù>            0, iOffset - iOffsetShift, szRegion + iOffsetShiftª        );¦#endifÙO        OSTRACE(("SHM-MAP-MAP pid=%lu, region=%d, offset=%d, size=%d, rc=%s\n",ÙE                 osGetCurrentProcessId(), pShmNode->nRegion, iOffset,Ù4                 szRegion, pMap ? "ok" : "failed"));§      }²      if( !pMap ){Ù/        pShmNode->lastErrno = osGetLastError();ÙB        rc = winLogError(SQLITE_IOERR_SHMMAP, pShmNode->lastErrno,Ù5                         "winShmMap3", pDbFd->zPath);Ù'        if( hMap ) osCloseHandle(hMap);¹        goto shmpage_out;§      } Ù7      pShmNode->aRegion[pShmNode->nRegion].pMap = pMap;Ù7      pShmNode->aRegion[pShmNode->nRegion].hMap = hMap;º      pShmNode->nRegion++;¥    }£  } ¬shmpage_out:Ù"  if( pShmNode->nRegion>iRegion ){Ù#    int iOffset = iRegion*szRegion;ÙD    int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;Ù6    char *p = (char *)pShmNode->aRegion[iRegion].pMap;Ù#    *pp = (void *)&p[iOffsetShift];¨  }else{¬    *pp = 0;£  }ÙC  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;Ù'  sqlite3_mutex_leave(pShmNode->mutex);¬  return rc;¡} ¥#else¸# define winShmMap     0¸# define winShmLock    0¸# define winShmBarrier 0¸# define winShmUnmap   0Ù$#endif /* #ifndef SQLITE_OMIT_WAL */ ¢/*Ù=** Cleans up the mapped region of the specified file, if any.¢*/º#if SQLITE_MAX_MMAP_SIZE>0Ù(static int winUnmapfile(winFile *pFile){µ  assert( pFile!=0 );ÙC  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, pMapRegion=%p, "ÙD           "mmapSize=%lld, mmapSizeActual=%lld, mmapSizeMax=%lld\n",ÙJ           osGetCurrentProcessId(), pFile, pFile->hMap, pFile->pMapRegion,ÙH           pFile->mmapSize, pFile->mmapSizeActual, pFile->mmapSizeMax));º  if( pFile->pMapRegion ){Ù0    if( !osUnmapViewOfFile(pFile->pMapRegion) ){Ù*      pFile->lastErrno = osGetLastError();Ù>      OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, pMapRegion=%p, "ÙH               "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(), pFile,Ù#               pFile->pMapRegion));Ù=      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,Ù8                         "winUnmapfile1", pFile->zPath);¥    }º    pFile->pMapRegion = 0;¸    pFile->mmapSize = 0;¾    pFile->mmapSizeActual = 0;£  }º  if( pFile->hMap!=NULL ){Ù&    if( !osCloseHandle(pFile->hMap) ){Ù*      pFile->lastErrno = osGetLastError();ÙO      OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, rc=SQLITE_IOERR_MMAP\n",Ù=               osGetCurrentProcessId(), pFile, pFile->hMap));Ù=      return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,Ù8                         "winUnmapfile2", pFile->zPath);¥    }·    pFile->hMap = NULL;£  }Ù:  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",Ù,           osGetCurrentProcessId(), pFile));³  return SQLITE_OK;¡} ¢/*ÙJ** Memory map or remap the file opened by file-descriptor pFd (if the fileÙJ** is already mapped, the existing mapping is replaced by the new). Or, ifÙD** there already exists a mapping for this file, and there are stillÙC** outstanding xFetch() references to it, this function is a no-op.¢**ÙG** If parameter nByte is non-negative, then it is the requested size ofÙI** the mapping to create. Otherwise, if nByte is less than zero, then theÙI** requested size is the size of the file on disk. The actual size of theÙG** created mapping is either the requested size or the value configuredÙ6** using SQLITE_FCNTL_MMAP_SIZE, whichever is smaller.¢**ÙG** SQLITE_OK is returned if no error occurs (even if the mapping is notÙF** recreated as a result of outstanding references) or an SQLite error²** code otherwise.¢*/Ù9static int winMapfile(winFile *pFd, sqlite3_int64 nByte){½  sqlite3_int64 nMap = nByte;©  int rc; Ù)  assert( nMap>=0 || pFd->nFetchOut==0 );Ù5  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, size=%lld\n",Ù1           osGetCurrentProcessId(), pFd, nByte)); Ù*  if( pFd->nFetchOut>0 ) return SQLITE_OK; ¯  if( nMap<0 ){Ù0    rc = winFileSize((sqlite3_file*)pFd, &nMap);­    if( rc ){ÙE      OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_IOERR_FSTAT\n",Ù.               osGetCurrentProcessId(), pFd));Ù       return SQLITE_IOERR_FSTAT;¥    }£  }¾  if( nMap>pFd->mmapSizeMax ){¼    nMap = pFd->mmapSizeMax;£  }Ù6  nMap &= ~(sqlite3_int64)(winSysInfo.dwPageSize - 1); Ù#  if( nMap==0 && pFd->mmapSize>0 ){¶    winUnmapfile(pFd);£  }¼  if( nMap!=pFd->mmapSize ){³    void *pNew = 0;Ù"    DWORD protect = PAGE_READONLY;Ù     DWORD flags = FILE_MAP_READ; ¶    winUnmapfile(pFd);¼#ifdef SQLITE_MMAP_READWRITEÙ/    if( (pFd->ctrlFlags & WINFILE_RDONLY)==0 ){¿      protect = PAGE_READWRITE;¾      flags |= FILE_MAP_WRITE;¥    }¦#endif³#if SQLITE_OS_WINRTÙN    pFd->hMap = osCreateFileMappingFromApp(pFd->h, NULL, protect, nMap, NULL);Ù$#elif defined(SQLITE_WIN32_HAS_WIDE)Ù;    pFd->hMap = osCreateFileMappingW(pFd->h, NULL, protect,ÙA                                (DWORD)((nMap>>32) & 0xffffffff),ÙB                                (DWORD)(nMap & 0xffffffff), NULL);ÙG#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGAÙ;    pFd->hMap = osCreateFileMappingA(pFd->h, NULL, protect,ÙA                                (DWORD)((nMap>>32) & 0xffffffff),ÙB                                (DWORD)(nMap & 0xffffffff), NULL);¦#endifº    if( pFd->hMap==NULL ){Ù(      pFd->lastErrno = osGetLastError();Ù9      rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,Ù2                       "winMapfile1", pFd->zPath);ÙK      /* Log the error, but continue normal operation using xRead/xWrite */Ù<      OSTRACE(("MAP-FILE-CREATE pid=%lu, pFile=%p, rc=%s\n",ÙB               osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));·      return SQLITE_OK;¥    }Ù0    assert( (nMap % winSysInfo.dwPageSize)==0 );ÙH    assert( sizeof(SIZE_T)==sizeof(sqlite3_int64) || nMap<=0xffffffff );³#if SQLITE_OS_WINRTÙE    pNew = osMapViewOfFileFromApp(pFd->hMap, flags, 0, (SIZE_T)nMap);¥#elseÙA    pNew = osMapViewOfFile(pFd->hMap, flags, 0, 0, (SIZE_T)nMap);¦#endifµ    if( pNew==NULL ){¿      osCloseHandle(pFd->hMap);·      pFd->hMap = NULL;Ù(      pFd->lastErrno = osGetLastError();Ù9      rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,Ù2                       "winMapfile2", pFd->zPath);ÙK      /* Log the error, but continue normal operation using xRead/xWrite */Ù9      OSTRACE(("MAP-FILE-MAP pid=%lu, pFile=%p, rc=%s\n",ÙB               osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));·      return SQLITE_OK;¥    }»    pFd->pMapRegion = pNew;¹    pFd->mmapSize = nMap;¿    pFd->mmapSizeActual = nMap;£  } Ù8  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",Ù*           osGetCurrentProcessId(), pFd));³  return SQLITE_OK;¡}Ù##endif /* SQLITE_MAX_MMAP_SIZE>0 */ ¢/*ÙK** If possible, return a pointer to a mapping of file fd starting at offsetÙ;** iOff. The mapping must be valid for at least nAmt bytes.¢**ÙK** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.ÙL** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.ÙJ** Finally, if an error does occur, return an SQLite error code. The finalÙ*** value of *pp is undefined in this case.¢**ÙE** If this function does return a pointer, the caller must eventuallyÙ1** release the reference by calling winUnfetch().¢*/ÙEstatic int winFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){º#if SQLITE_MAX_MMAP_SIZE>0ÙC  winFile *pFd = (winFile*)fd;   /* The underlying database file */¦#endifª  *pp = 0; ÙF  OSTRACE(("FETCH pid=%lu, pFile=%p, offset=%lld, amount=%d, pp=%p\n",Ù9           osGetCurrentProcessId(), fd, iOff, nAmt, pp)); º#if SQLITE_MAX_MMAP_SIZE>0»  if( pFd->mmapSizeMax>0 ){½    if( pFd->pMapRegion==0 ){Ù#      int rc = winMapfile(pFd, -1);º      if( rc!=SQLITE_OK ){Ù4        OSTRACE(("FETCH pid=%lu, pFile=%p, rc=%s\n",ÙD                 osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));²        return rc;§      }¥    }Ù%    if( pFd->mmapSize >= iOff+nAmt ){Ù+      *pp = &((u8 *)pFd->pMapRegion)[iOff];·      pFd->nFetchOut++;¥    }£  }¦#endif ÙD  OSTRACE(("FETCH pid=%lu, pFile=%p, pp=%p, *pp=%p, rc=SQLITE_OK\n",Ù2           osGetCurrentProcessId(), fd, pp, *pp));³  return SQLITE_OK;¡} ¢/*ÙC** If the third argument is non-NULL, then this function releases aÙB** reference obtained by an earlier call to winFetch(). The secondÙI** argument passed to this function must be the same as the correspondingÙ9** argument that was passed to the winFetch() invocation.¢**ÙH** Or, if the third argument is NULL, then this function is being calledÙI** to inform the VFS layer that, according to POSIX, any existing mappingÙ-** may now be invalid and should be unmapped.¢*/Ù;static int winUnfetch(sqlite3_file *fd, i64 iOff, void *p){º#if SQLITE_MAX_MMAP_SIZE>0ÙC  winFile *pFd = (winFile*)fd;   /* The underlying database file */ ÙF  /* If p==0 (unmap the entire file) then there must be no outstandingÙH  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),Ù5  ** then there must be at least one outstanding.  */Ù(  assert( (p==0)==(pFd->nFetchOut==0) ); Ù.  /* If p!=0, it must match the iOff value. */Ù6  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] ); Ù<  OSTRACE(("UNFETCH pid=%lu, pFile=%p, offset=%lld, p=%p\n",Ù3           osGetCurrentProcessId(), pFd, iOff, p)); ª  if( p ){µ    pFd->nFetchOut--;¨  }else{ÙH    /* FIXME:  If Windows truly always prevents truncating or deleting aÙK    ** file while a mapping is held, then the following winUnmapfile() callÙ<    ** is unnecessary can be omitted - potentially improving·    ** performance.  */¶    winUnmapfile(pFd);£  } ¾  assert( pFd->nFetchOut>=0 );¦#endif Ù7  OSTRACE(("UNFETCH pid=%lu, pFile=%p, rc=SQLITE_OK\n",Ù)           osGetCurrentProcessId(), fd));³  return SQLITE_OK;¡} ¢/*Ù<** Here ends the implementation of all sqlite3_file methods.¢**ÙO********************** End sqlite3_file Methods *******************************ÙO******************************************************************************/ ¢/*Ù=** This vector defines all the methods that can operate on anº** sqlite3_file for win32.¢*/Ù/static const sqlite3_io_methods winIoMethod = {Ù0  3,                              /* iVersion */Ù.  winClose,                       /* xClose */Ù-  winRead,                        /* xRead */Ù.  winWrite,                       /* xWrite */Ù1  winTruncate,                    /* xTruncate */Ù-  winSync,                        /* xSync */Ù1  winFileSize,                    /* xFileSize */Ù-  winLock,                        /* xLock */Ù/  winUnlock,                      /* xUnlock */Ù:  winCheckReservedLock,           /* xCheckReservedLock */Ù4  winFileControl,                 /* xFileControl */Ù3  winSectorSize,                  /* xSectorSize */Ù>  winDeviceCharacteristics,       /* xDeviceCharacteristics */Ù/  winShmMap,                      /* xShmMap */Ù0  winShmLock,                     /* xShmLock */Ù3  winShmBarrier,                  /* xShmBarrier */Ù1  winShmUnmap,                    /* xShmUnmap */Ù.  winFetch,                       /* xFetch */Ù0  winUnfetch                      /* xUnfetch */¢}; ¢/*Ù=** This vector defines all the methods that can operate on anÙ9** sqlite3_file for win32 without performing any locking.¢*/Ù5static const sqlite3_io_methods winIoNolockMethod = {Ù0  3,                              /* iVersion */Ù.  winClose,                       /* xClose */Ù-  winRead,                        /* xRead */Ù.  winWrite,                       /* xWrite */Ù1  winTruncate,                    /* xTruncate */Ù-  winSync,                        /* xSync */Ù1  winFileSize,                    /* xFileSize */Ù-  winNolockLock,                  /* xLock */Ù/  winNolockUnlock,                /* xUnlock */Ù:  winNolockCheckReservedLock,     /* xCheckReservedLock */Ù4  winFileControl,                 /* xFileControl */Ù3  winSectorSize,                  /* xSectorSize */Ù>  winDeviceCharacteristics,       /* xDeviceCharacteristics */Ù/  winShmMap,                      /* xShmMap */Ù0  winShmLock,                     /* xShmLock */Ù3  winShmBarrier,                  /* xShmBarrier */Ù1  winShmUnmap,                    /* xShmUnmap */Ù.  winFetch,                       /* xFetch */Ù0  winUnfetch                      /* xUnfetch */¢}; Ù#static winVfsAppData winAppData = {Ù#  &winIoMethod,       /* pMethod */Ù$  0,                  /* pAppData */Ù#  0                   /* bNoLock */¢}; Ù)static winVfsAppData winNolockAppData = {Ù#  &winIoNolockMethod, /* pMethod */Ù$  0,                  /* pAppData */Ù#  1                   /* bNoLock */¢}; ÙM/****************************************************************************ÙM**************************** sqlite3_vfs methods ****************************¢**Ù>** This division contains the implementation of methods on the¶** sqlite3_vfs object.¢*/ ·#if defined(__CYGWIN__)¢/*ÙC** Convert a filename from whatever the underlying operating systemÙB** supports for filenames into UTF-8.  Space to hold the result isÙB** obtained from malloc and must be freed by the calling function.¢*/Ù=static char *winConvertToUtf8Filename(const void *zFilename){·  char *zConverted = 0;±  if( osIsNT() ){Ù-    zConverted = winUnicodeToUtf8(zFilename);£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{Ù?    zConverted = winMbcsToUtf8(zFilename, osAreFileApisANSI());£  }¦#endifÙ(  /* caller will handle out of memory */´  return zConverted;¡}¦#endif ¢/*Ù=** Convert a UTF-8 filename into whatever form the underlyingÙA** operating system wants filenames in.  Space to hold the resultÙ;** is obtained from malloc and must be freed by the calling¬** function.¢*/Ù?static void *winConvertFromUtf8Filename(const char *zFilename){·  void *zConverted = 0;±  if( osIsNT() ){Ù-    zConverted = winUtf8ToUnicode(zFilename);£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{Ù?    zConverted = winUtf8ToMbcs(zFilename, osAreFileApisANSI());£  }¦#endifÙ(  /* caller will handle out of memory */´  return zConverted;¡} ¢/*ÙF** This function returns non-zero if the specified UTF-8 string bufferÙD** ends with a directory separator character or one was successfully¯** added to it.¢*/Ù4static int winMakeEndInDirSep(int nBuf, char *zBuf){­  if( zBuf ){Ù%    int nLen = sqlite3Strlen30(zBuf);±    if( nLen>0 ){Ù&      if( winIsDirSep(zBuf[nLen-1]) ){±        return 1;¾      }else if( nLen+1<nBuf ){Ù$        zBuf[nLen] = winGetDirSep();¼        zBuf[nLen+1] = '\0';±        return 1;§      }¥    }£  }«  return 0;¡} ¢/*ÙK** Create a temporary file name and store the resulting pointer into pzBuf.ÙB** The pointer returned in pzBuf must be freed via sqlite3_free().¢*/Ù;static int winGetTempname(sqlite3_vfs *pVfs, char **pzBuf){¸  static char zChars[] =Ù     "abcdefghijklmnopqrstuvwxyz"Ù     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"±    "0123456789";®  size_t i, j;Ù6  int nPre = sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX);½  int nMax, nBuf, nDir, nLen;­  char *zBuf; ÙC  /* It's odd to simulate an io-error here, but really this is justÙG  ** using the io-error infrastructure to test that SQLite handles this¶  ** function failing.¤  */Ù)  SimulateIOError( return SQLITE_IOERR ); ÙB  /* Allocate a temporary buffer to store the fully qualified fileÙE  ** name for the temporary file.  If this fails, we cannot continue.¤  */Ù+  nMax = pVfs->mxPathname; nBuf = nMax + 2;Ù#  zBuf = sqlite3MallocZero( nBuf );®  if( !zBuf ){Ù7    OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  } ÙG  /* Figure out the effective temporary directory.  First, check if oneÙG  ** has been explicitly set by the application; otherwise, use the oneÙ(  ** configured by the operating system.¤  */¼  nDir = nMax - (nPre + 15);³  assert( nDir>0 );¿  if( sqlite3_temp_directory ){Ù:    int nDirLen = sqlite3Strlen30(sqlite3_temp_directory);´    if( nDirLen>0 ){Ù<      if( !winIsDirSep(sqlite3_temp_directory[nDirLen-1]) ){²        nDirLen++;§      }¹      if( nDirLen>nDir ){»        sqlite3_free(zBuf);Ù5        OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));ÙB        return winLogError(SQLITE_ERROR, 0, "winGetTempname1", 0);§      }ÙA      sqlite3_snprintf(nMax, zBuf, "%s", sqlite3_temp_directory);¥    }£  }·#if defined(__CYGWIN__)§  else{Ù#    static const char *azDirs[] = {Ù'       0, /* getenv("SQLITE_TMPDIR") */Ù        0, /* getenv("TMPDIR") */½       0, /* getenv("TMP") */¾       0, /* getenv("TEMP") */Ù%       0, /* getenv("USERPROFILE") */²       "/var/tmp",²       "/usr/tmp",®       "/tmp",«       ".",Ù%       0        /* List terminator */¦    };³    unsigned int i;¹    const char *zDir = 0; Ù9    if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");Ù2    if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");Ù/    if( !azDirs[2] ) azDirs[2] = getenv("TMP");Ù0    if( !azDirs[3] ) azDirs[3] = getenv("TEMP");Ù7    if( !azDirs[4] ) azDirs[4] = getenv("USERPROFILE");ÙC    for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){·      void *zConverted;½      if( zDir==0 ) continue;ÙE      /* If the path starts with a drive letter followed by the colonÙH      ** character, assume it is already a native Win32 path; otherwise,ÙG      ** it must be converted to a native Win32 path via the Cygwin API»      ** prior to using it.¨      */Ù+      if( winIsDriveLetterAndColon(zDir) ){Ù6        zConverted = winConvertFromUtf8Filename(zDir);º        if( !zConverted ){½          sqlite3_free(zBuf);Ù=          OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù)          return SQLITE_IOERR_NOMEM_BKPT;©        }Ù#        if( winIsDir(zConverted) ){Ù3          sqlite3_snprintf(nMax, zBuf, "%s", zDir);Ù#          sqlite3_free(zConverted);°          break;©        }Ù!        sqlite3_free(zConverted);¬      }else{Ù1        zConverted = sqlite3MallocZero( nMax+1 );º        if( !zConverted ){½          sqlite3_free(zBuf);Ù=          OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù)          return SQLITE_IOERR_NOMEM_BKPT;©        }½        if( cygwin_conv_path(ÙI                osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A, zDir,Ù(                zConverted, nMax+1)<0 ){Ù#          sqlite3_free(zConverted);½          sqlite3_free(zBuf);Ù@          OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\n"));ÙA          return winLogError(SQLITE_IOERR_CONVPATH, (DWORD)errno,Ù6                             "winGetTempname2", zDir);©        }Ù#        if( winIsDir(zConverted) ){ÙM          /* At this point, we know the candidate directory exists and shouldÙL          ** be used.  However, we may need to convert the string containingÙB          ** its name into UTF-8 (i.e. if it is UTF-16 right now).¬          */Ù=          char *zUtf8 = winConvertToUtf8Filename(zConverted);·          if( !zUtf8 ){Ù%            sqlite3_free(zConverted);¿            sqlite3_free(zBuf);Ù?            OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù+            return SQLITE_IOERR_NOMEM_BKPT;«          }Ù4          sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);¾          sqlite3_free(zUtf8);Ù#          sqlite3_free(zConverted);°          break;©        }Ù!        sqlite3_free(zConverted);§      }¥    }£  }Ù.#elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)¶  else if( osIsNT() ){±    char *zMulti;Ù?    LPWSTR zWidePath = sqlite3MallocZero( nMax*sizeof(WCHAR) );µ    if( !zWidePath ){¹      sqlite3_free(zBuf);Ù9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }Ù-    if( osGetTempPathW(nMax, zWidePath)==0 ){¾      sqlite3_free(zWidePath);¹      sqlite3_free(zBuf);Ù?      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));ÙD      return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),Ù/                         "winGetTempname2", 0);¥    }Ù)    zMulti = winUnicodeToUtf8(zWidePath);±    if( zMulti ){Ù1      sqlite3_snprintf(nMax, zBuf, "%s", zMulti);»      sqlite3_free(zMulti);¾      sqlite3_free(zWidePath);ª    }else{¾      sqlite3_free(zWidePath);¹      sqlite3_free(zBuf);Ù9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{°    char *zUtf8;Ù0    char *zMbcsPath = sqlite3MallocZero( nMax );µ    if( !zMbcsPath ){¹      sqlite3_free(zBuf);Ù9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }Ù-    if( osGetTempPathA(nMax, zMbcsPath)==0 ){¹      sqlite3_free(zBuf);Ù?      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));ÙD      return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),Ù/                         "winGetTempname3", 0);¥    }Ù:    zUtf8 = winMbcsToUtf8(zMbcsPath, osAreFileApisANSI());°    if( zUtf8 ){Ù0      sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);º      sqlite3_free(zUtf8);ª    }else{¹      sqlite3_free(zBuf);Ù9      OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }£  }Ù"#endif /* SQLITE_WIN32_HAS_ANSI */½#endif /* !SQLITE_OS_WINRT */ ¤  /*ÙH  ** Check to make sure the temporary directory ends with an appropriateÙI  ** separator.  If it does not and there is not enough space left to add¯  ** one, fail.¤  */Ù*  if( !winMakeEndInDirSep(nDir+1, zBuf) ){·    sqlite3_free(zBuf);Ù1    OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));Ù>    return winLogError(SQLITE_ERROR, 0, "winGetTempname4", 0);£  } ¤  /*ÙH  ** Check that the output buffer is large enough for the temporary fileÙ"  ** name in the following format:¤  **Ù9  **   "<temporary_directory>/etilqs_XXXXXXXXXXXXXXX\0\0"¤  **ÙI  ** If not, return SQLITE_ERROR.  The number 17 is used here in order toÙI  ** account for the space used by the 15 character random suffix and theÙJ  ** two trailing NUL characters.  The final directory separator characterÙ5  ** has already added if it was not already present.¤  */¿  nLen = sqlite3Strlen30(zBuf);Ù"  if( (nLen + nPre + 17) > nBuf ){·    sqlite3_free(zBuf);Ù1    OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));Ù>    return winLogError(SQLITE_ERROR, 0, "winGetTempname5", 0);£  } ÙE  sqlite3_snprintf(nBuf-16-nLen, zBuf+nLen, SQLITE_TEMP_FILE_PREFIX); ¼  j = sqlite3Strlen30(zBuf);Ù#  sqlite3_randomness(15, &zBuf[j]);»  for(i=0; i<15; i++, j++){ÙJ    zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];£  }®  zBuf[j] = 0;°  zBuf[j+1] = 0;°  *pzBuf = zBuf; Ù;  OSTRACE(("TEMP-FILENAME name=%s, rc=SQLITE_OK\n", zBuf));³  return SQLITE_OK;¡} ¢/*ÙH** Return TRUE if the named file is really a directory.  Return false ifÙL** it is something other than a directory, or if there is any kind of memory¶** allocation failure.¢*/Ù,static int winIsDir(const void *zConverted){­  DWORD attr;­  int rc = 0;²  DWORD lastErrno; ±  if( osIsNT() ){°    int cnt = 0;Ù(    WIN32_FILE_ATTRIBUTE_DATA sAttrData;Ù-    memset(&sAttrData, 0, sizeof(sAttrData));Ù=    while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,Ù3                             GetFileExInfoStandard,ÙP                             &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}®    if( !rc ){Ù#      return 0; /* Invalid name? */¥    }Ù&    attr = sAttrData.dwFileAttributes;¶#if SQLITE_OS_WINCE==0¨  }else{Ù3    attr = osGetFileAttributesA((char*)zConverted);¦#endif£  }ÙL  return (attr!=INVALID_FILE_ATTRIBUTES) && (attr&FILE_ATTRIBUTE_DIRECTORY);¡} ·/* forward reference */µstatic int winAccess(Ù4  sqlite3_vfs *pVfs,         /* Not used on win32 */Ù8  const char *zFilename,     /* Name of file to check */ÙD  int flags,                 /* Type of test to make on this file */Ù.  int *pResOut               /* OUT: Result */¢); ¢/*¯** Open a file.¢*/³static int winOpen(ÙM  sqlite3_vfs *pVfs,        /* Used to get maximum path length and AppData */Ù:  const char *zName,        /* Name of the file (UTF-8) */ÙC  sqlite3_file *id,         /* Write the SQLite file handle here */Ù1  int flags,                /* Open mode flags */Ù5  int *pOutFlags            /* Status return flags */¢){«  HANDLE h;¶  DWORD lastErrno = 0;¸  DWORD dwDesiredAccess;´  DWORD dwShareMode;¾  DWORD dwCreationDisposition;Ù!  DWORD dwFlagsAndAttributes = 0;³#if SQLITE_OS_WINCE±  int isTemp = 0;¦#endifº  winVfsAppData *pAppData;Ù   winFile *pFile = (winFile*)id;Ù>  void *zConverted;              /* Filename in OS encoding */ÙA  const char *zUtf8Name = zName; /* Filename in UTF-8 encoding */®  int cnt = 0; ÙK  /* If argument zPath is a NULL pointer, this function is required to openÙA  ** a temporary file. Use this buffer to store the file name in.¤  */ÙA  char *zTmpname = 0; /* For temporary filename, if necessary. */ Ù;  int rc = SQLITE_OK;            /* Function Return Code */Ù'#if !defined(NDEBUG) || SQLITE_OS_WINCEÙ;  int eType = flags&0xFFFFFF00;  /* Type of file to open */¦#endif Ù5  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);Ù9  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);Ù2  int isCreate     = (flags & SQLITE_OPEN_CREATE);Ù4  int isReadonly   = (flags & SQLITE_OPEN_READONLY);Ù5  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE); ®#ifndef NDEBUGÙ$  int isOpenJournal = (isCreate && (Ù)        eType==SQLITE_OPEN_MASTER_JOURNALÙ'     || eType==SQLITE_OPEN_MAIN_JOURNAL¾     || eType==SQLITE_OPEN_WAL¥  ));¦#endif Ù>  OSTRACE(("OPEN name=%s, pFile=%p, flags=%x, pOutFlags=%p\n",Ù-           zUtf8Name, id, flags, pOutFlags)); Ù-  /* Check the following statements are true:¤  **ÙK  **   (a) Exactly one of the READWRITE and READONLY flags must be set, andÙA  **   (b) if CREATE is set, then READWRITE must also be set, andÙ=  **   (c) if EXCLUSIVE is set, then CREATE must also be set.ÙA  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.¤  */ÙK  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));Ù%  assert(isCreate==0 || isReadWrite);Ù%  assert(isExclusive==0 || isCreate);Ù"  assert(isDelete==0 || isCreate); ÙE  /* The main DB, main journal, WAL file and master journal are neverÙB  ** automatically deleted. Nor are they ever temporary files.  */Ù?  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );ÙD  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );ÙF  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );Ù;  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL ); ÙI  /* Assert that the upper layer has set one of the "file-type" flags. */ÙG  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DBÙL       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNALÙN       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNALÙC       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL¤  ); µ  assert( pFile!=0 );Ù$  memset(pFile, 0, sizeof(winFile));Ù"  pFile->h = INVALID_HANDLE_VALUE; ³#if SQLITE_OS_WINRTÙ.  if( !zUtf8Name && !sqlite3_temp_directory ){½    sqlite3_log(SQLITE_ERROR,ÙC        "sqlite3_temp_directory variable should be set for WinRT");£  }¦#endif Ù@  /* If the second argument to this function is NULL, generate a¿  ** temporary file name to use¤  */³  if( !zUtf8Name ){Ù)    assert( isDelete && !isOpenJournal );Ù)    rc = winGetTempname(pVfs, &zTmpname);¸    if( rc!=SQLITE_OK ){ÙF      OSTRACE(("OPEN name=%s, rc=%s", zUtf8Name, sqlite3ErrName(rc)));°      return rc;¥    }¹    zUtf8Name = zTmpname;£  } ÙB  /* Database filenames are double-zero terminated if they are notÙA  ** URIs with parameters.  Hence, they can always be passed into½  ** sqlite3_uri_parameter().¤  */ÙF  assert( (eType!=SQLITE_OPEN_MAIN_DB) || (flags & SQLITE_OPEN_URI) ||Ù4       zUtf8Name[sqlite3Strlen30(zUtf8Name)+1]==0 ); Ù4  /* Convert the filename to the system encoding. */Ù5  zConverted = winConvertFromUtf8Filename(zUtf8Name);¶  if( zConverted==0 ){»    sqlite3_free(zTmpname);Ù@    OSTRACE(("OPEN name=%s, rc=SQLITE_IOERR_NOMEM", zUtf8Name));Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  } ½  if( winIsDir(zConverted) ){½    sqlite3_free(zConverted);»    sqlite3_free(zTmpname);ÙC    OSTRACE(("OPEN name=%s, rc=SQLITE_CANTOPEN_ISDIR", zUtf8Name));Ù!    return SQLITE_CANTOPEN_ISDIR;£  } ´  if( isReadWrite ){Ù3    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;¨  }else{Ù#    dwDesiredAccess = GENERIC_READ;£  } ÙB  /* SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file isÙB  ** created. SQLite doesn't use it to indicate "exclusive access"Ù!  ** as it is usually understood.¤  */´  if( isExclusive ){Ù@    /* Creates a new file, only if it does not already exist. */Ù'    /* If the file exists, it fails. */Ù'    dwCreationDisposition = CREATE_NEW;·  }else if( isCreate ){Ù;    /* Open existing file, or create if it doesn't exist */Ù(    dwCreationDisposition = OPEN_ALWAYS;¨  }else{Ù*    /* Opens a file, only if it exists. */Ù*    dwCreationDisposition = OPEN_EXISTING;£  } Ù3  dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE; ±  if( isDelete ){³#if SQLITE_OS_WINCEÙ1    dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN;¯    isTemp = 1;¥#elseÙ3    dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARYÙ6                               | FILE_ATTRIBUTE_HIDDENÙ;                               | FILE_FLAG_DELETE_ON_CLOSE;¦#endif¨  }else{Ù1    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;£  }Ù=  /* Reports from the internet are that performance is alwaysÙA  ** better if FILE_FLAG_RANDOM_ACCESS is used.  Ticket #2699. */³#if SQLITE_OS_WINCEÙ2  dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;¦#endif ±  if( osIsNT() ){³#if SQLITE_OS_WINRTÙ7    CREATEFILE2_EXTENDED_PARAMETERS extendedParameters;ÙH    extendedParameters.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);Ù)    extendedParameters.dwFileAttributes =Ù7            dwFlagsAndAttributes & FILE_ATTRIBUTE_MASK;ÙK    extendedParameters.dwFileFlags = dwFlagsAndAttributes & FILE_FLAG_MASK;Ù?    extendedParameters.dwSecurityQosFlags = SECURITY_ANONYMOUS;Ù3    extendedParameters.lpSecurityAttributes = NULL;Ù,    extendedParameters.hTemplateFile = NULL;§    do{Ù,      h = osCreateFile2((LPCWSTR)zConverted,Ù(                        dwDesiredAccess,Ù$                        dwShareMode,Ù.                        dwCreationDisposition,Ù-                        &extendedParameters);Ù*      if( h!=INVALID_HANDLE_VALUE ) break;¸      if( isReadWrite ){º        int rc2, isRO = 0;Ù#        sqlite3BeginBenignMalloc();Ù@        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);Ù!        sqlite3EndBenignMalloc();Ù+        if( rc2==SQLITE_OK && isRO ) break;§      }Ù.    }while( winRetryIoerr(&cnt, &lastErrno) );¥#else§    do{Ù,      h = osCreateFileW((LPCWSTR)zConverted,Ù(                        dwDesiredAccess,Ù*                        dwShareMode, NULL,Ù.                        dwCreationDisposition,Ù-                        dwFlagsAndAttributes,¾                        NULL);Ù*      if( h!=INVALID_HANDLE_VALUE ) break;¸      if( isReadWrite ){º        int rc2, isRO = 0;Ù#        sqlite3BeginBenignMalloc();Ù@        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);Ù!        sqlite3EndBenignMalloc();Ù+        if( rc2==SQLITE_OK && isRO ) break;§      }Ù.    }while( winRetryIoerr(&cnt, &lastErrno) );¦#endif£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{§    do{Ù+      h = osCreateFileA((LPCSTR)zConverted,Ù(                        dwDesiredAccess,Ù*                        dwShareMode, NULL,Ù.                        dwCreationDisposition,Ù-                        dwFlagsAndAttributes,¾                        NULL);Ù*      if( h!=INVALID_HANDLE_VALUE ) break;¸      if( isReadWrite ){º        int rc2, isRO = 0;Ù#        sqlite3BeginBenignMalloc();Ù@        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);Ù!        sqlite3EndBenignMalloc();Ù+        if( rc2==SQLITE_OK && isRO ) break;§      }Ù.    }while( winRetryIoerr(&cnt, &lastErrno) );£  }¦#endif½  winLogIoerr(cnt, __LINE__); ÙF  OSTRACE(("OPEN file=%p, name=%s, access=%lx, rc=%s\n", h, zUtf8Name,ÙJ           dwDesiredAccess, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok")); Ù   if( h==INVALID_HANDLE_VALUE ){½    sqlite3_free(zConverted);»    sqlite3_free(zTmpname);Ù&    if( isReadWrite && !isExclusive ){Ù%      return winOpen(pVfs, zName, id,Ù(         ((flags|SQLITE_OPEN_READONLY) &ÙB                     ~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE)),´         pOutFlags);ª    }else{Ù#      pFile->lastErrno = lastErrno;ÙK      winLogError(SQLITE_CANTOPEN, pFile->lastErrno, "winOpen", zUtf8Name);Ù"      return SQLITE_CANTOPEN_BKPT;¥    }£  } ²  if( pOutFlags ){¶    if( isReadWrite ){Ù)      *pOutFlags = SQLITE_OPEN_READWRITE;ª    }else{Ù(      *pOutFlags = SQLITE_OPEN_READONLY;¥    }£  } ÙM  OSTRACE(("OPEN file=%p, name=%s, access=%lx, pOutFlags=%p, *pOutFlags=%d, "ÙK           "rc=%s\n", h, zUtf8Name, dwDesiredAccess, pOutFlags, pOutFlags ?ÙI           *pOutFlags : 0, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok")); Ù,  pAppData = (winVfsAppData*)pVfs->pAppData; ³#if SQLITE_OS_WINCE£  {Ù1    if( isReadWrite && eType==SQLITE_OPEN_MAIN_DBÙ4         && ((pAppData==NULL) || !pAppData->bNoLock)Ù;         && (rc = winceCreateLock(zName, pFile))!=SQLITE_OK¦    ){·      osCloseHandle(h);¿      sqlite3_free(zConverted);½      sqlite3_free(zTmpname);ÙL      OSTRACE(("OPEN-CE-LOCK name=%s, rc=%s\n", zName, sqlite3ErrName(rc)));°      return rc;¥    }£  }¯  if( isTemp ){Ù'    pFile->zDeleteOnClose = zConverted;§  }else¦#endif£  {½    sqlite3_free(zConverted);£  } ¹  sqlite3_free(zTmpname);Ù?  pFile->pMethod = pAppData ? pAppData->pMethod : &winIoMethod;µ  pFile->pVfs = pVfs;¯  pFile->h = h;³  if( isReadonly ){Ù'    pFile->ctrlFlags |= WINFILE_RDONLY;£  }ÙG  if( sqlite3_uri_boolean(zName, "psow", SQLITE_POWERSAFE_OVERWRITE) ){Ù%    pFile->ctrlFlags |= WINFILE_PSOW;£  }¾  pFile->lastErrno = NO_ERROR;·  pFile->zPath = zName;º#if SQLITE_MAX_MMAP_SIZE>0µ  pFile->hMap = NULL;¸  pFile->pMapRegion = 0;¶  pFile->mmapSize = 0;¼  pFile->mmapSizeActual = 0;Ù2  pFile->mmapSizeMax = sqlite3GlobalConfig.szMmap;¦#endif ²  OpenCounter(+1);¬  return rc;¡} ¢/*¹** Delete the named file.¢**ÙF** Note that Windows does not allow a file to be deleted if some otherÙF** process has it open.  Sometimes a virus scanner or indexing programÙF** will open a journal file shortly after it is created in order to doÙ=** whatever it does.  While this other process is holding theÙB** file open, we will be unable to delete it.  To work around thisÙB** problem, we delay 100 milliseconds and try to delete again.  UpÙB** to MX_DELETION_ATTEMPTs deletion attempts are run before giving½** up and returning an error.¢*/µstatic int winDelete(Ù5  sqlite3_vfs *pVfs,          /* Not used on win32 */Ù:  const char *zFilename,      /* Name of file to delete */Ù5  int syncDir                 /* Not used on win32 */¢){®  int cnt = 0;©  int rc;­  DWORD attr;¶  DWORD lastErrno = 0;³  void *zConverted;¹  UNUSED_PARAMETER(pVfs);¼  UNUSED_PARAMETER(syncDir); Ù.  SimulateIOError(return SQLITE_IOERR_DELETE);Ù@  OSTRACE(("DELETE name=%s, syncDir=%d\n", zFilename, syncDir)); Ù5  zConverted = winConvertFromUtf8Filename(zFilename);¶  if( zConverted==0 ){ÙD    OSTRACE(("DELETE name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  }±  if( osIsNT() ){¨    do {³#if SQLITE_OS_WINRTÙ*      WIN32_FILE_ATTRIBUTE_DATA sAttrData;Ù/      memset(&sAttrData, 0, sizeof(sAttrData));ÙD      if ( osGetFileAttributesExW(zConverted, GetFileExInfoStandard,Ù0                                  &sAttrData) ){Ù*        attr = sAttrData.dwFileAttributes;¬      }else{Ù%        lastErrno = osGetLastError();Ù+        if( lastErrno==ERROR_FILE_NOT_FOUNDÙ.         || lastErrno==ERROR_PATH_NOT_FOUND ){Ù=          rc = SQLITE_IOERR_DELETE_NOENT; /* Already gone? */®        }else{¼          rc = SQLITE_ERROR;©        }®        break;§      }¥#elseÙ.      attr = osGetFileAttributesW(zConverted);¦#endifÙ+      if ( attr==INVALID_FILE_ATTRIBUTES ){Ù%        lastErrno = osGetLastError();Ù+        if( lastErrno==ERROR_FILE_NOT_FOUNDÙ.         || lastErrno==ERROR_PATH_NOT_FOUND ){Ù=          rc = SQLITE_IOERR_DELETE_NOENT; /* Already gone? */®        }else{¼          rc = SQLITE_ERROR;©        }®        break;§      }Ù+      if ( attr&FILE_ATTRIBUTE_DIRECTORY ){Ù,        rc = SQLITE_ERROR; /* Files only. */®        break;§      }Ù'      if ( osDeleteFileW(zConverted) ){Ù)        rc = SQLITE_OK; /* Deleted OK. */®        break;§      }Ù.      if ( !winRetryIoerr(&cnt, &lastErrno) ){Ù1        rc = SQLITE_ERROR; /* No more retries. */®        break;§      }¯    } while(1);£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{¨    do {Ù.      attr = osGetFileAttributesA(zConverted);Ù+      if ( attr==INVALID_FILE_ATTRIBUTES ){Ù%        lastErrno = osGetLastError();Ù+        if( lastErrno==ERROR_FILE_NOT_FOUNDÙ.         || lastErrno==ERROR_PATH_NOT_FOUND ){Ù=          rc = SQLITE_IOERR_DELETE_NOENT; /* Already gone? */®        }else{¼          rc = SQLITE_ERROR;©        }®        break;§      }Ù+      if ( attr&FILE_ATTRIBUTE_DIRECTORY ){Ù,        rc = SQLITE_ERROR; /* Files only. */®        break;§      }Ù'      if ( osDeleteFileA(zConverted) ){Ù)        rc = SQLITE_OK; /* Deleted OK. */®        break;§      }Ù.      if ( !winRetryIoerr(&cnt, &lastErrno) ){Ù1        rc = SQLITE_ERROR; /* No more retries. */®        break;§      }¯    } while(1);£  }¦#endifÙ,  if( rc && rc!=SQLITE_IOERR_DELETE_NOENT ){ÙM    rc = winLogError(SQLITE_IOERR_DELETE, lastErrno, "winDelete", zFilename);¨  }else{¿    winLogIoerr(cnt, __LINE__);£  }»  sqlite3_free(zConverted);ÙF  OSTRACE(("DELETE name=%s, rc=%s\n", zFilename, sqlite3ErrName(rc)));¬  return rc;¡} ¢/*Ù,** Check the existence and status of a file.¢*/µstatic int winAccess(Ù4  sqlite3_vfs *pVfs,         /* Not used on win32 */Ù8  const char *zFilename,     /* Name of file to check */ÙD  int flags,                 /* Type of test to make on this file */Ù.  int *pResOut               /* OUT: Result */¢){­  DWORD attr;­  int rc = 0;¶  DWORD lastErrno = 0;³  void *zConverted;¹  UNUSED_PARAMETER(pVfs); Ù1  SimulateIOError( return SQLITE_IOERR_ACCESS; );Ù4  OSTRACE(("ACCESS name=%s, flags=%x, pResOut=%p\n",Ù'           zFilename, flags, pResOut)); Ù5  zConverted = winConvertFromUtf8Filename(zFilename);¶  if( zConverted==0 ){ÙD    OSTRACE(("ACCESS name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  }±  if( osIsNT() ){°    int cnt = 0;Ù(    WIN32_FILE_ATTRIBUTE_DATA sAttrData;Ù-    memset(&sAttrData, 0, sizeof(sAttrData));Ù=    while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,Ù3                             GetFileExInfoStandard,ÙP                             &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}­    if( rc ){ÙD      /* For an SQLITE_ACCESS_EXISTS query, treat a zero-length fileÙ!      ** as if it does not exist.¨      */Ù(      if(    flags==SQLITE_ACCESS_EXISTSÙ'          && sAttrData.nFileSizeHigh==0Ù)          && sAttrData.nFileSizeLow==0 ){Ù'        attr = INVALID_FILE_ATTRIBUTES;¬      }else{Ù*        attr = sAttrData.dwFileAttributes;§      }ª    }else{Ù!      winLogIoerr(cnt, __LINE__);ÙO      if( lastErrno!=ERROR_FILE_NOT_FOUND && lastErrno!=ERROR_PATH_NOT_FOUND ){Ù!        sqlite3_free(zConverted);ÙG        return winLogError(SQLITE_IOERR_ACCESS, lastErrno, "winAccess",Ù&                           zFilename);¬      }else{Ù'        attr = INVALID_FILE_ATTRIBUTES;§      }¥    }£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{Ù3    attr = osGetFileAttributesA((char*)zConverted);£  }¦#endif»  sqlite3_free(zConverted);²  switch( flags ){¼    case SQLITE_ACCESS_READ:¾    case SQLITE_ACCESS_EXISTS:Ù)      rc = attr!=INVALID_FILE_ATTRIBUTES;¬      break;Ù!    case SQLITE_ACCESS_READWRITE:Ù+      rc = attr!=INVALID_FILE_ATTRIBUTES &&Ù1             (attr & FILE_ATTRIBUTE_READONLY)==0;¬      break;¬    default:Ù(      assert(!"Invalid flags argument");£  }°  *pResOut = rc;ÙE  OSTRACE(("ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",Ù*           zFilename, pResOut, *pResOut));³  return SQLITE_OK;¡} ¢/*ÙI** Returns non-zero if the specified path name starts with a drive letterÙ!** followed by a colon character.¢*/Ù%static BOOL winIsDriveLetterAndColon(·  const char *zPathname¢){Ù?  return ( sqlite3Isalpha(zPathname[0]) && zPathname[1]==':' );¡} ¢/*ÙK** Returns non-zero if the specified path name should be used verbatim.  IfÙL** non-zero is returned from this function, the calling function must simplyÙL** use the provided path name verbatim -OR- resolve it into a full path nameÙ?** using the GetFullPathName Win32 API function (if available).¢*/Ù"static BOOL winIsVerbatimPathname(·  const char *zPathname¢){¤  /*ÙN  ** If the path name starts with a forward slash or a backslash, it is eitherÙN  ** a legal UNC name, a volume relative path, or an absolute path name in theÙM  ** "Unix" format on Windows.  There is no easy way to differentiate betweenÙM  ** the final two cases; therefore, we return the safer return value of TRUEÙB  ** so that callers of this function will simply use it verbatim.¤  */Ù#  if ( winIsDirSep(zPathname[0]) ){°    return TRUE;£  } ¤  /*ÙL  ** If the path name starts with a letter and a colon it is either a volumeÙJ  ** relative path or an absolute path.  Callers of this function must notÙM  ** attempt to treat it as a relative path name (i.e. they should simply use²  ** it verbatim).¤  */Ù-  if ( winIsDriveLetterAndColon(zPathname) ){°    return TRUE;£  } ¤  /*ÙO  ** If we get to this point, the path name should almost certainly be a purelyÙO  ** relative one (i.e. not a UNC name, not absolute, and not volume relative).¤  */¯  return FALSE;¡} ¢/*ÙA** Turn a relative pathname into a full pathname.  Write the fullÙB** pathname into zOut[].  zOut[] will be at least pVfs->mxPathname±** bytes in size.¢*/»static int winFullPathname(Ù;  sqlite3_vfs *pVfs,            /* Pointer to vfs object */ÙB  const char *zRelative,        /* Possibly relative input path */ÙD  int nFull,                    /* Size of output buffer in bytes */Ù3  char *zFull                   /* Output buffer */¢){Ù@#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)®  DWORD nByte;³  void *zConverted;­  char *zOut;¦#endif ÙE  /* If this path name begins with "/X:", where "X" is any alphabeticÙ:  ** character, discard the initial "/" from the pathname.¤  */ÙC  if( zRelative[0]=='/' && winIsDriveLetterAndColon(zRelative+1) ){°    zRelative++;£  } ·#if defined(__CYGWIN__)Ù)  SimulateIOError( return SQLITE_ERROR );º  UNUSED_PARAMETER(nFull);Ù$  assert( nFull>=pVfs->mxPathname );ÙE  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){¦    /*ÙB    ** NOTE: We are dealing with a relative path name and the dataÙD    **       directory has been set.  Therefore, use it as the basisÙA    **       for converting the relative path name to an absoluteÙ>    **       one by prepending the data directory and a slash.¦    */Ù9    char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );°    if( !zOut ){Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }¹    if( cygwin_conv_path(ÙB            (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A) |ÙC            CCP_RELATIVE, zRelative, zOut, pVfs->mxPathname+1)<0 ){¹      sqlite3_free(zOut);Ù@      return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,Ù8                         "winFullPathname1", zRelative);ª    }else{Ù3      char *zUtf8 = winConvertToUtf8Filename(zOut);³      if( !zUtf8 ){»        sqlite3_free(zOut);Ù'        return SQLITE_IOERR_NOMEM_BKPT;§      }ÙE      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",ÙF                       sqlite3_data_directory, winGetDirSep(), zUtf8);º      sqlite3_free(zUtf8);¹      sqlite3_free(zOut);¥    }¨  }else{Ù9    char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );°    if( !zOut ){Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }¹    if( cygwin_conv_path(ÙA            (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A),Ù5            zRelative, zOut, pVfs->mxPathname+1)<0 ){¹      sqlite3_free(zOut);Ù@      return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,Ù8                         "winFullPathname2", zRelative);ª    }else{Ù3      char *zUtf8 = winConvertToUtf8Filename(zOut);³      if( !zUtf8 ){»        sqlite3_free(zOut);Ù'        return SQLITE_IOERR_NOMEM_BKPT;§      }ÙI      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zUtf8);º      sqlite3_free(zUtf8);¹      sqlite3_free(zOut);¥    }£  }³  return SQLITE_OK;¦#endif Ù@#if (SQLITE_OS_WINCE || SQLITE_OS_WINRT) && !defined(__CYGWIN__)Ù)  SimulateIOError( return SQLITE_ERROR );ÙE  /* WinCE has no concept of a relative pathname, or so I am told. */ÙG  /* WinRT has no way to convert a relative path to an absolute one. */ÙE  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){¦    /*ÙB    ** NOTE: We are dealing with a relative path name and the dataÙD    **       directory has been set.  Therefore, use it as the basisÙA    **       for converting the relative path name to an absoluteÙB    **       one by prepending the data directory and a backslash.¦    */ÙC    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",ÙH                     sqlite3_data_directory, winGetDirSep(), zRelative);¨  }else{ÙK    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zRelative);£  }³  return SQLITE_OK;¦#endif Ù@#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)ÙC  /* It's odd to simulate an io-error here, but really this is justÙG  ** using the io-error infrastructure to test that SQLite handles thisÙD  ** function failing. This function could fail if, for example, theÙ1  ** current working directory has been unlinked.¤  */Ù)  SimulateIOError( return SQLITE_ERROR );ÙE  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){¦    /*ÙB    ** NOTE: We are dealing with a relative path name and the dataÙD    **       directory has been set.  Therefore, use it as the basisÙA    **       for converting the relative path name to an absoluteÙB    **       one by prepending the data directory and a backslash.¦    */ÙC    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",ÙH                     sqlite3_data_directory, winGetDirSep(), zRelative);µ    return SQLITE_OK;£  }Ù5  zConverted = winConvertFromUtf8Filename(zRelative);¶  if( zConverted==0 ){Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  }±  if( osIsNT() ){±    LPWSTR zTemp;Ù=    nByte = osGetFullPathNameW((LPCWSTR)zConverted, 0, 0, 0);³    if( nByte==0 ){¿      sqlite3_free(zConverted);ÙD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ù8                         "winFullPathname1", zRelative);¥    }¯    nByte += 3;Ù8    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );³    if( zTemp==0 ){¿      sqlite3_free(zConverted);Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }ÙE    nByte = osGetFullPathNameW((LPCWSTR)zConverted, nByte, zTemp, 0);³    if( nByte==0 ){¿      sqlite3_free(zConverted);º      sqlite3_free(zTemp);ÙD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ù8                         "winFullPathname2", zRelative);¥    }½    sqlite3_free(zConverted);Ù#    zOut = winUnicodeToUtf8(zTemp);¸    sqlite3_free(zTemp);£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{°    char *zTemp;Ù;    nByte = osGetFullPathNameA((char*)zConverted, 0, 0, 0);³    if( nByte==0 ){¿      sqlite3_free(zConverted);ÙD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ù8                         "winFullPathname3", zRelative);¥    }¯    nByte += 3;Ù8    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );³    if( zTemp==0 ){¿      sqlite3_free(zConverted);Ù%      return SQLITE_IOERR_NOMEM_BKPT;¥    }ÙC    nByte = osGetFullPathNameA((char*)zConverted, nByte, zTemp, 0);³    if( nByte==0 ){¿      sqlite3_free(zConverted);º      sqlite3_free(zTemp);ÙD      return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),Ù8                         "winFullPathname4", zRelative);¥    }½    sqlite3_free(zConverted);Ù5    zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());¸    sqlite3_free(zTemp);£  }¦#endif­  if( zOut ){ÙF    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zOut);·    sqlite3_free(zOut);µ    return SQLITE_OK;¨  }else{Ù#    return SQLITE_IOERR_NOMEM_BKPT;£  }¦#endif¡} Ù"#ifndef SQLITE_OMIT_LOAD_EXTENSION¢/*Ù@** Interfaces for opening a shared library, finding entry pointsÙ=** within the shared library, and closing the shared library.¢*/ÙAstatic void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){«  HANDLE h;·#if defined(__CYGWIN__)Ù!  int nFull = pVfs->mxPathname+1;Ù+  char *zFull = sqlite3MallocZero( nFull );·  void *zConverted = 0;±  if( zFull==0 ){ÙB    OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));­    return 0;£  }ÙB  if( winFullPathname(pVfs, zFilename, nFull, zFull)!=SQLITE_OK ){¸    sqlite3_free(zFull);ÙB    OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));­    return 0;£  }Ù1  zConverted = winConvertFromUtf8Filename(zFull);¶  sqlite3_free(zFull);¥#elseÙ;  void *zConverted = winConvertFromUtf8Filename(zFilename);¹  UNUSED_PARAMETER(pVfs);¦#endif¶  if( zConverted==0 ){ÙB    OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));­    return 0;£  }±  if( osIsNT() ){³#if SQLITE_OS_WINRTÙ6    h = osLoadPackagedLibrary((LPCWSTR)zConverted, 0);¥#elseÙ,    h = osLoadLibraryW((LPCWSTR)zConverted);¦#endif£  }¼#ifdef SQLITE_WIN32_HAS_ANSI§  else{Ù*    h = osLoadLibraryA((char*)zConverted);£  }¦#endifÙ@  OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)h));»  sqlite3_free(zConverted);²  return (void*)h;¡}ÙCstatic void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){¹  UNUSED_PARAMETER(pVfs);Ù6  winGetLastErrorMsg(osGetLastError(), nBuf, zBufOut);¡}ÙKstatic void (*winDlSym(sqlite3_vfs *pVfs,void *pH,const char *zSym))(void){¯  FARPROC proc;¹  UNUSED_PARAMETER(pVfs);Ù-  proc = osGetProcAddressA((HANDLE)pH, zSym);Ù6  OSTRACE(("DLSYM handle=%p, symbol=%s, address=%p\n",Ù*           (void*)pH, zSym, (void*)proc));½  return (void(*)(void))proc;¡}Ù9static void winDlClose(sqlite3_vfs *pVfs, void *pHandle){¹  UNUSED_PARAMETER(pVfs);Ù!  osFreeLibrary((HANDLE)pHandle);Ù3  OSTRACE(("DLCLOSE handle=%p\n", (void*)pHandle));¡}Ù5#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */¶  #define winDlOpen  0¶  #define winDlError 0¶  #define winDlSym   0¶  #define winDlClose 0¦#endif Ù4/* State information for the randomness gatherer. */Ù/typedef struct EntropyGatherer EntropyGatherer;¸struct EntropyGatherer {Ù;  unsigned char *a;   /* Gather entropy into this buffer */Ù0  int na;             /* Size of a[] in bytes */Ù4  int i;              /* XOR next input into a[i] */Ù9  int nXor;           /* Number of XOR operations done */¢}; Ù=#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)Ù%/* Mix sz bytes of entropy into p. */ÙDstatic void xorMemory(EntropyGatherer *p, unsigned char *x, int sz){«  int j, k;¾  for(j=0, k=p->i; j<sz; j++){¶    p->a[k++] ^= x[j];¹    if( k>=p->na ) k = 0;£  }«  p->i = k;°  p->nXor += sz;¡}ÙF#endif /* !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS) */ ¢/*Ù2** Write up to nBuf bytes of randomness into zBuf.¢*/ÙBstatic int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){Ù;#if defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS)¹  UNUSED_PARAMETER(pVfs);¸  memset(zBuf, 0, nBuf);®  return nBuf;¥#else´  EntropyGatherer e;¹  UNUSED_PARAMETER(pVfs);¸  memset(zBuf, 0, nBuf);½  e.a = (unsigned char*)zBuf;®  e.na = nBuf;­  e.nXor = 0;ª  e.i = 0;£  {±    SYSTEMTIME x;¸    osGetSystemTime(&x);Ù:    xorMemory(&e, (unsigned char*)&x, sizeof(SYSTEMTIME));£  }£  {Ù(    DWORD pid = osGetCurrentProcessId();Ù7    xorMemory(&e, (unsigned char*)&pid, sizeof(DWORD));£  }³#if SQLITE_OS_WINRT£  {Ù'    ULONGLONG cnt = osGetTickCount64();Ù;    xorMemory(&e, (unsigned char*)&cnt, sizeof(ULONGLONG));£  }¥#else£  {Ù!    DWORD cnt = osGetTickCount();Ù7    xorMemory(&e, (unsigned char*)&cnt, sizeof(DWORD));£  }¼#endif /* SQLITE_OS_WINRT */£  {´    LARGE_INTEGER i;Ù"    osQueryPerformanceCounter(&i);Ù=    xorMemory(&e, (unsigned char*)&i, sizeof(LARGE_INTEGER));£  }ÙA#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID£  {¬    UUID id;Ù!    memset(&id, 0, sizeof(UUID));¶    osUuidCreate(&id);Ù5    xorMemory(&e, (unsigned char*)&id, sizeof(UUID));Ù!    memset(&id, 0, sizeof(UUID));Ù     osUuidCreateSequential(&id);Ù5    xorMemory(&e, (unsigned char*)&id, sizeof(UUID));£  }ÙJ#endif /* !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID */Ù%  return e.nXor>nBuf ? nBuf : e.nXor;ÙD#endif /* defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS) */¡}  ¢/*Ù>** Sleep for a little while.  Return the amount of time slept.¢*/Ù5static int winSleep(sqlite3_vfs *pVfs, int microsec){Ù+  sqlite3_win32_sleep((microsec+999)/1000);¹  UNUSED_PARAMETER(pVfs);Ù$  return ((microsec+999)/1000)*1000;¡} ¢/*ÙH** The following variable, if set to a non-zero value, is interpreted asÙD** the number of seconds since 1970 and is used to set the result ofÙ)** sqlite3OsCurrentTime() during testing.¢*/²#ifdef SQLITE_TESTÙWSQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */¦#endif ¢/*ÙL** Find the current time (in Universal Coordinated Time).  Write into *piNowÙI** the current time and date as a Julian Day number times 86_400_000.  InÙM** other words, write into *piNow the number of milliseconds since the JulianÙG** epoch of noon in Greenwich on November 24, 4714 B.C according to theÙ ** proleptic Gregorian calendar.¢**ÙJ** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date³** cannot be found.¢*/ÙHstatic int winCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow){ÙD  /* FILETIME structure is a 64-bit value representing the number ofÙE     100-nanosecond intervals since January 1, 1601 (= JD 2305813.5).¤  */®  FILETIME ft;ÙP  static const sqlite3_int64 winFiletimeEpoch = 23058135*(sqlite3_int64)8640000;²#ifdef SQLITE_TESTÙI  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;¦#endifÙ5  /* 2^32 - to avoid use of LL and warnings in gcc */Ù,  static const sqlite3_int64 max32BitValue =Ù=      (sqlite3_int64)2000000000 + (sqlite3_int64)2000000000 +¿      (sqlite3_int64)294967296; ³#if SQLITE_OS_WINCE²  SYSTEMTIME time;¹  osGetSystemTime(&time);Ù9  /* if SystemTimeToFileTime() fails, it returns zero. */Ù*  if (!osSystemTimeToFileTime(&time,&ft)){¸    return SQLITE_ERROR;£  }¥#elseÙ#  osGetSystemTimeAsFileTime( &ft );¦#endif ½  *piNow = winFiletimeEpoch +ÙA            ((((sqlite3_int64)ft.dwHighDateTime)*max32BitValue) +ÙE               (sqlite3_int64)ft.dwLowDateTime)/(sqlite3_int64)10000; ²#ifdef SQLITE_TEST½  if( sqlite3_current_time ){ÙB    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;£  }¦#endif¹  UNUSED_PARAMETER(pVfs);³  return SQLITE_OK;¡} ¢/*ÙD** Find the current time (in Universal Coordinated Time).  Write theÙ?** current time and date as a Julian Day number into *prNow andÙ<** return 0.  Return 1 if the time and date cannot be found.¢*/Ù<static int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){©  int rc;²  sqlite3_int64 i;Ù%  rc = winCurrentTimeInt64(pVfs, &i);¬  if( !rc ){º    *prNow = i/86400000.0;£  }¬  return rc;¡} ¢/*Ù=** The idea is that this function works like a combination ofÙ>** GetLastError() and FormatMessage() on Windows (or errno andÙ=** strerror_r() on Unix). After an error is returned by an OSÙ=** function, SQLite calls this function with zBuf pointing toÙ;** a buffer of nBuf bytes. The OS layer should populate theÙ;** buffer with a nul-terminated UTF-8 encoded error messageÙC** describing the last IO error to have occurred within the callingª** thread.¢**Ù=** If the error message is too large for the supplied buffer,Ù<** it should be truncated. The return value of xGetLastErrorÙ?** is zero if the error message fits in the buffer, or non-zeroÙE** otherwise (if the message was truncated). If non-zero is returned,ÙC** then it is not necessary to include the nul-terminator character¸** in the output buffer.¢**Ù=** Not supplying an error message will have no adverse effectÙ=** on SQLite. It is fine to have an implementation that never¼** returns an error message:¢**Ù@**   int xGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){½**     assert(zBuf[0]=='\0');°**     return 0;¦**   }¢**ÙC** However if an error message is supplied, it will be incorporatedÙ?** by sqlite into the error message available to the user usingÙ?** sqlite3_errmsg(), possibly making IO errors easier to debug.¢*/ÙDstatic int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){½  DWORD e = osGetLastError();¹  UNUSED_PARAMETER(pVfs);Ù1  if( nBuf>0 ) winGetLastErrorMsg(e, nBuf, zBuf);«  return e;¡} ¢/*Ù>** Initialize and deinitialize the operating system interface.¢*/Ù%SQLITE_API int sqlite3_os_init(void){¿  static sqlite3_vfs winVfs = {Ù)    3,                     /* iVersion */Ù)    sizeof(winFile),       /* szOsFile */Ù1    SQLITE_WIN32_MAX_PATH_BYTES, /* mxPathname */Ù&    0,                     /* pNext */Ù&    "win32",               /* zName */Ù)    &winAppData,           /* pAppData */Ù&    winOpen,               /* xOpen */Ù(    winDelete,             /* xDelete */Ù(    winAccess,             /* xAccess */Ù.    winFullPathname,       /* xFullPathname */Ù(    winDlOpen,             /* xDlOpen */Ù)    winDlError,            /* xDlError */Ù'    winDlSym,              /* xDlSym */Ù)    winDlClose,            /* xDlClose */Ù,    winRandomness,         /* xRandomness */Ù'    winSleep,              /* xSleep */Ù-    winCurrentTime,        /* xCurrentTime */Ù.    winGetLastError,       /* xGetLastError */Ù2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ù/    winSetSystemCall,      /* xSetSystemCall */Ù/    winGetSystemCall,      /* xGetSystemCall */Ù0    winNextSystemCall,     /* xNextSystemCall */¤  };Ù"#if defined(SQLITE_WIN32_HAS_WIDE)Ù'  static sqlite3_vfs winLongPathVfs = {Ù)    3,                     /* iVersion */Ù)    sizeof(winFile),       /* szOsFile */Ù1    SQLITE_WINNT_MAX_PATH_BYTES, /* mxPathname */Ù&    0,                     /* pNext */Ù&    "win32-longpath",      /* zName */Ù)    &winAppData,           /* pAppData */Ù&    winOpen,               /* xOpen */Ù(    winDelete,             /* xDelete */Ù(    winAccess,             /* xAccess */Ù.    winFullPathname,       /* xFullPathname */Ù(    winDlOpen,             /* xDlOpen */Ù)    winDlError,            /* xDlError */Ù'    winDlSym,              /* xDlSym */Ù)    winDlClose,            /* xDlClose */Ù,    winRandomness,         /* xRandomness */Ù'    winSleep,              /* xSleep */Ù-    winCurrentTime,        /* xCurrentTime */Ù.    winGetLastError,       /* xGetLastError */Ù2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ù/    winSetSystemCall,      /* xSetSystemCall */Ù/    winGetSystemCall,      /* xGetSystemCall */Ù0    winNextSystemCall,     /* xNextSystemCall */¤  };¦#endifÙ%  static sqlite3_vfs winNolockVfs = {Ù)    3,                     /* iVersion */Ù)    sizeof(winFile),       /* szOsFile */Ù1    SQLITE_WIN32_MAX_PATH_BYTES, /* mxPathname */Ù&    0,                     /* pNext */Ù&    "win32-none",          /* zName */Ù)    &winNolockAppData,     /* pAppData */Ù&    winOpen,               /* xOpen */Ù(    winDelete,             /* xDelete */Ù(    winAccess,             /* xAccess */Ù.    winFullPathname,       /* xFullPathname */Ù(    winDlOpen,             /* xDlOpen */Ù)    winDlError,            /* xDlError */Ù'    winDlSym,              /* xDlSym */Ù)    winDlClose,            /* xDlClose */Ù,    winRandomness,         /* xRandomness */Ù'    winSleep,              /* xSleep */Ù-    winCurrentTime,        /* xCurrentTime */Ù.    winGetLastError,       /* xGetLastError */Ù2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ù/    winSetSystemCall,      /* xSetSystemCall */Ù/    winGetSystemCall,      /* xGetSystemCall */Ù0    winNextSystemCall,     /* xNextSystemCall */¤  };Ù"#if defined(SQLITE_WIN32_HAS_WIDE)Ù-  static sqlite3_vfs winLongPathNolockVfs = {Ù)    3,                     /* iVersion */Ù)    sizeof(winFile),       /* szOsFile */Ù1    SQLITE_WINNT_MAX_PATH_BYTES, /* mxPathname */Ù&    0,                     /* pNext */Ù&    "win32-longpath-none", /* zName */Ù)    &winNolockAppData,     /* pAppData */Ù&    winOpen,               /* xOpen */Ù(    winDelete,             /* xDelete */Ù(    winAccess,             /* xAccess */Ù.    winFullPathname,       /* xFullPathname */Ù(    winDlOpen,             /* xDlOpen */Ù)    winDlError,            /* xDlError */Ù'    winDlSym,              /* xDlSym */Ù)    winDlClose,            /* xDlClose */Ù,    winRandomness,         /* xRandomness */Ù'    winSleep,              /* xSleep */Ù-    winCurrentTime,        /* xCurrentTime */Ù.    winGetLastError,       /* xGetLastError */Ù2    winCurrentTimeInt64,   /* xCurrentTimeInt64 */Ù/    winSetSystemCall,      /* xSetSystemCall */Ù/    winGetSystemCall,      /* xGetSystemCall */Ù0    winNextSystemCall,     /* xNextSystemCall */¤  };¦#endif Ù@  /* Double-check that the aSyscall[] array has been constructedÙ2  ** correctly.  See ticket [bb3a86e890c8e96ab] */Ù$  assert( ArraySize(aSyscall)==80 ); Ù-  /* get memory map allocation granularity */Ù.  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));³#if SQLITE_OS_WINRTÙ%  osGetNativeSystemInfo(&winSysInfo);¥#else¿  osGetSystemInfo(&winSysInfo);¦#endifÙ1  assert( winSysInfo.dwAllocationGranularity>0 );Ù$  assert( winSysInfo.dwPageSize>0 ); Ù#  sqlite3_vfs_register(&winVfs, 1); Ù"#if defined(SQLITE_WIN32_HAS_WIDE)Ù+  sqlite3_vfs_register(&winLongPathVfs, 0);¦#endif Ù)  sqlite3_vfs_register(&winNolockVfs, 0); Ù"#if defined(SQLITE_WIN32_HAS_WIDE)Ù1  sqlite3_vfs_register(&winLongPathNolockVfs, 0);¦#endif ·#ifndef SQLITE_OMIT_WALÙ;  winBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);¦#endif ³  return SQLITE_OK;¡} Ù$SQLITE_API int sqlite3_os_end(void){³#if SQLITE_OS_WINRT·  if( sleepObj!=NULL ){¼    osCloseHandle(sleepObj);´    sleepObj = NULL;£  }¦#endif ·#ifndef SQLITE_OMIT_WAL±  winBigLock = 0;¦#endif ³  return SQLITE_OK;¡} º#endif /* SQLITE_OS_WIN */ ÙO/************** End of os_win.c **********************************************/ÙO/************** Begin file memdb.c *******************************************/¢/*­** 2016-09-07¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙN******************************************************************************¢**ÙL** This file implements an in-memory VFS. A database is held as a contiguous³** block of memory.¢**Ù>** This file also implements interface sqlite3_serialize() and¹** sqlite3_deserialize().¢*/Ù #ifdef SQLITE_ENABLE_DESERIALIZE¼/* #include "sqliteInt.h" */ ¢/*Ù6** Forward declaration of objects used by this utility¢*/Ù"typedef struct sqlite3_vfs MemVfs;¿typedef struct MemFile MemFile; ÙF/* Access to a lower-level VFS that (might) implement dynamic loading,½** access to randomness, etc.¢*/Ù2#define ORIGVFS(p) ((sqlite3_vfs*)((p)->pAppData)) ²/* An open file */°struct MemFile {Ù2  sqlite3_file base;              /* IO methods */Ù8  sqlite3_int64 sz;               /* Size of the file */Ù@  sqlite3_int64 szMax;            /* Space allocated to aData */Ù;  unsigned char *aData;           /* content of the file */ÙE  int nMmap;                      /* Number of memory mapped pages */Ù-  unsigned mFlags;                /* Flags */ÙJ  int eLock;                      /* Most recent lock against this file */¢}; ¢/*¶** Methods for MemFile¢*/Ù%static int memdbClose(sqlite3_file*);ÙJstatic int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);ÙOstatic int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);Ù<static int memdbTruncate(sqlite3_file*, sqlite3_int64 size);Ù/static int memdbSync(sqlite3_file*, int flags);Ù>static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);Ù)static int memdbLock(sqlite3_file*, int);ÙP/* static int memdbCheckReservedLock(sqlite3_file*, int *pResOut);// not used */Ù?static int memdbFileControl(sqlite3_file*, int op, void *pArg);Ù</* static int memdbSectorSize(sqlite3_file*); // not used */Ù5static int memdbDeviceCharacteristics(sqlite3_file*);ÙOstatic int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);ÙEstatic int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p); ¢/*µ** Methods for MemVfs¢*/ÙMstatic int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);ÙK/* static int memdbDelete(sqlite3_vfs*, const char *zName, int syncDir); */ÙJstatic int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);ÙOstatic int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);Ù>static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);ÙAstatic void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);ÙMstatic void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);Ù.static void memdbDlClose(sqlite3_vfs*, void*);Ù@static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);Ù6static int memdbSleep(sqlite3_vfs*, int microseconds);Ù9/* static int memdbCurrentTime(sqlite3_vfs*, double*); */Ù8static int memdbGetLastError(sqlite3_vfs*, int, char *);Ù?static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*); Ù static sqlite3_vfs memdb_vfs = {Ù-  2,                           /* iVersion */ÙC  0,                           /* szOsFile (set when registered) */Ù/  1024,                        /* mxPathname */Ù*  0,                           /* pNext */Ù*  "memdb",                     /* zName */ÙD  0,                           /* pAppData (set when registered) */ Ù*  memdbOpen,                   /* xOpen */Ù,  0, /* memdbDelete, */        /* xDelete */Ù,  memdbAccess,                 /* xAccess */Ù2  memdbFullPathname,           /* xFullPathname */Ù,  memdbDlOpen,                 /* xDlOpen */Ù-  memdbDlError,                /* xDlError */Ù+  memdbDlSym,                  /* xDlSym */Ù-  memdbDlClose,                /* xDlClose */Ù0  memdbRandomness,             /* xRandomness */Ù+  memdbSleep,                  /* xSleep */Ù1  0, /* memdbCurrentTime, */   /* xCurrentTime */Ù2  memdbGetLastError,           /* xGetLastError */Ù6  memdbCurrentTimeInt64        /* xCurrentTimeInt64 */¢}; Ù4static const sqlite3_io_methods memdb_io_methods = {Ù0  3,                              /* iVersion */Ù/  memdbClose,                      /* xClose */Ù.  memdbRead,                       /* xRead */Ù/  memdbWrite,                      /* xWrite */Ù2  memdbTruncate,                   /* xTruncate */Ù.  memdbSync,                       /* xSync */Ù2  memdbFileSize,                   /* xFileSize */Ù.  memdbLock,                       /* xLock */ÙN  memdbLock,                       /* xUnlock - same as xLock in this case */ Ù;  0, /* memdbCheckReservedLock, */ /* xCheckReservedLock */Ù5  memdbFileControl,                /* xFileControl */Ù4  0, /* memdbSectorSize,*/         /* xSectorSize */Ù?  memdbDeviceCharacteristics,      /* xDeviceCharacteristics */Ù0  0,                               /* xShmMap */Ù1  0,                               /* xShmLock */Ù4  0,                               /* xShmBarrier */Ù2  0,                               /* xShmUnmap */Ù/  memdbFetch,                      /* xFetch */Ù1  memdbUnfetch                     /* xUnfetch */¢};   ¢/*·** Close an memdb-file.¢**ÙE** The pData pointer is owned by the application, so there is nothing«** to free.¢*/Ù+static int memdbClose(sqlite3_file *pFile){Ù   MemFile *p = (MemFile *)pFile;ÙJ  if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ) sqlite3_free(p->aData);³  return SQLITE_OK;¡} ¢/*Ù ** Read data from an memdb-file.¢*/µstatic int memdbRead(·  sqlite3_file *pFile, ®  void *zBuf, ¬  int iAmt, ´  sqlite_int64 iOfst¢){Ù   MemFile *p = (MemFile *)pFile;¹  if( iOfst+iAmt>p->sz ){º    memset(zBuf, 0, iAmt);ÙB    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);Ù#    return SQLITE_IOERR_SHORT_READ;£  }Ù%  memcpy(zBuf, p->aData+iOfst, iAmt);³  return SQLITE_OK;¡} ¢/*ÙA** Try to enlarge the memory allocation to hold at least sz bytes¢*/Ù9static int memdbEnlarge(MemFile *p, sqlite3_int64 newSz){¶  unsigned char *pNew;ÙE  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || p->nMmap>0 ){·    return SQLITE_FULL;£  }Ù,  pNew = sqlite3_realloc64(p->aData, newSz);Ù$  if( pNew==0 ) return SQLITE_NOMEM;²  p->aData = pNew;³  p->szMax = newSz;³  return SQLITE_OK;¡} ¢/*¿** Write data to an memdb-file.¢*/¶static int memdbWrite(¶  sqlite3_file *pFile,°  const void *z,«  int iAmt,´  sqlite_int64 iOfst¢){Ù   MemFile *p = (MemFile *)pFile;¹  if( iOfst+iAmt>p->sz ){«    int rc;»    if( iOfst+iAmt>p->szMaxÙ9     && (rc = memdbEnlarge(p, (iOfst+iAmt)*2))!=SQLITE_OK¦    ){°      return rc;¥    }Ù=    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);·    p->sz = iOfst+iAmt;£  }Ù"  memcpy(p->aData+iOfst, z, iAmt);³  return SQLITE_OK;¡} ¢/*º** Truncate an memdb-file.¢**ÙG** In rollback mode (which is always the case for memdb, as it does notÙA** support WAL mode) the truncate() method is only used to reduceÙ2** the size of a file, never to increase the size.¢*/ÙAstatic int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){Ù   MemFile *p = (MemFile *)pFile;Ù-  if( NEVER(size>p->sz) ) return SQLITE_FULL;°  p->sz = size; ³  return SQLITE_OK;¡} ¢/*¶** Sync an memdb-file.¢*/Ù5static int memdbSync(sqlite3_file *pFile, int flags){³  return SQLITE_OK;¡} ¢/*Ù1** Return the current file-size of an memdb-file.¢*/ÙCstatic int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){Ù   MemFile *p = (MemFile *)pFile;±  *pSize = p->sz;³  return SQLITE_OK;¡} ¢/*¶** Lock an memdb-file.¢*/Ù5static int memdbLock(sqlite3_file *pFile, int eLock){Ù   MemFile *p = (MemFile *)pFile;³  p->eLock = eLock;³  return SQLITE_OK;¡} ÙA#if 0 /* Never used because memdbAccess() always returns false */¢/*ÙG** Check if another file-handle holds a RESERVED lock on an memdb-file.¢*/ÙEstatic int memdbCheckReservedLock(sqlite3_file *pFile, int *pResOut){¯  *pResOut = 0;³  return SQLITE_OK;¡}¦#endif ¢/*Ù?** File control method. For custom operations on an memdb-file.¢*/ÙEstatic int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){Ù   MemFile *p = (MemFile *)pFile;»  int rc = SQLITE_NOTFOUND;Ù!  if( op==SQLITE_FCNTL_VFSNAME ){ÙG    *(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);³    rc = SQLITE_OK;£  }¬  return rc;¡} ÙA#if 0  /* Not used because of SQLITE_IOCAP_POWERSAFE_OVERWRITE */¢/*Ù5** Return the sector-size in bytes for an memdb-file.¢*/Ù0static int memdbSectorSize(sqlite3_file *pFile){®  return 1024;¡}¦#endif ¢/*ÙE** Return the device characteristic flags supported by an memdb-file.¢*/Ù;static int memdbDeviceCharacteristics(sqlite3_file *pFile){¿  return SQLITE_IOCAP_ATOMIC | Ù+         SQLITE_IOCAP_POWERSAFE_OVERWRITE |Ù#         SQLITE_IOCAP_SAFE_APPEND |Ù!         SQLITE_IOCAP_SEQUENTIAL;¡} Ù*/* Fetch a page of a memory-mapped file */¶static int memdbFetch(¶  sqlite3_file *pFile,¶  sqlite3_int64 iOfst,«  int iAmt,«  void **pp¢){Ù   MemFile *p = (MemFile *)pFile;­  p->nMmap++;Ù"  *pp = (void*)(p->aData + iOfst);³  return SQLITE_OK;¡} Ù"/* Release a memory-mapped page */ÙOstatic int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){Ù   MemFile *p = (MemFile *)pFile;­  p->nMmap--;³  return SQLITE_OK;¡} ¢/*»** Open an mem file handle.¢*/µstatic int memdbOpen(´  sqlite3_vfs *pVfs,´  const char *zName,¶  sqlite3_file *pFile,¬  int flags,°  int *pOutFlags¢){¿  MemFile *p = (MemFile*)pFile;Ù)  if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){ÙO    return ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pFile, flags, pOutFlags);£  }»  memset(p, 0, sizeof(*p));ÙM  p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;ÙH  assert( pOutFlags!=0 );  /* True because flags==SQLITE_OPEN_MAIN_DB */Ù*  *pOutFlags = flags | SQLITE_OPEN_MEMORY;Ù'  p->base.pMethods = &memdb_io_methods;³  return SQLITE_OK;¡} ÙH#if 0 /* Only used to delete rollback journals, master journals, and WALÙO      ** files, none of which exist in memdb.  So this routine is never used */¢/*ÙE** Delete the file located at zPath. If the dirSync argument is true,ÙA** ensure the file-system modifications are synced to disk before­** returning.¢*/ÙJstatic int memdbDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){½  return SQLITE_IOERR_DELETE;¡}¦#endif ¢/*ÙG** Test for access permissions. Return true if the requested permissionÙ$** is available, or false otherwise.¢**ÙD** With memdb, no files ever exist on disk.  So always return false.¢*/·static int memdbAccess(µ  sqlite3_vfs *pVfs, µ  const char *zPath, ­  int flags, ®  int *pResOut¢){¯  *pResOut = 0;³  return SQLITE_OK;¡} ¢/*ÙF** Populate buffer zOut with the full canonical pathname correspondingÙD** to the pathname in zPath. zOut is guaranteed to point to a bufferÙ+** of at least (INST_MAX_PATHNAME+1) bytes.¢*/½static int memdbFullPathname(µ  sqlite3_vfs *pVfs, µ  const char *zPath, ¬  int nOut, ¬  char *zOut¢){Ù,  sqlite3_snprintf(nOut, zOut, "%s", zPath);³  return SQLITE_OK;¡} ¢/*ÙA** Open the dynamic library located at zPath and return a handle.¢*/Ù?static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){Ù6  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);¡} ¢/*ÙG** Populate the buffer zErrMsg (size nByte bytes) with a human readableÙH** utf-8 string describing the most recent error encountered associated º** with dynamic libraries.¢*/ÙFstatic void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){Ù9  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);¡} ¢/*ÙI** Return a pointer to the symbol zSymbol in the dynamic library pHandle.¢*/ÙNstatic void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){Ù7  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);¡} ¢/*Ù,** Close the dynamic library handle pHandle.¢*/Ù;static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){Ù2  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);¡} ¢/*ÙA** Populate the buffer pointed to by zBufOut with nByte bytes of ¯** random data.¢*/ÙHstatic int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){ÙC  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);¡} ¢/*ÙD** Sleep for nMicro microseconds. Return the number of microseconds ²** actually slept.¢*/Ù5static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){Ù6  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);¡} ÙD#if 0  /* Never used.  Modern cores only call xCurrentTimeInt64() */¢/*Ù?** Return the current time as a Julian Day number in *pTimeOut.¢*/ÙAstatic int memdbCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){Ù>  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);¡}¦#endif Ù@static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){Ù;  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);¡}ÙFstatic int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){Ù<  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);¡} ¢/*ÙA** Translate a database connection pointer and schema name into a³** MemFile pointer.¢*/ÙDstatic MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){±  MemFile *p = 0;ÙL  int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);´  if( rc ) return 0;Ù5  if( p->base.pMethods!=&memdb_io_methods ) return 0;«  return p;¡} ¢/*Ù)** Return the serialization of a database¢*/Ù,SQLITE_API unsigned char *sqlite3_serialize(Ù9  sqlite3 *db,              /* The database connection */ÙF  const char *zSchema,      /* Which database within the connection */Ù>  sqlite3_int64 *piSize,    /* Write size here, if not NULL */Ù?  unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */¢){­  MemFile *p;ª  int iDb;­  Btree *pBt;³  sqlite3_int64 sz;±  int szPage = 0;º  sqlite3_stmt *pStmt = 0;¶  unsigned char *pOut;­  char *zSql;©  int rc; ¾#ifdef SQLITE_ENABLE_API_ARMORÙ"  if( !sqlite3SafetyCheckOk(db) ){½    (void)SQLITE_MISUSE_BKPT;­    return 0;£  }¦#endif Ù1  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;Ù%  p = memdbFromDbSchema(db, zSchema);Ù'  iDb = sqlite3FindDbName(db, zSchema);¼  if( piSize ) *piSize = -1;·  if( iDb<0 ) return 0;ª  if( p ){Ù!    if( piSize ) *piSize = p->sz;Ù+    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){¶      pOut = p->aData;ª    }else{Ù'      pOut = sqlite3_malloc64( p->sz );Ù/      if( pOut ) memcpy(pOut, p->aData, p->sz);¥    }°    return pOut;£  }¹  pBt = db->aDb[iDb].pBt;¸  if( pBt==0 ) return 0;Ù(  szPage = sqlite3BtreeGetPageSize(pBt);Ù>  zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);ÙI  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;µ  sqlite3_free(zSql);´  if( rc ) return 0;»  rc = sqlite3_step(pStmt);·  if( rc!=SQLITE_ROW ){­    pOut = 0;¨  }else{Ù/    sz = sqlite3_column_int64(pStmt, 0)*szPage;¾    if( piSize ) *piSize = sz;Ù+    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){¯      pOut = 0;ª    }else{Ù$      pOut = sqlite3_malloc64( sz );±      if( pOut ){Ù1        int nPage = sqlite3_column_int(pStmt, 0);Ù/        Pager *pPager = sqlite3BtreePager(pBt);±        int pgno;Ù)        for(pgno=1; pgno<=nPage; pgno++){¼          DbPage *pPage = 0;ÙE          unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);ÙB          rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);¾          if( rc==SQLITE_OK ){Ù<            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);°          }else{Ù#            memset(pTo, 0, szPage);«          }Ù*          sqlite3PagerUnref(pPage);       ©        }§      }¥    }£  }º  sqlite3_finalize(pStmt);®  return pOut;¡} Ù9/* Convert zSchema to a MemDB and initialize its content.¢*/Ù#SQLITE_API int sqlite3_deserialize(Ù7  sqlite3 *db,            /* The database connection */ÙK  const char *zSchema,    /* Which DB to reopen with the deserialization */Ù?  unsigned char *pData,   /* The serialized database content */ÙC  sqlite3_int64 szDb,     /* Number bytes in the deserialization */Ù<  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */ÙG  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */¢){­  MemFile *p;­  char *zSql;º  sqlite3_stmt *pStmt = 0;©  int rc;ª  int iDb; ¾#ifdef SQLITE_ENABLE_API_ARMORÙ"  if( !sqlite3SafetyCheckOk(db) ){¾    return SQLITE_MISUSE_BKPT;£  }Ù)  if( szDb<0 ) return SQLITE_MISUSE_BKPT;Ù*  if( szBuf<0 ) return SQLITE_MISUSE_BKPT;¦#endif Ù!  sqlite3_mutex_enter(db->mutex);Ù1  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;Ù'  iDb = sqlite3FindDbName(db, zSchema);®  if( iDb<0 ){¶    rc = SQLITE_ERROR;¹    goto end_deserialize;§  }    Ù4  zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);Ù3  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);µ  sqlite3_free(zSql);Ù   if( rc ) goto end_deserialize;¹  db->init.iDb = (u8)iDb;»  db->init.reopenMemdb = 1;»  rc = sqlite3_step(pStmt);»  db->init.reopenMemdb = 0;¸  if( rc!=SQLITE_DONE ){¶    rc = SQLITE_ERROR;¹    goto end_deserialize;£  }Ù%  p = memdbFromDbSchema(db, zSchema);­  if( p==0 ){¶    rc = SQLITE_ERROR;¨  }else{µ    p->aData = pData;±    p->sz = szDb;µ    p->szMax = szBuf;·    p->mFlags = mFlags;³    rc = SQLITE_OK;£  } °end_deserialize:º  sqlite3_finalize(pStmt);Ù!  sqlite3_mutex_leave(db->mutex);¬  return rc;¡} £/* Ù7** This routine is called when the extension is loaded.¸** Register the new VFS.¢*/Ù*SQLITE_PRIVATE int sqlite3MemdbInit(void){Ù,  sqlite3_vfs *pLower = sqlite3_vfs_find(0);¼  int sz = pLower->szOsFile;¾  memdb_vfs.pAppData = pLower;ÙA  /* In all known configurations of SQLite, the size of a defaultÙC  ** sqlite3_file is greater than the size of a memdb sqlite3_file.Ù=  ** Should that ever change, remove the following NEVER() */Ù7  if( NEVER(sz<sizeof(MemFile)) ) sz = sizeof(MemFile);º  memdb_vfs.szOsFile = sz;Ù-  return sqlite3_vfs_register(&memdb_vfs, 0);¡}Ù&#endif /* SQLITE_ENABLE_DESERIALIZE */ ÙO/************** End of memdb.c ***********************************************/ÙO/************** Begin file bitvec.c ******************************************/¢/*³** 2008 February 16¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù@** This file implements an object that represents a fixed-lengthÙ.** bitmap.  Bits are numbered starting with 1.¢**ÙF** A bitmap is used to record which pages of a database file have beenÙH** journalled during a transaction, or which pages have the "dont-write"ÙA** property.  Usually only a few pages are meet either condition.Ù;** So the bitmap is usually sparse and has low cardinality.ÙG** But sometimes (for example when during a DROP of a large table) mostÙJ** or all of the pages in a database can get journalled.  In those cases, ÙH** the bitmap becomes dense with high cardinality.  The algorithm needs ½** to handle both cases well.¢**Ù>** The size of the bitmap is fixed when the object is created.¢**ÙB** All bits are clear when the bitmap is created.  Individual bitsÙ'** may be set or cleared one at a time.¢**ÙG** Test operations are about 100 times more common that set operations.ÙD** Clear operations are exceedingly rare.  There are usually betweenÙL** 5 and 500 set operations per Bitvec object, though the number of sets canÙD** sometimes grow into tens of thousands or larger.  The size of theÙC** Bitvec object is the number of pages in the database file at theÙH** start of a transaction, and is thus usually less than a few thousand,Ù>** but can be as large as 2 billion for a really big database.¢*/¼/* #include "sqliteInt.h" */ Ù,/* Size of the Bitvec structure in bytes. */¼#define BITVEC_SZ        512 ÙO/* Round the union size down to the nearest pointer boundary, since that's how Ù2** it will be aligned within the Bitvec struct. */¶#define BITVEC_USIZE \ÙC    (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*)) Ù>/* Type of the array "element" for the bitmap representation. ÙI** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE. ÙB** Setting this to the "natural word" size of your CPU may improve²** performance. */»#define BITVEC_TELEM     u8Ù+/* Size, in bits, of the bitmap element. */º#define BITVEC_SZELEM    8Ù+/* Number of elements in a bitmap array. */Ù<#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))Ù)/* Number of bits in the bitmap array. */Ù5#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM) Ù)/* Number of u32 values in hash table. */Ù3#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))Ù2/* Maximum number of entries in hash table before Ù"** sub-dividing and re-hashing. */Ù(#define BITVEC_MXHASH    (BITVEC_NINT/2)Ù1/* Hashing function for the aHash representation.Ù4** Empirical testing showed that the *37 multiplier Ù5** (an arbitrary prime)in the hash function provided Ù,** no fewer collisions than the no-op *1. */Ù.#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT) Ù8#define BITVEC_NPTR      (BITVEC_USIZE/sizeof(Bitvec *))  ¢/*Ù6** A bitmap is an instance of the following structure.¢**Ù9** This bitmap records the existence of zero or more bitsÙ.** with values between 1 and iSize, inclusive.¢**Ù:** There are three possible representations of the bitmap.Ù?** If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straightÙ/** bitmap.  The least significant bit is bit 1.¢**Ù@** If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] isÙC** a hash table that will hold up to BITVEC_MXHASH distinct values.¢**Ù?** Otherwise, the value i is redirected into one of BITVEC_NPTRÙ>** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmapÙ?** handles up to iDivisor separate values of i.  apSub[0] holdsÙ@** values between 1 and iDivisor.  apSub[1] holds values betweenÙ<** iDivisor+1 and 2*iDivisor.  apSub[N] holds values betweenÙA** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalizedÙ3** to hold deal with values between 1 and iDivisor.¢*/¯struct Bitvec {ÙG  u32 iSize;      /* Maximum bit index.  Max iSize is 4,294,967,296. */ÙG  u32 nSet;       /* Number of bits that are set - only valid for aHashÙI                  ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,Ù*                  ** this would be 125. */ÙE  u32 iDivisor;   /* Number of bits handled by each apSub[] entry. */Ù5                  /* Should >=0 for apSub element. */ÙD                  /* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */ÙI                  /* For a BITVEC_SZ of 512, this would be 34,359,739. */©  union {ÙF    BITVEC_TELEM aBitmap[BITVEC_NELEM];    /* Bitmap representation */Ù@    u32 aHash[BITVEC_NINT];      /* Hash table representation */Ù?    Bitvec *apSub[BITVEC_NPTR];  /* Recursive representation */¦  } u;¢}; ¢/*ÙF** Create a new bitmap object able to handle bits between 0 and iSize,ÙC** inclusive.  Return a pointer to the new object.  Return NULL if °** malloc fails.¢*/Ù6SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize){¬  Bitvec *p;Ù"  assert( sizeof(*p)==BITVEC_SZ );Ù&  p = sqlite3MallocZero( sizeof(*p) );ª  if( p ){µ    p->iSize = iSize;£  }«  return p;¡} ¢/*Ù>** Check to see if the i-th bit is set.  Return true or false.Ù:** If p is NULL (if the bitmap has not been created) or ifÙ(** i is out of range, then return false.¢*/Ù>SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){±  assert( p!=0 );¦  i--;½  if( i>=p->iSize ) return 0;·  while( p->iDivisor ){¼    u32 bin = i/p->iDivisor;¶    i = i%p->iDivisor;¸    p = p->u.apSub[bin];­    if (!p) {¯      return 0;¥    }£  }¾  if( p->iSize<=BITVEC_NBIT ){ÙK    return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;©  } else{½    u32 h = BITVEC_HASH(i++);»    while( p->u.aHash[h] ){Ù&      if( p->u.aHash[h]==i ) return 1;¾      h = (h+1) % BITVEC_NINT;¥    }­    return 0;£  }¡}Ù7SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i){Ù/  return p!=0 && sqlite3BitvecTestNotNull(p,i);¡} ¢/*Ù>** Set the i-th bit.  Return 0 on success and an error code if·** anything goes wrong.¢**ÙA** This routine might cause sub-bitmaps to be allocated.  FailingÙ>** to get the memory needed to hold the sub-bitmap is the onlyÙ@** that can go wrong with an insert, assuming p and i are valid.¢**ÙC** The calling function must ensure that p is a valid Bitvec objectÙC** and that the value for "i" is within range of the Bitvec object.Ù'** Otherwise the behavior is undefined.¢*/Ù6SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i){¨  u32 h;¾  if( p==0 ) return SQLITE_OK;°  assert( i>0 );¸  assert( i<=p->iSize );¦  i--;Ù2  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {¼    u32 bin = i/p->iDivisor;¶    i = i%p->iDivisor;½    if( p->u.apSub[bin]==0 ){Ù;      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );Ù8      if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM_BKPT;¥    }¸    p = p->u.apSub[bin];£  }¾  if( p->iSize<=BITVEC_NBIT ){Ù@    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));µ    return SQLITE_OK;£  }·  h = BITVEC_HASH(i++);Ù:  /* if there wasn't a hash collision, and this doesn't */Ù:  /* completely fill the hash, then just add it without */Ù2  /* worring about sub-dividing and re-hashing. */·  if( !p->u.aHash[h] ){Ù"    if (p->nSet<(BITVEC_NINT-1)) {º      goto bitvec_set_end;¬    } else {½      goto bitvec_set_rehash;¥    }£  }Ù;  /* there was a collision, check to see if it's already */Ù2  /* in hash, if not, try to find a spot for it */¦  do {Ù,    if( p->u.aHash[h]==i ) return SQLITE_OK;¨    h++;¿    if( h>=BITVEC_NINT ) h = 0;»  } while( p->u.aHash[h] );Ù=  /* we didn't find it in the hash.  h points to the first */Ù=  /* available free spot. check to see if this is going to */Ù"  /* make our hash too "full".  */²bitvec_set_rehash:¿  if( p->nSet>=BITVEC_MXHASH ){³    unsigned int j;«    int rc;Ù@    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));¶    if( aiValues==0 ){¿      return SQLITE_NOMEM_BKPT;ª    }else{Ù7      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));Ù0      memset(p->u.apSub, 0, sizeof(p->u.apSub));Ù=      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;Ù"      rc = sqlite3BitvecSet(p, i);Ù#      for(j=0; j<BITVEC_NINT; j++){ÙA        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);§      }Ù$      sqlite3StackFree(0, aiValues);°      return rc;¥    }£  }¯bitvec_set_end:¬  p->nSet++;´  p->u.aHash[h] = i;³  return SQLITE_OK;¡} ¢/*¶** Clear the i-th bit.¢**ÙJ** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storageÙ6** that BitvecClear can use to rebuilt its hash table.¢*/ÙESQLITE_PRIVATE void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){´  if( p==0 ) return;°  assert( i>0 );¦  i--;·  while( p->iDivisor ){¼    u32 bin = i/p->iDivisor;¶    i = i%p->iDivisor;¸    p = p->u.apSub[bin];­    if (!p) {­      return;¥    }£  }¾  if( p->iSize<=BITVEC_NBIT ){ÙC    p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));¨  }else{³    unsigned int j;¹    u32 *aiValues = pBuf;Ù5    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));Ù.    memset(p->u.aHash, 0, sizeof(p->u.aHash));°    p->nSet = 0;Ù!    for(j=0; j<BITVEC_NINT; j++){Ù.      if( aiValues[j] && aiValues[j]!=(i+1) ){Ù+        u32 h = BITVEC_HASH(aiValues[j]-1);²        p->nSet++;¿        while( p->u.aHash[h] ){®          h++;Ù%          if( h>=BITVEC_NINT ) h = 0;©        }Ù$        p->u.aHash[h] = aiValues[j];§      }¥    }£  }¡} ¢/*Ù5** Destroy a bitmap object.  Reclaim all memory used.¢*/Ù4SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p){´  if( p==0 ) return;´  if( p->iDivisor ){³    unsigned int i;Ù!    for(i=0; i<BITVEC_NPTR; i++){Ù*      sqlite3BitvecDestroy(p->u.apSub[i]);¥    }£  }²  sqlite3_free(p);¡} ¢/*ÙC** Return the value of the iSize parameter specified when Bitvec *p¯** was created.¢*/Ù0SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec *p){²  return p->iSize;¡} ¹#ifndef SQLITE_UNTESTABLE¢/*Ù@** Let V[] be an array of unsigned characters sufficient to holdÙ?** up to N bits.  Let I be an integer between 0 and N.  0<=I<N.Ù?** Then the following macros can be used to set, clear, or test¼** individual bits within V.¢*/Ù.#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))Ù/#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))Ù0#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0 ¢/*Ù:** This routine runs an extensive test of the Bitvec code.¢**Ù;** The input is an array of integers that acts as a programÙ9** to test the Bitvec.  The integers are opcodes followedÙ<** by 0, 1, or 3 operands, depending on the opcode.  AnotherÙ5** opcode follows immediately after the last operand.¢**Ù;** There are 6 opcodes numbered from 0 through 5.  0 is theÙ,** "halt" opcode and causes the test to end.¢**Ù5**    0          Halt and return the number of errorsÙB**    1 N S X    Set N bits beginning with S and incrementing by XÙD**    2 N S X    Clear N bits beginning with S and incrementing by XÙ+**    3 N        Set N randomly chosen bitsÙ-**    4 N        Clear N randomly chosen bitsÙK**    5 N S X    Set N bits from S increment X in array only, not in bitvec¢**ÙI** The opcodes 1 through 4 perform set and clear operations are performedÙN** on both a Bitvec object and on a linear array of bits obtained from malloc.Ù>** Opcode 5 works on the linear array only, not on the Bitvec.Ù>** Opcode 5 is used to deliberately induce a fault in order toÙ&** confirm that error detection works.¢**Ù=** At the conclusion of the test the linear array is comparedÙ<** against the Bitvec object.  If there are any differences,ÙA** an error is returned.  If they are the same, zero is returned.¢**Ù2** If a memory allocation error occurs, return -1.¢*/Ù>SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){¶  Bitvec *pBitvec = 0;¸  unsigned char *pV = 0;®  int rc = -1;´  int i, nx, pc, op;²  void *pTmpSpace; Ù;  /* Allocate the Bitvec to be tested and a linear array ofÙ$  ** bits to act as the reference */Ù&  pBitvec = sqlite3BitvecCreate( sz );Ù)  pV = sqlite3MallocZero( (sz+7)/8 + 1 );Ù*  pTmpSpace = sqlite3_malloc64(BITVEC_SZ);Ù=  if( pBitvec==0 || pV==0 || pTmpSpace==0  ) goto bitvec_end; º  /* NULL pBitvec tests */¹  sqlite3BitvecSet(0, 1);Ù&  sqlite3BitvecClear(0, 1, pTmpSpace); ·  /* Run the program */©  pc = 0;½  while( (op = aOp[pc])!=0 ){±    switch( op ){­      case 1:­      case 2:¯      case 5: {¯        nx = 4;º        i = aOp[pc+2] - 1;¿        aOp[pc+2] += aOp[pc+3];®        break;§      }­      case 3:®      case 4: °      default: {¯        nx = 2;Ù*        sqlite3_randomness(sizeof(i), &i);®        break;§      }¥    }Ù#    if( (--aOp[pc+1]) > 0 ) nx = 0;­    pc += nx;¼    i = (i & 0x7fffffff)%sz;¶    if( (op & 1)!=0 ){¸      SETBIT(pV, (i+1));²      if( op!=5 ){Ù=        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;§      }ª    }else{º      CLEARBIT(pV, (i+1));Ù2      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);¥    }£  } Ù;  /* Test to make sure the linear array exactly matches theÙ;  ** Bitvec object.  Start with the assumption that they doÙ;  ** match (rc==0).  Change rc to non-zero if a discrepancy®  ** is found.¤  */Ù@  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)Ù)          + sqlite3BitvecTest(pBitvec, 0)Ù.          + (sqlite3BitvecSize(pBitvec) - sz);·  for(i=1; i<=sz; i++){Ù9    if(  (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){­      rc = i;¬      break;¥    }£  } Ù   /* Free allocated structure */«bitvec_end:º  sqlite3_free(pTmpSpace);³  sqlite3_free(pV);Ù   sqlite3BitvecDestroy(pBitvec);¬  return rc;¡}¾#endif /* SQLITE_UNTESTABLE */ ÙO/************** End of bitvec.c **********************************************/ÙO/************** Begin file pcache.c ******************************************/¢/*±** 2008 August 05¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************Ù(** This file implements that page cache.¢*/¼/* #include "sqliteInt.h" */ ¢/*ÙA** A complete page cache is an instance of this structure.  EveryÙD** entry in the cache holds a single page of the database file.  TheÙF** btree layer only operates on the cached copy of the database pages.¢**ÙH** A page cache entry is "clean" if it exactly matches what is currentlyÙF** on disk.  A page is "dirty" if it has been modified and needs to beµ** persisted to disk.¢**¿** pDirty, pDirtyTail, pSynced:ÙA**   All dirty pages are linked into the doubly linked list usingÙI**   PgHdr.pDirtyNext and pDirtyPrev. The list is maintained in LRU orderÙH**   such that p was added to the list more recently than p->pDirtyNext.ÙG**   PCache.pDirty points to the first (newest) element in the list andÙ%**   pDirtyTail to the last (oldest).¢**ÙJ**   The PCache.pSynced variable is used to optimize searching for a dirtyÙH**   page to eject from the cache mid-transaction. It is better to ejectÙE**   a page that does not require a journal sync than one that does. ÙG**   Therefore, pSynced is maintained to that it *almost* always pointsÙG**   to either the oldest page in the pDirty/pDirtyTail list that has aÙH**   clear PGHDR_NEED_SYNC flag or to a page that is older than this oneÙJ**   (so that the right page to eject can be found by following pDirtyPrev¯**   pointers).¢*/¯struct PCache {ÙL  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */ÙO  PgHdr *pSynced;                     /* Last synced page in dirty page list */ÙL  int nRefSum;                        /* Sum of ref counts over all pages */ÙA  int szCache;                        /* Configured cache size */ÙG  int szSpill;                        /* Size before spilling occurs */ÙL  int szPage;                         /* Size of every page in this cache */ÙM  int szExtra;                        /* Size of extra space for each page */ÙN  u8 bPurgeable;                      /* True if pages are on backing store */ÙJ  u8 eCreate;                         /* eCreate value for for xFetch() */ÙI  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */Ù?  void *pStress;                      /* Argument to xStress */ÙB  sqlite3_pcache *pCache;             /* Pluggable cache module */¢}; ÙP/********************************** Test and Debug Logic **********************/¢/*ÙB** Debug tracing macros.  Enable by by changing the "0" to "1" and¯** recompiling.¢**ÙG** When sqlite3PcacheTrace is 1, single line trace messages are issued.ÙO** When sqlite3PcacheTrace is 2, a dump of the pcache showing all cache entriesÙB** is displayed for many operations, resulting in a lot of output.¢*/¾#if defined(SQLITE_DEBUG) && 0ÙK  int sqlite3PcacheTrace = 2;       /* 0: off  1: simple  2: cache dumps */ÙL  int sqlite3PcacheMxDump = 9999;   /* Max cache entries for pcacheDump() */ÙE# define pcacheTrace(X) if(sqlite3PcacheTrace){sqlite3DebugPrintf X;}Ù"  void pcacheDump(PCache *pCache){ª    int N;­    int i, j;Ù     sqlite3_pcache_page *pLower;¯    PgHdr *pPg;µ    unsigned char *a;¢  Ù&    if( sqlite3PcacheTrace<2 ) return;Ù#    if( pCache->pCache==0 ) return;Ù'    N = sqlite3PcachePagecount(pCache);Ù8    if( N>sqlite3PcacheMxDump ) N = sqlite3PcacheMxDump;¸    for(i=1; i<=N; i++){ÙI       pLower = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, i, 0);Ù        if( pLower==0 ) continue;Ù$       pPg = (PgHdr*)pLower->pExtra;ÙI       printf("%3d: nRef %2d flgs %02x data ", i, pPg->nRef, pPg->flags);Ù)       a = (unsigned char *)pLower->pBuf;Ù0       for(j=0; j<12; j++) printf("%02x", a[j]);´       printf("\n");»       if( pPg->pPage==0 ){ÙG         sqlite3GlobalConfig.pcache2.xUnpin(pCache->pCache, pLower, 0);¨       }¥    }£  }§  #else·# define pcacheTrace(X)¶# define pcacheDump(X)¦#endif ¢/*ÙG** Check invariants on a PgHdr entry.  Return true if everything is OK.Ù-** Return false if any invariant is violated.¢**ÙC** This routine is for use inside of assert() statements only.  For«** example:¢**Ù3**          assert( sqlite3PcachePageSanity(pPg) );¢*/³#ifdef SQLITE_DEBUGÙ7SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr *pPg){±  PCache *pCache;³  assert( pPg!=0 );ÙL  assert( pPg->pgno>0 || pPg->pPager==0 );    /* Page number is 1 or more */·  pCache = pPg->pCache;ÙE  assert( pCache!=0 );      /* Every page has an associated PCache */Ù!  if( pPg->flags & PGHDR_CLEAN ){ÙP    assert( (pPg->flags & PGHDR_DIRTY)==0 );/* Cannot be both CLEAN and DIRTY */ÙO    assert( pCache->pDirty!=pPg );          /* CLEAN pages not on dirty list */Ù&    assert( pCache->pDirtyTail!=pPg );£  }Ù*  /* WRITEABLE pages must also be DIRTY */Ù%  if( pPg->flags & PGHDR_WRITEABLE ){ÙI    assert( pPg->flags & PGHDR_DIRTY );     /* WRITEABLE implies DIRTY */£  }ÙG  /* NEED_SYNC can be set independently of WRITEABLE.  This can happen,ÙF  ** for example, when using the sqlite3PagerDontWrite() optimization:ÙD  **    (1)  Page X is journalled, and gets WRITEABLE and NEED_SEEK.Ù;  **    (2)  Page X moved to freelist, WRITEABLE is clearedÙ2  **    (3)  Page X reused, WRITEABLE is set againÙH  ** If NEED_SYNC had been cleared in step 2, then it would not be resetÙI  ** in step 3, and page might be written into the database without firstÙJ  ** syncing the rollback journal, which might cause corruption on a powerª  ** loss.¤  **ÙG  ** Another example is when the database page size is smaller than theÙJ  ** disk sector size.  When any page of a sector is journalled, all pagesÙK  ** in that sector are marked NEED_SYNC even if they are still CLEAN, justÙH  ** in case they are later modified, since all pages in the same sectorÙJ  ** must be journalled and synced before any of those pages can be safely­  ** written.¤  */«  return 1;¡}¹#endif /* SQLITE_DEBUG */  ÙP/********************************** Linked List Management ********************/ ÙC/* Allowed values for second argument to pcacheManageDirtyList() */ÙI#define PCACHE_DIRTYLIST_REMOVE   1    /* Remove pPage from dirty list */ÙH#define PCACHE_DIRTYLIST_ADD      2    /* Add pPage to the dirty list */ÙP#define PCACHE_DIRTYLIST_FRONT    3    /* Move pPage to the front of the list */ ¢/*ÙI** Manage pPage's participation on the dirty list.  Bits of the addRemoveÙF** argument determines what operation to do.  The 0x01 bit means firstÙF** remove pPage from the dirty list.  The 0x02 means add pPage back toÙJ** the dirty list.  Doing both moves pPage to the front of the dirty list.¢*/Ù>static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){¼  PCache *p = pPage->pCache; Ù)  pcacheTrace(("%p.DIRTYLIST.%s %d\n", p,ÙI                addRemove==1 ? "REMOVE" : addRemove==2 ? "ADD" : "FRONT",¾                pPage->pgno));Ù,  if( addRemove & PCACHE_DIRTYLIST_REMOVE ){Ù8    assert( pPage->pDirtyNext || pPage==p->pDirtyTail );Ù4    assert( pPage->pDirtyPrev || pPage==p->pDirty );¢  Ù;    /* Update the PCache1.pSynced variable if necessary. */¼    if( p->pSynced==pPage ){Ù%      p->pSynced = pPage->pDirtyPrev;¥    }¢  ¼    if( pPage->pDirtyNext ){Ù8      pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;ª    }else{Ù%      assert( pPage==p->pDirtyTail );Ù(      p->pDirtyTail = pPage->pDirtyPrev;¥    }¼    if( pPage->pDirtyPrev ){Ù8      pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;ª    }else{ÙI      /* If there are now no dirty pages in the cache, set eCreate to 2. ÙI      ** This is an optimization that allows sqlite3PcacheFetch() to skipÙI      ** searching for a dirty page to eject from the cache when it might¿      ** otherwise have to.  */Ù!      assert( pPage==p->pDirty );Ù$      p->pDirty = pPage->pDirtyNext;Ù/      assert( p->bPurgeable || p->eCreate==2 );Ù:      if( p->pDirty==0 ){         /*OPTIMIZATION-IF-TRUE*/Ù4        assert( p->bPurgeable==0 || p->eCreate==1 );·        p->eCreate = 2;§      }¥    }£  }Ù)  if( addRemove & PCACHE_DIRTYLIST_ADD ){º    pPage->pDirtyPrev = 0;Ù"    pPage->pDirtyNext = p->pDirty;¼    if( pPage->pDirtyNext ){Ù1      assert( pPage->pDirtyNext->pDirtyPrev==0 );Ù,      pPage->pDirtyNext->pDirtyPrev = pPage;ª    }else{¼      p->pDirtyTail = pPage;º      if( p->bPurgeable ){Ù         assert( p->eCreate==2 );·        p->eCreate = 1;§      }¥    }¶    p->pDirty = pPage; ÙG    /* If pSynced is NULL and this page has a clear NEED_SYNC flag, setÙA    ** pSynced to point to it. Checking the NEED_SYNC flag is an ÙF    ** optimization, as if pSynced points to a page with the NEED_SYNCÙF    ** flag set sqlite3PcacheFetchStress() searches through all newer ÙL    ** entries of the dirty-list for a page with NEED_SYNC clear anyway.  */´    if( !p->pSynced ÙE     && 0==(pPage->flags&PGHDR_NEED_SYNC)   /*OPTIMIZATION-IF-FALSE*/¦    ){¹      p->pSynced = pPage;¥    }£  }°  pcacheDump(p);¡} ¢/*ÙE** Wrapper around the pluggable caches xUnpin method. If the cache isÙB** being used for an in-memory database, this function is a no-op.¢*/Ù"static void pcacheUnpin(PgHdr *p){¾  if( p->pCache->bPurgeable ){Ù7    pcacheTrace(("%p.UNPIN %d\n", p->pCache, p->pgno));ÙG    sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);º    pcacheDump(p->pCache);£  }¡} ¢/*ÙF** Compute the number of pages of cache requested.   p->szCache is theÙ=** cache size requested by the "PRAGMA cache_size" statement.¢*/Ù)static int numberOfCachePages(PCache *p){¶  if( p->szCache>=0 ){ÙN    /* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then theÙ+    ** suggested cache size is set to N. */¶    return p->szCache;¨  }else{ÙK    /* IMPLEMENTATION-OF: R-61436-13639 If the argument N is negative, thenÙM    ** the number of cache pages is adjusted to use approximately abs(N*1024)º    ** bytes of memory. */ÙA    return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));£  }¡} ÙN/*************************************************** General Interfaces ******¢**ÙF** Initialize and shutdown the page cache subsystem. Neither of these ¼** functions are threadsafe.¢*/Ù1SQLITE_PRIVATE int sqlite3PcacheInitialize(void){Ù-  if( sqlite3GlobalConfig.pcache2.xInit==0 ){ÙO    /* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then theÙM    ** built-in default page cache is used instead of the application definedµ    ** page cache. */¾    sqlite3PCacheSetDefault();£  }ÙM  return sqlite3GlobalConfig.pcache2.xInit(sqlite3GlobalConfig.pcache2.pArg);¡}Ù0SQLITE_PRIVATE void sqlite3PcacheShutdown(void){Ù.  if( sqlite3GlobalConfig.pcache2.xShutdown ){ÙN    /* IMPLEMENTATION-OF: R-26000-56589 The xShutdown() method may be NULL. */ÙL    sqlite3GlobalConfig.pcache2.xShutdown(sqlite3GlobalConfig.pcache2.pArg);£  }¡} ¢/*Ù/** Return the size in bytes of a PCache object.¢*/ÙDSQLITE_PRIVATE int sqlite3PcacheSize(void){ return sizeof(PCache); } ¢/*Ù?** Create a new PCache object. Storage space to hold the objectÙA** has already been allocated and is passed in as the p pointer. Ù@** The caller discovers how much space needs to be allocated by ¿** calling sqlite3PcacheSize().¢**ÙB** szExtra is some extra space allocated for each page.  The firstÙF** 8 bytes of the extra space will be zeroed as the page is allocated,ÙD** but remaining content will be uninitialized.  Though it is opaqueÙC** to this module, the extra space really ends up being the MemPageº** structure in the pager.¢*/Ù%SQLITE_PRIVATE int sqlite3PcacheOpen(Ù7  int szPage,                  /* Size of every page */ÙJ  int szExtra,                 /* Extra space associated with each page */ÙG  int bPurgeable,              /* True if pages are on backing store */ÙD  int (*xStress)(void*,PgHdr*),/* Call to try to make pages clean */Ù8  void *pStress,               /* Argument to xStress */ÙF  PCache *p                    /* Preallocated space for the PCache */¢){¿  memset(p, 0, sizeof(PCache));°  p->szPage = 1;·  p->szExtra = szExtra;Ù;  assert( szExtra>=8 );  /* First 8 bytes will be zeroed */½  p->bPurgeable = bPurgeable;±  p->eCreate = 2;·  p->xStress = xStress;·  p->pStress = pStress;³  p->szCache = 100;±  p->szSpill = 1;ÙI  pcacheTrace(("%p.OPEN szPage %d bPurgeable %d\n",p,szPage,bPurgeable));Ù-  return sqlite3PcacheSetPageSize(p, szPage);¡} ¢/*ÙL** Change the page size for PCache object. The caller must ensure that thereÙC** are no outstanding page references when this function is called.¢*/ÙHSQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){Ù4  assert( pCache->nRefSum==0 && pCache->pDirty==0 );·  if( pCache->szPage ){¹    sqlite3_pcache *pNew;Ù/    pNew = sqlite3GlobalConfig.pcache2.xCreate(Ù@                szPage, pCache->szExtra + ROUND8(sizeof(PgHdr)),Ù"                pCache->bPurgeable¦    );Ù+    if( pNew==0 ) return SQLITE_NOMEM_BKPT;ÙM    sqlite3GlobalConfig.pcache2.xCachesize(pNew, numberOfCachePages(pCache));¹    if( pCache->pCache ){Ù;      sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);¥    }º    pCache->pCache = pNew;¼    pCache->szPage = szPage;Ù4    pcacheTrace(("%p.PAGESIZE %d\n",pCache,szPage));£  }³  return SQLITE_OK;¡} ¢/*Ù'** Try to obtain a page from the cache.¢**ÙE** This routine returns a pointer to an sqlite3_pcache_page object ifÙB** such an object is already in cache, or if a new one is created.ÙE** This routine returns a NULL pointer if the object was not in cache¼** and could not be created.¢**ÙE** The createFlags should be 0 to check for existing pages and shouldÙ3** be 3 (not 1, but 3) to try to create a new page.¢**ÙC** If the createFlag is 0, then NULL is always returned if the pageÙD** is not already in the cache.  If createFlag is 1, then a new pageÙC** is created only if that can be done without spilling dirty pagesÙ.** and without exceeding the cache size limit.¢**ÙD** The caller needs to invoke sqlite3PcacheFetchFinish() to properlyÙB** initialize the sqlite3_pcache_page object and convert it into aÙI** PgHdr object.  The sqlite3PcacheFetch() and sqlite3PcacheFetchFinish()ÙF** routines are split this way for performance reasons. When separatedÙC** they can both (usually) operate without having to push values toÙB** the stack on entry and pop them back off on exit, which saves a¾** lot of pushing and popping.¢*/Ù7SQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(Ù=  PCache *pCache,       /* Obtain the page from this cache */Ù3  Pgno pgno,            /* Page number to obtain */ÙO  int createFlag        /* If true, create page if it does not exist already */¢){®  int eCreate;¼  sqlite3_pcache_page *pRes; ¶  assert( pCache!=0 );¾  assert( pCache->pCache!=0 );Ù+  assert( createFlag==3 || createFlag==0 );ÙN  assert( pCache->eCreate==((pCache->bPurgeable && pCache->pDirty) ? 1 : 2) ); Ù;  /* eCreate defines what to do if the page does not exist.Ù:  **    0     Do not allocate a new page.  (createFlag==0)Ù=  **    1     Allocate a new page if doing so is inexpensive.Ù7  **          (createFlag==1 AND bPurgeable AND pDirty)Ù@  **    2     Allocate a new page even it doing so is difficult.Ù9  **          (createFlag==1 AND !(bPurgeable AND pDirty)¤  */Ù)  eCreate = createFlag & pCache->eCreate;Ù3  assert( eCreate==0 || eCreate==1 || eCreate==2 );Ù6  assert( createFlag==0 || pCache->eCreate==eCreate );ÙO  assert( createFlag==0 || eCreate==1+(!pCache->bPurgeable||!pCache->pDirty) );ÙK  pRes = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, eCreate);Ù:  pcacheTrace(("%p.FETCH %d%s (result: %p)\n",pCache,pgno,Ù.               createFlag?" create":"",pRes));®  return pRes;¡} ¢/*ÙB** If the sqlite3PcacheFetch() routine is unable to allocate a newÙD** page because no clean pages are available for reuse and the cacheÙD** size limit has been reached, then this routine can be invoked to ÙG** try harder to allocate a page.  This routine might invoke the stressÙE** callback to spill dirty pages to the journal.  It will then try toÙE** allocate the new page and will only fail to allocate a new page on°** an OOM error.¢**ÙH** This routine should be invoked only after sqlite3PcacheFetch() fails.¢*/Ù,SQLITE_PRIVATE int sqlite3PcacheFetchStress(ÙG  PCache *pCache,                 /* Obtain the page from this cache */Ù=  Pgno pgno,                      /* Page number to obtain */Ù9  sqlite3_pcache_page **ppPage    /* Write result here */¢){­  PgHdr *pPg;Ù$  if( pCache->eCreate==2 ) return 0; Ù7  if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){ÙG    /* Find a dirty page to write-out and recycle. First try to find a ÙJ    ** page that does not require a journal-sync (one with PGHDR_NEED_SYNCÙB    ** cleared), but if that is not possible settle for any other ¿    ** unreferenced dirty page.¦    **ÙI    ** If the LRU page in the dirty list that has a clear PGHDR_NEED_SYNCÙI    ** flag is currently referenced, then the following may leave pSyncedÙJ    ** set incorrectly (pointing to other than the LRU page with NEED_SYNCÙD    ** cleared). This is Ok, as pSynced is just an optimization.  */½    for(pPg=pCache->pSynced; Ù<        pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC)); »        pPg=pPg->pDirtyPrev¦    );º    pCache->pSynced = pPg;¯    if( !pPg ){ÙI      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);¥    }®    if( pPg ){­      int rc;½#ifdef SQLITE_LOG_CACHE_SPILL¿      sqlite3_log(SQLITE_FULL, ÙI                  "spill page %d making room for %d - cache used: %d/%d",Ù"                  pPg->pgno, pgno,ÙI                  sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache),Ù,                numberOfCachePages(pCache));¦#endifÙ6      pcacheTrace(("%p.SPILL %d\n",pCache,pPg->pgno));Ù1      rc = pCache->xStress(pCache->pStress, pPg);¹      pcacheDump(pCache);Ù-      if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){²        return rc;§      }¥    }£  }ÙH  *ppPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, 2);Ù4  return *ppPage==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;¡} ¢/*Ù:** This is a helper routine for sqlite3PcacheFetchFinish()¢**ÙA** In the uncommon case where the page being fetched has not beenÙA** initialized, this routine is invoked to do the initialization.Ù?** This routine is broken out into a separate function since itÙF** requires extra stack manipulation that can be avoided in the common¨** case.¢*/Ù8static SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit(ÙC  PCache *pCache,             /* Obtain the page from this cache */Ù8  Pgno pgno,                  /* Page number obtained */ÙM  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */¢){°  PgHdr *pPgHdr;µ  assert( pPage!=0 );Ù!  pPgHdr = (PgHdr*)pPage->pExtra;½  assert( pPgHdr->pPage==0 );ÙE  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));¸  pPgHdr->pPage = pPage;¾  pPgHdr->pData = pPage->pBuf;Ù&  pPgHdr->pExtra = (void *)&pPgHdr[1];¿  memset(pPgHdr->pExtra, 0, 8);º  pPgHdr->pCache = pCache;¶  pPgHdr->pgno = pgno;¾  pPgHdr->flags = PGHDR_CLEAN;Ù5  return sqlite3PcacheFetchFinish(pCache,pgno,pPage);¡} ¢/*ÙC** This routine converts the sqlite3_pcache_page object returned byÙG** sqlite3PcacheFetch() into an initialized PgHdr object.  This routineÙE** must be called after sqlite3PcacheFetch() in order to get a usableª** result.¢*/Ù/SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(ÙC  PCache *pCache,             /* Obtain the page from this cache */Ù8  Pgno pgno,                  /* Page number obtained */ÙM  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */¢){°  PgHdr *pPgHdr; µ  assert( pPage!=0 );Ù"  pPgHdr = (PgHdr *)pPage->pExtra; ·  if( !pPgHdr->pPage ){Ù:    return pcacheFetchFinishWithInit(pCache, pgno, pPage);£  }´  pCache->nRefSum++;±  pPgHdr->nRef++;Ù,  assert( sqlite3PcachePageSanity(pPgHdr) );°  return pPgHdr;¡} ¢/*ÙH** Decrement the reference count on a page. If the page is clean and theÙF** reference count drops to 0, then it is made eligible for recycling.¢*/ÙCSQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){¶  assert( p->nRef>0 );·  p->pCache->nRefSum--;·  if( (--p->nRef)==0 ){¿    if( p->flags&PGHDR_CLEAN ){µ      pcacheUnpin(p);ª    }else{Ù7      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);¥    }£  }¡} ¢/*Ù8** Increase the reference count of a supplied page by 1.¢*/Ù/SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p){´  assert(p->nRef>0);Ù'  assert( sqlite3PcachePageSanity(p) );¬  p->nRef++;·  p->pCache->nRefSum++;¡} ¢/*ÙI** Drop a page from the cache. There must be exactly one reference to theÙF** page. This function deletes that reference, so after it returns theÙ#** page pointed to by p is invalid.¢*/Ù0SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p){·  assert( p->nRef==1 );Ù'  assert( sqlite3PcachePageSanity(p) );½  if( p->flags&PGHDR_DIRTY ){Ù6    pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);£  }·  p->pCache->nRefSum--;ÙE  sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);¡} ¢/*ÙD** Make sure the page is marked as dirty. If it isn't dirty already,®** make it so.¢*/Ù5SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr *p){¶  assert( p->nRef>0 );Ù'  assert( sqlite3PcachePageSanity(p) );ÙO  if( p->flags & (PGHDR_CLEAN|PGHDR_DONT_WRITE) ){    /*OPTIMIZATION-IF-FALSE*/Ù"    p->flags &= ~PGHDR_DONT_WRITE;Ù!    if( p->flags & PGHDR_CLEAN ){Ù,      p->flags ^= (PGHDR_DIRTY|PGHDR_CLEAN);Ù7      pcacheTrace(("%p.DIRTY %d\n",p->pCache,p->pgno));ÙD      assert( (p->flags & (PGHDR_DIRTY|PGHDR_CLEAN))==PGHDR_DIRTY );Ù5      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_ADD);¥    }Ù)    assert( sqlite3PcachePageSanity(p) );£  }¡} ¢/*ÙD** Make sure the page is marked as clean. If it isn't clean already,®** make it so.¢*/Ù5SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr *p){Ù'  assert( sqlite3PcachePageSanity(p) );Ù(  assert( (p->flags & PGHDR_DIRTY)!=0 );Ù(  assert( (p->flags & PGHDR_CLEAN)==0 );Ù4  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);Ù=  p->flags &= ~(PGHDR_DIRTY|PGHDR_NEED_SYNC|PGHDR_WRITEABLE);º  p->flags |= PGHDR_CLEAN;Ù3  pcacheTrace(("%p.CLEAN %d\n",p->pCache,p->pgno));Ù'  assert( sqlite3PcachePageSanity(p) );³  if( p->nRef==0 ){³    pcacheUnpin(p);£  }¡} ¢/*Ù&** Make every page in the cache clean.¢*/Ù:SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache){«  PgHdr *p;Ù)  pcacheTrace(("%p.CLEAN-ALL\n",pCache));Ù#  while( (p = pCache->pDirty)!=0 ){¾    sqlite3PcacheMakeClean(p);£  }¡} ¢/*ÙK** Clear the PGHDR_NEED_SYNC and PGHDR_WRITEABLE flag from all dirty pages.¢*/Ù?SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache *pCache){«  PgHdr *p;Ù/  pcacheTrace(("%p.CLEAR-WRITEABLE\n",pCache));Ù,  for(p=pCache->pDirty; p; p=p->pDirtyNext){Ù3    p->flags &= ~(PGHDR_NEED_SYNC|PGHDR_WRITEABLE);£  }Ù'  pCache->pSynced = pCache->pDirtyTail;¡} ¢/*Ù7** Clear the PGHDR_NEED_SYNC flag from all dirty pages.¢*/Ù@SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache){«  PgHdr *p;Ù,  for(p=pCache->pDirty; p; p=p->pDirtyNext){Ù!    p->flags &= ~PGHDR_NEED_SYNC;£  }Ù'  pCache->pSynced = pCache->pDirtyTail;¡} ¢/*Ù0** Change the page number of page p to newPgno. ¢*/Ù>SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){½  PCache *pCache = p->pCache;¶  assert( p->nRef>0 );¶  assert( newPgno>0 );Ù'  assert( sqlite3PcachePageSanity(p) );Ù=  pcacheTrace(("%p.MOVE %d -> %d\n",pCache,p->pgno,newPgno));ÙP  sqlite3GlobalConfig.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno,newPgno);´  p->pgno = newPgno;Ù=  if( (p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC) ){Ù5    pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);£  }¡} ¢/*ÙG** Drop every cache entry whose page number is greater than "pgno". TheÙK** caller must ensure that there are no outstanding references to any pagesÙ:** other than page 1 with a page number greater than pgno.¢**ÙJ** If there is a reference to page 1 and the pgno parameter passed to thisÙJ** function is 0, then the data area associated with page 1 is zeroed, butÙ"** the page object is not dropped.¢*/ÙESQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){·  if( pCache->pCache ){­    PgHdr *p;±    PgHdr *pNext;Ù2    pcacheTrace(("%p.TRUNCATE %d\n",pCache,pgno));Ù&    for(p=pCache->pDirty; p; p=pNext){¼      pNext = p->pDirtyNext;ÙG      /* This routine never gets call with a positive pgno except rightÙE      ** after sqlite3PcacheCleanAll().  So if there are dirty pages,Ù!      ** it must be that pgno==0.¨      */º      assert( p->pgno>0 );¹      if( p->pgno>pgno ){Ù'        assert( p->flags&PGHDR_DIRTY );Ù"        sqlite3PcacheMakeClean(p);§      }¥    }Ù%    if( pgno==0 && pCache->nRefSum ){Ù"      sqlite3_pcache_page *pPage1;ÙF      pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache,1,0);ÙL      if( ALWAYS(pPage1) ){  /* Page 1 is always available in cache, becauseÙ4                             ** pCache->nRefSum>0 */Ù0        memset(pPage1->pBuf, 0, pCache->szPage);±        pgno = 1;§      }¥    }ÙB    sqlite3GlobalConfig.pcache2.xTruncate(pCache->pCache, pgno+1);£  }¡} ¢/*±** Close a cache.¢*/Ù7SQLITE_PRIVATE void sqlite3PcacheClose(PCache *pCache){¾  assert( pCache->pCache!=0 );Ù%  pcacheTrace(("%p.CLOSE\n",pCache));Ù7  sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);¡} £/* Ù%** Discard the contents of the cache.¢*/Ù7SQLITE_PRIVATE void sqlite3PcacheClear(PCache *pCache){Ù#  sqlite3PcacheTruncate(pCache, 0);¡} ¢/*ÙB** Merge two lists of pages connected by pDirty and in pgno order.Ù0** Do not bother fixing the pDirtyPrev pointers.¢*/Ù9static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){·  PgHdr result, *pTail;²  pTail = &result;»  assert( pA!=0 && pB!=0 );ª  for(;;){¼    if( pA->pgno<pB->pgno ){¹      pTail->pDirty = pA;±      pTail = pA;¶      pA = pA->pDirty;²      if( pA==0 ){»        pTail->pDirty = pB;®        break;§      }ª    }else{¹      pTail->pDirty = pB;±      pTail = pB;¶      pB = pB->pDirty;²      if( pB==0 ){»        pTail->pDirty = pA;®        break;§      }¥    }£  }·  return result.pDirty;¡} ¢/*Ù@** Sort the list of pages in accending order by pgno.  Pages areÙ=** connected by pDirty pointers.  The pDirtyPrev pointers areº** corrupted by this sort.¢**ÙE** Since there cannot be more than 2^31 distinct pages in a database,ÙE** there cannot be more than 31 buckets required by the merge sorter.Ù@** One extra bucket is added to catch overflow in case somethingÙ8** ever changes to make the previous sentence incorrect.¢*/¹#define N_SORT_BUCKET  32Ù.static PgHdr *pcacheSortDirtyList(PgHdr *pIn){¾  PgHdr *a[N_SORT_BUCKET], *p;¨  int i;º  memset(a, 0, sizeof(a));¯  while( pIn ){¬    p = pIn;´    pIn = p->pDirty;²    p->pDirty = 0;Ù-    for(i=0; ALWAYS(i<N_SORT_BUCKET-1); i++){´      if( a[i]==0 ){±        a[i] = p;®        break;¬      }else{Ù*        p = pcacheMergeDirtyList(a[i], p);±        a[i] = 0;§      }¥    }Ù$    if( NEVER(i==N_SORT_BUCKET-1) ){ÙD      /* To get here, there need to be 2^(N_SORT_BUCKET) elements inÙ1      ** the input list.  But that is impossible.¨      */Ù+      a[i] = pcacheMergeDirtyList(a[i], p);¥    }£  }«  p = a[0];Ù!  for(i=1; i<N_SORT_BUCKET; i++){»    if( a[i]==0 ) continue;Ù1    p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];£  }«  return p;¡} ¢/*ÙH** Return a list of all dirty pages in the cache, sorted by page number.¢*/Ù=SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){«  PgHdr *p;Ù,  for(p=pCache->pDirty; p; p=p->pDirtyNext){¾    p->pDirty = p->pDirtyNext;£  }Ù-  return pcacheSortDirtyList(pCache->pDirty);¡} £/* ÙH** Return the total number of references to all pages held by the cache.¢**ÙG** This is not the total number of pages referenced, but the sum of theÙ!** reference count for all pages.¢*/Ù9SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){¹  return pCache->nRefSum;¡} ¢/*ÙG** Return the number of references to the page supplied as an argument.¢*/Ù7SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p){±  return p->nRef;¡} £/* Ù1** Return the total number of pages in the cache.¢*/Ù:SQLITE_PRIVATE int sqlite3PcachePagecount(PCache *pCache){¾  assert( pCache->pCache!=0 );Ù@  return sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache);¡} ²#ifdef SQLITE_TEST¢/*Ù&** Get the suggested cache-size value.¢*/Ù=SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *pCache){Ù$  return numberOfCachePages(pCache);¡}¦#endif ¢/*Ù&** Set the suggested cache-size value.¢*/ÙJSQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){¾  assert( pCache->pCache!=0 );»  pCache->szCache = mxPage;Ù8  sqlite3GlobalConfig.pcache2.xCachesize(pCache->pCache,ÙE                                         numberOfCachePages(pCache));¡} ¢/*ÙB** Set the suggested cache-spill value.  Make no changes if if theÙG** argument is zero.  Return the effective cache-spill size, which willÙ,** be the larger of the szSpill and szCache.¢*/ÙDSQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *p, int mxPage){ª  int res;¹  assert( p->pCache!=0 );¯  if( mxPage ){³    if( mxPage<0 ){ÙA      mxPage = (int)((-1024*(i64)mxPage)/(p->szPage+p->szExtra));¥    }¸    p->szSpill = mxPage;£  }¾  res = numberOfCachePages(p);Ù)  if( res<p->szSpill ) res = p->szSpill; ­  return res;¡} ¢/*Ù:** Free up as much memory as possible from the page cache.¢*/Ù8SQLITE_PRIVATE void sqlite3PcacheShrink(PCache *pCache){¾  assert( pCache->pCache!=0 );Ù6  sqlite3GlobalConfig.pcache2.xShrink(pCache->pCache);¡} ¢/*Ù?** Return the size of the header added by this middleware layer¿** in the page-cache hierarchy.¢*/ÙQSQLITE_PRIVATE int sqlite3HeaderSizePcache(void){ return ROUND8(sizeof(PgHdr)); } ¢/*ÙK** Return the number of dirty pages currently in the cache, as a percentageÙ ** of the configured cache size.¢*/Ù=SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache *pCache){°  PgHdr *pDirty;±  int nDirty = 0;Ù*  int nCache = numberOfCachePages(pCache);ÙI  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;Ù:  return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0;¡} Ù8#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)¢/*ÙC** For all dirty pages currently in the cache, invoke the specifiedÙA** callback. This is only used if the SQLITE_CHECK_PAGES macro is«** defined.¢*/ÙVSQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){°  PgHdr *pDirty;Ù@  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext){²    xIter(pDirty);£  }¡}¦#endif ÙO/************** End of pcache.c **********************************************/ÙO/************** Begin file pcache1.c *****************************************/¢/*³** 2008 November 05¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙB** This file implements the default page cache implementation (theÙI** sqlite3_pcache interface). It also contains part of the implementationÙH** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.ÙJ** If the default page cache implementation is overridden, then neither ofÙ$** these two features are available.¢**Ù%** A Page cache line looks like this:¢**ÙA**  -------------------------------------------------------------ÙA**  |  database page content   |  PgHdr1  |  MemPage  |  PgHdr  |ÙA**  -------------------------------------------------------------¢**ÙJ** The database page content is up front (so that buffer overreads tend toÙM** flow harmlessly into the PgHdr1, MemPage, and PgHdr extensions).   MemPageÙK** is the extension added by the btree.c module containing information suchÙI** as the database page number and how that database page is used.  PgHdrÙM** is added by the pcache.c layer and contains information used to keep trackÙD** of which pages are "dirty".  PgHdr1 is an extension added by thisÙO** module (pcache1.c).  The PgHdr1 header is a subclass of sqlite3_pcache_page.ÙK** PgHdr1 contains information needed to look up a page by its page number.ÙE** The superclass sqlite3_pcache_page.pBuf points to the start of theÙH** database page content and sqlite3_pcache_page.pExtra points to PgHdr.¢**ÙH** The size of the extension (MemPage+PgHdr+PgHdr1) can be determined atÙH** runtime using sqlite3_config(SQLITE_CONFIG_PCACHE_HDRSZ, &size).  TheÙG** sizes of the extensions sum to 272 bytes on x64 for 3.8.10, but thisÙE** size can vary according to architecture, compile-time options, andÙ!** SQLite library version number.¢**ÙN** If SQLITE_PCACHE_SEPARATE_HEADER is defined, then the extension is obtainedÙK** using a separate memory allocation from the database page content.  ThisÙC** seeks to overcome the "clownshoe" problem (also called "internalÙH** fragmentation" in academic literature) of allocating a few bytes moreÙH** than a power of two with the memory allocator rounding up to the nextÙ9** power of two, and leaving the rounded-up space unused.¢**ÙM** This module tracks pointers to PgHdr1 objects.  Only pcache.c communicatesÙN** with this module.  Information is passed back and forth as PgHdr1 pointers.¢**ÙC** The pcache.c and pager.c modules deal pointers to PgHdr objects.Ù=** The btree.c module deals with pointers to MemPage objects.¢**¿** SOURCE OF PAGE CACHE MEMORY:¢**Ù:** Memory for a page might come from any of three sources:¢**ÙA**    (1)  The general-purpose memory allocator - sqlite3Malloc()ÙH**    (2)  Global page-cache memory provided using sqlite3_config() withÙ#**         SQLITE_CONFIG_PAGECACHE.Ù(**    (3)  PCache-local bulk allocation.¢**ÙK** The third case is a chunk of heap memory (defaulting to 100 pages worth)ÙK** that is allocated when the page cache is created.  The size of the localÙ)** bulk allocation can be adjusted using ¢**Ù?**     sqlite3_config(SQLITE_CONFIG_PAGECACHE, (void*)0, 0, N).¢**ÙN** If N is positive, then N pages worth of memory are allocated using a singleÙP** sqlite3Malloc() call and that memory is used for the first N pages allocated.ÙK** Or if N is negative, then -1024*N bytes of memory are allocated and usedÙ+** for as many pages as can be accomodated.¢**ÙK** Only one of (2) or (3) can be used.  Once the memory available to (2) orÙL** (3) is exhausted, subsequent allocations fail over to the general-purpose¸** memory allocator (1).¢**ÙM** Earlier versions of SQLite used only methods (1) and (2).  But experimentsÙM** show that method (3) with N==100 provides about a 5% performance boost for´** common workloads.¢*/¼/* #include "sqliteInt.h" */ ¿typedef struct PCache1 PCache1;½typedef struct PgHdr1 PgHdr1;Ù%typedef struct PgFreeslot PgFreeslot;½typedef struct PGroup PGroup; ¢/*ÙC** Each cache entry is represented by an instance of the following ÙJ** structure. Unless SQLITE_PCACHE_SEPARATE_HEADER is defined, a buffer ofÙK** PgHdr1.pCache->szPage bytes is allocated directly before this structure ­** in memory.¢*/¯struct PgHdr1 {ÙO  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf & pExtra */Ù>  unsigned int iKey;             /* Key value (page number) */ÙH  u8 isBulkLocal;                /* This page from bulk local storage */ÙE  u8 isAnchor;                   /* This is the PGroup.lru element */Ù?  PgHdr1 *pNext;                 /* Next in hash table chain */ÙJ  PCache1 *pCache;               /* Cache that currently owns this page */ÙI  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */ÙM  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */¢}; ¢/*Ù/** A page is pinned if it is no on the LRU list¢*/Ù/#define PAGE_IS_PINNED(p)    ((p)->pLruNext==0)Ù/#define PAGE_IS_UNPINNED(p)  ((p)->pLruNext!=0) ÙG/* Each page cache (or PCache) belongs to a PGroup.  A PGroup is a set ÙH** of one or more PCaches that are able to recycle each other's unpinnedÙI** pages when they are under memory pressure.  A PGroup is an instance of¸** the following object.¢**Ù<** This page cache implementation works in one of two modes:¢**ÙF**   (1)  Every PCache is the sole member of its own PGroup.  There isÙ **        one PGroup per PCache.¢**ÙG**   (2)  There is a single global PGroup that all PCaches are a member­**        of.¢**ÙF** Mode 1 uses more memory (since PCache instances are not able to robÙI** unused pages from other PCaches) but it also operates without a mutex,ÙI** and is therefore often faster.  Mode 2 requires a mutex in order to beÙ3** threadsafe, but recycles pages more efficiently.¢**ÙK** For mode (1), PGroup.mutex is NULL.  For mode (2) there is only a singleÙC** PGroup which is the pcache1.grp global variable and its mutex is»** SQLITE_MUTEX_STATIC_LRU.¢*/¯struct PGroup {Ù?  sqlite3_mutex *mutex;          /* MUTEX_STATIC_LRU or NULL */ÙG  unsigned int nMaxPage;         /* Sum of nMax for purgeable caches */ÙG  unsigned int nMinPage;         /* Sum of nMin for purgeable caches */Ù?  unsigned int mxPinned;         /* nMaxpage + 10 - nMinPage */ÙJ  unsigned int nPurgeable;       /* Number of purgeable pages allocated */ÙL  PgHdr1 lru;                    /* The beginning and end of the LRU list */¢}; ÙA/* Each page cache is an instance of the following object.  EveryÙA** open database file (including each in-memory database and eachÙA** temporary or transient database) has a single page cache whichÙ!** is an instance of this object.¢**Ù@** Pointers to structures of this type are cast and returned as Ù"** opaque sqlite3_pcache* handles.¢*/°struct PCache1 {ÙI  /* Cache configuration parameters. Page size (szPage) and the purgeableÙG  ** flag (bPurgeable) and the pnPurgeable pointer are all set when theÙD  ** cache is created and are never changed thereafter. nMax may be ÙE  ** modified at any time by a call to the pcache1Cachesize() method.Ù7  ** The PGroup mutex must be held when accessing nMax.¤  */ÙH  PGroup *pGroup;                     /* PGroup this cache belongs to */ÙI  unsigned int *pnPurgeable;          /* Pointer to pGroup->nPurgeable */ÙL  int szPage;                         /* Size of database content section */ÙI  int szExtra;                        /* sizeof(MemPage)+sizeof(PgHdr) */ÙI  int szAlloc;                        /* Total size of one pcache line */ÙF  int bPurgeable;                     /* True if cache is purgeable */ÙL  unsigned int nMin;                  /* Minimum number of pages reserved */ÙI  unsigned int nMax;                  /* Configured "cache_size" value */Ù5  unsigned int n90pct;                /* nMax*9/10 */ÙN  unsigned int iMaxKey;               /* Largest key seen since xTruncate() */ ÙJ  /* Hash table of all pages. The following variables may only be accessedÙ3  ** when the accessor is holding the PGroup mutex.¤  */ÙK  unsigned int nRecyclable;           /* Number of pages in the LRU list */ÙK  unsigned int nPage;                 /* Total number of pages in apHash */ÙG  unsigned int nHash;                 /* Number of slots in apHash[] */ÙM  PgHdr1 **apHash;                    /* Hash table for fast lookup by key */ÙM  PgHdr1 *pFree;                      /* List of unused pcache-local pages */ÙL  void *pBulk;                        /* Bulk memory used by pcache-local */¢}; ¢/*ÙF** Free slots in the allocator used to divide up the global page cacheÙ?** buffer provided using the SQLITE_CONFIG_PAGECACHE mechanism.¢*/³struct PgFreeslot {Ù*  PgFreeslot *pNext;  /* Next free slot */¢}; ¢/*Ù"** Global data used by this cache.¢*/Ù'static SQLITE_WSD struct PCacheGlobal {ÙE  PGroup grp;                    /* The global PGroup for mode (2) */ Ù@  /* Variables related to SQLITE_CONFIG_PAGECACHE settings.  TheÙE  ** szSlot, nSlot, pStart, pEnd, nReserve, and isInit values are allÙL  ** fixed at sqlite3_initialize() time and do not require mutex protection.Ù@  ** The nFreeSlot and pFree values do require mutex protection.¤  */Ù:  int isInit;                    /* True if initialized */ÙG  int separateCache;             /* Use a new PGroup for each PCache */ÙF  int nInitPage;                 /* Initial bulk allocation size */   Ù=  int szSlot;                    /* Size of each free slot */ÙA  int nSlot;                     /* The number of pcache slots */ÙG  int nReserve;                  /* Try to keep nFreeSlot above this */ÙI  void *pStart, *pEnd;           /* Bounds of global page cache memory */ÙK  /* Above requires no mutex.  Use mutex below for variable that follow. */ÙI  sqlite3_mutex *mutex;          /* Mutex for accessing the following: */Ù7  PgFreeslot *pFree;             /* Free page blocks */ÙD  int nFreeSlot;                 /* Number of unused pcache slots */ÙJ  /* The following value requires a mutex to change.  We skip the mutex onÙL  ** reading because (1) most platforms read a 32-bit integer atomically andÙM  ** (2) even if an incorrect value is read, no great harm is done since thisÙ'  ** is really just an optimization. */ÙF  int bUnderPressure;            /* True if low on PAGECACHE memory */¬} pcache1_g; ¢/*ÙI** All code in this file should access the global structure above via theÙD** alias "pcache1". This ensures that the WSD emulation is used whenÙ6** compiling for systems that do not support real WSD.¢*/Ù8#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g)) ¢/*Ù2** Macros to enter and leave the PCache LRU mutex.¢*/ÙE#if !defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) || SQLITE_THREADSAFE==0Ù4# define pcache1EnterMutex(X)  assert((X)->mutex==0)Ù4# define pcache1LeaveMutex(X)  assert((X)->mutex==0)Ù(# define PCACHE1_MIGHT_USE_GROUP_MUTEX 0¥#elseÙ=# define pcache1EnterMutex(X) sqlite3_mutex_enter((X)->mutex)Ù=# define pcache1LeaveMutex(X) sqlite3_mutex_leave((X)->mutex)Ù(# define PCACHE1_MIGHT_USE_GROUP_MUTEX 1¦#endif ÙP/******************************************************************************/ÙP/******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/  ¢/*ÙG** This function is called during initialization if a static buffer is ÙL** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHEÙI** verb to sqlite3_config(). Parameter pBuf points to an allocation largeÙ4** enough to contain 'n' buffers of 'sz' bytes each.¢**ÙK** This routine is called from sqlite3_initialize() and so it is guaranteedÙD** to be serialized already.  There is no need for further mutexing.¢*/ÙHSQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){·  if( pcache1.isInit ){²    PgFreeslot *p;½    if( pBuf==0 ) sz = n = 0;¶    if( n==0 ) sz = 0;¸    sz = ROUNDDOWN8(sz);¸    pcache1.szSlot = sz;Ù*    pcache1.nSlot = pcache1.nFreeSlot = n;Ù.    pcache1.nReserve = n>90 ? 10 : (n/10 + 1);º    pcache1.pStart = pBuf;¶    pcache1.pFree = 0;¿    pcache1.bUnderPressure = 0;±    while( n-- ){¼      p = (PgFreeslot*)pBuf;¿      p->pNext = pcache1.pFree;¸      pcache1.pFree = p;Ù'      pBuf = (void*)&((char*)pBuf)[sz];¥    }¸    pcache1.pEnd = pBuf;£  }¡} ¢/*ÙH** Try to initialize the pCache->pFree and pCache->pBulk fields.  ReturnÙC** true if pCache->pFree ends up containing one or more free pages.¢*/Ù,static int pcache1InitBulk(PCache1 *pCache){­  i64 szBulk;®  char *zBulk;Ù&  if( pcache1.nInitPage==0 ) return 0;ÙI  /* Do not bother with a bulk allocation if the cache size very small */Ù   if( pCache->nMax<3 ) return 0;½  sqlite3BeginBenignMalloc();¼  if( pcache1.nInitPage>0 ){Ù6    szBulk = pCache->szAlloc * (i64)pcache1.nInitPage;¨  }else{Ù,    szBulk = -1024 * (i64)pcache1.nInitPage;£  }Ù3  if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){Ù/    szBulk = pCache->szAlloc*(i64)pCache->nMax;£  }Ù2  zBulk = pCache->pBulk = sqlite3Malloc( szBulk );»  sqlite3EndBenignMalloc();®  if( zBulk ){Ù9    int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;§    do{Ù3      PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];¼      pX->page.pBuf = zBulk;¿      pX->page.pExtra = &pX[1];º      pX->isBulkLocal = 1;·      pX->isAnchor = 0;Ù       pX->pNext = pCache->pFree;¹      pCache->pFree = pX;¿      zBulk += pCache->szAlloc;¶    }while( --nBulk );£  }º  return pCache->pFree!=0;¡} ¢/*ÙJ** Malloc function used within this file to allocate space from the bufferÙJ** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no ÙK** such buffer exists or there is no space left in it, this function falls »** back to sqlite3Malloc().¢**ÙL** Multiple threads can run this routine at the same time.  Global variablesÙ-** in pcache1 need to be protected via mutex.¢*/Ù%static void *pcache1Alloc(int nByte){®  void *p = 0;Ù5  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );¾  if( nByte<=pcache1.szSlot ){Ù'    sqlite3_mutex_enter(pcache1.mutex);Ù     p = (PgHdr1 *)pcache1.pFree;¬    if( p ){Ù+      pcache1.pFree = pcache1.pFree->pNext;º      pcache1.nFreeSlot--;ÙB      pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;Ù%      assert( pcache1.nFreeSlot>=0 );ÙB      sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);Ù7      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);¥    }Ù'    sqlite3_mutex_leave(pcache1.mutex);£  }­  if( p==0 ){ÙH    /* Memory is not available in the SQLITE_CONFIG_PAGECACHE pool.  GetÙ%    ** it from sqlite3Malloc instead.¦    */½    p = sqlite3Malloc(nByte);Ù/#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS¬    if( p ){Ù$      int sz = sqlite3MallocSize(p);Ù)      sqlite3_mutex_enter(pcache1.mutex);ÙB      sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);Ù<      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);Ù)      sqlite3_mutex_leave(pcache1.mutex);¥    }¦#endifÙ.    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);£  }«  return p;¡} ¢/*Ù9** Free an allocated buffer obtained from pcache1Alloc().¢*/Ù!static void pcache1Free(void *p){´  if( p==0 ) return;Ù7  if( SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd) ){¶    PgFreeslot *pSlot;Ù'    sqlite3_mutex_enter(pcache1.mutex);Ù7    sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);»    pSlot = (PgFreeslot*)p;Ù!    pSlot->pNext = pcache1.pFree;º    pcache1.pFree = pSlot;¸    pcache1.nFreeSlot++;Ù@    pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;Ù/    assert( pcache1.nFreeSlot<=pcache1.nSlot );Ù'    sqlite3_mutex_leave(pcache1.mutex);¨  }else{Ù8    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );Ù,    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);Ù/#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS¥    {µ      int nFreed = 0;Ù$      nFreed = sqlite3MallocSize(p);Ù)      sqlite3_mutex_enter(pcache1.mutex);ÙB      sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);Ù)      sqlite3_mutex_leave(pcache1.mutex);¥    }¦#endif´    sqlite3_free(p);£  }¡} Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT¢/*Ù)** Return the size of a pcache allocation¢*/Ù#static int pcache1MemSize(void *p){Ù,  if( p>=pcache1.pStart && p<pcache1.pEnd ){º    return pcache1.szSlot;¨  }else{®    int iSize;Ù8    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );Ù,    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);Ù!    iSize = sqlite3MallocSize(p);Ù.    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);±    return iSize;£  }¡}Ù,#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */ ¢/*ÙE** Allocate a new page object initially associated with cache pCache.¢*/ÙCstatic PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){°  PgHdr1 *p = 0;¬  void *pPg; Ù6  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );ÙG  if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){¶    p = pCache->pFree;½    pCache->pFree = p->pNext;±    p->pNext = 0;¨  }else{Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTÙM    /* The group mutex must be released before pcache1Alloc() is called. ThisÙM    ** is because it might call sqlite3_release_memory(), which assumes that Ù!    ** this mutex is not held. */Ù'    assert( pcache1.separateCache==0 );Ù+    assert( pCache->pGroup==&pcache1.grp );Ù&    pcache1LeaveMutex(pCache->pGroup);¦#endifÙ5    if( benignMalloc ){ sqlite3BeginBenignMalloc(); }Ù$#ifdef SQLITE_PCACHE_SEPARATE_HEADERÙ'    pPg = pcache1Alloc(pCache->szPage);Ù8    p = sqlite3Malloc(sizeof(PgHdr1) + pCache->szExtra);µ    if( !pPg || !p ){·      pcache1Free(pPg);¶      sqlite3_free(p);®      pPg = 0;¥    }¥#elseÙ(    pPg = pcache1Alloc(pCache->szAlloc);Ù/    p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];¦#endifÙ3    if( benignMalloc ){ sqlite3EndBenignMalloc(); }Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENTÙ&    pcache1EnterMutex(pCache->pGroup);¦#endifº    if( pPg==0 ) return 0;·    p->page.pBuf = pPg;»    p->page.pExtra = &p[1];·    p->isBulkLocal = 0;´    p->isAnchor = 0;£  }»  (*pCache->pnPurgeable)++;«  return p;¡} ¢/*Ù6** Free a page object allocated by pcache1AllocPage().¢*/Ù'static void pcache1FreePage(PgHdr1 *p){²  PCache1 *pCache;±  assert( p!=0 );µ  pCache = p->pCache;Ù9  assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );·  if( p->isBulkLocal ){½    p->pNext = pCache->pFree;¶    pCache->pFree = p;¨  }else{¾    pcache1Free(p->page.pBuf);Ù$#ifdef SQLITE_PCACHE_SEPARATE_HEADER´    sqlite3_free(p);¦#endif£  }»  (*pCache->pnPurgeable)--;¡} ¢/*ÙL** Malloc function used by SQLite to obtain space from the buffer configuredÙJ** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such bufferÙ7** exists, this function falls back to sqlite3Malloc().¢*/Ù/SQLITE_PRIVATE void *sqlite3PageMalloc(int sz){º  return pcache1Alloc(sz);¡} ¢/*Ù>** Free an allocated buffer obtained from sqlite3PageMalloc().¢*/Ù-SQLITE_PRIVATE void sqlite3PageFree(void *p){±  pcache1Free(p);¡}  ¢/*ÙC** Return true if it desirable to avoid allocating a new page cache©** entry.¢**Ù?** If memory was allocated specifically to the page cache usingÙB** SQLITE_CONFIG_PAGECACHE but that memory has all been used, thenÙE** it is desirable to avoid allocating a new page cache entry becauseÙB** presumably SQLITE_CONFIG_PAGECACHE was suppose to be sufficientÙ?** for all page cache needs and we should not need to spill the¼** allocation onto the heap.¢**ÙA** Or, the heap is used for all page cache memory but the heap isÙ=** under memory pressure, then again it is desirable to avoidÙ@** allocating a new page cache entry in order to avoid stressing¹** the heap even further.¢*/Ù7static int pcache1UnderMemoryPressure(PCache1 *pCache){ÙJ  if( pcache1.nSlot && (pCache->szPage+pCache->szExtra)<=pcache1.szSlot ){Ù"    return pcache1.bUnderPressure;¨  }else{Ù#    return sqlite3HeapNearlyFull();£  }¡} ÙP/******************************************************************************/ÙP/******** General Implementation Functions ************************************/ ¢/*ÙJ** This function is used to resize the hash table used by the cache passed¹** as the first argument.¢**Ù>** The PCache mutex must be held when this function is called.¢*/Ù*static void pcache1ResizeHash(PCache1 *p){±  PgHdr1 **apNew;´  unsigned int nNew;±  unsigned int i; Ù1  assert( sqlite3_mutex_held(p->pGroup->mutex) ); ´  nNew = p->nHash*2;±  if( nNew<256 ){¯    nNew = 256;£  } ¿  pcache1LeaveMutex(p->pGroup);Ù/  if( p->nHash ){ sqlite3BeginBenignMalloc(); }Ù>  apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);Ù-  if( p->nHash ){ sqlite3EndBenignMalloc(); }¿  pcache1EnterMutex(p->pGroup);®  if( apNew ){¾    for(i=0; i<p->nHash; i++){´      PgHdr1 *pPage;Ù#      PgHdr1 *pNext = p->apHash[i];Ù"      while( (pPage = pNext)!=0 ){Ù,        unsigned int h = pPage->iKey % nNew;½        pNext = pPage->pNext;Ù         pPage->pNext = apNew[h];¹        apNew[h] = pPage;§      }¥    }¼    sqlite3_free(p->apHash);¶    p->apHash = apNew;´    p->nHash = nNew;£  }¡} ¢/*ÙF** This function is used internally to remove the page pPage from the ÙH** PGroup LRU list, if is part of it. If pPage is not part of the PGroupÙ+** LRU list, then this function is a no-op.¢**Ù>** The PGroup mutex must be held when this function is called.¢*/Ù-static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){µ  assert( pPage!=0 );Ù$  assert( PAGE_IS_UNPINNED(pPage) );¼  assert( pPage->pLruNext );¼  assert( pPage->pLruPrev );Ù=  assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );Ù.  pPage->pLruPrev->pLruNext = pPage->pLruNext;Ù.  pPage->pLruNext->pLruPrev = pPage->pLruPrev;¶  pPage->pLruNext = 0;¶  pPage->pLruPrev = 0;¿  assert( pPage->isAnchor==0 );Ù3  assert( pPage->pCache->pGroup->lru.isAnchor==1 );¿  pPage->pCache->nRecyclable--;¯  return pPage;¡}  ¢/*Ù?** Remove the page supplied as an argument from the hash table Ù=** (PCache1.apHash structure) that it is currently stored in.Ù*** Also free the page if freePage is true.¢**Ù>** The PGroup mutex must be held when this function is called.¢*/Ù?static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){±  unsigned int h;Ù"  PCache1 *pCache = pPage->pCache;®  PgHdr1 **pp; Ù6  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );Ù"  h = pPage->iKey % pCache->nHash;Ù=  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);µ  *pp = (*pp)->pNext; ²  pCache->nPage--;Ù(  if( freeFlag ) pcache1FreePage(pPage);¡} ¢/*ÙA** If there are currently more than nMaxPage pages allocated, tryÙ?** to recycle pages to reduce the number allocated to nMaxPage.¢*/Ù3static void pcache1EnforceMaxPage(PCache1 *pCache){Ù"  PGroup *pGroup = pCache->pGroup;¬  PgHdr1 *p;Ù.  assert( sqlite3_mutex_held(pGroup->mutex) );Ù,  while( pGroup->nPurgeable>pGroup->nMaxPageÙ.      && (p=pGroup->lru.pLruPrev)->isAnchor==0¤  ){Ù(    assert( p->pCache->pGroup==pGroup );Ù"    assert( PAGE_IS_UNPINNED(p) );¶    pcache1PinPage(p);Ù     pcache1RemoveFromHash(p, 1);£  }Ù*  if( pCache->nPage==0 && pCache->pBulk ){Ù     sqlite3_free(pCache->pBulk);Ù&    pCache->pBulk = pCache->pFree = 0;£  }¡} ¢/*ÙF** Discard all pages from cache pCache with a page number (key value) ÙD** greater than or equal to iLimit. Any pinned pages that meet this Ù3** criteria are unpinned before they are discarded.¢**Ù>** The PCache mutex must be held when this function is called.¢*/Ù"static void pcache1TruncateUnsafe(Ù:  PCache1 *pCache,             /* The cache to truncate */ÙH  unsigned int iLimit          /* Drop pages with this pgno or larger */¢){ÙF  TESTONLY( int nPage = 0; )  /* To assert pCache->nPage is correct */¸  unsigned int h, iStop;Ù6  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );Ù&  assert( pCache->iMaxKey >= iLimit );¾  assert( pCache->nHash > 0 );Ù1  if( pCache->iMaxKey - iLimit < pCache->nHash ){ÙC    /* If we are just shaving the last few pages off the end of theÙG    ** cache, then there is no point in scanning the entire hash table.ÙG    ** Only scan those hash slots that might contain pages that need toµ    ** be removed. */¿    h = iLimit % pCache->nHash;Ù,    iStop = pCache->iMaxKey % pCache->nHash;ÙL    TESTONLY( nPage = -10; )  /* Disable the pCache->nPage validity check */¨  }else{ÙC    /* This is the general case where many pages are being removed.Ù7    ** It is necessary to scan the entire hash table */¸    h = pCache->nHash/2;²    iStop = h - 1;£  }ª  for(;;){°    PgHdr1 **pp;²    PgHdr1 *pPage;¾    assert( h<pCache->nHash );½    pp = &pCache->apHash[h]; ¾    while( (pPage = *pp)!=0 ){Ù       if( pPage->iKey>=iLimit ){¸        pCache->nPage--;»        *pp = pPage->pNext;Ù<        if( PAGE_IS_UNPINNED(pPage) ) pcache1PinPage(pPage);¿        pcache1FreePage(pPage);¬      }else{»        pp = &pPage->pNext;Ù+        TESTONLY( if( nPage>=0 ) nPage++; )§      }¥    }¹    if( h==iStop ) break;¾    h = (h+1) % pCache->nHash;£  }Ù6  assert( nPage<0 || pCache->nPage==(unsigned)nPage );¡} ÙP/******************************************************************************/ÙP/******** sqlite3_pcache Methods **********************************************/ ¢/*Ù5** Implementation of the sqlite3_pcache.xInit method.¢*/Ù&static int pcache1Init(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);¾  assert( pcache1.isInit==0 );Ù'  memset(&pcache1, 0, sizeof(pcache1));  ¤  /*ÙJ  ** The pcache1.separateCache variable is true if each PCache has its ownÙK  ** private PGroup (mode-1).  pcache1.separateCache is false if the singleÙ@  ** PGroup in pcache1.grp is used for all page caches (mode-2).¤  **ÙI  **   *  Always use a unified cache (mode-2) if ENABLE_MEMORY_MANAGEMENT¤  **ÙG  **   *  Use a unified cache in single-threaded applications that haveÙK  **      configured a start-time buffer for use as page-cache memory usingÙM  **      sqlite3_config(SQLITE_CONFIG_PAGECACHE, pBuf, sz, N) with non-NULL ¸  **      pBuf argument.¤  **Ù0  **   *  Otherwise use separate caches (mode-1)¤  */Ù,#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT)¼  pcache1.separateCache = 0;·#elif SQLITE_THREADSAFEÙ6  pcache1.separateCache = sqlite3GlobalConfig.pPage==0Ù>                          || sqlite3GlobalConfig.bCoreMutex>0;¥#elseÙ7  pcache1.separateCache = sqlite3GlobalConfig.pPage==0;¦#endif µ#if SQLITE_THREADSAFEÙ'  if( sqlite3GlobalConfig.bCoreMutex ){ÙC    pcache1.grp.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU);Ù@    pcache1.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PMEM);£  }¦#endif»  if( pcache1.separateCacheÙ"   && sqlite3GlobalConfig.nPage!=0Ù"   && sqlite3GlobalConfig.pPage==0¤  ){Ù2    pcache1.nInitPage = sqlite3GlobalConfig.nPage;¨  }else{º    pcache1.nInitPage = 0;£  }¼  pcache1.grp.mxPinned = 10;µ  pcache1.isInit = 1;³  return SQLITE_OK;¡} ¢/*Ù9** Implementation of the sqlite3_pcache.xShutdown method.Ù6** Note that the static mutex allocated in xInit does ¸** not need to be freed.¢*/Ù+static void pcache1Shutdown(void *NotUsed){¼  UNUSED_PARAMETER(NotUsed);¾  assert( pcache1.isInit!=0 );Ù'  memset(&pcache1, 0, sizeof(pcache1));¡} ¹/* forward declaration */Ù.static void pcache1Destroy(sqlite3_pcache *p); ¢/*Ù7** Implementation of the sqlite3_pcache.xCreate method.¢**¸** Allocate a new cache.¢*/ÙNstatic sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){Ù:  PCache1 *pCache;      /* The newly created page cache */ÙI  PGroup *pGroup;       /* The group the new page cache will belong to */ÙP  int sz;               /* Bytes of memory required to allocate the new cache */ ÙE  assert( (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 );º  assert( szExtra < 300 ); Ù>  sz = sizeof(PCache1) + sizeof(PGroup)*pcache1.separateCache;Ù,  pCache = (PCache1 *)sqlite3MallocZero(sz);¯  if( pCache ){Ù     if( pcache1.separateCache ){Ù#      pGroup = (PGroup*)&pCache[1];¼      pGroup->mxPinned = 10;ª    }else{¼      pGroup = &pcache1.grp;¥    }Ù"    if( pGroup->lru.isAnchor==0 ){¿      pGroup->lru.isAnchor = 1;ÙA      pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;¥    }¼    pCache->pGroup = pGroup;¼    pCache->szPage = szPage;¾    pCache->szExtra = szExtra;Ù@    pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));Ù.    pCache->bPurgeable = (bPurgeable ? 1 : 0);¾    pcache1EnterMutex(pGroup);¾    pcache1ResizeHash(pCache);µ    if( bPurgeable ){¸      pCache->nMin = 10;Ù'      pGroup->nMinPage += pCache->nMin;ÙB      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;Ù0      pCache->pnPurgeable = &pGroup->nPurgeable;ª    }else{Ù+      static unsigned int dummyCurrentPage;Ù.      pCache->pnPurgeable = &dummyCurrentPage;¥    }¾    pcache1LeaveMutex(pGroup);»    if( pCache->nHash==0 ){Ù.      pcache1Destroy((sqlite3_pcache*)pCache);±      pCache = 0;¥    }£  }Ù"  return (sqlite3_pcache *)pCache;¡} ¢/*Ù;** Implementation of the sqlite3_pcache.xCachesize method. ¢**Ù.** Configure the cache_size limit for a cache.¢*/Ù:static void pcache1Cachesize(sqlite3_pcache *p, int nMax){Ù!  PCache1 *pCache = (PCache1 *)p;»  if( pCache->bPurgeable ){Ù$    PGroup *pGroup = pCache->pGroup;¾    pcache1EnterMutex(pGroup);Ù.    pGroup->nMaxPage += (nMax - pCache->nMax);Ù@    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;¸    pCache->nMax = nMax;Ù'    pCache->n90pct = pCache->nMax*9/10;Ù"    pcache1EnforceMaxPage(pCache);¾    pcache1LeaveMutex(pGroup);£  }¡} ¢/*Ù8** Implementation of the sqlite3_pcache.xShrink method. ¢**Ù&** Free up as much memory as possible.¢*/Ù-static void pcache1Shrink(sqlite3_pcache *p){Ù   PCache1 *pCache = (PCache1*)p;»  if( pCache->bPurgeable ){Ù$    PGroup *pGroup = pCache->pGroup;µ    int savedMaxPage;¾    pcache1EnterMutex(pGroup);Ù$    savedMaxPage = pGroup->nMaxPage;¹    pGroup->nMaxPage = 0;Ù"    pcache1EnforceMaxPage(pCache);Ù$    pGroup->nMaxPage = savedMaxPage;¾    pcache1LeaveMutex(pGroup);£  }¡} ¢/*Ù;** Implementation of the sqlite3_pcache.xPagecount method. ¢*/Ù/static int pcache1Pagecount(sqlite3_pcache *p){¨  int n;Ù   PCache1 *pCache = (PCache1*)p;Ù$  pcache1EnterMutex(pCache->pGroup);´  n = pCache->nPage;Ù$  pcache1LeaveMutex(pCache->pGroup);«  return n;¡}  ¢/*ÙH** Implement steps 3, 4, and 5 of the pcache1Fetch() algorithm describedÙ1** in the header of the pcache1Fetch() procedure.¢**ÙG** This steps are broken out into a separate procedure because they areÙH** usually not needed, and by avoiding the stack initialization requiredÙE** for these steps, the main pcache1Fetch() procedure can run faster.¢*/Ù2static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(³  PCache1 *pCache, µ  unsigned int iKey, °  int createFlag¢){·  unsigned int nPinned;Ù"  PGroup *pGroup = pCache->pGroup;´  PgHdr1 *pPage = 0; ÙE  /* Step 3: Abort if createFlag is 1 but the cache is nearly full */Ù1  assert( pCache->nPage >= pCache->nRecyclable );Ù0  nPinned = pCache->nPage - pCache->nRecyclable;ÙI  assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );Ù0  assert( pCache->n90pct == pCache->nMax*9/10 );¸  if( createFlag==1 && (Ù!        nPinned>=pGroup->mxPinned¿     || nPinned>=pCache->n90pctÙK     || (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)¥  )){­    return 0;£  } Ù?  if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);Ù.  assert( pCache->nHash>0 && pCache->apHash ); Ù&  /* Step 4. Try to recycle a page. */¸  if( pCache->bPurgeableÙ%   && !pGroup->lru.pLruPrev->isAnchorÙM   && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))¤  ){´    PCache1 *pOther;Ù!    pPage = pGroup->lru.pLruPrev;Ù&    assert( PAGE_IS_UNPINNED(pPage) );Ù$    pcache1RemoveFromHash(pPage, 0);º    pcache1PinPage(pPage);»    pOther = pPage->pCache;Ù-    if( pOther->szAlloc != pCache->szAlloc ){½      pcache1FreePage(pPage);°      pPage = 0;ª    }else{ÙF      pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);¥    }£  } Ù?  /* Step 5. If a usable page buffer has still not been found, Ù$  ** attempt to allocate a new one. ¤  */¯  if( !pPage ){Ù4    pPage = pcache1AllocPage(pCache, createFlag==1);£  } ®  if( pPage ){Ù*    unsigned int h = iKey % pCache->nHash;´    pCache->nPage++;·    pPage->iKey = iKey;Ù%    pPage->pNext = pCache->apHash[h];»    pPage->pCache = pCache;¸    pPage->pLruPrev = 0;¸    pPage->pLruNext = 0;Ù%    *(void **)pPage->page.pExtra = 0;¾    pCache->apHash[h] = pPage;¿    if( iKey>pCache->iMaxKey ){½      pCache->iMaxKey = iKey;¥    }£  }¯  return pPage;¡} ¢/*Ù7** Implementation of the sqlite3_pcache.xFetch method. ¢**½** Fetch a page by key value.¢**ÙI** Whether or not a new page may be allocated by this function depends onÙG** the value of the createFlag argument.  0 means do not allocate a newÙG** page.  1 means allocate a new page if space is easily available.  2 Ù3** means to try really hard to allocate a new page.¢**ÙJ** For a non-purgeable cache (a cache used as the storage for an in-memoryÙJ** database) there is really no difference between createFlag 1 and 2.  SoÙG** the calling function (pcache.c) will never have a createFlag of 1 on¹** a non-purgeable cache.¢**ÙF** There are three different approaches to obtaining space for a page,ÙK** depending on the value of parameter createFlag (which may be 0, 1 or 2).¢**ÙK**   1. Regardless of the value of createFlag, the cache is searched for a ÙD**      copy of the requested page. If one is found, it is returned.¢**ÙJ**   2. If createFlag==0 and the page is not already in the cache, NULL is±**      returned.¢**ÙJ**   3. If createFlag is 1, and the page is not already in the cache, thenÙH**      return NULL (do not allocate a new page) if any of the following¼**      conditions are true:¢**ÙD**       (a) the number of pages pinned by the cache is greater than½**           PCache1.nMax, or¢**ÙD**       (b) the number of pages pinned by the cache is greater thanÙG**           the sum of nMax for all purgeable caches, less the sum of Ù4**           nMin for all other purgeable caches, or¢**ÙK**   4. If none of the first three conditions apply and the cache is markedÙ:**      as purgeable, and if one of the following is true:¢**ÙD**       (a) The number of pages allocated for the cache is already ½**           PCache1.nMax, or¢**ÙF**       (b) The number of pages allocated for all purgeable caches isÙE**           already equal to or greater than the sum of nMax for all¾**           purgeable caches,¢**ÙC**       (c) The system is under memory pressure and wants to avoidÙ6**           unnecessary pages cache entry allocations¢**ÙL**      then attempt to recycle a page from the LRU list. If it is the rightÙH**      size, return the recycled buffer. Otherwise, free the buffer and»**      proceed to step 5. ¢**Ù9**   5. Otherwise, allocate and return a new page buffer.¢**ÙF** There are two versions of this routine.  pcache1FetchWithMutex() isÙJ** the general case.  pcache1FetchNoMutex() is a faster implementation forÙK** the common case where pGroup->mutex is NULL.  The pcache1Fetch() wrapperÙ#** invokes the appropriate routine.¢*/Ù#static PgHdr1 *pcache1FetchNoMutex(µ  sqlite3_pcache *p, µ  unsigned int iKey, °  int createFlag¢){Ù!  PCache1 *pCache = (PCache1 *)p;´  PgHdr1 *pPage = 0; Ù<  /* Step 1: Search the hash table for an existing entry. */Ù/  pPage = pCache->apHash[iKey % pCache->nHash];Ù>  while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; } ÙE  /* Step 2: If the page was found in the hash table, then return it.ÙF  ** If the page was not in the hash table and createFlag is 0, abort.ÙA  ** Otherwise (page not in hash and createFlag!=0) continue withÙ3  ** subsequent steps to try to create the page. */®  if( pPage ){Ù"    if( PAGE_IS_UNPINNED(pPage) ){Ù#      return pcache1PinPage(pPage);ª    }else{³      return pPage;¥    }¹  }else if( createFlag ){Ù:    /* Steps 3, 4, and 5 implemented by this subroutine */Ù8    return pcache1FetchStage2(pCache, iKey, createFlag);¨  }else{­    return 0;£  }¡}Ù!#if PCACHE1_MIGHT_USE_GROUP_MUTEXÙ%static PgHdr1 *pcache1FetchWithMutex(µ  sqlite3_pcache *p, µ  unsigned int iKey, °  int createFlag¢){Ù!  PCache1 *pCache = (PCache1 *)p;°  PgHdr1 *pPage; Ù$  pcache1EnterMutex(pCache->pGroup);Ù3  pPage = pcache1FetchNoMutex(p, iKey, createFlag);Ù.  assert( pPage==0 || pCache->iMaxKey>=iKey );Ù$  pcache1LeaveMutex(pCache->pGroup);¯  return pPage;¡}¦#endifÙ)static sqlite3_pcache_page *pcache1Fetch(µ  sqlite3_pcache *p, µ  unsigned int iKey, °  int createFlag¢){Ù:#if PCACHE1_MIGHT_USE_GROUP_MUTEX || defined(SQLITE_DEBUG)Ù!  PCache1 *pCache = (PCache1 *)p;¦#endif Ù%  assert( offsetof(PgHdr1,page)==0 );Ù0  assert( pCache->bPurgeable || createFlag!=1 );Ù2  assert( pCache->bPurgeable || pCache->nMin==0 );Ù6  assert( pCache->bPurgeable==0 || pCache->nMin==10 );Ù2  assert( pCache->nMin==0 || pCache->bPurgeable );¼  assert( pCache->nHash>0 );Ù!#if PCACHE1_MIGHT_USE_GROUP_MUTEX¾  if( pCache->pGroup->mutex ){ÙL    return (sqlite3_pcache_page*)pcache1FetchWithMutex(p, iKey, createFlag);§  }else¦#endif£  {ÙJ    return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);£  }¡}  ¢/*Ù6** Implementation of the sqlite3_pcache.xUnpin method.¢**ÙA** Mark a page as unpinned (eligible for asynchronous recycling).¢*/¹static void pcache1Unpin(µ  sqlite3_pcache *p, ¼  sqlite3_pcache_page *pPg, ³  int reuseUnlikely¢){Ù!  PCache1 *pCache = (PCache1 *)p;Ù   PgHdr1 *pPage = (PgHdr1 *)pPg;Ù"  PGroup *pGroup = pCache->pGroup;¡ Ù"  assert( pPage->pCache==pCache );¼  pcache1EnterMutex(pGroup); ÙA  /* It is an error to call this function if the page is already Ù!  ** part of the PGroup LRU list.¤  */Ù5  assert( pPage->pLruPrev==0 && pPage->pLruNext==0 );Ù"  assert( PAGE_IS_PINNED(pPage) ); Ù=  if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){Ù$    pcache1RemoveFromHash(pPage, 1);¨  }else{Ù.    /* Add the page to the PGroup LRU list. */Ù-    PgHdr1 **ppFirst = &pGroup->lru.pLruNext;Ù#    pPage->pLruPrev = &pGroup->lru;Ù3    (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;µ    *ppFirst = pPage;º    pCache->nRecyclable++;£  } Ù$  pcache1LeaveMutex(pCache->pGroup);¡} ¢/*Ù7** Implementation of the sqlite3_pcache.xRekey method. ¢*/¹static void pcache1Rekey(´  sqlite3_pcache *p,»  sqlite3_pcache_page *pPg,´  unsigned int iOld,³  unsigned int iNew¢){Ù!  PCache1 *pCache = (PCache1 *)p;Ù   PgHdr1 *pPage = (PgHdr1 *)pPg;®  PgHdr1 **pp;²  unsigned int h; ¾  assert( pPage->iKey==iOld );Ù"  assert( pPage->pCache==pCache ); Ù$  pcache1EnterMutex(pCache->pGroup); ¹  h = iOld%pCache->nHash;º  pp = &pCache->apHash[h];¸  while( (*pp)!=pPage ){·    pp = &(*pp)->pNext;£  }µ  *pp = pPage->pNext; ¹  h = iNew%pCache->nHash;µ  pPage->iKey = iNew;Ù#  pPage->pNext = pCache->apHash[h];¼  pCache->apHash[h] = pPage;½  if( iNew>pCache->iMaxKey ){»    pCache->iMaxKey = iNew;£  } Ù$  pcache1LeaveMutex(pCache->pGroup);¡} ¢/*Ù:** Implementation of the sqlite3_pcache.xTruncate method. ¢**ÙF** Discard all unpinned pages in the cache with a page number equal toÙH** or greater than parameter iLimit. Any pinned pages with a page numberÙ;** equal to or greater than iLimit are implicitly unpinned.¢*/ÙDstatic void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){Ù!  PCache1 *pCache = (PCache1 *)p;Ù$  pcache1EnterMutex(pCache->pGroup);Ù   if( iLimit<=pCache->iMaxKey ){Ù*    pcache1TruncateUnsafe(pCache, iLimit);¿    pCache->iMaxKey = iLimit-1;£  }Ù$  pcache1LeaveMutex(pCache->pGroup);¡} ¢/*Ù9** Implementation of the sqlite3_pcache.xDestroy method. ¢**Ù3** Destroy a cache allocated using pcache1Create().¢*/Ù.static void pcache1Destroy(sqlite3_pcache *p){Ù!  PCache1 *pCache = (PCache1 *)p;Ù"  PGroup *pGroup = pCache->pGroup;ÙG  assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );¼  pcache1EnterMutex(pGroup);Ù7  if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);Ù-  assert( pGroup->nMaxPage >= pCache->nMax );Ù#  pGroup->nMaxPage -= pCache->nMax;Ù-  assert( pGroup->nMinPage >= pCache->nMin );Ù#  pGroup->nMinPage -= pCache->nMin;Ù>  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;Ù   pcache1EnforceMaxPage(pCache);¼  pcache1LeaveMutex(pGroup);¾  sqlite3_free(pCache->pBulk);¿  sqlite3_free(pCache->apHash);·  sqlite3_free(pCache);¡} ¢/*ÙJ** This function is called during initialization (sqlite3_initialize()) toÙH** install the default pluggable cache module, assuming the user has notÙ#** already provided an alternative.¢*/Ù2SQLITE_PRIVATE void sqlite3PCacheSetDefault(void){Ù9  static const sqlite3_pcache_methods2 defaultMethods = {Ù+    1,                       /* iVersion */Ù'    0,                       /* pArg */Ù(    pcache1Init,             /* xInit */Ù,    pcache1Shutdown,         /* xShutdown */Ù*    pcache1Create,           /* xCreate */Ù-    pcache1Cachesize,        /* xCachesize */Ù-    pcache1Pagecount,        /* xPagecount */Ù)    pcache1Fetch,            /* xFetch */Ù)    pcache1Unpin,            /* xUnpin */Ù)    pcache1Rekey,            /* xRekey */Ù,    pcache1Truncate,         /* xTruncate */Ù+    pcache1Destroy,          /* xDestroy */Ù*    pcache1Shrink            /* xShrink */¤  };Ù9  sqlite3_config(SQLITE_CONFIG_PCACHE2, &defaultMethods);¡} ¢/*ÙL** Return the size of the header on each page of this PCACHE implementation.¢*/ÙSSQLITE_PRIVATE int sqlite3HeaderSizePcache1(void){ return ROUND8(sizeof(PgHdr1)); } ¢/*ÙC** Return the global mutex used by this PCACHE implementation.  TheÙ7** sqlite3_status() routine needs access to this mutex.¢*/Ù8SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void){·  return pcache1.mutex;¡} Ù&#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT¢/*ÙK** This function is called to free superfluous dynamically allocated memoryÙH** held by the pager system. Memory in use by any SQLite pager allocatedÙ1** by the current thread may be sqlite3_free()ed.¢**ÙE** nReq is the number of bytes of memory required. Once this much hasÙM** been released, the function returns. The return value is the total number ¿** of bytes of memory released.¢*/Ù8SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){°  int nFree = 0;Ù5  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );Ù1  assert( sqlite3_mutex_notheld(pcache1.mutex) );Ù%  if( sqlite3GlobalConfig.pPage==0 ){®    PgHdr1 *p;Ù$    pcache1EnterMutex(&pcache1.grp);Ù!    while( (nReq<0 || nFree<nReq)Ù*       &&  (p=pcache1.grp.lru.pLruPrev)!=0¹       &&  p->isAnchor==0¦    ){Ù,      nFree += pcache1MemSize(p->page.pBuf);Ù$#ifdef SQLITE_PCACHE_SEPARATE_HEADERÙ!      nFree += sqlite3MemSize(p);¦#endifÙ$      assert( PAGE_IS_UNPINNED(p) );¸      pcache1PinPage(p);Ù"      pcache1RemoveFromHash(p, 1);¥    }Ù$    pcache1LeaveMutex(&pcache1.grp);£  }¯  return nFree;¡}Ù,#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */ ²#ifdef SQLITE_TEST¢/*ÙI** This function is used by test procedures to inspect the internal state·** of the global cache.¢*/Ù'SQLITE_PRIVATE void sqlite3PcacheStats(Ù>  int *pnCurrent,      /* OUT: Total number of pages cached */Ù;  int *pnMax,          /* OUT: Global maximum cache size */ÙJ  int *pnMin,          /* OUT: Sum of PCache1.nMin for purgeable caches */ÙO  int *pnRecyclable    /* OUT: Total number of pages available for recycling */¢){¬  PgHdr1 *p;¶  int nRecyclable = 0;ÙD  for(p=pcache1.grp.lru.pLruNext; p && !p->isAnchor; p=p->pLruNext){Ù"    assert( PAGE_IS_UNPINNED(p) );²    nRecyclable++;£  }Ù&  *pnCurrent = pcache1.grp.nPurgeable;Ù%  *pnMax = (int)pcache1.grp.nMaxPage;Ù%  *pnMin = (int)pcache1.grp.nMinPage;¾  *pnRecyclable = nRecyclable;¡}¦#endif ÙO/************** End of pcache1.c *********************************************/ÙO/************** Begin file rowset.c ******************************************/¢/*²** 2008 December 3¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**Ù7** This module implements an object we call a "RowSet".¢**Ù7** The RowSet object is a collection of rowids.  RowidsÙ?** are inserted into the RowSet in an arbitrary order.  InsertsÙ@** can be intermixed with tests to see if a given rowid has beenÙ'** previously inserted into the RowSet.¢**Ù@** After all inserts are finished, it is possible to extract theÙ@** elements of the RowSet in sorted order.  Once this extractionÙ8** process has started, no new elements may be inserted.¢**Ù4** Hence, the primitive operations for a RowSet are:¢**¬**    CREATE¬**    INSERTª**    TEST®**    SMALLEST­**    DESTROY¢**ÙH** The CREATE and DESTROY primitives are the constructor and destructor,ÙE** obviously.  The INSERT primitive adds a new element to the RowSet.ÙG** TEST checks to see if an element is already in the RowSet.  SMALLESTÙ,** extracts the least value from the RowSet.¢**ÙD** The INSERT primitive might allocate additional memory.  Memory isÙF** allocated in chunks so most INSERTs do no allocation.  There is an ÙC** upper bound on the size of allocated memory.  No memory is freed±** until DESTROY.¢**ÙD** The TEST primitive includes a "batch" number.  The TEST primitiveÙC** will only see elements that were inserted before the last changeÙD** in the batch number.  In other words, if an INSERT occurs betweenÙA** two TESTs where the TESTs have the same batch nubmer, then theÙD** value added by the INSERT will not be visible to the second TEST.ÙG** The initial batch number is zero, so if the very first TEST containsÙ:** a non-zero batch number, it will see all prior INSERTs.¢**ÙE** No INSERTs may occurs after a SMALLEST.  An assertion will fail ifµ** that is attempted.¢**ÙD** The cost of an INSERT is roughly constant.  (Sometimes new memoryÙD** has to be allocated on an INSERT.)  The cost of a TEST with a newÙL** batch number is O(NlogN) where N is the number of elements in the RowSet.ÙG** The cost of a TEST using the same batch number is O(logN).  The costÙE** of the first SMALLEST is O(NlogN).  Second and subsequent SMALLESTÙ>** primitives are constant time.  The cost of DESTROY is O(N).¢**ÙF** TEST and SMALLEST may not be used by the same RowSet.  This used toÙH** be possible, but the feature was not used, so it was removed in order¸** to simplify the code.¢*/¼/* #include "sqliteInt.h" */  ¢/*Ù%** Target size for allocation chunks.¢*/Ù##define ROWSET_ALLOCATION_SIZE 1024 ¢/*Ù5** The number of rowset entries per allocation chunk.¢*/Ù!#define ROWSET_ENTRY_PER_CHUNK  \ÙN                       ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry)) ¢/*ÙA** Each entry in a RowSet is an instance of the following object.¢**ÙL** This same object is reused to store a linked list of trees of RowSetEntryÙE** objects.  In that alternative use, pRight points to the next entryÙ?** in the list, pLeft points to the tree, and v is unused.  TheÙ?** RowSet.pForest value points to the head of this forest list.¢*/Ù struct RowSetEntry {            Ù@  i64 v;                        /* ROWID value for this entry */ÙL  struct RowSetEntry *pRight;   /* Right subtree (larger entries) or list */ÙD  struct RowSetEntry *pLeft;    /* Left subtree (smaller entries) */¢}; ¢/*ÙF** RowSetEntry objects are allocated in large chunks (instances of theÙB** following structure) to reduce memory allocation overhead.  TheÙC** chunks are kept on a linked list so that they can be deallocatedÙ ** when the RowSet is destroyed.¢*/´struct RowSetChunk {ÙM  struct RowSetChunk *pNextChunk;        /* Next chunk on list of them all */ÙL  struct RowSetEntry aEntry[ROWSET_ENTRY_PER_CHUNK]; /* Allocated entries */¢}; ¢/*Ù6** A RowSet in an instance of the following structure.¢**Ù7** A typedef of this structure if found in sqliteInt.h.¢*/¯struct RowSet {ÙD  struct RowSetChunk *pChunk;    /* List of all chunk allocations */Ù>  sqlite3 *db;                   /* The database connection */ÙC  struct RowSetEntry *pEntry;    /* List of entries using pRight */ÙD  struct RowSetEntry *pLast;     /* Last entry on the pEntry list */ÙB  struct RowSetEntry *pFresh;    /* Source of new entry objects */ÙF  struct RowSetEntry *pForest;   /* List of binary trees of entries */ÙB  u16 nFresh;                    /* Number of objects on pFresh */Ù4  u16 rsFlags;                   /* Various flags */Ù;  int iBatch;                    /* Current insert batch */¢}; ¢/*Ù$** Allowed values for RowSet.rsFlags¢*/ÙC#define ROWSET_SORTED  0x01   /* True if RowSet.pEntry is sorted */ÙO#define ROWSET_NEXT    0x02   /* True if sqlite3RowSetNext() has been called */ ¢/*Ù<** Turn bulk memory into a RowSet object.  N bytes of memoryÙG** are available at pSpace.  The db pointer is used as a memory contextÙ5** for any subsequent allocations that need to occur.Ù-** Return a pointer to the new RowSet object.¢**ÙE** It must be the case that N is sufficient to make a Rowset.  If not½** an assertion fault occurs.£** ÙA** If N is larger than the minimum, use the surplus as an initialÙ0** allocation of entries available to be filled.¢*/ÙTSQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3 *db, void *pSpace, unsigned int N){¬  RowSet *p;Ù$  assert( N >= ROUND8(sizeof(*p)) );­  p = pSpace;°  p->pChunk = 0;­  p->db = db;°  p->pEntry = 0;¯  p->pLast = 0;±  p->pForest = 0;ÙC  p->pFresh = (struct RowSetEntry*)(ROUND8(sizeof(*p)) + (char*)p);ÙI  p->nFresh = (u16)((N - ROUND8(sizeof(*p)))/sizeof(struct RowSetEntry));½  p->rsFlags = ROWSET_SORTED;°  p->iBatch = 0;«  return p;¡} ¢/*ÙC** Deallocate all chunks from a RowSet.  This frees all memory thatÙ?** the RowSet has allocated over its lifetime.  This routine isÙ!** the destructor for the RowSet.¢*/Ù2SQLITE_PRIVATE void sqlite3RowSetClear(RowSet *p){Ù*  struct RowSetChunk *pChunk, *pNextChunk;Ù5  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){Ù$    pNextChunk = pChunk->pNextChunk;Ù!    sqlite3DbFree(p->db, pChunk);£  }°  p->pChunk = 0;°  p->nFresh = 0;°  p->pEntry = 0;¯  p->pLast = 0;±  p->pForest = 0;½  p->rsFlags = ROWSET_SORTED;¡} ¢/*Ù@** Allocate a new RowSetEntry object that is associated with theÙJ** given RowSet.  Return a pointer to the new and completely uninitialized¬** objected.¢**ÙH** In an OOM situation, the RowSet.db->mallocFailed flag is set and this¸** routine returns NULL.¢*/Ù7static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){±  assert( p!=0 );Ù0  if( p->nFresh==0 ){  /*OPTIMIZATION-IF-FALSE*/ÙL    /* We could allocate a fresh RowSetEntry each time one is needed, but itÙF    ** is more efficient to pull a preallocated entry from the pool */½    struct RowSetChunk *pNew;Ù6    pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));²    if( pNew==0 ){¯      return 0;¥    }Ù!    pNew->pNextChunk = p->pChunk;µ    p->pChunk = pNew;½    p->pFresh = pNew->aEntry;Ù'    p->nFresh = ROWSET_ENTRY_PER_CHUNK;£  }®  p->nFresh--;µ  return p->pFresh++;¡} ¢/*Ù$** Insert a new value into a RowSet.¢**Ù?** The mallocFailed flag of the database connection is set if a»** memory allocation fails.¢*/Ù>SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet *p, i64 rowid){Ù2  struct RowSetEntry *pEntry;  /* The new entry */Ù9  struct RowSetEntry *pLast;   /* The last prior entry */ Ù>  /* This routine is never called after sqlite3RowSetNext() */Ù2  assert( p!=0 && (p->rsFlags & ROWSET_NEXT)==0 ); ¿  pEntry = rowSetEntryAlloc(p);¹  if( pEntry==0 ) return;´  pEntry->v = rowid;µ  pEntry->pRight = 0;³  pLast = p->pLast;®  if( pLast ){Ù5    if( rowid<=pLast->v ){  /*OPTIMIZATION-IF-FALSE*/ÙF      /* Avoid unnecessary sorts by preserving the ROWSET_SORTED flagsº      ** where possible */Ù#      p->rsFlags &= ~ROWSET_SORTED;¥    }»    pLast->pRight = pEntry;¨  }else{·    p->pEntry = pEntry;£  }´  p->pLast = pEntry;¡} ¢/*Ù>** Merge two lists of RowSetEntry objects.  Remove duplicates.¢**Ù=** The input lists are connected via pRight pointers and are Ù.** assumed to each already be in sorted order.¢*/Ù,static struct RowSetEntry *rowSetEntryMerge(ÙA  struct RowSetEntry *pA,    /* First sorted list to be merged */ÙB  struct RowSetEntry *pB     /* Second sorted list to be merged */¢){º  struct RowSetEntry head;¼  struct RowSetEntry *pTail; °  pTail = &head;»  assert( pA!=0 && pB!=0 );ª  for(;;){Ù4    assert( pA->pRight==0 || pA->v<=pA->pRight->v );Ù4    assert( pB->pRight==0 || pB->v<=pB->pRight->v );·    if( pA->v<=pB->v ){Ù3      if( pA->v<pB->v ) pTail = pTail->pRight = pA;¶      pA = pA->pRight;²      if( pA==0 ){»        pTail->pRight = pB;®        break;§      }ª    }else{Ù!      pTail = pTail->pRight = pB;¶      pB = pB->pRight;²      if( pB==0 ){»        pTail->pRight = pA;®        break;§      }¥    }£  }µ  return head.pRight;¡} ¢/*ÙE** Sort all elements on the list of RowSetEntry objects into order of°** increasing v.£*/ ÙDstatic struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){±  unsigned int i;Ù*  struct RowSetEntry *pNext, *aBucket[40]; Ù&  memset(aBucket, 0, sizeof(aBucket));¯  while( pIn ){¸    pNext = pIn->pRight;´    pIn->pRight = 0;¾    for(i=0; aBucket[i]; i++){Ù.      pIn = rowSetEntryMerge(aBucket[i], pIn);µ      aBucket[i] = 0;¥    }µ    aBucket[i] = pIn;°    pIn = pNext;£  }³  pIn = aBucket[0];Ù6  for(i=1; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){Ù!    if( aBucket[i]==0 ) continue;Ù?    pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];£  }­  return pIn;¡}  ¢/*ÙH** The input, pIn, is a binary tree (or subtree) of RowSetEntry objects.ÙH** Convert this tree into a linked list connected by the pRight pointersÙF** and return pointers to the first and last elements of the new list.¢*/½static void rowSetTreeToList(Ù?  struct RowSetEntry *pIn,         /* Root of the input tree */ÙK  struct RowSetEntry **ppFirst,    /* Write head of the output list here */ÙK  struct RowSetEntry **ppLast      /* Write tail of the output list here */¢){³  assert( pIn!=0 );³  if( pIn->pLeft ){º    struct RowSetEntry *p;Ù.    rowSetTreeToList(pIn->pLeft, ppFirst, &p);´    p->pRight = pIn;¨  }else{³    *ppFirst = pIn;£  }´  if( pIn->pRight ){Ù8    rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);¨  }else{²    *ppLast = pIn;£  }Ù!  assert( (*ppLast)->pRight==0 );¡}  ¢/*ÙH** Convert a sorted list of elements (connected by pRight) into a binaryÙL** tree with depth of iDepth.  A depth of 1 means the tree contains a singleÙG** node taken from the head of *ppList.  A depth of 2 means a tree with¾** three nodes.  And so forth.¢**ÙE** Use as many entries from the input list as required and update theÙE** *ppList to point to the unused elements of the list.  If the inputÙD** list contains too few elements, then construct an incomplete treeÙ!** and leave *ppList set to NULL.¢**Ù?** Return a pointer to the root of the constructed binary tree.¢*/Ù+static struct RowSetEntry *rowSetNDeepTree(¾  struct RowSetEntry **ppList,¬  int iDepth¢){Ù;  struct RowSetEntry *p;         /* Root of the new tree */Ù3  struct RowSetEntry *pLeft;     /* Left subtree */Ù,  if( *ppList==0 ){ /*OPTIMIZATION-IF-TRUE*/ÙG    /* Prevent unnecessary deep recursion when we run out of entries */®    return 0; £  }Ù,  if( iDepth>1 ){   /*OPTIMIZATION-IF-TRUE*/ÙJ    /* This branch causes a *balanced* tree to be generated.  A valid treeÙE    ** is still generated without this branch, but the tree is wildlyÙ%    ** unbalanced and inefficient. */Ù.    pLeft = rowSetNDeepTree(ppList, iDepth-1);°    p = *ppList;Ù-    if( p==0 ){     /*OPTIMIZATION-IF-FALSE*/ÙA      /* It is safe to always return here, but the resulting tree¿      ** would be unbalanced */³      return pLeft;¥    }µ    p->pLeft = pLeft;¸    *ppList = p->pRight;Ù2    p->pRight = rowSetNDeepTree(ppList, iDepth-1);¨  }else{°    p = *ppList;¸    *ppList = p->pRight;½    p->pLeft = p->pRight = 0;£  }«  return p;¡} ¢/*ÙF** Convert a sorted list of elements into a binary tree. Make the treeÙA** as deep as it needs to be in order to contain the entire list.¢*/ÙGstatic struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){Ù6  int iDepth;           /* Depth of the tree so far */Ù6  struct RowSetEntry *p;       /* Current tree root */Ù1  struct RowSetEntry *pLeft;   /* Left subtree */ µ  assert( pList!=0 );¬  p = pList;´  pList = p->pRight;»  p->pLeft = p->pRight = 0;Ù!  for(iDepth=1; pList; iDepth++){®    pLeft = p;®    p = pList;¶    pList = p->pRight;µ    p->pLeft = pLeft;Ù0    p->pRight = rowSetNDeepTree(&pList, iDepth);£  }«  return p;¡} ¢/*Ù0** Extract the smallest element from the RowSet.Ù@** Write the element into *pRowid.  Return 1 on success.  ReturnÙ$** 0 if the RowSet is already empty.¢**Ù@** After this routine has been called, the sqlite3RowSetInsert()Ù#** routine may not be called again.¢**Ù?** This routine may not be called after sqlite3RowSetTest() hasÙ@** been used.  Older versions of RowSet allowed that, but as theÙ@** capability was not used by the code generator, it was removed´** for code economy.¢*/Ù=SQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid){±  assert( p!=0 );ÙI  assert( p->pForest==0 );  /* Cannot be used with sqlite3RowSetText() */ Ù@  /* Merge the forest into a single sorted list on first call */ÙA  if( (p->rsFlags & ROWSET_NEXT)==0 ){  /*OPTIMIZATION-IF-FALSE*/ÙE    if( (p->rsFlags & ROWSET_SORTED)==0 ){  /*OPTIMIZATION-IF-FALSE*/Ù-      p->pEntry = rowSetEntrySort(p->pEntry);¥    }Ù,    p->rsFlags |= ROWSET_SORTED|ROWSET_NEXT;£  } Ù)  /* Return the next entry on the list */²  if( p->pEntry ){»    *pRowid = p->pEntry->v;Ù"    p->pEntry = p->pEntry->pRight;Ù0    if( p->pEntry==0 ){ /*OPTIMIZATION-IF-TRUE*/ÙN      /* Free memory immediately, rather than waiting on sqlite3_finalize() */¼      sqlite3RowSetClear(p);¥    }­    return 1;¨  }else{­    return 0;£  }¡} ¢/*ÙA** Check to see if element iRowid was inserted into the rowset asÙ<** part of any insert batch prior to iBatch.  Return 1 or 0.¢**ÙF** If this is the first test of a new batch and if there exist entriesÙA** on pRowSet->pEntry, then sort those entries into the forest atÙ/** pRowSet->pForest so that they can be tested.¢*/ÙXSQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){Ù   struct RowSetEntry *p, *pTree; Ù>  /* This routine is never called after sqlite3RowSetNext() */Ù>  assert( pRowSet!=0 && (pRowSet->rsFlags & ROWSET_NEXT)==0 ); ÙC  /* Sort entries into the forest on the first test of a new batch.ÙJ  ** To save unnecessary work, only do this when the batch number changes.¤  */Ù;  if( iBatch!=pRowSet->iBatch ){  /*OPTIMIZATION-IF-FALSE*/¸    p = pRowSet->pEntry;¬    if( p ){Ù:      struct RowSetEntry **ppPrevTree = &pRowSet->pForest;ÙL      if( (pRowSet->rsFlags & ROWSET_SORTED)==0 ){ /*OPTIMIZATION-IF-FALSE*/ÙC        /* Only sort the current set of entiries if they need it */¿        p = rowSetEntrySort(p);§      }Ù@      for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){Ù$        ppPrevTree = &pTree->pRight;¾        if( pTree->pLeft==0 ){Ù-          pTree->pLeft = rowSetListToTree(p);°          break;®        }else{Ù+          struct RowSetEntry *pAux, *pTail;Ù8          rowSetTreeToList(pTree->pLeft, &pAux, &pTail);»          pTree->pLeft = 0;Ù(          p = rowSetEntryMerge(pAux, p);©        }§      }µ      if( pTree==0 ){Ù8        *ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);´        if( pTree ){·          pTree->v = 0;¼          pTree->pRight = 0;Ù-          pTree->pLeft = rowSetListToTree(p);©        }§      }º      pRowSet->pEntry = 0;¹      pRowSet->pLast = 0;Ù(      pRowSet->rsFlags |= ROWSET_SORTED;¥    }½    pRowSet->iBatch = iBatch;£  } ÙD  /* Test to see if the iRowid value appears anywhere in the forest.Ù&  ** Return 1 if it does and 0 if not.¤  */Ù<  for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){µ    p = pTree->pLeft;¯    while( p ){¸      if( p->v<iRowid ){¶        p = p->pRight;¾      }else if( p->v>iRowid ){µ        p = p->pLeft;¬      }else{±        return 1;§      }¥    }£  }«  return 0;¡} ÙO/************** End of rowset.c **********************************************/ÙO/************** Begin file pager.c *******************************************/¢/*´** 2001 September 15¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙE** This is the implementation of the page cache subsystem or "pager".£** ÙC** The pager is used to access a database disk file.  It implementsÙD** atomic commit and rollback through the use of a journal file thatÙF** is separate from the database file.  The pager also implements fileÙB** locking to prevent two processes from writing the same databaseÙF** file simultaneously, or one process from reading the database while¶** another is writing.¢*/º#ifndef SQLITE_OMIT_DISKIO¼/* #include "sqliteInt.h" */ÙO/************** Include wal.h in the middle of pager.c ***********************/ÙO/************** Begin file wal.h *********************************************/¢/*²** 2010 February 1¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************ÙE** This header file defines the interface to the write-ahead logging ÙJ** system. Refer to the comments below and the header comment attached to ÙD** the implementation of each function in log.c for further details.¢*/ ´#ifndef SQLITE_WAL_H´#define SQLITE_WAL_H ¼/* #include "sqliteInt.h" */ ÙF/* Macros for extracting appropriate sync flags for either transactionÙJ** commits (WAL_SYNC_FLAGS(X)) or for checkpoint ops (CKPT_SYNC_FLAGS(X)):¢*/Ù&#define WAL_SYNC_FLAGS(X)   ((X)&0x03)Ù+#define CKPT_SYNC_FLAGS(X)  (((X)>>2)&0x03) ¶#ifdef SQLITE_OMIT_WALÙ2# define sqlite3WalOpen(x,y,z)                   0½# define sqlite3WalLimit(x,y)Ù2# define sqlite3WalClose(v,w,x,y,z)              0Ù2# define sqlite3WalBeginReadTransaction(y,z)     0Ù(# define sqlite3WalEndReadTransaction(z)Ù2# define sqlite3WalDbsize(y)                     0Ù2# define sqlite3WalBeginWriteTransaction(y)      0Ù2# define sqlite3WalEndWriteTransaction(x)        0Ù2# define sqlite3WalUndo(x,y,z)                   0Ù!# define sqlite3WalSavepoint(y,z)Ù2# define sqlite3WalSavepointUndo(y,z)            0Ù2# define sqlite3WalFrames(u,v,w,x,y,z)           0Ù4# define sqlite3WalCheckpoint(q,r,s,t,u,v,w,x,y,z) 0Ù2# define sqlite3WalCallback(z)                   0Ù2# define sqlite3WalExclusiveMode(y,z)            0Ù2# define sqlite3WalHeapMemory(z)                 0Ù2# define sqlite3WalFramesize(z)                  0Ù2# define sqlite3WalFindFrame(x,y,z)              0Ù2# define sqlite3WalFile(x)                       0¥#else ½#define WAL_SAVEPOINT_NDATA 4 Ù//* Connection to a write-ahead log (WAL) file. Ù4** There is one object of this type for each pager. ¢*/·typedef struct Wal Wal; Ù7/* Open and close a connection to a write-ahead log. */Ù^SQLITE_PRIVATE int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *, int, i64, Wal**);ÙSSQLITE_PRIVATE int sqlite3WalClose(Wal *pWal, sqlite3*, int sync_flags, int, u8 *); Ù*/* Set the limiting size of a WAL file. */Ù/SQLITE_PRIVATE void sqlite3WalLimit(Wal*, i64); ÙD/* Used by readers to open (lock) and close (unlock) a snapshot.  A ÙH** snapshot is like a read-transaction.  It is the state of the databaseÙF** at an instant in time.  sqlite3WalOpenSnapshot gets a read lock andÙE** preserves the current state even if the other threads or processesÙH** write to or checkpoint the WAL.  sqlite3WalCloseSnapshot() closes theÙ%** transaction and releases the lock.¢*/ÙDSQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *);Ù<SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal); Ù=/* Read a page from the write-ahead log, if it is present. */Ù;SQLITE_PRIVATE int sqlite3WalFindFrame(Wal *, Pgno, u32 *);Ù>SQLITE_PRIVATE int sqlite3WalReadFrame(Wal *, u32, int, u8 *); Ù?/* If the WAL is not empty, return the size of the database. */Ù0SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal); Ù(/* Obtain or release the WRITER lock. */Ù>SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal);Ù<SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal); Ù</* Undo any frames written (but not committed) to the log */ÙYSQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx); ÙA/* Return an integer that records the current (uncommitted) write¹** position in the WAL */ÙBSQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData); Ù@/* Move the write position of the WAL back to iFrame.  Called inÙ(** response to a ROLLBACK TO command. */ÙESQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData); Ù)/* Write a frame or frames to the log. */ÙMSQLITE_PRIVATE int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int); Ù3/* Copy pages from the log to the database file */ Ù(SQLITE_PRIVATE int sqlite3WalCheckpoint(ÙB  Wal *pWal,                      /* Write-ahead log connection */ÙJ  sqlite3 *db,                    /* Check this handle's interrupt flag */ÙH  int eMode,                      /* One of PASSIVE, FULL and RESTART */ÙB  int (*xBusy)(void*),            /* Function to call when busy */ÙI  void *pBusyArg,                 /* Context argument for xBusyHandler */ÙI  int sync_flags,                 /* Flags to sync db file with (or 0) */Ù;  int nBuf,                       /* Size of buffer nBuf */Ù?  u8 *zBuf,                       /* Temporary buffer to use */ÙD  int *pnLog,                     /* OUT: Number of frames in WAL */ÙO  int *pnCkpt                     /* OUT: Number of backfilled frames in WAL */¢); Ù?/* Return the value to pass to a sqlite3_wal_hook callback, theÙD** number of frames in the WAL at the point of the last commit sinceÙF** sqlite3WalCallback() was called.  If no commits have occurred sinceÙ ** the last call, then return 0.¢*/Ù1SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal); ÙL/* Tell the wal layer that an EXCLUSIVE lock has been obtained (or released)Ù+** by the pager layer on the database file.¢*/Ù>SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op); ÙF/* Return true if the argument is non-NULL and the WAL module is usingÙK** heap-memory for the wal-index. Otherwise, if the argument is NULL or theÙ4** WAL module is using shared-memory, return false. ¢*/Ù3SQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal); ½#ifdef SQLITE_ENABLE_SNAPSHOTÙSSQLITE_PRIVATE int sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot);ÙSSQLITE_PRIVATE void sqlite3WalSnapshotOpen(Wal *pWal, sqlite3_snapshot *pSnapshot);Ù8SQLITE_PRIVATE int sqlite3WalSnapshotRecover(Wal *pWal);¦#endif »#ifdef SQLITE_ENABLE_ZIPVFSÙF/* If the WAL file is not empty, return the number of bytes of contentÙI** stored in each frame (i.e. the db page-size when the WAL was created).¢*/Ù2SQLITE_PRIVATE int sqlite3WalFramesize(Wal *pWal);¦#endif Ù5/* Return the sqlite3_file object for the WAL file */Ù7SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal); Ù##endif /* ifndef SQLITE_OMIT_WAL */¹#endif /* SQLITE_WAL_H */ ÙO/************** End of wal.h *************************************************/ÙO/************** Continuing where we left off in pager.c **********************/  ÙN/******************* NOTES ON THE DESIGN OF THE PAGER ************************¢**ÙJ** This comment block describes invariants that hold when using a rollbackÙ@** journal.  These invariants do not apply for journal_mode=WAL,Ù,** journal_mode=MEMORY, or journal_mode=OFF.¢**ÙB** Within this comment block, a page is deemed to have been syncedÙF** automatically as soon as it is written when PRAGMA synchronous=OFF.ÙF** Otherwise, the page is not synced until the xSync method of the VFSÙ:** is called successfully on the file containing the page.¢**ÙL** Definition:  A page of the database file is said to be "overwriteable" ifÙ8** one or more of the following are true about the page:£** ÙJ**     (a)  The original content of the page as it was at the beginning ofÙJ**          the transaction has been written into the rollback journal and³**          synced.£** ÙN**     (b)  The page was a freelist leaf page at the start of the transaction.£** ÙL**     (c)  The page number is greater than the largest page that existed inÙ>**          the database file at the start of the transaction.£** ÙI** (1) A page of the database file is never overwritten unless one of theº**     following are true:£** ÙM**     (a) The page and all other pages on the same sector are overwriteable.£** ÙH**     (b) The atomic page write optimization is enabled, and the entireÙH**         transaction other than the update of the transaction sequenceÙ3**         number consists of a single page change.£** ÙN** (2) The content of a page written into the rollback journal exactly matchesÙM**     both the content in the database when the rollback journal was writtenÙF**     and the content in the database at the beginning of the current³**     transaction.£** ÙK** (3) Writes to the database file are an integer multiple of the page sizeÙ4**     in length and are aligned on a page boundary.£** ÙM** (4) Reads from the database file are either aligned on a page boundary andÙK**     an integer multiple of the page size in length or are taken from theÙ,**     first 100 bytes of the database file.£** ÙO** (5) All writes to the database file are synced prior to the rollback journalÙ+**     being deleted, truncated, or zeroed.£** ÙM** (6) If a master journal file is used, then all writes to the database fileÙ<**     are synced prior to the master journal being deleted.£** ÙI** Definition: Two databases (or the same database at two points it time)ÙH** are said to be "logically equivalent" if they give the same answer toÙ@** all queries.  Note in particular the content of freelist leafÙM** pages can be changed arbitrarily without affecting the logical equivalence³** of the database.£** ÙM** (7) At any time, if any subset, including the empty set and the total set,ÙI**     of the unsynced changes to a rollback journal are removed and the ÙL**     journal is rolled back, the resulting database file will be logicallyÙK**     equivalent to the database file at the beginning of the transaction.£** ÙI** (8) When a transaction is rolled back, the xTruncate method of the VFSÙH**     is called to restore the database file to the same size it was atÙG**     the beginning of the transaction.  (In some VFSes, the xTruncateÙK**     method is a no-op, but that does not change the fact the SQLite will²**     invoke it.)£** ÙL** (9) Whenever the database file is modified, at least one bit in the rangeÙO**     of bytes from 24 through 39 inclusive will be changed prior to releasingÙG**     the EXCLUSIVE lock, thus signaling other connections on the sameÙ&**     database to flush their caches.¢**ÙK** (10) The pattern of bits in bytes 24 through 39 shall not repeat in lessÙ&**      than one billion transactions.¢**ÙM** (11) A database file is well-formed at the beginning and at the conclusion½**      of every transaction.¢**ÙF** (12) An EXCLUSIVE lock is held on the database file when writing toº**      the database file.¢**ÙD** (13) A SHARED lock is held on the database file while reading anyÙ)**      content out of the database file.¢**ÙO******************************************************************************/ ¢/*Ù3** Macros for troubleshooting.  Normally turned off¢*/¥#if 0Ù6int sqlite3PagerTrace=1;  /* True to enable tracing */Ù!#define sqlite3DebugPrintf printfÙJ#define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }¥#elseµ#define PAGERTRACE(X)¦#endif ¢/*ÙI** The following two macros are used within the PAGERTRACE() macros aboveÙ"** to print out file-descriptors. ¢**ÙC** PAGERID() takes a pointer to a Pager struct as its argument. TheÙO** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_fileº** struct as its argument.¢*/Ù-#define PAGERID(p) (SQLITE_PTR_TO_INT(p->fd))Ù0#define FILEHANDLEID(fd) (SQLITE_PTR_TO_INT(fd)) ¢/*ÙE** The Pager.eState variable stores the current 'state' of a pager. AÙE** pager may be in any one of the seven states shown in the following±** state diagram.¢**Ù2**                            OPEN <------+------+Ù2**                              |         |      |Ù2**                              V         |      |Ù2**               +---------> READER-------+      |Ù2**               |              |                |Ù2**               |              V                |Ù4**               |<-------WRITER_LOCKED------> ERRORÙ4**               |              |                ^  Ù2**               |              V                |Ù2**               |<------WRITER_CACHEMOD-------->|Ù2**               |              |                |Ù2**               |              V                |Ù2**               |<-------WRITER_DBMOD---------->|Ù2**               |              |                |Ù2**               |              V                |Ù2**               +<------WRITER_FINISHED-------->+¢**¢**ÙE** List of state transitions and the C [function] that performs each:£** ÙF**   OPEN              -> READER              [sqlite3PagerSharedLock]Ù<**   READER            -> OPEN                [pager_unlock]¢**ÙA**   READER            -> WRITER_LOCKED       [sqlite3PagerBegin]ÙB**   WRITER_LOCKED     -> WRITER_CACHEMOD     [pager_open_journal]Ù;**   WRITER_CACHEMOD   -> WRITER_DBMOD        [syncJournal]ÙJ**   WRITER_DBMOD      -> WRITER_FINISHED     [sqlite3PagerCommitPhaseOne]ÙE**   WRITER_***        -> READER              [pager_end_transaction]¢**Ù;**   WRITER_***        -> ERROR               [pager_error]Ù<**   ERROR             -> OPEN                [pager_unlock]£** ¢**©**  OPEN:¢**ÙF**    The pager starts up in this state. Nothing is guaranteed in thisÙH**    state - the file may or may not be locked and the database size isÙ7**    unknown. The database may not be read or written.¢**Ù/**    * No read or write transaction is active.ÙF**    * Any lock, or no lock at all, may be held on the database file.ÙK**    * The dbSize, dbOrigSize and dbFileSize variables may not be trusted.¢**«**  READER:¢**ÙE**    In this state all the requirements for reading the database in ÙG**    rollback (non-WAL) mode are met. Unless the pager is (or recentlyÙG**    was) in exclusive-locking mode, a user-level read transaction is Ù5**    open. The database size is known in this state.¢**ÙJ**    A connection running with locking_mode=normal enters this state whenÙF**    it opens a read-transaction on the database and returns to stateÙH**    OPEN after the read-transaction is completed. However a connectionÙM**    running in locking_mode=exclusive (including temp databases) remains inÙH**    this state even after the read-transaction is closed. The only wayÙL**    a locking_mode=exclusive connection can transition from READER to OPENÙ)**    is via the ERROR state (see below).£** ÙJ**    * A read transaction may be active (but a write-transaction cannot).Ù>**    * A SHARED or greater lock is held on the database file.ÙF**    * The dbSize variable may be trusted (even if a user-level read ÙK**      transaction is not active). The dbOrigSize and dbFileSize variablesÙ)**      may not be trusted at this point.ÙK**    * If the database is a WAL database, then the WAL connection is open.ÙF**    * Even if a read-transaction is not open, it is guaranteed that Ù3**      there is no hot-journal in the file-system.¢**²**  WRITER_LOCKED:¢**ÙH**    The pager moves to this state from READER when a write-transactionÙI**    is first opened on the database. In WRITER_LOCKED state, all locks ÙD**    required to start a write-transaction are held, but no actual Ù>**    modifications to the cache or database have taken place.¢**ÙJ**    In rollback mode, a RESERVED or (if the transaction was opened with ÙK**    BEGIN EXCLUSIVE) EXCLUSIVE lock is obtained on the database file whenÙM**    moving to this state, but the journal file is not written to or opened ÙM**    to in this state. If the transaction is committed or rolled back while ÙM**    in WRITER_LOCKED state, all that is required is to unlock the database «**    file.¢**ÙM**    IN WAL mode, WalBeginWriteTransaction() is called to lock the log file.ÙJ**    If the connection is running with locking_mode=exclusive, an attemptÙ?**    is made to obtain an EXCLUSIVE lock on the database file.¢**Ù&**    * A write transaction is active.ÙJ**    * If the connection is open in rollback-mode, a RESERVED or greater Ù***      lock is held on the database file.ÙF**    * If the connection is open in WAL-mode, a WAL write transactionÙM**      is open (i.e. sqlite3WalBeginWriteTransaction() has been successfully°**      called).ÙF**    * The dbSize, dbOrigSize and dbFileSize variables are all valid.Ù?**    * The contents of the pager cache have not been modified.Ù0**    * The journal file may or may not be open.ÙL**    * Nothing (not even the first header) has been written to the journal.¢**´**  WRITER_CACHEMOD:¢**ÙI**    A pager moves from WRITER_LOCKED state to this state when a page isÙJ**    first modified by the upper layer. In rollback mode the journal fileÙG**    is opened (if it is not already open) and a header written to theÙC**    start of it. The database file on disk has not been modified.¢**Ù&**    * A write transaction is active.Ù@**    * A RESERVED or greater lock is held on the database file.ÙG**    * The journal file is open and the first header has been written Ù:**      to it, but the header has not been synced to disk.Ù:**    * The contents of the page cache have been modified.¢**±**  WRITER_DBMOD:¢**ÙH**    The pager transitions from WRITER_CACHEMOD into WRITER_DBMOD stateÙI**    when it modifies the contents of the database file. WAL connectionsÙI**    never enter this state (since they do not modify the database file,¹**    just the log file).¢**Ù&**    * A write transaction is active.ÙB**    * An EXCLUSIVE or greater lock is held on the database file.ÙG**    * The journal file is open and the first header has been written »**      and synced to disk.ÙG**    * The contents of the page cache have been modified (and possibly¹**      written to disk).¢**´**  WRITER_FINISHED:¢**ÙB**    It is not possible for a WAL connection to enter this state.¢**ÙN**    A rollback-mode pager changes to WRITER_FINISHED state from WRITER_DBMODÙO**    state after the entire transaction has been successfully written into theÙJ**    database file. In this state the transaction may be committed simplyÙK**    by finalizing the journal file. Once in WRITER_FINISHED state, it is ÙL**    not possible to modify the database further. At this point, the upper Ù;**    layer must either commit or rollback the transaction.¢**Ù&**    * A write transaction is active.ÙB**    * An EXCLUSIVE or greater lock is held on the database file.ÙJ**    * All writing and syncing of journal and database data has finished.ÙL**      If no error occurred, all that remains is to finalize the journal toÙK**      commit the transaction. If an error did occur, the caller will needÙ%**      to rollback the transaction. ¢**ª**  ERROR:¢**ÙI**    The ERROR state is entered when an IO or disk-full error (includingÙF**    SQLITE_IOERR_NOMEM) occurs at a point in the code that makes it ÙK**    difficult to be sure that the in-memory pager state (cache contents, ÙH**    db size etc.) are consistent with the contents of the file-system.¢**ÙK**    Temporary pager files may enter the ERROR state, but in-memory pagers­**    cannot.¢**ÙF**    For example, if an IO error occurs while performing a rollback, ÙJ**    the contents of the page-cache may be left in an inconsistent state.ÙH**    At this point it would be dangerous to change back to READER stateÙI**    (as usually happens after a rollback). Any subsequent readers mightÙH**    report database corruption (due to the inconsistent cache), and ifÙJ**    they upgrade to writers, they may inadvertently corrupt the databaseÙI**    file. To avoid this hazard, the pager switches into the ERROR stateÙ0**    instead of READER following such an error.¢**ÙG**    Once it has entered the ERROR state, any attempt to use the pagerÙC**    to read or write data returns an error. Eventually, once all ÙH**    outstanding transactions have been abandoned, the pager is able toÙD**    transition back to OPEN state, discarding the contents of the ÙK**    page-cache and any other in-memory state at the same time. EverythingÙN**    is reloaded from disk (and, if necessary, hot-journal rollback peformed)ÙH**    when a read-transaction is next opened on the pager (transitioningÙK**    the pager into READER state). At that point the system has recovered µ**    from the error.¢**Ù<**    Specifically, the pager jumps into the ERROR state if:¢**ÙG**      1. An error occurs while attempting a rollback. This happens inÙ+**         function sqlite3PagerRollback().¢**ÙF**      2. An error occurs while attempting to finalize a journal fileÙG**         following a commit in function sqlite3PagerCommitPhaseTwo().¢**ÙF**      3. An error occurs while attempting to write to the journal orÙF**         database file in function pagerStress() in order to free up²**         memory.¢**ÙK**    In other cases, the error is returned to the b-tree layer. The b-treeÙG**    layer then attempts a rollback operation. If the error condition ÙI**    persists, the pager enters the ERROR state via condition (1) above.¢**ÙK**    Condition (3) is necessary because it can be triggered by a read-onlyÙI**    statement executed within a transaction. In this case, if the errorÙG**    code were simply returned to the user, the b-tree layer would notÙH**    automatically attempt a rollback, as it assumes that an error in aÙO**    read-only statement cannot leave the pager in an internally inconsistent ¬**    state.¢**ÙL**    * The Pager.errCode variable is set to something other than SQLITE_OK.ÙH**    * There are one or more outstanding references to pages (after theÙL**      last reference is dropped the pager should move back to OPEN state).Ù,**    * The pager is not an in-memory pager.¦**    ¢**©** Notes:¢**ÙG**   * A pager is never in WRITER_DBMOD or WRITER_FINISHED state if theÙH**     connection is open in WAL mode. A WAL connection is always in oneÙ **     of the first four states.¢**ÙK**   * Normally, a connection open in exclusive mode is never in PAGER_OPENÙL**     state. There are two exceptions: immediately after exclusive-mode hasÙE**     been turned on (and before any read or write transactions are ÙB**     executed), and when the pager is leaving the "error state".¢**Ù&**   * See also: assert_pager_state().¢*/Ù%#define PAGER_OPEN                  0Ù%#define PAGER_READER                1Ù%#define PAGER_WRITER_LOCKED         2Ù%#define PAGER_WRITER_CACHEMOD       3Ù%#define PAGER_WRITER_DBMOD          4Ù%#define PAGER_WRITER_FINISHED       5Ù%#define PAGER_ERROR                 6 ¢/*Ù?** The Pager.eLock variable is almost always set to one of the ÙD** following locking-states, according to the lock currently held onÙL** the database file: NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.ÙF** This variable is kept up to date as locks are taken and released byÙ2** the pagerLockDb() and pagerUnlockDb() wrappers.¢**ÙJ** If the VFS xLock() or xUnlock() returns an error other than SQLITE_BUSYÙJ** (i.e. one of the SQLITE_IOERR subtypes), it is not clear whether or notÙI** the operation was successful. In these circumstances pagerLockDb() andÙI** pagerUnlockDb() take a conservative approach - eLock is always updatedÙI** when unlocking the file, and only updated when locking the file if theÙH** VFS call is successful. This way, the Pager.eLock variable may be setÙH** to a less exclusive (lower) value than the lock that is actually heldÙF** at the system level, but it is never set to a more exclusive value.¢**ÙK** This is usually safe. If an xUnlock fails or appears to fail, there may ÙI** be a few redundant xLock() calls or a lock may be held for longer thanÙ+** required, but nothing really goes wrong.¢**ÙI** The exception is when the database file is unlocked as the pager movesÙK** from ERROR to OPEN state. At this point there may be a hot-journal file ÙN** in the file-system that needs to be rolled back (as part of an OPEN->SHAREDÙH** transition, by the same pager or any other). If the call to xUnlock()ÙL** fails at this point and the pager is left holding an EXCLUSIVE lock, thisÙG** can confuse the call to xCheckReservedLock() call made later as part¼** of hot-journal detection.¢**ÙM** xCheckReservedLock() is defined as returning true "if there is a RESERVED ÙG** lock held by this process or any others". So xCheckReservedLock may ÙJ** return true because the caller itself is holding an EXCLUSIVE lock (butÙK** doesn't know it because of a previous error in xUnlock). If this happensÙI** a hot-journal may be mistaken for a journal being created by an activeÙK** transaction in another process, causing SQLite to read from the database»** without rolling it back.¢**ÙG** To work around this, if a call to xUnlock() fails when unlocking theÙF** database in the ERROR state, Pager.eLock is set to UNKNOWN_LOCK. ItÙG** is only changed back to a real locking state after a successful callÙN** to xLock(EXCLUSIVE). Also, the code to do the OPEN->SHARED state transitionÙK** omits the check for a hot-journal if Pager.eLock is set to UNKNOWN_LOCK ÙJ** lock. Instead, it assumes a hot-journal exists and obtains an EXCLUSIVEÙL** lock on the database file before attempting to roll it back. See functionÙ%** PagerSharedLock() for more detail.¢**ÙD** Pager.eLock may only be set to UNKNOWN_LOCK when the pager is in ´** PAGER_OPEN state.¢*/Ù6#define UNKNOWN_LOCK                (EXCLUSIVE_LOCK+1) ¢/*Ù6** A macro used for invoking the codec if there is one¢*/·#ifdef SQLITE_HAS_CODEC¼# define CODEC1(P,D,N,X,E) \Ù:    if( P->xCodec && P->xCodec(P->pCodec,D,N,X)==0 ){ E; }¾# define CODEC2(P,D,N,X,E,O) \Ù+    if( P->xCodec==0 ){ O=(char*)D; }else \Ù:    if( (O=(char*)(P->xCodec(P->pCodec,D,N,X)))==0 ){ E; }¥#elseÙ(# define CODEC1(P,D,N,X,E)   /* NO-OP */Ù'# define CODEC2(P,D,N,X,E,O) O=(char*)D¦#endif ¢/*ÙG** The maximum allowed sector size. 64KiB. If the xSectorsize() method ÙJ** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.ÙG** This could conceivably cause corruption following a power failure onÙ:** such a system. This is currently an undocumented limit.¢*/¿#define MAX_SECTOR_SIZE 0x10000  ¢/*ÙF** An instance of the following structure is allocated for each activeÙI** savepoint and statement transaction in the system. All such structuresÙE** are stored in the Pager.aSavepoint[] array, which is allocated andÙ"** resized using sqlite3Realloc().¢**ÙF** When a savepoint is created, the PagerSavepoint.iHdrOffset field isÙG** set to 0. If a journal-header is written into the main journal whileÙF** the savepoint is active, then iHdrOffset is set to the byte offset ÙF** immediately following the last journal record written into the mainÙG** journal before the journal-header. This is required during savepointÙ+** rollback (see pagerPlaybackSavepoint()).¢*/Ù-typedef struct PagerSavepoint PagerSavepoint;·struct PagerSavepoint {ÙD  i64 iOffset;                 /* Starting offset in main journal */Ù.  i64 iHdrOffset;              /* See above */ÙC  Bitvec *pInSavepoint;        /* Set of pages in this savepoint */ÙE  Pgno nOrig;                  /* Original number of pages in file */ÙI  Pgno iSubRec;                /* Index of first record in sub-journal */·#ifndef SQLITE_OMIT_WALÙG  u32 aWalData[WAL_SAVEPOINT_NDATA];        /* WAL savepoint context */¦#endif¢}; ¢/*ÙE** Bits of the Pager.doNotSpill flag.  See further description below.¢*/ÙK#define SPILLFLAG_OFF         0x01 /* Never spill cache.  Set via pragma */ÙN#define SPILLFLAG_ROLLBACK    0x02 /* Current rolling back, so do not spill */ÙE#define SPILLFLAG_NOSYNC      0x04 /* Spill is ok, but do not sync */ ¢/*ÙF** An open page cache is an instance of struct Pager. A description ofÙ7** some of the more important member variables follows:¢**©** eState¢**ÙG**   The current 'state' of the pager object. See the comment and stateÙ8**   diagram above for a description of the pager state.¢**¨** eLock¢**ÙN**   For a real on-disk database, the current lock held on the database file -Ù;**   NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.¢**ÙH**   For a temporary or in-memory database (neither of which require anyÙF**   locks), this variable is always set to EXCLUSIVE_LOCK. Since suchÙH**   databases always have Pager.exclusiveMode==1, this tricks the pagerÙG**   logic into thinking that it already has all the locks it will everÙ***   need (and no reason to release them).¢**ÙF**   In some (obscure) circumstances, this variable may also be set toÙH**   UNKNOWN_LOCK. See the comment above the #define of UNKNOWN_LOCK for­**   details.¢**²** changeCountDone¢**ÙH**   This boolean variable is used to make sure that the change-counter ÙI**   (the 4-byte header field at byte offset 24 of the database file) is Ù,**   not updated more often than necessary. ¢**ÙG**   It is set to true when the change-counter field is updated, which ÙG**   can only happen if an exclusive lock is held on the database file.Ù@**   It is cleared (set to false) whenever an exclusive lock is ÙM**   relinquished on the database file. Each time a transaction is committed,ÙF**   The changeCountDone flag is inspected. If it is true, the work ofÙH**   updating the change-counter is omitted for the current transaction.¢**ÙL**   This mechanism means that when running in exclusive mode, a connection ÙH**   need only update the change-counter once, for the first transaction¯**   committed.¢**¬** setMaster¢**ÙI**   When PagerCommitPhaseOne() is called to commit a transaction, it mayÙG**   (or may not) specify a master-journal name to be written into the Ù.**   journal file before it is synced to disk.¢**ÙM**   Whether or not a journal file contains a master-journal pointer affects ÙM**   the way in which the journal file is finalized after the transaction is ÙJ**   committed or rolled back when running in "journal_mode=PERSIST" mode.ÙG**   If a journal file does not contain a master-journal pointer, it isÙF**   finalized by overwriting the first journal header with zeroes. IfÙL**   it does contain a master-journal pointer the journal file is finalized ÙD**   by truncating it to zero bytes, just as if the connection were Ù-**   running in "journal_mode=truncate" mode.¢**ÙK**   Journal files that contain master journal pointers cannot be finalizedÙG**   simply by overwriting the first journal-header with zeroes, as theÙL**   master journal pointer could interfere with hot-journal rollback of anyÙG**   subsequently interrupted transaction that reuses the journal file.¢**ÙI**   The flag is cleared as soon as the journal file is finalized (eitherÙJ**   by PagerCommitPhaseTwo or PagerRollback). If an IO error prevents theÙG**   journal file from being successfully finalized, the setMaster flagÙ@**   is cleared anyway (and the pager will move to ERROR state).¢**­** doNotSpill¢**ÙH**   This variables control the behavior of cache-spills  (calls made byÙH**   the pcache module to the pagerStress() routine to write cached dataÙ4**   to the file-system in order to free up memory).¢**ÙI**   When bits SPILLFLAG_OFF or SPILLFLAG_ROLLBACK of doNotSpill are set,ÙG**   writing to the database from pagerStress() is disabled altogether.ÙD**   The SPILLFLAG_ROLLBACK case is done in a very obscure case thatÙG**   comes up during savepoint rollback that requires the pcache moduleÙJ**   to allocate a new page to prevent the journal file from being writtenÙP**   while it is being traversed by code in pager_playback().  The SPILLFLAG_OFF¿**   case is a user preference.£** ÙE**   If the SPILLFLAG_NOSYNC bit is set, writing to the database fromÙE**   pagerStress() is permitted, but syncing the journal file is not.ÙM**   This flag is set by sqlite3PagerWrite() when the file-system sector-sizeÙM**   is larger than the database page-size in order to prevent a journal syncÙP**   from happening in between the journalling of two pages on the same sector. ¢**¯** subjInMemory¢**ÙG**   This is a boolean variable. If true, then any required sub-journalÙE**   is opened as an in-memory journal file. If false, then in-memoryÙ:**   sub-journals are only used for in-memory pager files.¢**ÙA**   This variable is updated by the upper layer each time a new Ù!**   write-transaction is opened.¢**Ù!** dbSize, dbOrigSize, dbFileSize¢**ÙH**   Variable dbSize is set to the number of pages in the database file.ÙI**   It is valid in PAGER_READER and higher states (all states except for¶**   OPEN and ERROR). ¢**ÙH**   dbSize is set based on the size of the database file, which may be ÙE**   larger than the size of the database (the value stored at offsetÙE**   28 of the database header by the btree). If the size of the fileÙE**   is not an integer multiple of the page-size, the value stored inÙN**   dbSize is rounded down (i.e. a 5KB file with 2K page-size has dbSize==2).ÙH**   Except, any file that is greater than 0 bytes in size is consideredÙH**   to have at least one page. (i.e. a 1KB file with 2K page-size leads³**   to dbSize==1).¢**ÙH**   During a write-transaction, if pages with page-numbers greater thanÙE**   dbSize are modified in the cache, dbSize is updated accordingly.ÙI**   Similarly, if the database is truncated using PagerTruncateImage(), ·**   dbSize is updated.¢**Ù=**   Variables dbOrigSize and dbFileSize are valid in states ÙG**   PAGER_WRITER_LOCKED and higher. dbOrigSize is a copy of the dbSizeÙJ**   variable at the start of the transaction. It is used during rollback,ÙG**   and to determine whether or not pages need to be journalled before´**   being modified.¢**ÙD**   Throughout a write-transaction, dbFileSize contains the size ofÙF**   the file on disk in pages. It is set to a copy of dbSize when theÙK**   write-transaction is first opened, and updated when VFS calls are madeÙ5**   to write or truncate the database file on disk. ¢**ÙH**   The only reason the dbFileSize variable is required is to suppress ÙJ**   unnecessary calls to xTruncate() after committing a transaction. If, ÙH**   when a transaction is committed, the dbFileSize variable indicates ÙN**   that the database file is larger than the database image (Pager.dbSize), ÙK**   pager_truncate() is called. The pager_truncate() call uses xFilesize()ÙM**   to measure the database file on disk, and then truncates it if required.ÙI**   dbFileSize is not used when rolling back a transaction. In this caseÙI**   pager_truncate() is called unconditionally (which means there may beÙJ**   a call to xFilesize() that is not strictly required). In either case,ÙE**   pager_truncate() may cause the file to become smaller or larger.¢**­** dbHintSize¢**ÙI**   The dbHintSize variable is used to limit the number of calls made toÙ3**   the VFS xFileControl(FCNTL_SIZE_HINT) method. ¢**Ù>**   dbHintSize is set to a copy of the dbSize variable when aÙD**   write-transaction is opened (at the same time as dbFileSize andÙH**   dbOrigSize). If the xFileControl(FCNTL_SIZE_HINT) method is called,ÙJ**   dbHintSize is increased to the number of pages that correspond to theÙI**   size-hint passed to the method call. See pager_write_pagelist() for ­**   details.¢**ª** errCode¢**ÙJ**   The Pager.errCode variable is only ever used in PAGER_ERROR state. ItÙM**   is set to zero in all other states. In PAGER_ERROR state, Pager.errCode ÙO**   is always set to SQLITE_FULL, SQLITE_IOERR or one of the SQLITE_IOERR_XXX ¯**   sub-codes.¢**º** syncFlags, walSyncFlags¢**ÙN**   syncFlags is either SQLITE_SYNC_NORMAL (0x02) or SQLITE_SYNC_FULL (0x03).ÙL**   syncFlags is used for rollback mode.  walSyncFlags is used for WAL modeÙI**   and contains the flags used to sync the checkpoint operations in theÙK**   lower two bits, and sync flags used for transaction commits in the WALÙO**   file in bits 0x04 and 0x08.  In other words, to get the correct sync flagsÙN**   for checkpoint operations, use (walSyncFlags&0x03) and to get the correctÙK**   sync flags for transaction commit, use ((walSyncFlags>>2)&0x03).  NoteÙO**   that with synchronous=NORMAL in WAL mode, transaction commit is not syncedÙ7**   meaning that the 0x04 and 0x08 bits are both zero.¢*/®struct Pager {Ù>  sqlite3_vfs *pVfs;          /* OS functions to use for IO */ÙL  u8 exclusiveMode;           /* Boolean. True if locking_mode==EXCLUSIVE */ÙI  u8 journalMode;             /* One of the PAGER_JOURNALMODE_* values */ÙG  u8 useJournal;              /* Use a rollback journal on this file */ÙC  u8 noSync;                  /* Do not sync the journal if true */ÙP  u8 fullSync;                /* Do extra syncs of the journal for robustness */ÙG  u8 extraSync;               /* sync directory after journal delete */ÙF  u8 syncFlags;               /* SYNC_NORMAL or SYNC_FULL otherwise */Ù9  u8 walSyncFlags;            /* See description above */ÙN  u8 tempFile;                /* zFilename is a temporary or immutable file */ÙD  u8 noLock;                  /* Do not lock (except in WAL mode) */ÙA  u8 readOnly;                /* True for a read-only database */Ù@  u8 memDb;                   /* True to inhibit all file I/O */ ÙM  /**************************************************************************ÙH  ** The following block contains those class members that change duringÙI  ** routine operation.  Class members not in this block are either fixedÙH  ** when the pager is first created or else only change when there is aÙK  ** significant mode change (such as changing the page_size, locking_mode,ÙK  ** or the journal_mode).  From another view, these class members describeÙE  ** the "state" of the pager, while other class members describe theÙ"  ** "configuration" of the pager.¤  */ÙO  u8 eState;                  /* Pager state (OPEN, READER, WRITER_LOCKED..) */ÙF  u8 eLock;                   /* Current lock held on database file */ÙM  u8 changeCountDone;         /* Set after incrementing the change-counter */ÙO  u8 setMaster;               /* True if a m-j name has been written to jrnl */ÙH  u8 doNotSpill;              /* Do not spill the cache when non-zero */ÙF  u8 subjInMemory;            /* True to use in-memory sub-journals */Ù8  u8 bUseFetch;               /* True to use xFetch() */ÙL  u8 hasHeldSharedLock;       /* True if a shared lock has ever been held */ÙC  Pgno dbSize;                /* Number of pages in the database */ÙI  Pgno dbOrigSize;            /* dbSize before the current transaction */ÙH  Pgno dbFileSize;            /* Number of pages in the database file */ÙH  Pgno dbHintSize;            /* Value passed to FCNTL_SIZE_HINT call */ÙB  int errCode;                /* One of several kinds of errors */ÙP  int nRec;                   /* Pages journalled since last j-header written */ÙN  u32 cksumInit;              /* Quasi-random value added to every checksum */ÙL  u32 nSubRec;                /* Number of records written to sub-journal */ÙN  Bitvec *pInJournal;         /* One bit for each page in the database file */Ù@  sqlite3_file *fd;           /* File descriptor for database */ÙD  sqlite3_file *jfd;          /* File descriptor for main journal */ÙC  sqlite3_file *sjfd;         /* File descriptor for sub-journal */ÙL  i64 journalOff;             /* Current write offset in the journal file */ÙJ  i64 journalHdr;             /* Byte offset to previous journal header */ÙO  sqlite3_backup *pBackup;    /* Pointer to list of ongoing backup processes */Ù>  PagerSavepoint *aSavepoint; /* Array of active savepoints */ÙF  int nSavepoint;             /* Number of elements in aSavepoint[] */ÙM  u32 iDataVersion;           /* Changes whenever database content changes */ÙJ  char dbFileVers[16];        /* Changes whenever database file changes */ ÙN  int nMmapOut;               /* Number of mmap pages currently outstanding */Ù=  sqlite3_int64 szMmap;       /* Desired maximum mmap size */ÙK  PgHdr *pMmapFreelist;       /* List of free mmap page headers (pDirty) */¤  /*Ù0  ** End of the routinely-changing class membersÙN  ***************************************************************************/ ÙN  u16 nExtra;                 /* Add this many bytes to each in-memory page */ÙN  i16 nReserve;               /* Number of unused bytes at end of each page */ÙA  u32 vfsFlags;               /* Flags for sqlite3_vfs.xOpen() */ÙG  u32 sectorSize;             /* Assumed sector size during rollback */Ù=  int pageSize;               /* Number of bytes in a page */ÙH  Pgno mxPgno;                /* Maximum allowed size of the database */ÙK  i64 journalSizeLimit;       /* Size limit for persistent journal files */Ù=  char *zFilename;            /* Name of the database file */Ù<  char *zJournal;             /* Name of the journal file */Ù>  int (*xBusyHandler)(void*); /* Function to call when busy */ÙE  void *pBusyHandlerArg;      /* Context argument for xBusyHandler */ÙL  int aStat[4];               /* Total cache hits, misses, writes, spills */²#ifdef SQLITE_TESTÙ7  int nRead;                  /* Database pages read */¦#endifÙJ  void (*xReiniter)(DbPage*); /* Call this routine when reloading pages */ÙG  int (*xGet)(Pager*,Pgno,DbPage**,int); /* Routine to fetch a patch */·#ifdef SQLITE_HAS_CODECÙK  void *(*xCodec)(void*,void*,Pgno,int); /* Routine for en/decoding data */ÙJ  void (*xCodecSizeChng)(void*,int,int); /* Notify of page size changes */ÙG  void (*xCodecFree)(void*);             /* Destructor for the codec */ÙG  void *pCodec;               /* First argument to xCodec... methods */¦#endifÙM  char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */Ù@  PCache *pPCache;            /* Pointer to page cache object */·#ifndef SQLITE_OMIT_WALÙN  Wal *pWal;                  /* Write-ahead log used by "journal_mode=wal" */ÙA  char *zWal;                 /* File name for write-ahead log */¦#endif¢}; ¢/*ÙG** Indexes for use with Pager.aStat[]. The Pager.aStat[] array containsÙH** the values accessed by passing SQLITE_DBSTATUS_CACHE_HIT, CACHE_MISS Ù)** or CACHE_WRITE to sqlite3_db_status().¢*/º#define PAGER_STAT_HIT   0º#define PAGER_STAT_MISS  1º#define PAGER_STAT_WRITE 2º#define PAGER_STAT_SPILL 3 ¢/*Ù8** The following global variables hold counters used forÙ:** testing purposes only.  These variables do not exist inÙ=** a non-testing build.  These variables are not thread-safe.¢*/²#ifdef SQLITE_TESTÙYSQLITE_API int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */ÙZSQLITE_API int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */ÙZSQLITE_API int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */»# define PAGER_INCR(v)  v++¥#else¶# define PAGER_INCR(v)¦#endif   ¢/*ÙA** Journal files begin with the following magic string.  The dataÙE** was obtained from /dev/random.  It is used only as a sanity check.¢**ÙE** Since version 2.8.0, the journal format contains additional sanityÙG** checking information.  If the power fails while the journal is beingÙ@** written, semi-random garbage data might appear in the journalÙ<** file after power is restored.  If an attempt is then madeÙM** to roll the journal back, the database could be corrupted.  The additionalÙD** sanity checking data is an attempt to discover the garbage in the¹** journal and ignore it.¢**ÙF** The sanity checking information for the new journal format consistsÙG** of a 32-bit checksum on each page of data.  The checksum covers bothÙG** the page number and the pPager->pageSize bytes of data for the page.ÙI** This cksum is initialized to a 32-bit random value that appears in theÙM** journal file right after the header.  The random initializer is important,ÙF** because garbage data that appears at the end of a journal is likelyÙH** data that was once in other files that have now been deleted.  If theÙG** garbage data came from an obsolete journal file, the checksums mightÙF** be correct.  But by initializing the checksum to random value whichÙ9** is different for every journal, we minimize that risk.¢*/Ù.static const unsigned char aJournalMagic[] = {Ù1  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,¢}; ¢/*ÙA** The size of the of each page record in the journal is given by·** the following macro.¢*/Ù7#define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8) ¢/*ÙD** The journal header size for this pager. This is usually the same Ù:** size as a single disk sector. See also setSectorSize().¢*/Ù3#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize) ¢/*ÙH** The macro MEMDB is true if we are dealing with an in-memory database.ÙJ** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,ÙG** the value of MEMDB will be a constant and the compiler will optimizeÙ%** out code that would never execute.¢*/»#ifdef SQLITE_OMIT_MEMORYDB°# define MEMDB 0¥#else¼# define MEMDB pPager->memDb¦#endif ¢/*ÙN** The macro USEFETCH is true if we are allowed to use the xFetch and xUnfetchÙ=** interfaces to access the database using memory-mapped I/O.¢*/º#if SQLITE_MAX_MMAP_SIZE>0Ù%# define USEFETCH(x) ((x)->bUseFetch)¥#else¶# define USEFETCH(x) 0¦#endif ¢/*Ù/** The maximum legal page number is (2^31 - 1).¢*/Ù!#define PAGER_MAX_PGNO 2147483647 ¢/*ÙH** The argument to this macro is a file descriptor (type sqlite3_file*).Ù@** Return 0 if it is not open, or non-zero (but not 1) if it is.¢**Ù1** This is so that expressions can be written as:¢**Ù#**   if( isOpen(pPager->jfd) ){ ...¢**­** instead of¢**Ù%**   if( pPager->jfd->pMethods ){ ...¢*/Ù(#define isOpen(pFd) ((pFd)->pMethods!=0) ¢/*ÙF** Return true if this pager uses a write-ahead log to read page pgno.ÙC** Return false if the pager reads pgno directly from the database.¢*/ÙE#if !defined(SQLITE_OMIT_WAL) && defined(SQLITE_DIRECT_OVERFLOW_READ)Ù@SQLITE_PRIVATE int sqlite3PagerUseWal(Pager *pPager, Pgno pgno){°  u32 iRead = 0;©  int rc;Ù!  if( pPager->pWal==0 ) return 0;Ù7  rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);µ  return rc || iRead;¡}¦#endif·#ifndef SQLITE_OMIT_WALÙ&# define pagerUseWal(x) ((x)->pWal!=0)¥#else¹# define pagerUseWal(x) 0¾# define pagerRollbackWal(x) 0Ù"# define pagerWalFrames(v,w,x,y) 0Ù+# define pagerOpenWalIfPresent(z) SQLITE_OKÙ/# define pagerBeginReadTransaction(z) SQLITE_OK¦#endif ¯#ifndef NDEBUG ¢/*©** Usage:¢**Ù***   assert( assert_pager_state(pPager) );¢**ÙD** This function runs many asserts to try to find inconsistencies inÙ*** the internal state of the Pager object.¢*/Ù(static int assert_pager_state(Pager *p){´  Pager *pPager = p; ¼  /* State must be valid. */¿  assert( p->eState==PAGER_OPENÙ!       || p->eState==PAGER_READERÙ(       || p->eState==PAGER_WRITER_LOCKEDÙ*       || p->eState==PAGER_WRITER_CACHEMODÙ'       || p->eState==PAGER_WRITER_DBMODÙ*       || p->eState==PAGER_WRITER_FINISHEDÙ        || p->eState==PAGER_ERROR¤  ); ÙK  /* Regardless of the current state, a temp-file connection always behavesÙJ  ** as if it has an exclusive lock on the database file. It never updatesÙI  ** the change-counter field, so the changeCountDone flag is always set.¤  */Ù7  assert( p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK );Ù6  assert( p->tempFile==0 || pPager->changeCountDone ); ÙF  /* If the useJournal flag is clear, the journal-mode must be "OFF". ÙI  ** And if the journal-mode is "OFF", the journal file must not be open.¤  */ÙC  assert( p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal );ÙE  assert( p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) ); ÙF  /* Check that MEMDB implies noSync. And an in-memory journal. Since ÙN  ** this means an in-memory pager performs no IO at all, it cannot encounter ÙL  ** either SQLITE_IOERR or SQLITE_FULL during rollback or while finalizing ÙH  ** a journal file. (although the in-memory journal implementation may ÙL  ** return SQLITE_IOERR_NOMEM while the journal file is being written). It ÙI  ** is therefore not possible for an in-memory pager to enter the ERROR «  ** state.¤  */®  if( MEMDB ){½    assert( !isOpen(p->fd) );¸    assert( p->noSync );Ù2    assert( p->journalMode==PAGER_JOURNALMODE_OFF Ù5         || p->journalMode==PAGER_JOURNALMODE_MEMORY ¦    );Ù>    assert( p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN );Ù     assert( pagerUseWal(p)==0 );£  } ÙG  /* If changeCountDone is set, a RESERVED lock or greater must be held±  ** on the file.¤  */ÙG  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );Ù#  assert( p->eLock!=PENDING_LOCK ); ¶  switch( p->eState ){´    case PAGER_OPEN:·      assert( !MEMDB );Ù+      assert( pPager->errCode==SQLITE_OK );ÙN      assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );¬      break; ¶    case PAGER_READER:Ù+      assert( pPager->errCode==SQLITE_OK );Ù'      assert( p->eLock!=UNKNOWN_LOCK );Ù&      assert( p->eLock>=SHARED_LOCK );¬      break; ½    case PAGER_WRITER_LOCKED:Ù'      assert( p->eLock!=UNKNOWN_LOCK );Ù+      assert( pPager->errCode==SQLITE_OK );Ù!      if( !pagerUseWal(pPager) ){Ù*        assert( p->eLock>=RESERVED_LOCK );§      }Ù3      assert( pPager->dbSize==pPager->dbOrigSize );Ù7      assert( pPager->dbOrigSize==pPager->dbFileSize );Ù7      assert( pPager->dbOrigSize==pPager->dbHintSize );Ù%      assert( pPager->setMaster==0 );¬      break; ¿    case PAGER_WRITER_CACHEMOD:Ù'      assert( p->eLock!=UNKNOWN_LOCK );Ù+      assert( pPager->errCode==SQLITE_OK );Ù!      if( !pagerUseWal(pPager) ){ÙH        /* It is possible that if journal_mode=wal here that neither theÙF        ** journal file nor the WAL file are open. This happens duringÙE        ** a rollback transaction that switches from journal_mode=off¿        ** to journal_mode=wal.ª        */Ù*        assert( p->eLock>=RESERVED_LOCK );¿        assert( isOpen(p->jfd) Ù6             || p->journalMode==PAGER_JOURNALMODE_OFF Ù6             || p->journalMode==PAGER_JOURNALMODE_WAL ª        );§      }Ù7      assert( pPager->dbOrigSize==pPager->dbFileSize );Ù7      assert( pPager->dbOrigSize==pPager->dbHintSize );¬      break; ¼    case PAGER_WRITER_DBMOD:Ù)      assert( p->eLock==EXCLUSIVE_LOCK );Ù+      assert( pPager->errCode==SQLITE_OK );Ù%      assert( !pagerUseWal(pPager) );Ù)      assert( p->eLock>=EXCLUSIVE_LOCK );½      assert( isOpen(p->jfd) Ù4           || p->journalMode==PAGER_JOURNALMODE_OFF Ù4           || p->journalMode==PAGER_JOURNALMODE_WAL ÙO           || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)¨      );Ù7      assert( pPager->dbOrigSize<=pPager->dbHintSize );¬      break; ¿    case PAGER_WRITER_FINISHED:Ù)      assert( p->eLock==EXCLUSIVE_LOCK );Ù+      assert( pPager->errCode==SQLITE_OK );Ù%      assert( !pagerUseWal(pPager) );½      assert( isOpen(p->jfd) Ù4           || p->journalMode==PAGER_JOURNALMODE_OFF Ù4           || p->journalMode==PAGER_JOURNALMODE_WAL ÙO           || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)¨      );¬      break; µ    case PAGER_ERROR:ÙI      /* There must be at least one outstanding reference to the pager ifÙH      ** in ERROR state. Otherwise the pager should have already dropped¼      ** back to OPEN state.¨      */Ù+      assert( pPager->errCode!=SQLITE_OK );ÙM      assert( sqlite3PcacheRefCount(pPager->pPCache)>0 || pPager->tempFile );¬      break;£  } «  return 1;¡}º#endif /* ifndef NDEBUG */ ´#ifdef SQLITE_DEBUG ¢/*ÙA** Return a pointer to a human readable string in a static bufferÙG** containing the state of the Pager object passed as an argument. ThisÙJ** is intended to be used within debuggers. For example, as an alternative½** to "print *pPager" in gdb:¢**Ù/** (gdb) printf "%s", print_pager_state(pPager)¢*/Ù)static char *print_pager_state(Pager *p){¹  static char zRet[1024]; ¾  sqlite3_snprintf(1024, zRet,»      "Filename:      %s\n"Ù&      "State:         %s errCode=%d\n"»      "Lock:          %s\n"Ù(      "Locking mode:  locking_mode=%s\n"Ù(      "Journal mode:  journal_mode=%s\n"Ù;      "Backing store: tempFile=%d memDb=%d useJournal=%d\n"Ù8      "Journal:       journalOff=%lld journalHdr=%lld\n"Ù>      "Size:          dbsize=%d dbOrigSize=%d dbFileSize=%d\n"´      , p->zFilenameÙ3      , p->eState==PAGER_OPEN            ? "OPEN" :Ù5        p->eState==PAGER_READER          ? "READER" :Ù<        p->eState==PAGER_WRITER_LOCKED   ? "WRITER_LOCKED" :Ù>        p->eState==PAGER_WRITER_CACHEMOD ? "WRITER_CACHEMOD" :Ù;        p->eState==PAGER_WRITER_DBMOD    ? "WRITER_DBMOD" :Ù>        p->eState==PAGER_WRITER_FINISHED ? "WRITER_FINISHED" :Ù>        p->eState==PAGER_ERROR           ? "ERROR" : "?error?"·      , (int)p->errCodeÙ/      , p->eLock==NO_LOCK         ? "NO_LOCK" :Ù0        p->eLock==RESERVED_LOCK   ? "RESERVED" :Ù1        p->eLock==EXCLUSIVE_LOCK  ? "EXCLUSIVE" :Ù.        p->eLock==SHARED_LOCK     ? "SHARED" :Ù9        p->eLock==UNKNOWN_LOCK    ? "UNKNOWN" : "?error?"Ù1      , p->exclusiveMode ? "exclusive" : "normal"Ù?      , p->journalMode==PAGER_JOURNALMODE_MEMORY   ? "memory" :Ù<        p->journalMode==PAGER_JOURNALMODE_OFF      ? "off" :Ù?        p->journalMode==PAGER_JOURNALMODE_DELETE   ? "delete" :Ù@        p->journalMode==PAGER_JOURNALMODE_PERSIST  ? "persist" :ÙA        p->journalMode==PAGER_JOURNALMODE_TRUNCATE ? "truncate" :ÙF        p->journalMode==PAGER_JOURNALMODE_WAL      ? "wal" : "?error?"Ù;      , (int)p->tempFile, (int)p->memDb, (int)p->useJournalÙ$      , p->journalOff, p->journalHdrÙ>      , (int)p->dbSize, (int)p->dbOrigSize, (int)p->dbFileSize¤  ); ®  return zRet;¡}¦#endif Ù4/* Forward references to the various page getters */Ù3static int getPageNormal(Pager*,Pgno,DbPage**,int);Ù2static int getPageError(Pager*,Pgno,DbPage**,int);º#if SQLITE_MAX_MMAP_SIZE>0Ù1static int getPageMMap(Pager*,Pgno,DbPage**,int);¦#endif ¢/*ÙF** Set the Pager.xGet method for the appropriate routine used to fetchº** content from the pager.¢*/Ù+static void setGetterMethod(Pager *pPager){¸  if( pPager->errCode ){Ù     pPager->xGet = getPageError;º#if SQLITE_MAX_MMAP_SIZE>0¼  }else if( USEFETCH(pPager)·#ifdef SQLITE_HAS_CODEC·   && pPager->xCodec==0¦#endif¤  ){¿    pPager->xGet = getPageMMap;Ù##endif /* SQLITE_MAX_MMAP_SIZE>0 */¨  }else{Ù!    pPager->xGet = getPageNormal;£  }¡} ¢/*ÙJ** Return true if it is necessary to write page *pPg into the sub-journal.ÙF** A page needs to be written into the sub-journal if there exists oneÙ%** or more open savepoints for which:¢**ÙI**   * The page-number is less than or equal to PagerSavepoint.nOrig, andÙ=**   * The bit corresponding to the page-number is not set inÙ#**     PagerSavepoint.pInSavepoint.¢*/Ù(static int subjRequiresPage(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;´  PagerSavepoint *p;¸  Pgno pgno = pPg->pgno;¨  int i;Ù&  for(i=0; i<pPager->nSavepoint; i++){¿    p = &pPager->aSavepoint[i];ÙO    if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){¯      return 1;¥    }£  }«  return 0;¡} ³#ifdef SQLITE_DEBUG¢/*Ù:** Return true if the page is already in the journal file.¢*/Ù4static int pageInJournal(Pager *pPager, PgHdr *pPg){Ù:  return sqlite3BitvecTest(pPager->pInJournal, pPg->pgno);¡}¦#endif ¢/*ÙK** Read a 32-bit integer from the given file descriptor.  Store the integerÙG** that is read in *pRes.  Return SQLITE_OK if everything worked, or anÙ&** error code is something goes wrong.¢**Ù/** All values are stored on disk as big-endian.¢*/Ù?static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){¶  unsigned char ac[4];Ù5  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);¶  if( rc==SQLITE_OK ){Ù     *pRes = sqlite3Get4byte(ac);£  }¬  return rc;¡} ¢/*ÙH** Write a 32-bit integer into a string buffer in big-endian byte order.¢*/Ù1#define put32bits(A,B)  sqlite3Put4byte((u8*)A,B)  ¢/*ÙK** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OKÙ7** on success or an error code is something goes wrong.¢*/Ù>static int write32bits(sqlite3_file *fd, i64 offset, u32 val){­  char ac[4];µ  put32bits(ac, val);Ù+  return sqlite3OsWrite(fd, ac, 4, offset);¡} ¢/*ÙH** Unlock the database file to level eLock, which must be either NO_LOCKÙE** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()ÙL** succeeds, set the Pager.eLock variable to match the (attempted) new lock.¢**ÙF** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function isÙB** called, do not modify it. See the comment above the #define of Ù+** UNKNOWN_LOCK for an explanation of this.¢*/Ù3static int pagerUnlockDb(Pager *pPager, int eLock){µ  int rc = SQLITE_OK; Ù;  assert( !pPager->exclusiveMode || pPager->eLock==eLock );Ù1  assert( eLock==NO_LOCK || eLock==SHARED_LOCK );Ù5  assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );»  if( isOpen(pPager->fd) ){Ù#    assert( pPager->eLock>=eLock );ÙI    rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);Ù&    if( pPager->eLock!=UNKNOWN_LOCK ){Ù       pPager->eLock = (u8)eLock;¥    }Ù.    IOTRACE(("UNLOCK %p %d\n", pPager, eLock))£  }¬  return rc;¡} ¢/*ÙK** Lock the database file to level eLock, which must be either SHARED_LOCK,ÙH** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set theÙ2** Pager.eLock variable to the new locking state. ¢**ÙG** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is ÙL** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. ÙH** See the comment above the #define of UNKNOWN_LOCK for an explanation «** of this.¢*/Ù1static int pagerLockDb(Pager *pPager, int eLock){µ  int rc = SQLITE_OK; ÙP  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );Ù;  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){ÙG    rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);ÙP    if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){Ù       pPager->eLock = (u8)eLock;Ù.      IOTRACE(("LOCK %p %d\n", pPager, eLock))¥    }£  }¬  return rc;¡} ¢/*Ù>** This function determines whether or not the atomic-write orÙD** atomic-batch-write optimizations can be used with this pager. TheÙ,** atomic-write optimization can be used if:¢**ÙF**  (a) the value returned by OsDeviceCharacteristics() indicates thatÙ6**      a database page may be written atomically, andÙB**  (b) the value returned by OsSectorSize() is less than or equal¹**      to the page size.¢**ÙI** If it can be used, then the value returned is the size of the journal Ù<** file when it contains rollback data for exactly one page.¢**ÙO** The atomic-batch-write optimization can be used if OsDeviceCharacteristics()ÙD** returns a value with the SQLITE_IOCAP_BATCH_ATOMIC bit set. -1 is¹** returned in this case.¢**Ù6** If neither optimization can be used, 0 is returned.¢*/Ù)static int jrnlBufferSize(Pager *pPager){³  assert( !MEMDB ); Ù)#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \Ù- || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)Ù@  int dc;                           /* Device characteristics */ ¿  assert( isOpen(pPager->fd) );Ù2  dc = sqlite3OsDeviceCharacteristics(pPager->fd);¥#else»  UNUSED_PARAMETER(pPager);¦#endif Ù'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITEÙ;  if( pPager->dbSize>0 && (dc&SQLITE_IOCAP_BATCH_ATOMIC) ){®    return -1;£  }¦#endif Ù!#ifdef SQLITE_ENABLE_ATOMIC_WRITE£  {Ù%    int nSector = pPager->sectorSize;Ù"    int szPage = pPager->pageSize; Ù-    assert(SQLITE_IOCAP_ATOMIC512==(512>>8));Ù/    assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));ÙF    if( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){¯      return 0;¥    }£  } Ù8  return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);¦#endif «  return 0;¡} ¢/*ÙC** If SQLITE_CHECK_PAGES is defined then we do some sanity checkingÙ@** on the cache using a hash function.  This is used for testing¶** and debugging only.¢*/¹#ifdef SQLITE_CHECK_PAGES¢/*Ù3** Return a 32-bit hash of the page data for pPage.¢*/Ù;static u32 pager_datahash(int nByte, unsigned char *pData){¯  u32 hash = 0;¨  int i;¹  for(i=0; i<nByte; i++){Ù"    hash = (hash*1039) + pData[i];£  }®  return hash;¡}Ù(static u32 pager_pagehash(PgHdr *pPage){ÙP  return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData);¡}Ù-static void pager_set_pagehash(PgHdr *pPage){Ù*  pPage->pageHash = pager_pagehash(pPage);¡} ¢/*ÙL** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGESÙF** is defined, and NDEBUG is not defined, an assert() statement checksÙK** that the page is either dirty or still matches the calculated page-hash.¢*/Ù"#define CHECK_PAGE(x) checkPage(x)Ù"static void checkPage(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;Ù(  assert( pPager->eState!=PAGER_ERROR );ÙK  assert( (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) );¡} ¥#else¾#define pager_datahash(X,Y)  0¼#define pager_pagehash(X)  0½#define pager_set_pagehash(X)µ#define CHECK_PAGE(x)Ù #endif  /* SQLITE_CHECK_PAGES */ ¢/*ÙF** When this is called the journal file for pager pPager must be open.ÙF** This function attempts to read a master journal file name from the ÙF** end of the file and, if successful, copies it into memory supplied ÙH** by the caller. See comments above writeMasterJournal() for the formatÙI** used to store a master journal file name at the end of a journal file.¢**ÙH** zMaster must point to a buffer of at least nMaster bytes allocated byÙJ** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there isÙH** enough space to write the master journal name). If the master journalÙ@** name in the journal is longer than nMaster bytes (including aÙE** nul-terminator), then this is handled as if no master journal name¿** were present in the journal.¢**ÙE** If a master journal file name is present at the end of the journalÙC** file, then it is copied into the buffer pointed to by zMaster. AÙE** nul-terminator byte is appended to the buffer following the masterµ** journal file name.¢**ÙC** If it is determined that no master journal file name is present Ù1** zMaster[0] is set to 0 and SQLITE_OK returned.¢**ÙD** If an error occurs while reading from the journal file, an SQLiteº** error code is returned.¢*/ÙNstatic int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){Ù.  int rc;                    /* Return code */ÙI  u32 len;                   /* Length in bytes of master journal name */ÙL  i64 szJ;                   /* Total size in bytes of journal file pJrnl */ÙF  u32 cksum;                 /* MJ checksum value read from journal */Ù8  u32 u;                     /* Unsigned loop counter */ÙD  unsigned char aMagic[8];   /* A buffer to hold the magic header */´  zMaster[0] = '\0'; Ù6  if( SQLITE_OK!=(rc = sqlite3OsFileSize(pJrnl, &szJ))¬   || szJ<16Ù7   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-16, &len))³   || len>=nMaster °   || len>szJ-16­   || len==0 Ù9   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-12, &cksum))Ù>   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))Ù&   || memcmp(aMagic, aJournalMagic, 8)ÙF   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len))¤  ){®    return rc;£  } Ù;  /* See if the checksum matches the master journal name */·  for(u=0; u<len; u++){¸    cksum -= zMaster[u];£  }®  if( cksum ){ÙK    /* If the checksum doesn't add up, then one or more of the disk sectorsÙF    ** containing the master journal filename is corrupted. This meansÙH    ** definitely roll back, so just return SQLITE_OK and report a (nul)¿    ** master-journal filename.¦    */¬    len = 0;£  }¶  zMaster[len] = '\0';£   ³  return SQLITE_OK;¡} ¢/*Ù>** Return the offset of the sector boundary at or immediately Ù@** following the value in pPager->journalOff, assuming a sector Ù$** size of pPager->sectorSize bytes.¢**Ù ** i.e for a sector size of 512:¢**Ù+**   Pager.journalOff          Return valueÙ,**   ---------------------------------------Ù **   0                         0Ù"**   512                       512Ù"**   100                       512Ù#**   2000                      2048£** ¢*/Ù+static i64 journalHdrOffset(Pager *pPager){±  i64 offset = 0;½  i64 c = pPager->journalOff;ª  if( c ){ÙI    offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);£  }Ù-  assert( offset%JOURNAL_HDR_SZ(pPager)==0 );¶  assert( offset>=c );Ù.  assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );°  return offset;¡} ¢/*Ù>** The journal file must be open when this function is called.¢**ÙG** This function is a no-op if the journal file has not been written toÙ@** within the current transaction (i.e. if Pager.journalOff==0).¢**ÙF** If doTruncate is non-zero or the Pager.journalSizeLimit variable isÙM** set to 0, then truncate the journal file to zero bytes in size. Otherwise,ÙM** zero the 28-byte header at the start of the journal file. In either case, ÙJ** if the pager is not in no-sync mode, sync the journal file immediately Ù"** after writing or truncating it.¢**ÙF** If Pager.journalSizeLimit is set to a positive, non-zero value, andÙG** following the truncation or zeroing described above the size of the ÙE** journal file in bytes is larger than this value, then truncate theÙF** journal file to Pager.journalSizeLimit bytes. The journal file doesÙ2** not need to be synced following this operation.¢**ÙJ** If an IO error occurs, abandon processing and return the IO error code.¿** Otherwise, return SQLITE_OK.¢*/Ù9static int zeroJournalHdr(Pager *pPager, int doTruncate){ÙE  int rc = SQLITE_OK;                               /* Return code */Ù   assert( isOpen(pPager->jfd) );Ù3  assert( !sqlite3JournalIsInMemory(pPager->jfd) );»  if( pPager->journalOff ){ÙL    const i64 iLimit = pPager->journalSizeLimit;    /* Local cache of jsl */ Ù&    IOTRACE(("JZEROHDR %p\n", pPager))Ù"    if( doTruncate || iLimit==0 ){Ù-      rc = sqlite3OsTruncate(pPager->jfd, 0);ª    }else{Ù*      static const char zeroHdr[28] = {0};ÙD      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);¥    }Ù+    if( rc==SQLITE_OK && !pPager->noSync ){ÙN      rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);¥    } ÙE    /* At this point the transaction is committed but the write lock ÙJ    ** is still held on the file. If there is a size limit configured for ÙJ    ** the persistent journal and the journal file currently consumes moreÙJ    ** space than that limit allows for, truncate it now. There is no needÙ1    ** to sync the file following this operation.¦    */Ù$    if( rc==SQLITE_OK && iLimit>0 ){­      i64 sz;Ù/      rc = sqlite3OsFileSize(pPager->jfd, &sz);Ù'      if( rc==SQLITE_OK && sz>iLimit ){Ù4        rc = sqlite3OsTruncate(pPager->jfd, iLimit);§      }¥    }£  }¬  return rc;¡} ¢/*ÙG** The journal file must be open when this routine is called. A journalÙH** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the´** current location.¢**Ù3** The format for the journal header is as follows:Ù/** - 8 bytes: Magic identifying journal format.ÙE** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.Ù/** - 4 bytes: Random number used for page hash.Ù*** - 4 bytes: Initial database page count.ÙF** - 4 bytes: Sector size used by the process that wrote this journal.Ù!** - 4 bytes: Database page size.£** Ù;** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.¢*/Ù*static int writeJournalHdr(Pager *pPager){Ù7  int rc = SQLITE_OK;                 /* Return code */ÙP  char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */ÙP  u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */ÙJ  u32 nWrite;                         /* Bytes of header sector written */Ù8  int ii;                             /* Loop counter */ ÙF  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */ Ù'  if( nHeader>JOURNAL_HDR_SZ(pPager) ){Ù%    nHeader = JOURNAL_HDR_SZ(pPager);£  } ÙA  /* If there are active savepoints and any of them were created ÙB  ** since the most recent journal header was written, update the Ù*  ** PagerSavepoint.iHdrOffset fields now.¤  */Ù)  for(ii=0; ii<pPager->nSavepoint; ii++){Ù/    if( pPager->aSavepoint[ii].iHdrOffset==0 ){Ù=      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;¥    }£  } ÙE  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager); ¥  /* ÙG  ** Write the nRec Field - the number of page records that follow thisÙJ  ** journal header. Normally, zero is written to this value at this time.ÙI  ** After the records are added to the journal (and the journal synced, ÙH  ** if in full-sync mode), the zero is overwritten with the true numberÙ$  ** of records (see syncJournal()).¤  **ÙH  ** A faster alternative is to write 0xFFFFFFFF to the nRec field. WhenÙC  ** reading the journal this value tells SQLite to assume that theÙJ  ** rest of the journal file contains valid page records. This assumptionÙI  ** is dangerous, as if a failure occurred whilst writing to the journalÙC  ** file it may contain some garbage data. There are two scenariosÙ$  ** where this risk can be ignored:¤  **ÙC  **   * When the pager is in no-sync mode. Corruption can follow aÙ+  **     power failure in this case anyway.¤  **ÙG  **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guaranteesÙA  **     that garbage data is never appended to the journal file.¤  */Ù1  assert( isOpen(pPager->fd) || pPager->noSync );ÙG  if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)ÙL   || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) ¤  ){Ù:    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));Ù;    put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);¨  }else{Ù0    memset(zHeader, 0, sizeof(aJournalMagic)+4);£  } Ù*  /* The random check-hash initializer */ ÙD  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);ÙB  put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);Ù!  /* The initial database size */ÙC  put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);Ù0  /* The assumed sector size for this process */ÙD  put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize); µ  /* The page size */ÙB  put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize); ÙF  /* Initializing the tail of the buffer is not necessary.  EverythingÙG  ** works find if the following memset() is omitted.  But initializingÙH  ** the memory prevents valgrind from complaining, so we are willing to¾  ** take the performance hit.¤  */Ù/  memset(&zHeader[sizeof(aJournalMagic)+20], 0,Ù-         nHeader-(sizeof(aJournalMagic)+20)); ÙD  /* In theory, it is only necessary to write the 28 bytes that the ÙJ  ** journal header consumes to the journal file here. Then increment the ÙB  ** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next ÙI  ** record is written to the following sector (leaving a gap in the fileÙ2  ** that will be implicitly filled in by the OS).¤  **ÙJ  ** However it has been discovered that on some systems this pattern can ÙH  ** be significantly slower than contiguously writing data to the file,Ù@  ** even if that means explicitly writing data to the block of ÙG  ** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what®  ** is done. ¤  **ÙJ  ** The loop is required here in case the sector-size is larger than the ÙH  ** database page size. Since the zHeader buffer is only Pager.pageSizeÙJ  ** bytes in size, more than one call to sqlite3OsWrite() may be requiredÙ2  ** to populate the entire journal header sector.¥  */ ÙO  for(nWrite=0; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){ÙG    IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))ÙK    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);Ù7    assert( pPager->journalHdr <= pPager->journalOff );Ù"    pPager->journalOff += nHeader;£  } ¬  return rc;¡} ¢/*ÙK** The journal file must be open when this is called. A journal header fileÙJ** (JOURNAL_HDR_SZ bytes) is read from the current location in the journalÙ=** file. The current location in the journal file is given byÙH** pPager->journalOff. See comments above function writeJournalHdr() forÙ.** a description of the journal header format.¢**ÙE** If the header is read successfully, *pNRec is set to the number ofÙL** page records following this header and *pDbSize is set to the size of theÙK** database before the transaction began, in pages. Also, pPager->cksumInitÙJ** is set to the value read from the journal header. SQLITE_OK is returned°** in this case.¢**ÙE** If the journal header file appears to be corrupted, SQLITE_DONE isÙK** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytesÙB** cannot be read from the journal file an error code is returned.¢*/ºstatic int readJournalHdr(Ù1  Pager *pPager,               /* Pager object */¬  int isHot,ÙK  i64 journalSize,             /* Size of the open journal file in bytes */ÙH  u32 *pNRec,                  /* OUT: Value read from the nRec field */ÙO  u32 *pDbSize                 /* OUT: Value of original database size field */¢){Ù0  int rc;                      /* Return code */ÙF  unsigned char aMagic[8];     /* A buffer to hold the magic header */ÙH  i64 iHdrOff;                 /* Offset of journal header being read */ ÙF  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */ ÙE  /* Advance Pager.journalOff to the start of the next sector. If theÙF  ** journal file is too small for there to be a header stored at this¿  ** point, return SQLITE_DONE.¤  */Ù0  pPager->journalOff = journalHdrOffset(pPager);Ù@  if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){·    return SQLITE_DONE;£  }¿  iHdrOff = pPager->journalOff; ÙJ  /* Read in the first 8 bytes of the journal header. If they do not matchÙH  ** the  magic string found at the start of each journal header, returnÙI  ** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,­  ** proceed.¤  */Ù-  if( isHot || iHdrOff!=pPager->journalHdr ){ÙE    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);­    if( rc ){°      return rc;¥    }Ù;    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){¹      return SQLITE_DONE;¥    }£  } ÙG  /* Read the first three 32-bit fields of the journal header: The nRecÙG  ** field, the checksum-initializer and the database size at the startÙE  ** of the transaction. Return an error code if anything goes wrong.¤  */ÙA  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))ÙO   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))ÙD   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))¤  ){®    return rc;£  } ¾  if( pPager->journalOff==0 ){ÙH    u32 iPageSize;               /* Page-size field of journal header */ÙJ    u32 iSectorSize;             /* Sector-size field of journal header */ ÙC    /* Read the page-size and sector-size journal header fields. */ÙK    if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))ÙI     || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))¦    ){°      return rc;¥    } ÙG    /* Versions of SQLite prior to 3.5.8 set the page-size field of theÙK    ** journal header to zero. In this case, assume that the Pager.pageSizeÙ8    ** variable is already set to the correct page size.¦    */·    if( iPageSize==0 ){Ù#      iPageSize = pPager->pageSize;¥    } ÙK    /* Check that the values read from the page-size and sector-size fieldsÙI    ** are within range. To be 'in range', both values need to be a powerÙM    ** of two greater than or equal to 512 or 32, and not greater than their Ù.    ** respective compile time maximum limits.¦    */Ù8    if( iPageSize<512                  || iSectorSize<32ÙE     || iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZEÙK     || ((iPageSize-1)&iPageSize)!=0   || ((iSectorSize-1)&iSectorSize)!=0 ¦    ){ÙM      /* If the either the page-size or sector-size in the journal-header is ÙK      ** invalid, then the process that wrote the journal-header must have ÙI      ** crashed before the header was synced. In this case stop reading ¿      ** the journal file here.¨      */¹      return SQLITE_DONE;¥    } ÙF    /* Update the page-size to match the value read from the journal. ÙF    ** Use a testcase() macro to make sure that malloc failure within Ù$    ** PagerSetPagesize() is tested.¦    */Ù9    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);¾    testcase( rc!=SQLITE_OK ); ÙA    /* Update the assumed sector-size to match the value used by ÙA    ** the process that created this journal. If this journal wasÙB    ** created by a process other than this one, then this routineÙD    ** is being called from within pager_playback(). The local valueÙB    ** of Pager.sectorSize is restored at the end of that routine.¦    */Ù%    pPager->sectorSize = iSectorSize;£  } Ù/  pPager->journalOff += JOURNAL_HDR_SZ(pPager);¬  return rc;¡}  ¢/*ÙI** Write the supplied master journal name into the journal file for pagerÙK** pPager at the current location. The master journal name must be the lastÙJ** thing written to a journal file. If the pager is in full-sync mode, theÙI** journal file descriptor is advanced to the next sector boundary beforeÙ&** anything is written. The format is:¢**¾**   + 4 bytes: PAGER_MJ_PGNO.Ù1**   + N bytes: Master journal filename in utf-8.ÙN**   + 4 bytes: N (length of master journal name in bytes, no nul-terminator).Ù-**   + 4 bytes: Master journal name checksum.Ù **   + 8 bytes: aJournalMagic[].¢**ÙI** The master journal page checksum is the sum of the bytes in the masterÙJ** journal name, where each byte is interpreted as a signed 8-bit integer.¢**ÙL** If zMaster is a NULL pointer (occurs for a single database transaction), ¸** this call is a no-op.¢*/ÙBstatic int writeMasterJournal(Pager *pPager, const char *zMaster){Ù4  int rc;                          /* Return code */ÙA  int nMaster;                     /* Length of string zMaster */ÙI  i64 iHdrOff;                     /* Offset of header in journal file */ÙE  i64 jrnlSize;                    /* Size of journal file on disk */ÙC  u32 cksum = 0;                   /* Checksum of string zMaster */ Ù!  assert( pPager->setMaster==0 );Ù!  assert( !pagerUseWal(pPager) ); ¯  if( !zMaster Ù4   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY º   || !isOpen(pPager->jfd)¤  ){µ    return SQLITE_OK;£  }¸  pPager->setMaster = 1;Ù5  assert( pPager->journalHdr <= pPager->journalOff ); ÙA  /* Calculate the length in bytes and the checksum of zMaster */Ù.  for(nMaster=0; zMaster[nMaster]; nMaster++){¾    cksum += zMaster[nMaster];£  } ÙI  /* If in full-sync mode, advance to the next disk sector before writingÙJ  ** the master journal name. This is in case the previous page written toÙ)  ** the journal has already been synced.¤  */¹  if( pPager->fullSync ){Ù2    pPager->journalOff = journalHdrOffset(pPager);£  }¿  iHdrOff = pPager->journalOff; ÙE  /* Write the master journal data to the end of the journal file. IfÙ:  ** an error occurs, return the error code to the caller.¤  */ÙL  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))ÙL   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))ÙH   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))ÙH   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))Ù?   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,Ù7                                 iHdrOff+4+nMaster+8)))¤  ){®    return rc;£  }Ù%  pPager->journalOff += (nMaster+20); ÙB  /* If the pager is in peristent-journal mode, then the physical ÙD  ** journal-file may extend past the end of the master-journal nameÙA  ** and 8 bytes of magic data just written to the file. This is Ù>  ** dangerous because the code to rollback a hot-journal fileÙC  ** will not be able to find the master-journal name to determine Ù(  ** whether or not the journal is hot. ¤  **ÙE  ** Easiest thing to do in this scenario is to truncate the journal ¿  ** file to the required size.¥  */ ÙA  if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))Ù!   && jrnlSize>pPager->journalOff¤  ){Ù<    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);£  }¬  return rc;¡} ¢/*Ù;** Discard the entire contents of the in-memory page-cache.¢*/Ù'static void pager_reset(Pager *pPager){¹  pPager->iDataVersion++;Ù(  sqlite3BackupRestart(pPager->pBackup);Ù&  sqlite3PcacheClear(pPager->pPCache);¡} ¢/*Ù(** Return the pPager->iDataVersion value¢*/Ù:SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager *pPager){Ù&  assert( pPager->eState>PAGER_OPEN );¾  return pPager->iDataVersion;¡} ¢/*ÙC** Free all structures in the Pager.aSavepoint[] array and set bothÙG** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journalÙ8** if it is open and the pager is not in exclusive mode.¢*/Ù0static void releaseAllSavepoints(Pager *pPager){ÙK  int ii;               /* Iterator for looping through Pager.aSavepoint */Ù)  for(ii=0; ii<pPager->nSavepoint; ii++){Ù>    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);£  }ÙI  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){Ù!    sqlite3OsClose(pPager->sjfd);£  }Ù#  sqlite3_free(pPager->aSavepoint);¹  pPager->aSavepoint = 0;¹  pPager->nSavepoint = 0;¶  pPager->nSubRec = 0;¡} ¢/*Ù>** Set the bit number pgno in the PagerSavepoint.pInSavepoint ÙA** bitvecs of all open savepoints. Return SQLITE_OK if successfulÙ.** or SQLITE_NOMEM if a malloc failure occurs.¢*/Ù;static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){Ù.  int ii;                   /* Loop counter */Ù-  int rc = SQLITE_OK;       /* Result code */ Ù)  for(ii=0; ii<pPager->nSavepoint; ii++){Ù0    PagerSavepoint *p = &pPager->aSavepoint[ii];¹    if( pgno<=p->nOrig ){Ù4      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);Ù#      testcase( rc==SQLITE_NOMEM );Ù2      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );¥    }£  }¬  return rc;¡} ¢/*ÙE** This function is a no-op if the pager is in exclusive mode and notÙE** in the ERROR state. Otherwise, it switches the pager to PAGER_OPEN©** state.¢**ÙE** If the pager is not in exclusive-access mode, the database file isÙH** completely unlocked. If the file is unlocked and the file-system doesÙF** not exhibit the UNDELETABLE_WHEN_OPEN property, the journal file isº** closed (if it is open).¢**ÙD** If the pager is in ERROR state when this function is called, the ÙF** contents of the pager cache are discarded before switching back to ÙG** the OPEN state. Regardless of whether the pager is in exclusive-modeÙC** or not, any journal file left in the file-system will be treatedÙD** as a hot-journal and rolled back the next time a read-transactionÙ2** is opened (by this or by any other connection).¢*/Ù(static void pager_unlock(Pager *pPager){ Ù'  assert( pPager->eState==PAGER_READER Ù%       || pPager->eState==PAGER_OPEN Ù&       || pPager->eState==PAGER_ERROR ¤  ); Ù+  sqlite3BitvecDestroy(pPager->pInJournal);¹  pPager->pInJournal = 0;¿  releaseAllSavepoints(pPager); ¼  if( pagerUseWal(pPager) ){Ù#    assert( !isOpen(pPager->jfd) );Ù/    sqlite3WalEndReadTransaction(pPager->pWal);Ù     pPager->eState = PAGER_OPEN;Ù%  }else if( !pPager->exclusiveMode ){ÙN    int rc;                       /* Error code returned by pagerUnlockDb() */ÙN    int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0; ÙC    /* If the operating system support deletion of open files, thenÙI    ** close the journal file when dropping the database lock.  OtherwiseÙH    ** another connection with journal_mode=delete might delete the file¹    ** out from under us.¦    */Ù2    assert( (PAGER_JOURNALMODE_MEMORY   & 5)!=1 );Ù2    assert( (PAGER_JOURNALMODE_OFF      & 5)!=1 );Ù2    assert( (PAGER_JOURNALMODE_WAL      & 5)!=1 );Ù2    assert( (PAGER_JOURNALMODE_DELETE   & 5)!=1 );Ù2    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );Ù2    assert( (PAGER_JOURNALMODE_PERSIST  & 5)==1 );Ù5    if( 0==(iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)Ù$     || 1!=(pPager->journalMode & 5)¦    ){Ù"      sqlite3OsClose(pPager->jfd);¥    } ÙM    /* If the pager is in the ERROR state and the call to unlock the databaseÙH    ** file fails, set the current lock to UNKNOWN_LOCK. See the commentÙH    ** above the #define for UNKNOWN_LOCK for an explanation of why this´    ** is necessary.¦    */Ù(    rc = pagerUnlockDb(pPager, NO_LOCK);Ù7    if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){Ù#      pPager->eLock = UNKNOWN_LOCK;¥    } ÙI    /* The pager state may be changed from PAGER_ERROR to PAGER_OPEN hereÙG    ** without clearing the error code. This is intentional - the errorÙ>    ** code is cleared and the cache reset in the block below.¦    */Ù=    assert( pPager->errCode || pPager->eState!=PAGER_ERROR );Ù     pPager->changeCountDone = 0;Ù     pPager->eState = PAGER_OPEN;£  } ÙG  /* If Pager.errCode is set, the contents of the pager cache cannot beÙH  ** trusted. Now that there are no outstanding references to the pager,ÙF  ** it can safely move back to PAGER_OPEN state. This happens in bothÙ'  ** normal and exclusive-locking mode.¤  */Ù1  assert( pPager->errCode==SQLITE_OK || !MEMDB );¸  if( pPager->errCode ){¾    if( pPager->tempFile==0 ){º      pager_reset(pPager);Ù"      pPager->changeCountDone = 0;Ù"      pPager->eState = PAGER_OPEN;ª    }else{ÙI      pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);¥    }Ù>    if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);Ù     pPager->errCode = SQLITE_OK;¼    setGetterMethod(pPager);£  } ¹  pPager->journalOff = 0;¹  pPager->journalHdr = 0;¸  pPager->setMaster = 0;¡} ¢/*ÙH** This function is called whenever an IOERR or FULL error that requiresÙB** the pager to transition into the ERROR state may ahve occurred.ÙF** The first argument is a pointer to the pager structure, the second ÙD** the error-code about to be returned by a pager API function. The ÙE** value returned is a copy of the second argument to this function. ¢**ÙD** If the second argument is SQLITE_FULL, SQLITE_IOERR or one of theÙG** IOERR sub-codes, the pager enters the ERROR state and the error codeÙJ** is stored in Pager.errCode. While the pager remains in the ERROR state,ÙJ** all major API calls on the Pager will immediately return Pager.errCode.¢**ÙB** The ERROR state indicates that the contents of the pager-cache ÙI** cannot be trusted. This state can be cleared by completely discarding ÙD** the contents of the pager-cache. If a transaction was active whenÙD** the persistent error occurred, then the rollback journal may needÙE** to be replayed to restore the contents of the database file (as ifº** it were a hot-journal).¢*/Ù.static int pager_error(Pager *pPager, int rc){¶  int rc2 = rc & 0xff;Ù$  assert( rc==SQLITE_OK || !MEMDB );©  assert(Ù&       pPager->errCode==SQLITE_FULL ||Ù$       pPager->errCode==SQLITE_OK ||Ù-       (pPager->errCode & 0xff)==SQLITE_IOERR¤  );Ù.  if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){¹    pPager->errCode = rc;Ù!    pPager->eState = PAGER_ERROR;¼    setGetterMethod(pPager);£  }¬  return rc;¡} Ù5static int pager_truncate(Pager *pPager, Pgno nPage); ¢/*ÙG** The write transaction open on pPager is being committed (bCommit==1)¿** or rolled back (bCommit==0).¢**ÙH** Return TRUE if and only if all dirty pages should be flushed to disk.¢**©** Rules:¢**ÙG**   *  For non-TEMP databases, always sync to disk.  This is necessaryÙ'**      for transactions to be durable.¢**ÙM**   *  Sync TEMP database only on a COMMIT (not a ROLLBACK) when the backingÙH**      file has been created already (via a spill on pagerStress()) andÙI**      when the number of dirty pages in memory exceeds 25% of the total³**      cache size.¢*/Ù:static int pagerFlushOnCommit(Pager *pPager, int bCommit){Ù%  if( pPager->tempFile==0 ) return 1;º  if( !bCommit ) return 0;Ù%  if( !isOpen(pPager->fd) ) return 0;Ù:  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);¡} ¢/*ÙF** This routine ends a transaction. A transaction is usually ended by ÙG** either a COMMIT or a ROLLBACK operation. This routine may be called ÙG** after rollback of a hot-journal, or if an error occurs while openingÙA** the journal file or writing the very first journal-header of a¸** database transaction.£** ÙE** This routine is never called in PAGER_ERROR state. If it is calledÙ@** in PAGER_NONE or PAGER_SHARED state and the lock held is lessÙ1** exclusive than a RESERVED lock, it is a no-op.¢**Ù1** Otherwise, any active savepoints are released.¢**ÙG** If the journal file is open, then it is "finalized". Once a journal ÙG** file has been finalized it is not possible to use it to roll back a ÙE** transaction. Nor will it be considered to be a hot-journal by thisÙG** or any other database connection. Exactly how a journal is finalizedÙG** depends on whether or not the pager is running in exclusive mode andÙB** the current journal-mode (Pager.journalMode value), as follows:¢**¸**   journalMode==MEMORYÙB**     Journal file descriptor is simply closed. This destroys an ¹**     in-memory journal.¢**º**   journalMode==TRUNCATEÙ7**     Journal file is truncated to zero bytes in size.¢**¹**   journalMode==PERSISTÙJ**     The first 28 bytes of the journal file are zeroed. This invalidatesÙI**     the first journal header in the file, and hence the entire journalÙ;**     file. An invalid journal file cannot be rolled back.¢**¸**   journalMode==DELETEÙF**     The journal file is closed and deleted using sqlite3OsDelete().¢**ÙK**     If the pager is running in exclusive mode, this method of finalizingÙE**     the journal file is never used. Instead, if the journalMode isÙL**     DELETE and the pager is in exclusive mode, the method described underÙ,**     journalMode==PERSIST is used instead.¢**ÙI** After the journal is finalized, the pager moves to PAGER_READER state.ÙF** If running in non-exclusive rollback mode, the lock on the file is ¿** downgraded to a SHARED_LOCK.¢**ÙF** SQLITE_OK is returned if no error occurs. If an error occurs duringÙF** any of the IO operations to finalize the journal file or unlock theÙC** database then the IO error code is returned to the user. If the ÙD** operation to finalize the journal file fails, then the code stillÙE** tries to unlock the database file if not in exclusive mode. If theÙD** unlock operation fails as well, then the first error code relatedÙC** to the first error encountered (the journal finalization one) is¬** returned.¢*/ÙLstatic int pager_end_transaction(Pager *pPager, int hasMaster, int bCommit){ÙO  int rc = SQLITE_OK;      /* Error code from journal finalization operation */ÙI  int rc2 = SQLITE_OK;     /* Error code from db file unlock operation */ ÙD  /* Do nothing if the pager does not have an open write transactionÙH  ** or at least a RESERVED lock. This function may be called when thereÙE  ** is no write-transaction active but a RESERVED or greater lock isÙ"  ** held under two circumstances:¤  **ÙD  **   1. After a successful hot-journal rollback, it is called withÙ7  **      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.¤  **ÙK  **   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE ÙG  **      lock switches back to locking_mode=normal and then executes aÙN  **      read-transaction, this function is called with eState==PAGER_READER ÙH  **      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.¤  */Ù'  assert( assert_pager_state(pPager) );Ù(  assert( pPager->eState!=PAGER_ERROR );ÙJ  if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){µ    return SQLITE_OK;£  } ¿  releaseAllSavepoints(pPager);Ù7  assert( isOpen(pPager->jfd) || pPager->pInJournal==0 ÙO      || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_BATCH_ATOMIC)¤  );¼  if( isOpen(pPager->jfd) ){Ù#    assert( !pagerUseWal(pPager) ); Ù$    /* Finalize the journal file. */Ù0    if( sqlite3JournalIsInMemory(pPager->jfd) ){ÙD      /* assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ); */Ù"      sqlite3OsClose(pPager->jfd);Ù@    }else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){Ù"      if( pPager->journalOff==0 ){·        rc = SQLITE_OK;¬      }else{Ù/        rc = sqlite3OsTruncate(pPager->jfd, 0);Ù0        if( rc==SQLITE_OK && pPager->fullSync ){ÙN          /* Make sure the new file size is written into the inode right away.ÙM          ** Otherwise the journal might resurrect following a power loss andÙ:          ** cause the last transaction to roll back.  SeeÙA          ** https://bugzilla.mozilla.org/show_bug.cgi?id=1072773¬          */Ù=          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);©        }§      }½      pPager->journalOff = 0;Ù<    }else if( pPager->journalMode==PAGER_JOURNALMODE_PERSISTÙN      || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)¦    ){Ù?      rc = zeroJournalHdr(pPager, hasMaster||pPager->tempFile);½      pPager->journalOff = 0;ª    }else{ÙF      /* This branch may be executed with Pager.journalMode==MEMORY ifÙE      ** a hot-journal was just rolled back. In this case the journalÙH      ** file should be closed and deleted. If this connection writes toÙE      ** the database file, it will do so using an in-memory journal.¨      */Ù&      int bDelete = !pPager->tempFile;Ù9      assert( sqlite3JournalIsInMemory(pPager->jfd)==0 );Ù<      assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE Ù<           || pPager->journalMode==PAGER_JOURNALMODE_MEMORY Ù9           || pPager->journalMode==PAGER_JOURNALMODE_WAL ¨      );Ù"      sqlite3OsClose(pPager->jfd);´      if( bDelete ){ÙP        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);§      }¥    }£  } ¹#ifdef SQLITE_CHECK_PAGESÙA  sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);ÙF  if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){Ù-    PgHdr *p = sqlite3PagerLookup(pPager, 1);¬    if( p ){¶      p->pageHash = 0;Ù"      sqlite3PagerUnrefNotNull(p);¥    }£  }¦#endif Ù+  sqlite3BitvecDestroy(pPager->pInJournal);¹  pPager->pInJournal = 0;³  pPager->nRec = 0;¶  if( rc==SQLITE_OK ){Ù7    if( MEMDB || pagerFlushOnCommit(pPager, bCommit) ){Ù-      sqlite3PcacheCleanAll(pPager->pPCache);ª    }else{Ù2      sqlite3PcacheClearWritable(pPager->pPCache);¥    }Ù;    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);£  } ¼  if( pagerUseWal(pPager) ){ÙG    /* Drop the WAL write-lock, if any. Also, if the connection was in ÙH    ** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE Ù&    ** lock held on the database file.¦    */Ù6    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);½    assert( rc2==SQLITE_OK );ÙL  }else if( rc==SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize ){ÙM    /* This branch is taken when committing a transaction in rollback-journalÙK    ** mode if the database file on disk is larger than the database image.ÙH    ** At this point the journal has been finalized and the transaction ÙJ    ** successfully committed, but the EXCLUSIVE lock is still held on theÙG    ** file. So it is safe to truncate the database file to its minimum¹    ** required size.  */Ù,    assert( pPager->eLock==EXCLUSIVE_LOCK );Ù0    rc = pager_truncate(pPager, pPager->dbSize);£  } Ù!  if( rc==SQLITE_OK && bCommit ){ÙK    rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);Ù-    if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;£  } ½  if( !pPager->exclusiveMode ÙH   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))¤  ){Ù-    rc2 = pagerUnlockDb(pPager, SHARED_LOCK);Ù     pPager->changeCountDone = 0;£  }Ù   pPager->eState = PAGER_READER;¸  pPager->setMaster = 0; Ù   return (rc==SQLITE_OK?rc2:rc);¡} ¢/*Ù@** Execute a rollback if a transaction is active and unlock the ²** database file. ¢**ÙD** If the pager has already entered the ERROR state, do not attempt ÙD** the rollback at this time. Instead, pager_unlock() is called. TheÙB** call to pager_unlock() will discard all in-memory pages, unlockÙD** the database file and move the pager back to OPEN state. If this ÙG** means that there is a hot-journal left in the file-system, the next ÙK** connection to obtain a shared lock on the pager (which may be this one) µ** will roll it back.¢**ÙE** If the pager has not already entered the ERROR state, but an IO orÙF** malloc error occurs during a rollback, then this will itself cause ÙC** the pager to enter the ERROR state. Which will be cleared by theÙ.** call to pager_unlock(), as described above.¢*/Ù2static void pagerUnlockAndRollback(Pager *pPager){ÙB  if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){Ù)    assert( assert_pager_state(pPager) );Ù.    if( pPager->eState>=PAGER_WRITER_LOCKED ){Ù!      sqlite3BeginBenignMalloc();Ù#      sqlite3PagerRollback(pPager);¿      sqlite3EndBenignMalloc();Ù'    }else if( !pPager->exclusiveMode ){Ù-      assert( pPager->eState==PAGER_READER );Ù*      pager_end_transaction(pPager, 0, 0);¥    }£  }·  pager_unlock(pPager);¡} ¢/*ÙC** Parameter aData must point to a buffer of pPager->pageSize bytesÙH** of data. Compute and return a checksum based ont the contents of the Ù;** page of data and the current value of pPager->cksumInit.¢**ÙA** This is not a real checksum. It is really just the sum of the Ù@** random initial value (pPager->cksumInit) and every 200th byteÙF** of the page data, starting with byte offset (pPager->pageSize%200).Ù9** Each byte is interpreted as an 8-bit unsigned integer.¢**ÙC** Changing the formula used to compute this checksum results in anÙ$** incompatible journal file format.¢**ÙH** If journal corruption occurs due to a power failure, the most likely ÙH** scenario is that one end or the other of the record will be changed. ÙI** It is much less likely that the two ends of the journal record will beÙD** correct and the middle be corrupt.  Thus, this "checksum" scheme,ÙH** though fast and simple, catches the mostly likely kind of corruption.¢*/Ù7static u32 pager_cksum(Pager *pPager, const u8 *aData){ÙG  u32 cksum = pPager->cksumInit;         /* Checksum value to return */Ù;  int i = pPager->pageSize-200;          /* Loop counter */¯  while( i>0 ){¶    cksum += aData[i];­    i -= 200;£  }¯  return cksum;¡} ¢/*ÙA** Report the current page size and number of reserved bytes back°** to the codec.¢*/·#ifdef SQLITE_HAS_CODECÙ+static void pagerReportSize(Pager *pPager){¿  if( pPager->xCodecSizeChng ){Ù<    pPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,Ù2                           (int)pPager->nReserve);£  }¡}¥#elseÙH# define pagerReportSize(X)     /* No-op if we do not support a codec */¦#endif ·#ifdef SQLITE_HAS_CODEC¢/*ÙG** Make sure the number of reserved bits is the same in the destinationÙI** pager as it is in the source.  This comes up when a VACUUM changes theÙ3** number of reserved bits to the "optimal" amount.¢*/ÙHSQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager *pDest, Pager *pSrc){Ù(  if( pDest->nReserve!=pSrc->nReserve ){Ù%    pDest->nReserve = pSrc->nReserve;»    pagerReportSize(pDest);£  }¡}¦#endif ¢/*ÙH** Read a single page from either the journal file (if isMainJrnl==1) orÙB** from the sub-journal (if isMainJrnl==0) and playback that page.ÙA** The page begins at offset *pOffset into the file. The *pOffsetÙC** value is increased to the start of the next page in the journal.¢**ÙI** The main rollback journal uses checksums - the statement journal does §** not.¢**ÙI** If the page number of the page record read from the (sub-)journal fileÙF** is greater than the current value of Pager.dbSize, then playback isÙ%** skipped and SQLITE_OK is returned.¢**ÙG** If pDone is not NULL, then it is a record of pages that have alreadyÙJ** been played back.  If the page at *pOffset has already been played backÙB** (if the corresponding pDone bit is set) then skip the playback.ÙD** Make sure the pDone bit corresponding to the *pOffset page is set¶** prior to returning.¢**ÙF** If the page record is successfully read from the (sub-)journal fileÙE** and played back, then SQLITE_OK is returned. If an IO error occursÙH** while reading the record from the (sub-)journal file or while writingÙD** to the database file, then the IO error code is returned. If dataÙE** is successfully read from the (sub-)journal file but appears to beÙF** corrupted, SQLITE_DONE is returned. Data is considered corrupted inµ** two circumstances:£** ÙD**   * If the record page-number is illegal (0 or PAGER_MJ_PGNO), orÙD**   * If the record is being rolled back from the main journal fileÙ@**     and the checksum field does not match the record content.¢**ÙK** Neither of these two scenarios are possible during a savepoint rollback.¢**ÙJ** If this is a savepoint rollback, then memory may have to be dynamicallyÙK** allocated by this function. If this is the case and an allocation fails,¼** SQLITE_NOMEM is returned.¢*/Ù#static int pager_playback_one_page(ÙA  Pager *pPager,                /* The pager being played back */ÙB  i64 *pOffset,                 /* Offset of record to playback */ÙI  Bitvec *pDone,                /* Bitvec of pages already played back */ÙJ  int isMainJrnl,               /* 1 -> main journal. 0 -> sub-journal. */ÙC  int isSavepnt                 /* True for a savepoint rollback */¢){©  int rc;ÙC  PgHdr *pPg;                   /* An existing page in the cache */ÙJ  Pgno pgno;                    /* The page number of a page in journal */ÙG  u32 cksum;                    /* Checksum used for sanity checking */ÙD  char *aData;                  /* Temporary storage for the page */ÙN  sqlite3_file *jfd;            /* The file descriptor for the journal file */ÙD  int isSynced;                 /* True if journal page is synced */·#ifdef SQLITE_HAS_CODECÙG  /* The jrnlEnc flag is true if Journal pages should be passed throughÙ<  ** the codec.  It is false for pure in-memory journals. */Ù>  const int jrnlEnc = (isMainJrnl || pPager->subjInMemory==0);¦#endif Ù?  assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */Ù>  assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */ÙL  assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */ÙL  assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */ ¼  aData = pPager->pTmpSpace;ÙN  assert( aData );         /* Temp storage must have already been allocated */ÙA  assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) ); ÙK  /* Either the state is greater than PAGER_WRITER_CACHEMOD (a transaction ÙH  ** or savepoint rollback done at the request of the caller) or this isÙG  ** a hot-journal rollback. If it is a hot-journal rollback, the pagerÙG  ** is in state OPEN and holds an EXCLUSIVE lock. Hot-journal rollbackÙ;  ** only reads from the main journal, not the sub-journal.¤  */Ù/  assert( pPager->eState>=PAGER_WRITER_CACHEMODÙG       || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)¤  );Ù@  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl ); ÙG  /* Read the page number and page data from the journal or sub-journalÙD  ** file. Return an error code to the caller if an IO error occurs.¤  */Ù0  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;Ù(  rc = read32bits(jfd, *pOffset, &pgno);Ù   if( rc!=SQLITE_OK ) return rc;ÙF  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);Ù   if( rc!=SQLITE_OK ) return rc;Ù2  *pOffset += pPager->pageSize + 4 + isMainJrnl*4; ÙK  /* Sanity checking on the page.  This is more important that I originallyÙL  ** thought.  If a power failure occurs while the journal is being written,ÙL  ** it could cause invalid data to be written into the journal.  We need toÙD  ** detect this invalid data (with high probability) and ignore it.¤  */Ù/  if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){¹    assert( !isSavepnt );·    return SQLITE_DONE;£  }ÙD  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){µ    return SQLITE_OK;£  }³  if( isMainJrnl ){Ù/    rc = read32bits(jfd, (*pOffset)-4, &cksum);·    if( rc ) return rc;Ù?    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){¹      return SQLITE_DONE;¥    }£  } ÙH  /* If this page has already been played back before during the currentÙ7  ** rollback, then don't bother to play it back again.¤  */ÙA  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=SQLITE_OK ){®    return rc;£  } Ù;  /* When playing back page 1, restore the nReserve setting¤  */Ù6  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){Ù(    pPager->nReserve = ((u8*)aData)[20];¼    pagerReportSize(pPager);£  } ÙI  /* If the pager is in CACHEMOD state, then there must be a copy of thisÙG  ** page in the pager cache. In this case just update the pager cache,ÙG  ** not the database file. The page is left marked dirty in this case.¤  **ÙG  ** An exception to the above rule: If the database is in no-sync modeÙG  ** and a page is moved during an incremental vacuum then the page mayÙG  ** not be in the pager cache. Later: if a malloc() or IO error occursÙD  ** during a Movepage() call, then the page may not be in the cacheÙE  ** either. So the condition described in the above paragraph is not²  ** assert()able.¤  **ÙJ  ** If in WRITER_DBMOD, WRITER_FINISHED or OPEN state, then we update theÙI  ** pager cache if it exists and the main file. The page is then marked ÙH  ** not dirty. Since this code is only executed in PAGER_OPEN state forÙJ  ** a hot-journal rollback, it is guaranteed that the page-cache is emptyÙ#  ** if the pager is in OPEN state.¤  **ÙL  ** Ticket #1171:  The statement journal might contain page content that isÙE  ** different from the page content at the start of the transaction.ÙI  ** This occurs when a page is changed prior to the start of a statementÙG  ** then changed again within the statement.  When rolling back such aÙH  ** statement we must not write to the original database unless we knowÙN  ** for certain that original page contents are synced into the main rollbackÙG  ** journal.  Otherwise, a power loss might leave modified data in theÙD  ** database file without an entry in the rollback journal that canÙG  ** restore the database to its original form.  Two conditions must beÙG  ** met before writing to the database files. (1) the database must beÙH  ** locked.  (2) we know that the original page content is fully syncedÙH  ** in the main journal either because the page is not in cache or elseÙ'  ** the page is marked as needSync==0.¤  **ÙG  ** 2008-04-14:  When attempting to vacuum a corrupt database file, itÙK  ** is possible to fail a statement on a database that does not yet exist.ÙD  ** Do not attempt to write if database file has never been opened.¤  */¼  if( pagerUseWal(pPager) ){¬    pPg = 0;¨  }else{Ù+    pPg = sqlite3PagerLookup(pPager, pgno);£  }º  assert( pPg || !MEMDB );ÙE  assert( pPager->eState!=PAGER_OPEN || pPg==0 || pPager->tempFile );Ù4  PAGERTRACE(("PLAYBACK %d page %d hash(%08x) %s\n",ÙO           PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),Ù4           (isMainJrnl?"main-journal":"sub-journal")¥  ));³  if( isMainJrnl ){ÙB    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);¨  }else{Ù=    isSynced = (pPg==0 || 0==(pPg->flags & PGHDR_NEED_SYNC));£  }¸  if( isOpen(pPager->fd)ÙH   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)®   && isSynced¤  ){Ù.    i64 ofst = (pgno-1)*(i64)pPager->pageSize;ÙH    testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );Ù#    assert( !pagerUseWal(pPager) ); ÙH    /* Write the data read from the journal back into the database file.ÙH    ** This is usually safe even for an encrypted database - as the dataÙM    ** was encrypted before it was written to the journal file. The exceptionÙJ    ** is if the data was just read from an in-memory sub-journal. In thatÙK    ** case it must be encrypted here before it is copied into the database°    ** file.  */·#ifdef SQLITE_HAS_CODEC³    if( !jrnlEnc ){ÙB      CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT, aData);ÙK      rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);Ù;      CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);©    }else¦#endifÙI    rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst); Ù"    if( pgno>pPager->dbFileSize ){Ù       pPager->dbFileSize = pgno;¥    }º    if( pPager->pBackup ){·#ifdef SQLITE_HAS_CODEC´      if( jrnlEnc ){Ù=        CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);Ù?        sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);ÙC        CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT,aData);«      }else¦#endifÙ=      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);¥    }Ù$  }else if( !isMainJrnl && pPg==0 ){ÙG    /* If this is a rollback of a savepoint and data was not written toÙG    ** the database and the page is not in-memory, there is a potentialÙF    ** problem. When the page is next fetched by the b-tree layer, it ÙD    ** will be read from the database file, which may or may not be °    ** current. ¦    **ÙJ    ** There are a couple of different ways this can happen. All are quiteÙG    ** obscure. When running in synchronous mode, this can only happen ÙL    ** if the page is on the free-list at the start of the transaction, thenÙ:    ** populated, then moved using sqlite3PagerMovepage().¦    **ÙG    ** The solution is to add an in-memory page to the cache containingÙG    ** the data just read from the sub-journal. Mark the page as dirty ÙG    ** and if the pager requires a journal-sync, then mark the page as Ù5    ** requiring a journal-sync before it is written.¦    */¸    assert( isSavepnt );Ù;    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)==0 );Ù-    pPager->doNotSpill |= SPILLFLAG_ROLLBACK;Ù0    rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);Ù;    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)!=0 );Ù.    pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;Ù"    if( rc!=SQLITE_OK ) return rc;Ù     sqlite3PcacheMakeDirty(pPg);£  }¬  if( pPg ){ÙK    /* No page should ever be explicitly rolled back that is in use, exceptÙG    ** for page 1 which is held in use in order to keep the lock on theÙJ    ** database active. However such a page may be rolled back as a resultÙ=    ** of an internal error resulting in an automatic call to¾    ** sqlite3PagerRollback().¦    */°    void *pData;·    pData = pPg->pData;Ù0    memcpy(pData, (u8*)aData, pPager->pageSize);»    pPager->xReiniter(pPg);ÙK    /* It used to be that sqlite3PcacheMakeClean(pPg) was called here.  ButÙL    ** that call was dangerous and had no detectable benefit since the cacheÙK    ** is normally cleaned by sqlite3PcacheCleanAll() after rollback and so»    ** has been removed. */¼    pager_set_pagehash(pPg); ÙF    /* If this was page 1, then restore the value of Pager.dbFileVers.Ù&    ** Do this before any decoding. */²    if( pgno==1 ){ÙP      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));¥    } Ù-    /* Decode the page just read from disk */´#if SQLITE_HAS_CODECÙO    if( jrnlEnc ){ CODEC1(pPager, pData, pPg->pgno, 3, rc=SQLITE_NOMEM_BKPT); }¦#endif¾    sqlite3PcacheRelease(pPg);£  }¬  return rc;¡} ¢/*ÙK** Parameter zMaster is the name of a master journal file. A single journalÙK** file that referred to the master journal file has just been rolled back.ÙK** This routine checks if it is possible to delete the master journal file,¸** and does so if it is.¢**ÙH** Argument zMaster may point to Pager.pTmpSpace. So that buffer is not Ù*** available for use within this function.¢**ÙI** When a master journal file is created, it is populated with the names ÙG** of all of its child journals, one after another, formatted as utf-8 ÙE** encoded text. The end of each child journal file is marked with a ÙK** nul-terminator byte (0x00). i.e. the entire contents of a master journalÙ;** file for a transaction involving two databases might be:¢**Ù=**   "/home/bill/a.db-journal\x00/home/bill/b.db-journal\x00"¢**ÙC** A master journal file may only be deleted once all of its child Ù"** journals have been rolled back.¢**ÙD** This function reads the contents of the master-journal file into Ù@** memory and loops through each of the child journal names. ForÙ$** each child journal, it checks if:¢**Ù-**   * if the child journal exists, and if soÙC**   * if the child journal contains a reference to master journal ³**     file zMaster¢**ÙD** If a child journal can be found that matches both of the criteriaÙE** above, this function returns without doing anything. Otherwise, ifÙC** no such child journal can be found, file zMaster is deleted fromÙ+** the file-system using sqlite3OsDelete().¢**ÙG** If an IO error within this function, an error code is returned. ThisÙI** function allocates memory by calling sqlite3Malloc(). If an allocationÙI** fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors Ù ** occur, SQLITE_OK is returned.¢**ÙA** TODO: This function allocates a single block of memory to loadÙ@** the entire contents of the master journal file. This could beÙB** a couple of kilobytes or so - potentially larger than the page ¨** size.¢*/Ù?static int pager_delmaster(Pager *pPager, const char *zMaster){Ù#  sqlite3_vfs *pVfs = pPager->pVfs;Ù-  int rc;                   /* Return code */ÙI  sqlite3_file *pMaster;    /* Malloc'd master-journal file descriptor */ÙH  sqlite3_file *pJournal;   /* Malloc'd child-journal file descriptor */ÙA  char *zMasterJournal = 0; /* Contents of master journal file */Ù=  i64 nMasterJournal;       /* Size of master journal file */ÙG  char *zJournal;           /* Pointer to one journal within MJ file */ÙO  char *zMasterPtr;         /* Space to hold MJ filename from a journal file */ÙK  int nMasterPtr;           /* Amount of space allocated to zMasterPtr[] */ ÙG  /* Allocate space for both the pJournal and pMaster file descriptors.Ù=  ** If successful, open the master journal file for reading.¤  */ÙB  pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);Ù@  pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);±  if( !pMaster ){»    rc = SQLITE_NOMEM_BKPT;¨  }else{ÙH    const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL);Ù9    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);£  }Ù)  if( rc!=SQLITE_OK ) goto delmaster_out; ÙA  /* Load the entire master journal file into space obtained fromÙE  ** sqlite3_malloc() and pointed to by zMasterJournal.   Also obtainÙA  ** sufficient space (in zMasterPtr) to hold the names of masterÙ<  ** journal files extracted from regular rollback-journals.¤  */Ù3  rc = sqlite3OsFileSize(pMaster, &nMasterJournal);Ù)  if( rc!=SQLITE_OK ) goto delmaster_out;Ù"  nMasterPtr = pVfs->mxPathname+1;ÙB  zMasterJournal = sqlite3Malloc(nMasterJournal + nMasterPtr + 1);¸  if( !zMasterJournal ){»    rc = SQLITE_NOMEM_BKPT;·    goto delmaster_out;£  }Ù1  zMasterPtr = &zMasterJournal[nMasterJournal+1];ÙF  rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);Ù)  if( rc!=SQLITE_OK ) goto delmaster_out;Ù%  zMasterJournal[nMasterJournal] = 0; ¼  zJournal = zMasterJournal;Ù4  while( (zJournal-zMasterJournal)<nMasterJournal ){¯    int exists;ÙH    rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);¸    if( rc!=SQLITE_OK ){¹      goto delmaster_out;¥    }±    if( exists ){ÙE      /* One of the journals pointed to by the master journal exists.ÙA      ** Open it and check if it points at the master journal. IfÙ=      ** so, return without deleting the master journal file.¨      */¬      int c;ÙB      int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL);Ù=      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);º      if( rc!=SQLITE_OK ){»        goto delmaster_out;§      } Ù?      rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);¿      sqlite3OsClose(pJournal);º      if( rc!=SQLITE_OK ){»        goto delmaster_out;§      } Ù=      c = zMasterPtr[0]!=0 && strcmp(zMasterPtr, zMaster)==0;®      if( c ){ÙE        /* We have a match. Do not delete the master journal file. */»        goto delmaster_out;§      }¥    }Ù.    zJournal += (sqlite3Strlen30(zJournal)+1);£  }¡ º  sqlite3OsClose(pMaster);Ù)  rc = sqlite3OsDelete(pVfs, zMaster, 0); ®delmaster_out:¿  sqlite3_free(zMasterJournal);°  if( pMaster ){¼    sqlite3OsClose(pMaster);Ù     assert( !isOpen(pJournal) );º    sqlite3_free(pMaster);£  }¬  return rc;¡}  ¢/*ÙC** This function is used to change the actual size of the database ÙL** file in the file-system. This only happens when committing a transaction,ÙH** or rolling back a transaction (including rolling back a hot-journal).¢**ÙG** If the main database file is not open, or the pager is not in eitherÙF** DBMOD or OPEN state, this function is a no-op. Otherwise, the size ÙI** of the file is changed to nPage pages (nPage*pPager->pageSize bytes). ÙM** If the file on disk is currently larger than nPage pages, then use the VFSÙ%** xTruncate() method to truncate it.¢**ÙB** Or, it might be the case that the file on disk is smaller than ÙJ** nPage pages. Some operating system implementations can get confused if ÙB** you try to truncate a file to some size that is larger than it ÙE** currently is, so detect this case and write a single zero byte to Ù#** the end of the new file instead.¢**ÙI** If successful, return SQLITE_OK. If an IO error occurs while modifyingÙ:** the database file, return the error code to the caller.¢*/Ù5static int pager_truncate(Pager *pPager, Pgno nPage){µ  int rc = SQLITE_OK;Ù(  assert( pPager->eState!=PAGER_ERROR );Ù)  assert( pPager->eState!=PAGER_READER );¢  ¹  if( isOpen(pPager->fd) ÙI   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN) ¤  ){½    i64 currentSize, newSize;Ù"    int szPage = pPager->pageSize;Ù,    assert( pPager->eLock==EXCLUSIVE_LOCK );Ù8    /* TODO: Is it safe to use Pager.dbFileSize here? */Ù5    rc = sqlite3OsFileSize(pPager->fd, &currentSize);Ù     newSize = szPage*(i64)nPage;Ù0    if( rc==SQLITE_OK && currentSize!=newSize ){Ù       if( currentSize>newSize ){Ù4        rc = sqlite3OsTruncate(pPager->fd, newSize);Ù0      }else if( (currentSize+szPage)<=newSize ){Ù'        char *pTmp = pPager->pTmpSpace;Ù         memset(pTmp, 0, szPage);Ù4        testcase( (newSize-szPage) == currentSize );Ù4        testcase( (newSize-szPage) >  currentSize );ÙF        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);§      }º      if( rc==SQLITE_OK ){Ù#        pPager->dbFileSize = nPage;§      }¥    }£  }¬  return rc;¡} ¢/*ÙF** Return a sanitized version of the sector-size of OS file pFile. TheÙD** return value is guaranteed to lie between 32 and MAX_SECTOR_SIZE.¢*/Ù:SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *pFile){Ù(  int iRet = sqlite3OsSectorSize(pFile);°  if( iRet<32 ){¯    iRet = 512;Ù#  }else if( iRet>MAX_SECTOR_SIZE ){Ù#    assert( MAX_SECTOR_SIZE>=512 );»    iRet = MAX_SECTOR_SIZE;£  }®  return iRet;¡} ¢/*Ù?** Set the value of the Pager.sectorSize variable for the givenÙ>** pager based on the value returned by the xSectorSize methodÙ;** of the open database file. The sector size will be used Ù=** to determine the size and alignment of journal header and Ù8** master journal pointers within created journal files.¢**ÙE** For temporary files the effective sector size is always 512 bytes.¢**ÙC** Otherwise, for non-temporary files, the effective sector size isÙE** the value returned by the xSectorSize() method rounded up to 32 ifÙ?** it is less than 32, or rounded down to MAX_SECTOR_SIZE if itÙ#** is greater than MAX_SECTOR_SIZE.¢**ÙJ** If the file has the SQLITE_IOCAP_POWERSAFE_OVERWRITE property, then setÙH** the effective sector size to its minimum value (512).  The purpose ofÙC** pPager->sectorSize is to define the "blast radius" of bytes thatÙC** might change if a crash occurs while writing to a single byte inÙF** that range.  But with POWERSAFE_OVERWRITE, the blast radius is zeroÙF** (that is what POWERSAFE_OVERWRITE means), so we minimize the sectorÙJ** size.  For backwards compatibility of the rollback journal file format,Ù8** we cannot reduce the effective sector size below 512.¢*/Ù)static void setSectorSize(Pager *pPager){Ù3  assert( isOpen(pPager->fd) || pPager->tempFile ); ¶  if( pPager->tempFileÙ4   || (sqlite3OsDeviceCharacteristics(pPager->fd) & Ù2              SQLITE_IOCAP_POWERSAFE_OVERWRITE)!=0¤  ){ÙE    /* Sector size doesn't matter for temporary files. Also, the fileÙE    ** may not have been opened yet, in which case the OsSectorSize()½    ** call will segfault. */½    pPager->sectorSize = 512;¨  }else{Ù7    pPager->sectorSize = sqlite3SectorSize(pPager->fd);£  }¡} ¢/*Ù=** Playback the journal and thus restore the database file toÙ:** the state it was in before we started making changes.  ¢**Ù*** The journal file format is as follows: ¢**Ù3**  (1)  8 byte prefix.  A copy of aJournalMagic[].ÙL**  (2)  4 byte big-endian integer which is the number of valid page recordsÙG**       in the journal.  If this value is 0xffffffff, then compute theÙ6**       number of page records from the journal size.ÙF**  (3)  4 byte big-endian integer which is the initial value for the ¹**       sanity checksum.ÙD**  (4)  4 byte integer which is the number of pages to truncate theÙ'**       database to during a rollback.ÙH**  (5)  4 byte big-endian integer which is the sector size.  The headerÙ$**       is this many bytes in size.Ù:**  (6)  4 byte big-endian integer which is the page size.Ù2**  (7)  zero padding out to the next sector size.Ù7**  (8)  Zero or more pages instances, each as follows:Ù **        +  4 byte page number.Ù,**        +  pPager->pageSize bytes of data.¼**        +  4 byte checksum¢**ÙH** When we speak of the journal header, we mean the first 7 items above.Ù<** Each entry in the journal is an instance of the 8th item.¢**ÙG** Call the value from the second bullet "nRec".  nRec is the number ofÙI** valid page entries in the journal.  In most cases, you can compute theÙC** value of nRec from the size of the journal file.  But if a powerÙH** failure occurred while the journal was being written, it could be theÙH** case that the size of the journal file had already been increased butÙI** the extra entries had not yet made it safely to disk.  In such a case,ÙI** the value of nRec computed from the file size would be too large.  ForÙ;** that reason, we always use the nRec value in the header.¢**ÙH** If the nRec value is 0xffffffff it means that nRec should be computedÙD** from the file size.  This value is used when the user selects theÙL** no-sync option for the journal.  A power failure could lead to corruptionÙD** in this case.  But for things like temporary table (which will beÙ7** deleted when the power is restored) we don't care.  ¢**Ù>** If the file opened as the journal file is not a well-formedÙH** journal file then all pages up to the first corrupted page are rolledÙJ** back (or no pages if the journal header is corrupted). The journal fileÙG** is then deleted and SQLITE_OK returned, just as if no corruption had´** been encountered.¢**ÙF** If an I/O or malloc() error occurs, the journal-file is not deletedÙ!** and an error code is returned.¢**ÙI** The isHot parameter indicates that we are trying to rollback a journalÙE** that might be a hot journal.  Or, it could be that the journal is ÙD** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.ÙD** If the journal really is hot, reset the pager cache prior rollingÙF** back any content.  If the journal is merely persistent, no reset isª** needed.¢*/Ù4static int pager_playback(Pager *pPager, int isHot){Ù#  sqlite3_vfs *pVfs = pPager->pVfs;ÙB  i64 szJ;                 /* Size of the journal file in bytes */ÙA  u32 nRec;                /* Number of Records in the journal */Ù6  u32 u;                   /* Unsigned loop counter */ÙC  Pgno mxPg = 0;           /* Size of the original file in pages */Ù<  int rc;                  /* Result code of a subroutine */ÙD  int res = 1;             /* Value returned by sqlite3OsAccess() */ÙC  char *zMaster = 0;       /* Name of master journal file if any */ÙP  int needPagerReset;      /* True to reset page prior to first page rollback */ÙL  int nPlayback = 0;       /* Total number of pages restored from journal */Ù'  u32 savedPageSize = pPager->pageSize; ÙD  /* Figure out how many records are in the journal.  Abort early ifº  ** the journal is empty.¤  */Ù   assert( isOpen(pPager->jfd) );Ù,  rc = sqlite3OsFileSize(pPager->jfd, &szJ);¶  if( rc!=SQLITE_OK ){¶    goto end_playback;£  } ÙE  /* Read the master journal name from the journal, if it is present.ÙD  ** If a master journal file name is specified, but the file is notÙI  ** present on disk, then the journal is not hot and does not need to be±  ** played back.¤  **ÙH  ** TODO: Technically the following is an error because it assumes thatÙH  ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. thatÙG  ** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,ÙH  ** mxPathname is 512, which is the same as the minimum allowable value²  ** for pageSize.¤  */¾  zMaster = pPager->pTmpSpace;ÙK  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);Ù$  if( rc==SQLITE_OK && zMaster[0] ){ÙD    rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);£  }®  zMaster = 0;¾  if( rc!=SQLITE_OK || !res ){¶    goto end_playback;£  }¹  pPager->journalOff = 0;¹  needPagerReset = isHot; Ù<  /* This loop terminates either when a readJournalHdr() or ÙG  ** pager_playback_one_page() call returns SQLITE_DONE or an IO error ­  ** occurs. ¤  */­  while( 1 ){ÙH    /* Read the next journal header from the journal file.  If there areÙJ    ** not enough bytes left in the journal file for a complete header, orÙI    ** it is corrupted, then a process must have failed while writing it.Ù;    ** This indicates nothing more needs to be rolled back.¦    */Ù:    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);¹    if( rc!=SQLITE_OK ){ ¼      if( rc==SQLITE_DONE ){·        rc = SQLITE_OK;§      }¸      goto end_playback;¥    } ÙH    /* If nRec is 0xffffffff, then this journal was created by a processÙG    ** working in no-sync mode. This means that the rest of the journalÙI    ** file consists of pages, there are no more journal headers. ComputeÙ2    ** the value of nRec based on this assumption.¦    */»    if( nRec==0xffffffff ){Ù;      assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );ÙI      nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));¥    } ÙI    /* If nRec is 0 and this rollback is of a transaction created by thisÙL    ** process and if this is the final header in the journal, then it meansÙJ    ** that this part of the journal was being filled but has not yet beenÙJ    ** synced to disk.  Compute the number of pages based on the remaining¸    ** size of the file.¦    **Ù@    ** The third term of the test was added to fix ticket #2565.ÙJ    ** When rolling back a hot journal, nRec==0 always means that the nextÙG    ** chunk of the journal contains zero pages to be rolled back.  ButÙG    ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk inÙF    ** the journal, it means that the journal might contain additionalÙF    ** pages that need to be rolled back and that the number of pages Ù9    ** should be computed based on the journal file size.¦    */¼    if( nRec==0 && !isHot &&ÙH        pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){ÙG      nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));¥    } ÙF    /* If this is the first header read from the journal, truncate theÙ/    ** database file back to its original size.¦    */Ù5    if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){Ù(      rc = pager_truncate(pPager, mxPg);º      if( rc!=SQLITE_OK ){º        goto end_playback;§      }¼      pPager->dbSize = mxPg;¥    } Ù@    /* Copy original pages out of the journal and back into the Ù'    ** database file and/or page cache.¦    */º    for(u=0; u<nRec; u++){»      if( needPagerReset ){¼        pager_reset(pPager);»        needPagerReset = 0;§      }ÙE      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);º      if( rc==SQLITE_OK ){´        nPlayback++;¬      }else{¾        if( rc==SQLITE_DONE ){Ù#          pPager->journalOff = szJ;°          break;Ù0        }else if( rc==SQLITE_IOERR_SHORT_READ ){ÙG          /* If the journal has been truncated, simply stop reading andÙI          ** processing the journal. This might happen if the journal wasÙI          ** not completely written and synced prior to a crash.  In thatÙE          ** case, the database should have never been written in theÙG          ** first place so it is OK to simply abandon the rollback. */¹          rc = SQLITE_OK;¼          goto end_playback;®        }else{ÙD          /* If we are unable to rollback, quit and return the errorÙF          ** code.  This will cause the pager to enter the error stateÙD          ** so that no further harm will be done.  Perhaps the nextÙI          ** process to come along will be able to rollback the database.¬          */¼          goto end_playback;©        }§      }¥    }£  }°  /*NOTREACHED*/®  assert( 0 ); ­end_playback:¶  if( rc==SQLITE_OK ){Ù=    rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);£  }ÙK  /* Following a rollback, the database file should be back in its originalÙ?  ** state prior to the start of the transaction, so invoke theÙA  ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable theÙ9  ** assertion that the transaction counter was modified.¤  */³#ifdef SQLITE_DEBUGÙC  sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);¦#endif ÙI  /* If this playback is happening automatically as a result of an IO or ÙI  ** malloc error that occurred after the change-counter was updated but ÙC  ** before the transaction was committed, then the change-counter ÙL  ** modification may just have been reverted. If this happens in exclusive ÙL  ** mode, then subsequent transactions performed by the connection will notÙK  ** update the change-counter at all. This may lead to cache inconsistencyÙG  ** problems for other processes at some point in the future. So, justÙC  ** in case this has happened, clear the changeCountDone flag now.¤  */Ù-  pPager->changeCountDone = pPager->tempFile; ¶  if( rc==SQLITE_OK ){Ù     zMaster = pPager->pTmpSpace;ÙM    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);¾    testcase( rc!=SQLITE_OK );£  }³  if( rc==SQLITE_OKÙH   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)¤  ){Ù%    rc = sqlite3PagerSync(pPager, 0);£  }¶  if( rc==SQLITE_OK ){Ù<    rc = pager_end_transaction(pPager, zMaster[0]!='\0', 0);¾    testcase( rc!=SQLITE_OK );£  }Ù+  if( rc==SQLITE_OK && zMaster[0] && res ){ÙJ    /* If there was a master journal and this routine will return success,Ù:    ** see if it is possible to delete the master journal.¦    */Ù*    rc = pager_delmaster(pPager, zMaster);¾    testcase( rc!=SQLITE_OK );£  }»  if( isHot && nPlayback ){ÙM    sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",Ù-                nPlayback, pPager->zJournal);£  } ÙF  /* The Pager.sectorSize variable may have been updated while rollingÙE  ** back a journal created by a process with a different sector sizeÙ;  ** value. Reset it to the correct value for this process.¤  */¸  setSectorSize(pPager);¬  return rc;¡}  ¢/*ÙD** Read the content for page pPg out of the database file (or out ofÙ@** the WAL if that is where the most recent copy if found) into ÙD** pPg->pData. A shared lock or greater must be held on the databaseÙ'** file before this function is called.¢**ÙD** If page 1 is read, then the value of Pager.dbFileVers[] is set toÙ)** the value read from the database file.¢**ÙF** If an IO error occurs, then the IO error is returned to the caller.Ù$** Otherwise, SQLITE_OK is returned.¢*/Ù"static int readDbPage(PgHdr *pPg){ÙJ  Pager *pPager = pPg->pPager; /* Pager object associated with page pPg */Ù0  int rc = SQLITE_OK;          /* Return code */ ·#ifndef SQLITE_OMIT_WALÙA  u32 iFrame = 0;              /* Frame of WAL containing pgno */ Ù3  assert( pPager->eState>=PAGER_READER && !MEMDB );¿  assert( isOpen(pPager->fd) ); ¼  if( pagerUseWal(pPager) ){Ù?    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);·    if( rc ) return rc;£  }¯  if( iFrame ){ÙO    rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);§  }else¦#endif£  {Ù6    i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;ÙJ    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);Ù&    if( rc==SQLITE_IOERR_SHORT_READ ){µ      rc = SQLITE_OK;¥    }£  } µ  if( pPg->pgno==1 ){­    if( rc ){ÙG      /* If the read is unsuccessful, set the dbFileVers[] to somethingÙI      ** that will never be a valid file version.  dbFileVers[] is a copyÙH      ** of bytes 24..39 of the database.  Bytes 28..31 should always beÙJ      ** zero or the size of the database in page. Bytes 32..35 and 35..39ÙG      ** should be page numbers which are never 0xffffffff.  So fillingÙA      ** pPager->dbFileVers[] with all 0xff bytes should suffice.¨      **ÙI      ** For an encrypted database, the situation is more complex:  bytesÙH      ** 24..39 of the database are white noise.  But the probability ofÙF      ** white noise equaling 16 bytes of 0xff is vanishingly small so¿      ** we should still be ok.¨      */ÙC      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));ª    }else{Ù.      u8 *dbFileVers = &((u8*)pPg->pData)[24];ÙJ      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));¥    }£  }ÙC  CODEC1(pPager, pPg->pData, pPg->pgno, 3, rc = SQLITE_NOMEM_BKPT); Ù)  PAGER_INCR(sqlite3_pager_readdb_count);¼  PAGER_INCR(pPager->nRead);Ù/  IOTRACE(("PGIN %p %d\n", pPager, pPg->pgno));Ù.  PAGERTRACE(("FETCH %d page %d hash(%08x)\n",ÙA               PAGERID(pPager), pPg->pgno, pager_pagehash(pPg))); ¬  return rc;¡} ¢/*ÙA** Update the value of the change-counter at offsets 24 and 92 inÙ9** the header and the sqlite version number at offset 96.¢**ÙL** This is an unconditional update.  See also the pager_incr_changecounter()ÙJ** routine which only updates the change-counter if the update is actuallyÙG** needed, as determined by the pPager->changeCountDone state variable.¢*/Ù2static void pager_write_changecounter(PgHdr *pPg){µ  u32 change_counter; ÙC  /* Increment the value just read and write it back to byte 24. */ÙC  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;Ù4  put32bits(((char*)pPg->pData)+24, change_counter); Ù@  /* Also store the SQLite version number in bytes 96..99 and inÙG  ** bytes 92..95 store the change counter for which the version number±  ** is valid. */Ù4  put32bits(((char*)pPg->pData)+92, change_counter);Ù;  put32bits(((char*)pPg->pData)+96, SQLITE_VERSION_NUMBER);¡} ·#ifndef SQLITE_OMIT_WAL¢/*ÙE** This function is invoked once for each page that has already been ÙC** written into the log file when a WAL transaction is rolled back.ÙD** Parameter iPg is the page number of said page. The pCtx argument Ù0** is actually a pointer to the Pager structure.¢**ÙJ** If page iPg is present in the cache, and has no outstanding references,ÙC** it is discarded. Otherwise, if there are one or more outstandingÙE** references, the page content is reloaded from the database. If theÙF** attempt to reload content from the database is required and fails, Ù5** return an SQLite error code. Otherwise, SQLITE_OK.¢*/Ù3static int pagerUndoCallback(void *pCtx, Pgno iPg){µ  int rc = SQLITE_OK;Ù   Pager *pPager = (Pager *)pCtx;­  PgHdr *pPg; Ù   assert( pagerUseWal(pPager) );Ù(  pPg = sqlite3PagerLookup(pPager, iPg);¬  if( pPg ){Ù,    if( sqlite3PcachePageRefcount(pPg)==1 ){½      sqlite3PcacheDrop(pPg);ª    }else{»      rc = readDbPage(pPg);º      if( rc==SQLITE_OK ){¿        pPager->xReiniter(pPg);§      }Ù$      sqlite3PagerUnrefNotNull(pPg);¥    }£  } ÙH  /* Normally, if a transaction is rolled back, any backup processes areÙG  ** updated as data is copied out of the rollback journal and into theÙE  ** database. This is not generally possible with a WAL database, asÙH  ** rollback involves simply truncating the log file. Therefore, if oneÙH  ** or more frames have already been written to the log (and therefore ÙH  ** also copied into the backup databases) as part of this transaction,Ù#  ** the backups must be restarted.¤  */Ù(  sqlite3BackupRestart(pPager->pBackup); ¬  return rc;¡} ¢/*ÙG** This function is called to rollback a transaction on a WAL database.¢*/Ù+static int pagerRollbackWal(Pager *pPager){Ù3  int rc;                         /* Return Code */ÙE  PgHdr *pList;                   /* List of dirty pages to revert */ ÙH  /* For all pages in the cache that are currently dirty or have alreadyÙE  ** been written (but not committed) to the log file, do one of the ¯  ** following:¤  **Ù5  **   + Discard the cached page (if refcount==0), orÙ?  **   + Reload page content from the database (if refcount>0).¤  */Ù&  pPager->dbSize = pPager->dbOrigSize;ÙG  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);Ù2  pList = sqlite3PcacheDirtyList(pPager->pPCache);Ù"  while( pList && rc==SQLITE_OK ){Ù!    PgHdr *pNext = pList->pDirty;Ù8    rc = pagerUndoCallback((void *)pPager, pList->pgno);²    pList = pNext;£  } ¬  return rc;¡} ¢/*ÙK** This function is a wrapper around sqlite3WalFrames(). As well as loggingÙK** the contents of the list of pages headed by pList (connected by pDirty),ÙI** this function notifies any active backup processes that the pages have¬** changed. ¢**ÙN** The list of pages passed into this routine is always sorted by page number.ÙL** Hence, if page 1 appears anywhere on the list, it will be the first page.£*/ ºstatic int pagerWalFrames(Ù4  Pager *pPager,                  /* Pager object */Ù=  PgHdr *pList,                   /* List of frames to log */ÙG  Pgno nTruncate,                 /* Database size after this commit */Ù@  int isCommit                    /* True if this is a commit */¢){Ù3  int rc;                         /* Return code */Ù@  int nList;                      /* Number of pages in pList */Ù>  PgHdr *p;                       /* For looping over pages */ ¹  assert( pPager->pWal );²  assert( pList );³#ifdef SQLITE_DEBUGÙ7  /* Verify that the page list is in accending order */Ù,  for(p=pList; p && p->pDirty; p=p->pDirty){Ù(    assert( p->pgno < p->pDirty->pgno );£  }¦#endif Ù)  assert( pList->pDirty==0 || isCommit );±  if( isCommit ){ÙL    /* If a WAL transaction is being committed, there is no point in writingÙL    ** any pages with page numbers greater than nTruncate into the WAL file.ÙL    ** They will never be read by any client. So remove them from the pDirty´    ** list here. */¼    PgHdr **ppNext = &pList;®    nList = 0;Ù0    for(p=pList; (*ppNext = p)!=0; p=p->pDirty){¿      if( p->pgno<=nTruncate ){¼        ppNext = &p->pDirty;°        nList++;§      }¥    }´    assert( pList );¨  }else{®    nList = 1;£  }Ù+  pPager->aStat[PAGER_STAT_WRITE] += nList; Ù8  if( pList->pgno==1 ) pager_write_changecounter(pList);Ù&  rc = sqlite3WalFrames(pPager->pWal, ÙH      pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags¤  );Ù)  if( rc==SQLITE_OK && pPager->pBackup ){Ù!    for(p=pList; p; p=p->pDirty){ÙD      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);¥    }£  } ¹#ifdef SQLITE_CHECK_PAGESÙ2  pList = sqlite3PcacheDirtyList(pPager->pPCache);¿  for(p=pList; p; p=p->pDirty){º    pager_set_pagehash(p);£  }¦#endif ¬  return rc;¡} ¢/*Ù'** Begin a read transaction on the WAL.¢**ÙN** This routine used to be called "pagerOpenSnapshot()" because it essentiallyÙN** makes a snapshot of the database at the current point in time and preservesÙJ** that snapshot for use by the reader in spite of concurrently changes byÙ"** other writers or checkpointers.¢*/Ù4static int pagerBeginReadTransaction(Pager *pPager){Ù3  int rc;                         /* Return code */ÙC  int changed = 0;                /* True if cache must be reset */ Ù   assert( pagerUseWal(pPager) );ÙG  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER ); ÙC  /* sqlite3WalEndReadTransaction() was not called for the previousÙC  ** transaction in locking_mode=EXCLUSIVE.  So call it now.  If weÙD  ** are in locking_mode=NORMAL and EndRead() was previously called,Ù$  ** the duplicate call is harmless.¤  */Ù-  sqlite3WalEndReadTransaction(pPager->pWal); Ù>  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);Ù!  if( rc!=SQLITE_OK || changed ){¸    pager_reset(pPager);Ù>    if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);£  } ¬  return rc;¡}¦#endif ¢/*ÙD** This function is called as part of the transition from PAGER_OPENÙC** to PAGER_READER state to determine the size of the database fileÙH** in pages (assuming the page size currently stored in Pager.pageSize).¢**ÙI** If no error occurs, SQLITE_OK is returned and the size of the databaseÙC** in pages is stored in *pnPage. Otherwise, an error code (perhapsÙB** SQLITE_IOERR_FSTAT) is returned and *pnPage is left unmodified.¢*/Ù7static int pagerPagecount(Pager *pPager, Pgno *pnPage){ÙC  Pgno nPage;                     /* Value to return via *pnPage */ ÙD  /* Query the WAL sub-system for the database size. The WalDbsize()ÙJ  ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), orÙD  ** if the database size is not available. The database size is notÙB  ** available from the WAL sub-system if the log file is empty orÙ.  ** contains no valid committed transactions.¤  */Ù'  assert( pPager->eState==PAGER_OPEN );Ù'  assert( pPager->eLock>=SHARED_LOCK );¿  assert( isOpen(pPager->fd) );Ù   assert( pPager->tempFile==0 );Ù)  nPage = sqlite3WalDbsize(pPager->pWal); ÙE  /* If the number of pages in the database is not available from theÙB  ** WAL sub-system, determine the page count based on the size ofÙC  ** the database file.  If the size of the database file is not anÙ<  ** integer multiple of the page-size, round up the result.¤  */Ù/  if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){Ù@    i64 n = 0;                    /* Size of db file in bytes */Ù/    int rc = sqlite3OsFileSize(pPager->fd, &n);¸    if( rc!=SQLITE_OK ){°      return rc;¥    }Ù>    nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);£  } ÙC  /* If the current number of pages in the file is greater than theÙC  ** configured maximum pager number, increase the allowed limit so¿  ** that the file can be read.¤  */½  if( nPage>pPager->mxPgno ){Ù!    pPager->mxPgno = (Pgno)nPage;£  } ²  *pnPage = nPage;³  return SQLITE_OK;¡} ·#ifndef SQLITE_OMIT_WAL¢/*ÙL** Check if the *-wal file that corresponds to the database opened by pPagerÙI** exists if the database is not empy, or verify that the *-wal file doesÙ<** not exist (by deleting it) if the database file is empty.¢**ÙI** If the database is not empty and the *-wal file exists, open the pagerÙH** in WAL mode.  If the database is empty or if no *-wal file exists andÙ@** if no error occurs, make sure Pager.journalMode is not set to¹** PAGER_JOURNALMODE_WAL.¢**Ù%** Return SQLITE_OK or an error code.¢**ÙG** The caller must hold a SHARED lock on the database file to call thisÙL** function. Because an EXCLUSIVE lock on the db file is required to delete ÙK** a WAL on a none-empty database, this ensures there is no race condition ÙG** between the xAccess() below and an xDelete() being executed by some ´** other connection.¢*/Ù0static int pagerOpenWalIfPresent(Pager *pPager){µ  int rc = SQLITE_OK;Ù'  assert( pPager->eState==PAGER_OPEN );Ù'  assert( pPager->eLock>=SHARED_LOCK ); º  if( !pPager->tempFile ){Ù?    int isWal;                    /* True if WAL file exists */¹    rc = sqlite3OsAccess(Ù@        pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal¦    );¸    if( rc==SQLITE_OK ){²      if( isWal ){ÙE        Pgno nPage;                   /* Size of the database file */ Ù,        rc = pagerPagecount(pPager, &nPage);»        if( rc ) return rc;·        if( nPage==0 ){Ù>          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);®        }else{ÙA          testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );Ù.          rc = sqlite3PagerOpenWal(pPager, 0);©        }Ù=      }else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){Ù7        pPager->journalMode = PAGER_JOURNALMODE_DELETE;§      }¥    }£  }¬  return rc;¡}¦#endif ¢/*ÙH** Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playbackÙI** the entire master journal file. The case pSavepoint==NULL occurs when ÙI** a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction ­** savepoint.¢**ÙG** When pSavepoint is not NULL (meaning a non-transaction savepoint is ÙH** being rolled back), then the rollback consists of up to three stages,Ù$** performed in the order specified:¢**ÙC**   * Pages are played back from the main journal starting at byteÙ7**     offset PagerSavepoint.iOffset and continuing to ÙC**     PagerSavepoint.iHdrOffset, or to the end of the main journalÙ1**     file if PagerSavepoint.iHdrOffset is zero.¢**ÙF**   * If PagerSavepoint.iHdrOffset is not zero, then pages are playedÙC**     back starting from the journal header immediately following ÙE**     PagerSavepoint.iHdrOffset to the end of the main journal file.¢**ÙE**   * Pages are then played back from the sub-journal file, startingÙC**     with the PagerSavepoint.iSubRec and continuing to the end of¸**     the journal file.¢**ÙH** Throughout the rollback process, each time a page is rolled back, theÙH** corresponding bit is set in a bitvec structure (variable pDone in theÙD** implementation below). This is used to ensure that a page is onlyÙB** rolled back the first time it is encountered in either journal.¢**ÙG** If pSavepoint is NULL, then pages are only played back from the mainÙ<** journal file. There is no need for a bitvec in this case.¢**ÙF** In either case, before playback commences the Pager.dbSize variableÙD** is reset to the value that it held at the start of the savepoint ÙG** (or transaction). No page with a page-number greater than this valueÙ>** is played back. If one is encountered it is simply skipped.¢*/ÙMstatic int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){ÙC  i64 szJ;                 /* Effective size of the main journal */ÙM  i64 iHdrOff;             /* End of first segment of main-journal records */Ù,  int rc = SQLITE_OK;      /* Return code */ÙM  Bitvec *pDone = 0;       /* Bitvec to ensure pages played back only once */ Ù(  assert( pPager->eState!=PAGER_ERROR );Ù0  assert( pPager->eState>=PAGER_WRITER_LOCKED ); ÙF  /* Allocate a bitvec to use to store the set of pages rolled back */³  if( pSavepoint ){Ù3    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);±    if( !pDone ){¿      return SQLITE_NOMEM_BKPT;¥    }£  } ÙI  /* Set the database size back to the value it was before the savepoint ¿  ** being reverted was opened.¤  */ÙG  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;Ù-  pPager->changeCountDone = pPager->tempFile; Ù+  if( !pSavepoint && pagerUseWal(pPager) ){Ù$    return pagerRollbackWal(pPager);£  } ÙF  /* Use pPager->journalOff as the effective size of the main rollbackÙ;  ** journal.  The actual file might be larger than this inÙK  ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anythingÙ1  ** past pPager->journalOff is off-limits to us.¤  */»  szJ = pPager->journalOff;Ù-  assert( pagerUseWal(pPager)==0 || szJ==0 ); ÙD  /* Begin by rolling back records from the main journal starting atÙF  ** PagerSavepoint.iOffset and continuing to the next journal header.ÙG  ** There might be records in the main journal that have a page numberÙF  ** greater than the current database size (pPager->dbSize) but thoseÙE  ** will be skipped automatically.  Pages are added to pDone as theyµ  ** are played back.¤  */Ù+  if( pSavepoint && !pagerUseWal(pPager) ){ÙD    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;Ù-    pPager->journalOff = pSavepoint->iOffset;Ù9    while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){ÙM      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);¥    }¾    assert( rc!=SQLITE_DONE );¨  }else{»    pPager->journalOff = 0;£  } ÙF  /* Continue rolling back records out of the main journal starting atÙI  ** the first journal header seen and continuing until the effective endÙG  ** of the main journal file.  Continue to skip out-of-range pages andÙ0  ** continue adding pages rolled back to pDone.¤  */Ù3  while( rc==SQLITE_OK && pPager->journalOff<szJ ){Ù)    u32 ii;            /* Loop counter */Ù6    u32 nJRec = 0;     /* Number of Journal Records */®    u32 dummy;Ù8    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);¾    assert( rc!=SQLITE_DONE ); ¦    /*ÙJ    ** The "pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff"ÙB    ** test is related to ticket #2565.  See the discussion in theÙ<    ** pager_playback() function for additional information.¦    */±    if( nJRec==0 ÙE     && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff¦    ){ÙF      nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));¥    }ÙI    for(ii=0; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){ÙM      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);¥    }¾    assert( rc!=SQLITE_DONE );£  }Ù5  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ ); ÙC  /* Finally,  rollback pages from the sub-journal.  Page that wereÙL  ** previously rolled back out of the main journal (and are hence in pDone)Ù;  ** will be skipped.  Out-of-range pages are also skipped.¤  */³  if( pSavepoint ){Ù)    u32 ii;            /* Loop counter */Ù?    i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize); ¾    if( pagerUseWal(pPager) ){ÙG      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);¥    }ÙK    for(ii=pSavepoint->iSubRec; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){Ù5      assert( offset==(i64)ii*(4+pPager->pageSize) );ÙA      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);¥    }¾    assert( rc!=SQLITE_DONE );£  } ¾  sqlite3BitvecDestroy(pDone);¶  if( rc==SQLITE_OK ){½    pPager->journalOff = szJ;£  } ¬  return rc;¡} ¢/*Ù@** Change the maximum number of in-memory pages that are allowedÙ7** before attempting to recycle clean and unused pages.¢*/ÙHSQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){Ù5  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);¡} ¢/*Ù@** Change the maximum number of in-memory pages that are allowedÙ/** before attempting to spill pages to journal.¢*/ÙGSQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){Ù<  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);¡} ¢/*ÙF** Invoke SQLITE_FCNTL_MMAP_SIZE based on the current value of szMmap.¢*/Ù,static void pagerFixMaplimit(Pager *pPager){º#if SQLITE_MAX_MMAP_SIZE>0Ù   sqlite3_file *fd = pPager->fd;Ù0  if( isOpen(fd) && fd->pMethods->iVersion>=3 ){µ    sqlite3_int64 sz;¸    sz = pPager->szMmap;¿    pPager->bUseFetch = (sz>0);¼    setGetterMethod(pPager);ÙF    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);£  }¦#endif¡} ¢/*ÙK** Change the maximum size of any memory mapping made of the database file.¢*/ÙRSQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){º  pPager->szMmap = szMmap;»  pagerFixMaplimit(pPager);¡} ¢/*Ù2** Free as much memory as possible from the pager.¢*/Ù6SQLITE_PRIVATE void sqlite3PagerShrink(Pager *pPager){Ù'  sqlite3PcacheShrink(pPager->pPCache);¡} ¢/*ÙL** Adjust settings of the pager to those specified in the pgFlags parameter.¢**ÙF** The "level" in pgFlags & PAGER_SYNCHRONOUS_MASK sets the robustnessÙC** of the database to damage due to OS crashes or power failures byÙ=** changing the number of syncs()s when writing the journals.¹** There are four levels:¢**ÙE**    OFF       sqlite3OsSync() is never called.  This is the defaultÙ2**              for temporary and transient files.¢**ÙE**    NORMAL    The journal is synced once before writes begin on theÙD**              database.  This is normally adequate protection, butÙC**              it is theoretically possible, though very unlikely,ÙH**              that an inopertune power failure could leave the journalÙC**              in a state which would cause damage to the databaseÙ'**              when it is rolled back.¢**ÙF**    FULL      The journal is synced twice before writes begin on theÙK**              database (with some additional information - the nRec fieldÙH**              of the journal header - being written in between the twoÙ4**              syncs).  If we assume that writing aÙE**              single disk sector is atomic, then this mode providesÙG**              assurance that the journal will not be corrupted to theÙH**              point of causing damage to the database during rollback.¢**ÙI**    EXTRA     This is like FULL except that is also syncs the directoryÙE**              that contains the rollback journal after the rollbackÙ$**              journal is unlinked.¢**ÙI** The above is for a rollback-journal mode.  For WAL mode, OFF continuesÙI** to mean that no syncs ever occur.  NORMAL means that the WAL is syncedÙH** prior to the start of checkpoint and that the database file is syncedÙG** at the conclusion of the checkpoint if the entire content of the WALÙH** was written back into the database.  But no sync operations occur forÙG** an ordinary commit in NORMAL mode with WAL.  FULL means that the WALÙE** file is synced following each commit operation, in addition to theÙE** syncs associated with NORMAL.  There is no difference between FULLº** and EXTRA for WAL mode.¢**Ù>** Do not confuse synchronous=FULL with SQLITE_SYNC_FULL.  TheÙB** SQLITE_SYNC_FULL macro means to use the MacOSX-style full-fsyncÙ?** using fcntl(F_FULLFSYNC).  SQLITE_SYNC_NORMAL means to do anÙJ** ordinary fsync() call.  There is no difference between SQLITE_SYNC_FULLÙB** and SQLITE_SYNC_NORMAL on platforms other than MacOSX.  But theÙE** synchronous=FULL versus synchronous=NORMAL setting determines whenÙB** the xSync primitive is called and is relevant to all platforms.¢**ÙD** Numeric values associated with these states are OFF==1, NORMAL=2,®** and FULL=3.¢*/Ù!#ifndef SQLITE_OMIT_PAGER_PRAGMASÙ)SQLITE_PRIVATE void sqlite3PagerSetFlags(Ù?  Pager *pPager,        /* The pager to set safety level for */Ù+  unsigned pgFlags      /* Various flags */¢){Ù4  unsigned level = pgFlags & PAGER_SYNCHRONOUS_MASK;¹  if( pPager->tempFile ){·    pPager->noSync = 1;¹    pPager->fullSync = 0;º    pPager->extraSync = 0;¨  }else{Ù8    pPager->noSync =  level==PAGER_SYNCHRONOUS_OFF ?1:0;Ù:    pPager->fullSync = level>=PAGER_SYNCHRONOUS_FULL ?1:0;Ù<    pPager->extraSync = level==PAGER_SYNCHRONOUS_EXTRA ?1:0;£  }·  if( pPager->noSync ){º    pPager->syncFlags = 0;Ù(  }else if( pgFlags & PAGER_FULLFSYNC ){Ù)    pPager->syncFlags = SQLITE_SYNC_FULL;¨  }else{Ù+    pPager->syncFlags = SQLITE_SYNC_NORMAL;£  }Ù0  pPager->walSyncFlags = (pPager->syncFlags<<2);¹  if( pPager->fullSync ){Ù.    pPager->walSyncFlags |= pPager->syncFlags;£  }Ù<  if( (pgFlags & PAGER_CKPT_FULLFSYNC) && !pPager->noSync ){Ù2    pPager->walSyncFlags |= (SQLITE_SYNC_FULL<<2);£  }Ù#  if( pgFlags & PAGER_CACHESPILL ){Ù)    pPager->doNotSpill &= ~SPILLFLAG_OFF;¨  }else{Ù(    pPager->doNotSpill |= SPILLFLAG_OFF;£  }¡}¦#endif ¢/*ÙD** The following global variable is incremented whenever the libraryÙC** attempts to open a temporary file.  This information is used for¿** testing and analysis only.  ¢*/²#ifdef SQLITE_TESTÙ*SQLITE_API int sqlite3_opentemp_count = 0;¦#endif ¢/*¹** Open a temporary file.¢**ÙF** Write the file descriptor into *pFile. Return SQLITE_OK on success ÙB** or some other error code if we fail. The OS will automatically Ù/** delete the temporary file when it is closed.¢**ÙE** The flags passed to the VFS layer xOpen() call are those specifiedÙ1** by parameter vfsFlags ORed with the following:¢**¼**     SQLITE_OPEN_READWRITE¹**     SQLITE_OPEN_CREATE¼**     SQLITE_OPEN_EXCLUSIVEÙ **     SQLITE_OPEN_DELETEONCLOSE¢*/¹static int pagerOpentemp(Ù.  Pager *pPager,        /* The pager object */Ù<  sqlite3_file *pFile,  /* Write the file descriptor here */Ù=  int vfsFlags          /* Flags passed through to the VFS */¢){Ù)  int rc;               /* Return code */ ²#ifdef SQLITE_TESTÙE  sqlite3_opentemp_count++;  /* Used for testing and analysis only */¦#endif Ù;  vfsFlags |=  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |Ù>            SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;Ù:  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);Ù+  assert( rc!=SQLITE_OK || isOpen(pFile) );¬  return rc;¡} ¢/*Ù!** Set the busy handler function.¢**ÙA** The pager invokes the busy-handler if sqlite3OsLock() returns ÙD** SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,ÙB** or when trying to upgrade from a RESERVED lock to an EXCLUSIVE ÙB** lock. It does *not* invoke the busy handler when upgrading fromÙA** SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVEÙ7** (which occurs during hot-journal rollback). Summary:¢**Ù=**   Transition                        | Invokes xBusyHandlerÙ=**   --------------------------------------------------------Ù,**   NO_LOCK       -> SHARED_LOCK      | YesÙ+**   SHARED_LOCK   -> RESERVED_LOCK    | NoÙ+**   SHARED_LOCK   -> EXCLUSIVE_LOCK   | NoÙ,**   RESERVED_LOCK -> EXCLUSIVE_LOCK   | Yes¢**Ù>** If the busy-handler callback returns non-zero, the lock is Ù=** retried. If it returns zero, then the SQLITE_BUSY error isÙ4** returned to the caller of the pager API function.¢*/Ù/SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Ù9  Pager *pPager,                       /* Pager object */ÙM  int (*xBusyHandler)(void *),         /* Pointer to busy-handler function */ÙM  void *pBusyHandlerArg                /* Argument to pass to xBusyHandler */¢){¬  void **ap;Ù&  pPager->xBusyHandler = xBusyHandler;Ù,  pPager->pBusyHandlerArg = pBusyHandlerArg;Ù&  ap = (void **)&pPager->xBusyHandler;Ù4  assert( ((int(*)(void *))(ap[0]))==xBusyHandler );Ù#  assert( ap[1]==pBusyHandlerArg );ÙM  sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);¡} ¢/*ÙD** Change the page size used by the Pager object. The new page size »** is passed in *pPageSize.¢**ÙF** If the pager is in the error state when this function is called, itÙF** is a no-op. The value returned is the error state error code (i.e. ÙE** one of SQLITE_IOERR, an SQLITE_IOERR_xxx sub-code or SQLITE_FULL).¢**Ù/** Otherwise, if all of the following are true:¢**ÙA**   * the new page size (value of *pPageSize) is valid (a power ÙC**     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and¢**Ù4**   * there are no outstanding page references, and¢**Ù@**   * the database is either not an in-memory database or it isÙC**     an in-memory database that currently consists of zero pages.¢**Ù8** then the pager object page size is set to *pPageSize.¢**ÙM** If the page size is changed, then this function uses sqlite3PagerMalloc() ÙF** to obtain a new Pager.pTmpSpace buffer. If this allocation attempt ÙH** fails, SQLITE_NOMEM is returned and the page size remains unchanged. Ù-** In all other cases, SQLITE_OK is returned.¢**ÙH** If the page size is not changed, either because one of the enumeratedÙG** conditions above is not true, the pager was in error state when thisÙI** function was called, or because the memory allocation attempt failed, ÙJ** then *pPageSize is set to the old, retained page size before returning.¢*/ÙXSQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){µ  int rc = SQLITE_OK; ÙG  /* It is not possible to do a full assert_pager_state() here, as thisÙE  ** function may be called from within PagerOpen(), before the stateÙ2  ** of the Pager object is internally consistent.¤  **ÙF  ** At one point this function returned an error if the pager was in ÙC  ** PAGER_ERROR state. But since PAGER_ERROR state guarantees thatÙD  ** there is at least one outstanding page reference, this functionÙ%  ** is a no-op for that case anyhow.¤  */ ¼  u32 pageSize = *pPageSize;ÙM  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );Ù-  if( (pPager->memDb==0 || pPager->dbSize==0)Ù0   && sqlite3PcacheRefCount(pPager->pPCache)==0 Ù2   && pageSize && pageSize!=(u32)pPager->pageSize ¤  ){Ù7    char *pNew = NULL;             /* New temp space */²    i64 nByte = 0; Ù:    if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){Ù1      rc = sqlite3OsFileSize(pPager->fd, &nByte);¥    }¸    if( rc==SQLITE_OK ){Ù1      pNew = (char *)sqlite3PageMalloc(pageSize);Ù)      if( !pNew ) rc = SQLITE_NOMEM_BKPT;¥    } ¸    if( rc==SQLITE_OK ){º      pager_reset(pPager);Ù?      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);¥    }¸    if( rc==SQLITE_OK ){Ù)      sqlite3PageFree(pPager->pTmpSpace);¿      pPager->pTmpSpace = pNew;Ù;      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);Ù"      pPager->pageSize = pageSize;ª    }else{¼      sqlite3PageFree(pNew);¥    }£  } Ù   *pPageSize = pPager->pageSize;¶  if( rc==SQLITE_OK ){Ù1    if( nReserve<0 ) nReserve = pPager->nReserve;Ù+    assert( nReserve>=0 && nReserve<1000 );Ù%    pPager->nReserve = (i16)nReserve;¼    pagerReportSize(pPager);½    pagerFixMaplimit(pPager);£  }¬  return rc;¡} ¢/*ÙB** Return a pointer to the "temporary page" buffer held internallyÙA** by the pager.  This is a buffer that is big enough to hold theÙE** entire content of a database page.  This buffer is used internallyÙ>** during rollback and will be overwritten whenever a rollbackÙ@** occurs.  But other modules are free to use it too, as long as¾** no rollbacks are happening.¢*/Ù:SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager *pPager){»  return pPager->pTmpSpace;¡} ¢/*ÙI** Attempt to set the maximum database page count if mxPage is positive. ÙG** Make no changes if mxPage is zero or negative.  And never reduce theÙ=** maximum page count below the current size of the database.¢**Ù?** Regardless of mxPage, return the current maximum page count.¢*/ÙGSQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){±  if( mxPage>0 ){¼    pPager->mxPgno = mxPage;£  }ÙM  assert( pPager->eState!=PAGER_OPEN );      /* Called only by OP_MaxPgcnt */ÙL  assert( pPager->mxPgno>=pPager->dbSize );  /* OP_MaxPgcnt enforces this */¸  return pPager->mxPgno;¡} ¢/*ÙB** The following set of routines are used to disable the simulatedÙC** I/O error mechanism.  These routines are used to avoid simulatedÙ6** errors in places where we do not care about errors.¢**Ù@** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops¸** and generate no code.¢*/²#ifdef SQLITE_TESTÙ/SQLITE_API extern int sqlite3_io_error_pending;Ù+SQLITE_API extern int sqlite3_io_error_hit;µstatic int saved_cnt;Ù'void disable_simulated_io_errors(void){Ù'  saved_cnt = sqlite3_io_error_pending;Ù   sqlite3_io_error_pending = -1;¡}Ù&void enable_simulated_io_errors(void){Ù'  sqlite3_io_error_pending = saved_cnt;¡}¥#elseÙ&# define disable_simulated_io_errors()Ù%# define enable_simulated_io_errors()¦#endif ¢/*ÙD** Read the first N bytes from the beginning of the file into memory¹** that pDest points to. ¢**ÙB** If the pager was opened on a transient file (zFilename==""), orÙC** opened on a file less than N bytes in size, the output buffer isÙF** zeroed and SQLITE_OK returned. The rationale for this is that this ÙD** function is used to read database headers, and a new transient orÙE** zero sized database has a header than consists entirely of zeroes.¢**ÙE** If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,ÙC** the error code is returned to the caller and the contents of the»** output buffer undefined.¢*/ÙZSQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){µ  int rc = SQLITE_OK;¶  memset(pDest, 0, N);Ù3  assert( isOpen(pPager->fd) || pPager->tempFile ); ÙD  /* This routine is only called by btree immediately after creatingÙG  ** the Pager object.  There has not been an opportunity to transitionµ  ** to WAL mode yet.¤  */Ù!  assert( !pagerUseWal(pPager) ); »  if( isOpen(pPager->fd) ){Ù+    IOTRACE(("DBHDR %p 0 %d\n", pPager, N))Ù0    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);Ù&    if( rc==SQLITE_IOERR_SHORT_READ ){µ      rc = SQLITE_OK;¥    }£  }¬  return rc;¡} ¢/*ÙF** This function may only be called when a read-transaction is open onÙC** the pager. It returns the total number of pages in the database.¢**ÙI** However, if the file is between 1 and <page-size> bytes in size, then Ù$** this is considered a 1 page file.¢*/ÙFSQLITE_PRIVATE void sqlite3PagerPagecount(Pager *pPager, int *pnPage){Ù)  assert( pPager->eState>=PAGER_READER );Ù2  assert( pPager->eState!=PAGER_WRITER_FINISHED );Ù   *pnPage = (int)pPager->dbSize;¡}  ¢/*ÙA** Try to obtain a lock of type locktype on the database file. IfÙF** a similar or greater lock is already held, this function is a no-opÙ%** (returning SQLITE_OK immediately).¢**ÙG** Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke ÙD** the busy callback if the lock is currently not available. Repeat ÙA** until the busy callback returns false or until the attempt to ¼** obtain the lock succeeds.¢**ÙD** Return SQLITE_OK on success and an error code if we cannot obtainÙG** the lock. If the lock is obtained successfully, set the Pager.state Ù)** variable to locktype before returning.¢*/Ù;static int pager_wait_on_lock(Pager *pPager, int locktype){Ù8  int rc;                              /* Return code */ ÙF  /* Check that this is either a no-op (because the requested lock is ÙC  ** already held), or one of the transitions that the busy-handlerÙ:  ** may be invoked during, according to the comment aboveÙ"  ** sqlite3PagerSetBusyhandler().¤  */Ù#  assert( (pPager->eLock>=locktype)Ù;       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)ÙD       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)¤  ); ¦  do {Ù'    rc = pagerLockDb(pPager, locktype);ÙM  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );¬  return rc;¡} ¢/*ÙD** Function assertTruncateConstraint(pPager) checks that one of the ÙE** following is true for all dirty pages currently in the page-cache:¢**ÙA**   a) The page number is less than or equal to the size of the Ù,**      current database image, in pages, OR¢**ÙC**   b) if the page content were written at this time, it would notÙH**      be necessary to write the current content out to the sub-journalÙ7**      (as determined by function subjRequiresPage()).¢**ÙD** If the condition asserted by this function were not true, and theÙG** dirty page were to be discarded from the cache via the pagerStress()ÙE** routine, pagerStress() would not write the current page content toÙG** the database file. If a savepoint transaction were rolled back afterÙF** this happened, the correct behavior would be to restore the currentÙL** content of the page. However, since this content is not present in eitherÙ@** the database file or the portion of the rollback journal and ÙD** sub-journal rolled back the content could not be restored and theÙG** database image would become corrupt. It is therefore fortunate that Ù"** this circumstance cannot arise.¢*/¹#if defined(SQLITE_DEBUG)Ù3static void assertTruncateConstraintCb(PgHdr *pPg){Ù#  assert( pPg->flags&PGHDR_DIRTY );ÙE  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );¡}Ù4static void assertTruncateConstraint(Pager *pPager){ÙI  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);¡}¥#elseÙ)# define assertTruncateConstraint(pPager)¦#endif ¢/*ÙC** Truncate the in-memory database file image to nPage pages. This ÙC** function does not actually modify the database file on disk. It Ù@** just sets the internal state of the pager object so that the ÙE** truncation will be done when the current transaction is committed.¢**ÙF** This function is only called right before committing a transaction.ÙE** Once this function has been called, the transaction must either beÙE** rolled back or committed. It is not safe to call this function andÙ)** then continue writing to the database.¢*/ÙISQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){Ù"  assert( pPager->dbSize>=nPage );Ù2  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );¹  pPager->dbSize = nPage; ÙD  /* At one point the code here called assertTruncateConstraint() toÙF  ** ensure that all pages being truncated away by this operation are,ÙB  ** if one or more savepoints are open, present in the savepoint ÙD  ** journal so that they can be restored if the savepoint is rolledÙC  ** back. This is no longer necessary as this function is now onlyÙC  ** called right before committing a transaction. So although the ÙH  ** Pager object may still have open savepoints (Pager.nSavepoint!=0), ÙG  ** they cannot be rolled back. So the assertTruncateConstraint() call½  ** is no longer correct. */¡}  ¢/*ÙG** This function is called before attempting a hot-journal rollback. ItÙF** syncs the journal file to disk, then sets pPager->journalHdr to theÙF** size of the journal file so that the pager_playback() routine knowsÙ0** that the entire journal file has been synced.¢**ÙK** Syncing a hot-journal to disk before attempting to roll it back ensures ÙG** that if a power-failure occurs during the rollback, the process thatÙD** attempts rollback following system recovery sees the same journal»** content as this process.¢**ÙD** If everything goes as planned, SQLITE_OK is returned. Otherwise, ¸** an SQLite error code.¢*/Ù.static int pagerSyncHotJournal(Pager *pPager){µ  int rc = SQLITE_OK;¸  if( !pPager->noSync ){Ù8    rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);£  }¶  if( rc==SQLITE_OK ){Ù=    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);£  }¬  return rc;¡} º#if SQLITE_MAX_MMAP_SIZE>0¢/*ÙK** Obtain a reference to a memory mapped page object for page number pgno. ÙE** The new object will use the pointer pData, obtained from xFetch().Ù@** If successful, set *ppPage to point to the new page referenceÙG** and return SQLITE_OK. Otherwise, return an SQLite error code and set³** *ppPage to zero.¢**ÙG** Page references obtained by calling this function should be releasedÙ$** by calling pagerReleaseMapPage().¢*/¿static int pagerAcquireMapPage(Ù4  Pager *pPager,                  /* Pager object */Ù3  Pgno pgno,                      /* Page number */ÙE  void *pData,                    /* xFetch()'d data for this page */ÙA  PgHdr **ppPage                  /* OUT: Acquired page object */¢){ÙD  PgHdr *p;                       /* Memory mapped page to return */¢  ¾  if( pPager->pMmapFreelist ){Ù(    *ppPage = p = pPager->pMmapFreelist;Ù&    pPager->pMmapFreelist = p->pDirty;²    p->pDirty = 0;Ù     assert( pPager->nExtra>=8 );¼    memset(p->pExtra, 0, 8);¨  }else{ÙM    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);¯    if( p==0 ){ÙL      sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);¿      return SQLITE_NOMEM_BKPT;¥    }¾    p->pExtra = (void *)&p[1];º    p->flags = PGHDR_MMAP;°    p->nRef = 1;·    p->pPager = pPager;£  } Ù%  assert( p->pExtra==(void *)&p[1] );¸  assert( p->pPage==0 );Ù!  assert( p->flags==PGHDR_MMAP );¾  assert( p->pPager==pPager );·  assert( p->nRef==1 ); ±  p->pgno = pgno;³  p->pData = pData;µ  pPager->nMmapOut++; ³  return SQLITE_OK;¡}¦#endif ¢/*ÙF** Release a reference to page pPg. pPg must have been returned by an Ù)** earlier call to pagerAcquireMapPage().¢*/Ù,static void pagerReleaseMapPage(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;µ  pPager->nMmapOut--;Ù&  pPg->pDirty = pPager->pMmapFreelist;¾  pPager->pMmapFreelist = pPg; Ù.  assert( pPager->fd->pMethods->iVersion>=3 );ÙP  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);¡} ¢/*ÙA** Free all PgHdr objects stored in the Pager.pMmapFreelist list.¢*/Ù,static void pagerFreeMapHdrs(Pager *pPager){«  PgHdr *p;¯  PgHdr *pNext;Ù+  for(p=pPager->pMmapFreelist; p; p=pNext){¶    pNext = p->pDirty;´    sqlite3_free(p);£  }¡} ÙG/* Verify that the database file has not be deleted or renamed out fromÙM** under the pager.  Return SQLITE_OK if the database is still where it oughtÙO** to be on disk.  Return non-zero (SQLITE_READONLY_DBMOVED or some other errorÙA** code from sqlite3OsAccess()) if the database has gone missing.¢*/Ù,static int databaseIsUnmoved(Pager *pPager){´  int bHasMoved = 0;©  int rc; Ù*  if( pPager->tempFile ) return SQLITE_OK;Ù+  if( pPager->dbSize==0 ) return SQLITE_OK;Ù6  assert( pPager->zFilename && pPager->zFilename[0] );ÙL  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);¼  if( rc==SQLITE_NOTFOUND ){ÙK    /* If the HAS_MOVED file-control is unimplemented, assume that the fileÙO    ** has not been moved.  That is the historical behavior of SQLite: prior toÙ)    ** version 3.8.3, it never checked */³    rc = SQLITE_OK;Ù)  }else if( rc==SQLITE_OK && bHasMoved ){Ù!    rc = SQLITE_READONLY_DBMOVED;£  }¬  return rc;¡}  ¢/*ÙA** Shutdown the page cache.  Free all memory and close all files.¢**ÙE** If a transaction was in progress when this routine is called, thatÙE** transaction is rolled back.  All outstanding pages are invalidatedÙC** and their memory is freed.  Any attempt to use a page associatedÙ?** with this page cache after this function returns will likely¸** result in a coredump.¢**ÙG** This function always succeeds. If a transaction is active an attemptÙC** is made to roll it back. If an error occurs during the rollback ÙG** a hot journal may be left in the filesystem but no error is returned±** to the caller.¢*/ÙASQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3 *db){Ù$  u8 *pTmp = (u8*)pPager->pTmpSpace;Ù)  assert( db || pagerUseWal(pPager)==0 );Ù'  assert( assert_pager_state(pPager) );Ù   disable_simulated_io_errors();½  sqlite3BeginBenignMalloc();»  pagerFreeMapHdrs(pPager);¼  /* pPager->errCode = 0; */¼  pPager->exclusiveMode = 0;·#ifndef SQLITE_OMIT_WAL£  {®    u8 *a = 0;Ù$    assert( db || pPager->pWal==0 );Ù4    if( db && 0==(db->flags & SQLITE_NoCkptOnClose) Ù,     && SQLITE_OK==databaseIsUnmoved(pPager)¦    ){¯      a = pTmp;¥    }ÙP    sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);µ    pPager->pWal = 0;£  }¦#endif¶  pager_reset(pPager);®  if( MEMDB ){¹    pager_unlock(pPager);¨  }else{ÙM    /* If it is open, sync the journal file before calling UnlockAndRollback.ÙI    ** If this is not done, then an unsynced portion of the open journal ÙL    ** file may be played back into the database. If a power failure occurs ÙB    ** while this is happening, the database could become corrupt.¦    **ÙK    ** If an error occurs while trying to sync the journal, shift the pagerÙH    ** into the ERROR state. This causes UnlockAndRollback to unlock theÙH    ** database and close the journal file without attempting to roll itÙN    ** back or finalize it. The next database user will have to do hot-journalÙ3    ** rollback before accessing the database file.¦    */¾    if( isOpen(pPager->jfd) ){Ù7      pager_error(pPager, pagerSyncHotJournal(pPager));¥    }Ù#    pagerUnlockAndRollback(pPager);£  }»  sqlite3EndBenignMalloc();¿  enable_simulated_io_errors();Ù.  PAGERTRACE(("CLOSE %d\n", PAGERID(pPager)));Ù!  IOTRACE(("CLOSE %p\n", pPager))¾  sqlite3OsClose(pPager->jfd);½  sqlite3OsClose(pPager->fd);¸  sqlite3PageFree(pTmp);Ù&  sqlite3PcacheClose(pPager->pPCache); ·#ifdef SQLITE_HAS_CODECÙ>  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);¦#endif Ù7  assert( !pPager->aSavepoint && !pPager->pInJournal );Ù:  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) ); ·  sqlite3_free(pPager);³  return SQLITE_OK;¡} Ù,#if !defined(NDEBUG) || defined(SQLITE_TEST)¢/*Ù'** Return the page number for page pPg.¢*/Ù8SQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage *pPg){³  return pPg->pgno;¡}¦#endif ¢/*Ù.** Increment the reference count for page pPg.¢*/Ù1SQLITE_PRIVATE void sqlite3PagerRef(DbPage *pPg){¸  sqlite3PcacheRef(pPg);¡} ¢/*ÙF** Sync the journal. In other words, make sure all the pages that haveÙG** been written to the journal have actually reached the surface of theÙC** disk and can be restored in the event of a hot-journal rollback.¢**ÙB** If the Pager.noSync flag is set, then this function is a no-op.ÙF** Otherwise, the actions required depend on the journal-mode and the Ù9** device characteristics of the file-system, as follows:¢**ÙG**   * If the journal file is an in-memory journal file, no action need°**     be taken.¢**ÙJ**   * Otherwise, if the device does not support the SAFE_APPEND property,ÙF**     then the nRec field of the most recently written journal headerÙD**     is updated to contain the number of journal records that haveÙH**     been written following it. If the pager is operating in full-syncÙJ**     mode, then the journal file is synced before this field is updated.¢**ÙD**   * If the device does not support the SEQUENTIAL property, then ¾**     journal file is synced.¢**¶** Or, in pseudo-code:¢**Ù#**   if( NOT <in-memory journal> ){½**     if( NOT SAFE_APPEND ){Ù6**       if( <full-sync mode> ) xSync(<journal file>);¼**       <update nRec field>©**     } Ù2**     if( NOT SEQUENTIAL ) xSync(<journal file>);¦**   }¢**ÙH** If successful, this routine clears the PGHDR_NEED_SYNC flag of every ÙE** page currently held in memory before returning SQLITE_OK. If an IOÙJ** error is encountered, then the IO error code is returned to the caller.¢*/Ù2static int syncJournal(Pager *pPager, int newHdr){Ù3  int rc;                         /* Return code */ Ù/  assert( pPager->eState==PAGER_WRITER_CACHEMODÙ,       || pPager->eState==PAGER_WRITER_DBMOD¤  );Ù'  assert( assert_pager_state(pPager) );Ù!  assert( !pagerUseWal(pPager) ); Ù)  rc = sqlite3PagerExclusiveLock(pPager);Ù   if( rc!=SQLITE_OK ) return rc; ¸  if( !pPager->noSync ){Ù     assert( !pPager->tempFile );ÙO    if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){ÙA      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);Ù$      assert( isOpen(pPager->jfd) ); Ù.      if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){ÙK        /* This block deals with an obscure problem. If the last connectionÙJ        ** that wrote to this database was operating in persistent-journalÙK        ** mode, then the journal file may at this point actually be largerÙH        ** than Pager.journalOff bytes. If the next thing in the journalÙF        ** file happens to be a journal-header (written as part of theÙL        ** previous connection's transaction), and a crash or power-failure ÙJ        ** occurs after nRec is updated but before this connection writes ÙH        ** anything else to the journal file (or commits/rolls back its ÙH        ** transaction), then SQLite may become confused when doing the ÙH        ** hot-journal rollback following recovery. It may roll back allÙJ        ** of this connections data, then proceed to rolling back the old,ÙA        ** out-of-date data that follows it. Database corruption.ª        **ÙJ        ** To work around this, if the journal file does appear to containÙG        ** a valid header following Pager.journalOff, then write a 0x00ÙG        ** byte to the start of it to prevent it from being recognized.ª        **ÙE        ** Variable iNextHdrOffset is set to the offset at which thisÙG        ** problematic header will occur, if it exists. aMagic is used ÙH        ** as a temporary buffer to inspect the first couple of bytes ofÙ(        ** the potential journal header.ª        */»        i64 iNextHdrOffset;µ        u8 aMagic[8];Ù,        u8 zHeader[sizeof(aJournalMagic)+4]; Ù>        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));ÙA        put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec); Ù2        iNextHdrOffset = journalHdrOffset(pPager);ÙC        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);ÙC        if( rc==SQLITE_OK && 0==memcmp(aMagic, aJournalMagic, 8) ){Ù'          static const u8 zerobyte = 0;ÙI          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);©        }Ù;        if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){´          return rc;©        } ÙC        /* Write the nRec value into the journal file header. If inÙK        ** full-synchronous mode, sync the journal first. This ensures thatÙJ        ** all data has really hit the disk before nRec is updated to markÙ*        ** it as a candidate for rollback.ª        **ÙD        ** This is not required if the persistent media supports theÙI        ** SAFE_APPEND property. Because in this case it is not possible ÙF        ** for garbage data to be appended to the file, the nRec fieldÙJ        ** is populated with 0xFFFFFFFF when the journal header is writtenÙ)        ** and never needs to be updated.ª        */ÙC        if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){Ù@          PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));Ù)          IOTRACE(("JSYNC %p\n", pPager))Ù=          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);Ù(          if( rc!=SQLITE_OK ) return rc;©        }Ù@        IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));¼        rc = sqlite3OsWrite(ÙE            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdrª        );Ù&        if( rc!=SQLITE_OK ) return rc;§      }Ù-      if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){Ù>        PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));Ù'        IOTRACE(("JSYNC %p\n", pPager))Ù;        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags| ÙF          (pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)ª        );Ù&        if( rc!=SQLITE_OK ) return rc;§      } Ù.      pPager->journalHdr = pPager->journalOff;Ù8      if( newHdr && 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){¹        pPager->nRec = 0;Ù%        rc = writeJournalHdr(pPager);Ù&        if( rc!=SQLITE_OK ) return rc;§      }ª    }else{Ù.      pPager->journalHdr = pPager->journalOff;¥    }£  } ÙC  /* Unless the pager is in noSync mode, the journal file was just ÙH  ** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on ¯  ** all pages.¤  */Ù/  sqlite3PcacheClearSyncFlags(pPager->pPCache);Ù&  pPager->eState = PAGER_WRITER_DBMOD;Ù'  assert( assert_pager_state(pPager) );³  return SQLITE_OK;¡} ¢/*ÙF** The argument is the first in a linked list of dirty pages connectedÙD** by the PgHdr.pDirty pointer. This function writes each one of theÙE** in-memory pages in the list to the database file. The argument mayÙE** be NULL, representing an empty list. In this case this function is«** a no-op.¢**ÙB** The pager must hold at least a RESERVED lock when this functionÙE** is called. Before writing anything to the database file, this lockÙD** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,ÙG** SQLITE_BUSY is returned and no data is written to the database file.£** ÙD** If the pager is a temp-file pager and the actual file-system fileÙ@** is not yet open, it is created and opened before any data is ¯** written out.¢**ÙF** Once the lock has been upgraded and, if necessary, the file opened,ÙH** the pages are written out to the database file in list order. WritingÙB** a page is skipped if it meets either of the following criteria:¢**Ù7**   * The page number is greater than Pager.dbSize, orÙ4**   * The PGHDR_DONT_WRITE flag is set on the page.¢**ÙK** If writing out a page causes the database file to grow, Pager.dbFileSizeÙJ** is updated accordingly. If page 1 is written out, then the value cachedÙD** in Pager.dbFileVers[] is updated to match the new value stored inµ** the database file.¢**ÙF** If everything is successful, SQLITE_OK is returned. If an IO error ÙI** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannotÙ(** be obtained, SQLITE_BUSY is returned.¢*/Ù=static int pager_write_pagelist(Pager *pPager, PgHdr *pList){Ù8  int rc = SQLITE_OK;                  /* Return code */ ÙO  /* This function is only called for rollback pagers in WRITER_DBMOD state. */Ù!  assert( !pagerUseWal(pPager) );ÙC  assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );Ù*  assert( pPager->eLock==EXCLUSIVE_LOCK );Ù3  assert( isOpen(pPager->fd) || pList->pDirty==0 ); ÙH  /* If the file is a temp-file has not yet been opened, open it now. ItÙE  ** is not possible for rc to be other than SQLITE_OK if this branchÙA  ** is taken, as pager_wait_on_lock() is a no-op for temp-files.¤  */¼  if( !isOpen(pPager->fd) ){Ù0    assert( pPager->tempFile && rc==SQLITE_OK );Ù=    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);£  } ÙB  /* Before the first write, give the VFS a hint of what the final·  ** file size will be.¤  */Ù0  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );´  if( rc==SQLITE_OK Ù'   && pPager->dbHintSize<pPager->dbSizeÙ7   && (pList->pDirty || pList->pgno>pPager->dbHintSize)¤  ){ÙL    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;ÙJ    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);Ù(    pPager->dbHintSize = pPager->dbSize;£  } Ù"  while( rc==SQLITE_OK && pList ){¼    Pgno pgno = pList->pgno; ÙK    /* If there are dirty pages in the page cache with page numbers greaterÙN    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called toÙK    ** make the file smaller (presumably by auto-vacuum code). Do not writeÙ"    ** any such pages to the file.¦    **ÙI    ** Also, do not write out any page that has the PGHDR_DONT_WRITE flagÙ,    ** set (set by sqlite3PagerDontWrite()).¦    */ÙE    if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){ÙJ      i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */ÙL      char *pData;                                   /* Data to write */     Ù2      assert( (pList->flags&PGHDR_NEED_SYNC)==0 );Ù<      if( pList->pgno==1 ) pager_write_changecounter(pList); ¿      /* Encode the database */ÙM      CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM_BKPT, pData); Ù$      /* Write out the page data. */ÙG      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset); ÙE      /* If page 1 was just written, update Pager.dbFileVers to matchÙD      ** the value now stored in the database file. If writing this ÙC      ** page caused the database file to grow, update dbFileSize. ¨      */´      if( pgno==1 ){ÙL        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));§      }Ù$      if( pgno>pPager->dbFileSize ){Ù"        pPager->dbFileSize = pgno;§      }Ù(      pPager->aStat[PAGER_STAT_WRITE]++; ÙI      /* Update any backup objects copying the contents of this pager. */ÙD      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData); Ù2      PAGERTRACE(("STORE %d page %d hash(%08x)\n",ÙB                   PAGERID(pPager), pgno, pager_pagehash(pList)));Ù/      IOTRACE(("PGOUT %p %d\n", pPager, pgno));Ù.      PAGER_INCR(sqlite3_pager_writedb_count);ª    }else{ÙB      PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));¥    }¾    pager_set_pagehash(pList);º    pList = pList->pDirty;£  } ¬  return rc;¡} ¢/*ÙI** Ensure that the sub-journal file is open. If it is already open, this ·** function is a no-op.¢**ÙB** SQLITE_OK is returned if everything goes according to plan. An ÙH** SQLITE_IOERR_XXX error code is returned if a call to sqlite3OsOpen() ©** fails.¢*/Ù)static int openSubJournal(Pager *pPager){µ  int rc = SQLITE_OK;¾  if( !isOpen(pPager->sjfd) ){ÙF    const int flags =  SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_READWRITE Ù3      | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE Ù"      | SQLITE_OPEN_DELETEONCLOSE;Ù.    int nStmtSpill = sqlite3Config.nStmtSpill;ÙP    if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){¶      nStmtSpill = -1;¥    }ÙN    rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);£  }¬  return rc;¡} ¢/*ÙH** Append a record of the current state of page pPg to the sub-journal. ¢**ÙG** If successful, set the bit corresponding to pPg->pgno in the bitvecsÙ,** for all open savepoints before returning.¢**ÙE** This function returns SQLITE_OK if everything is successful, an IOÙC** error code if the attempt to write to the sub-journal fails, or ÙD** SQLITE_NOMEM if a malloc fails while setting a bit in a savepointª** bitvec.¢*/Ù&static int subjournalPage(PgHdr *pPg){µ  int rc = SQLITE_OK;¾  Pager *pPager = pPg->pPager;Ù3  if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){ ÙA    /* Open the sub-journal, if it has not already been opened */Ù!    assert( pPager->useJournal );Ù9    assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );Ù9    assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );Ù     assert( pagerUseWal(pPager) Ù'         || pageInJournal(pPager, pPg) Ù)         || pPg->pgno>pPager->dbOrigSize ¦    );Ù     rc = openSubJournal(pPager); ÙH    /* If the sub-journal was opened successfully (or was already open),Ù2    ** write the journal record into the file.  */¸    if( rc==SQLITE_OK ){¿      void *pData = pPg->pData;Ù=      i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);³      char *pData2; ·#if SQLITE_HAS_CODEC   Ù"      if( !pPager->subjInMemory ){ÙN        CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);«      }else¦#endifµ      pData2 = pData;ÙL      PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));Ù8      rc = write32bits(pPager->sjfd, offset, pPg->pgno);º      if( rc==SQLITE_OK ){ÙN        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);§      }¥    }£  }¶  if( rc==SQLITE_OK ){¶    pPager->nSubRec++;Ù#    assert( pPager->nSavepoint>0 );Ù2    rc = addToSavepointBitvecs(pPager, pPg->pgno);£  }¬  return rc;¡}Ù0static int subjournalPageIfRequired(PgHdr *pPg){¾  if( subjRequiresPage(pPg) ){¿    return subjournalPage(pPg);¨  }else{µ    return SQLITE_OK;£  }¡} ¢/*ÙG** This function is called by the pcache layer when it has reached someÙG** soft memory limit. The first argument is a pointer to a Pager objectÙG** (cast as a void*). The pager is always 'purgeable' (not an in-memoryÙC** database). The second argument is a reference to a page that is Ù>** currently dirty but has no outstanding references. The pageÙB** is always associated with the Pager object passed as the first ¬** argument.¢**ÙH** The job of this function is to make pPg clean by writing its contentsÙF** out to the database file, if possible. This may involve syncing the±** journal file. ¢**ÙD** If successful, sqlite3PcacheMakeClean() is called on the page andÙE** SQLITE_OK returned. If an IO error occurs while trying to make theÙC** page clean, the IO error code is returned. If the page cannot beÙH** made clean for some other reason, but no error occurs, then SQLITE_OKÙ9** is returned by sqlite3PcacheMakeClean() is not called.¢*/Ù,static int pagerStress(void *p, PgHdr *pPg){½  Pager *pPager = (Pager *)p;µ  int rc = SQLITE_OK; Ù   assert( pPg->pPager==pPager );Ù#  assert( pPg->flags&PGHDR_DIRTY ); ÙG  /* The doNotSpill NOSYNC bit is set during times when doing a sync ofÙC  ** journal (and adding a new header) is not allowed.  This occursÙI  ** during calls to sqlite3PagerWrite() while trying to journal multipleÙ(  ** pages belonging to the same sector.¤  **ÙE  ** The doNotSpill ROLLBACK and OFF bits inhibits all cache spillingÙI  ** regardless of whether or not a sync is required.  This is set duringÙ1  ** a rollback or by user request, respectively.¤  **ÙH  ** Spilling is also prohibited when in an error state since that couldÙE  ** lead to database corruption.   In the current implementation it ÙK  ** is impossible for sqlite3PcacheFetch() to be called with createFlag==3ÙI  ** while in the error state, hence it is impossible for this routine toÙF  ** be called in the error state.  Nevertheless, we include a NEVER()ÙD  ** test for the error state as a safeguard against future changes.¤  */Ù0  if( NEVER(pPager->errCode) ) return SQLITE_OK;Ù6  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );Ù1  testcase( pPager->doNotSpill & SPILLFLAG_OFF );Ù4  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );¸  if( pPager->doNotSpillÙC   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0Ù+      || (pPg->flags & PGHDR_NEED_SYNC)!=0)¤  ){µ    return SQLITE_OK;£  } Ù$  pPager->aStat[PAGER_STAT_SPILL]++;²  pPg->pDirty = 0;¼  if( pagerUseWal(pPager) ){Ù8    /* Write a single frame for this page to the log. */Ù(    rc = subjournalPageIfRequired(pPg); ¸    if( rc==SQLITE_OK ){Ù-      rc = pagerWalFrames(pPager, pPg, 0, 0);¥    }¨  }else{¤    Ù'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE¾    if( pPager->tempFile==0 ){Ù-      rc = sqlite3JournalCreate(pPager->jfd);Ù9      if( rc!=SQLITE_OK ) return pager_error(pPager, rc);¥    }¦#endif¢  Ù,    /* Sync the journal file if required. */Ù#    if( pPg->flags&PGHDR_NEED_SYNC Ù-     || pPager->eState==PAGER_WRITER_CACHEMOD¦    ){Ù"      rc = syncJournal(pPager, 1);¥    }¢  ÙB    /* Write the contents of the page out to the database file. */¸    if( rc==SQLITE_OK ){Ù0      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );Ù-      rc = pager_write_pagelist(pPager, pPg);¥    }£  } ¿  /* Mark the page as clean. */¶  if( rc==SQLITE_OK ){ÙD    PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));Ù     sqlite3PcacheMakeClean(pPg);£  } Ù"  return pager_error(pPager, rc); ¡} ¢/*Ù.** Flush all unreferenced dirty pages to disk.¢*/Ù4SQLITE_PRIVATE int sqlite3PagerFlush(Pager *pPager){»  int rc = pPager->errCode;¯  if( !MEMDB ){Ù;    PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);Ù)    assert( assert_pager_state(pPager) );Ù$    while( rc==SQLITE_OK && pList ){Ù#      PgHdr *pNext = pList->pDirty;»      if( pList->nRef==0 ){Ù/        rc = pagerStress((void*)pPager, pList);§      }´      pList = pNext;¥    }£  } ¬  return rc;¡} ¢/*ÙE** Allocate and initialize a new Pager object and put a pointer to itÙB** in *ppPager. The pager should eventually be freed by passing itº** to sqlite3PagerClose().¢**ÙC** The zFilename argument is the path to the database file to open.ÙG** If zFilename is NULL then a randomly-named temporary file is createdÙD** and used as the file to be cached. Temporary files are be deletedÙG** automatically when they are closed. If zFilename is ":memory:" then ÙB** all information is held in cache. It is never written to disk. Ù7** This can be used to implement an in-memory database.¢**ÙH** The nExtra parameter specifies the number of bytes of space allocatedÙF** along with each page reference. This space is available to the userÙI** via the sqlite3PagerGetExtra() API.  When a new page is allocated, theÙM** first 8 bytes of this space are zeroed but the remainder is uninitialized.Ù<** (The extra space is used by btree as the MemPage object.)¢**ÙC** The flags argument is used to specify properties that affect theÙG** operation of the pager. It should be passed some bitwise combination¸** of the PAGER_* flags.¢**ÙE** The vfsFlags parameter is a bitmask to pass to the flags parameterÙA** of the xOpen() method of the supplied VFS when opening files. ¢**ÙB** If the pager object is allocated and the specified file opened ÙC** successfully, SQLITE_OK is returned and *ppPager set to point toÙD** the new pager object. If an error occurs, *ppPager is set to NULLÙA** and error code returned. This function may return SQLITE_NOMEMÙD** (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or Ù ** various SQLITE_IO_XXX errors.¢*/Ù$SQLITE_PRIVATE int sqlite3PagerOpen(Ù?  sqlite3_vfs *pVfs,       /* The virtual file system to use */ÙE  Pager **ppPager,         /* OUT: Return the Pager structure here */ÙB  const char *zFilename,   /* Name of the database file to open */ÙJ  int nExtra,              /* Extra bytes append to each in-memory page */Ù<  int flags,               /* flags controlling this file */ÙL  int vfsFlags,            /* flags passed through to sqlite3_vfs.xOpen() */Ù?  void (*xReinit)(DbPage*) /* Function to reinitialize pages */¢){«  u8 *pPtr;ÙD  Pager *pPager = 0;       /* Pager object to allocate and return */Ù,  int rc = SQLITE_OK;      /* Return code */ÙL  int tempFile = 0;        /* True for temp files (incl. in-memory files) */ÙB  int memDb = 0;           /* True if this is an in-memory file */Ù #ifdef SQLITE_ENABLE_DESERIALIZEÙ4  int memJM = 0;           /* Memory journal mode */¥#else°# define memJM 0¦#endifÙA  int readOnly = 0;        /* True if this is a read-only file */ÙF  int journalFileSize;     /* Bytes to allocate for each journal fd */Ù;  char *zPathname = 0;     /* Full path to database file */Ù=  int nPathname = 0;       /* Number of bytes in zPathname */ÙO  int useJournal = (flags & PAGER_OMIT_JOURNAL)==0; /* False to omit journal */ÙP  int pcacheSize = sqlite3PcacheSize();       /* Bytes to allocate for PCache */ÙE  u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */Ù1  const char *zUri = 0;    /* URI args to copy */ÙE  int nUri = 0;            /* Number of bytes of URI args at *zUri */ ÙG  /* Figure out how much space is required for each journal file-handleÙG  ** (there are two of them, the main journal and the sub-journal).  */Ù5  journalFileSize = ROUND8(sqlite3JournalSize(pVfs)); Ù@  /* Set the output variable to NULL in case an error occurs. */¯  *ppPager = 0; ¼#ifndef SQLITE_OMIT_MEMORYDB½  if( flags & PAGER_MEMORY ){®    memDb = 1;Ù$    if( zFilename && zFilename[0] ){Ù0      zPathname = sqlite3DbStrDup(0, zFilename);Ù3      if( zPathname==0  ) return SQLITE_NOMEM_BKPT;Ù-      nPathname = sqlite3Strlen30(zPathname);´      zFilename = 0;¥    }£  }¦#endif ÙG  /* Compute and store the full pathname in an allocated buffer pointedÙH  ** to by zPathname, length nPathname. Or, if this is a temporary file,Ù1  ** leave both nPathname and zPathname set to 0.¤  */Ù"  if( zFilename && zFilename[0] ){²    const char *z;Ù#    nPathname = pVfs->mxPathname+1;Ù3    zPathname = sqlite3DbMallocRaw(0, nPathname*2);·    if( zPathname==0 ){¿      return SQLITE_NOMEM_BKPT;¥    }ÙN    zPathname[0] = 0; /* Make sure initialized even if FullPathname() fails */ÙF    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);Ù+    nPathname = sqlite3Strlen30(zPathname);Ù8    z = zUri = &zFilename[sqlite3Strlen30(zFilename)+1];°    while( *z ){Ù       z += sqlite3Strlen30(z)+1;Ù       z += sqlite3Strlen30(z)+1;¥    }¿    nUri = (int)(&z[1] - zUri);¶    assert( nUri>=0 );Ù8    if( rc==SQLITE_OK && nPathname+8>pVfs->mxPathname ){Ù?      /* This branch is taken when the journal path required byÙE      ** the database being opened will be more than pVfs->mxPathnameÙC      ** bytes in length. This means the database cannot be opened,ÙD      ** as it will not be possible to open the journal file or evenÙ0      ** check for a hot-journal before reading.¨      */Ù       rc = SQLITE_CANTOPEN_BKPT;¥    }¸    if( rc!=SQLITE_OK ){Ù"      sqlite3DbFree(0, zPathname);°      return rc;¥    }£  } Ù@  /* Allocate memory for the Pager structure, PCache object, theÙD  ** three file descriptors, the database file name and the journal Ù3  ** file name. The layout in memory is as follows:¤  **Ù>  **     Pager object                    (sizeof(Pager) bytes)ÙD  **     PCache object                   (sqlite3PcacheSize() bytes)Ù?  **     Database file handle            (pVfs->szOsFile bytes)Ù@  **     Sub-journal file handle         (journalFileSize bytes)Ù@  **     Main journal file handle        (journalFileSize bytes)Ù<  **     Database file name              (nPathname+1 bytes)Ù>  **     Journal file name               (nPathname+8+1 bytes)¤  */Ù!  pPtr = (u8 *)sqlite3MallocZero(Ù8    ROUND8(sizeof(*pPager)) +      /* Pager structure */Ù6    ROUND8(pcacheSize) +           /* PCache object */Ù9    ROUND8(pVfs->szOsFile) +       /* The main db file */Ù?    journalFileSize * 2 +          /* The two journal files */ Ù2    nPathname + 1 + nUri +         /* zFilename */Ù1    nPathname + 8 + 2              /* zJournal */·#ifndef SQLITE_OMIT_WALÙ-    + nPathname + 4 + 2            /* zWal */¦#endif¤  );ÙE  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) );®  if( !pPtr ){Ù     sqlite3DbFree(0, zPathname);½    return SQLITE_NOMEM_BKPT;£  }Ù'  pPager =              (Pager*)(pPtr);ÙB  pPager->pPCache =    (PCache*)(pPtr += ROUND8(sizeof(*pPager)));Ù=  pPager->fd =   (sqlite3_file*)(pPtr += ROUND8(pcacheSize));ÙA  pPager->sjfd = (sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));Ù:  pPager->jfd =  (sqlite3_file*)(pPtr += journalFileSize);Ù:  pPager->zFilename =    (char*)(pPtr += journalFileSize);Ù.  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) ); ÙL  /* Fill in the Pager.zFilename and Pager.zJournal buffers, if required. */²  if( zPathname ){º    assert( nPathname>0 );Ù?    pPager->zJournal =   (char*)(pPtr += nPathname + 1 + nUri);Ù4    memcpy(pPager->zFilename, zPathname, nPathname);ÙC    if( nUri ) memcpy(&pPager->zFilename[nPathname+1], zUri, nUri);Ù3    memcpy(pPager->zJournal, zPathname, nPathname);Ù>    memcpy(&pPager->zJournal[nPathname], "-journal\000", 8+2);Ù<    sqlite3FileSuffix3(pPager->zFilename, pPager->zJournal);·#ifndef SQLITE_OMIT_WALÙ4    pPager->zWal = &pPager->zJournal[nPathname+8+1];Ù/    memcpy(pPager->zWal, zPathname, nPathname);Ù6    memcpy(&pPager->zWal[nPathname], "-wal\000", 4+1);Ù8    sqlite3FileSuffix3(pPager->zFilename, pPager->zWal);¦#endifÙ     sqlite3DbFree(0, zPathname);£  }¶  pPager->pVfs = pVfs;¾  pPager->vfsFlags = vfsFlags; ¹  /* Open the pager file.¤  */Ù"  if( zFilename && zFilename[0] ){ÙH    int fout = 0;                    /* VFS flags returned by xOpen() */ÙM    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);µ    assert( !memDb );Ù #ifdef SQLITE_ENABLE_DESERIALIZEÙ)    memJM = (fout&SQLITE_OPEN_MEMORY)!=0;¦#endifÙ.    readOnly = (fout&SQLITE_OPEN_READONLY)!=0; ÙA    /* If the file was successfully opened for read/write access,Ù?    ** choose a default page size in case we have to create theÙ>    ** database file. The default page size is the maximum of:¦    **Ù%    **    + SQLITE_DEFAULT_PAGE_SIZE,Ù7    **    + The value returned by sqlite3OsSectorSize()ÙA    **    + The largest page size that can be written atomically.¦    */¸    if( rc==SQLITE_OK ){Ù;      int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);¶      if( !readOnly ){¾        setSectorSize(pPager);ÙG        assert(SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE);Ù,        if( szPageDflt<pPager->sectorSize ){Ù@          if( pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE ){Ù6            szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;°          }else{Ù1            szPageDflt = (u32)pPager->sectorSize;«          }©        }Ù!#ifdef SQLITE_ENABLE_ATOMIC_WRITE©        {±          int ii;Ù3          assert(SQLITE_IOCAP_ATOMIC512==(512>>8));Ù5          assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));Ù6          assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);ÙH          for(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){Ù4            if( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ){¾              szPageDflt = ii;­            }«          }©        }¦#endif§      }ÙC      pPager->noLock = sqlite3_uri_boolean(zFilename, "nolock", 0);Ù+      if( (iDc & SQLITE_IOCAP_IMMUTABLE)!=0Ù;       || sqlite3_uri_boolean(zFilename, "immutable", 0) ){Ù+          vfsFlags |= SQLITE_OPEN_READONLY;Ù"          goto act_like_temp_file;§      }¥    }¨  }else{ÙF    /* If a temporary file is requested, it is not opened immediately.ÙF    ** In this case we accept the default page size and delay actuallyÙ:    ** opening the file until the first call to OsWrite().¦    **ÙF    ** This branch is also run for an in-memory database. An in-memoryÙG    ** database is the same as a temp-file that is never written out toÙ3    ** disk and uses an in-memory rollback journal.¦    **Ù;    ** This branch also runs for files marked as immutable.§    */ ³act_like_temp_file:±    tempFile = 1;ÙK    pPager->eState = PAGER_READER;     /* Pretend we already have a lock */ÙM    pPager->eLock = EXCLUSIVE_LOCK;    /* Pretend we are in EXCLUSIVE mode */Ù:    pPager->noLock = 1;                /* Do no locking */Ù/    readOnly = (vfsFlags&SQLITE_OPEN_READONLY);£  } ÙI  /* The following call to PagerSetPagesize() serves to set the value of Ù?  ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.¤  */¶  if( rc==SQLITE_OK ){¿    assert( pPager->memDb==0 );Ù:    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);¾    testcase( rc!=SQLITE_OK );£  } Ù%  /* Initialize the PCache object. */¶  if( rc==SQLITE_OK ){¼    nExtra = ROUND8(nExtra);Ù'    assert( nExtra>=8 && nExtra<1000 );Ù6    rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,ÙN                       !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);£  } ÙN  /* If an error occurred above, free the  Pager structure and close the file.¤  */¶  if( rc!=SQLITE_OK ){¿    sqlite3OsClose(pPager->fd);Ù'    sqlite3PageFree(pPager->pTmpSpace);¹    sqlite3_free(pPager);®    return rc;£  } ÙL  PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));Ù6  IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename)) Ù&  pPager->useJournal = (u8)useJournal;½  /* pPager->stmtOpen = 0; */¾  /* pPager->stmtInUse = 0; */¹  /* pPager->nRef = 0; */½  /* pPager->stmtSize = 0; */¾  /* pPager->stmtJSize = 0; */º  /* pPager->nPage = 0; */Ù)  pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;Ù%  /* pPager->state = PAGER_UNLOCK; */¼  /* pPager->errMask = 0; */Ù"  pPager->tempFile = (u8)tempFile;Ù-  assert( tempFile==PAGER_LOCKINGMODE_NORMAL Ù5          || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE );Ù+  assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );Ù(  pPager->exclusiveMode = (u8)tempFile; Ù-  pPager->changeCountDone = pPager->tempFile;¼  pPager->memDb = (u8)memDb;Ù"  pPager->readOnly = (u8)readOnly;Ù+  assert( useJournal || pPager->tempFile );Ù$  pPager->noSync = pPager->tempFile;·  if( pPager->noSync ){Ù"    assert( pPager->fullSync==0 );Ù#    assert( pPager->extraSync==0 );Ù#    assert( pPager->syncFlags==0 );Ù&    assert( pPager->walSyncFlags==0 );¨  }else{¹    pPager->fullSync = 1;º    pPager->extraSync = 0;Ù+    pPager->syncFlags = SQLITE_SYNC_NORMAL;ÙH    pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);£  }»  /* pPager->pFirst = 0; */Ù!  /* pPager->pFirstSynced = 0; */º  /* pPager->pLast = 0; */¿  pPager->nExtra = (u16)nExtra;Ù?  pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;Ù+  assert( isOpen(pPager->fd) || tempFile );¸  setSectorSize(pPager);´  if( !useJournal ){Ù0    pPager->journalMode = PAGER_JOURNALMODE_OFF;½  }else if( memDb || memJM ){Ù3    pPager->journalMode = PAGER_JOURNALMODE_MEMORY;£  }Ù!  /* pPager->xBusyHandler = 0; */Ù$  /* pPager->pBusyHandlerArg = 0; */¾  pPager->xReiniter = xReinit;º  setGetterMethod(pPager);Ù8  /* memset(pPager->aHash, 0, sizeof(pPager->aHash)); */ÙK  /* pPager->szMmap = SQLITE_DEFAULT_MMAP_SIZE // will be set by btree.c */ ´  *ppPager = pPager;³  return SQLITE_OK;¡}   ¢/*ÙC** This function is called after transitioning from PAGER_UNLOCK toÙD** PAGER_SHARED state. It tests if there is a hot journal present inÙB** the file-system for the given pager. A hot journal is one that ÙE** needs to be played back. According to this function, a hot-journalÙ1** file exists if the following criteria are met:¢**Ù6**   * The journal file exists in the file system, andÙL**   * No process holds a RESERVED or greater lock on the database file, andÙD**   * The database file itself is greater than 0 bytes in size, andÙA**   * The first byte of the journal file exists and is not 0x00.¢**ÙC** If the current size of the database file is 0 but a journal fileÙA** exists, that is probably an old journal left over from a priorÙ@** database with the same name. In this case the journal file isÙB** just deleted using OsDelete, *pExists is set to 0 and SQLITE_OK¯** is returned.¢**ÙD** This routine does not check if there is a master journal filenameÙD** at the end of the file. If there is, and that master journal fileÙC** does not exist, then the journal file is not really hot. In thisÙG** case this routine will return a false-positive. The pager_playback()ÙE** routine will discover that the journal file is not really hot and º** will not roll it back. ¢**ÙE** If a hot-journal file is found to exist, *pExists is set to 1 and ÙE** SQLITE_OK returned. If no hot-journal file is present, *pExists isÙF** set to 0 and SQLITE_OK returned. If an IO error occurs while tryingÙF** to determine whether or not a hot-journal file exists, the IO errorÙ;** code is returned and the value of *pExists is undefined.¢*/Ù6static int hasHotJournal(Pager *pPager, int *pExists){Ù*  sqlite3_vfs * const pVfs = pPager->pVfs;Ù1  int rc = SQLITE_OK;           /* Return code */ÙG  int exists = 1;               /* True if a journal file is present */Ù'  int jrnlOpen = !!isOpen(pPager->jfd); ¿  assert( pPager->useJournal );¿  assert( isOpen(pPager->fd) );Ù'  assert( pPager->eState==PAGER_OPEN ); ÙH  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &Ù&    SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN¥  )); ¯  *pExists = 0;²  if( !jrnlOpen ){ÙP    rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);£  }Ù   if( rc==SQLITE_OK && exists ){ÙP    int locked = 0;             /* True if some process holds a RESERVED lock */ ÙH    /* Race condition here:  Another process might have been holding theÙJ    ** the RESERVED lock and have a journal open at the sqlite3OsAccess() ÙG    ** call above, but then delete the journal and drop the lock beforeÙJ    ** we get to the following sqlite3OsCheckReservedLock() call.  If thatÙH    ** is the case, this routine might think there is a hot journal whenÙJ    ** in fact there is none.  This results in a false-positive which willÙ<    ** be dealt with by the playback routine.  Ticket #3883.¦    */Ù9    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);Ù#    if( rc==SQLITE_OK && !locked ){ÙH      Pgno nPage;                 /* Number of pages in database file */ Ù$      assert( pPager->tempFile==0 );Ù*      rc = pagerPagecount(pPager, &nPage);º      if( rc==SQLITE_OK ){ÙP        /* If the database is zero pages in size, that means that either (1) theÙN        ** journal is a remnant from a prior database with the same name whereÙP        ** the database file but not the journal was deleted, or (2) the initialÙJ        ** transaction that populates a new database is being rolled back.ÙO        ** In either case, the journal file can be deleted.  However, take careÙF        ** not to delete the journal file if it is already open due toÙ         ** journal_mode=PERSIST.ª        */Ù$        if( nPage==0 && !jrnlOpen ){Ù%          sqlite3BeginBenignMalloc();Ù>          if( pagerLockDb(pPager, RESERVED_LOCK)==SQLITE_OK ){Ù7            sqlite3OsDelete(pVfs, pPager->zJournal, 0);ÙL            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);«          }Ù#          sqlite3EndBenignMalloc();®        }else{ÙK          /* The journal file exists and no other connection has a reservedÙJ          ** or greater lock on the database file. Now check that there isÙJ          ** at least one non-zero bytes at the start of the journal file.ÙK          ** If there is, then we consider this journal to be hot. If not, ¿          ** it can be ignored.¬          */º          if( !jrnlOpen ){ÙB            int f = SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL;ÙK            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);«          }¾          if( rc==SQLITE_OK ){¹            u8 first = 0;ÙB            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);Ù.            if( rc==SQLITE_IOERR_SHORT_READ ){½              rc = SQLITE_OK;­            }¼            if( !jrnlOpen ){Ù*              sqlite3OsClose(pPager->jfd);­            }Ù"            *pExists = (first!=0);Ù*          }else if( rc==SQLITE_CANTOPEN ){ÙM            /* If we cannot open the rollback journal file in order to see ifÙJ            ** it has a zero header, that might be due to an I/O error, orÙK            ** it might be due to the race condition described above and inÙI            ** ticket #3883.  Either way, assume that the journal is hot.ÙF            ** This might be a false positive.  But if it is, then theÙJ            ** automatic journal playback and recovery mechanism will dealÙF            ** with it under an EXCLUSIVE lock where we do not need toÙ2            ** worry so much with race conditions.®            */¹            *pExists = 1;»            rc = SQLITE_OK;«          }©        }§      }¥    }£  } ¬  return rc;¡} ¢/*ÙH** This function is called to obtain a shared lock on the database file.ÙD** It is illegal to call sqlite3PagerGet() until after this functionÙF** has been successfully called. If a shared-lock is already held whenÙ*** this function is called, it is a no-op.¢**Ù@** The following operations are also performed by this function.¢**ÙC**   1) If the pager is currently in PAGER_OPEN state (no lock heldÙB**      on the database file), then an attempt is made to obtain aÙE**      SHARED lock on the database file. Immediately after obtainingÙF**      the SHARED lock, the file-system is checked for a hot-journal,ÙC**      which is played back if present. Following any hot-journal ÙE**      rollback, the contents of the cache are validated by checkingÙB**      the 'change-counter' field of the database file header andÙ2**      discarded if they are found to be invalid.¢**ÙJ**   2) If the pager is running in exclusive-mode, and there are currentlyÙJ**      no outstanding references to any pages, and is in the error state,ÙF**      then an attempt is made to clear the error state by discardingÙH**      the contents of the page cache and rolling back any open journal­**      file.¢**ÙF** If everything is successful, SQLITE_OK is returned. If an IO error ÙI** occurs while locking the database, checking for a hot-journal file or Ù>** rolling back a journal file, the IO error code is returned.¢*/Ù9SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){Ù6  int rc = SQLITE_OK;                /* Return code */ ÙG  /* This routine is only called from b-tree and only when there are noÙG  ** outstanding pages. This implies that the pager state should eitherÙJ  ** be OPEN or READER. READER is only possible if the pager is or was in ¿  ** exclusive access mode.  */Ù6  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );Ù'  assert( assert_pager_state(pPager) );ÙG  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );Ù'  assert( pPager->errCode==SQLITE_OK ); Ù;  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){ÙO    int bHotJournal = 1;          /* True if there exists a hot journal-file */ µ    assert( !MEMDB );ÙC    assert( pPager->tempFile==0 || pPager->eLock==EXCLUSIVE_LOCK ); Ù1    rc = pager_wait_on_lock(pPager, SHARED_LOCK);¸    if( rc!=SQLITE_OK ){ÙF      assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );²      goto failed;¥    } ÙE    /* If a journal file exists, and there is no RESERVED lock on theÙH    ** database file, then it either needs to be played back or deleted.¦    */Ù%    if( pPager->eLock<=SHARED_LOCK ){Ù/      rc = hasHotJournal(pPager, &bHotJournal);¥    }¸    if( rc!=SQLITE_OK ){²      goto failed;¥    }¶    if( bHotJournal ){½      if( pPager->readOnly ){Ù&        rc = SQLITE_READONLY_ROLLBACK;´        goto failed;§      } ÙH      /* Get an EXCLUSIVE lock on the database file. At this point it isÙI      ** important that a RESERVED lock is not obtained on the way to theÙC      ** EXCLUSIVE lock. If it were, another process might open theÙG      ** database file, detect the RESERVED lock, and conclude that theÙJ      ** database is safe to read while this process is still rolling the º      ** hot-journal back.©      ** ÙE      ** Because the intermediate RESERVED lock is not requested, anyÙJ      ** other process attempting to access the database file will get to ÙJ      ** this point in the code and fail to obtain its own EXCLUSIVE lock ¾      ** on the database file.¨      **ÙH      ** Unless the pager is in locking_mode=exclusive mode, the lock isÙ@      ** downgraded to SHARED_LOCK before this function returns.¨      */Ù/      rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);º      if( rc!=SQLITE_OK ){´        goto failed;§      }¡ ÙI      /* If it is not already open and the file exists on disk, open the ÙI      ** journal for read/write access. Write access is required because ÙH      ** in exclusive-access mode the file descriptor will be kept open ÙJ      ** and possibly used for a transaction later on. Also, write-access ÙM      ** is usually required to finalize the journal in journal_mode=persist ÙC      ** mode (and also for journal_mode=truncate on some systems).¨      **ÙC      ** If the journal does not exist, it usually means that some ÙD      ** other connection managed to get in and roll it back before ÙC      ** this connection obtained the exclusive lock above. Or, it ÙA      ** may mean that the pager was in the error-state when thisÙA      ** function was called and the journal file does not exist.¨      */Ù!      if( !isOpen(pPager->jfd) ){Ù0        sqlite3_vfs * const pVfs = pPager->pVfs;ÙC        int bExists;              /* True if journal file exists */½        rc = sqlite3OsAccess(ÙD            pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);Ù'        if( rc==SQLITE_OK && bExists ){·          int fout = 0;ÙA          int f = SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_JOURNAL;Ù&          assert( !pPager->tempFile );ÙL          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);Ù9          assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );Ù;          if( rc==SQLITE_OK && fout&SQLITE_OPEN_READONLY ){Ù&            rc = SQLITE_CANTOPEN_BKPT;Ù(            sqlite3OsClose(pPager->jfd);«          }©        }§      }¡ ÙB      /* Playback and delete the journal.  Drop the database writeÙA      ** lock and reacquire the read lock. Purge the cache beforeÙB      ** playing back the hot-journal so that we don't end up withÙD      ** an inconsistent cache.  Sync the hot journal before playingÙH      ** it back since the process that crashed and left the hot journalÙD      ** probably did not sync it and we are required to always syncÙ,      ** the journal before playing it back.¨      */Ù       if( isOpen(pPager->jfd) ){Ù         assert( rc==SQLITE_OK );Ù)        rc = pagerSyncHotJournal(pPager);¼        if( rc==SQLITE_OK ){Ù9          rc = pager_playback(pPager, !pPager->tempFile);Ù&          pPager->eState = PAGER_OPEN;©        }Ù)      }else if( !pPager->exclusiveMode ){Ù+        pagerUnlockDb(pPager, SHARED_LOCK);§      } º      if( rc!=SQLITE_OK ){ÙG        /* This branch is taken if an error occurs while trying to openÙJ        ** or roll back a hot-journal while holding an EXCLUSIVE lock. TheÙK        ** pager_unlock() routine will be called before returning to unlockÙJ        ** the file. If the unlock attempt fails, then Pager.eLock must beÙF        ** set to UNKNOWN_LOCK (see the comment above the #define for Ù3        ** UNKNOWN_LOCK above for an explanation). ª        **ÙI        ** In order to get pager_unlock() to do this, set Pager.eState toÙH        ** PAGER_ERROR now. This is not actually counted as a transitionÙG        ** to ERROR state in the state diagram at the top of this file,ÙG        ** since we know that the same call to pager_unlock() will veryÙI        ** shortly transition the pager object to the OPEN state. CallingÙL        ** assert_pager_state() would fail now, as it should not be possibleÙE        ** to be in ERROR state when there are zero outstanding page ¶        ** references.ª        */Ù         pager_error(pPager, rc);´        goto failed;§      } Ù+      assert( pPager->eState==PAGER_OPEN );Ù*      assert( (pPager->eLock==SHARED_LOCK)ÙB           || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)¨      );¥    } Ù9    if( !pPager->tempFile && pPager->hasHeldSharedLock ){Ù=      /* The shared-lock has just been acquired then check toÙM      ** see if the database has been modified.  If the database has changed,ÙH      ** flush the cache.  The hasHeldSharedLock flag prevents this fromÙI      ** occurring on the very first access to a file, in order to save aÙA      ** single unnecessary sqlite3OsRead() call at the start-up.¨      **ÙG      ** Database changes are detected by looking at 15 bytes beginningÙG      ** at offset 24 into the file.  The first 4 of these 16 bytes areÙD      ** a 32-bit counter that is incremented with each change.  TheÙ?      ** other bytes change randomly with each file change when»      ** a codec is in use.©      ** ÙG      ** There is a vanishingly small chance that a change will not be ÙG      ** detected.  The chance of an undetected change is so small that½      ** it can be neglected.¨      */Ù2      char dbFileVers[sizeof(pPager->dbFileVers)]; Ù>      IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));ÙJ      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);º      if( rc!=SQLITE_OK ){Ù*        if( rc!=SQLITE_IOERR_SHORT_READ ){¶          goto failed;©        }Ù2        memset(dbFileVers, 0, sizeof(dbFileVers));§      } ÙJ      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){¼        pager_reset(pPager); ÙJ        /* Unmap the database file. It is possible that external processesÙI        ** may have truncated the database file and then extended it backÙJ        ** to its original size while this process was not holding a lock.ÙI        ** In this case there may exist a Pager.pMap mapping that appearsÙE        ** to be the right size but is not actually valid. Avoid thisÙ3        ** possibility by unmapping the db here. */¿        if( USEFETCH(pPager) ){Ù-          sqlite3OsUnfetch(pPager->fd, 0, 0);©        }§      }¥    } ÙK    /* If there is a WAL file in the file-system, open this database in WALÙ?    ** mode. Otherwise, the following function call is a no-op.¦    */Ù'    rc = pagerOpenWalIfPresent(pPager);·#ifndef SQLITE_OMIT_WALÙ/    assert( pPager->pWal==0 || rc==SQLITE_OK );¦#endif£  } ¼  if( pagerUseWal(pPager) ){¼    assert( rc==SQLITE_OK );Ù+    rc = pagerBeginReadTransaction(pPager);£  } ÙK  if( pPager->tempFile==0 && pPager->eState==PAGER_OPEN && rc==SQLITE_OK ){Ù1    rc = pagerPagecount(pPager, &pPager->dbSize);£  } ¨ failed:¶  if( rc!=SQLITE_OK ){µ    assert( !MEMDB );¹    pager_unlock(pPager);Ù)    assert( pPager->eState==PAGER_OPEN );¨  }else{Ù"    pPager->eState = PAGER_READER;Ù"    pPager->hasHeldSharedLock = 1;£  }¬  return rc;¡} ¢/*Ù?** If the reference count has reached zero, rollback any activeÙ$** transaction and unlock the pager.¢**Ù@** Except, in locking_mode=EXCLUSIVE when there is nothing to inÙA** the rollback journal, the unlock is not performed and there isÙ3** nothing to rollback, so this routine is a no-op.£*/ Ù/static void pagerUnlockIfUnused(Pager *pPager){Ù2  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){ÙM    assert( pPager->nMmapOut==0 ); /* because page1 is never memory mapped */Ù#    pagerUnlockAndRollback(pPager);£  }¡} ¢/*Ù?** The page getter methods each try to acquire a reference to aÙ=** page with page number pgno. If the requested reference is ÙI** successfully obtained, it is copied to *ppPage and SQLITE_OK returned.¢**ÙE** There are different implementations of the getter method dependingÙ%** on the current state of the pager.¢**Ù4**     getPageNormal()         --  The normal getterÙI**     getPageError()          --  Used if the pager is in an error stateÙG**     getPageMmap()           --  Used if memory-mapped I/O is enabled¢**ÙB** If the requested page is already in the cache, it is returned. ÙD** Otherwise, a new page object is allocated and populated with dataÙD** read from the database file. In some cases, the pcache module mayÙE** choose not to allocate a new page object and may reuse an existingÙ)** object with no outstanding references.¢**ÙH** The extra data appended to a page is always initialized to zeros the ÙE** first time a page is loaded into memory. If the page requested is ÙD** already in the cache when this function is called, then the extraÙ=** data is left as it was when the page object was last used.¢**ÙB** If the database image is smaller than the requested page or if ÙD** the flags parameter contains the PAGER_GET_NOCONTENT bit and the Ù>** requested page is not already stored in the cache, then no ÙA** actual disk read occurs. In this case the memory image of the Ù%** page is initialized to all zeros. ¢**ÙE** If PAGER_GET_NOCONTENT is true, it means that we do not care aboutÙ:** the contents of the page. This occurs in two scenarios:¢**ÙA**   a) When reading a free-list leaf page from the database, and¢**ÙA**   b) When a savepoint is being rolled back and we need to loadÙA**      a new page into the cache to be filled with the data readÙ#**      from the savepoint journal.¢**ÙK** If PAGER_GET_NOCONTENT is true, then the data returned is zeroed insteadÙH** of being read from the database. Additionally, the bits correspondingÙF** to pgno in Pager.pInJournal (bitvec of pages already written to theÙH** journal file) and the PagerSavepoint.pInSavepoint bitvecs of any openÙE** savepoints are set. This means if the page is made writable at anyÙI** point in the future, using a call to sqlite3PagerWrite(), its contentsÙ(** will not be journaled. This saves IO.¢**ÙA** The acquisition might fail for several reasons.  In all cases,ÙD** an appropriate error code is returned and *ppPage is set to NULL.¢**ÙI** See also sqlite3PagerLookup().  Both this routine and Lookup() attemptÙK** to find a page in the in-memory cache first.  If the page is not alreadyÙF** in memory, this routine goes to disk to read it in whereas Lookup()ÙG** just returns 0.  This routine acquires a read-lock the first time itÙJ** has to go to disk, and could also playback an old journal if necessary.ÙE** Since Lookup() never goes to disk, it never has to deal with locks´** or journal files.¢*/¹static int getPageNormal(Ù?  Pager *pPager,      /* The pager open on the database file */Ù0  Pgno pgno,          /* Page number to fetch */Ù<  DbPage **ppPage,    /* Write a pointer to the page here */Ù/  int flags           /* PAGER_GET_XXX flags */¢){µ  int rc = SQLITE_OK;­  PgHdr *pPg;ÙJ  u8 noContent;                   /* True if PAGER_GET_NOCONTENT is set */½  sqlite3_pcache_page *pBase; Ù'  assert( pPager->errCode==SQLITE_OK );Ù)  assert( pPager->eState>=PAGER_READER );Ù'  assert( assert_pager_state(pPager) );Ù)  assert( pPager->hasHeldSharedLock==1 ); Ù+  if( pgno==0 ) return SQLITE_CORRUPT_BKPT;Ù7  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);±  if( pBase==0 ){¬    pPg = 0;ÙA    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);Ù/    if( rc!=SQLITE_OK ) goto pager_acquire_err;³    if( pBase==0 ){½      rc = SQLITE_NOMEM_BKPT;½      goto pager_acquire_err;¥    }£  }ÙI  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);»  assert( pPg==(*ppPage) );¼  assert( pPg->pgno==pgno );Ù2  assert( pPg->pPager==pPager || pPg->pPager==0 ); Ù/  noContent = (flags & PAGER_GET_NOCONTENT)!=0;Ù"  if( pPg->pPager && !noContent ){ÙF    /* In this case the pcache already contains an initialized copy ofÙ0    ** the page. Return without further ado.  */ÙB    assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );Ù$    pPager->aStat[PAGER_STAT_HIT]++;µ    return SQLITE_OK; ¨  }else{ÙD    /* The pager cache has created a new page. Its content needs to Ù3    ** be initialized. But first some error checks:¦    **Ù*    ** (1) The maximum page number is 2^31Ù.    ** (2) Never try to fetch the locking page¦    */Ù=    if( pgno>PAGER_MAX_PGNO || pgno==PAGER_MJ_PGNO(pPager) ){¿      rc = SQLITE_CORRUPT_BKPT;½      goto pager_acquire_err;¥    } ¹    pPg->pPager = pPager; Ù,    assert( !isOpen(pPager->fd) || !MEMDB );ÙB    if( !isOpen(pPager->fd) || pPager->dbSize<pgno || noContent ){Ù       if( pgno>pPager->mxPgno ){¹        rc = SQLITE_FULL;¿        goto pager_acquire_err;§      }¶      if( noContent ){ÙJ        /* Failure to set the bits in the InJournal bit-vectors is benign.ÙI        ** It merely means that we might do some extra work to journal a ÙK        ** page that does not need to be journaled.  Nevertheless, be sure ÙL        ** to test the case where a malloc error occurs while trying to set Ù!        ** a bit in a bit vector.ª        */Ù#        sqlite3BeginBenignMalloc();Ù'        if( pgno<=pPager->dbOrigSize ){ÙF          TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);Ù'          testcase( rc==SQLITE_NOMEM );©        }Ù=        TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);Ù%        testcase( rc==SQLITE_NOMEM );Ù!        sqlite3EndBenignMalloc();§      }Ù.      memset(pPg->pData, 0, pPager->pageSize);Ù.      IOTRACE(("ZERO %p %d\n", pPager, pgno));ª    }else{Ù$      assert( pPg->pPager==pPager );Ù'      pPager->aStat[PAGER_STAT_MISS]++;»      rc = readDbPage(pPg);º      if( rc!=SQLITE_OK ){¿        goto pager_acquire_err;§      }¥    }¼    pager_set_pagehash(pPg);£  }³  return SQLITE_OK; ²pager_acquire_err:º  assert( rc!=SQLITE_OK );¬  if( pPg ){»    sqlite3PcacheDrop(pPg);£  }¾  pagerUnlockIfUnused(pPager);®  *ppPage = 0;¬  return rc;¡} º#if SQLITE_MAX_MMAP_SIZE>0Ù;/* The page getter for when memory-mapped I/O is enabled */·static int getPageMMap(Ù?  Pager *pPager,      /* The pager open on the database file */Ù0  Pgno pgno,          /* Page number to fetch */Ù<  DbPage **ppPage,    /* Write a pointer to the page here */Ù/  int flags           /* PAGER_GET_XXX flags */¢){µ  int rc = SQLITE_OK;±  PgHdr *pPg = 0;ÙC  u32 iFrame = 0;                 /* Frame to read from WAL file */ ÙH  /* It is acceptable to use a read-only (mmap) page for any page exceptÙI  ** page 1 if there is no write-transaction open or the ACQUIRE_READONLYÙF  ** flag was specified by the caller. And so long as the db is not a Ù)  ** temporary or in-memory database.  */½  const int bMmapOk = (pgno>1ÙD   && (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))¤  ); ½  assert( USEFETCH(pPager) );·#ifdef SQLITE_HAS_CODEC¾  assert( pPager->xCodec==0 );¦#endif ÙH  /* Optimization note:  Adding the "pgno<=1" term before "pgno==0" hereÙG  ** allows the compiler optimizer to reuse the results of the "pgno>1"ÙE  ** test in the previous statement, and avoid testing pgno==0 in theÙ(  ** common case where pgno is large. */»  if( pgno<=1 && pgno==0 ){¿    return SQLITE_CORRUPT_BKPT;£  }Ù)  assert( pPager->eState>=PAGER_READER );Ù'  assert( assert_pager_state(pPager) );Ù)  assert( pPager->hasHeldSharedLock==1 );Ù'  assert( pPager->errCode==SQLITE_OK ); Ù'  if( bMmapOk && pagerUseWal(pPager) ){Ù:    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);¸    if( rc!=SQLITE_OK ){²      *ppPage = 0;°      return rc;¥    }£  }½  if( bMmapOk && iFrame==0 ){´    void *pData = 0;Ù$    rc = sqlite3OsFetch(pPager->fd, ÙB        (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData¦    );Ù!    if( rc==SQLITE_OK && pData ){Ù<      if( pPager->eState>PAGER_READER || pPager->tempFile ){Ù/        pPg = sqlite3PagerLookup(pPager, pgno);§      }³      if( pPg==0 ){Ù<        rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);¬      }else{ÙL        sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);§      }°      if( pPg ){Ù         assert( rc==SQLITE_OK );¶        *ppPage = pPg;¹        return SQLITE_OK;§      }¥    }¸    if( rc!=SQLITE_OK ){²      *ppPage = 0;°      return rc;¥    }£  }Ù4  return getPageNormal(pPager, pgno, ppPage, flags);¡}Ù##endif /* SQLITE_MAX_MMAP_SIZE>0 */ ÙA/* The page getter method for when the pager is an error state */¸static int getPageError(Ù?  Pager *pPager,      /* The pager open on the database file */Ù0  Pgno pgno,          /* Page number to fetch */Ù<  DbPage **ppPage,    /* Write a pointer to the page here */Ù/  int flags           /* PAGER_GET_XXX flags */¢){¹  UNUSED_PARAMETER(pgno);º  UNUSED_PARAMETER(flags);Ù'  assert( pPager->errCode!=SQLITE_OK );®  *ppPage = 0;¹  return pPager->errCode;¡}  ÙE/* Dispatch all page fetch requests to the appropriate getter method.¢*/Ù#SQLITE_PRIVATE int sqlite3PagerGet(Ù?  Pager *pPager,      /* The pager open on the database file */Ù0  Pgno pgno,          /* Page number to fetch */Ù<  DbPage **ppPage,    /* Write a pointer to the page here */Ù/  int flags           /* PAGER_GET_XXX flags */¢){Ù3  return pPager->xGet(pPager, pgno, ppPage, flags);¡} ¢/*Ù>** Acquire a page if it is already in the in-memory cache.  DoÙ>** not read the page from disk.  Return a pointer to the page,Ù%** or 0 if the page is not in cache. ¢**ÙC** See also sqlite3PagerGet().  The difference between this routineÙD** and sqlite3PagerGet() is that _get() will go to the disk and readÙA** in the page if the page is not already in cache.  This routineÙC** returns NULL if the page is not in cache or if a disk I/O error µ** has ever happened.¢*/ÙDSQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){½  sqlite3_pcache_page *pPage;¶  assert( pPager!=0 );´  assert( pgno!=0 );¿  assert( pPager->pPCache!=0 );Ù7  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);Ù2  assert( pPage==0 || pPager->hasHeldSharedLock );º  if( pPage==0 ) return 0;Ù@  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);¡} ¢/*¼** Release a page reference.¢**ÙE** The sqlite3PagerUnref() and sqlite3PagerUnrefNotNull() may only beÙE** used if we know that the page being released is not the last page.ÙH** The btree layer always holds page1 open until the end, so these firstÙJ** to routines can be used to release any page other than BtShared.pPage1.¢**ÙH** Use sqlite3PagerUnrefPageOne() to release page1.  This latter routineÙD** checks the total number of outstanding pages and if the number ofÙ1** pages reaches zero it drops the database lock.¢*/Ù:SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage *pPg){Ù*  TESTONLY( Pager *pPager = pPg->pPager; )³  assert( pPg!=0 );Ù   if( pPg->flags & PGHDR_MMAP ){Ù?    assert( pPg->pgno!=1 );  /* Page1 is never memory mapped */½    pagerReleaseMapPage(pPg);¨  }else{¾    sqlite3PcacheRelease(pPg);£  }ÙF  /* Do not use this routine to release the last reference to page1 */Ù5  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );¡}Ù3SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){Ù*  if( pPg ) sqlite3PagerUnrefNotNull(pPg);¡}Ù:SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage *pPg){°  Pager *pPager;³  assert( pPg!=0 );¹  assert( pPg->pgno==1 );ÙL  assert( (pPg->flags & PGHDR_MMAP)==0 ); /* Page1 is never memory mapped */·  pPager = pPg->pPager;Ù'  sqlite3PagerResetLockTimeout(pPager);¼  sqlite3PcacheRelease(pPg);¾  pagerUnlockIfUnused(pPager);¡} ¢/*ÙC** This function is called at the start of every write transaction.ÙF** There must already be a RESERVED or EXCLUSIVE lock on the database Ù$** file when this routine is called.¢**ÙD** Open the journal file for pager pPager and write a journal headerÙK** to the start of it. If there are active savepoints, open the sub-journalÙF** as well. This function is only used when the journal file is being ÙD** opened to write a rollback log for a transaction. It is not used Ù3** when opening a hot journal file to roll it back.¢**ÙH** If the journal file is already open (as it may be in exclusive mode),ÙF** then this function just writes a journal header to the start of the¶** already open file. ¢**ÙB** Whether or not the journal file is opened by this function, theÙ2** Pager.pInJournal bitvec structure is allocated.¢**ÙC** Return SQLITE_OK if everything is successful. Otherwise, return ÙF** SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or ÙA** an IO error code if opening or writing the journal file fails.¢*/Ù-static int pager_open_journal(Pager *pPager){Ù>  int rc = SQLITE_OK;                        /* Return code */ÙM  sqlite3_vfs * const pVfs = pPager->pVfs;   /* Local cache of vfs pointer */ Ù0  assert( pPager->eState==PAGER_WRITER_LOCKED );Ù'  assert( assert_pager_state(pPager) );Ù"  assert( pPager->pInJournal==0 );¢  ÙE  /* If already in the error state, this function is a no-op.  But onÙF  ** the other hand, this routine is never called if we are already in·  ** an error state. */Ù6  if( NEVER(pPager->errCode) ) return pPager->errCode; ÙK  if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){Ù=    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);Ù     if( pPager->pInJournal==0 ){¿      return SQLITE_NOMEM_BKPT;¥    }¢  Ù:    /* Open the journal file if it is not already open. */¿    if( !isOpen(pPager->jfd) ){Ù:      if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){Ù+        sqlite3MemJournalOpen(pPager->jfd);¬      }else{Ù=        int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;³        int nSpill; ¿        if( pPager->tempFile ){ÙH          flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL);Ù,          nSpill = sqlite3Config.nStmtSpill;®        }else{Ù,          flags |= SQLITE_OPEN_MAIN_JOURNAL;Ù*          nSpill = jrnlBufferSize(pPager);©        }ª          ÙJ        /* Verify that the database still has the same name as it did whenÙ'        ** it was originally opened. */Ù'        rc = databaseIsUnmoved(pPager);¼        if( rc==SQLITE_OK ){Ù#          rc = sqlite3JournalOpen (Ù@              pVfs, pPager->zJournal, pPager->jfd, flags, nSpill¬          );©        }§      }Ù5      assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );¥    }¢  ¢  ÙC    /* Write the first journal header to the journal file and open Ù$    ** the sub-journal if necessary.¦    */¸    if( rc==SQLITE_OK ){Ù<      /* TODO: Check if all of these are really required. */·      pPager->nRec = 0;½      pPager->journalOff = 0;¼      pPager->setMaster = 0;½      pPager->journalHdr = 0;Ù#      rc = writeJournalHdr(pPager);¥    }£  } ¶  if( rc!=SQLITE_OK ){Ù-    sqlite3BitvecDestroy(pPager->pInJournal);»    pPager->pInJournal = 0;¨  }else{Ù2    assert( pPager->eState==PAGER_WRITER_LOCKED );Ù+    pPager->eState = PAGER_WRITER_CACHEMOD;£  } ¬  return rc;¡} ¢/*ÙA** Begin a write-transaction on the specified pager object. If a ÙG** write-transaction has already been opened, this function is a no-op.¢**ÙD** If the exFlag argument is false, then acquire at least a RESERVEDÙF** lock on the database file. If exFlag is true, then acquire at leastÙA** an EXCLUSIVE lock. If such a lock is already held, no locking ¼** functions need be called.¢**ÙH** If the subjInMemory argument is non-zero, then any sub-journal openedÙD** within this transaction will be opened as an in-memory file. ThisÙH** has no effect if the sub-journal is already opened (as it may be whenÙF** running in exclusive mode) or if the transaction does not require aÙG** sub-journal. If the subjInMemory argument is zero, then any requiredÙL** sub-journal is implemented in-memory if pPager is an in-memory database, Ù'** or using a temporary file otherwise.¢*/ÙRSQLITE_PRIVATE int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){µ  int rc = SQLITE_OK; Ù/  if( pPager->errCode ) return pPager->errCode;ÙG  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );Ù*  pPager->subjInMemory = (u8)subjInMemory; Ù-  if( ALWAYS(pPager->eState==PAGER_READER) ){Ù$    assert( pPager->pInJournal==0 ); ¾    if( pagerUseWal(pPager) ){ÙI      /* If the pager is configured to use locking_mode=exclusive, and anÙK      ** exclusive lock on the database is not already held, obtain it now.¨      */ÙO      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){Ù1        rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);¼        if( rc!=SQLITE_OK ){´          return rc;©        }Ù7        (void)sqlite3WalExclusiveMode(pPager->pWal, 1);§      } ÙG      /* Grab the write lock on the log file. If successful, upgrade toÙM      ** PAGER_RESERVED state. Otherwise, return an error code to the caller.ÙF      ** The busy-handler is not invoked if another connection alreadyÙI      ** holds the write-lock. If possible, the upper layer will call it.¨      */Ù9      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);ª    }else{ÙM      /* Obtain a RESERVED lock on the database file. If the exFlag parameterÙI      ** is true, then immediately upgrade this to an EXCLUSIVE lock. TheÙJ      ** busy-handler callback can be used when upgrading to the EXCLUSIVEÙ8      ** lock, but not when obtaining the RESERVED lock.¨      */Ù.      rc = pagerLockDb(pPager, RESERVED_LOCK);Ù$      if( rc==SQLITE_OK && exFlag ){Ù8        rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);§      }¥    } ¸    if( rc==SQLITE_OK ){Ù'      /* Change to WRITER_LOCKED state.¨      **ÙF      ** WAL mode sets Pager.eState to PAGER_WRITER_LOCKED or CACHEMODÙI      ** when it has an open transaction, but never to DBMOD or FINISHED.ÙI      ** This is because in those states the code to roll back savepoint ÙK      ** transactions may copy data from the sub-journal into the database ÙJ      ** file as well as into the page cache. Which would be incorrect in ²      ** WAL mode.¨      */Ù+      pPager->eState = PAGER_WRITER_LOCKED;Ù*      pPager->dbHintSize = pPager->dbSize;Ù*      pPager->dbFileSize = pPager->dbSize;Ù*      pPager->dbOrigSize = pPager->dbSize;½      pPager->journalOff = 0;¥    } Ù<    assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );ÙC    assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );Ù)    assert( assert_pager_state(pPager) );£  } Ù4  PAGERTRACE(("TRANSACTION %d\n", PAGERID(pPager)));¬  return rc;¡} ¢/*Ù7** Write page pPg onto the end of the rollback journal.¢*/ÙEstatic SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;©  int rc;¬  u32 cksum;¯  char *pData2;Ù   i64 iOff = pPager->journalOff; Ù<  /* We should never write to the journal file the page thatÙ@  ** contains the database locks.  The following assert verifies·  ** that we do not. */Ù-  assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) ); Ù3  assert( pPager->journalHdr<=pPager->journalOff );ÙM  CODEC2(pPager, pPg->pData, pPg->pgno, 7, return SQLITE_NOMEM_BKPT, pData2);Ù+  cksum = pager_cksum(pPager, (u8*)pData2); ÙA  /* Even if an IO or diskfull error occurs while journalling theÙB  ** page in the block above, set the need-sync flag for the page.ÙA  ** Otherwise, when the transaction is rolled back, the logic inÙF  ** playback_one_page() will think that the page needs to be restoredÙD  ** in the database file. And if an IO error occurs while doing so,Ù   ** then corruption may follow.¤  */Ù   pPg->flags |= PGHDR_NEED_SYNC; Ù1  rc = write32bits(pPager->jfd, iOff, pPg->pgno);Ù   if( rc!=SQLITE_OK ) return rc;ÙE  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);Ù   if( rc!=SQLITE_OK ) return rc;Ù@  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);Ù   if( rc!=SQLITE_OK ) return rc; Ù6  IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno, Ù2           pPager->journalOff, pPager->pageSize));Ù)  PAGER_INCR(sqlite3_pager_writej_count);Ù<  PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",Ù#       PAGERID(pPager), pPg->pgno, ÙA       ((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg))); Ù-  pPager->journalOff += 8 + pPager->pageSize;±  pPager->nRec++;Ù"  assert( pPager->pInJournal!=0 );Ù7  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);¿  testcase( rc==SQLITE_NOMEM );Ù.  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );Ù1  rc |= addToSavepointBitvecs(pPager, pPg->pgno);Ù.  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );¬  return rc;¡} ¢/*ÙF** Mark a single data page as writeable. The page is written into the ÙG** main journal or sub-journal as required. If the page is written intoÙ<** one of the journals, the corresponding bit is set in the ÙF** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecsÙ)** of any open savepoints as appropriate.¢*/Ù#static int pager_write(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;µ  int rc = SQLITE_OK; ÙG  /* This routine is not called unless a write-transaction has already ÙI  ** been started. The journal file may or may not be open at this point.Ù+  ** It is never called in the ERROR state.¤  */Ù-  assert( pPager->eState==PAGER_WRITER_LOCKEDÙ/       || pPager->eState==PAGER_WRITER_CACHEMODÙ,       || pPager->eState==PAGER_WRITER_DBMOD¤  );Ù'  assert( assert_pager_state(pPager) );¿  assert( pPager->errCode==0 );Ù   assert( pPager->readOnly==0 );²  CHECK_PAGE(pPg); ÙL  /* The journal file needs to be opened. Higher level routines have alreadyÙI  ** obtained the necessary locks to begin the write-transaction, but theÙM  ** rollback journal might not yet be open. Open it now if this is the case.¤  **ÙG  ** This is done before calling sqlite3PcacheMakeDirty() on the page. ÙL  ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), thenÙK  ** an error might occur and the pager would end up in WRITER_LOCKED stateÙ-  ** with pages marked as dirty in the cache.¤  */Ù,  if( pPager->eState==PAGER_WRITER_LOCKED ){Ù$    rc = pager_open_journal(pPager);Ù"    if( rc!=SQLITE_OK ) return rc;£  }Ù2  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );Ù'  assert( assert_pager_state(pPager) ); Ù<  /* Mark the page that is about to be modified as dirty. */¾  sqlite3PcacheMakeDirty(pPg); ÙK  /* If a rollback journal is in use, them make sure the page that is aboutÙK  ** to change is in the rollback journal, or if the page is a new page offÙE  ** then end of the file, make sure it is marked as PGHDR_NEED_SYNC.¤  */Ù;  assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );»  if( pPager->pInJournal!=0Ù@   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0¤  ){Ù%    assert( pagerUseWal(pPager)==0 );Ù(    if( pPg->pgno<=pPager->dbOrigSize ){Ù.      rc = pagerAddPageToRollbackJournal(pPg);º      if( rc!=SQLITE_OK ){²        return rc;§      }ª    }else{Ù/      if( pPager->eState!=PAGER_WRITER_DBMOD ){Ù&        pPg->flags |= PGHDR_NEED_SYNC;§      }Ù4      PAGERTRACE(("APPEND %d page %d needSync=%d\n",Ù)              PAGERID(pPager), pPg->pgno,Ù2             ((pPg->flags&PGHDR_NEED_SYNC)?1:0)));¥    }£  } ÙO  /* The PGHDR_DIRTY bit is set above when the page was added to the dirty-listÙL  ** and before writing the page into the rollback journal.  Wait until now,ÙH  ** after the page has been successfully journalled, before setting theÙM  ** PGHDR_WRITEABLE bit that indicates that the page can be safely modified.¤  */Ù   pPg->flags |= PGHDR_WRITEABLE;¢  Ù@  /* If the statement journal is open and the page is not in it,Ù4  ** then write the page into the statement journal.¤  */½  if( pPager->nSavepoint>0 ){Ù'    rc = subjournalPageIfRequired(pPg);£  } Ù,  /* Update the database size and return. */Ù!  if( pPager->dbSize<pPg->pgno ){¿    pPager->dbSize = pPg->pgno;£  }¬  return rc;¡} ¢/*ÙJ** This is a variant of sqlite3PagerWrite() that runs when the sector sizeÙO** is larger than the page size.  SQLite makes the (reasonable) assumption thatÙO** all bytes of a sector are written together by hardware.  Hence, all bytes ofÙJ** a sector need to be journalled in case of a power loss in the middle of«** a write.¢**ÙL** Usually, the sector size is less than or equal to the page size, in whichÙI** case pages can be individually written.  This routine only runs in theÙH** exceptional case where the page size is smaller than the sector size.¢*/Ù=static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){Ù0  int rc = SQLITE_OK;          /* Return code */ÙK  Pgno nPageCount;             /* Total number of pages in database file */ÙP  Pgno pg1;                    /* First page of the sector pPg is located on. */ÙO  int nPage = 0;               /* Number of pages starting at pg1 to journal */Ù1  int ii;                      /* Loop counter */ÙI  int needSync = 0;            /* True if any page has PGHDR_NEED_SYNC */Ù<  Pager *pPager = pPg->pPager; /* The pager that owns pPg */Ù>  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize); ÙH  /* Set the doNotSpill NOSYNC bit to 1. This is because we cannot allowÙB  ** a journal header to be written between the pages journaled by³  ** this function.¤  */³  assert( !MEMDB );Ù7  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)==0 );Ù)  pPager->doNotSpill |= SPILLFLAG_NOSYNC; ÙC  /* This trick assumes that both the page-size and sector-size areÙB  ** an integer power of 2. It sets variable pg1 to the identifierÙ7  ** of the first page of the sector pPg is located on.¤  */Ù2  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1; ¾  nPageCount = pPager->dbSize;½  if( pPg->pgno>nPageCount ){Ù     nPage = (pPg->pgno - pg1)+1;Ù0  }else if( (pg1+nPagePerSector-1)>nPageCount ){½    nPage = nPageCount+1-pg1;¨  }else{»    nPage = nPagePerSector;£  }²  assert(nPage>0);¹  assert(pg1<=pPg->pgno);Ù   assert((pg1+nPage)>pPg->pgno); Ù-  for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){µ    Pgno pg = pg1+ii;±    PgHdr *pPage;ÙF    if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){Ù&      if( pg!=PAGER_MJ_PGNO(pPager) ){Ù4        rc = sqlite3PagerGet(pPager, pg, &pPage, 0);¼        if( rc==SQLITE_OK ){Ù"          rc = pager_write(pPage);Ù-          if( pPage->flags&PGHDR_NEED_SYNC ){¹            needSync = 1;«          }Ù*          sqlite3PagerUnrefNotNull(pPage);©        }§      }Ù<    }else if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){Ù)      if( pPage->flags&PGHDR_NEED_SYNC ){µ        needSync = 1;§      }Ù&      sqlite3PagerUnrefNotNull(pPage);¥    }£  } ÙC  /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages ÙF  ** starting at pg1, then it needs to be set for all of them. BecauseÙC  ** writing to any of these nPage pages may damage the others, theÙ=  ** journal file must contain sync()ed copies of all of themÙ@  ** before any of them can be written out to the database file.¤  */Ù"  if( rc==SQLITE_OK && needSync ){µ    assert( !MEMDB );¾    for(ii=0; ii<nPage; ii++){Ù8      PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);²      if( pPage ){Ù(        pPage->flags |= PGHDR_NEED_SYNC;Ù(        sqlite3PagerUnrefNotNull(pPage);§      }¥    }£  } Ù7  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)!=0 );Ù*  pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;¬  return rc;¡} ¢/*ÙE** Mark a data page as writeable. This routine must be called before ÙD** making changes to a page. The caller must check the return value ÙF** of this function and be careful not to change any page data unless Ù"** this routine returns SQLITE_OK.¢**ÙF** The difference between this function and pager_write() is that thisÙB** function also deals with the special case where 2 or more pagesÙB** fit on a single disk sector. In this case all co-resident pagesÙ?** must have been written to the journal file before returning.¢**ÙC** If an error occurs, SQLITE_NOMEM or an IO error code is returnedÙ(** as appropriate. Otherwise, SQLITE_OK.¢*/Ù1SQLITE_PRIVATE int sqlite3PagerWrite(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;Ù)  assert( (pPg->flags & PGHDR_MMAP)==0 );Ù0  assert( pPager->eState>=PAGER_WRITER_LOCKED );Ù'  assert( assert_pager_state(pPager) );ÙG  if( (pPg->flags & PGHDR_WRITEABLE)!=0 && pPager->dbSize>=pPg->pgno ){ÙB    if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);µ    return SQLITE_OK;¾  }else if( pPager->errCode ){»    return pPager->errCode;Ù9  }else if( pPager->sectorSize > (u32)pPager->pageSize ){Ù"    assert( pPager->tempFile==0 );Ù&    return pagerWriteLargeSector(pPg);¨  }else{¼    return pager_write(pPg);£  }¡} ¢/*ÙF** Return TRUE if the page given in the argument was previously passedÙC** to sqlite3PagerWrite().  In other words, return TRUE if it is okÙ%** to change the content of the page.¢*/®#ifndef NDEBUGÙ8SQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage *pPg){Ù&  return pPg->flags & PGHDR_WRITEABLE;¡}¦#endif ¢/*ÙE** A call to this routine tells the pager that it is not necessary toÙB** write the information on page pPg back to the disk, even thoughÙG** that page might be marked as dirty.  This happens, for example, whenÙ?** the page has been added as a leaf of the freelist and so its½** content no longer matters.¢**ÙG** The overlying software layer calls this routine when all of the dataÙD** on the given page is unused. The pager marks the page as clean soÙ(** that it does not get written to disk.¢**ÙF** Tests show that this optimization can quadruple the speed of large µ** DELETE operations.¢**ÙE** This optimization cannot be used with a temp-file, as the page mayÙD** have been dirty at the start of the transaction. In that case, ifÙH** memory pressure forces page pPg out of the cache, the data does need ÙC** to be written out to disk so that it may be read back in if the Ù&** current transaction is rolled back.¢*/Ù6SQLITE_PRIVATE void sqlite3PagerDontWrite(PgHdr *pPg){¾  Pager *pPager = pPg->pPager;ÙO  if( !pPager->tempFile && (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){ÙK    PAGERTRACE(("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager)));Ù1    IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno))Ù#    pPg->flags |= PGHDR_DONT_WRITE;Ù#    pPg->flags &= ~PGHDR_WRITEABLE;Ù-    testcase( pPg->flags & PGHDR_NEED_SYNC );¼    pager_set_pagehash(pPg);£  }¡} ¢/*ÙF** This routine is called to increment the value of the database file ÙE** change-counter, stored as a 4-byte big-endian integer starting at ÙE** byte offset 24 of the pager file.  The secondary change counter atÙD** 92 is also updated, as is the SQLite version number at offset 96.¢**ÙF** But this only happens if the pPager->changeCountDone flag is false.ÙD** To avoid excess churning of page 1, the update only happens once.ÙA** See also the pager_write_changecounter() routine that does an Ù/** unconditional update of the change counters.¢**ÙB** If the isDirectMode flag is zero, then this is done by calling ÙD** sqlite3PagerWrite() on page 1, then modifying the contents of theÙD** page data. In this case the file will be updated when the current¼** transaction is committed.¢**ÙI** The isDirectMode flag may only be non-zero if the library was compiledÙC** with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,ÙF** if isDirect is non-zero, then the database file is updated directlyÙ?** by writing an updated version of page 1 using a call to the ½** sqlite3OsWrite() function.¢*/ÙEstatic int pager_incr_changecounter(Pager *pPager, int isDirectMode){µ  int rc = SQLITE_OK; Ù/  assert( pPager->eState==PAGER_WRITER_CACHEMODÙ,       || pPager->eState==PAGER_WRITER_DBMOD¤  );Ù'  assert( assert_pager_state(pPager) ); Ù?  /* Declare and initialize constant integer 'isDirect'. If theÙF  ** atomic-write optimization is enabled in this build, then isDirectÙE  ** is initialized to the value passed as the isDirectMode parameterÙ;  ** to this function. Otherwise, it is always set to zero.¤  **Ù=  ** The idea is that if the atomic-write optimization is notÙ@  ** enabled at compile time, the compiler can omit the tests ofÙ;  ** 'isDirect' below, as well as the block enclosed in theÙ   ** "if( isDirect )" condition.¤  */Ù"#ifndef SQLITE_ENABLE_ATOMIC_WRITE¶# define DIRECT_MODE 0¼  assert( isDirectMode==0 );Ù!  UNUSED_PARAMETER(isDirectMode);¥#elseÙ!# define DIRECT_MODE isDirectMode¦#endif Ù=  if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){Ù;    PgHdr *pPgHdr;                /* Reference to page 1 */ Ù6    assert( !pPager->tempFile && isOpen(pPager->fd) ); Ù.    /* Open page 1 of the file for writing. */Ù0    rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);Ù)    assert( pPgHdr==0 || rc==SQLITE_OK ); ÙE    /* If page one was fetched successfully, and this function is notÙD    ** operating in direct-mode, make page 1 writable.  When not in ÙK    ** direct mode, page 1 is always held in cache and hence the PagerGet()ÙF    ** above is always successful - hence the ALWAYS on rc==SQLITE_OK.¦    */Ù0    if( !DIRECT_MODE && ALWAYS(rc==SQLITE_OK) ){Ù%      rc = sqlite3PagerWrite(pPgHdr);¥    } ¸    if( rc==SQLITE_OK ){Ù8      /* Actually do the update of the change counter */Ù(      pager_write_changecounter(pPgHdr); ÙP      /* If running in direct mode, write the contents of page 1 to the file. */¸      if( DIRECT_MODE ){¹        const void *zBuf;Ù'        assert( pPager->dbFileSize>0 );ÙH        CODEC2(pPager, pPgHdr->pData, 1, 6, rc=SQLITE_NOMEM_BKPT, zBuf);¼        if( rc==SQLITE_OK ){ÙE          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);Ù,          pPager->aStat[PAGER_STAT_WRITE]++;©        }¼        if( rc==SQLITE_OK ){ÙJ          /* Update the pager's copy of the change-counter. Otherwise, theÙE          ** next time a read transaction is opened the cache will beÙG          ** flushed (as the change-counter values will not match).  */ÙF          const void *pCopy = (const void *)&((const char *)zBuf)[24];ÙI          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));Ù&          pPager->changeCountDone = 1;©        }¬      }else{Ù$        pPager->changeCountDone = 1;§      }¥    } Ù%    /* Release the page reference. */¾    sqlite3PagerUnref(pPgHdr);£  }¬  return rc;¡} ¢/*ÙJ** Sync the database file to disk. This is a no-op for in-memory databasesÙ+** or pages with the Pager.noSync flag set.¢**ÙG** If successful, or if called on a pager for which it is a no-op, thisÙG** function returns SQLITE_OK. Otherwise, an IO error code is returned.¢*/ÙHSQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster){µ  int rc = SQLITE_OK;¾  void *pArg = (void*)zMaster;ÙA  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);Ù+  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;Ù)  if( rc==SQLITE_OK && !pPager->noSync ){µ    assert( !MEMDB );Ù6    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);£  }¬  return rc;¡} ¢/*ÙJ** This function may only be called while a write-transaction is active inÙE** rollback. If the connection is in WAL mode, this call is a no-op. ÙK** Otherwise, if the connection does not already have an EXCLUSIVE lock on Ù7** the database file, an attempt is made to obtain one.¢**ÙG** If the EXCLUSIVE lock is already held or the attempt to obtain it isÙG** successful, or the connection is in WAL mode, SQLITE_OK is returned.ÙF** Otherwise, either SQLITE_BUSY or an SQLITE_IOERR_XXX error code is ¬** returned.¢*/Ù<SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager *pPager){»  int rc = pPager->errCode;Ù'  assert( assert_pager_state(pPager) );¶  if( rc==SQLITE_OK ){Ù2    assert( pPager->eState==PAGER_WRITER_CACHEMOD Ù/         || pPager->eState==PAGER_WRITER_DBMOD Ù0         || pPager->eState==PAGER_WRITER_LOCKED ¦    );Ù)    assert( assert_pager_state(pPager) );Ù!    if( 0==pagerUseWal(pPager) ){Ù6      rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);¥    }£  }¬  return rc;¡} ¢/*ÙJ** Sync the database file for the pager pPager. zMaster points to the nameÙF** of a master journal file that should be written into the individualÙG** journal file. zMaster may be NULL, which is interpreted as no masterÙ+** journal (a single database transaction).¢**½** This routine ensures that:¢**Ù3**   * The database file change-counter is updated,ÙL**   * the journal is synced (unless the atomic-write optimization is used),Ù9**   * all dirty pages are written to the database file, Ù8**   * the database file is truncated (if required), andÙ!**   * the database file synced. ¢**ÙH** The only thing that remains to commit the transaction is to finalize ÙE** (delete, truncate or zero the first part of) the journal file (or Ù0** delete the master journal file if specified).¢**ÙG** Note that if zMaster==NULL, this does not overwrite a previous valueÙ2** passed to an sqlite3PagerCommitPhaseOne() call.¢**ÙK** If the final parameter - noSync - is true, then the database file itselfÙE** is not synced. The caller must call sqlite3PagerSync() directly toÙG** sync the database file before calling CommitPhaseTwo() to delete the½** journal file in this case.¢*/Ù.SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Ù4  Pager *pPager,                  /* Pager object */ÙL  const char *zMaster,            /* If not NULL, the master journal name */ÙM  int noSync                      /* True to omit the xSync on the db file */¢){Ù3  int rc = SQLITE_OK;             /* Return code */ Ù-  assert( pPager->eState==PAGER_WRITER_LOCKEDÙ/       || pPager->eState==PAGER_WRITER_CACHEMODÙ,       || pPager->eState==PAGER_WRITER_DBMODÙ%       || pPager->eState==PAGER_ERROR¤  );Ù'  assert( assert_pager_state(pPager) ); Ù;  /* If a prior error occurred, report that error again. */Ù6  if( NEVER(pPager->errCode) ) return pPager->errCode; ÙJ  /* Provide the ability to easily simulate an I/O error during testing */Ù1  if( sqlite3FaultSim(400) ) return SQLITE_IOERR; Ù>  PAGERTRACE(("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n", Ù3      pPager->zFilename, zMaster, pPager->dbSize)); Ù<  /* If no database changes have been made, return early. */Ù>  if( pPager->eState<PAGER_WRITER_CACHEMOD ) return SQLITE_OK; Ù)  assert( MEMDB==0 || pPager->tempFile );Ù3  assert( isOpen(pPager->fd) || pPager->tempFile );Ù)  if( 0==pagerFlushOnCommit(pPager, 1) ){ÙL    /* If this is an in-memory db, or no pages have been written to, or thisÙL    ** function has already been called, it is mostly a no-op.  However, anyÙ4    ** backup in progress needs to be restarted.  */Ù*    sqlite3BackupRestart(pPager->pBackup);¨  }else{¾    if( pagerUseWal(pPager) ){Ù=      PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);º      PgHdr *pPageOne = 0;µ      if( pList==0 ){Ù?        /* Must have at least one page for the WAL commit flag.Ù?        ** Ticket [2d1a5c67dfc2363e44f29d9bbd57f] 2011-05-18 */Ù6        rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);¹        pList = pPageOne;º        pList->pDirty = 0;§      }¾      assert( rc==SQLITE_OK );º      if( ALWAYS(pList) ){Ù>        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);§      }Ù"      sqlite3PagerUnref(pPageOne);º      if( rc==SQLITE_OK ){Ù/        sqlite3PcacheCleanAll(pPager->pPCache);§      }ª    }else{ÙK      /* The bBatch boolean is true if the batch-atomic-write commit methodÙN      ** should be used.  No rollback journal is created if batch-atomic-write´      ** is enabled.¨      */Ù$      sqlite3_file *fd = pPager->fd;Ù'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITEÙP      const int bBatch = zMaster==0    /* An SQLITE_IOCAP_BATCH_ATOMIC commit */ÙK        && (sqlite3OsDeviceCharacteristics(fd) & SQLITE_IOCAP_BATCH_ATOMIC)º        && !pPager->noSyncÙ1        && sqlite3JournalIsInMemory(pPager->jfd);¥#else±# define bBatch 0¦#endif Ù!#ifdef SQLITE_ENABLE_ATOMIC_WRITEÙG      /* The following block updates the change-counter. Exactly how itÙK      ** does this depends on whether or not the atomic-update optimizationÙH      ** was enabled at compile time, and if this transaction meets the Ù0      ** runtime criteria to use the operation: ¨      **ÙD      **    * The file-system supports the atomic-write property forÙ,      **      blocks of size page-size, and ÙF      **    * This commit is not part of a multi-file transaction, andÙO      **    * Exactly one page has been modified and store in the journal file.¨      **ÙF      ** If the optimization was not enabled at compile time, then theÙK      ** pager_incr_changecounter() function is called to update the changeÙK      ** counter in 'indirect-mode'. If the optimization is compiled in butÙK      ** is not applicable to this transaction, call sqlite3JournalCreate()ÙK      ** to make sure the journal file has actually been created, then callÙL      ** pager_incr_changecounter() to update the change-counter in indirect¯      ** mode. ¨      **ÙG      ** Otherwise, if the optimization is both enabled and applicable,ÙJ      ** then call pager_incr_changecounter() to update the change-counterÙF      ** in 'direct' mode. In this case the journal file will never beÙ&      ** created for this transaction.¨      */¶      if( bBatch==0 ){³        PgHdr *pPg;Ù$        assert( isOpen(pPager->jfd) Ù:            || pPager->journalMode==PAGER_JOURNALMODE_OFF Ù:            || pPager->journalMode==PAGER_JOURNALMODE_WAL ®            );Ù,        if( !zMaster && isOpen(pPager->jfd) Ù7         && pPager->journalOff==jrnlBufferSize(pPager) Ù.         && pPager->dbSize>=pPager->dbOrigSizeÙP         && (!(pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)ª        ){ÙP          /* Update the db file change counter via the direct-write method. The ÙO          ** following call will modify the in-memory representation of page 1 ÙI          ** to include the updated change counter and then write page 1 ÙH          ** directly to the database file. Because of the atomic-write Ù<          ** property of the host file-system, this is safe.¬          */Ù3          rc = pager_incr_changecounter(pPager, 1);®        }else{Ù1          rc = sqlite3JournalCreate(pPager->jfd);¾          if( rc==SQLITE_OK ){Ù5            rc = pager_incr_changecounter(pPager, 0);«          }©        }§      }¦#else Ù'#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE´      if( zMaster ){Ù/        rc = sqlite3JournalCreate(pPager->jfd);Ù7        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;§      }¦#endifÙ/      rc = pager_incr_changecounter(pPager, 0);¦#endifÙ5      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;¢  ÙJ      /* Write the master journal name into the journal file. If a master ÙI      ** journal file name has already been written to the journal file, ÙN      ** or if zMaster is NULL (no master journal), then this call is a no-op.¨      */Ù/      rc = writeMasterJournal(pPager, zMaster);Ù5      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;¢  ÙI      /* Sync the journal file and write all dirty pages to the database.ÙM      ** If the atomic-update optimization is being used, this sync will not Ù8      ** create the journal file or perform any real IO.¨      **ÙF      ** Because the change-counter page was just modified, unless theÙI      ** atomic-update optimization is used it is almost certain that theÙI      ** journal requires a sync here. However, in locking_mode=exclusiveÙL      ** on a system under memory pressure it is just possible that this is ÙJ      ** not the case. In this case it is likely enough that the redundantÙC      ** xSync() call will be changed to a no-op by the OS anyhow. ¨      */Ù"      rc = syncJournal(pPager, 0);Ù5      if( rc!=SQLITE_OK ) goto commit_phase_one_exit; ³      if( bBatch ){ÙJ        /* The pager is now in DBMOD state. But regardless of what happensÙL        ** next, attempting to play the journal back into the database wouldÙI        ** be unsafe. Close it now to make sure that does not happen.  */Ù$        sqlite3OsClose(pPager->jfd);ÙJ        rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, 0);Ù7        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;§      }ÙP      rc = pager_write_pagelist(pPager,sqlite3PcacheDirtyList(pPager->pPCache));³      if( bBatch ){¼        if( rc==SQLITE_OK ){ÙM          rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, 0);©        }¼        if( rc!=SQLITE_OK ){ÙN          sqlite3OsFileControlHint(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);©        }§      } º      if( rc!=SQLITE_OK ){Ù+        assert( rc!=SQLITE_IOERR_BLOCKED );Ù#        goto commit_phase_one_exit;§      }Ù-      sqlite3PcacheCleanAll(pPager->pPCache); ÙE      /* If the file on disk is smaller than the database image, use ÙN      ** pager_truncate to grow the file here. This can happen if the databaseÙK      ** image was extended as part of the current transaction and then theÙK      ** last page in the db image moved to the free-list. In this case theÙJ      ** last page is never written out to disk, leaving the database fileÙ8      ** undersized. Fix this now if it is the case.  */Ù.      if( pPager->dbSize>pPager->dbFileSize ){ÙM        Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));Ù5        assert( pPager->eState==PAGER_WRITER_DBMOD );Ù*        rc = pager_truncate(pPager, nNew);Ù7        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;§      }¢  Ù,      /* Finally, sync the database file. */´      if( !noSync ){Ù/        rc = sqlite3PagerSync(pPager, zMaster);§      }Ù&      IOTRACE(("DBSYNC %p\n", pPager))¥    }£  } ¶commit_phase_one_exit:Ù.  if( rc==SQLITE_OK && !pagerUseWal(pPager) ){Ù+    pPager->eState = PAGER_WRITER_FINISHED;£  }¬  return rc;¡}  ¢/*ÙF** When this function is called, the database file has been completelyÙE** updated to reflect the changes made by the current transaction andÙD** synced to disk. The journal file still exists in the file-system ÙC** though, and if a failure occurs at this point it will eventuallyÙD** be used as a hot-journal and the current transaction rolled back.¢**ÙA** This function finalizes the journal file, either by deleting, ÙA** truncating or partially zeroing it, so that it cannot be used ÙA** for hot-journal rollback. Once this is done the transaction is¹** irrevocably committed.¢**ÙA** If an error occurs, an IO error code is returned and the pagerÙ@** moves into the error state. Otherwise, SQLITE_OK is returned.¢*/Ù=SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager *pPager){Ù8  int rc = SQLITE_OK;                  /* Return code */ ÙE  /* This routine should not be called if a prior error has occurred.ÙG  ** But if (due to a coding error elsewhere in the system) it does getÙG  ** called, just return the same error code without doing anything. */Ù6  if( NEVER(pPager->errCode) ) return pPager->errCode; Ù-  assert( pPager->eState==PAGER_WRITER_LOCKEDÙ/       || pPager->eState==PAGER_WRITER_FINISHEDÙH       || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD)¤  );Ù'  assert( assert_pager_state(pPager) ); ÙF  /* An optimization. If the database was not actually modified duringÙD  ** this transaction, the pager is running in exclusive-mode and isÙ>  ** using persistent journals, then this function is a no-op.¤  **ÙG  ** The start of the journal file currently contains a single journal ÙF  ** header with the nRec field set to 0. If such a journal is used asÙF  ** a hot-journal during hot-journal rollback, 0 changes will be madeÙC  ** to the database file. So there is no need to zero the journal ÙC  ** header. Since the pager is in exclusive mode, there is no need¾  ** to drop any locks either.¤  */Ù*  if( pPager->eState==PAGER_WRITER_LOCKED ¼   && pPager->exclusiveMode Ù4   && pPager->journalMode==PAGER_JOURNALMODE_PERSIST¤  ){ÙP    assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );Ù"    pPager->eState = PAGER_READER;µ    return SQLITE_OK;£  } Ù/  PAGERTRACE(("COMMIT %d\n", PAGERID(pPager)));¹  pPager->iDataVersion++;Ù;  rc = pager_end_transaction(pPager, pPager->setMaster, 1);Ù!  return pager_error(pPager, rc);¡} ¢/*ÙD** If a write transaction is open, then all changes made within the ÙH** transaction are reverted and the current write-transaction is closed.ÙK** The pager falls back to PAGER_READER state if successful, or PAGER_ERROR¼** state if an error occurs.¢**ÙM** If the pager is already in PAGER_ERROR state when this function is called,ÙK** it returns Pager.errCode immediately. No work is performed in this case.¢**ÙE** Otherwise, in rollback mode, this function performs two functions:¢**ÙH**   1) It rolls back the journal file, restoring all database file and ÙL**      in-memory cache pages to the state they were in when the transaction·**      was opened, and¢**ÙE**   2) It finalizes the journal file, so that it is not used for hotÙ,**      rollback at any point in the future.¢**ÙF** Finalization of the journal file (task 2) is only performed if the º** rollback is successful.¢**ÙE** In WAL mode, all cache-entries containing data modified within theÙH** current transaction are either expelled from the cache or reverted toÙF** their pre-transaction state by re-reading data from the database orÙ1** WAL files. The WAL transaction is then closed.¢*/Ù7SQLITE_PRIVATE int sqlite3PagerRollback(Pager *pPager){Ù8  int rc = SQLITE_OK;                  /* Return code */Ù1  PAGERTRACE(("ROLLBACK %d\n", PAGERID(pPager))); ÙE  /* PagerRollback() is a no-op if called in READER or OPEN state. IfÙB  ** the pager is already in the ERROR state, the rollback is not ÙG  ** attempted here. Instead, the error code is returned to the caller.¤  */Ù'  assert( assert_pager_state(pPager) );Ù;  if( pPager->eState==PAGER_ERROR ) return pPager->errCode;Ù6  if( pPager->eState<=PAGER_READER ) return SQLITE_OK; ¼  if( pagerUseWal(pPager) ){¬    int rc2;Ù?    rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);Ù>    rc2 = pager_end_transaction(pPager, pPager->setMaster, 0);Ù!    if( rc==SQLITE_OK ) rc = rc2;ÙJ  }else if( !isOpen(pPager->jfd) || pPager->eState==PAGER_WRITER_LOCKED ){Ù     int eState = pPager->eState;Ù-    rc = pager_end_transaction(pPager, 0, 0);Ù/    if( !MEMDB && eState>PAGER_WRITER_LOCKED ){ÙM      /* This can happen using journal_mode=off. Move the pager to the error ÙM      ** state to indicate that the contents of the cache may not be trusted.Ù2      ** Any active readers will get SQLITE_ABORT.¨      */Ù%      pPager->errCode = SQLITE_ABORT;Ù#      pPager->eState = PAGER_ERROR;¾      setGetterMethod(pPager);°      return rc;¥    }¨  }else{Ù#    rc = pager_playback(pPager, 0);£  } Ù:  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );Ù@  assert( rc==SQLITE_OK || rc==SQLITE_FULL || rc==SQLITE_CORRUPTÙ9          || rc==SQLITE_NOMEM || (rc&0xFF)==SQLITE_IOERR Ù           || rc==SQLITE_CANTOPEN¤  ); ÙK  /* If an error occurs during a ROLLBACK, we can no longer trust the pagerÙN  ** cache. So call pager_error() on the way out to make any error persistent.¤  */Ù!  return pager_error(pPager, rc);¡} ¢/*ÙF** Return TRUE if the database file is opened read-only.  Return FALSEÙ+** if the database is (in theory) writable.¢*/Ù8SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager *pPager){º  return pPager->readOnly;¡} ³#ifdef SQLITE_DEBUG¢/*ÙG** Return the sum of the reference counts for all pages held by pPager.¢*/Ù7SQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager){Ù0  return sqlite3PcacheRefCount(pPager->pPCache);¡}¦#endif ¢/*Ù=** Return the approximate number of bytes of memory currentlyÙ.** used by the pager and its associated cache.¢*/Ù6SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager *pPager){ÙE  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)Ù7                                     + 5*sizeof(void*);Ù<  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)Ù&           + sqlite3MallocSize(pPager)¾           + pPager->pageSize;¡} ¢/*Ù9** Return the number of references to the specified page.¢*/Ù;SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage *pPage){Ù*  return sqlite3PcachePageRefcount(pPage);¡} ²#ifdef SQLITE_TEST¢/*Ù6** This routine is used for testing and analysis only.¢*/Ù5SQLITE_PRIVATE int *sqlite3PagerStats(Pager *pPager){³  static int a[11];Ù0  a[0] = sqlite3PcacheRefCount(pPager->pPCache);Ù1  a[1] = sqlite3PcachePagecount(pPager->pPCache);Ù4  a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);Ù@  a[3] = pPager->eState==PAGER_OPEN ? -1 : (int) pPager->dbSize;¸  a[4] = pPager->eState;¹  a[5] = pPager->errCode;Ù'  a[6] = pPager->aStat[PAGER_STAT_HIT];Ù(  a[7] = pPager->aStat[PAGER_STAT_MISS];Ù+  a[8] = 0;  /* Used to be pPager->nOvfl */·  a[9] = pPager->nRead;Ù*  a[10] = pPager->aStat[PAGER_STAT_WRITE];«  return a;¡}¦#endif ¢/*ÙK** Parameter eStat must be one of SQLITE_DBSTATUS_CACHE_HIT, _MISS, _WRITE,ÙH** or _WRITE+1.  The SQLITE_DBSTATUS_CACHE_WRITE+1 case is a translationÙM** of SQLITE_DBSTATUS_CACHE_SPILL.  The _SPILL case is not contiguous because¶** it was added later.¢**Ù1** Before returning, *pnVal is incremented by theÙL** current cache hit or miss count, according to the value of eStat. If the ÙM** reset parameter is non-zero, the cache hit or miss count is zeroed before ­** returning.¢*/Ù[SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){ Ù*  assert( eStat==SQLITE_DBSTATUS_CACHE_HITÙ+       || eStat==SQLITE_DBSTATUS_CACHE_MISSÙ,       || eStat==SQLITE_DBSTATUS_CACHE_WRITEÙ.       || eStat==SQLITE_DBSTATUS_CACHE_WRITE+1¤  ); ÙD  assert( SQLITE_DBSTATUS_CACHE_HIT+1==SQLITE_DBSTATUS_CACHE_MISS );ÙE  assert( SQLITE_DBSTATUS_CACHE_HIT+2==SQLITE_DBSTATUS_CACHE_WRITE );Ù1  assert( PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1Ù;           && PAGER_STAT_WRITE==2 && PAGER_STAT_SPILL==3 ); Ù%  eStat -= SQLITE_DBSTATUS_CACHE_HIT;Ù!  *pnVal += pPager->aStat[eStat];®  if( reset ){½    pPager->aStat[eStat] = 0;£  }¡} ¢/*ÙA** Return true if this is an in-memory or temp-file backed pager.¢*/Ù6SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager){º  return pPager->tempFile;¡} ¢/*ÙI** Check that there are at least nSavepoint savepoints open. If there areÙI** currently less than nSavepoints open, then open one or more savepointsÙD** to make up the difference. If the number of savepoints is alreadyÙ6** equal to nSavepoint, then this function is a no-op.¢**ÙG** If a memory allocation fails, SQLITE_NOMEM is returned. If an error ÙF** occurs while opening the sub-journal file, then an IO error code isÙ"** returned. Otherwise, SQLITE_OK.¢*/ÙMstatic SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){Ù=  int rc = SQLITE_OK;                       /* Return code */ÙN  int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */ÙC  int ii;                                   /* Iterator variable */ÙL  PagerSavepoint *aNew;                     /* New Pager.aSavepoint array */ Ù0  assert( pPager->eState>=PAGER_WRITER_LOCKED );Ù'  assert( assert_pager_state(pPager) );Ù6  assert( nSavepoint>nCurrent && pPager->useJournal ); ÙI  /* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEMÙH  ** if the allocation fails. Otherwise, zero the new portion in case a ÙJ  ** malloc failure occurs while populating it in the for(...) loop below.¤  */Ù*  aNew = (PagerSavepoint *)sqlite3Realloc(Ù;      pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint¤  );®  if( !aNew ){½    return SQLITE_NOMEM_BKPT;£  }ÙM  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));¼  pPager->aSavepoint = aNew; Ù>  /* Populate the PagerSavepoint structures just allocated. */Ù(  for(ii=nCurrent; ii<nSavepoint; ii++){Ù$    aNew[ii].nOrig = pPager->dbSize;Ù6    if( isOpen(pPager->jfd) && pPager->journalOff>0 ){Ù,      aNew[ii].iOffset = pPager->journalOff;ª    }else{Ù0      aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);¥    }Ù'    aNew[ii].iSubRec = pPager->nSubRec;Ù@    aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);Ù!    if( !aNew[ii].pInSavepoint ){¿      return SQLITE_NOMEM_BKPT;¥    }¾    if( pagerUseWal(pPager) ){Ù;      sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);¥    }¾    pPager->nSavepoint = ii+1;£  }Ù+  assert( pPager->nSavepoint==nSavepoint );Ù#  assertTruncateConstraint(pPager);¬  return rc;¡}ÙLSQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){Ù0  assert( pPager->eState>=PAGER_WRITER_LOCKED );Ù'  assert( assert_pager_state(pPager) ); Ù<  if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){Ù2    return pagerOpenSavepoint(pPager, nSavepoint);¨  }else{µ    return SQLITE_OK;£  }¡}  ¢/*ÙG** This function is called to rollback or release (commit) a savepoint.ÙF** The savepoint to release or rollback need not be the most recently µ** created savepoint.¢**ÙI** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.ÙJ** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint withÙK** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changesÙ@** that have occurred since the specified savepoint was created.¢**ÙC** The savepoint to rollback or release is identified by parameter ÙG** iSavepoint. A value of 0 means to operate on the outermost savepointÙE** (the first created). A value of (Pager.nSavepoint-1) means operateÙH** on the most recently created savepoint. If iSavepoint is greater thanÙ7** (Pager.nSavepoint-1), then this function is a no-op.¢**ÙC** If a negative value is passed to this function, then the currentÙ<** transaction is rolled back. This is different to calling ÙB** sqlite3PagerRollback() because this function does not terminateÙ@** the transaction or unlock the database, it just restores the Ù3** contents of the database to its original state. ¢**ÙE** In any case, all savepoints with an index greater than iSavepoint ÙI** are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),Ù/** then savepoint iSavepoint is also destroyed.¢**ÙF** This function may return SQLITE_NOMEM if a memory allocation fails,ÙB** or an IO error code if an IO error occurs while rolling back a Ù8** savepoint. If no errors occur, SQLITE_OK is returned.£*/ ÙPSQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){»  int rc = pPager->errCode;¢  »#ifdef SQLITE_ENABLE_ZIPVFSÙ-  if( op==SAVEPOINT_RELEASE ) rc = SQLITE_OK;¦#endif Ù<  assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );Ù4  assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK ); Ù7  if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){Ù.    int ii;            /* Iterator variable */ÙJ    int nNew;          /* Number of remaining savepoints after this op. */ ÙE    /* Figure out how many savepoints will still be active after thisÙK    ** operation. Store this value in nNew. Then free resources associated Ù@    ** with any savepoints that are destroyed by this operation.¦    */Ù<    nNew = iSavepoint + (( op==SAVEPOINT_RELEASE ) ? 0 : 1);Ù.    for(ii=nNew; ii<pPager->nSavepoint; ii++){Ù@      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);¥    }¾    pPager->nSavepoint = nNew; ÙA    /* If this is a release of the outermost savepoint, truncate Ù0    ** the sub-journal to zero bytes in size. */Ù     if( op==SAVEPOINT_RELEASE ){Ù,      if( nNew==0 && isOpen(pPager->sjfd) ){Ù>        /* Only truncate if it is an in-memory sub-journal. */Ù5        if( sqlite3JournalIsInMemory(pPager->sjfd) ){Ù2          rc = sqlite3OsTruncate(pPager->sjfd, 0);Ù"          assert( rc==SQLITE_OK );©        }¼        pPager->nSubRec = 0;§      }¥    }ÙK    /* Else this is a rollback operation, playback the specified savepoint.ÙG    ** If this is a temp-file, it is possible that the journal file hasÙF    ** not yet been opened. In this case there have been no changes toÙC    ** the database file, so the playback operation can be skipped.¦    */Ù:    else if( pagerUseWal(pPager) || isOpen(pPager->jfd) ){ÙK      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];Ù6      rc = pagerPlaybackSavepoint(pPager, pSavepoint);¾      assert(rc!=SQLITE_DONE);¥    }¤    »#ifdef SQLITE_ENABLE_ZIPVFSÙI    /* If the cache has been modified but the savepoint cannot be rolled ÙI    ** back journal_mode=off, put the pager in the error state. This way,ÙL    ** if the VFS used by this pager includes ZipVFS, the entire transactionÙ2    ** can be rolled back at the ZipVFS level.  */­    else if( Ù3        pPager->journalMode==PAGER_JOURNALMODE_OFF Ù-     && pPager->eState>=PAGER_WRITER_CACHEMOD¦    ){Ù%      pPager->errCode = SQLITE_ABORT;Ù#      pPager->eState = PAGER_ERROR;¾      setGetterMethod(pPager);¥    }¦#endif£  } ¬  return rc;¡} ¢/*Ù1** Return the full pathname of the database file.¢**ÙI** Except, if the pager is in-memory only, then return an empty string ifÙH** nullIfMemDb is true.  This routine is called with nullIfMemDb==1 whenÙI** used to report the filename to the user, for compatibility with legacyÙK** behavior.  But when the Btree needs to know the filename for matching toÙG** shared cache, it uses nullIfMemDb==0 so that in-memory databases can¿** participate in shared-cache.¢*/ÙPSQLITE_PRIVATE const char *sqlite3PagerFilename(Pager *pPager, int nullIfMemDb){ÙA  return (nullIfMemDb && pPager->memDb) ? "" : pPager->zFilename;¡} ¢/*Ù*** Return the VFS structure for the pager.¢*/Ù;SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){¶  return pPager->pVfs;¡} ¢/*Ù:** Return the file handle for the database file associatedÙ:** with the pager.  This might return NULL if the file has·** not yet been opened.¢*/Ù=SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager){´  return pPager->fd;¡} Ù"#ifdef SQLITE_ENABLE_SETLK_TIMEOUT¢/*Ù$** Reset the lock timeout for pager.¢*/Ù@SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager){¬  int x = 0;ÙB  sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_LOCK_TIMEOUT, &x);¡}¦#endif ¢/*Ù>** Return the file handle for the journal file (if it exists).Ù<** This will be either the rollback journal or the WAL file.¢*/ÙASQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){³#if SQLITE_OMIT_WALµ  return pPager->jfd;¥#elseÙC  return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;¦#endif¡} ¢/*Ù0** Return the full pathname of the journal file.¢*/ÙBSQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager){º  return pPager->zJournal;¡} ·#ifdef SQLITE_HAS_CODEC¢/*Ù+** Set or retrieve the codec for this pager¢*/Ù)SQLITE_PRIVATE void sqlite3PagerSetCodec(°  Pager *pPager,Ù(  void *(*xCodec)(void*,void*,Pgno,int),Ù(  void (*xCodecSizeChng)(void*,int,int),¼  void (*xCodecFree)(void*),®  void *pCodec¢){Ù>  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);Ù.  pPager->xCodec = pPager->memDb ? 0 : xCodec;Ù*  pPager->xCodecSizeChng = xCodecSizeChng;Ù"  pPager->xCodecFree = xCodecFree;º  pPager->pCodec = pCodec;º  setGetterMethod(pPager);º  pagerReportSize(pPager);¡}Ù9SQLITE_PRIVATE void *sqlite3PagerGetCodec(Pager *pPager){¸  return pPager->pCodec;¡} ¢/*ÙF** This function is called by the wal module when writing page contentµ** into the log file.¢**ÙG** This function returns a pointer to a buffer containing the encryptedÙB** page content. If a malloc fails, this function may return NULL.¢*/Ù3SQLITE_PRIVATE void *sqlite3PagerCodec(PgHdr *pPg){²  void *aData = 0;ÙA  CODEC2(pPg->pPager, pPg->pData, pPg->pgno, 6, return 0, aData);¯  return aData;¡} ¢/*Ù!** Return the current pager state¢*/Ù4SQLITE_PRIVATE int sqlite3PagerState(Pager *pPager){¸  return pPager->eState;¡}½#endif /* SQLITE_HAS_CODEC */ ¾#ifndef SQLITE_OMIT_AUTOVACUUM¢/*Ù2** Move the page pPg to location pgno in the file.¢**Ù@** There must be no references to the page previously located atÙ@** pgno (which we call pPgOld) though that page is allowed to beÙC** in cache.  If the page previously located at pgno is not alreadyÙC** in the rollback journal, it is not put there by by this routine.¢**Ù8** References to the page pPg remain valid. Updating anyÙF** meta-data associated with pPg (i.e. data stored in the nExtra bytesÙF** allocated along with the page) is the responsibility of the caller.¢**ÙJ** A transaction must be active when this routine is called. It used to beÙM** required that a statement transaction was not active, but this restrictionÙG** has been removed (CREATE INDEX needs to move a page when a statementº** transaction is active).¢**ÙI** If the fourth argument, isCommit, is non-zero, then this page is beingÙJ** moved as part of a database reorganization just before the transaction ÙM** is being committed. In this case, it is guaranteed that the database page ÙF** pPg refers to will not be written to again within this transaction.¢**ÙH** This function may return SQLITE_NOMEM or an IO error code if an errorÙ+** occurs. Otherwise, it returns SQLITE_OK.¢*/Ù]SQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){Ù@  PgHdr *pPgOld;               /* The page being overwritten. */ÙP  Pgno needSyncPgno = 0;       /* Old value of pPg->pgno, if sync is required */Ù0  int rc;                      /* Return code */Ù=  Pgno origPgno;               /* The original page number */ ¸  assert( pPg->nRef>0 );Ù/  assert( pPager->eState==PAGER_WRITER_CACHEMODÙ,       || pPager->eState==PAGER_WRITER_DBMOD¤  );Ù'  assert( assert_pager_state(pPager) ); ÙH  /* In order to be able to rollback, an in-memory database must journalÙ!  ** the page we are moving from.¤  */Ù'  assert( pPager->tempFile || !MEMDB );¹  if( pPager->tempFile ){Ù     rc = sqlite3PagerWrite(pPg);·    if( rc ) return rc;£  } ÙJ  /* If the page being moved is dirty and has not been saved by the latestÙD  ** savepoint, then save the current contents of the page into the ÙH  ** sub-journal now. This is required to handle the following scenario:¤  **­  **   BEGIN;Ù3  **     <journal page X, then modify it in memory>·  **     SAVEPOINT one;Ù&  **       <Move page X to location Y>¹  **     ROLLBACK TO one;¤  **ÙE  ** If page X were not written to the sub-journal here, it would notÙC  ** be possible to restore its contents when the "ROLLBACK TO one"Ù!  ** statement were is processed.¤  **ÙH  ** subjournalPage() may need to allocate space to store pPg->pgno intoÙD  ** one or more savepoint bitvecs. This is the reason this function½  ** may return SQLITE_NOMEM.¤  */Ù#  if( (pPg->flags & PGHDR_DIRTY)!=0Ù5   && SQLITE_OK!=(rc = subjournalPageIfRequired(pPg))¤  ){®    return rc;£  } Ù=  PAGERTRACE(("MOVE %d page %d (needSync=%d) moves to %d\n", ÙK      PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC)?1:0, pgno));Ù7  IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno)) ÙB  /* If the journal needs to be sync()ed before page pPg->pgno canÙC  ** be written to, store pPg->pgno in local variable needSyncPgno.¤  **ÙC  ** If the isCommit flag is set, there is no need to remember thatÙE  ** the journal needs to be sync()ed before database page pPg->pgno ÙK  ** can be written to. The caller has already promised not to write to it.¤  */Ù2  if( (pPg->flags&PGHDR_NEED_SYNC) && !isCommit ){½    needSyncPgno = pPg->pgno;Ù9    assert( pPager->journalMode==PAGER_JOURNALMODE_OFF ||ÙI            pageInJournal(pPager, pPg) || pPg->pgno>pPager->dbOrigSize );Ù%    assert( pPg->flags&PGHDR_DIRTY );£  } ÙB  /* If the cache contains a page with page-number pgno, remove itÙH  ** from its hash chain. Also, if the PGHDR_NEED_SYNC flag was set for ÙD  ** page pgno before the 'move' operation, it needs to be retained ¾  ** for the page moved there.¤  */Ù!  pPg->flags &= ~PGHDR_NEED_SYNC;Ù,  pPgOld = sqlite3PagerLookup(pPager, pgno);Ù'  assert( !pPgOld || pPgOld->nRef==1 );¯  if( pPgOld ){Ù2    pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC);»    if( pPager->tempFile ){ÙG      /* Do not discard pages from an in-memory database since we mightÙG      ** need to rollback later.  Just move the page out of the way. */Ù2      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);ª    }else{Ù       sqlite3PcacheDrop(pPgOld);¥    }£  } ·  origPgno = pPg->pgno;¿  sqlite3PcacheMove(pPg, pgno);¾  sqlite3PcacheMakeDirty(pPg); ÙE  /* For an in-memory database, make sure the original page continuesÙF  ** to exist, in case the transaction needs to roll back.  Use pPgOldÙ>  ** as the original page since it has already been allocated.¤  */Ù#  if( pPager->tempFile && pPgOld ){Ù(    sqlite3PcacheMove(pPgOld, origPgno);Ù%    sqlite3PagerUnrefNotNull(pPgOld);£  } µ  if( needSyncPgno ){ÙF    /* If needSyncPgno is non-zero, then the journal file needs to be ÙN    ** sync()ed before any data is written to database file page needSyncPgno.Ù@    ** Currently, no such page exists in the page-cache and the ÙL    ** "is journaled" bitvec flag has been set. This needs to be remedied byÙL    ** loading the page into the pager-cache and setting the PGHDR_NEED_SYNC¬    ** flag.¦    **ÙF    ** If the attempt to load the page into the page-cache fails, (dueÙF    ** to a malloc() or IO failure), clear the bit in the pInJournal[]ÙC    ** array. Otherwise, if the page is loaded and written again inÙF    ** this transaction, it may be written to the database file beforeÙE    ** it is synced into the journal file. This way, it may end up inÙ9    ** the journal file twice, but that is not a problem.¦    */²    PgHdr *pPgHdr;Ù;    rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);¸    if( rc!=SQLITE_OK ){Ù-      if( needSyncPgno<=pPager->dbOrigSize ){Ù'        assert( pPager->pTmpSpace!=0 );ÙP        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);§      }°      return rc;¥    }Ù%    pPgHdr->flags |= PGHDR_NEED_SYNC;Ù#    sqlite3PcacheMakeDirty(pPgHdr);Ù%    sqlite3PagerUnrefNotNull(pPgHdr);£  } ³  return SQLITE_OK;¡}¦#endif ¢/*ÙG** The page handle passed as the first argument refers to a dirty page ÙH** with a page number other than iNew. This function changes the page's ÙF** page number to iNew and sets the value of the PgHdr.flags field to Ù+** the value passed as the third parameter.¢*/ÙISQLITE_PRIVATE void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){¼  assert( pPg->pgno!=iNew );µ  pPg->flags = flags;¿  sqlite3PcacheMove(pPg, iNew);¡} ¢/*Ù7** Return a pointer to the data for the specified page.¢*/Ù6SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *pPg){Ù.  assert( pPg->nRef>0 || pPg->pPager->memDb );´  return pPg->pData;¡} ¢/*Ù?** Return a pointer to the Pager.nExtra bytes of "extra" space Ù+** allocated along with the specified page.¢*/Ù7SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg){µ  return pPg->pExtra;¡} ¢/*ÙG** Get/set the locking-mode for this pager. Parameter eMode must be oneÙ;** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or ÙD** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, thenÙ2** the locking-mode is set to the value specified.¢**Ù;** The returned value is either PAGER_LOCKINGMODE_NORMAL orÙI** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)°** locking-mode.¢*/ÙESQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *pPager, int eMode){Ù(  assert( eMode==PAGER_LOCKINGMODE_QUERYÙ.            || eMode==PAGER_LOCKINGMODE_NORMALÙ4            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );Ù&  assert( PAGER_LOCKINGMODE_QUERY<0 );ÙJ  assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );ÙK  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );ÙM  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){Ù&    pPager->exclusiveMode = (u8)eMode;£  }Ù$  return (int)pPager->exclusiveMode;¡} ¢/*ÙG** Set the journal-mode for this pager. Parameter eMode must be one of:¢**¾**    PAGER_JOURNALMODE_DELETEÙ **    PAGER_JOURNALMODE_TRUNCATE¿**    PAGER_JOURNALMODE_PERSIST»**    PAGER_JOURNALMODE_OFF¾**    PAGER_JOURNALMODE_MEMORY»**    PAGER_JOURNALMODE_WAL¢**ÙJ** The journalmode is set to the value specified if the change is allowed.Ù:** The change may be disallowed for the following reasons:¢**ÙH**   *  An in-memory database can only have its journal_mode set to _OFF³**      or _MEMORY.¢**Ù9**   *  Temporary databases cannot have _WAL journalmode.¢**ÙE** The returned indicate the current (possibly updated) journal-mode.¢*/ÙHSQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){Ù;  u8 eOld = pPager->journalMode;    /* Prior journalmode */ ³#ifdef SQLITE_DEBUGÙK  /* The print_pager_state() routine is intended to be used by the debuggerÙE  ** only.  We invoke it once here to suppress a compiler warning. */¼  print_pager_state(pPager);¦#endif  Ù+  /* The eMode parameter is always valid */Ù.  assert(      eMode==PAGER_JOURNALMODE_DELETEÙ0            || eMode==PAGER_JOURNALMODE_TRUNCATEÙ/            || eMode==PAGER_JOURNALMODE_PERSISTÙ,            || eMode==PAGER_JOURNALMODE_OFF Ù,            || eMode==PAGER_JOURNALMODE_WAL Ù1            || eMode==PAGER_JOURNALMODE_MEMORY ); ÙD  /* This routine is only called from the OP_JournalMode opcode, andÙD  ** the logic there will never allow a temporary file to be changed±  ** to WAL mode.¤  */Ù@  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL ); ÙC  /* Do allow the journalmode of an in-memory database to be set toÙ&  ** anything other than MEMORY or OFF¤  */®  if( MEMDB ){ÙL    assert( eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF );ÙJ    if( eMode!=PAGER_JOURNALMODE_MEMORY && eMode!=PAGER_JOURNALMODE_OFF ){³      eMode = eOld;¥    }£  } ´  if( eMode!=eOld ){ Ù"    /* Change the journal mode. */Ù*    assert( pPager->eState!=PAGER_ERROR );Ù$    pPager->journalMode = (u8)eMode; ÙH    /* When transistioning from TRUNCATE or PERSIST to any other journalÙK    ** mode except WAL, unless the pager is in locking_mode=exclusive mode,¿    ** delete the journal file.¦    */Ù2    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );Ù1    assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );Ù0    assert( (PAGER_JOURNALMODE_DELETE & 5)==0 );Ù0    assert( (PAGER_JOURNALMODE_MEMORY & 5)==4 );Ù-    assert( (PAGER_JOURNALMODE_OFF & 5)==0 );Ù-    assert( (PAGER_JOURNALMODE_WAL & 5)==5 ); Ù:    assert( isOpen(pPager->fd) || pPager->exclusiveMode );ÙD    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){ ÙH      /* In this case we would like to delete the journal file. If it isÙL      ** not possible, then that is not a problem. Deleting the journal fileÙ&      ** here is an optimization only.¨      **ÙH      ** Before deleting the journal file, obtain a RESERVED lock on theÙI      ** database file. This ensures that the journal file is not deletedÙ1      ** while it is in use by some other client.¨      */Ù"      sqlite3OsClose(pPager->jfd);Ù)      if( pPager->eLock>=RESERVED_LOCK ){Ù;        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);¬      }else{»        int rc = SQLITE_OK;Ù#        int state = pPager->eState;Ù;        assert( state==PAGER_OPEN || state==PAGER_READER );Ù         if( state==PAGER_OPEN ){Ù.          rc = sqlite3PagerSharedLock(pPager);©        }Ù+        if( pPager->eState==PAGER_READER ){Ù"          assert( rc==SQLITE_OK );Ù2          rc = pagerLockDb(pPager, RESERVED_LOCK);©        }¼        if( rc==SQLITE_OK ){Ù=          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);©        }Ù3        if( rc==SQLITE_OK && state==PAGER_READER ){Ù-          pagerUnlockDb(pPager, SHARED_LOCK);Ù&        }else if( state==PAGER_OPEN ){¿          pager_unlock(pPager);©        }Ù(        assert( state==pPager->eState );§      }Ù-    }else if( eMode==PAGER_JOURNALMODE_OFF ){Ù"      sqlite3OsClose(pPager->jfd);¥    }£  } Ù#  /* Return the new journal mode */Ù"  return (int)pPager->journalMode;¡} ¢/*Ù#** Return the current journal mode.¢*/Ù=SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager *pPager){Ù"  return (int)pPager->journalMode;¡} ¢/*ÙF** Return TRUE if the pager is in a state where it is OK to change theÙF** journalmode.  Journalmode changes can only happen when the database±** is unmodified.¢*/ÙDSQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager *pPager){Ù'  assert( assert_pager_state(pPager) );Ù7  if( pPager->eState>=PAGER_WRITER_CACHEMOD ) return 0;ÙD  if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) return 0;«  return 1;¡} ¢/*Ù<** Get/set the size-limit used for persistent journal files.¢**Ù;** Setting the size limit to -1 means no limit is enforced.Ù8** An attempt to set a limit smaller than -1 is a no-op.¢*/ÙKSQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){³  if( iLimit>=-1 ){Ù&    pPager->journalSizeLimit = iLimit;Ù*    sqlite3WalLimit(pPager->pWal, iLimit);£  }Ù"  return pPager->journalSizeLimit;¡} ¢/*ÙF** Return a pointer to the pPager->pBackup variable. The backup moduleÙB** in backup.c maintains the content of this variable. This moduleÙ@** uses it opaquely as an argument to sqlite3BackupRestart() and¾** sqlite3BackupUpdate() only.¢*/ÙESQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){º  return &pPager->pBackup;¡} º#ifndef SQLITE_OMIT_VACUUM¢/*ÙL** Unless this is an in-memory or temporary database, clear the pager cache.¢*/Ù:SQLITE_PRIVATE void sqlite3PagerClearCache(Pager *pPager){Ù)  assert( MEMDB==0 || pPager->tempFile );Ù0  if( pPager->tempFile==0 ) pager_reset(pPager);¡}¦#endif  ·#ifndef SQLITE_OMIT_WAL¢/*ÙI** This function is called when the user invokes "PRAGMA wal_checkpoint",ÙI** "PRAGMA wal_blocking_checkpoint" or calls the sqlite3_wal_checkpoint()Ù.** or wal_blocking_checkpoint() API functions.¢**ÙH** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.¢*/Ù*SQLITE_PRIVATE int sqlite3PagerCheckpoint(Ù@  Pager *pPager,                  /* Checkpoint on this pager */ÙN  sqlite3 *db,                    /* Db handle used to check for interrupts */Ù:  int eMode,                      /* Type of checkpoint */ÙJ  int *pnLog,                     /* OUT: Final number of frames in log */ÙP  int *pnCkpt                     /* OUT: Final number of checkpointed frames */¢){µ  int rc = SQLITE_OK;µ  if( pPager->pWal ){Ù6    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,ÙF        (eMode==SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager->xBusyHandler),Ù         pPager->pBusyHandlerArg,ÙH        pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,µ        pnLog, pnCkpt¦    );Ù)    sqlite3PagerResetLockTimeout(pPager);£  }¬  return rc;¡} Ù:SQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager){Ù*  return sqlite3WalCallback(pPager->pWal);¡} ¢/*ÙE** Return true if the underlying VFS for the given pager supports theÙ0** primitives necessary for write-ahead logging.¢*/Ù;SQLITE_PRIVATE int sqlite3PagerWalSupported(Pager *pPager){Ù<  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;Ù   if( pPager->noLock ) return 0;ÙO  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);¡} ¢/*ÙL** Attempt to take an exclusive lock on the database file. If a PENDING lockÙ/** is obtained instead, immediately release it.¢*/Ù-static int pagerExclusiveLock(Pager *pPager){Ù3  int rc;                         /* Return code */ ÙH  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );Ù+  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);¶  if( rc!=SQLITE_OK ){ÙE    /* If the attempt to grab the exclusive lock failed, release the Ù<    ** pending lock that may have been obtained instead.  */Ù'    pagerUnlockDb(pPager, SHARED_LOCK);£  } ¬  return rc;¡} ¢/*ÙD** Call sqlite3WalOpen() to open the WAL handle. If the pager is in ÙI** exclusive-locking mode when this function is called, take an EXCLUSIVEÙG** lock on the database file and use heap-memory to store the wal-indexÙ/** in. Otherwise, use the normal shared-memory.¢*/Ù'static int pagerOpenWal(Pager *pPager){µ  int rc = SQLITE_OK; Ù3  assert( pPager->pWal==0 && pPager->tempFile==0 );ÙH  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK ); ÙH  /* If the pager is already in exclusive-mode, the WAL module will use ÙD  ** heap-memory for the wal-index instead of the VFS shared-memory ÙH  ** implementation. Take the exclusive lock now, before opening the WALÙ%  ** file, to make sure this is safe.¤  */¾  if( pPager->exclusiveMode ){Ù$    rc = pagerExclusiveLock(pPager);£  } ÙC  /* Open the connection to the log file. If this operation fails, Ù:  ** (e.g. due to malloc() failure), return an error code.¤  */¶  if( rc==SQLITE_OK ){Ù%    rc = sqlite3WalOpen(pPager->pVfs,Ù8        pPager->fd, pPager->zWal, pPager->exclusiveMode,Ù/        pPager->journalSizeLimit, &pPager->pWal¦    );£  }»  pagerFixMaplimit(pPager); ¬  return rc;¡}  ¢/*ÙH** The caller must be holding a SHARED lock on the database file to call±** this function.¢**ÙG** If the pager passed as the first argument is open on a real databaseÙD** file (not a temp file or an in-memory database), and the WAL fileÙF** is not already open, make an attempt to open it now. If successful,ÙJ** return SQLITE_OK. If an error occurs or the VFS used by the pager does ÙF** not support the xShmXXX() methods, return an error code. *pbOpen is¿** not modified in either case.¢**ÙE** If the pager is open on a temp-file (or in-memory database), or ifÙF** the WAL file is already open, set *pbOpen to 1 and return SQLITE_OKº** without doing anything.¢*/Ù'SQLITE_PRIVATE int sqlite3PagerOpenWal(Ù4  Pager *pPager,                  /* Pager object */ÙK  int *pbOpen                     /* OUT: Set to true if call is a no-op */¢){Ù3  int rc = SQLITE_OK;             /* Return code */ Ù'  assert( assert_pager_state(pPager) );Ù3  assert( pPager->eState==PAGER_OPEN   || pbOpen );Ù4  assert( pPager->eState==PAGER_READER || !pbOpen );Ù$  assert( pbOpen==0 || *pbOpen==0 );Ù>  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) ); Ù+  if( !pPager->tempFile && !pPager->pWal ){ÙC    if( !sqlite3PagerWalSupported(pPager) ) return SQLITE_CANTOPEN; Ù4    /* Close any rollback journal previously open */Ù     sqlite3OsClose(pPager->jfd); ¾    rc = pagerOpenWal(pPager);¸    if( rc==SQLITE_OK ){Ù2      pPager->journalMode = PAGER_JOURNALMODE_WAL;Ù"      pPager->eState = PAGER_OPEN;¥    }¨  }else{°    *pbOpen = 1;£  } ¬  return rc;¡} ¢/*ÙH** This function is called to close the connection to the log file priorÙ*** to switching from WAL to rollback mode.¢**ÙB** Before closing the log file, this function attempts to take an ÙF** EXCLUSIVE lock on the database file. If this cannot be obtained, anÙH** error (SQLITE_BUSY) is returned and the log connection is not closed.ÙF** If successful, the EXCLUSIVE lock is not released before returning.¢*/ÙDSQLITE_PRIVATE int sqlite3PagerCloseWal(Pager *pPager, sqlite3 *db){µ  int rc = SQLITE_OK; Ù7  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL ); ÙL  /* If the log file is not already open, but does exist in the file-system,ÙG  ** it may need to be checkpointed before the connection can switch toÙ3  ** rollback mode. Open it now so this can happen.¤  */¶  if( !pPager->pWal ){¶    int logexists = 0;Ù*    rc = pagerLockDb(pPager, SHARED_LOCK);¸    if( rc==SQLITE_OK ){»      rc = sqlite3OsAccess(ÙF          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists¨      );¥    }Ù%    if( rc==SQLITE_OK && logexists ){Ù       rc = pagerOpenWal(pPager);¥    }£  }¤    ÙG  /* Checkpoint and close the log. Because an EXCLUSIVE lock is held onÙF  ** the database file, the log and log-summary files will be deleted.¤  */Ù&  if( rc==SQLITE_OK && pPager->pWal ){Ù$    rc = pagerExclusiveLock(pPager);¸    if( rc==SQLITE_OK ){ÙB      rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,ÙE                           pPager->pageSize, (u8*)pPager->pTmpSpace);·      pPager->pWal = 0;¿      pagerFixMaplimit(pPager);ÙL      if( rc && !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);¥    }£  }¬  return rc;¡} ½#ifdef SQLITE_ENABLE_SNAPSHOT¢/*ÙG** If this is a WAL database, obtain a snapshot handle for the snapshotÙ.** currently open. Otherwise, return an error.¢*/ÙYSQLITE_PRIVATE int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot){¸  int rc = SQLITE_ERROR;µ  if( pPager->pWal ){Ù9    rc = sqlite3WalSnapshotGet(pPager->pWal, ppSnapshot);£  }¬  return rc;¡} ¢/*ÙG** If this is a WAL database, store a pointer to pSnapshot. Next time aÙD** read transaction is opened, attempt to read from the snapshot it Ù>** identifies. If this is not a WAL database, return an error.¢*/ÙXSQLITE_PRIVATE int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot){µ  int rc = SQLITE_OK;µ  if( pPager->pWal ){Ù4    sqlite3WalSnapshotOpen(pPager->pWal, pSnapshot);¨  }else{¶    rc = SQLITE_ERROR;£  }¬  return rc;¡} ¢/*ÙH** If this is a WAL database, call sqlite3WalSnapshotRecover(). If this Ù*** is not a WAL database, return an error.¢*/Ù>SQLITE_PRIVATE int sqlite3PagerSnapshotRecover(Pager *pPager){©  int rc;µ  if( pPager->pWal ){Ù1    rc = sqlite3WalSnapshotRecover(pPager->pWal);¨  }else{¶    rc = SQLITE_ERROR;£  }¬  return rc;¡}Ù##endif /* SQLITE_ENABLE_SNAPSHOT */½#endif /* !SQLITE_OMIT_WAL */ »#ifdef SQLITE_ENABLE_ZIPVFS¢/*ÙI** A read-lock must be held on the pager when this function is called. IfÙK** the pager is in WAL mode and the WAL file currently contains one or moreÙH** frames, return the size in bytes of the page images stored within theÙG** WAL frames. Otherwise, if this is not a WAL database or the WAL file¶** is empty, return 0.¢*/Ù;SQLITE_PRIVATE int sqlite3PagerWalFramesize(Pager *pPager){Ù)  assert( pPager->eState>=PAGER_READER );Ù+  return sqlite3WalFramesize(pPager->pWal);¡}¦#endif ¿#endif /* SQLITE_OMIT_DISKIO */ ÙO/************** End of pager.c ***********************************************/ÙO/************** Begin file wal.c *********************************************/¢/*²** 2010 February 1¢**ÙC** The author disclaims copyright to this source code.  In place ofÙ&** a legal notice, here is a blessing:¢**Ù#**    May you do good and not evil.Ù?**    May you find forgiveness for yourself and forgive others.Ù<**    May you share freely, never taking more than you give.¢**ÙI*************************************************************************¢**ÙL** This file contains the implementation of a write-ahead log (WAL) used in »** "journal_mode=WAL" mode.¢**Ù$** WRITE-AHEAD LOG (WAL) FILE FORMAT¢**ÙE** A WAL file consists of a header followed by zero or more "frames".ÙC** Each frame records the revised content of a single page from theÙF** database file.  All changes to the database are recorded by writingÙI** frames into the WAL.  Transactions commit when a frame is written thatÙG** contains a commit marker.  A single WAL can and usually does record ÙB** multiple transactions.  Periodically, the content of the WAL isÙC** transferred back into the database file in an operation called a°** "checkpoint".¢**ÙE** A single WAL file can be used multiple times.  In other words, theÙD** WAL can fill up with frames and then be checkpointed and then newÙH** frames can overwrite the old ones.  A WAL always grows from beginningÙE** toward the end.  Checksums and counters attached to each frame areÙD** used to determine which frames within the WAL are valid and whichÙ(** are leftovers from prior checkpoints.¢**ÙI** The WAL header is 32 bytes in size and consists of the following eightÙ-** big-endian 32-bit unsigned integer values:¢**Ù1**     0: Magic number.  0x377f0682 or 0x377f0683Ù1**     4: File format version.  Currently 3007000Ù,**     8: Database page size.  Example: 1024Ù$**    12: Checkpoint sequence numberÙA**    16: Salt-1, random integer incremented with each checkpointÙD**    20: Salt-2, a different random integer changing with each ckptÙK**    24: Checksum-1 (first part of checksum for first 24 bytes of header).ÙL**    28: Checksum-2 (second part of checksum for first 24 bytes of header).¢**ÙE** Immediately following the wal-header are zero or more frames. EachÙK** frame consists of a 24-byte frame-header followed by a <page-size> bytesÙD** of page data. The frame-header is six big-endian 32-bit unsigned ¾** integer values, as follows:¢**¶**     0: Page number.ÙF**     4: For commit records, the size of the database image in pages Ù8**        after the commit. For all other records, zero.Ù)**     8: Salt-1 (copied from the header)Ù)**    12: Salt-2 (copied from the header)µ**    16: Checksum-1.µ**    20: Checksum-2.¢**ÙJ** A frame is considered valid if and only if the following conditions are¨** true:¢**Ù@**    (1) The salt-1 and salt-2 values in the frame-header matchÙ'**        salt values in the wal-header¢**ÙF**    (2) The checksum values in the final 8 bytes of the frame-headerÙB**        exactly match the checksum computed consecutively on theÙH**        WAL header and the first 8 bytes and the content of all framesÙ0**        up to and including the current frame.¢**ÙC** The checksum is computed using 32-bit big-endian integers if theÙD** magic number in the first 4 bytes of the WAL is 0x377f0683 and itÙE** is computed using little-endian if the magic number is 0x377f0682.ÙA** The checksum values are always stored in the frame header in aÙF** big-endian format regardless of which byte order is used to computeÙG** the checksum.  The checksum is computed by interpreting the input asÙF** an even number of unsigned 32-bit integers: x[0] through x[N].  TheÙ1** algorithm used for the checksum is as follows:£** Ù **   for i from 0 to n-1 step 2:·**     s0 += x[i] + s1;¹**     s1 += x[i+1] + s0;«**   endfor¢**ÙJ** Note that s0 and s1 are both weighted checksums using fibonacci weightsÙM** in reverse order (the largest fibonacci weight occurs on the first elementÙA** of the sequence being summed.)  The s1 value spans all 32-bit Ù9** terms of the sequence whereas s0 omits the final term.¢**ÙL** On a checkpoint, the WAL is first VFS.xSync-ed, then valid content of theÙK** WAL is transferred into the database, then the database is VFS.xSync-ed.ÙI** The VFS.xSync operations serve as write barriers - all writes launchedÙJ** before the xSync must complete before any write that launches after the°** xSync begins.¢**ÙH** After each checkpoint, the salt-1 value is incremented and the salt-2ÙI** value is randomized.  This prevents old and new frames in the WAL fromÙK** being considered valid at the same time and being checkpointing togetherµ** following a crash.¢**³** READER ALGORITHM¢**ÙE** To read a page from the database (call it page number P), a readerÙF** first checks the WAL to see if it contains page P.  If so, then theÙE** last valid instance of page P that is a followed by a commit frameÙB** or is a commit frame itself becomes the value read.  If the WALÙE** contains no copies of page P that are valid and which are a commitÙD** frame or are followed by a commit frame, then page P is read fromµ** the database file.¢**ÙH** To start a read transaction, the reader records the index of the lastÙI** valid frame in the WAL.  The reader uses this recorded "mxFrame" valueÙH** for all subsequent read operations.  New transactions can be appendedÙH** to the WAL, but as long as the reader uses its original mxFrame valueÙL** and ignores the newly appended content, it will see a consistent snapshotÙF** of the database from a single point in time.  This technique allowsÙI** multiple concurrent readers to view different versions of the databaseº** content simultaneously.¢**ÙH** The reader algorithm in the previous paragraphs works correctly, but ÙD** because frames for page P can appear anywhere within the WAL, theÙG** reader has to scan the entire WAL looking for page P frames.  If theÙF** WAL is large (multiple megabytes is typical) that scan can be slow,ÙF** and read performance suffers.  To overcome this problem, a separateÙD** data structure called the wal-index is maintained to expedite theÙ*** search for frames of a particular page.£** ³** WAL-INDEX FORMAT¢**ÙK** Conceptually, the wal-index is shared memory, though VFS implementationsÙI** might choose to implement the wal-index using a mmapped file.  BecauseÙL** the wal-index is shared memory, SQLite does not support journal_mode=WAL ÙF** on a network filesystem.  All users of the database must be able to°** share memory.¢**ÙM** In the default unix and windows implementation, the wal-index is a mmappedÙM** file whose name is the database name with a "-shm" suffix added.  For thatÙ<** reason, the wal-index is sometimes called the "shm" file.¢**ÙL** The wal-index is transient.  After a crash, the wal-index can (and shouldÙN** be) reconstructed from the original WAL file.  In fact, the VFS is requiredÙG** to either truncate or zero the header of the wal-index when the lastÙG** connection to it closes.  Because the wal-index is transient, it canÙN** use an architecture-specific format; it does not have to be cross-platform.ÙI** Hence, unlike the database and WAL file formats which store all valuesÙI** as big endian, the wal-index can store multi-byte values in the nativeÙ#** byte order of the host computer.¢**ÙJ** The purpose of the wal-index is to answer this question quickly:  GivenÙH** a page number P and a maximum frame index M, return the index of the ÙH** last frame in the wal before frame M for page P in the WAL, or returnÙ@** NULL if there are no frames for page P in the WAL prior to M.¢**ÙC** The wal-index consists of a header region, followed by an one or·** more index blocks.  ¢**ÙJ** The wal-index header contains the total number of frames within the WAL¸** in the mxFrame field.¢**ÙA** Each index block except for the first contains information on ÙH** HASHTABLE_NPAGE frames. The first index block contains information onÙE** HASHTABLE_NPAGE_ONE frames. The values of HASHTABLE_NPAGE_ONE and ÙI** HASHTABLE_NPAGE are selected so that together the wal-index header andÙG** first index block are the same size as all other index blocks in the­** wal-index.¢**ÙK** Each index block contains two sections, a page-mapping that contains theÙI** database page number associated with each wal frame, and a hash-table ÙJ** that allows readers to query an index block for a specific page number.ÙJ** The page-mapping is an array of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONEÙJ** for the first index block) 32-bit page numbers. The first entry in the ÙK** first index-block contains the database page number corresponding to theÙI** first frame in the WAL file. The first entry in the second index blockÙH** in the WAL file corresponds to the (HASHTABLE_NPAGE_ONE+1)th frame in¶** the log, and so on.¢**ÙJ** The last index block in a wal-index usually contains less than the fullÙG** complement of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE) page-numbers,ÙF** depending on the contents of the WAL file. This does not change theÙK** allocated size of the page-mapping array - the page-mapping array merely»** contains unused entries.¢**Ù?** Even without using the hash table, the last frame for page PÙI** can be found by scanning the page-mapping sections of each index blockÙF** starting with the last index block and moving toward the first, andÙE** within each index block, starting at the end and moving toward theÙE** beginning.  The first entry that equals P corresponds to the frameÙ%** holding the content for that page.¢**ÙG** The hash table consists of HASHTABLE_NSLOT 16-bit unsigned integers.ÙE** HASHTABLE_NSLOT = 2*HASHTABLE_NPAGE, and there is one entry in theÙG** hash table for each page number in the mapping section, so the hash ÙJ** table is never more than half full.  The expected number of collisions ÙE** prior to finding a match is 1.  Each entry of the hash table is anÙ?** 1-based index of an entry in the mapping section of the sameÙD** index block.   Let K be the 1-based index of the largest entry inÙF** the mapping section.  (For index blocks other than the last, K willÙH** always be exactly HASHTABLE_NPAGE (4096) and for the last index blockÙH** K will be (mxFrame%HASHTABLE_NPAGE).)  Unused slots of the hash table¸** contain a value of 0.¢**ÙE** To look for page P in the hash table, first compute a hash iKey on°** P as follows:¢**Ù***      iKey = (P * 383) % HASHTABLE_NSLOT¢**ÙD** Then start scanning entries of the hash table, starting with iKeyÙF** (wrapping around to the beginning when the end of the hash table isÙI** reached) until an unused hash slot is found. Let the first unused slotÙF** be at index iUnused.  (iUnused might be less than iKey if there wasÙE** wrap-around.) Because the hash table is never more than half full,ÙD** the search is guaranteed to eventually hit an unused entry.  Let ÙB** iMax be the value between iKey and iUnused, closest to iUnused,ÙD** where aHash[iMax]==P.  If there is no iMax entry (if there existsÙ@** no hash slot such that aHash[i]==p) then page P is not in theÙC** current index block.  Otherwise the iMax-th mapping entry of theÙE** current index block corresponds to the last entry that references ª** page P.¢**ÙF** A hash search begins with the last index block and moves toward theÙF** first index block, looking for entries corresponding to page P.  OnÙB** average, only two or three slots in each index block need to beÙD** examined in order to either find the last entry for page P, or toÙF** establish that no such entry exists in the block.  Each index blockÙH** holds over 4000 entries.  So two or three index blocks are sufficientÙG** to cover a typical 10 megabyte WAL file, assuming 1K pages.  8 or 10ÙC** comparisons (on average) suffice to either locate a frame in theÙF** WAL or to establish that the frame does not exist in the WAL.  ThisÙ4** is much faster than scanning the entire 10MB WAL.¢**ÙD** Note that entries are added in order of increasing K.  Hence, oneÙG** reader might be using some value K0 and a second reader that startedÙG** at a later time (after additional transactions were added to the WALÙJ** and to the wal-index) might be using a different value K1, where K1>K0.ÙF** Both readers can use the same hash table and mapping section to getÙC** the correct result.  There may be entries in the hash table withÙG** K>K0 but to the first reader, those entries will appear to be unusedÙH** slots in the hash table and so the first reader will get an answer asÙJ** if no values greater than K0 had ever been inserted into the hash tableÙG** in the first place - which is what reader one wants.  Meanwhile, theÙG** second reader using K1 will see additional values that were insertedÙ3** later, which is exactly what reader two wants.  ¢**ÙJ** When a rollback occurs, the value of K is decreased. Hash table entriesÙE** that correspond to frames greater than the new K value are removedÙ%** from the hash table at this point.¢*/·#ifndef SQLITE_OMIT_WAL ¶/* #include "wal.h" */ ¢/*¶** Trace output macros¢*/Ù1#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)Ù'SQLITE_PRIVATE int sqlite3WalTrace = 0;Ù># define WALTRACE(X)  if(sqlite3WalTrace) sqlite3DebugPrintf X¥#else´# define WALTRACE(X)¦#endif ¢/*ÙC** The maximum (and only) versions of the wal and wal-index formatsÙ5** that may be interpreted by this version of SQLite.¢**ÙK** If a client begins recovering a WAL file and finds that (a) the checksumÙH** values in the wal-header are correct and (b) the version field is notÙF** WAL_MAX_VERSION, recovery fails and SQLite returns SQLITE_CANTOPEN.¢**ÙJ** Similarly, if a client successfully reads a wal-index header (i.e. the ÙG** checksum test is successful) and finds that the version field is notÙF** WALINDEX_MAX_VERSION, then no read-transaction is opened and SQLite»** returns SQLITE_CANTOPEN.¢*/Ù$#define WAL_MAX_VERSION      3007000Ù$#define WALINDEX_MAX_VERSION 3007000 ¢/*ÙG** Index numbers for various locking bytes.   WAL_NREADER is the numberÙC** of available reader locks and should be at least 3.  The defaultÙ.** is SQLITE_SHM_NLOCK==8 and  WAL_NREADER==5.¢**ÙK** Technically, the various VFSes are free to implement these locks howeverÙH** they see fit.  However, compatibility is encouraged so that VFSes canÙI** interoperate.  The standard implemention used on both unix and windowsÙ=** is for the index number to indicate a byte offset into theÙJ** WalCkptInfo.aLock[] array in the wal-index header.  In other words, allÙG** locks are on the shm file.  The WALINDEX_LOCK_OFFSET constant (whichÙG** should be 120) is the location in the shm file for the first locking¨** byte.¢*/Ù #define WAL_WRITE_LOCK         0Ù #define WAL_ALL_BUT_WRITE      1Ù #define WAL_CKPT_LOCK          1Ù #define WAL_RECOVER_LOCK       2Ù&#define WAL_READ_LOCK(I)       (3+(I))Ù3#define WAL_NREADER            (SQLITE_SHM_NLOCK-3)  ¹/* Object declarations */Ù'typedef struct WalIndexHdr WalIndexHdr;Ù'typedef struct WalIterator WalIterator;Ù'typedef struct WalCkptInfo WalCkptInfo;  ¢/*ÙE** The following object holds a copy of the wal-index header content.¢**ÙD** The actual header in the wal-index consists of two copies of thisÙ=** object followed by one instance of the WalCkptInfo object.ÙA** For all versions of SQLite through 3.10.0 and probably beyond,Ù@** the locking bytes (WalCkptInfo.aLock) start at offset 120 andÙ&** the total header size is 136 bytes.¢**ÙK** The szPage value can be any power of 2 between 512 and 32768, inclusive.ÙF** Or it can be 1 to represent a 65536-byte page.  The latter case wasÙ9** added in 3.7.1 when support for 64K pages was added.  ¢*/´struct WalIndexHdr {Ù9  u32 iVersion;                   /* Wal-index version */Ù>  u32 unused;                     /* Unused (padding) field */ÙL  u32 iChange;                    /* Counter incremented each transaction */Ù:  u8 isInit;                      /* 1 when initialized */ÙO  u8 bigEndCksum;                 /* True if checksums in WAL are big-endian */ÙK  u16 szPage;                     /* Database page size in bytes. 1==64K */ÙL  u32 mxFrame;                    /* Index of last valid frame in the WAL */ÙA  u32 nPage;                      /* Size of database in pages */ÙE  u32 aFrameCksum[2];             /* Checksum of last frame in log */ÙN  u32 aSalt[2];                   /* Two salt values copied from WAL header */ÙF  u32 aCksum[2];                  /* Checksum over all prior fields */¢}; ¢/*ÙE** A copy of the following object occurs in the wal-index immediatelyÙD** following the second copy of the WalIndexHdr.  This object storesÙ"** information used by checkpoint.¢**ÙF** nBackfill is the number of frames in the WAL that have been writtenÙI** back into the database. (We call the act of moving content from WAL toÙG** database "backfilling".)  The nBackfill number is never greater thanÙC** WalIndexHdr.mxFrame.  nBackfill can only be increased by threadsÙE** holding the WAL_CKPT_LOCK lock (which includes a recovery thread).ÙH** However, a WAL_WRITE_LOCK thread can move the value of nBackfill fromÙ.** mxFrame back to zero when the WAL is reset.¢**ÙI** nBackfillAttempted is the largest value of nBackfill that a checkpointÙL** has attempted to achieve.  Normally nBackfill==nBackfillAtempted, howeverÙG** the nBackfillAttempted is set before any backfilling is done and theÙM** nBackfill is only set after all backfilling completes.  So if a checkpointÙC** crashes, nBackfillAttempted might be larger than nBackfill.  TheÙB** WalIndexHdr.mxFrame must never be less than nBackfillAttempted.¢**ÙL** The aLock[] field is a set of bytes used for locking.  These bytes should¼** never be read or written.¢**ÙG** There is one entry in aReadMark[] for each reader lock.  If a readerÙG** holds read-lock K, then the value in aReadMark[K] is no greater thanÙI** the mxFrame for that reader.  The value READMARK_NOT_USED (0xffffffff)ÙD** for any aReadMark[] means that entry is unused.  aReadMark[0] is ÙJ** a special case; its value is never used and it exists as a place-holderÙH** to avoid having to offset aReadMark[] indexs by one.  Readers holdingÙE** WAL_READ_LOCK(0) always ignore the entire WAL and read all content¾** directly from the database.¢**ÙA** The value of aReadMark[K] may only be changed by a thread thatÙH** is holding an exclusive lock on WAL_READ_LOCK(K).  Thus, the value ofÙI** aReadMark[K] cannot changed while there is a reader is using that markÙF** since the reader will be holding a shared lock on WAL_READ_LOCK(K).¢**ÙG** The checkpointer may only transfer frames from WAL to database whereÙH** the frame numbers are less than or equal to every aReadMark[] that isÙI** in use (that is, every aReadMark[j] for which there is a correspondingÙJ** WAL_READ_LOCK(j)).  New readers (usually) pick the aReadMark[] with theÙL** largest value and will increase an unused aReadMark[] to mxFrame if thereÙH** is not already an aReadMark[] equal to mxFrame.  The exception to theÙN** previous sentence is when nBackfill equals mxFrame (meaning that everythingÙE** in the WAL has been backfilled into the database) then new readersÙH** will choose aReadMark[0] which has value 0 and hence such reader willÙH** get all their all content directly from the database file and ignore «** the WAL.¢**ÙF** Writers normally append new frames to the end of the WAL.  However,ÙE** if nBackfill equals mxFrame (meaning that all WAL content has beenÙF** written back into the database) and if no readers are using the WALÙD** (in other words, if there are no WAL_READ_LOCK(i) where i>0) thenÙH** the writer will first "reset" the WAL back to the beginning and startÙ,** writing new content beginning at frame 1.¢**ÙG** We assume that 32-bit loads are atomic and so no locks are needed inÙ.** order to read from any aReadMark[] entries.¢*/´struct WalCkptInfo {ÙO  u32 nBackfill;                  /* Number of WAL frames backfilled into DB */Ù4  u32 aReadMark[WAL_NREADER];     /* Reader marks */Ù@  u8 aLock[SQLITE_SHM_NLOCK];     /* Reserved space for locks */ÙP  u32 nBackfillAttempted;         /* WAL frames perhaps written, or maybe not */ÙI  u32 notUsed0;                   /* Available for future enhancements */¢};Ù%#define READMARK_NOT_USED  0xffffffff  Ù7/* A block of WALINDEX_LOCK_RESERVED bytes beginning atÙA** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systemsÙB** only support mandatory file-locks, we do not read or write dataÙ:** from the region of the file on which locks are applied.¢*/ÙP#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))ÙH#define WALINDEX_HDR_SIZE    (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo)) Ù-/* Size of header before each frame in wal */¼#define WAL_FRAME_HDRSIZE 24 Ù9/* Size of write ahead log header, including checksum. */¶#define WAL_HDRSIZE 32 ÙG/* WAL magic value. Either this value, or the same value with the leastÙH** significant bit also set (WAL_MAGIC | 0x00000001) is stored in 32-bitÙ8** big-endian format in the first 4 bytes of a WAL file.¢**ÙF** If the LSB is set, then the checksums for each frame within the WALÙB** file are calculated by treating all data as an array of 32-bit ÙD** big-endian words. Otherwise, they are calculated by interpreting Ù*** all data as 32-bit little-endian words.¢*/¼#define WAL_MAGIC 0x377f0682 ¢/*ÙB** Return the offset of frame iFrame in the write-ahead log file, ÙE** assuming a database page size of szPage bytes. The offset returnedÙ7** is to the start of the write-ahead log frame-header.¢*/ÙH#define walFrameOffset(iFrame, szPage) (                               \ÙH  WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)         \¡) ¢/*ÙD** An open write-ahead log file is represented by an instance of the´** following object.¢*/¬struct Wal {Ù?  sqlite3_vfs *pVfs;         /* The VFS used to create pDbFd */ÙD  sqlite3_file *pDbFd;       /* File handle for the database file */Ù;  sqlite3_file *pWalFd;      /* File handle for WAL file */ÙG  u32 iCallback;             /* Value to pass to log callback (or 0) */ÙG  i64 mxWalSize;             /* Truncate WAL to this size upon reset */Ù9  int nWiData;               /* Size of array apWiData */ÙJ  int szFirstBlock;          /* Size of first block written to WAL file */ÙI  volatile u32 **apWiData;   /* Pointer to wal-index content in memory */Ù5  u32 szPage;                /* Database page size */ÙN  i16 readLock;              /* Which read lock is being held.  -1 for none */ÙE  u8 syncFlags;              /* Flags to use to sync header writes */ÙN  u8 exclusiveMode;          /* Non-zero if connection is in exclusive mode */ÙA  u8 writeLock;              /* True if in a write transaction */ÙD  u8 ckptLock;               /* True if holding a checkpoint lock */ÙJ  u8 readOnly;               /* WAL_RDWR, WAL_RDONLY, or WAL_SHM_RDONLY */ÙF  u8 truncateOnCommit;       /* True to truncate WAL file on commit */Ù?  u8 syncHeader;             /* Fsync the WAL header if true */ÙJ  u8 padToSectorBoundary;    /* Pad transactions out to the next sector */ÙJ  u8 bShmUnreliable;         /* SHM content is read-only and unreliable */ÙK  WalIndexHdr hdr;           /* Wal-index header for current transaction */ÙD  u32 minFrame;              /* Ignore wal frames before this one */ÙM  u32 iReCksum;              /* On commit, recalculate checksums from here */Ù3  const char *zWalName;      /* Name of WAL file */ÙP  u32 nCkpt;                 /* Checkpoint sequence counter in the wal-header */³#ifdef SQLITE_DEBUGÙG  u8 lockError;              /* True if a locking error has occurred */¦#endif½#ifdef SQLITE_ENABLE_SNAPSHOTÙE  WalIndexHdr *pSnapshot;    /* Start transaction here if not NULL */¦#endif¢}; ¢/*Ù*** Candidate values for Wal.exclusiveMode.¢*/½#define WAL_NORMAL_MODE     0Ù"#define WAL_EXCLUSIVE_MODE  1     ½#define WAL_HEAPMEMORY_MODE 2 ¢/*Ù#** Possible values for WAL.readOnly¢*/Ù?#define WAL_RDWR        0    /* Normal read/write connection */Ù;#define WAL_RDONLY      1    /* The WAL file is readonly */Ù;#define WAL_SHM_RDONLY  2    /* The SHM file is readonly */ ¢/*ÙF** Each page of the wal-index mapping contains a hash-table made up ofÙ>** an array of HASHTABLE_NSLOT elements of the following type.¢*/´typedef u16 ht_slot; ¢/*ÙE** This structure is used to implement an iterator that loops throughÙI** all frames in the WAL in database page order. Where two or more framesÙF** correspond to the same database page, the iterator visits only the ÙI** frame most recently written to the WAL (in other words, the frame with¶** the largest index).¢**Ù8** The internals of this structure are only accessed by:¢**Ù/**   walIteratorInit() - Create a new iterator,Ù***   walIteratorNext() - Step an iterator,Ù***   walIteratorFree() - Free an iterator.¢**ÙK** This functionality is used by the checkpoint code (see walCheckpoint()).¢*/´struct WalIterator {ÙN  int iPrior;                     /* Last result returned from the iterator */ÙG  int nSegment;                   /* Number of entries in aSegment[] */µ  struct WalSegment {ÙN    int iNext;                    /* Next slot in aIndex[] not yet returned */ÙP    ht_slot *aIndex;              /* i0, i1, i2... such that aPgno[iN] ascend */Ù>    u32 *aPgno;                   /* Array of page numbers. */ÙN    int nEntry;                   /* Nr. of entries in aPgno[] and aIndex[] */ÙM    int iZero;                    /* Frame number associated with aPgno[0] */ÙP  } aSegment[1];                  /* One for every 32KB page in the wal-index */¢}; ¢/*ÙH** Define the parameters of the hash tables in the wal-index file. ThereÙF** is a hash-table following every HASHTABLE_NPAGE page numbers in the­** wal-index.¢**ÙF** Changing any of these constants will alter the wal-index format and¼** create incompatibilities.¢*/ÙJ#define HASHTABLE_NPAGE      4096                 /* Must be power of 2 */ÙG#define HASHTABLE_HASH_1     383                  /* Should be prime */ÙL#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  /* Must be a power of 2 */ £/* ÙF** The block of page numbers associated with the first hash-table in aÙG** wal-index is smaller than usual. This is so that there is a completeÙ9** hash-table on each aligned 32KB page of the wal-index.¢*/ÙP#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32))) ÙF/* The wal-index is divided into pages of WALINDEX_PGSZ bytes each. */ÙC#define WALINDEX_PGSZ   (                                         \ÙC    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \¡) ¢/*ÙH** Obtain a pointer to the iPage'th page of the wal-index. The wal-indexÙC** is broken into pages of WALINDEX_PGSZ bytes. Wal-index pages are¶** numbered from zero.¢**ÙF** If the wal-index is currently smaller the iPage pages then the sizeÙD** of the wal-index might be increased, but only if it is safe to doÙF** so.  It is safe to enlarge the wal-index if pWal->writeLock is trueÙ/** or pWal->exclusiveMode==WAL_HEAPMEMORY_MODE.¢**ÙG** If this call is successful, *ppPage is set to point to the wal-indexÙL** page and SQLITE_OK is returned. If an error (an OOM or VFS error) occurs,ÙA** then an SQLite error code is returned and *ppPage is set to 0.¢*/Ù/static SQLITE_NOINLINE int walIndexPageRealloc(Ù0  Wal *pWal,               /* The WAL context */Ù1  int iPage,               /* The page we seek */Ù<  volatile u32 **ppPage    /* Write the page pointer here */¢){µ  int rc = SQLITE_OK; Ù6  /* Enlarge the pWal->apWiData[] array if required */½  if( pWal->nWiData<=iPage ){Ù'    int nByte = sizeof(u32*)*(iPage+1);¹    volatile u32 **apNew;ÙN    apNew = (volatile u32 **)sqlite3_realloc64((void *)pWal->apWiData, nByte);±    if( !apNew ){²      *ppPage = 0;¿      return SQLITE_NOMEM_BKPT;¥    }Ù+    memset((void*)&apNew[pWal->nWiData], 0,Ù1           sizeof(u32*)*(iPage+1-pWal->nWiData));»    pWal->apWiData = apNew;¼    pWal->nWiData = iPage+1;£  } Ù;  /* Request a pointer to the required page from the VFS */Ù%  assert( pWal->apWiData[iPage]==0 );Ù1  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){ÙM    pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);Ù8    if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;¨  }else{Ù<    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ, ÙA        pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]¦    );ÙN    assert( pWal->apWiData[iPage]!=0 || rc!=SQLITE_OK || pWal->writeLock==0 );Ù:    testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );Ù%    if( (rc&0xff)==SQLITE_READONLY ){Ù'      pWal->readOnly |= WAL_SHM_RDONLY;Ù       if( rc==SQLITE_READONLY ){·        rc = SQLITE_OK;§      }¥    }£  } Ù"  *ppPage = pWal->apWiData[iPage];Ù1  assert( iPage==0 || *ppPage || rc!=SQLITE_OK );¬  return rc;¡}¸static int walIndexPage(Ù0  Wal *pWal,               /* The WAL context */Ù1  int iPage,               /* The page we seek */Ù<  volatile u32 **ppPage    /* Write the page pointer here */¢){ÙE  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){Ù4    return walIndexPageRealloc(pWal, iPage, ppPage);£  }³  return SQLITE_OK;¡} ¢/*ÙB** Return a pointer to the WalCkptInfo structure in the wal-index.¢*/Ù4static volatile WalCkptInfo *walCkptInfo(Wal *pWal){Ù1  assert( pWal->nWiData>0 && pWal->apWiData[0] );ÙL  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);¡} ¢/*ÙB** Return a pointer to the WalIndexHdr structure in the wal-index.¢*/Ù4static volatile WalIndexHdr *walIndexHdr(Wal *pWal){Ù1  assert( pWal->nWiData>0 && pWal->apWiData[0] );Ù2  return (volatile WalIndexHdr*)pWal->apWiData[0];¡} ¢/*ÙE** The argument to this macro must be of type u32. On a little-endianÙH** architecture, it returns the u32 value that results from interpretingÙF** the 4 bytes as a big-endian value. On a big-endian architecture, itÙG** returns the value that would be produced by interpreting the 4 bytesÙ1** of the input value as a little-endian integer.¢*/¹#define BYTESWAP32(x) ( \Ù5    (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8)  \Ù5  + (((x)&0x00FF0000)>>8)  + (((x)&0xFF000000)>>24) \¡) ¢/*Ù>** Generate or extend an 8 byte checksum based on the data in Ù@** array aByte[] and the initial values of aIn[0] and aIn[1] (orÙ+** initial values of 0 and 0 if aIn==NULL).¢**Ù=** The checksum is written back into aOut[] before returning.¢**Ù*** nByte must be a positive multiple of 8.¢*/½static void walChecksumBytes(ÙI  int nativeCksum, /* True for native byte-order, false for non-native */Ù2  u8 *a,           /* Content to be checksummed */ÙK  int nByte,       /* Bytes of content in a[].  Must be a multiple of 8. */Ù5  const u32 *aIn,  /* Initial checksum value input */Ù9  u32 *aOut        /* OUT: Final checksum value output */¢){­  u32 s1, s2;¸  u32 *aData = (u32 *)a;¿  u32 *aEnd = (u32 *)&a[nByte]; ¬  if( aIn ){°    s1 = aIn[0];°    s2 = aIn[1];¨  }else{°    s1 = s2 = 0;£  } µ  assert( nByte>=8 );Ù"  assert( (nByte&0x00000007)==0 ); ´  if( nativeCksum ){¨    do {º      s1 += *aData++ + s2;º      s2 += *aData++ + s1;¹    }while( aData<aEnd );¨  }else{¨    do {Ù&      s1 += BYTESWAP32(aData[0]) + s2;Ù&      s2 += BYTESWAP32(aData[1]) + s1;±      aData += 2;¹    }while( aData<aEnd );£  } ¯  aOut[0] = s1;¯  aOut[1] = s2;¡} Ù%static void walShmBarrier(Wal *pWal){Ù1  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){Ù%    sqlite3OsShmBarrier(pWal->pDbFd);£  }¡} ¢/*Ù@** Write the header information in pWal->hdr into the wal-index.¢**Ù=** The checksum on pWal->hdr is updated before it is written.¢*/Ù(static void walIndexWriteHdr(Wal *pWal){Ù1  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);Ù3  const int nCksum = offsetof(WalIndexHdr, aCksum); ¼  assert( pWal->writeLock );·  pWal->hdr.isInit = 1;Ù,  pWal->hdr.iVersion = WALINDEX_MAX_VERSION;ÙD  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);ÙH  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));¶  walShmBarrier(pWal);ÙH  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));¡} ¢/*ÙH** This function encodes a single frame header and writes it to a bufferÙD** supplied by the caller. A frame-header is made up of a series of Ù*** 4-byte big-endian integers, as follows:¢**¶**     0: Page number.ÙF**     4: For commit records, the size of the database image in pages Ù8**        after the commit. For all other records, zero.Ù-**     8: Salt-1 (copied from the wal-header)Ù-**    12: Salt-2 (copied from the wal-header)µ**    16: Checksum-1.µ**    20: Checksum-2.¢*/»static void walEncodeFrame(Ù;  Wal *pWal,                      /* The write-ahead log */ÙF  u32 iPage,                      /* Database page number for frame */ÙP  u32 nTruncate,                  /* New db size (or 0 for non-commit frames) */Ù<  u8 *aData,                      /* Pointer to page data */ÙE  u8 *aFrame                      /* OUT: Write encoded frame here */¢){ÙL  int nativeCksum;                /* True for native byte-order checksums */Ù&  u32 *aCksum = pWal->hdr.aFrameCksum;Ù"  assert( WAL_FRAME_HDRSIZE==24 );Ù%  sqlite3Put4byte(&aFrame[0], iPage);Ù)  sqlite3Put4byte(&aFrame[4], nTruncate);º  if( pWal->iReCksum==0 ){Ù+    memcpy(&aFrame[8], pWal->hdr.aSalt, 8); Ù<    nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);Ù=    walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);ÙG    walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum); Ù,    sqlite3Put4byte(&aFrame[16], aCksum[0]);Ù,    sqlite3Put4byte(&aFrame[20], aCksum[1]);¨  }else{¾    memset(&aFrame[8], 0, 16);£  }¡} ¢/*Ù@** Check to see if the frame with header in aFrame[] and contentÙA** in aData[] is valid.  If it is a valid frame, fill *piPage andÙB** *pnTruncate and return true.  Return if the frame is not valid.¢*/ºstatic int walDecodeFrame(Ù;  Wal *pWal,                      /* The write-ahead log */ÙK  u32 *piPage,                    /* OUT: Database page number for frame */ÙM  u32 *pnTruncate,                /* OUT: New db size (or 0 if not commit) */ÙK  u8 *aData,                      /* Pointer to page data (for checksum) */Ù2  u8 *aFrame                      /* Frame data */¢){ÙL  int nativeCksum;                /* True for native byte-order checksums */Ù&  u32 *aCksum = pWal->hdr.aFrameCksum;Ù@  u32 pgno;                       /* Page number of the frame */Ù"  assert( WAL_FRAME_HDRSIZE==24 ); ÙA  /* A frame is only valid if the salt values in the frame-headerÙ.  ** match the salt values in the wal-header. ¤  */Ù3  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){­    return 0;£  } ÙC  /* A frame is only valid if the page number is creater than zero.¤  */Ù%  pgno = sqlite3Get4byte(&aFrame[0]);°  if( pgno==0 ){­    return 0;£  } Ù;  /* A frame is only valid if a checksum of the WAL header,Ù?  ** all prior frams, the first 16 bytes of this frame-header, Ù;  ** and the frame-data matches the checksum in the last 8 Ù   ** bytes of this frame-header.¤  */Ù:  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);Ù;  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);ÙE  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);Ù.  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16]) Ù.   || aCksum[1]!=sqlite3Get4byte(&aFrame[20]) ¤  ){º    /* Checksum failed. */­    return 0;£  } ÙH  /* If we reach this point, the frame is valid.  Return the page number¿  ** and the new database size.¤  */±  *piPage = pgno;Ù,  *pnTruncate = sqlite3Get4byte(&aFrame[4]);«  return 1;¡}  Ù1#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)¢/*ÙO** Names of locks.  This routine is used to provide debugging output and is not¿** a part of an ordinary build.¢*/Ù,static const char *walLockName(int lockIdx){Ù   if( lockIdx==WAL_WRITE_LOCK ){¸    return "WRITE-LOCK";Ù%  }else if( lockIdx==WAL_CKPT_LOCK ){·    return "CKPT-LOCK";Ù(  }else if( lockIdx==WAL_RECOVER_LOCK ){º    return "RECOVER-LOCK";¨  }else{º    static char zName[15];Ù;    sqlite3_snprintf(sizeof(zName), zName, "READ-LOCK[%d]",Ù/                     lockIdx-WAL_READ_LOCK(0));±    return zName;£  }¡}Ù9#endif /*defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */¤     ¢/*ÙJ** Set or release locks on the WAL.  Locks are either shared or exclusive.ÙL** A lock cannot be moved directly between shared and exclusive - it must goÙ$** through the unlocked state first.¢**ÙB** In locking_mode=EXCLUSIVE, all of these routines become no-ops.¢*/Ù1static int walLockShared(Wal *pWal, int lockIdx){©  int rc;Ù-  if( pWal->exclusiveMode ) return SQLITE_OK;Ù0  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,Ù=                        SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);Ù2  WALTRACE(("WAL%p: acquire SHARED-%s %s\n", pWal,Ù9            walLockName(lockIdx), rc ? "failed" : "ok"));ÙG  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && rc!=SQLITE_BUSY); )¬  return rc;¡}Ù4static void walUnlockShared(Wal *pWal, int lockIdx){Ù#  if( pWal->exclusiveMode ) return;Ù1  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,Ù@                         SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);ÙG  WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx)));¡}Ù;static int walLockExclusive(Wal *pWal, int lockIdx, int n){©  int rc;Ù-  if( pWal->exclusiveMode ) return SQLITE_OK;Ù0  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,Ù@                        SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);Ù<  WALTRACE(("WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n", pWal,Ù<            walLockName(lockIdx), n, rc ? "failed" : "ok"));ÙG  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && rc!=SQLITE_BUSY); )¬  return rc;¡}Ù>static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){Ù#  if( pWal->exclusiveMode ) return;Ù1  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,ÙC                         SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);Ù9  WALTRACE(("WAL%p: release EXCLUSIVE-%s cnt=%d\n", pWal,Ù'             walLockName(lockIdx), n));¡} ¢/*ÙG** Compute a hash on a page number.  The resulting hash value must landÙJ** between 0 and (HASHTABLE_NSLOT-1).  The walHashNext() function advancesÙ:** the hash to the next value in the event of a collision.¢*/¾static int walHash(u32 iPage){´  assert( iPage>0 );Ù7  assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );Ù8  return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT-1);¡}Ù'static int walNextHash(int iPriorHash){Ù,  return (iPriorHash+1)&(HASHTABLE_NSLOT-1);¡} £/* ÙD** Return pointers to the hash table and page number array stored onÙG** page iHash of the wal-index. The wal-index is broken into 32KB pages¼** numbered starting from 0.¢**ÙF** Set output variable *paHash to point to the start of the hash tableÙA** in the wal-index file. Set *piZero to one less than the frame Ù=** number of the first frame indexed by this hash table. If aÙA** slot in the hash table is set to N, it refers to frame number º** (*piZero+N) in the log.¢**ÙD** Finally, set *paPgno so that *paPgno[1] is the page number of theÙ<** first frame indexed by the hash table, frame (*piZero+1).¢*/¶static int walHashGet(Ù2  Wal *pWal,                      /* WAL handle */Ù?  int iHash,                      /* Find the iHash'th table */ÙB  volatile ht_slot **paHash,      /* OUT: Pointer to hash index */ÙI  volatile u32 **paPgno,          /* OUT: Pointer to page number array */ÙM  u32 *piZero                     /* OUT: Frame associated with *paPgno[0] */¢){Ù3  int rc;                         /* Return code */¶  volatile u32 *aPgno; Ù)  rc = walIndexPage(pWal, iHash, &aPgno);Ù%  assert( rc==SQLITE_OK || iHash>0 ); ¶  if( rc==SQLITE_OK ){®    u32 iZero;¼    volatile ht_slot *aHash; Ù8    aHash = (volatile ht_slot *)&aPgno[HASHTABLE_NPAGE];³    if( iHash==0 ){Ù4      aPgno = &aPgno[WALINDEX_HDR_SIZE/sizeof(u32)];°      iZero = 0;ª    }else{Ù>      iZero = HASHTABLE_NPAGE_ONE + (iHash-1)*HASHTABLE_NPAGE;¥    }¢  ¹    *paPgno = &aPgno[-1];´    *paHash = aHash;´    *piZero = iZero;£  }¬  return rc;¡} ¢/*ÙG** Return the number of the wal-index page that contains the hash-tableÙH** and page-number array that contain entries corresponding to WAL frameÙG** iFrame. The wal-index is broken up into 32KB pages. Wal-index pages Ù ** are numbered starting from 0.¢*/Ù$static int walFramePage(u32 iFrame){ÙO  int iHash = (iFrame+HASHTABLE_NPAGE-HASHTABLE_NPAGE_ONE-1) / HASHTABLE_NPAGE;Ù2  assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)Ù3       && (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE)ÙD       && (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE))ÙC       && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)ÙF       && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))¤  );¯  return iHash;¡} ¢/*ÙC** Return the page number associated with frame iFrame in this WAL.¢*/Ù/static u32 walFramePgno(Wal *pWal, u32 iFrame){Ù#  int iHash = walFramePage(iFrame);±  if( iHash==0 ){ÙI    return pWal->apWiData[0][WALINDEX_HDR_SIZE/sizeof(u32) + iFrame - 1];£  }ÙO  return pWal->apWiData[iHash][(iFrame-1-HASHTABLE_NPAGE_ONE)%HASHTABLE_NPAGE];¡} ¢/*ÙE** Remove entries from the hash table that point to WAL slots greaterº** than pWal->hdr.mxFrame.¢**ÙF** This function is called whenever pWal->hdr.mxFrame is decreased due¾** to a rollback or savepoint.¢**ÙG** At most only the hash table containing pWal->hdr.mxFrame needs to beÙE** updated.  Any later hash tables will be automatically cleared whenÙF** pWal->hdr.mxFrame advances to the point where those hash tables are³** actually needed.¢*/Ù&static void walCleanupHash(Wal *pWal){ÙF  volatile ht_slot *aHash = 0;    /* Pointer to hash table to clear */ÙH  volatile u32 *aPgno = 0;        /* Page number array for hash table */ÙA  u32 iZero = 0;                  /* frame == (aHash[x]+iZero) */ÙE  int iLimit = 0;                 /* Zero values greater than this */ÙJ  int nByte;                      /* Number of bytes to zero in aPgno[] */ÙG  int i;                          /* Used to iterate through aHash[] */ ¼  assert( pWal->writeLock );Ù7  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );Ù5  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE );Ù7  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE+1 ); Ù$  if( pWal->hdr.mxFrame==0 ) return; ÙH  /* Obtain pointers to the hash-table and page-number array containing ÙL  ** the entry that corresponds to frame pWal->hdr.mxFrame. It is guaranteedÙI  ** that the page said hash-table and array reside on is already mapped.¤  */Ù:  assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );Ù<  assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );ÙL  walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &aHash, &aPgno, &iZero); ÙI  /* Zero all hash-table entries that correspond to frame numbers greater¼  ** than pWal->hdr.mxFrame.¤  */Ù%  iLimit = pWal->hdr.mxFrame - iZero;µ  assert( iLimit>0 );Ù#  for(i=0; i<HASHTABLE_NSLOT; i++){º    if( aHash[i]>iLimit ){³      aHash[i] = 0;¥    }£  }¢  ÙG  /* Zero the entries in the aPgno array that correspond to frames withÙ3  ** frame numbers greater than pWal->hdr.mxFrame. ¤  */Ù:  nByte = (int)((char *)aHash - (char *)&aPgno[iLimit+1]);Ù-  memset((void *)&aPgno[iLimit+1], 0, nByte); Ù%#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERTÙI  /* Verify that the every entry in the mapping region is still reachableÙ/  ** via the hash table even after the cleanup.¤  */¯  if( iLimit ){Ù'    int j;           /* Loop counter */Ù#    int iKey;        /* Hash key */½    for(j=1; j<=iLimit; j++){ÙG      for(iKey=walHash(aPgno[j]); aHash[iKey]; iKey=walNextHash(iKey)){Ù#        if( aHash[iKey]==j ) break;§      }¿      assert( aHash[iKey]==j );¥    }£  }Ù+#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */¡}  ¢/*ÙC** Set an entry in the wal-index that will map database page number¿** pPage into WAL frame iFrame.¢*/Ù<static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){Ù3  int rc;                         /* Return code */ÙN  u32 iZero = 0;                  /* One less than frame number of aPgno[1] */Ù9  volatile u32 *aPgno = 0;        /* Page number array */Ù2  volatile ht_slot *aHash = 0;    /* Hash table */ ÙF  rc = walHashGet(pWal, walFramePage(iFrame), &aHash, &aPgno, &iZero); ÙF  /* Assuming the wal-index file was successfully mapped, populate theÙ,  ** page number array and hash table entry.¤  */¶  if( rc==SQLITE_OK ){Ù6    int iKey;                     /* Hash table key */ÙI    int idx;                      /* Value to write to hash-table slot */ÙA    int nCollide;                 /* Number of hash collisions */ ¹    idx = iFrame - iZero;Ù+    assert( idx <= HASHTABLE_NSLOT/2 + 1 );¤    ÙJ    /* If this is the first entry to be added to this hash-table, zero theÙ>    ** entire hash table and aPgno[] array before proceeding. ¦    */±    if( idx==1 ){ÙI      int nByte = (int)((u8 *)&aHash[HASHTABLE_NSLOT] - (u8 *)&aPgno[1]);Ù)      memset((void*)&aPgno[1], 0, nByte);¥    } ÙG    /* If the entry in aPgno[] is already set, then the previous writerÙJ    ** must have exited unexpectedly in the middle of a transaction (afterÙF    ** writing one or more dirty pages to the WAL to free up memory). ÙH    ** Remove the remnants of that writers uncommitted transaction from Ù5    ** the hash-table before writing any new entries.¦    */µ    if( aPgno[idx] ){»      walCleanupHash(pWal);¼      assert( !aPgno[idx] );¥    } Ù@    /* Write the aPgno[] array entry and the hash-table slot. */³    nCollide = idx;ÙB    for(iKey=walHash(iPage); aHash[iKey]; iKey=walNextHash(iKey)){Ù7      if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;¥    }·    aPgno[idx] = iPage;¿    aHash[iKey] = (ht_slot)idx; Ù%#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERTÙI    /* Verify that the number of entries in the hash table exactly equalsÙ3    ** the number of entries in the mapping region.¦    */¥    {Ù)      int i;           /* Loop counter */Ù@      int nEntry = 0;  /* Number of entries in the hash table */ÙB      for(i=0; i<HASHTABLE_NSLOT; i++){ if( aHash[i] ) nEntry++; }¼      assert( nEntry==idx );¥    } ÙE    /* Verify that the every entry in the mapping region is reachableÙK    ** via the hash table.  This turns out to be a really, really expensiveÙB    ** thing to check, so only do this occasionally - not on every±    ** iteration.¦    */¹    if( (idx&0x3ff)==0 ){Ù)      int i;           /* Loop counter */¼      for(i=1; i<=idx; i++){ÙI        for(iKey=walHash(aPgno[i]); aHash[iKey]; iKey=walNextHash(iKey)){Ù%          if( aHash[iKey]==i ) break;©        }Ù!        assert( aHash[iKey]==i );§      }¥    }Ù+#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */£  }  ¬  return rc;¡}  ¢/*Ù>** Recover the wal-index by reading the write-ahead log file. ¢**ÙA** This routine first tries to establish an exclusive lock on theÙC** wal-index to prevent other threads/processes from doing anythingÙ<** with the WAL or wal-index while recovery is running.  TheÙ@** WAL_RECOVER_LOCK is also held so that other threads will knowÙ@** that this thread is running recovery.  If unable to establishÙ9** the necessary locks, this routine returns SQLITE_BUSY.¢*/Ù&static int walIndexRecover(Wal *pWal){Ù3  int rc;                         /* Return Code */Ù8  i64 nSize;                      /* Size of log file */¾  u32 aFrameCksum[2] = {0, 0};ÙJ  int iLock;                      /* Lock offset to lock for checkpoint */ ÙJ  /* Obtain an exclusive lock on all byte in the locking range not alreadyÙF  ** locked by the caller. The caller is guaranteed to have locked theÙJ  ** WAL_WRITE_LOCK byte, and may have also locked the WAL_CKPT_LOCK byte.ÙK  ** If successful, the same bytes that are locked here are unlocked before»  ** this function returns.¤  */Ù3  assert( pWal->ckptLock==1 || pWal->ckptLock==0 );Ù0  assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );Ù-  assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );¼  assert( pWal->writeLock );Ù-  iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;Ù=  rc = walLockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);¶  if( rc==SQLITE_OK ){ÙA    rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);¸    if( rc!=SQLITE_OK ){Ù>      walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);¥    }£  }«  if( rc ){®    return rc;£  } Ù1  WALTRACE(("WAL%p: recovery begin...\n", pWal)); Ù-  memset(&pWal->hdr, 0, sizeof(WalIndexHdr)); Ù/  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);¶  if( rc!=SQLITE_OK ){¸    goto recovery_error;£  } º  if( nSize>WAL_HDRSIZE ){ÙF    u8 aBuf[WAL_HDRSIZE];         /* Buffer to load WAL header into */ÙL    u8 *aFrame = 0;               /* Malloc'd buffer to load entire frame */ÙJ    int szFrame;                  /* Number of bytes in buffer aFrame[] */ÙM    u8 *aData;                    /* Pointer to data part of aFrame buffer */Ù@    int iFrame;                   /* Index of last frame read */ÙI    i64 iOffset;                  /* Next offset to read from log file */ÙF    int szPage;                   /* Page size according to the log */ÙH    u32 magic;                    /* Magic value read from WAL header */ÙH    u32 version;                  /* Magic value read from WAL header */ÙC    int isValid;                  /* True if this frame is valid */ Ù!    /* Read in the WAL header. */Ù;    rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);¸    if( rc!=SQLITE_OK ){º      goto recovery_error;¥    } ÙJ    /* If the database page size is not a power of two, or is greater thanÙJ    ** SQLITE_MAX_PAGE_SIZE, conclude that the WAL file contains no valid ÙI    ** data. Similarly, if the 'magic' value is invalid, ignore the whole°    ** WAL file.¦    */Ù&    magic = sqlite3Get4byte(&aBuf[0]);Ù'    szPage = sqlite3Get4byte(&aBuf[8]);Ù&    if( (magic&0xFFFFFFFE)!=WAL_MAGIC º     || szPage&(szPage-1) Ù$     || szPage>SQLITE_MAX_PAGE_SIZE ³     || szPage<512 ¦    ){´      goto finished;¥    }Ù3    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);º    pWal->szPage = szPage;Ù-    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);Ù+    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8); Ù8    /* Verify that the WAL header checksum is correct */Ù>    walChecksumBytes(pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN, Ù7        aBuf, WAL_HDRSIZE-2*4, 0, pWal->hdr.aFrameCksum¦    );Ù<    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])Ù<     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])¦    ){´      goto finished;¥    } ÙC    /* Verify that the version number on the WAL format is one thatÙ     ** are able to understand */Ù(    version = sqlite3Get4byte(&aBuf[4]);Ù#    if( version!=WAL_MAX_VERSION ){Ù       rc = SQLITE_CANTOPEN_BKPT;´      goto finished;¥    } Ù.    /* Malloc a buffer to read frames into. */Ù)    szFrame = szPage + WAL_FRAME_HDRSIZE;Ù-    aFrame = (u8 *)sqlite3_malloc64(szFrame);²    if( !aFrame ){½      rc = SQLITE_NOMEM_BKPT;º      goto recovery_error;¥    }Ù'    aData = &aFrame[WAL_FRAME_HDRSIZE]; Ù,    /* Read all frames from the log file. */¯    iFrame = 0;ÙI    for(iOffset=WAL_HDRSIZE; (iOffset+szFrame)<=nSize; iOffset+=szFrame){ÙF      u32 pgno;                   /* Database page number for frame */ÙF      u32 nTruncate;              /* dbsize field from frame header */ Ù/      /* Read and decode the next log frame. */¯      iFrame++;ÙA      rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);Ù       if( rc!=SQLITE_OK ) break;ÙG      isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);»      if( !isValid ) break;Ù.      rc = walIndexAppend(pWal, iFrame, pgno);Ù       if( rc!=SQLITE_OK ) break; Ù>      /* If nTruncate is non-zero, this is a commit record. */¶      if( nTruncate ){Ù#        pWal->hdr.mxFrame = iFrame;Ù$        pWal->hdr.nPage = nTruncate;ÙA        pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));Ù"        testcase( szPage<=32768 );Ù"        testcase( szPage>=65536 );Ù2        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];Ù2        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];§      }¥    } ¹    sqlite3_free(aFrame);£  } ©finished:¶  if( rc==SQLITE_OK ){Ù     volatile WalCkptInfo *pInfo;ª    int i;Ù.    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];Ù.    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];»    walIndexWriteHdr(pWal); ÙH    /* Reset the checkpoint-header. This is safe because this thread is ÙJ    ** currently holding locks that exclude all other readers, writers andµ    ** checkpointers.¦    */¾    pInfo = walCkptInfo(pWal);¹    pInfo->nBackfill = 0;Ù2    pInfo->nBackfillAttempted = pWal->hdr.mxFrame;¼    pInfo->aReadMark[0] = 0;ÙI    for(i=1; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;ÙD    if( pWal->hdr.mxFrame ) pInfo->aReadMark[1] = pWal->hdr.mxFrame; ÙH    /* If more than one frame was recovered from the log file, report anÙL    ** event via sqlite3_log(). This is to help with identifying performanceÙF    ** problems caused by applications routinely shutting down withoutÙ"    ** checkpointing the log file.¦    */º    if( pWal->hdr.nPage ){Ù,      sqlite3_log(SQLITE_NOTICE_RECOVER_WAL,Ù1          "recovered %d frames from WAL file %s",Ù+          pWal->hdr.mxFrame, pWal->zWalName¨      );¥    }£  } ¯recovery_error:ÙA  WALTRACE(("WAL%p: recovery %s\n", pWal, rc ? "failed" : "ok"));Ù:  walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);Ù<  walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);¬  return rc;¡} ¢/*»** Close an open wal-index.¢*/Ù3static void walIndexClose(Wal *pWal, int isDelete){ÙI  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE || pWal->bShmUnreliable ){ª    int i;Ù#    for(i=0; i<pWal->nWiData; i++){Ù.      sqlite3_free((void *)pWal->apWiData[i]);¼      pWal->apWiData[i] = 0;¥    }£  }Ù1  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){Ù-    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);£  }¡} £/* ÙF** Open a connection to the WAL file zWalName. The database file must ÙI** already be opened on connection pDbFd. The buffer that zWalName pointsÙE** to must remain valid for the lifetime of the returned Wal* handle.¢**ÙG** A SHARED lock should be held on the database file when this functionÙE** is called. The purpose of this SHARED lock is to prevent any otherÙF** client from unlinking the WAL or wal-index file. If another processÙH** were to do this just after this client opened one of these files, theÙ ** system would be badly broken.¢**ÙE** If the log file is successfully opened, SQLITE_OK is returned and ÙB** *ppWal is set to point to a new WAL handle. If an error occurs,ÙB** an SQLite error code is returned and *ppWal is left unmodified.¢*/Ù"SQLITE_PRIVATE int sqlite3WalOpen(ÙL  sqlite3_vfs *pVfs,              /* vfs module to open wal and wal-index */Ù>  sqlite3_file *pDbFd,            /* The open database file */Ù<  const char *zWalName,           /* Name of the WAL file */ÙG  int bNoShm,                     /* True to run in heap-memory mode */ÙJ  i64 mxWalSize,                  /* Truncate WAL to this size on reset */ÙA  Wal **ppWal                     /* OUT: Allocated Wal handle */¢){Ù3  int rc;                         /* Return Code */ÙE  Wal *pRet;                      /* Object to allocate and return */Ù@  int flags;                      /* Flags passed to OsOpen() */ Ù$  assert( zWalName && zWalName[0] );²  assert( pDbFd ); ÙM  /* In the amalgamation, the os_unix.c and os_win.c source files come beforeÙL  ** this source file.  Verify that the #defines of the locking byte offsetsÙI  ** in os_unix.c and os_win.c agree with the WALINDEX_LOCK_OFFSET value.ÙM  ** For that matter, if the lock offset ever changes from its initial designÙL  ** value of 120, we need to know that so there is an assert() to check it.¤  */Ù&  assert( 120==WALINDEX_LOCK_OFFSET );Ù#  assert( 136==WALINDEX_HDR_SIZE );³#ifdef WIN_SHM_BASEÙ/  assert( WIN_SHM_BASE==WALINDEX_LOCK_OFFSET );¦#endif´#ifdef UNIX_SHM_BASEÙ0  assert( UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET );¦#endif  Ù5  /* Allocate an instance of struct Wal to return. */­  *ppWal = 0;Ù?  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);®  if( !pRet ){½    return SQLITE_NOMEM_BKPT;£  } ´  pRet->pVfs = pVfs;Ù*  pRet->pWalFd = (sqlite3_file *)&pRet[1];¶  pRet->pDbFd = pDbFd;¶  pRet->readLock = -1;¾  pRet->mxWalSize = mxWalSize;¼  pRet->zWalName = zWalName;·  pRet->syncHeader = 1;Ù   pRet->padToSectorBoundary = 1;ÙH  pRet->exclusiveMode = (bNoShm ? WAL_HEAPMEMORY_MODE: WAL_NORMAL_MODE); Ù5  /* Open file handle on the write-ahead log file. */ÙE  flags = (SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_WAL);ÙB  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);Ù4  if( rc==SQLITE_OK && flags&SQLITE_OPEN_READONLY ){Ù     pRet->readOnly = WAL_RDONLY;£  } ¶  if( rc!=SQLITE_OK ){»    walIndexClose(pRet, 0);Ù!    sqlite3OsClose(pRet->pWalFd);·    sqlite3_free(pRet);¨  }else{Ù4    int iDC = sqlite3OsDeviceCharacteristics(pDbFd);Ù@    if( iDC & SQLITE_IOCAP_SEQUENTIAL ){ pRet->syncHeader = 0; }Ù1    if( iDC & SQLITE_IOCAP_POWERSAFE_OVERWRITE ){Ù$      pRet->padToSectorBoundary = 0;¥    }²    *ppWal = pRet;Ù(    WALTRACE(("WAL%d: opened\n", pRet));£  }¬  return rc;¡} ¢/*ÙC** Change the size to which the WAL file is trucated on each reset.¢*/Ù;SQLITE_PRIVATE void sqlite3WalLimit(Wal *pWal, i64 iLimit){Ù&  if( pWal ) pWal->mxWalSize = iLimit;¡} ¢/*ÙF** Find the smallest page number out of all pages held in the WAL thatÙF** has not been returned by any prior invocation of this method on theÙG** same WalIterator object.   Write into *piFrame the frame index whereÙH** that page was last written into the WAL.  Write into *piPage the pageª** number.¢**ÙE** Return 0 on success.  If there are no pages in the WAL with a pageÙ-** number larger than *piPage, then return 1.¢*/»static int walIteratorNext(Ù.  WalIterator *p,               /* Iterator */ÙK  u32 *piPage,                  /* OUT: The page number of the next page */ÙG  u32 *piFrame                  /* OUT: Wal frame index of next page */¢){ÙK  u32 iMin;                     /* Result pgno must be greater than iMin */ÙM  u32 iRet = 0xFFFFFFFF;        /* 0xffffffff is never a valid page number */ÙB  int i;                        /* For looping through segments */ ³  iMin = p->iPrior;¼  assert( iMin<0xffffffff );Ù"  for(i=p->nSegment-1; i>=0; i--){Ù2    struct WalSegment *pSegment = &p->aSegment[i];Ù.    while( pSegment->iNext<pSegment->nEntry ){ÙC      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];µ      if( iPg>iMin ){·        if( iPg<iRet ){µ          iRet = iPg;ÙI          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];©        }®        break;§      }¸      pSegment->iNext++;¥    }£  } ½  *piPage = p->iPrior = iRet;¼  return (iRet==0xFFFFFFFF);¡} ¢/*ÙC** This function merges two sorted lists into a single sorted list.¢**Ù?** aLeft[] and aRight[] are arrays of indices.  The sort key isÙG** aContent[aLeft[]] and aContent[aRight[]].  Upon entry, the following½** is guaranteed for all J<K:¢**Ù1**        aContent[aLeft[J]] < aContent[aLeft[K]]Ù3**        aContent[aRight[J]] < aContent[aRight[K]]¢**ÙI** This routine overwrites aRight[] with a new (probably longer) sequenceÙI** of indices such that the aRight[] contains every index that appears inÙH** either aLeft[] or the old aRight[] and such that the second condition¶** above is still met.¢**ÙC** The aContent[aLeft[X]] values will be unique for all X.  And theÙE** aContent[aRight[X]] values will be unique too.  But there might beÙ0** one or more combinations of X and Y such that¢**ÙJ**      aLeft[X]!=aRight[Y]  &&  aContent[aLeft[X]] == aContent[aRight[Y]]¢**ÙD** When that happens, omit the aLeft[X] and use the aRight[Y] index.¢*/µstatic void walMerge(ÙH  const u32 *aContent,            /* Pages in wal - keys for the sort */Ù@  ht_slot *aLeft,                 /* IN: Left hand input list */ÙE  int nLeft,                      /* IN: Elements in array *paLeft */ÙE  ht_slot **paRight,              /* IN/OUT: Right hand input list */ÙD  int *pnRight,                   /* IN/OUT: Elements in *paRight */Ù8  ht_slot *aTmp                   /* Temporary buffer */¢){Ù>  int iLeft = 0;                  /* Current index in aLeft */Ù?  int iRight = 0;                 /* Current index in aRight */ÙF  int iOut = 0;                   /* Current index in output buffer */¸  int nRight = *pnRight;½  ht_slot *aRight = *paRight; Ù   assert( nLeft>0 && nRight>0 );Ù(  while( iRight<nRight || iLeft<nLeft ){´    ht_slot logpage;°    Pgno dbpage; ¶    if( (iLeft<nLeft) ÙK     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])¦    ){¿      logpage = aLeft[iLeft++];ª    }else{Ù!      logpage = aRight[iRight++];¥    }¿    dbpage = aContent[logpage]; »    aTmp[iOut++] = logpage;Ù@    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++; Ù<    assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );Ù@    assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );£  } ³  *paRight = aLeft;²  *pnRight = iOut;Ù,  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);¡} ¢/*ÙD** Sort the elements in list aList using aContent[] as the sort key.Ù>** Remove elements with duplicate keys, preferring to keep the¹** larger aList[] values.¢**ÙB** The aList[] entries are indices into aContent[].  The values inÙ0** aList[] are to be sorted so that for all J<K:¢**Ù/**      aContent[aList[J]] < aContent[aList[K]]¢**¼** For any X and Y such that¢**Ù0**      aContent[aList[X]] == aContent[aList[Y]]¢**ÙF** Keep the larger of the two values aList[X] and aList[Y] and discard¯** the smaller.¢*/¹static void walMergesort(Ù4  const u32 *aContent,            /* Pages in wal */ÙO  ht_slot *aBuffer,               /* Buffer of at least *pnList items to use */Ù<  ht_slot *aList,                 /* IN/OUT: List to sort */ÙM  int *pnList                     /* IN/OUT: Number of elements in aList[] */¢){²  struct Sublist {ÙC    int nList;                    /* Number of elements in aList */ÙC    ht_slot *aList;               /* Pointer to sub-list content */¤  }; Ù:  const int nList = *pnList;      /* Size of input list */ÙI  int nMerge = 0;                 /* Number of elements in list aMerge */Ù9  ht_slot *aMerge = 0;            /* List to be merged */Ù=  int iList;                      /* Index into input list */Ù=  u32 iSub = 0;                   /* Index into aSub array */Ù:  struct Sublist aSub[13];        /* Array of sub-lists */ Ù   memset(aSub, 0, sizeof(aSub));Ù.  assert( nList<=HASHTABLE_NPAGE && nList>0 );Ù6  assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) ); Ù%  for(iList=0; iList<nList; iList++){¯    nMerge = 1;»    aMerge = &aList[iList];Ù+    for(iSub=0; iList & (1<<iSub); iSub++){¸      struct Sublist *p;Ù%      assert( iSub<ArraySize(aSub) );¶      p = &aSub[iSub];Ù0      assert( p->aList && p->nList<=(1<<iSub) );Ù7      assert( p->aList==&aList[iList&~((2<<iSub)-1)] );ÙH      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);¥    }¾    aSub[iSub].aList = aMerge;¾    aSub[iSub].nList = nMerge;£  } Ù,  for(iSub++; iSub<ArraySize(aSub); iSub++){¼    if( nList & (1<<iSub) ){¸      struct Sublist *p;Ù%      assert( iSub<ArraySize(aSub) );¶      p = &aSub[iSub];Ù$      assert( p->nList<=(1<<iSub) );Ù7      assert( p->aList==&aList[nList&~((2<<iSub)-1)] );ÙH      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);¥    }£  }º  assert( aMerge==aList );³  *pnList = nMerge; ³#ifdef SQLITE_DEBUG£  {ª    int i;½    for(i=1; i<*pnList; i++){Ù:      assert( aContent[aList[i]] > aContent[aList[i-1]] );¥    }£  }¦#endif¡} £/* Ù3** Free an iterator allocated by walIteratorInit().¢*/Ù,static void walIteratorFree(WalIterator *p){²  sqlite3_free(p);¡} ¢/*ÙE** Construct a WalInterator object that can be used to loop over all ÙH** pages in the WAL following frame nBackfill in ascending order. FramesÙK** nBackfill or earlier may be included - excluding them is an optimizationÙ2** only. The caller must hold the checkpoint lock.¢**ÙH** On success, make *pp point to the newly allocated WalInterator objectÙE** return SQLITE_OK. Otherwise, return an error code. If this routineÙ3** returns an error, the value of *pp is undefined.¢**ÙE** The calling routine should invoke walIteratorFree() to destroy theÙ3** WalIterator object when it has finished with it.¢*/ÙGstatic int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){Ù4  WalIterator *p;                 /* Return value */ÙC  int nSegment;                   /* Number of segments to merge */Ù9  u32 iLast;                      /* Last frame in log */ÙC  int nByte;                      /* Number of bytes to allocate */Ù9  int i;                          /* Iterator variable */ÙE  ht_slot *aTmp;                  /* Temp space used by merge-sort */Ù3  int rc = SQLITE_OK;             /* Return Code */ ÙB  /* This routine only runs while holding the checkpoint lock. AndÙF  ** it only runs if there is actually content in the log (mxFrame>0).¤  */Ù2  assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );¼  iLast = pWal->hdr.mxFrame; Ù2  /* Allocate space for the WalIterator object. */Ù%  nSegment = walFramePage(iLast) + 1;¾  nByte = sizeof(WalIterator) Ù0        + (nSegment-1)*sizeof(struct WalSegment)Ù         + iLast*sizeof(ht_slot);Ù-  p = (WalIterator *)sqlite3_malloc64(nByte);«  if( !p ){½    return SQLITE_NOMEM_BKPT;£  }¶  memset(p, 0, nByte);¹  p->nSegment = nSegment; ÙH  /* Allocate temporary space used by the merge-sort routine. This blockÙ:  ** of memory will be freed before this function returns.¤  */Ù%  aTmp = (ht_slot *)sqlite3_malloc64(ÙE      sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)¤  );®  if( !aTmp ){»    rc = SQLITE_NOMEM_BKPT;£  } ÙE  for(i=walFramePage(nBackfill+1); rc==SQLITE_OK && i<nSegment; i++){¼    volatile ht_slot *aHash;®    u32 iZero;¸    volatile u32 *aPgno; Ù5    rc = walHashGet(pWal, i, &aHash, &aPgno, &iZero);¸    if( rc==SQLITE_OK ){Ù8      int j;                      /* Counter variable */ÙI      int nEntry;                 /* Number of entries in this segment */ÙE      ht_slot *aIndex;            /* Sorted index for this segment */ ®      aPgno++;¼      if( (i+1)==nSegment ){Ù&        nEntry = (int)(iLast - iZero);¬      }else{Ù2        nEntry = (int)((u32*)aHash - (u32*)aPgno);§      }Ù>      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[iZero];®      iZero++;¢  ¾      for(j=0; j<nEntry; j++){¿        aIndex[j] = (ht_slot)j;§      }Ù8      walMergesort((u32 *)aPgno, aTmp, aIndex, &nEntry);Ù#      p->aSegment[i].iZero = iZero;Ù%      p->aSegment[i].nEntry = nEntry;Ù%      p->aSegment[i].aIndex = aIndex;Ù*      p->aSegment[i].aPgno = (u32 *)aPgno;¥    }£  }µ  sqlite3_free(aTmp); ¶  if( rc!=SQLITE_OK ){·    walIteratorFree(p);ª    p = 0;£  }ª  *pp = p;¬  return rc;¡} ¢/*ÙM** Attempt to obtain the exclusive WAL lock defined by parameters lockIdx andÙH** n. If the attempt fails and parameter xBusy is not NULL, then it is aÙG** busy-handler function. Invoke it and retry the lock until either theÙ?** lock is successfully obtained or the busy-handler returns 0.¢*/·static int walBusyLock(Ù6  Wal *pWal,                      /* WAL connection */ÙB  int (*xBusy)(void*),            /* Function to call when busy */ÙI  void *pBusyArg,                 /* Context argument for xBusyHandler */ÙD  int lockIdx,                    /* Offset of first byte to lock */Ù?  int n                           /* Number of bytes to lock */¢){©  int rc;¦  do {Ù,    rc = walLockExclusive(pWal, lockIdx, n);Ù8  }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );¬  return rc;¡} ¢/*ÙI** The cache of the wal-index header must be valid to call this function.Ù6** Return the page-size in bytes used by the database.¢*/Ù"static int walPagesize(Wal *pWal){ÙE  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);¡} ¢/*Ù<** The following is guaranteed when this function is called:¢**Ù **   a) the WRITER lock is held,Ù6**   b) the entire log file has been checkpointed, andÙF**   c) any existing readers are reading exclusively from the databaseÙI**      file - there are no readers that may attempt to read a frame fromµ**      the log file.¢**ÙF** This function updates the shared-memory structures so that the nextÙE** client to write to the database (which may be this one) does so byÙ1** writing frames into the start of the log file.¢**ÙE** The value of parameter salt1 is used as the aSalt[1] value in the ÙI** new wal-index header. It should be passed a pseudo-random value (i.e. Ù+** one obtained from sqlite3_randomness()).¢*/Ù0static void walRestartHdr(Wal *pWal, u32 salt1){Ù2  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);Ù4  int i;                          /* Loop counter */Ù>  u32 *aSalt = pWal->hdr.aSalt;   /* Big-endian salt values */°  pWal->nCkpt++;¸  pWal->hdr.mxFrame = 0;ÙG  sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));Ù)  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);¹  walIndexWriteHdr(pWal);·  pInfo->nBackfill = 0;Ù   pInfo->nBackfillAttempted = 0;º  pInfo->aReadMark[1] = 0;ÙG  for(i=2; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;Ù#  assert( pInfo->aReadMark[0]==0 );¡} ¢/*ÙJ** Copy as much content as we can from the WAL back into the database fileÙH** in response to an sqlite3_wal_checkpoint() request or the equivalent.¢**ÙI** The amount of information copies from WAL to database might be limitedÙH** by active readers.  This routine will never overwrite a database pageÙ+** that a concurrent reader might be using.¢**ÙG** All I/O barrier operations (a.k.a fsyncs) occur in this routine whenÙD** SQLite is in WAL-mode in synchronous=NORMAL.  That means that if ÙC** checkpoints are always run by a background thread or background ÙH** process, foreground threads will never block on a lengthy fsync call.¢**ÙG** Fsync is called on the WAL before writing content out of the WAL andÙI** into the database.  This ensures that if the new content is persistentÙH** in the WAL and can be recovered following a power-loss or hard reset.¢**ÙH** Fsync is also called on the database file if (and only if) the entireÙI** WAL content is copied into the database file.  This second fsync makesÙF** it safe to delete the WAL since the new content will persist in the±** database file.¢**ÙM** This routine uses and updates the nBackfill field of the wal-index header.ÙH** This is the only routine that will increase the value of nBackfill.  ÙK** (A WAL reset or recovery will revert nBackfill to zero, but not increase®** its value.)¢**ÙF** The caller must be holding sufficient locks to ensure that no otherÙE** checkpoint is running (in any other thread or process) at the same¨** time.¢*/¹static int walCheckpoint(Ù6  Wal *pWal,                      /* Wal connection */ÙK  sqlite3 *db,                    /* Check for interrupts on this handle */ÙG  int eMode,                      /* One of PASSIVE, FULL or RESTART */ÙB  int (*xBusy)(void*),            /* Function to call when busy */ÙI  void *pBusyArg,                 /* Context argument for xBusyHandler */ÙA  int sync_flags,                 /* Flags for OsSync() (or 0) */Ù?  u8 *zBuf                        /* Temporary buffer to use */¢){Ù3  int rc = SQLITE_OK;             /* Return code */Ù:  int szPage;                     /* Database page-size */Ù<  WalIterator *pIter = 0;         /* Wal iterator context */ÙC  u32 iDbpage = 0;                /* Next database page to write */ÙM  u32 iFrame = 0;                 /* Wal frame containing data for iDbpage */ÙH  u32 mxSafeFrame;                /* Max frame that can be backfilled */ÙB  u32 mxPage;                     /* Max database page to write */Ù4  int i;                          /* Loop counter */ÙI  volatile WalCkptInfo *pInfo;    /* The checkpoint status information */ ½  szPage = walPagesize(pWal);¼  testcase( szPage<=32768 );¼  testcase( szPage>=65536 );¼  pInfo = walCkptInfo(pWal);Ù+  if( pInfo->nBackfill<pWal->hdr.mxFrame ){ ÙL    /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invokedÙ0    ** in the SQLITE_CHECKPOINT_PASSIVE mode. */Ù;    assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 ); ÙL    /* Compute in mxSafeFrame the index of the last frame of the WAL that isÙH    ** safe to write into the database.  Frames beyond mxSafeFrame mightÙJ    ** overwrite database pages that are in use by active readers and thusÙ)    ** cannot be backfilled from the WAL.¦    */Ù$    mxSafeFrame = pWal->hdr.mxFrame;½    mxPage = pWal->hdr.nPage;Ù!    for(i=1; i<WAL_NREADER; i++){ÙG      /* Thread-sanitizer reports that the following is an unsafe read,ÙI      ** as some other thread may be in the process of updating the valueÙH      ** of the aReadMark[] slot. The assumption here is that if that isÙF      ** happening, the other client may only be increasing the value,ÙG      ** not decreasing it. So assuming either that either the "old" orÙI      ** "new" version of the value is read, and not some arbitrary valueÙH      ** that would never be written by a real client, things are still ²      ** safe.  */Ù"      u32 y = pInfo->aReadMark[i];º      if( mxSafeFrame>y ){Ù'        assert( y<=pWal->hdr.mxFrame );ÙE        rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);¼        if( rc==SQLITE_OK ){ÙI          pInfo->aReadMark[i] = (i==1 ? mxSafeFrame : READMARK_NOT_USED);Ù8          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);Ù$        }else if( rc==SQLITE_BUSY ){º          mxSafeFrame = y;´          xBusy = 0;®        }else{Ù!          goto walcheckpoint_out;©        }§      }¥    } ¿    /* Allocate the iterator */Ù'    if( pInfo->nBackfill<mxSafeFrame ){Ù;      rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);Ù*      assert( rc==SQLITE_OK || pIter==0 );¥    } ­    if( pIterÙP     && (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0),1))==SQLITE_OK¦    ){ÙG      i64 nSize;                    /* Current size of database file */Ù'      u32 nBackfill = pInfo->nBackfill; Ù.      pInfo->nBackfillAttempted = mxSafeFrame; Ù       /* Sync the WAL to disk */ÙD      rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags)); ÙF      /* If the database may grow as a result of this checkpoint, hintÙA      ** about the eventual size of the db file to the VFS layer.¨      */º      if( rc==SQLITE_OK ){Ù*        i64 nReq = ((i64)mxPage * szPage);Ù4        rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);Ù*        if( rc==SQLITE_OK && nSize<nReq ){ÙO          sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);©        }§      }  ÙP      /* Iterate through the contents of the WAL, copying data to the db file */ÙM      while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){´        i64 iOffset;Ù6        assert( walFramePgno(pWal, iFrame)==iDbpage );Ù#        if( db->u1.isInterrupted ){ÙG          rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;°          break;©        }ÙH        if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){³          continue;©        }ÙE        iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;ÙJ        /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */Ù@        rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);Ù"        if( rc!=SQLITE_OK ) break;Ù*        iOffset = (iDbpage-1)*(i64)szPage;Ù(        testcase( IS_BIG_INT(iOffset) );Ù@        rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);Ù"        if( rc!=SQLITE_OK ) break;§      } Ù0      /* If work was actually accomplished... */º      if( rc==SQLITE_OK ){Ù6        if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){Ù1          i64 szDb = pWal->hdr.nPage*(i64)szPage;Ù'          testcase( IS_BIG_INT(szDb) );Ù4          rc = sqlite3OsTruncate(pWal->pDbFd, szDb);¾          if( rc==SQLITE_OK ){ÙI            rc = sqlite3OsSync(pWal->pDbFd, CKPT_SYNC_FLAGS(sync_flags));«          }©        }¼        if( rc==SQLITE_OK ){Ù)          pInfo->nBackfill = mxSafeFrame;©        }§      } Ù:      /* Release the reader lock held while backfilling */Ù4      walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);¥    } º    if( rc==SQLITE_BUSY ){ÙG      /* Reset the return code so as not to report a checkpoint failureÙ3      ** just because there are active readers.  */µ      rc = SQLITE_OK;¥    }£  } ÙK  /* If this is an SQLITE_CHECKPOINT_RESTART or TRUNCATE operation, and theÙH  ** entire wal file has been copied into the database file, then block ÙK  ** until all readers have finished using the wal file. This ensures that ÙE  ** the next process to write to the database restarts the wal file.¤  */Ù:  if( rc==SQLITE_OK && eMode!=SQLITE_CHECKPOINT_PASSIVE ){¾    assert( pWal->writeLock );Ù-    if( pInfo->nBackfill<pWal->hdr.mxFrame ){·      rc = SQLITE_BUSY;Ù1    }else if( eMode>=SQLITE_CHECKPOINT_RESTART ){°      u32 salt1;Ù$      sqlite3_randomness(4, &salt1);Ù4      assert( pInfo->nBackfill==pWal->hdr.mxFrame );ÙO      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);º      if( rc==SQLITE_OK ){Ù0        if( eMode==SQLITE_CHECKPOINT_TRUNCATE ){ÙM          /* IMPLEMENTATION-OF: R-44699-57140 This mode works the same way asÙE          ** SQLITE_CHECKPOINT_RESTART with the addition that it alsoÙA          ** truncates the log file to zero bytes just prior to a¿          ** successful return.¬          **ÙH          ** In theory, it might be safe to do this without updating theÙK          ** wal-index header in shared memory, as all subsequent reader orÙH          ** writer clients should see that the entire log file has beenÙK          ** checkpointed and behave accordingly. This seems unsafe though,ÙJ          ** as it would leave the system in a state where the contents ofÙC          ** the wal-index header do not match the contents of the ÙG          ** file-system. To avoid this, update the wal-index header toÙG          ** indicate that the log file contains zero valid frames.  */Ù%          walRestartHdr(pWal, salt1);Ù2          rc = sqlite3OsTruncate(pWal->pWalFd, 0);©        }ÙB        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);§      }¥    }£  } ³ walcheckpoint_out:¹  walIteratorFree(pIter);¬  return rc;¡} ¢/*ÙH** If the WAL file is currently larger than nMax bytes in size, truncateÙJ** it to exactly nMax bytes. If an error occurs while doing so, ignore it.¢*/Ù.static void walLimitSize(Wal *pWal, i64 nMax){©  i64 sz;©  int rx;½  sqlite3BeginBenignMalloc();Ù,  rx = sqlite3OsFileSize(pWal->pWalFd, &sz);Ù&  if( rx==SQLITE_OK && (sz > nMax ) ){Ù/    rx = sqlite3OsTruncate(pWal->pWalFd, nMax);£  }»  sqlite3EndBenignMalloc();«  if( rx ){ÙA    sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);£  }¡} ¢/*Ù$** Close a connection to a log file.¢*/Ù#SQLITE_PRIVATE int sqlite3WalClose(Ù4  Wal *pWal,                      /* Wal to close */Ù:  sqlite3 *db,                    /* For interrupt flag */ÙH  int sync_flags,                 /* Flags to pass to OsSync() (or 0) */«  int nBuf,ÙE  u8 *zBuf                        /* Buffer of at least nBuf bytes */¢){µ  int rc = SQLITE_OK;­  if( pWal ){ÙN    int isDelete = 0;             /* True to unlink wal and wal-index files */ ÙK    /* If an EXCLUSIVE lock can be obtained on the database file (using theÙH    ** ordinary, rollback-mode locking methods, this guarantees that theÙI    ** connection associated with this log file is the only connection toÙI    ** the database. In this case checkpoint the database and unlink bothÙ#    ** the wal and wal-index files.¦    **Ù;    ** The EXCLUSIVE lock is not released before returning.¦    */¯    if( zBuf!=0ÙK     && SQLITE_OK==(rc = sqlite3OsLock(pWal->pDbFd, SQLITE_LOCK_EXCLUSIVE))¦    ){Ù1      if( pWal->exclusiveMode==WAL_NORMAL_MODE ){Ù1        pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;§      }Ù*      rc = sqlite3WalCheckpoint(pWal, db, ÙG          SQLITE_CHECKPOINT_PASSIVE, 0, 0, sync_flags, nBuf, zBuf, 0, 0¨      );º      if( rc==SQLITE_OK ){º        int bPersist = -1;Ù!        sqlite3OsFileControlHint(Ù<            pWal->pDbFd, SQLITE_FCNTL_PERSIST_WAL, &bPersistª        );º        if( bPersist!=1 ){ÙG          /* Try to delete the WAL file if the checkpoint completed andÙG          ** fsyned (rc==SQLITE_OK) and if we are not in persistent-walÙ           ** mode (!bPersist) */·          isDelete = 1;Ù'        }else if( pWal->mxWalSize>=0 ){ÙI          /* Try to truncate the WAL file to zero bytes if the checkpointÙK          ** completed and fsynced (rc==SQLITE_OK) and we are in persistentÙJ          ** WAL mode (bPersist) and if the PRAGMA journal_size_limit is aÙL          ** non-negative value (pWal->mxWalSize>=0).  Note that we truncateÙH          ** to zero bytes as truncating to the journal_size_limit mightÙ1          ** leave a corrupt WAL file on disk. */Ù           walLimitSize(pWal, 0);©        }§      }¥    } Ù"    walIndexClose(pWal, isDelete);Ù!    sqlite3OsClose(pWal->pWalFd);³    if( isDelete ){Ù!      sqlite3BeginBenignMalloc();Ù5      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);¿      sqlite3EndBenignMalloc();¥    }Ù(    WALTRACE(("WAL%p: closed\n", pWal));Ù)    sqlite3_free((void *)pWal->apWiData);·    sqlite3_free(pWal);£  }¬  return rc;¡} ¢/*ÙB** Try to read the wal-index header.  Return 0 on success and 1 if¶** there is a problem.¢**ÙF** The wal-index is in shared memory.  Another thread or process mightÙE** be writing the header at the same time this procedure is trying toÙJ** read it, which might result in inconsistency.  A dirty read is detectedÙG** by verifying that both copies of the header are the same and also by¼** a checksum on the header.¢**ÙI** If and only if the read is consistent and the header is different fromÙH** pWal->hdr, then pWal->hdr is updated to the content of the new header½** and *pChanged is set to 1.¢**ÙD** If the checksum cannot be verified return non-zero. If the headerÙ?** is read successfully and the checksum verified, return zero.¢*/Ù4static int walIndexTryHdr(Wal *pWal, int *pChanged){ÙF  u32 aCksum[2];                  /* Checksum on the header content */ÙH  WalIndexHdr h1, h2;             /* Two copies of the header content */Ù?  WalIndexHdr volatile *aHdr;     /* Header in shared memory */ ÙE  /* The first page of the wal-index must be mapped at this point. */Ù1  assert( pWal->nWiData>0 && pWal->apWiData[0] ); ÙH  /* Read the header. This might happen concurrently with a write to theÙ<  ** same area of shared memory on a different CPU in a SMP,ÙA  ** meaning it is possible that an inconsistent snapshot is readÙ5  ** from the file. If this happens, return non-zero.¤  **ÙJ  ** There are two copies of the header at the beginning of the wal-index.ÙM  ** When reading, read [0] first then [1].  Writes are in the reverse order.ÙJ  ** Memory barriers are used to prevent the compiler or the hardware fromÙ%  ** reordering the reads and writes.¤  */»  aHdr = walIndexHdr(pWal);Ù,  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));¶  walShmBarrier(pWal);Ù,  memcpy(&h2, (void *)&aHdr[1], sizeof(h2)); Ù(  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){Ù     return 1;   /* Dirty read */¥  }  µ  if( h1.isInit==0 ){Ù;    return 1;   /* Malformed header - probably all zeros */£  }ÙI  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);Ù;  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){Ù-    return 1;   /* Checksum does not match */£  } Ù5  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){²    *pChanged = 1;Ù1    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));ÙO    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);Ù$    testcase( pWal->szPage<=32768 );Ù$    testcase( pWal->szPage>=65536 );£  } Ù6  /* The header was successfully read. Return zero. */«  return 0;¡} ¢/*ÙB** This is the value that walTryBeginRead returns when it needs to®** be retried.¢*/·#define WAL_RETRY  (-1) ¢/*ÙC** Read the wal-index header from the wal-index and into pWal->hdr.ÙB** If the wal-header appears to be corrupt, try to reconstruct theÙ+** wal-index from the WAL before returning.¢**ÙC** Set *pChanged to 1 if the wal-index header value in pWal->hdr isÙG** changed by this operation.  If pWal->hdr is unchanged, set *pChanged¨** to 0.¢**ÙC** If the wal-index header is successfully read, return SQLITE_OK. Ù"** Otherwise an SQLite error code.¢*/Ù5static int walIndexReadHdr(Wal *pWal, int *pChanged){Ù3  int rc;                         /* Return code */ÙD  int badHdr;                     /* True if a header read failed */ÙL  volatile u32 *page0;            /* Chunk of wal-index containing header */ ÙE  /* Ensure that page 0 of the wal-index (the page that contains the ÙG  ** wal-index header) is mapped. Return early if an error occurs here.¤  */µ  assert( pChanged );Ù%  rc = walIndexPage(pWal, 0, &page0);¶  if( rc!=SQLITE_OK ){ÙO    assert( rc!=SQLITE_READONLY ); /* READONLY changed to OK in walIndexPage */Ù'    if( rc==SQLITE_READONLY_CANTINIT ){ÙI      /* The SQLITE_READONLY_CANTINIT return means that the shared-memoryÙG      ** was openable but is not writable, and this thread is unable toÙL      ** confirm that another write-capable connection has the shared-memoryÙH      ** open, and hence the content of the shared-memory is unreliable,ÙH      ** since the shared-memory might be inconsistent with the WAL fileÙ5      ** and there is no writer on hand to fix it. */¹      assert( page0==0 );Ù#      assert( pWal->writeLock==0 );Ù0      assert( pWal->readOnly & WAL_SHM_RDONLY );¿      pWal->bShmUnreliable = 1;Ù0      pWal->exclusiveMode = WAL_HEAPMEMORY_MODE;´      *pChanged = 1;ª    }else{Ù?      return rc; /* Any other non-OK return is just an error */¥    }¨  }else{ÙM    /* page0 can be NULL if the SHM is zero bytes in size and pWal->writeLockÙ6    ** is zero, which prevents the SHM from growing */¹    testcase( page0!=0 );£  }Ù+  assert( page0!=0 || pWal->writeLock==0 ); ÙH  /* If the first page of the wal-index has been mapped, try to read theÙI  ** wal-index header immediately, without holding any lock. This usuallyÙI  ** works, but may fail if the wal-index header is corrupt or currently Ù1  ** being modified by another thread or process.¤  */Ù8  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1); ÙB  /* If the first attempt failed, it might have been due to a raceÙ7  ** with a writer.  So get a WRITE lock and try again.¤  */Ù,  assert( badHdr==0 || pWal->writeLock==0 );¯  if( badHdr ){ÙG    if( pWal->bShmUnreliable==0 && (pWal->readOnly & WAL_SHM_RDONLY) ){ÙB      if( SQLITE_OK==(rc = walLockShared(pWal, WAL_WRITE_LOCK)) ){Ù.        walUnlockShared(pWal, WAL_WRITE_LOCK);Ù&        rc = SQLITE_READONLY_RECOVERY;§      }ÙL    }else if( SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1)) ){º      pWal->writeLock = 1;Ù<      if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){Ù0        badHdr = walIndexTryHdr(pWal, pChanged);µ        if( badHdr ){ÙJ          /* If the wal-index header is still malformed even while holdingÙL          ** a WRITE lock, it can only mean that the header is corrupted andÙL          ** needs to be reconstructed.  So run recovery to do exactly that.¬          */Ù%          rc = walIndexRecover(pWal);¸          *pChanged = 1;©        }§      }º      pWal->writeLock = 0;Ù2      walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);¥    }£  } ÙI  /* If the header is read successfully, check the version number to makeÙH  ** sure the wal-index was not constructed with some future format thatÙ.  ** this version of SQLite cannot understand.¤  */Ù>  if( badHdr==0 && pWal->hdr.iVersion!=WALINDEX_MAX_VERSION ){¾    rc = SQLITE_CANTOPEN_BKPT;£  }½  if( pWal->bShmUnreliable ){¸    if( rc!=SQLITE_OK ){½      walIndexClose(pWal, 0);¿      pWal->bShmUnreliable = 0;Ù8      assert( pWal->nWiData>0 && pWal->apWiData[0]==0 );ÙI      /* walIndexRecover() might have returned SHORT_READ if a concurrentÙI      ** writer truncated the WAL out from under it.  If that happens, itÙK      ** indicates that a writer has fixed the SHM file for us, so retry */Ù7      if( rc==SQLITE_IOERR_SHORT_READ ) rc = WAL_RETRY;¥    }Ù*    pWal->exclusiveMode = WAL_NORMAL_MODE;£  } ¬  return rc;¡} ¢/*ÙJ** Open a transaction in a connection where the shared-memory is read-onlyÙO** and where we cannot verify that there is a separate write-capable connectionÙB** on hand to keep the shared-memory up-to-date with the WAL file.¢**ÙI** This can happen, for example, when the shared-memory is implemented byÙF** memory-mapping a *-shm file, where a prior writer has shut down andÙH** left the *-shm file on disk, and now the present connection is tryingÙE** to use that database but lacks write permission on the *-shm file.ÙJ** Other scenarios are also possible, depending on the VFS implementation.¢**°** Precondition:¢**ÙH**    The *-wal file has been read and an appropriate wal-index has beenÙI**    constructed in pWal->apWiData[] using heap memory instead of shared®**    memory. ¢**ÙD** If this function returns SQLITE_OK, then the read transaction hasÙF** been successfully opened. In this case output variable (*pChanged) ÙC** is set to true before returning if the caller should discard theÙC** contents of the page cache before proceeding. Or, if it returns ÙD** WAL_RETRY, then the heap memory wal-index has been discarded and ÙA** the caller should retry opening the read transaction from the Ù;** beginning (including attempting to map the *-shm file). ¢**Ù8** If an error occurs, an SQLite error code is returned.¢*/Ù;static int walBeginShmUnreliable(Wal *pWal, int *pChanged){ÙI  i64 szWal;                      /* Size of wal file on disk in bytes */ÙL  i64 iOffset;                    /* Current offset when reading wal file */ÙF  u8 aBuf[WAL_HDRSIZE];           /* Buffer to load WAL header into */ÙL  u8 *aFrame = 0;                 /* Malloc'd buffer to load entire frame */ÙJ  int szFrame;                    /* Number of bytes in buffer aFrame[] */ÙM  u8 *aData;                      /* Pointer to data part of aFrame buffer */ÙB  volatile void *pDummy;          /* Dummy argument for xShmMap */Ù3  int rc;                         /* Return code */ÙK  u32 aSaveCksum[2];              /* Saved copy of pWal->hdr.aFrameCksum */ Ù!  assert( pWal->bShmUnreliable );Ù,  assert( pWal->readOnly & WAL_SHM_RDONLY );Ù1  assert( pWal->nWiData>0 && pWal->apWiData[0] ); ÙA  /* Take WAL_READ_LOCK(0). This has the effect of preventing anyÙ>  ** writers from running a checkpoint, but does not stop them¿  ** from running recovery.  */Ù-  rc = walLockShared(pWal, WAL_READ_LOCK(0));¶  if( rc!=SQLITE_OK ){Ù)    if( rc==SQLITE_BUSY ) rc = WAL_RETRY;Ù"    goto begin_unreliable_shm_out;£  }µ  pWal->readLock = 0; ÙN  /* Check to see if a separate writer has attached to the shared-memory area,ÙI  ** thus making the shared-memory "reliable" again.  Do this by invokingÙF  ** the xShmMap() routine of the VFS and looking to see if the returnÙ<  ** is SQLITE_READONLY instead of SQLITE_READONLY_CANTINIT.¤  **ÙH  ** If the shared-memory is now "reliable" return WAL_RETRY, which willÙC  ** cause the heap-memory WAL-index to be discarded and the actualÙ+  ** shared memory to be used in its place.¤  **ÙK  ** This step is important because, even though this connection is holdingÙE  ** the WAL_READ_LOCK(0) which prevents a checkpoint, a writer mightÙB  ** have already checkpointed the WAL file and, while the currentÙC  ** is active, wrap the WAL and start overwriting frames that thisº  ** process wants to use.¤  **ÙG  ** Once sqlite3OsShmMap() has been called for an sqlite3_file and hasÙL  ** returned any SQLITE_READONLY value, it must return only SQLITE_READONLYÙN  ** or SQLITE_READONLY_CANTINIT or some error for all subsequent invocations,ÙI  ** even if some external agent does a "chmod" to make the shared-memoryÙ?  ** writable by us, until sqlite3OsShmUnmap() has been called.Ù5  ** This is a requirement on the VFS implementation.¥   */ÙB  rc = sqlite3OsShmMap(pWal->pDbFd, 0, WALINDEX_PGSZ, 0, &pDummy);ÙP  assert( rc!=SQLITE_OK ); /* SQLITE_OK not possible for read-only connection */Ù%  if( rc!=SQLITE_READONLY_CANTINIT ){Ù0    rc = (rc==SQLITE_READONLY ? WAL_RETRY : rc);Ù"    goto begin_unreliable_shm_out;£  } ÙL  /* We reach this point only if the real shared-memory is still unreliable.ÙE  ** Assume the in-memory WAL-index substitute is correct and load it´  ** into pWal->hdr.¤  */ÙD  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr)); ÙF  /* Make sure some writer hasn't come in and changed the WAL file outÙA  ** from under us, then disconnected, while we were not looking.¤  */Ù/  rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);¶  if( rc!=SQLITE_OK ){Ù"    goto begin_unreliable_shm_out;£  }º  if( szWal<WAL_HDRSIZE ){ÙC    /* If the wal file is too small to contain a wal-header and theÙG    ** wal-index header has mxFrame==0, then it must be safe to proceedÙE    ** reading the database file only. However, the page cache cannotÙI    ** be trusted, as a read/write connection may have connected, writtenÙH    ** the db, run a checkpoint, truncated the wal file and disconnectedÙ5    ** since this client's last read transaction.  */²    *pChanged = 1;Ù8    rc = (pWal->hdr.mxFrame==0 ? SQLITE_OK : WAL_RETRY);Ù"    goto begin_unreliable_shm_out;£  } ÙE  /* Check the salt keys at the start of the wal file still match. */Ù9  rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);¶  if( rc!=SQLITE_OK ){Ù"    goto begin_unreliable_shm_out;£  }Ù/  if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){ÙF    /* Some writer has wrapped the WAL file while we were not looking.ÙF    ** Return WAL_RETRY which will cause the in-memory WAL-index to be²    ** rebuilt. */³    rc = WAL_RETRY;Ù"    goto begin_unreliable_shm_out;£  } Ù-  /* Allocate a buffer to read frames into */Ù1  szFrame = pWal->hdr.szPage + WAL_FRAME_HDRSIZE;Ù+  aFrame = (u8 *)sqlite3_malloc64(szFrame);²  if( aFrame==0 ){»    rc = SQLITE_NOMEM_BKPT;Ù"    goto begin_unreliable_shm_out;£  }Ù%  aData = &aFrame[WAL_FRAME_HDRSIZE]; ÙD  /* Check to see if a complete transaction has been appended to theÙE  ** wal file since the heap-memory wal-index was created. If so, theÙA  ** heap-memory wal-index is discarded and WAL_RETRY returned to´  ** the caller.  */Ù+  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];Ù+  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];ÙE  for(iOffset=walFrameOffset(pWal->hdr.mxFrame+1, pWal->hdr.szPage); ¾      iOffset+szFrame<=szWal; ¶      iOffset+=szFrame¤  ){ÙD    u32 pgno;                   /* Database page number for frame */ÙD    u32 nTruncate;              /* dbsize field from frame header */ Ù-    /* Read and decode the next log frame. */Ù?    rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);¾    if( rc!=SQLITE_OK ) break;ÙH    if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break; ÙE    /* If nTruncate is non-zero, then a complete transaction has beenÙF    ** appended to this wal file. Set rc to WAL_RETRY and break out of´    ** the loop.  */´    if( nTruncate ){µ      rc = WAL_RETRY;¬      break;¥    }£  }Ù+  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];Ù+  pWal->hdr.aFrameCksum[1] = aSaveCksum[1]; º begin_unreliable_shm_out:·  sqlite3_free(aFrame);¶  if( rc!=SQLITE_OK ){ª    int i;Ù#    for(i=0; i<pWal->nWiData; i++){Ù-      sqlite3_free((void*)pWal->apWiData[i]);¼      pWal->apWiData[i] = 0;¥    }½    pWal->bShmUnreliable = 0;Ù'    sqlite3WalEndReadTransaction(pWal);²    *pChanged = 1;£  }¬  return rc;¡} ¢/*ÙI** Attempt to start a read transaction.  This might fail due to a race orÙI** other transient condition.  When that happens, it returns WAL_RETRY toÙ?** indicate to the caller that it is safe to retry immediately.¢**Ù@** On success return SQLITE_OK.  On a permanent failure (such anÙA** I/O error or an SQLITE_BUSY because another process is runningÙ*** recovery) return a positive error code.¢**ÙG** The useWal parameter is true to force the use of the WAL and disableÙD** the case where the WAL is bypassed because it has been completelyÙI** checkpointed.  If useWal==0 then this routine calls walIndexReadHdr() ÙB** to make a copy of the wal-index header into pWal->hdr.  If the ÙI** wal-index header has changed, *pChanged is set to 1 (as an indication ÙG** to the caller that the local page cache is obsolete and needs to be ÙH** flushed.)  When useWal==1, the wal-index header is assumed to alreadyÙ2** be loaded and the pChanged parameter is unused.¢**ÙH** The caller must set the cnt parameter to the number of prior calls toÙH** this routine during the current read attempt that returned WAL_RETRY.ÙG** This routine will start taking more aggressive measures to clear theÙK** race conditions after multiple WAL_RETRY returns, and after an excessiveÙ@** number of errors will ultimately return SQLITE_PROTOCOL.  TheÙJ** SQLITE_PROTOCOL return indicates that some other process has gone rogueÙJ** and is not honoring the locking protocol.  There is a vanishingly smallÙK** chance that SQLITE_PROTOCOL could be returned because of a run of reallyÙH** bad luck when there is lots of contention for the wal-index, but thatÙG** possibility is so small that it can be safely neglected, we believe.¢**Ù3** On success, this routine obtains a read lock on Ù@** WAL_READ_LOCK(pWal->readLock).  The pWal->readLock integer isÙK** in the range 0 <= pWal->readLock < WAL_NREADER.  If pWal->readLock==(-1)ÙG** that means the Wal does not hold any read lock.  The reader must notÙE** access any database page that is modified by a WAL frame up to andÙE** including frame number aReadMark[pWal->readLock].  The reader willÙK** use WAL frames up to and including pWal->hdr.mxFrame if pWal->readLock>0Ù?** Or if pWal->readLock==0, then the reader will ignore the WALÙB** completely and get all content directly from the database file.ÙF** If the useWal parameter is 1 then the WAL will never be ignored andÙ<** this routine will always set pWal->readLock>0 on success.ÙF** When the read transaction is completed, the caller must release theÙF** lock on WAL_READ_LOCK(pWal->readLock) and set pWal->readLock to -1.¢**ÙG** This routine uses the nBackfill and aReadMark[] fields of the headerÙA** to select a particular WAL_READ_LOCK() that strives to let theÙF** checkpoint process do as much work as possible.  This routine mightÙG** update values of the aReadMark[] array in the header, but if it doesÙB** so it takes care to hold an exclusive lock on the correspondingÙ)** WAL_READ_LOCK() while changing values.¢*/ÙJstatic int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){ÙK  volatile WalCkptInfo *pInfo;    /* Checkpoint information in wal-index */ÙA  u32 mxReadMark;                 /* Largest aReadMark[] value */ÙJ  int mxI;                        /* Index of largest aReadMark[] value */Ù4  int i;                          /* Loop counter */Ù4  int rc = SQLITE_OK;             /* Return code  */Ù<  u32 mxFrame;                    /* Wal frame to lock to */ Ù<  assert( pWal->readLock<0 );     /* Not currently locked */ Ù9  /* useWal may only be set for read/write connections */Ù>  assert( (pWal->readOnly & WAL_SHM_RDONLY)==0 || useWal==0 ); ÙG  /* Take steps to avoid spinning forever if there is a protocol error.¤  **ÙG  ** Circumstances that cause a RETRY should only last for the briefestÙH  ** instances of time.  No I/O or other system calls are done while theÙH  ** locks are held, so the locks should not be held for very long. But ÙH  ** if we are unlucky, another process that is holding a lock might getÙG  ** paged out or take a page-fault that is time-consuming to resolve, ÙK  ** during the few nanoseconds that it is holding the lock.  In that case,Ù;  ** it might take longer than normal for the lock to free.¤  **ÙF  ** After 5 RETRYs, we begin calling sqlite3OsSleep().  The first fewÙJ  ** calls to sqlite3OsSleep() have a delay of 1 microsecond.  Really thisÙH  ** is more of a scheduler yield than an actual delay.  But on the 10thÙI  ** an subsequent retries, the delays start becoming longer and longer, ÙI  ** so that on the 100th (and last) RETRY we delay for 323 milliseconds.ÙC  ** The total delay time before giving up is less than 10 seconds.¤  */®  if( cnt>5 ){ÙI    int nDelay = 1;                      /* Pause time in microseconds */²    if( cnt>100 ){Ù&      VVA_ONLY( pWal->lockError = 1; )½      return SQLITE_PROTOCOL;¥    }Ù.    if( cnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;Ù'    sqlite3OsSleep(pWal->pVfs, nDelay);£  } °  if( !useWal ){¼    assert( rc==SQLITE_OK );Ù"    if( pWal->bShmUnreliable==0 ){Ù+      rc = walIndexReadHdr(pWal, pChanged);¥    }º    if( rc==SQLITE_BUSY ){ÙH      /* If there is not a recovery running in another thread or processÙH      ** then convert BUSY errors to WAL_RETRY.  If recovery is known toÙI      ** be running, convert BUSY to BUSY_RECOVERY.  There is a race hereÙI      ** which might cause WAL_RETRY to be returned even if BUSY_RECOVERYÙI      ** would be technically correct.  But the race is benign since withÙI      ** WAL_RETRY this routine will be called again and will probably beÙ'      ** right on the second iteration.¨      */Ù!      if( pWal->apWiData[0]==0 ){ÙN        /* This branch is taken when the xShmMap() method returns SQLITE_BUSY.ÙL        ** We assume this is a transient condition, so return WAL_RETRY. TheÙK        ** xShmMap() implementation used by the default unix and win32 VFS ÙI        ** modules may return SQLITE_BUSY due to a race condition in the ÙH        ** code that determines whether or not the shared-memory region Ù@        ** must be zeroed before the requested page is returned.ª        */·        rc = WAL_RETRY;ÙJ      }else if( SQLITE_OK==(rc = walLockShared(pWal, WAL_RECOVER_LOCK)) ){Ù0        walUnlockShared(pWal, WAL_RECOVER_LOCK);·        rc = WAL_RETRY;Ù"      }else if( rc==SQLITE_BUSY ){Ù"        rc = SQLITE_BUSY_RECOVERY;§      }¥    }¸    if( rc!=SQLITE_OK ){°      return rc;¥    }Ù$    else if( pWal->bShmUnreliable ){Ù3      return walBeginShmUnreliable(pWal, pChanged);¥    }£  } ¼  assert( pWal->nWiData>0 );Ù!  assert( pWal->apWiData[0]!=0 );¼  pInfo = walCkptInfo(pWal);Ù4  if( !useWal && pInfo->nBackfill==pWal->hdr.mxFrame½#ifdef SQLITE_ENABLE_SNAPSHOTÙ2   && (pWal->pSnapshot==0 || pWal->hdr.mxFrame==0)¦#endif¤  ){Ù?    /* The WAL has been completely backfilled (or it is empty).Ù!    ** and can be safely ignored.¦    */Ù/    rc = walLockShared(pWal, WAL_READ_LOCK(0));¸    walShmBarrier(pWal);¸    if( rc==SQLITE_OK ){ÙO      if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){ÙH        /* It is not safe to allow the reader to continue here if framesÙN        ** may have been appended to the log before READ_LOCK(0) was obtained.ÙM        ** When holding READ_LOCK(0), the reader ignores the entire log file,ÙF        ** which implies that the database file contains a trustworthyÙJ        ** snapshot. Since holding READ_LOCK(0) prevents a checkpoint fromÙ.        ** happening, this is usually correct.ª        **ÙK        ** However, if frames have been appended to the log (or if the log ÙJ        ** is wrapped and written for that matter) before the READ_LOCK(0)ÙH        ** is obtained, that is not necessarily true. A checkpointer mayÙJ        ** have started to backfill the appended frames but crashed beforeÙE        ** it finished. Leaving a corrupt image in the database file.ª        */Ù0        walUnlockShared(pWal, WAL_READ_LOCK(0));¹        return WAL_RETRY;§      }¹      pWal->readLock = 0;·      return SQLITE_OK;Ù     }else if( rc!=SQLITE_BUSY ){°      return rc;¥    }£  } ÙB  /* If we get this far, it means that the reader will want to useÙC  ** the WAL to get at content from recent commits.  The job now isÙ@  ** to select one of the aReadMark[] entries that is closest toÙ=  ** but not exceeding pWal->hdr.mxFrame and lock that entry.¤  */±  mxReadMark = 0;ª  mxI = 0;¾  mxFrame = pWal->hdr.mxFrame;½#ifdef SQLITE_ENABLE_SNAPSHOTÙ<  if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){Ù'    mxFrame = pWal->pSnapshot->mxFrame;£  }¦#endif¿  for(i=1; i<WAL_NREADER; i++){Ù'    u32 thisMark = pInfo->aReadMark[i];Ù4    if( mxReadMark<=thisMark && thisMark<=mxFrame ){Ù,      assert( thisMark!=READMARK_NOT_USED );¼      mxReadMark = thisMark;®      mxI = i;¥    }£  }Ù*  if( (pWal->readOnly & WAL_SHM_RDONLY)==0Ù$   && (mxReadMark<mxFrame || mxI==0)¤  ){Ù!    for(i=1; i<WAL_NREADER; i++){Ù7      rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);º      if( rc==SQLITE_OK ){Ù3        mxReadMark = pInfo->aReadMark[i] = mxFrame;°        mxI = i;Ù6        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);®        break;Ù"      }else if( rc!=SQLITE_BUSY ){²        return rc;§      }¥    }£  }¯  if( mxI==0 ){ÙF    assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );ÙB    return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;£  } Ù/  rc = walLockShared(pWal, WAL_READ_LOCK(mxI));«  if( rc ){Ù,    return rc==SQLITE_BUSY ? WAL_RETRY : rc;£  }ÙE  /* Now that the read-lock has been obtained, check that neither theÙD  ** value in the aReadMark[] array or the contents of the wal-index¹  ** header have changed.¤  **ÙF  ** It is necessary to check that the wal-index header did not changeÙG  ** between the time it was read and when the shared-lock was obtainedÙF  ** on WAL_READ_LOCK(mxI) was obtained to account for the possibilityÙH  ** that the log file may have been wrapped by a writer, or that framesÙE  ** that occur later in the log than pWal->hdr.mxFrame may have beenÙJ  ** copied into the database by a checkpointer. If either of these thingsÙB  ** happened, then reading the database with the current value ofÙD  ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry­  ** instead.¤  **ÙC  ** Before checking that the live wal-index header has not changedÙF  ** since it was read, set Wal.minFrame to the first frame in the walÙG  ** file that has not yet been checkpointed. This client will not needÙF  ** to read any frames earlier than minFrame from the wal file - theyÙ8  ** can be safely read directly from the database file.¤  **ÙD  ** Because a ShmBarrier() call is made between taking the copy of ÙF  ** nBackfill and checking that the wal-header in shared-memory stillÙD  ** matches the one cached in pWal->hdr, it is guaranteed that the ÙE  ** checkpointer that set nBackfill was not working with a wal-indexÙG  ** header newer than that cached in pWal->hdr. If it were, that couldÙ?  ** cause a problem. The checkpointer could omit to checkpointÙK  ** a version of page X that lies before pWal->minFrame (call that versionÙJ  ** A) on the basis that there is a newer version (version B) of the sameÙF  ** page later in the wal file. But if version B happens to like pastÙG  ** frame pWal->hdr.mxFrame - then the client would incorrectly assumeÙF  ** that it can read version A from the database file. However, sinceÙH  ** we can guarantee that the checkpointer that set nBackfill could notÙI  ** see any pages past pWal->hdr.mxFrame, this problem does not come up.¤  */Ù&  pWal->minFrame = pInfo->nBackfill+1;¶  walShmBarrier(pWal);Ù'  if( pInfo->aReadMark[mxI]!=mxReadMarkÙH   || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))¤  ){Ù.    walUnlockShared(pWal, WAL_READ_LOCK(mxI));µ    return WAL_RETRY;¨  }else{Ù,    assert( mxReadMark<=pWal->hdr.mxFrame );¾    pWal->readLock = (i16)mxI;£  }¬  return rc;¡} ½#ifdef SQLITE_ENABLE_SNAPSHOT¢/*ÙE** Attempt to reduce the value of the WalCkptInfo.nBackfillAttempted ÙE** variable so that older snapshots can be accessed. To do this, loopÙD** through all wal frames from nBackfillAttempted to (nBackfill+1), ÙF** comparing their content to the corresponding page with the databaseÙB** file, if any. Set nBackfillAttempted to the frame number of theÙB** first frame for which the wal file content matches the db file.¢**ÙE** This is only really safe if the file-system is such that any page ÙF** writes made by earlier checkpointers were atomic operations, which ÙB** is not always true. It is also possible that nBackfillAttemptedÙB** may be left set to a value larger than expected, if a wal frameÙD** contains content that duplicate of an earlier version of the same¨** page.¢**ÙE** SQLITE_OK is returned if successful, or an SQLite error code if anÙC** error occurs. It is not an error if nBackfillAttempted cannot be´** decreased at all.¢*/Ù8SQLITE_PRIVATE int sqlite3WalSnapshotRecover(Wal *pWal){©  int rc; ¾  assert( pWal->readLock>=0 );Ù0  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);¶  if( rc==SQLITE_OK ){Ù4    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);Ù#    int szPage = (int)pWal->szPage;Ù>    i64 szDb;                   /* Size of db file in bytes */ Ù/    rc = sqlite3OsFileSize(pWal->pDbFd, &szDb);¸    if( rc==SQLITE_OK ){Ù+      void *pBuf1 = sqlite3_malloc(szPage);Ù+      void *pBuf2 = sqlite3_malloc(szPage);Ù!      if( pBuf1==0 || pBuf2==0 ){º        rc = SQLITE_NOMEM;¬      }else{Ù*        u32 i = pInfo->nBackfillAttempted;ÙB        for(i=pInfo->nBackfillAttempted; i>pInfo->nBackfill; i--){Ù"          volatile ht_slot *dummy;Ù?          volatile u32 *aPgno;      /* Array of page numbers */ÙI          u32 iZero;                /* Frame corresponding to aPgno[0] */Ù@          u32 pgno;                 /* Page number in db file */ÙA          i64 iDbOff;               /* Offset of db file entry */ÙB          i64 iWalOff;              /* Offset of wal file entry */ ÙI          rc = walHashGet(pWal, walFramePage(i), &dummy, &aPgno, &iZero);Ù$          if( rc!=SQLITE_OK ) break;Ù           pgno = aPgno[i-iZero];Ù*          iDbOff = (i64)(pgno-1) * szPage; Ù$          if( iDbOff+szPage<=szDb ){ÙD            iWalOff = walFrameOffset(i, szPage) + WAL_FRAME_HDRSIZE;ÙE            rc = sqlite3OsRead(pWal->pWalFd, pBuf1, szPage, iWalOff); Ù             if( rc==SQLITE_OK ){ÙE              rc = sqlite3OsRead(pWal->pDbFd, pBuf2, szPage, iDbOff);­            } ÙC            if( rc!=SQLITE_OK || 0==memcmp(pBuf1, pBuf2, szPage) ){´              break;­            }«          } Ù*          pInfo->nBackfillAttempted = i-1;©        }§      } º      sqlite3_free(pBuf1);º      sqlite3_free(pBuf2);¥    }Ù/    walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);£  } ¬  return rc;¡}Ù##endif /* SQLITE_ENABLE_SNAPSHOT */ ¢/*Ù,** Begin a read transaction on the database.¢**ÙM** This routine used to be called sqlite3OpenSnapshot() and with good reason:ÙL** it takes a snapshot of the state of the WAL and wal-index for the currentÙK** instant in time.  The current thread will continue to use this snapshot.ÙF** Other threads might append new content to the WAL and wal-index butÙ7** that extra content is ignored by the current thread.¢**Ù@** If the database contents have changes since the previous readÙA** transaction, then *pChanged is set to 1 before returning.  TheÙ?** Pager layer will use this to know that is cache is stale and·** needs to be flushed.¢*/ÙLSQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){Ù3  int rc;                         /* Return code */ÙG  int cnt = 0;                    /* Number of TryBeginRead attempts */ ½#ifdef SQLITE_ENABLE_SNAPSHOT³  int bChanged = 0;Ù+  WalIndexHdr *pSnapshot = pWal->pSnapshot;ÙK  if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){±    bChanged = 1;£  }¦#endif ¥  do{Ù3    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);º  }while( rc==WAL_RETRY );Ù%  testcase( (rc&0xff)==SQLITE_BUSY );Ù&  testcase( (rc&0xff)==SQLITE_IOERR );Ù"  testcase( rc==SQLITE_PROTOCOL );¼  testcase( rc==SQLITE_OK ); ½#ifdef SQLITE_ENABLE_SNAPSHOT¶  if( rc==SQLITE_OK ){ÙM    if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){ÙK      /* At this point the client has a lock on an aReadMark[] slot holdingÙK      ** a value equal to or smaller than pSnapshot->mxFrame, but pWal->hdrÙI      ** is populated with the wal-index header corresponding to the headÙE      ** of the wal file. Verify that pSnapshot is still valid beforeÙE      ** continuing.  Reasons why pSnapshot might no longer be valid:¨      **ÙJ      **    (1)  The WAL file has been reset since the snapshot was taken.Ù:      **         In this case, the salt will have changed.¨      **ÙF      **    (2)  A checkpoint as been attempted that wrote frames pastÙJ      **         pSnapshot->mxFrame into the database file.  Note that theÙO      **         checkpoint need not have completed for this to cause problems.¨      */Ù6      volatile WalCkptInfo *pInfo = walCkptInfo(pWal); Ù9      assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );ÙE      assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame ); ÙD      /* It is possible that there is a checkpointer thread running ÙK      ** concurrent with this code. If this is the case, it may be that theÙE      ** checkpointer has already determined that it will checkpoint ÙJ      ** snapshot X, where X is later in the wal file than pSnapshot, but ÙL      ** has not yet set the pInfo->nBackfillAttempted variable to indicate ÙK      ** its intent. To avoid the race condition this leads to, ensure thatÙG      ** there is no checkpointer process by taking a shared CKPT lock Ù5      ** before checking pInfo->nBackfillAttempted.  ¨      **ÙJ      ** TODO: Does the aReadMark[] lock prevent a checkpointer from doing¼      **       this already?¨      */Ù.      rc = walLockShared(pWal, WAL_CKPT_LOCK); º      if( rc==SQLITE_OK ){ÙM        /* Check that the wal file has not been wrapped. Assuming that it hasÙO        ** not, also check that no checkpointer has attempted to checkpoint anyÙN        ** frames beyond pSnapshot->mxFrame. If either of these conditions areÙL        ** true, return SQLITE_BUSY_SNAPSHOT. Otherwise, overwrite pWal->hdrÙK        ** with *pSnapshot and set *pChanged as appropriate for opening the¸        ** snapshot.  */ÙO        if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))Ù9         && pSnapshot->mxFrame>=pInfo->nBackfillAttemptedª        ){Ù%          assert( pWal->readLock>0 );Ù=          memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));¿          *pChanged = bChanged;®        }else{Ù$          rc = SQLITE_BUSY_SNAPSHOT;©        } Ù:        /* Release the shared CKPT lock obtained above. */Ù-        walUnlockShared(pWal, WAL_CKPT_LOCK);§      }  º      if( rc!=SQLITE_OK ){Ù+        sqlite3WalEndReadTransaction(pWal);§      }¥    }£  }¦#endif¬  return rc;¡} ¢/*Ù@** Finish with a read transaction.  All this does is release the­** read-lock.¢*/Ù<SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal){Ù&  sqlite3WalEndWriteTransaction(pWal);º  if( pWal->readLock>=0 ){Ù9    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));¸    pWal->readLock = -1;£  }¡} ¢/*ÙM** Search the wal file for page pgno. If found, set *piRead to the frame thatÙL** contains the page. Otherwise, if pgno is not in the wal file, set *piRead«** to zero.¢**ÙM** Return SQLITE_OK if successful, or an error code if an error occurs. If anÙ=** error does occur, the final value of *piRead is undefined.¢*/Ù'SQLITE_PRIVATE int sqlite3WalFindFrame(Ù2  Wal *pWal,                      /* WAL handle */ÙM  Pgno pgno,                      /* Database page number to read data for */ÙC  u32 *piRead                     /* OUT: Frame number (or zero) */¢){ÙM  u32 iRead = 0;                  /* If !=0, WAL frame to return data from */ÙH  u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */ÙJ  int iHash;                      /* Used to loop through N hash tables */¯  int iMinHash; ÙF  /* This routine is only be called from within a read transaction. */Ù1  assert( pWal->readLock>=0 || pWal->lockError ); ÙI  /* If the "last page" field of the wal-index header snapshot is 0, thenÙL  ** no data will be read from the wal under any circumstances. Return earlyÙG  ** in this case as an optimization.  Likewise, if pWal->readLock==0, ÙF  ** then the WAL is ignored by the reader so return early, as if the ´  ** WAL were empty.¤  */ÙC  if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){°    *piRead = 0;µ    return SQLITE_OK;£  } ÙF  /* Search the hash table or tables for an entry matching page numberÙB  ** pgno. Each iteration of the following for() loop searches oneÙG  ** hash table (each hash table indexes up to HASHTABLE_NPAGE frames).¤  **ÙE  ** This code might run concurrently to the code in walIndexAppend()ÙC  ** that adds entries to the wal-index (and possibly to this hash Ù:  ** table). This means the value just read from the hash Ù@  ** slot (aHash[iKey]) may have been added before or after the Ù@  ** current read transaction was opened. Values added after theÙD  ** read transaction was opened may have been written incorrectly -ÙB  ** i.e. these slots may contain garbage data. However, we assumeÙC  ** that any slots written before the current read transaction was¾  ** opened remain unmodified.¤  **ÙG  ** For the reasons above, the if(...) condition featured in the innerÙJ  ** loop of the following block is more stringent that would be required Ù2  ** if we had exclusive access to the hash-table:¤  **¾  **   (aPgno[iFrame]==pgno): ÙA  **     This condition filters out normal hash-table collisions.¤  **¸  **   (iFrame<=iLast): ÙG  **     This condition filters out entries that were added to the hashÙ>  **     table after the current read-transaction had started.¤  */Ù*  iMinHash = walFramePage(pWal->minFrame);Ù;  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){Ù=    volatile ht_slot *aHash;      /* Pointer to hash table */ÙH    volatile u32 *aPgno;          /* Pointer to array of page numbers */ÙN    u32 iZero;                    /* Frame number corresponding to aPgno[0] */Ù7    int iKey;                     /* Hash slot index */ÙK    int nCollide;                 /* Number of hash collisions remaining */Ù2    int rc;                       /* Error code */ Ù9    rc = walHashGet(pWal, iHash, &aHash, &aPgno, &iZero);¸    if( rc!=SQLITE_OK ){°      return rc;¥    }¿    nCollide = HASHTABLE_NSLOT;ÙA    for(iKey=walHash(pgno); aHash[iKey]; iKey=walNextHash(iKey)){Ù'      u32 iFrame = aHash[iKey] + iZero;ÙP      if( iFrame<=iLast && iFrame>=pWal->minFrame && aPgno[aHash[iKey]]==pgno ){Ù-        assert( iFrame>iRead || CORRUPT_DB );·        iRead = iFrame;§      }¼      if( (nCollide--)==0 ){Ù#        return SQLITE_CORRUPT_BKPT;§      }¥    }¶    if( iRead ) break;£  } Ù%#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERTÙG  /* If expensive assert() statements are available, do a linear searchÙH  ** of the wal-index file content. Make sure the results agree with theÙ6  ** result obtained using the hash indexes above.  */£  {³    u32 iRead2 = 0;®    u32 iTest;Ù7    assert( pWal->bShmUnreliable || pWal->minFrame>0 );Ù@    for(iTest=iLast; iTest>=pWal->minFrame && iTest>0; iTest--){Ù,      if( walFramePgno(pWal, iTest)==pgno ){·        iRead2 = iTest;®        break;§      }¥    }¼    assert( iRead==iRead2 );£  }¦#endif ²  *piRead = iRead;³  return SQLITE_OK;¡} ¢/*ÙF** Read the contents of frame iRead from the wal file into buffer pOutÙG** (which is nOut bytes in size). Return SQLITE_OK if successful, or an¸** error code otherwise.¢*/Ù'SQLITE_PRIVATE int sqlite3WalReadFrame(Ù2  Wal *pWal,                      /* WAL handle */Ù5  u32 iRead,                      /* Frame to read */ÙD  int nOut,                       /* Size of buffer pOut in bytes */ÙD  u8 *pOut                        /* Buffer to write page data to */¢){©  int sz;®  i64 iOffset;¸  sz = pWal->hdr.szPage;Ù'  sz = (sz&0xfe00) + ((sz&0x0001)<<16);¸  testcase( sz<=32768 );¸  testcase( sz>=65536 );Ù:  iOffset = walFrameOffset(iRead, sz) + WAL_FRAME_HDRSIZE;Ù?  /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */ÙK  return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset);¡} £/* ÙB** Return the size of the database in pages (or zero, if unknown).¢*/Ù0SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal){Ù*  if( pWal && ALWAYS(pWal->readLock>=0) ){»    return pWal->hdr.nPage;£  }«  return 0;¡}  £/* Ù7** This function starts a write transaction on the WAL.¢**ÙD** A read transaction must have already been started by a prior callÙ'** to sqlite3WalBeginReadTransaction().¢**ÙC** If another thread or process has written into the database sinceÙE** the read transaction was started, then it is not possible for thisÙC** thread to write as doing so would cause a fork.  So this routineÙH** returns SQLITE_BUSY in that case and no write transaction is started.¢**Ù6** There can only be a single writer active at a time.¢*/Ù>SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){©  int rc; ÙB  /* Cannot start a write transaction without first holding a read´  ** transaction. */¾  assert( pWal->readLock>=0 );Ù4  assert( pWal->writeLock==0 && pWal->iReCksum==0 ); ·  if( pWal->readOnly ){»    return SQLITE_READONLY;£  } ÙD  /* Only one writer allowed at a time.  Get the write lock.  Return»  ** SQLITE_BUSY if unable.¤  */Ù1  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);«  if( rc ){®    return rc;£  }¶  pWal->writeLock = 1; ÙE  /* If another connection has written to the database file since theÙC  ** time the read transaction on this connection was started, then½  ** the write is disallowed.¤  */ÙN  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){Ù0    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);¸    pWal->writeLock = 0;¾    rc = SQLITE_BUSY_SNAPSHOT;£  } ¬  return rc;¡} ¢/*ÙD** End a write transaction.  The commit has already been done.  ThisÙ$** routine merely releases the lock.¢*/Ù<SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal){¸  if( pWal->writeLock ){Ù0    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);¸    pWal->writeLock = 0;·    pWal->iReCksum = 0;¿    pWal->truncateOnCommit = 0;£  }³  return SQLITE_OK;¡} ¢/*ÙI** If any data has been written (but not committed) to the log file, thisÙI** function moves the write-pointer back to the start of the transaction.¢**ÙH** Additionally, the callback function is invoked for each frame writtenÙI** to the WAL since the start of the transaction. If the callback returnsÙF** other than SQLITE_OK, it is not invoked again and the error code isº** returned to the caller.¢**ÙE** Otherwise, if the callback function does not return an error, this¾** function returns SQLITE_OK.¢*/ÙYSQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){µ  int rc = SQLITE_OK;Ù   if( ALWAYS(pWal->writeLock) ){Ù"    Pgno iMax = pWal->hdr.mxFrame;°    Pgno iFrame;¢  ÙH    /* Restore the clients cache of the wal-index header to the state itÙ?    ** was in before the client began writing to the database. ¦    */ÙG    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr)); Ù$    for(iFrame=pWal->hdr.mxFrame+1; Ù/        ALWAYS(rc==SQLITE_OK) && iFrame<=iMax; °        iFrame++¦    ){ÙI      /* This call cannot fail. Unless the page for which the page numberÙB      ** is passed as the second argument is (a) in the cache and ÙG      ** (b) has an outstanding reference, then xUndo is either a no-opÙK      ** (if (a) is false) or simply expels the page from the cache (if (b)³      ** is false).¨      **ÙL      ** If the upper layer is doing a rollback, it is guaranteed that thereÙI      ** are no outstanding references to any page other than page 1. AndÙD      ** page 1 is never written to the log until the transaction isÙ@      ** committed. As a result, the call to xUndo may not fail.¨      */Ù.      assert( walFramePgno(pWal, iFrame)!=1 );Ù7      rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));¥    }Ù7    if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);£  }¬  return rc;¡} £/* ÙG** Argument aWalData must point to an array of WAL_SAVEPOINT_NDATA u32 ÙE** values. This function populates the array with values required to ÙG** "rollback" the write position of the WAL handle back to the current ÙG** point in the event of a savepoint rollback (via WalSavepointUndo()).¢*/ÙBSQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){¼  assert( pWal->writeLock );Ù"  aWalData[0] = pWal->hdr.mxFrame;Ù)  aWalData[1] = pWal->hdr.aFrameCksum[0];Ù)  aWalData[2] = pWal->hdr.aFrameCksum[1];¼  aWalData[3] = pWal->nCkpt;¡} £/* ÙE** Move the write position of the WAL back to the point identified byÙF** the values in the aWalData[] array. aWalData must point to an arrayÙG** of WAL_SAVEPOINT_NDATA u32 values that has been previously populated¿** by a call to WalSavepoint().¢*/ÙESQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){µ  int rc = SQLITE_OK; ¼  assert( pWal->writeLock );ÙG  assert( aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame ); Ù!  if( aWalData[3]!=pWal->nCkpt ){ÙH    /* This savepoint was opened immediately after the write-transactionÙG    ** was started. Right after that, the writer decided to wrap aroundÙE    ** to the start of the log. Update the savepoint values to match.¦    */´    aWalData[0] = 0;¾    aWalData[3] = pWal->nCkpt;£  } Ù&  if( aWalData[0]<pWal->hdr.mxFrame ){Ù$    pWal->hdr.mxFrame = aWalData[0];Ù+    pWal->hdr.aFrameCksum[0] = aWalData[1];Ù+    pWal->hdr.aFrameCksum[1] = aWalData[2];¹    walCleanupHash(pWal);£  } ¬  return rc;¡} ¢/*ÙI** This function is called just before writing a set of frames to the logÙK** file (see sqlite3WalFrames()). It checks to see if, instead of appendingÙH** to the current log file, it is possible to overwrite the start of theÙG** existing log file with the new frames (i.e. "reset" the log). If so,ÙG** it sets pWal->hdr.mxFrame to 0. Otherwise, pWal->hdr.mxFrame is left­** unchanged.¢**ÙJ** SQLITE_OK is returned if no error is encountered (regardless of whetherÙJ** or not pWal->hdr.mxFrame is modified). An SQLite error code is returned¶** if an error occurs.¢*/Ù$static int walRestartLog(Wal *pWal){µ  int rc = SQLITE_OK;ª  int cnt; º  if( pWal->readLock==0 ){Ù4    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);Ù2    assert( pInfo->nBackfill==pWal->hdr.mxFrame );½    if( pInfo->nBackfill>0 ){°      u32 salt1;Ù$      sqlite3_randomness(4, &salt1);ÙC      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);º      if( rc==SQLITE_OK ){ÙJ        /* If all readers are using WAL_READ_LOCK(0) (in other words if noÙF        ** readers are currently using the WAL), then the transactionsÙJ        ** frames will overwrite the start of the existing log. Update theÙ,        ** wal-index header to reflect this.ª        **ÙJ        ** In theory it would be Ok to update the cache of the header onlyÙJ        ** at this point. But updating the actual wal-index header is alsoÙG        ** safe and means there is no special case for sqlite3WalUndo()Ù<        ** to handle if this transaction is rolled back.  */Ù#        walRestartHdr(pWal, salt1);ÙB        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);Ù"      }else if( rc!=SQLITE_BUSY ){²        return rc;§      }¥    }Ù,    walUnlockShared(pWal, WAL_READ_LOCK(0));¸    pWal->readLock = -1;¬    cnt = 0;§    do{²      int notUsed;Ù5      rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);¼    }while( rc==WAL_RETRY );ÙL    assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */Ù(    testcase( (rc&0xff)==SQLITE_IOERR );Ù$    testcase( rc==SQLITE_PROTOCOL );¾    testcase( rc==SQLITE_OK );£  }¬  return rc;¡} ¢/*Ù@** Information about the current state of the WAL file and whereÙD** the next fsync should occur - passed from sqlite3WalFrames() into³** walWriteToLog().¢*/ºtypedef struct WalWriter {ÙA  Wal *pWal;                   /* The complete WAL information */ÙC  sqlite3_file *pFd;           /* The WAL file to which we write */Ù9  sqlite3_int64 iSyncPoint;    /* Fsync at this offset */Ù8  int syncFlags;               /* Flags for the fsync */Ù5  int szPage;                  /* Size of one page */¬} WalWriter; ¢/*ÙF** Write iAmt bytes of content into the WAL file beginning at iOffset.Ù6** Do a sync when crossing the p->iSyncPoint boundary.¢**ÙH** In other words, if iSyncPoint is in between iOffset and iOffset+iAmt,ÙD** first write the part before iSyncPoint, then sync, then write the¨** rest.¢*/¹static int walWriteToLog(Ù2  WalWriter *p,              /* WAL to write to */Ù8  void *pContent,            /* Content to be written */Ù;  int iAmt,                  /* Number of bytes to write */Ù?  sqlite3_int64 iOffset      /* Start writing at this offset */¢){©  int rc;Ù=  if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){Ù3    int iFirstAmt = (int)(p->iSyncPoint - iOffset);Ù>    rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);·    if( rc ) return rc;¹    iOffset += iFirstAmt;¶    iAmt -= iFirstAmt;Ù4    pContent = (void*)(iFirstAmt + (char*)pContent);Ù.    assert( WAL_SYNC_FLAGS(p->syncFlags)!=0 );Ù=    rc = sqlite3OsSync(p->pFd, WAL_SYNC_FLAGS(p->syncFlags));Ù"    if( iAmt==0 || rc ) return rc;£  }Ù7  rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);¬  return rc;¡} ¢/*Ù&** Write out a single frame of the WAL 